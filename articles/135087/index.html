<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic programming in speech recognition algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In speech recognition systems that contain words, recognition requires a comparison between the input word and the various words in the dictionary. Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic programming in speech recognition algorithms</h1><div class="post__text post__text-html js-mediator-article">  In speech recognition systems that contain words, recognition requires a comparison between the input word and the various words in the dictionary.  The effective solution of the problem lies in the dynamic comparison algorithms, the purpose of which is to introduce the time scales of two words into optimal correspondence.  Algorithms of this type are dynamic timeline transformation algorithms.  This article presents two variants of the implementation of the algorithm designed to recognize individual words. <br><br><a name="habracut"></a><h4>  Introduction </h4><br><br>  Studies in the field of speech recognition, as well as in other areas, follow two directions: fundamental research, the purpose of which is to develop and test new methods, algorithms and concepts on a non-commercial basis;  and applied research, which aims to improve existing methods by following certain criteria.  This article discusses the recognition of individual words in the trend of applied research. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Basic research is aimed at obtaining a medium or long-term benefit, while applied research is aimed at rapidly improving existing methods or expanding their use in areas where such methods are practically not used. <br><br>  Improving the speed of speech recognition can be given the following criteria: <br><ul><li>  The size of recognizable vocabulary; </li><li>  The degree of spontaneity of speech that must be recognized; </li><li>  Addiction / independence from announcer; </li><li>  The time required to set the system in motion; </li><li>  System adjustment time for new users; </li><li>  Time selection and recognition; </li><li>  The degree of recognition (expressed by word or sentence). </li></ul><br><br>  Today, sound recognition systems are built on the basis of the recognition principles of recognition forms.  The methods and algorithms that have been used so far can be divided into four large classes: <br>  Discriminative analysis methods based on Bayesian discrimination; <br>  Hidden Markov models; <br>  Dynamic programming - temporary dynamic algorithms (DTW); <br>  Neural networks; <br><br>  This article provides an example and alternative to the DTW dynamic programming algorithm that implements speech recognition. <br><br>  Dynamic Time Transformation Algorithm (DTW) <br><br>  The dynamic time transformation (DTW) algorithm calculates the optimal sequence of time transformation (deformation) between two time series.  The algorithm calculates both strain values ‚Äã‚Äãbetween two rows and the distance between them. <br><br>  Suppose we have two numerical sequences (a1, a2, ..., an) and (b1, b2, ..., bm).  As you can see, the length of the two sequences may be different.  The algorithm begins with calculating local deviations between elements of two sequences that use different types of deviations.  The most common method for calculating deviations is the method that calculates the absolute deviation between the values ‚Äã‚Äãof two elements (Euclidean distance).  As a result, we obtain a deviation matrix with n rows and m columns of common members: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/9ae/209/4449ae209feecfd0cb3fec3ef2e4a5f8.jpg" alt="image"><br><br>  The minimum distance in the matrix between the sequences is determined using a dynamic programming algorithm and the following optimization criterion: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/03c/ae9/32703cae9382bcc0f05804f06932e65a.jpg" alt="image"><br><br>  where: aij is the minimum distance between the sequences (a1, a2, ..., an) and (b1, b2, ..., bm).  The deformation path is the minimum distance in the matrix between the elements a11 and anm, consisting of those aij elements that express the distance to anm. <br><br>  Global deformations consist of two sequences and are determined by the following formula: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/97d/029/e5f97d0298ed549a33bd15ae00265a92.jpg" alt="image"><br><br>  where: wi - elements that belong to the strain path;  p is their number.  The calculations were made for two short sequences and are shown in the table in which the strain sequence is highlighted. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/572/9a5/b26/5729a5b26ee0e13dd4f7210402048856.jpg" alt="image"><br><br>  There are three conditions imposed on the DTW algorithm to ensure fast convergence: <br><br>  1. Monotonicity - the path never returns, that is: both indices, i and j, which are used in a sequence, never decrease. <br><br>  2. Continuity - the sequence advances gradually: in one step, the indices, i and j, increase by no more than 1. <br><br>  3. Limit - the sequence begins in the lower left corner and ends in the upper right. <br><br>  An example of sequence deformation using the Java programming language is shown below: <br><br><pre> <code class="hljs markdown"><code class="java">public static void dtw(double a[<span class="hljs-string"></span><span class="hljs-string"></span>],double b[<span class="hljs-string"></span><span class="hljs-string"></span>],double dw[<span class="hljs-string"></span><span class="hljs-string"></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>], Stack<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Double</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> w){ // a,b - the sequences, dw - the minimal distances matrix // w - the warping path int n=a.length,m=b.length; double d[<span class="hljs-string"></span><span class="hljs-string"></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>]=new double[<span class="hljs-string"><span class="hljs-string">n</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">m</span></span>]; // the euclidian distances matrix for(int i=0;i<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">n;i++)</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;j</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m</span></span></span></span><span class="xml"><span class="hljs-tag">;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">++)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">d</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">Math.abs(a[i]-b[j]);</span></span></span></span><span class="xml"><span class="hljs-tag"> // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">determinate</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">of</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">minimal</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">distance</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[0][0];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1;i</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[i][0]+dw[i-1][0];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1;j</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m</span></span></span></span><span class="xml"><span class="hljs-tag">;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">++)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[0][j]+dw[0][j-1];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1;i</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1;j</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m</span></span></span></span><span class="xml"><span class="hljs-tag">;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">++) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i-1</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j-1</span></span></span></span><span class="xml"><span class="hljs-tag">]&lt;=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">dw[i-1][j])</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i-1</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j-1</span></span></span></span><span class="xml"><span class="hljs-tag">]&lt;=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">dw[i][j-1])dw[i][j]</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[i][j]+dw[i-1][j-1];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[i][j]+dw[i][j-1];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i-1</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">]&lt;=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">dw[i][j-1])dw[i][j]</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[i][j]+dw[i-1][j];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[i][j]+dw[i][j-1];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">n-1,j</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">m-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">double</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">element</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">dw[i][j];</span></span></span></span><span class="xml"><span class="hljs-tag"> // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">determinate</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">of</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">warping</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">w.push</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">new</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Double</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">])); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">do</span></span></span></span><span class="xml"><span class="hljs-tag">{ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>0&amp;&amp;j&gt;0) if(dw[<span class="hljs-string"><span class="hljs-string">i-1</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">j-1</span></span>]<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=dw[i-1][j])</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i-1</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j-1</span></span></span></span><span class="xml"><span class="hljs-tag">]&lt;=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">dw[i][j-1]){i--;j--;}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j--</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i-1</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">]&lt;=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">dw[i][j-1])i--;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j--</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">==</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0)j--;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i--</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">w.push</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">new</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Double</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dw</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">])); } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">while</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">!=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0||j!</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0);</span></span></span></span><span class="xml"><span class="hljs-tag"> }</span></span></span></span></code></code> </pre><br>  Since to determine the basis of a sequence in dynamic programming, it is optimal to use the inverse programming method, it is necessary to use a certain dynamic type of structure called a ‚Äústack‚Äù.  Like any dynamic programming algorithm, DWT has a polynomial complexity.  When we deal with large sequences, there are two disadvantages: <br>  - Memorization of large numeric matrices; <br>  - Perform a large number of calculations of deviations. <br><br>  There is an improved version of the algorithm, FastDWT, which solves the above two problems.  The solution is to split the state matrix into 2, 4, 8, 16, etc.  smaller matrices by repeating the process of splitting the input sequence into two parts.  Thus, deviations are calculated only on these small matrices, and the deformation paths calculated for small matrices.  From the algorithmic point of view, the proposed solution is based on the ‚ÄúDivide et Impera‚Äù method (approx. Trans. From the Latin. ‚ÄúDivide and dominate‚Äù). <br><br><h4>  Using DWT Algorithm in Speech Recognition </h4><br><br><h5>  Voice Signal Analysis </h5><br><br>  The sound passes through the medium, as a longitudinal wave with a velocity depending on the density of the medium.  The easiest way to present sounds is a sine graph.  Graphic representation of the air vibrations under pressure for some time. <br><br>  The shape of the sound wave depends on three factors: aplitude, frequency, and phase. <br><br>  Amplitude is the movement of sinusoidal graphs above and below the time axis (y = 0), which corresponds to the energy of the loaded sound wave.  Amplitude measurements can be made in pressure units (DB decibels), which measure the amplitude of normal sound using logarithmic functions.  Measuring amplitude using decibels is very important in practice, as it is a direct idea of ‚Äã‚Äãhow the sound volume is perceived by people.  Frequency - the number of sinusoid cycles per second.  The cycle of oscillations begins with the middle line, then reaches a maximum and a minimum, and then returns to the middle line.  The cycle frequency is measured in one second or in hertz (Hz).  The inverse of the frequency is called the period - the time required for the sound wave to complete the cycle. <br><br>  The last factor is the phase.  It measures the position relative to the start of the sine curve.  A phase cannot be heard by a person, but it can be defined relative to the position between two signals.  However, the hearing aid perceives the position of the sound on different phases. <br><br>  In order to parse the sound waves on a sinusoidal curve, we use the Fourier theorem.  It states that any complex periodic wave can be disassembled using a sinusoidal curve with different frequencies, amplitudes and phases.  This process is called Fourier analysis, and its result is a set of amplitudes, phases and frequencies for each sinusoidal wave component.  Putting these sinusoidal curves together, we get the original sound wave.  The point of frequency or phase taken together with amplitude is called a spectrum.  Any periodic signal indicates a recursive model of time, which corresponds to the first frequency of the signal and is called the fundamental frequency.  It can be measured from a speech signal by checking the period of oscillation around the 0 axis.  The spectrum shows the frequency of a short sequence of sounds, and if we want to analyze its development over time, you need to find a way to demonstrate this.  This can be shown on the spectrogram.  A spectrogram is a diagram in two dimensions: frequency and time, in which the color of a point (dark - strong, bright - weak) determines the amplitude of the intensity.  The method plays an important role in speech recognition, and a professional can reveal many details by looking only at the sound spectrogram. <br><br><h4>  Identify words </h4><br><br>  Modern detection methods can accurately determine the starting and ending point of the spoken word in the audio stream, based on signal processing that changes over time.  These methods estimate the energy and the average value in a short period of time, and also calculate the average level of zero crossing. <br><br>  Creating a start and end point is a simple task if the audio recording is done under ideal conditions.  In this case, the signal-to-noise ratio is great, since it is not difficult to determine the actual signal in the stream by analyzing the images.  In reality, everything is not so simple: the background noise is of tremendous intensity and can disrupt the process of separating words in a stream of speech. <br><br>  The best word separation algorithm is the Rabinel-Lamel algorithm.  If we consider Stob pulses {s1, s2, ..., sn}, where n is the number of strobe pulse images, and si, i = 1, n is the numerical expression of the samples, the total strobe pulse energy is calculated: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccd/54d/59a/ccd54d59a0ebbf30138c40aa55666c1e.jpg" alt="image"><br><br>  Middle level zero crossing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73b/a02/a99/73ba02a99d7e416e67f310ddbbeb828b.jpg" alt="image"><br><br>  Where: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8e/db7/2f3/f8edb72f34b66fc1a6b04224ecb59a93.jpg" alt="image"><br><br>  The method uses three numeric levels: two for energy (upper, lower) and one for the average zero crossing.  The point from which energy overlaps the upper level and the level of positive and negative values ‚Äã‚Äãdoes not cancel the set level, which is considered the starting point of the voice sound (not silence).  The search for the first such point is made by crossing the pulses from the beginning to the end, and this will determine the first area with speech.  The reverse transition, from end to beginning, allows you to determine the end point of the last area with the speech.  The definition within the region can be made by crossing the pulses between these two points.  The onset of the deaf region begins at the point at which the energy becomes less than the value of the lower level.  Pay attention to the figure below, in which before and after the removal of the blind area: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ec/1d4/f8a/9ec1d4f8ad99a2db0514856ee09d482f.jpg" alt="image"><br>  beep the words "nouƒÉ" <br><br>  Definition of words using the DWT algorithm <br><br>  The definition of a word can be done by comparing numerical waveforms or by comparing the spectrogram of signals.  The comparison process in both cases should compensate for the different sequence lengths and the non-linear nature of the sound.  The DWT algorithm manages to sort out these problems by finding the deformation corresponding to the optimal distance between two rows of different lengths. <br><br>  There are 2 features of the algorithm: <br><br>  1. Direct comparison of numerical waveforms.  In this case, for each numerical sequence, a new sequence is created, the dimensions of which are much smaller.  The algorithm deals with these sequences.  A numeric sequence can have several thousand numeric values, while a subsequence can have several hundred values.  Reducing the number of numerical values ‚Äã‚Äãcan be accomplished by removing them between the corner points.  This process of reducing the length of a numerical sequence should not change its presentation.  Undoubtedly, the process leads to a decrease in recognition accuracy.  However, taking into account the increase in speed, accuracy, in fact, is increased by increasing the words in the dictionary. <br><br>  2. Representation of spectrogram signals and application of the DTW algorithm for comparing two spectrograms.  The method consists in dividing a digital signal into a number of intervals that will overlap.  For each pulse, the intervals of real numbers (sound frequencies) will calculate the Fast Fourier Transform, and will be stored in the matrix of the sound spectrogram.  The parameters will be the same for all computational operations: pulse lengths, Fourier transform lengths, overlap lengths for two consecutive pulses.  The Fourier transform is symmetrically related to the center, and the complex number is on the one hand related to the numbers on the other.  In this regard, only the values ‚Äã‚Äãfrom the first part of the symmetry can be saved, so the spectrogram will represent the matrix of complex numbers, the number of lines in such a matrix is ‚Äã‚Äãequal to half the length of the Fourier transform, and the number of columns will be determined depending on the length of the sound.  DTW will be applied on the matrix of real numbers as a result of conjugation of the spectrogram of values, such a matrix is ‚Äã‚Äãcalled the energy matrix. <br><br><h4>  Conclusion </h4><br><br>  DTW algorithms are very useful for recognizing individual words in a limited vocabulary.  For recognition of fluent speech, hidden Markov models are used.  The use of dynamic programming provides the polymineral complexity of the algorithm: O (n2v), where n is the length of the sequence, and v is the number of words in the dictionary. <br>  DWT have several weaknesses.  First, O (n2v) complexity does not satisfy large dictionaries, which increase the success of the recognition process.  Secondly, it is difficult to calculate two elements in two different sequences, if we take into account that there are many channels with different characteristics.  However, DTW remains simple to implement, open to improvements and suitable for applications that require simple word recognition: telephones, car computers, security systems, etc. <br><br><h4>  Literature </h4><br><br>  [1] Benoit Legrand, CS Chang, SH Ong, Soek-Ying Neo, Nallasivam Palanisamy, Chromosome classification using dynamic time warping, ScienceDirect Pattern Recognition Letters 29 (2008) 215‚Äì222 <br>  [2] Cory Myers, Lawyers R. Rabiner, Aaron E. Rosenberg, Word Logging Recognition, Ieee Transactions On Acoustics, Speech, And Signal Processing, Vol.  Assp-28, No.  6, December 1980 <br>  [3] F. Jelinek.  ‚ÄúContinuous Speech Recognition by Statisical Methods.‚Äù IEEE Proceedings 64: 4 (1976): 532-556 <br>  [4] Rabiner, LR, A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition, Proc.  of IEEE, Feb.  1989 <br>  [5] Rabiner, LR, Schafer, RW, Digital Processing of Speech Signals, Prentice Hall, 1978. <br>  [6] Stan Salvador, Chan, FastDTW: Toward Accurate Dynamic Time Warping in Linear Time <br>  and Space, IEEE Transactions on Biomedical.  Engineering, vol.  43, no.  four <br>  [7] Young, S., A Review of Large-Vocabulary Continuous Speech Recognition, IEEE Signal <br>  Processing Magazine, pp.  45-57, Sep.  1996 <br>  [8] Sakoe, H. &amp; S. Chiba.  (1978) Dynamic programming optimization for spoken word recognition.  IEEE Trans.  Acoustics, Speech, and Signal Proc., Vol.  ASSP-26. <br>  [9] FurtunƒÉ, F., D√¢rdalƒÉ, M., Using Discriminant of the Fourth National Conference Humman Computer Interaction 2007, Universitatea Ovidius ConstanRa, 2007, MatrixRom, Bucharest, 2007 <br>  [10] * * *, Speech Separation by Humans, Kluwer Academic Publishers, 2005 <br><br>  article translation: <a href="http://revistaie.ase.ro/content/46/s%2520-%2520furtuna.pdf">Dynamic Programming Algorithms in Speech Recognition by Titus Felix FURTUNƒÇ</a> </div><p>Source: <a href="https://habr.com/ru/post/135087/">https://habr.com/ru/post/135087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135078/index.html">The meaning of social entrepreneurship (The Meaning of Social Entrepreneurship)</a></li>
<li><a href="../135082/index.html">Business analyst: ‚ÄúHow to write a list of system requirements correctly?‚Äù, Alistair Coburn, review part 1</a></li>
<li><a href="../135083/index.html">Shoes for real geeks</a></li>
<li><a href="../135084/index.html">Ruby on Rails is already at 3.2, the next station is 4.0.0.beta</a></li>
<li><a href="../135086/index.html">Prediction monitoring, potential crash alerts</a></li>
<li><a href="../135089/index.html">Autodaf√©</a></li>
<li><a href="../135090/index.html">Why do programmers work at night</a></li>
<li><a href="../135091/index.html">Very unusual presentation of the tablet</a></li>
<li><a href="../135092/index.html">Ads appear on Facebook news feed.</a></li>
<li><a href="../135095/index.html">Steve Jobs Wins Grammy Award</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>