<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Part 4.2. - Stencil Test</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once the fragment shader has processed the fragment, a so-called stencil test is performed, which, like the depth test, can discard fragments. Then th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Part 4.2. - Stencil Test</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" align="left" width="300"></p><br><p>  Once the fragment shader has processed the fragment, a so-called <strong>stencil test</strong> is performed, which, like the depth test, can discard fragments.  Then the remaining fragments go to the depth test, which, can discard even more fragments.  The stencil test is based on the contents of another buffer, called a <strong>stencil buffer</strong> .  We can update it during rendering to achieve interesting effects. </p><br><a name="habracut"></a><br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models <br><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li></ol></div></div><br><br><h1>  Stencil test </h1><br><p>  The stencil buffer usually contains 8 bits for each <strong>stencil value</strong> , which in total gives 256 different stencil values ‚Äã‚Äãper fragment / pixel.  We can set these values ‚Äã‚Äãto our taste, and then discard or save fragments, whenever a certain fragment has a certain pattern value. </p><br><blockquote><p>  Each window library should set up a stencil buffer for you.  GLFW does this automatically, so you don‚Äôt need to worry about it, but other window libraries can‚Äôt not create a default stencil buffer, so be sure to review your library‚Äôs documentation. </p></blockquote><br><p>  A simple example of a stencil buffer is shown below: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/42e/e30/5fe/42ee305fe97672535349f97a4cdefef8.png" alt="img">  First, the stencil buffer is filled with zeros, and then the buffer area, which looks like a rectangular frame, is filled with ones.  Only those fragments of the scene are displayed, the stencil value of which is equal to one, the rest are discarded. </p><br><p>  Stencil buffer operations allow us to set a different value for the stencil buffer where we display fragments.  By changing the stencil buffer values ‚Äã‚Äãduring rendering, we perform a <em>write</em> operation.  In the same (or next) rendering iteration, we can <em>read the</em> values ‚Äã‚Äãfrom the buffer in order to, based on the read values, discard or accept certain fragments.  Using a stencil buffer, you can fool around as you please, but the general scheme is: </p><br><ul><li>  Enable writing to the stencil buffer. </li><li>  Draw objects, update the contents of the stencil buffer. </li><li>  Disable writing to the stencil buffer. </li><li>  Draw (other) objects, this time discarding certain objects, based on the contents of the stencil buffer. </li></ul><br><p>  In summary, we can say that, using a stencil buffer, we can discard certain fragments based on fragments of other objects in the scene. </p><br><p> You can turn on stencil testing by turning on <code>GL_STENCIL_TEST</code> .  From this point on, all rendering calls will somehow affect the stencil buffer. </p><br><pre> <code class="cpp hljs">glEnable(GL_STENCIL_TEST);</code> </pre><br><p>  Note that you need to clear the stencil buffer at each iteration, as well as the color and depth buffer: </p><br><pre> <code class="cpp hljs">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</code> </pre><br><p>  For the stencil buffer, there is an analogue of the <code>glDepthMask</code> function used to parameterize the depth test.  The <code>glStencilMask</code> function allows us to set a bit mask that will participate in the bitwise AND operation with the stencil values ‚Äã‚Äãwritten to the buffer.  By default, the bitmask is equal to one, which does not affect the output, but if we set the mask to <code>0x00</code> , then all the stencil values ‚Äã‚Äãwould eventually be written as zeros.  The equivalent of setting the depth test mask for <code>glDepthMask(GL_FALSE)</code> would be the following pair of calls: </p><br><pre> <code class="cpp hljs">glStencilMask(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-comment"><span class="hljs-comment">//         glStencilMask(0x00); //        ( )</span></span></code> </pre><br><p>  In most cases, simply write <code>0x00</code> or <code>0xFF</code> to a stencil mask, but it would be nice to know that it is possible to set custom bitmasks. </p><br><h2>  Stencil functions </h2><br><p>  As well as in the depth test, we have a certain ability to control when the stencil test is passed, and when it is not, and how this should affect the stencil buffer.  We have only two functions that we can use to customize screen testing: <code>glStencilFunc</code> and <code>glStencilOp</code> . </p><br><p>  The <code>glStencilFunc(GLenum func, GLint ref, GLuint mask)</code> function <code>glStencilFunc(GLenum func, GLint ref, GLuint mask)</code> has three parameters: </p><br><ul><li>  <code>func</code> : sets the screening function.  This function is applied to the stored stencil value and the value of the <code>ref</code> parameter.  The options are: <code>GL_NEVER</code> , <code>GL_LESS</code> , <code>GL_LEQUAL</code> , <code>GL_GREATER</code> , <code>GL_GEQUAL</code> , <code>GL_EQUAL</code> , <code>GL_NOTEQUAL</code> and <code>GL_ALWAYS</code> .  The meaning of these functions is similar to the functions of the depth test. </li></ul><br><ul><li>  <code>ref</code> : Specifies the reference value for the stencil test.  The stencil buffer content is compared with this value. </li><li>  <code>mask</code> : sets the mask used in the bitwise AND operation with the stored and reference values ‚Äã‚Äãbefore comparing them.  The default is set to 1. </li></ul><br><p>  So, in the case of our simple stencil example, which we showed at the beginning, the function would be: </p><br><pre> <code class="cpp hljs">glStencilFunc(GL_EQUAL, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)</code> </pre><br><p>  This tells OpenGL that, whenever the stencil fragment value is equal to the reference value 1, the fragment passes the test and is drawn, otherwise it is discarded. </p><br><p>  But the <code>glStencilFunc</code> function <code>glStencilFunc</code> describes what OpenGL should do with the stencil buffer contents, not how we can refresh the buffer.  This is where <code>glStencilOp</code> comes to the <code>glStencilOp</code> . </p><br><p>  The <code>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</code> function <code>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</code> contains three parameters with which we can determine actions for each option: </p><br><ul><li>  <code>sfail</code> : action taken in case of stencil failure. </li><li>  <code>dpfail</code> : action taken when the stencil test is passed, but the depth test is not. </li><li>  <code>dppass</code> : action taken when both tests pass </li></ul><br><p>  Then, for each case, you can do one of the following: </p><br><table><thead><tr><th>  Act </th><th>  Description </th></tr></thead><tbody><tr><td> <code>GL_KEEP</code> </td> <td>  The currently stored stencil value is saved. </td></tr><tr><td> <code>GL_ZERO</code> </td> <td>  Stencil value is reset. </td></tr><tr><td> <code>GL_REPLACE</code> </td> <td>  The stencil value is replaced by the reference value set by <code>glStencilFunc</code> . </td></tr><tr><td> <code>GL_INCR</code> </td> <td>  The stencil value is incremented by one if it is less than the maximum value. </td></tr><tr><td> <code>GL_INCR_WRAP</code> </td> <td>  It behaves in the same way as <code>GL_INCR</code> , but when passing through the maximum, the value in the buffer is reset. </td></tr><tr><td> <code>GL_DECR</code> </td> <td>  The stencil value is reduced by one if it exceeds the minimum value. </td></tr><tr><td> <code>GL_DECR_WRAP</code> </td> <td>  It behaves in the same way as <code>GL_DECR</code> , but when going through 0, the value in the buffer is set to the maximum. </td></tr><tr><td> <code>GL_INVERT</code> </td> <td>  Bitwise inverts the current stencil buffer value. </td></tr></tbody></table><br><p>  By default, the arguments to <code>glStencilOp</code> are set to <code>(GL_KEEP, GL_KEEP, GL_KEEP)</code> , so that, regardless of the test results, the values ‚Äã‚Äãin the stencil buffer are saved.  Standard behavior does not update the stencil buffer, so if we want to write to the stencil buffer, we need to set at least one action different from the standard one for any variant. </p><br><p>  So, using <code>glStencilFunc</code> and <code>glStencilOp</code> we can set exactly when and how we want to update the stencil buffer, and we also determine when the stencil test will be passed, and when not - that is, when the fragments should be dropped. </p><br><h2>  Stroke objects </h2><br><p>  It is unlikely that you fully understood how screen testing works on the basis of the previous sections, so we will demonstrate a useful technique that can be implemented using screen testing.  This is a <em>stroke object</em> . </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/68b/888/26068b888be74dbc90b404ed327184b2.png" alt="circled cube"></div><br><p>  There is no need to explain what is meant by the stroke of the object.  For each object (or only for one) we create a small color frame.  This effect is especially useful when we, for example, need to select units in a strategic game, and then show the user which ones have been selected.  The algorithm for forming a stroke for an object is as follows: </p><br><ol><li>  Set the stencil function in <code>GL_ALWAYS</code> , before drawing the objects (which will be circled), update the stencil buffer with units where the fragments of the objects will be drawn. </li><li>  Draw objects. </li><li>  Disable depth testing and stencil buffer writing. </li><li>  Slightly enlarge each object. </li><li>  Use another fragmentary shader, which output only one color (the color of the stroke). </li><li>  Draw the object again, but only if the stencil value of their fragments is not equal to one. </li><li>  Re-enable stencil buffer entry and depth testing. </li></ol><br><p>  This process sets the buffer contents for each object fragment to unity, and when we want to draw borders, we essentially draw scalable versions of objects, and where the test allows, the scalable version is drawn (around the object borders).  Using the stencil test, we discard those fragments of scaled objects that are superimposed on the fragments of the original objects. </p><br><p>  First we create a very simple fragmentary shader that displays the color of the stroke.  We simply set the hard-coded color and call the <code>shaderSingleColor</code> shader: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.04</span></span>, <span class="hljs-number"><span class="hljs-number">0.28</span></span>, <span class="hljs-number"><span class="hljs-number">0.26</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br><p>  We plan to include a stroke for only two containers, but not for the floor.  Therefore, you first need to display the floor, then two containers (with writing to the stencil buffer), and then - enlarged versions of the containers (with rejection of fragments superimposed on the already drawn fragments of the original containers). </p><br><p>  First, we need to turn on stencil testing and set actions to be taken if any of the tests are successful or unsuccessful: </p><br><pre> <code class="cpp hljs">glEnable(GL_DEPTH_TEST); glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);</code> </pre><br><p>  If any of the tests fail, then we do nothing, but simply leave the current value in the stencil buffer.  If the stencil test and the depth test are passed successfully, then we replace the current stencil value with the reference value set via <code>glStencilFunc</code> , which we will later set to 1. </p><br><p>  The buffer is cleared by filling with zeros, and for containers we update the stencil buffer to 1 for each drawn fragment: </p><br><pre> <code class="cpp hljs">glStencilFunc(GL_ALWAYS, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      glStencilMask(0xFF); //      normalShader.use(); DrawTwoContainers();</span></span></code> </pre><br><p>  Using <code>GL_ALWAYS</code> in the <code>glStencilFunc</code> function <code>glStencilFunc</code> we ensure that each container fragment updates the stencil buffer with the stencil value 1. Since the fragments always pass the stencil test, the stencil buffer is updated with the reference value, everywhere we drew them. </p><br><p>  Now that the stencil buffer has been updated to one, where we painted the containers, we need to draw enlarged versions of the containers, but, now having turned off the recording in the stencil buffer: </p><br><pre> <code class="cpp hljs">glStencilFunc(GL_NOTEQUAL, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); glStencilMask(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      glDisable(GL_DEPTH_TEST); shaderSingleColor.use(); DrawTwoScaledUpContainers();</span></span></code> </pre><br><p>  We use the <code>GL_NOTEQUAL</code> argument in <code>glStencilFunc</code> , which guarantees that we draw only parts of objects that are not equal to one, so we draw only those parts of objects that are outside the previously drawn objects.  Note that we also turned off the depth test so that elements of enlarged containers, for example, their boundaries, are not overwritten by the floor. </p><br><p>  Also be sure to re-enable the depth test. </p><br><p>  The overall object stroke pattern for our scene looks something like this: </p><br><pre> <code class="cpp hljs">glEnable(GL_DEPTH_TEST); glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); glStencilMask(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,           normalShader.use(); DrawFloor() glStencilFunc(GL_ALWAYS, 1, 0xFF); glStencilMask(0xFF); DrawTwoContainers(); glStencilFunc(GL_NOTEQUAL, 1, 0xFF); glStencilMask(0x00); glDisable(GL_DEPTH_TEST); shaderSingleColor.use(); DrawTwoScaledUpContainers(); glStencilMask(0xFF); glEnable(GL_DEPTH_TEST);</span></span></code> </pre><br><p>  If you understand the general idea behind stencil testing, this piece of code should not be too complicated to understand.  Otherwise, try to carefully read the previous sections and fully understand what each function does, now that you have seen an example of its use. </p><br><p>  The result of applying the stroke algorithm to the scene from the <a href="https://habrahabr.ru/post/342610/">depth test</a> lesson looks like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/185/921/eef/185921eefb9b95a85492c4f0f75fd2ef.png" alt="img"></p><br><p>  Check the source code <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/2.stencil_testing/stencil_testing.cpp">here</a> to see the full code of the object's stroke algorithm. </p><br><blockquote><p>  You can see that the boundaries between the two containers overlap.  Usually, this is exactly what you need (remember strategic games when we select several units).  If you need a complete border around each object, you need to clear the stencil buffer for each object and poke a little with the depth test setting. </p></blockquote><br><p>  The object stroke algorithm that you saw is quite often used in some games to visualize selected objects (remember strategic games), and such an algorithm can be easily implemented in the model class.  Then you can simply set the logical flag in the model class to draw with or without borders.  If you show a little creativity, you can make the borders more organic by using post-processing filters, such as Gaussian blur. </p><br><p>  With the help of screen testing, you can do more things than just trace objects, for example, to draw textures inside the rearview mirror so that they fit into the frame of the mirror.  Or render shadows in real time using <em>shadow volumes</em> .  Stencil buffer provides us with another great tool in our already extensive OpenGL toolkit. </p><br><br>  <b>PS</b> <br>  More thanks for the help and comments on the transfer to the user <a href="https://habrahabr.ru/users/uberschlag/" class="user_link">UberSchlag</a> ! <br>  If you want to help with the translation, <a href="https://t.me/joinchat/Cpb05A46UPpMWdNVVCb4Vg">join</a> the conversation in the Telegram: <br>  Could not add a link to the original publication (writes: <i>not a link</i> ), so, <a href="https://learnopengl.com/">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/344238/">https://habr.com/ru/post/344238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344226/index.html">Tanchiki in the console, the first article: "From the dispute to writing code"</a></li>
<li><a href="../344228/index.html">‚ÄúIs it a good design or not?‚Äù - how do I answer this question with the help of 3 categories</a></li>
<li><a href="../344230/index.html">Oracle Open World 2017: Announcements of ‚ÄúAutonomous AI‚Äù</a></li>
<li><a href="../344234/index.html">Python Meetup 11/14/2017: Python in Porto, Aiohttp and again tests</a></li>
<li><a href="../344236/index.html">The future billing systems and how they change the communications market</a></li>
<li><a href="../344240/index.html">Weekly sprint, candidate‚Äôs questionnaire and cardboard man</a></li>
<li><a href="../344242/index.html">Dispel the myths about the inefficiency of email marketing</a></li>
<li><a href="../344246/index.html">We script on WebAssembly, or WebAssembly without Web</a></li>
<li><a href="../344248/index.html">firebase.js is JUST HUGE (and what can we do about it)</a></li>
<li><a href="../344250/index.html">We invite you to December 15 at the Moscow CocoaHeads Meetup in Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>