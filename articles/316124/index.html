<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Better in RainTime than never: Extend the JIRA API on the fly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What should be done if the API available in the application is not enough to solve the problem, but there is no possibility to promptly make changes t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Better in RainTime than never: Extend the JIRA API on the fly</h1><div class="post__text post__text-html js-mediator-article">  What should be done if the API available in the application is not enough to solve the problem, but there is no possibility to promptly make changes to the code? <br><br><img src="https://habrastorage.org/files/2fa/67d/0e1/2fa67d0e1abc455385d45f4e5db19e64.jpg"><br><br>  The last hope in this situation may be the use of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">java.lang.instrument</a> tools.  Anyone who is interested in what and how in Java can be done with code in an already running VM, welcome under cat. <br><a name="habracut"></a><br>  On Habr√© there are already articles about working with bytecode: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habrahabr.ru/post/230239/">Java Agent on JVM service</a> </li><li>  <a href="https://habrahabr.ru/company/yandex/blog/280117/">Theory and Practice of AOP.</a>  <a href="https://habrahabr.ru/company/yandex/blog/280117/">How we do it in Yandex</a> </li><li>  <a href="https://habrahabr.ru/post/254791/">Aspect-oriented programming.</a>  <a href="https://habrahabr.ru/post/254791/">The basics</a> </li></ul><br>  But the application of these technologies, as a rule, is limited to logging or other simplest functions.  And what if you try to wipe at expanding the functionality of the application through instrumentation? <br><br>  In this article, I will show how you can perform tooling for a java agent application (both <a href="https://www.osgi.org/"><abbr title="Open Service Gateway interface">OSGi</abbr></a> and Byte Buddy libraries) in order to add new functionality to the application.  The article will be interesting primarily to people working with JIRA, but the approach used is quite universal and can be applied to other platforms. <br><br><h3>  <font color="#9cc2ce">Task</font> </h3><br>  So, after two or three days of researching the JIRA API, we understand that it is normal to implement cross-validation of field values ‚Äã‚Äã(in the case when the valid values ‚Äã‚Äãof one field depend on the value of another field) when creating / changing a task does not work out except through <a href="https://answers.atlassian.com/questions/125775/how-can-i-make-fields-required-on-a-transition-screen-but-not-required-on-the-edit-screen">transition validation</a> .  The approach is working, but difficult and not convenient, so in my free time I decided to continue research in order to have a plan B. <br><br>  On the recent <a href="http://jokerconf.com/">Joker, there</a> was a <a href="http://jokerconf.com/talks/making-java-more-dynamic/">report by</a> <a href="https://twitter.com/rafaelcodes">Rafael Winterhalter</a> about the <a href="http://bytebuddy.net/">Byte Buddy</a> library, which wraps a powerful low-level bytecode editing API into a more convenient high-level shell.  The library is currently quite popular, in particular, recently it is used in <a href="http://site.mockito.org/">Mockito</a> and <a href="http://jug.ru/2016/11/hibernate-switches-to-byte-buddy/">Hibernate</a> .  Among other things, Raphael talked about the possibility of changing already loaded classes with Byte Buddy. <br><br>  We think "And this is a thought!", And begin the work. <br><br><h3>  <font color="#9cc2ce">Design</font> </h3><br>  First, from the report by Raphael, we recall that modification of already loaded classes is possible only with the help of the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html">java.lang.instrument.Instrumentation</a> interface, which is available when you start the java agent.  It can be installed either when starting a VM using the command line, or using the <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/attach/">Attach API</a> , which is platform-specific and comes with the JDK. <br><br>  <i>There is an important detail - you cannot remove the agent - its classes remain loaded until the end of the VM.</i> <br><br>  As for JIRA in terms of attach API support, then we cannot guarantee that it will be launched on the JDK and even more so we cannot guarantee the OS on which it will be running. <br>  Second, we recall that the basic unit for expanding JIRA functionality is the <a href="https://developer.atlassian.com/jiradev/jira-platform/building-jira-add-ons">add-on</a> - <a href="https://osgi.org/javadoc/r4v43/core/org/osgi/framework/Bundle.html">Bundle</a> on steroids.  So all our logic, whatever it may be, will have to be in the form of add-ons.  Hence the requirement that if we make any changes to the system, they must be idempotent and disconnectable. <br><br>  Given these limitations, we see globally 2 tasks: <br><br><ul><li>  Agent installation: should occur when installing an add-on, provide protection against double installation, support installation of an agent on Linux and Windows, on JDK and JRE. <br>  Since  the agent cannot be removed, its update will require restarting the application - this does not really fit into the concept of OSGi.  Therefore, it is necessary to minimize the responsibility of the agent so that the need to update it occurs as little as possible. <br><br></li><li>  Implementing the instrumentation: should occur during the installation of the add-on, should provide the idempotency of the transformation of classes, should ensure the extensibility of the validation logic. </li></ul><br>  In the distribution of responsibility between the components, I got this scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a05/0e6/6e2/a050e66e2a9642ac816f4c6fd7aef2a8.png"></div><br><h3>  <font color="#9cc2ce">Implementation</font> </h3><br><h4>  Agent </h4><br>  First we create an agent: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrumentationSupplierAgent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Instrumentation instrumentation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">agentmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args, Instrumentation inst)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"==**agent started**=="</span></span>); InstrumentationSupplierAgent.instrumentation = inst; System.out.println(<span class="hljs-string"><span class="hljs-string">"==**agent execution complete**=="</span></span>); } }</code> </pre> <br>  The code is trivial, explanations, I think, are not needed.  As agreed - the most common logic, it is unlikely we will need to update it often. <br><br><h4>  Provider </h4><br>  Now create an add-on that this agent will attach to the target VM.  Let's start with the agent installation logic.  Full installer code under the spoiler: <br><br><div class="spoiler">  <b class="spoiler_title">AgentInstaller.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentInstaller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = LoggerFactory.getLogger(AgentInstaller.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JiraHome jiraHome; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JiraProperties jiraProperties; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AgentInstaller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @ComponentImport JiraHome jiraHome, @ComponentImport JiraProperties jiraProperties )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jiraHome = jiraHome; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jiraProperties = jiraProperties; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> File </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstrumentationDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JiraHome jiraHome)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File dataDirectory = jiraHome.getDataDirectory(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File instrFolder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(dataDirectory, <span class="hljs-string"><span class="hljs-string">"instrumentation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!instrFolder.exists()) { Files.createDirectory(instrFolder.toPath()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instrFolder; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> File </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadFileFromCurrentJar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File destination, String fileName)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream resourceAsStream = AgentInstaller.class.getResourceAsStream(<span class="hljs-string"><span class="hljs-string">"/lib/"</span></span> + fileName)) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File existingFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destination, fileName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!existingFile.exists() || !isCheckSumEqual(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(existingFile), resourceAsStream)) { Files.deleteIfExists(existingFile.toPath()); existingFile.createNewFile(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (OutputStream os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(existingFile)) { IOUtils.copy(resourceAsStream, os); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> existingFile; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckSumEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream existingFileStream, InputStream newFileStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream oldIs = existingFileStream; InputStream newIs = newFileStream) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.equals(getMDFiveDigest(oldIs), getMDFiveDigest(newIs)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchAlgorithmException | IOException e) { log.error(<span class="hljs-string"><span class="hljs-string">"Error to compare checksum for streams {},{}"</span></span>, existingFileStream, newFileStream); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] getMDFiveDigest(InputStream is) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> IOException, NoSuchAlgorithmException { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MessageDigest md = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"MD5"</span></span>); md.digest(IOUtils.toByteArray(is)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> md.digest(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PluginException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to install tools and agent"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isProperAgentLoaded()) { log.info(<span class="hljs-string"><span class="hljs-string">"Instrumentation agent is not installed yet or has wrong version"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String pid = getPid(); log.debug(<span class="hljs-string"><span class="hljs-string">"Current VM PID={}"</span></span>, pid); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> URLClassLoader systemClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader(); log.debug(<span class="hljs-string"><span class="hljs-string">"System classLoader={}"</span></span>, systemClassLoader); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Class&lt;?&gt; virtualMachine = getVirtualMachineClass( systemClassLoader, <span class="hljs-string"><span class="hljs-string">"com.sun.tools.attach.VirtualMachine"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ); log.debug(<span class="hljs-string"><span class="hljs-string">"VM class={}"</span></span>, virtualMachine); Method attach = virtualMachine.getMethod(<span class="hljs-string"><span class="hljs-string">"attach"</span></span>, String.class); Method loadAgent = virtualMachine.getMethod(<span class="hljs-string"><span class="hljs-string">"loadAgent"</span></span>, String.class); Method detach = virtualMachine.getMethod(<span class="hljs-string"><span class="hljs-string">"detach"</span></span>); Object vm = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { log.trace(<span class="hljs-string"><span class="hljs-string">"Attaching to VM with PID={}"</span></span>, pid); vm = attach.invoke(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, pid); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File agentFile = getAgentFile(); log.debug(<span class="hljs-string"><span class="hljs-string">"Agent file: {}"</span></span>, agentFile); loadAgent.invoke(vm, agentFile.getAbsolutePath()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { tryToDetach(vm, detach); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.info(<span class="hljs-string"><span class="hljs-string">"Instrumentation agent is already installed"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalPluginStateException(<span class="hljs-string"><span class="hljs-string">"Failed to load: agent and tools are not installed properly"</span></span>, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isProperAgentLoaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ClassLoader.getSystemClassLoader().loadClass(InstrumentationProvider.INSTRUMENTATION_CLASS_NAME); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToDetach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object vm, Method detach)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.trace(<span class="hljs-string"><span class="hljs-string">"Detaching from VM: {}"</span></span>, vm); detach.invoke(vm); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.warn(<span class="hljs-string"><span class="hljs-string">"Failed to detach, vm is null"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.warn(<span class="hljs-string"><span class="hljs-string">"Failed to detach"</span></span>, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nameOfRunningVM.split(<span class="hljs-string"><span class="hljs-string">"@"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Class&lt;?&gt; getVirtualMachineClass(URLClassLoader systemClassLoader, String className, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> tryLoadTools) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> Exception { log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to get VM class, loadingTools={}"</span></span>, tryLoadTools); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> systemClassLoader.loadClass(className); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tryLoadTools) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> OS os = getRunningOs(); os.tryToLoadTools(systemClassLoader, jiraHome); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getVirtualMachineClass(systemClassLoader, className, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(<span class="hljs-string"><span class="hljs-string">"Failed to load VM class"</span></span>, e); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> OS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRunningOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String osName = jiraProperties.getSanitisedProperties().get(<span class="hljs-string"><span class="hljs-string">"os.name"</span></span>); log.debug(<span class="hljs-string"><span class="hljs-string">"OS name: {}"</span></span>, osName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pattern.compile(<span class="hljs-string"><span class="hljs-string">".*[Ll]inux.*"</span></span>).matcher(osName).matches()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OS.LINUX; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pattern.compile(<span class="hljs-string"><span class="hljs-string">".*[Ww]indows.*"</span></span>).matcher(osName).matches()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OS.WINDOWS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Unknown OS running"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> File </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAgentFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File agent = loadFileFromCurrentJar(getInstrumentationDirectory(jiraHome), <span class="hljs-string"><span class="hljs-string">"instrumentation-agent.jar"</span></span>); agent.deleteOnExit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> agent; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OS { WINDOWS { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToolsFilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"tools-windows.jar"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAttachLibFilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"attach.dll"</span></span>; } }, LINUX { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToolsFilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"tools-linux.jar"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAttachLibFilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"libattach.so"</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToLoadTools</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URLClassLoader systemClassLoader, JiraHome jiraHome)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to load tools"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File instrumentationDirectory = getInstrumentationDirectory(jiraHome); appendLibPath(instrumentationDirectory.getAbsolutePath()); loadFileFromCurrentJar(instrumentationDirectory, getAttachLibFilename()); resetCache(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File tools = loadFileFromCurrentJar(instrumentationDirectory, getToolsFilename()); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method = URLClassLoader.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"addURL"</span></span>, URL.class); method.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); method.invoke(systemClassLoader, tools.toURI().toURL()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchFieldException, IllegalAccessException </span></span>{ Field fieldSysPath = ClassLoader.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"sys_paths"</span></span>); fieldSysPath.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); fieldSysPath.set(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendLibPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String instrumentationDirectory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (System.getProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.setProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>, System.getProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>) + System.getProperty(<span class="hljs-string"><span class="hljs-string">"path.separator"</span></span>) + instrumentationDirectory); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.setProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>, instrumentationDirectory); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToolsFilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAttachLibFilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }</code> </pre> <br></div></div><br>  Let's sort the code in parts. <br><br>  The simplest scenario is if the agent is already loaded.  Maybe it was enabled via the command line parameters at boot, or maybe the add-on is not installed the first time. <br><br>  Check - easy, just load the agent class with the system classifier <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isProperAgentLoaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ClassLoader.getSystemClassLoader().loadClass(InstrumentationProvider.INSTRUMENTATION_CLASS_NAME); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  If it is available, then nothing else needs to be installed.  But let's say we have the first installation, and the agent is not yet loaded - we will do it ourselves using the attach API.  Similarly to the previous case, we first check whether we are working under the JDK, i.e.  the necessary API is available to us without additional manipulations or not.  If not, then try to deliver the API. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Class&lt;?&gt; getVirtualMachineClass(URLClassLoader systemClassLoader, String className, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> tryLoadTools) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> Exception { log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to get VM class, loadingTools={}"</span></span>, tryLoadTools); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> systemClassLoader.loadClass(className); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tryLoadTools) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> OS os = getRunningOs(); os.tryToLoadTools(systemClassLoader, jiraHome); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getVirtualMachineClass(systemClassLoader, className, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(<span class="hljs-string"><span class="hljs-string">"Failed to load VM class"</span></span>, e); } } }</code> </pre> <br>  Now consider the installation procedure attach API.  The task of ‚Äúturning‚Äù a JRE into a JDK begins with the definition of a container OS.  In JIRA, the OS definition code is already implemented: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> OS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRunningOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String osName = jiraProperties.getSanitisedProperties().get(<span class="hljs-string"><span class="hljs-string">"os.name"</span></span>); log.debug(<span class="hljs-string"><span class="hljs-string">"OS name: {}"</span></span>, osName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pattern.compile(<span class="hljs-string"><span class="hljs-string">".*[Ll]inux.*"</span></span>).matcher(osName).matches()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OS.LINUX; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Pattern.compile(<span class="hljs-string"><span class="hljs-string">".*[Ww]indows.*"</span></span>).matcher(osName).matches()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OS.WINDOWS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Unknown OS running"</span></span>); } }</code> </pre> <br>  Now, knowing what OS we are under, let's consider how attach API can be downloaded.  First of all, let's take a look at what the <a href="http://www.oracle.com/technetwork/java/javase/jrereadme-182762.html">attach API</a> actually <a href="http://www.oracle.com/technetwork/java/javase/jrereadme-182762.html">consists of</a> .  As I said he is platform dependent. <br><br>  <i>Note: tools.jar is listed as platform independent, but this is not the case.</i>  <i>In META-INF / services / it hides the com.sun.tools.attach.spi.AttachProvider configuration file, which lists the available providers for the environment:</i> <br><br><blockquote>  # [solaris] sun.tools.attach.SolarisAttachProvider <br>  # [windows] sun.tools.attach.WindowsAttachProvider <br>  # [linux] sun.tools.attach.LinuxAttachProvider <br>  # [macosx] sun.tools.attach.BsdAttachProvider <br>  # [aix] sun.tools.attach.AixAttachProvider </blockquote><br>  They, in turn, are just very platform dependent. <br><br>  To connect the necessary files to the assembly at the moment, I decided to simply pull out the library files and copies of the tools.jar from the corresponding JDK distributions and put them into the repository. <br>  What is important to note is that after the upload, the attach API files cannot be deleted or modified, so if we want our add-on to still be deleted and updated, then we don‚Äôt need to load libraries directly from the jar - better when downloading copy them from our jar to a quiet, peaceful location accessible to us from JIRA. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToLoadTools</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URLClassLoader systemClassLoader, JiraHome jiraHome)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to load tools"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File instrumentationDirectory = getInstrumentationDirectory(jiraHome);<span class="hljs-comment"><span class="hljs-comment">//{JIRA_HOME}/data/instrumentation loadFileFromCurrentJar(instrumentationDirectory, getAttachLibFilename());//    final File tools = loadFileFromCurrentJar(instrumentationDirectory, getToolsFilename());// tools.jar ... }</span></span></code> </pre> <br>  To copy the files we will use the following method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> File </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadFileFromCurrentJar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File destination, String fileName)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream resourceAsStream = AgentInstaller.class.getResourceAsStream(<span class="hljs-string"><span class="hljs-string">"/lib/"</span></span> + fileName)) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File existingFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destination, fileName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!existingFile.exists() || !isCheckSumEqual(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(existingFile), resourceAsStream)) { Files.deleteIfExists(existingFile.toPath());<span class="hljs-comment"><span class="hljs-comment">//    -   existingFile.createNewFile(); try (OutputStream os = new FileOutputStream(existingFile)) { IOUtils.copy(resourceAsStream, os); } } return existingFile; } }</span></span></code> </pre> <br>  In addition to the usual file operations, this code also performs checksum calculation.  At the time of writing this method of verification of components that are not updated in runtime, it first occurred to me.  In principle, you can with the same success do a version check, if you version the artifacts.  If the files are already uploaded, but the checksums do not match the artifacts from the archive, we will try to replace them. <br><br>  So, there are files, let's figure out how to download.  Let's start with the most difficult - loading the native library.  If we look into the attach API subsoil, we will see that directly when performing tasks, the library is unloaded using this code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"attach"</span></span>); }</code> </pre> <br>  This suggests that we need to add the location of our library to ‚Äújava.library.path‚Äù <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendLibPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String instrumentationDirectory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (System.getProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.setProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>, System.getProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>) + System.getProperty(<span class="hljs-string"><span class="hljs-string">"path.separator"</span></span>) + instrumentationDirectory); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.setProperty(<span class="hljs-string"><span class="hljs-string">"java.library.path"</span></span>, instrumentationDirectory); } }</code> </pre> <br>  After that, it remains to add the necessary file of the native library into the correct directory and ... to score the first crutch in our solution.  "Java.library.path" is cached in the ClassLoader class, in private static String sys_paths [].  Well, we are private - let's go reset the cache ... <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchFieldException, IllegalAccessException </span></span>{ Field fieldSysPath = ClassLoader.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"sys_paths"</span></span>); fieldSysPath.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); fieldSysPath.set(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre> <br>  Here, we uploaded the native part ‚Äî go to the Java part of the API.  tools.jar in JDK is loaded by the system loader.  We need to do the same. <br><br>  After a bit of a jib, we find that the system loader implements java.net.URLClassLoader. <br>  In short, this loader stores class locations as a list of URLs.  All we need to download is to add the URL of our tools- [OS] .jar to this list.  Having studied the URLClassLoader API, we are upset once again, because  we find that the addURL method, which does exactly what is needed, turns out to be protected.  Eh ... another backup to a slim prototype: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method = URLClassLoader.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"addURL"</span></span>, URL.class); method.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); method.invoke(systemClassLoader, tools.toURI().toURL());</code> </pre> <br>  Well, finally, everything is ready to load the class of the virtual machine. <br><br>  It is necessary to load it not with the current OSGi-classifier, but with the system one, which always remains in the system, since  during the attach process, this class will load the native library, and this can only be done once.  OSGi is the same when creating a bundle - every time a new one.  So we risk getting such a thing: <br><br><blockquote>  ... 19 more <br>  Caused by: com.sun.tools.attach.AttachNotSupportedException: no providers installed <br>  at com.sun.tools.attach.VirtualMachine.attach (VirtualMachine.java:203) </blockquote><br>  The description is not obvious, but the real reason is that we are trying to load an already loaded library ‚Äî you can only find out about this by attaching the attach method and seeing the real exception. <br><br>  When we loaded the class, we can load the necessary methods and finally attach our agent: <br><br><pre> <code class="java hljs">Method attach = virtualMachine.getMethod(<span class="hljs-string"><span class="hljs-string">"attach"</span></span>, String.class); Method loadAgent = virtualMachine.getMethod(<span class="hljs-string"><span class="hljs-string">"loadAgent"</span></span>, String.class); Method detach = virtualMachine.getMethod(<span class="hljs-string"><span class="hljs-string">"detach"</span></span>); Object vm = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String pid = getPid(); log.debug(<span class="hljs-string"><span class="hljs-string">"Current VM PID={}"</span></span>, pid); log.trace(<span class="hljs-string"><span class="hljs-string">"Attaching to VM with PID={}"</span></span>, pid); vm = attach.invoke(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, pid); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File agentFile = getAgentFile(); log.debug(<span class="hljs-string"><span class="hljs-string">"Agent file: {}"</span></span>, agentFile); loadAgent.invoke(vm, agentFile.getAbsolutePath()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { tryToDetach(vm, detach); }</code> </pre> <br>  The only subtlety here is the code for getting the pid of the virtual machine: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nameOfRunningVM.split(<span class="hljs-string"><span class="hljs-string">"@"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  The method is not standardized, but quite working, and in the <a href="http://openjdk.java.net/jeps/102">Java 9 Process API</a> it will generally allow you to do this without any problems. <br><br><h4>  Add-on </h4><br>  Now we embed this logic in the add-on.  We are interested in the ability to call the code during the installation of the add-on - this is done using the standard Springs InitializingBean. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterPropertiesSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentInstaller.install(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceTracker.open(); }</code> </pre> <br>  First, we call the agent installation logic (discussed above), and then open <a href="https://osgi.org/javadoc/r4v42/org/osgi/util/tracker/ServiceTracker.html">ServiceTracker</a> - one of the main mechanisms for implementing the <a href="https://www.osgi.org/wp-content/uploads/whiteboard1.pdf">whiteboard</a> pattern in OSGi.  In short, this piece allows us to perform logic when adding / changing services of a certain type in a container. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ServiceTracker&lt;InstrumentationConsumer, Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initTracker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BundleContext bundleContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> InstrumentationProvider instrumentationProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceTracker&lt;&gt;(bundleContext, InstrumentationConsumer.class, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceTrackerCustomizer&lt;InstrumentationConsumer, Void&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Void </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addingService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceReference&lt;InstrumentationConsumer&gt; serviceReference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { log.trace(<span class="hljs-string"><span class="hljs-string">"addingService called"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> InstrumentationConsumer consumer = bundleContext.getService(serviceReference); log.debug(<span class="hljs-string"><span class="hljs-string">"Consumer: {}"</span></span>, consumer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (consumer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { applyInstrumentation(consumer, instrumentationProvider); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { log.error(<span class="hljs-string"><span class="hljs-string">"Error on 'addingService'"</span></span>, t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modifiedService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceReference&lt;InstrumentationConsumer&gt; serviceReference, Void aVoid)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removedService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceReference&lt;InstrumentationConsumer&gt; serviceReference, Void aVoid)</span></span></span><span class="hljs-function"> </span></span>{ } }); }</code> </pre> <br>  Now, every time a service that implements the InstrumentationConsumer class is registered to the container, we will do the following <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyInstrumentation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InstrumentationConsumer consumer, InstrumentationProvider instrumentationProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Instrumentation instrumentation; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { instrumentation = instrumentationProvider.getInstrumentation(); consumer.applyInstrumentation(instrumentation); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InstrumentationAgentException e) { log.error(<span class="hljs-string"><span class="hljs-string">"Error on getting insrumentation"</span></span>, e); } }</code> </pre> <br>  The java.lang.instrument.Instrumentation object will be received like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrumentationProviderImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrumentationProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = LoggerFactory.getLogger(InstrumentationProviderImpl.class); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Instrumentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstrumentation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InstrumentationAgentException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Class&lt;?&gt; agentClass = ClassLoader.getSystemClassLoader().loadClass(INSTRUMENTATION_CLASS_NAME);<span class="hljs-comment"><span class="hljs-comment">//     ,   javaagents log.debug("Agent class loaded from system classloader", agentClass); final Field instrumentation = agentClass.getDeclaredField(INSTRUMENTATION_FIELD_NAME);//   reflection log.debug("Instrumentation field: {}", instrumentation); final Object instrumentationValue = instrumentation.get(null); if (instrumentationValue == null) { throw new NullPointerException("instrumentation data is null. Seems agent is not installed"); } return (Instrumentation) instrumentationValue; } catch (Throwable e) { String msg = "Error getting instrumentation"; log.error(msg, e); throw new InstrumentationAgentException("Error getting instrumentation", e); } } }</span></span></code> </pre> <br>  We proceed to writing the validation engine. <br><br><h4>  Validation engine </h4><br>  We find the point to which the most effective changes are made - the DefaultIssueService class (in fact, not all creation / change calls go through this point, but this is a separate topic), and its methods: <br><br>  validateCreate: <br><br><pre> <code class="java hljs">IssueService.<span class="hljs-function"><span class="hljs-function">CreateValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable ApplicationUser var1, IssueInputParameters var2)</span></span></span></span>;</code> </pre> <br>  and validateUpdate: <br><br><pre> <code class="java hljs">IssueService.<span class="hljs-function"><span class="hljs-function">UpdateValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validateUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable ApplicationUser var1, Long var2, IssueInputParameters var3)</span></span></span></span>;</code> </pre> <br>  and pretend what logic we lack. <br><br>  We need to, after calling the main logic, cause custom validation of the initial parameters by our code, which, if necessary, can change the result. <br><br>  ByteBuddy offers us 2 options for implementing our ideas: using an interrupt and using the Advice mechanism.  The difference of approaches can be clearly seen on the slide of <a href="http://www.slideshare.net/RafaelWinterhalter/runtime-code-generation-for-the-jvm">the</a> Raphael <a href="http://www.slideshare.net/RafaelWinterhalter/runtime-code-generation-for-the-jvm">presentation</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1ea/558/ac8/1ea558ac8ba64041b1fbfcadf5e6c68a.PNG"></div><br>  The Interceptor API is well documented, any public class can act as it, more details <a href="http://bytebuddy.net/">here</a> .  Interceptor's call to the original bytecode is inserted INSTEAD of the original method. <br><br>  When trying to use this method, I identified 2 significant drawbacks: <br><br><ul><li>  In general, we have the opportunity to get the original method, and even the <a href="http://bytebuddy.net/">object of the method call</a> .  However, due to <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html">restrictions on changing the signature of the loaded classes</a> , in the case when we are instructing an already loaded class, we lose the original method (because it cannot be saved as a private method of the same class).  So if we want to reuse the original logic, we will have to re-write it ourselves. <br><br></li><li>  Since  we actually call the methods of another class, we need to provide visibility between the classes in the chain of class-cloneers.  In the case when the class is instrumented inside the OSGi-container, there will be no problems with visibility.  But in our case, most of the classes from the JIRA API are loaded by a WebappClassLoader, which is outside OSGi, which means that when we try to call our Interceptor method we will get a well-deserved ClassNotFoundException. </li></ul><br>  During the work on the project, I was born a solution to this problem, but since  It interferes with the logic of loading classes of the entire application. I do not recommend using it without thorough testing and will lay out under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Solving the downloader problem</b> <div class="spoiler_text">  The basic idea is to interrupt the WebappClassLoader's parent chain and insert a certain ClassLoader proxy that will try to load classes using the BundleClassLoader before delegating the download to the real WebappClassLoader parent <br><br>  Like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/57c/5b2/b2b/57c5b2b2b84e4997bf98c55ef4b4d3bc.png"></div><br>  The implementation of the approach looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToFixClassloader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassLoader originalClassLoader, BundleWiringImpl.BundleClassLoader bundleClassLoader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ClassLoader originalParent = originalClassLoader.getParent(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (originalParent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(originalParent <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BundleProxyClassLoader)) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BundleProxyClassLoader proxyClassLoader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BundleProxyClassLoader&lt;&gt;(originalParent, bundleClassLoader); FieldUtils.writeDeclaredField(originalClassLoader, <span class="hljs-string"><span class="hljs-string">"parent"</span></span>, proxyClassLoader, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IllegalAccessException e) { log.warn(<span class="hljs-string"><span class="hljs-string">"Error on try to fix originalClassLoader {}"</span></span>, originalClassLoader, e); } }</code> </pre> <br>  It should be used in the application of instrumentation: <br><br><pre> <code class="java hljs">... .transform((builder, typeDescription, classloader) -&gt; { builder.method(named(<span class="hljs-string"><span class="hljs-string">"validateCreate"</span></span>).and(ElementMatchers.isPublic())).intercept(MethodDelegation.to(Interceptor.class)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ClassUtils.isVisible(InstrumentationConsumer.class, classloader)) { tryToFixClassloader(classloader, (BundleWiringImpl.BundleClassLoader) Interceptor.class.getClassLoader()); } }) .installOn(instrumentation);</code> </pre> <br>  In this case, we will be able to load the OSGi classes via the WebappClassLoader.  The only thing to take care of is not to try to load classes using OSGi, loading of which will be delegated to outside of OSGi, since  this will obviously lead to looping and exceptions. <br>  BundleProxyClassLoader code: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BundleProxyClassLoader</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BundleWiringImpl</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BundleClassLoader</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassLoader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = LoggerFactory.getLogger(BundleProxyClassLoader.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;T&gt; proxies; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method loadClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method shouldDelegate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BundleProxyClassLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassLoader parent, T proxy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(parent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadClass = getLoadClassMethod(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shouldDelegate = getShouldDelegateMethod(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(); proxies.add(proxy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Method </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLoadClassMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IllegalStateException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Method loadClass = ClassLoader.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"loadClass"</span></span>, String.class, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>.class); loadClass.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadClass; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchMethodException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Failed to get loadClass method"</span></span>, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Method </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShouldDelegateMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IllegalStateException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Method shouldDelegate = BundleWiringImpl.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"shouldBootDelegate"</span></span>, String.class); shouldDelegate.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shouldDelegate; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchMethodException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Failed to get shouldDelegate method"</span></span>, e); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> resolve) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> ClassNotFoundException { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (getClassLoadingLock(name)) { log.trace(<span class="hljs-string"><span class="hljs-string">"Trying to find already loaded class {}"</span></span>, name); Class&lt;?&gt; c = findLoadedClass(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.trace(<span class="hljs-string"><span class="hljs-string">"This is new class. Trying to load {} with OSGi"</span></span>, name); c = tryToLoadWithProxies(name, resolve); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.trace(<span class="hljs-string"><span class="hljs-string">"Failed to load with OSGi. Trying to load {} with parent CL"</span></span>, name); c = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.loadClass(name, resolve); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassNotFoundException(name); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Class&lt;?&gt; tryToLoadWithProxies(String name, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> resolve) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T proxy : proxies) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String pkgName = Util.getClassPackage(name); <span class="hljs-comment"><span class="hljs-comment">//avoid cycle if(!isShouldDelegatePackageLoad(proxy, pkgName)) { log.trace("The load of class {} should not be delegated to OSGI parent, so let's try to load with bundles", name); return (Class&lt;?&gt;) this.loadClass.invoke(proxy, name, resolve); } } catch (ReflectiveOperationException e) { log.trace("Class {} is not found with {}", name, proxy); } } return null; } private boolean isShouldDelegatePackageLoad(T proxy, String pkgName) throws IllegalAccessException, InvocationTargetException { return (boolean)this.shouldDelegate.invoke( FieldUtils.readDeclaredField(proxy, "m_wiring", true), pkgName ); } }</span></span></code> </pre> <br>  I saved it in case someone wants to develop this idea. <br></div></div><br>  The second implementation of the instrumentation is the use of the Advice.  This method is much worse documented - in fact, examples can only be found on <a href="https://github.com/raphw/byte-buddy/issues/110">Github</a> tickets and <a href="http://stackoverflow.com/questions/35968530/retransform-classes-with-byte-buddy">StackOverflow</a> responses. <br><br><div class="spoiler">  <b class="spoiler_title">But it is not all that bad</b> <div class="spoiler_text">  Here we must give Rafael his due - all the questions and tickets that I saw are provided with detailed explanations and examples, so it won't be difficult to figure it out - I hope these works will bear fruit and we will see Byte Buddy in even more projects. <br></div></div><br>  It differs from the first one in that by default our advice methods are <b>embedded</b> in the class code.  For us, this means: <br><br><ul><li>  no need to dance with ClassLoaders </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preservation of the original logic - we can only perform certain actions before the original code or after </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It sounds perfect, we are provided with a smart API that allows you to get the original arguments, the results of the original code (including exceptions) and even get the results of the work of the Advice who worked to the original code. </font><font style="vertical-align: inherit;">But there is always a ‚Äúbut‚Äù, and embedding imposes some restrictions on the code that can be embedded:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all embedded code must be executed by one method </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the method must not contain calls to methods of classes that are not available to the class in which we are embedded, including </font><font style="vertical-align: inherit;">and anonymous (goodbye lambdas!)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exceptions are not supported - exceptions must be thrown explicitly in the body of the method </font></font></li></ul><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did not find these limitations in the Byte Buddy documentation.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, let's try to write our Advice-style logic. As we remember, we need to try to minimize the necessary instrumentation. This means that I would like to abstract away from specific validation checks ‚Äî to make sure that when a new check appears, it is automatically added to the list of checks that will be performed when validateCreate / validateUpdate is called, and the code of the DefaultIssueService class would not have to be changed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In OSGi, this is easy to do, but the DefaultIssueService is beyond the framework of the framework and OSGi tricks will not work here.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suddenly, the JIRA API comes to our rescue. Each add-on is represented in JIRA as an object of the Plugin class (wrapper over a Bundle with a number of special functions) with a specific key by which you can search for this plugin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key is set by us in the addon configuration, the plugin API is loaded by the same classifier as our DefaultIssueService - so nothing prevents us from calling our plugin in our advice, and using it to load any class that comes with this plugin. For example, this could be our check aggregator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that we can get an instance of this class through again the standard com.atlassian.jira.component.ComponentAccessor # getOSGiComponentInstanceOfType. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And no magic:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultIssueServiceValidateCreateAdvice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Advice</span></span>.OnMethodExit(onThrowable = IllegalArgumentException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @Advice.Return(readOnly = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> CreateValidationResult originalResult,</span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//        -   (readOnly = false) @Advice.Thrown Throwable throwable,//     -    @Advice.Argument(0) ApplicationUser user, @Advice.Argument(1) IssueInputParameters issueInputParameters ) { try { if (throwable == null) { //current plugin key final Plugin plugin = ComponentAccessor.getPluginAccessor().getEnabledPlugin("org.jrx.jira.instrumentation.issue-validation"); //related aggregator class final Class&lt;?&gt; issueValidatorClass = plugin != null ? plugin.getClassLoader().loadClass("org.jrx.jira.instrumentation.validation.spi.issueservice.IssueServiceValidateCreateValidatorAggregator") : null; final Object issueValidator = issueValidatorClass != null ? ComponentAccessor.getOSGiComponentInstanceOfType(issueValidatorClass) : null;//      API JIRA if (issueValidator != null) { final Method validate = issueValidator.getClass().getMethod("validate", CreateValidationResult.class, ApplicationUser.class, IssueInputParameters.class); if (validate != null) { final CreateValidationResult validationResult = (CreateValidationResult) validate .invoke(issueValidator, originalResult, user, issueInputParameters); if (validationResult != null) { originalResult = validationResult; } } else { System.err.println("==**Warn: method validate is not found on aggregator " + "**=="); } } } //Nothing should break service } catch (Throwable e) { System.err.println("==**Warn: Exception on additional logic of validateCreate " + e + "**=="); } } }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DefaultIssueServiceValidateUpdateAdvice looks similar to class and method names. </font><font style="vertical-align: inherit;">It's time to write InstrumentationConsumer, which will apply our advice to the method you need.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@ExportAsService</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultIssueServiceTransformer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrumentationConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = LoggerFactory.getLogger(DefaultIssueServiceTransformer.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AgentBuilder.Listener listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogTransformListener(log); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DEFAULT_ISSUE_SERVICE_CLASS_NAME = <span class="hljs-string"><span class="hljs-string">"com.atlassian.jira.bc.issue.DefaultIssueService"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyInstrumentation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Instrumentation instrumentation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AgentBuilder.Default().disableClassFormatChanges() .with(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AgentBuilder.Listener.Filtering( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringMatcher(DEFAULT_ISSUE_SERVICE_CLASS_NAME, EQUALS_FULLY), listener )) .with(AgentBuilder.TypeStrategy.Default.REDEFINE) .with(AgentBuilder.RedefinitionStrategy.REDEFINITION) .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE) .type(named(DEFAULT_ISSUE_SERVICE_CLASS_NAME)) .transform((builder, typeDescription, classloader) -&gt; builder <span class="hljs-comment"><span class="hljs-comment">//transformation is idempotent!!! You can call it many times with same effect //no way to add advice on advice if it applies to original class //https://github.com/raphw/byte-buddy/issues/206 .visit(Advice.to(DefaultIssueServiceValidateCreateAdvice.class).on(named("validateCreate").and(ElementMatchers.isPublic()))) .visit(Advice.to(DefaultIssueServiceValidateUpdateAdvice.class).on(named("validateUpdate").and(ElementMatchers.isPublic())))) .installOn(instrumentation); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I must say about one nice bonus. </font><font style="vertical-align: inherit;">Using advice is idempotent! </font><font style="vertical-align: inherit;">No need to take care not to apply the transformation twice when reinstalling the addon - </font></font><a href="https://github.com/raphw/byte-buddy/issues/206"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the VM will do it for us</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional features</font></font></b> <div class="spoiler_text">    , - <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html"></a>     ,            .   ,    JRE (, JAXB  ..),                ‚Äî ,   .. <br>      , ..   . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, business for small - we will write the aggregator. </font><font style="vertical-align: inherit;">First, we define the validation API:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IssueServiceValidateCreateValidator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Nonnull</span></span> <span class="hljs-function"><span class="hljs-function">CreateValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> @Nonnull CreateValidationResult originalResult, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ApplicationUser user, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IssueInputParameters issueInputParameters )</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, using standard OSGi tools at the time of the call, we obtain all available validations and execute them: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@ExportAsService</span></span>(IssueServiceValidateCreateValidatorAggregator.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IssueServiceValidateCreateValidatorAggregator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IssueServiceValidateCreateValidator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = LoggerFactory.getLogger(IssueServiceValidateCreateValidatorAggregator.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BundleContext bundleContext; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IssueServiceValidateCreateValidatorAggregator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BundleContext bundleContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bundleContext = bundleContext; } <span class="hljs-meta"><span class="hljs-meta">@Nonnull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IssueService.<span class="hljs-function"><span class="hljs-function">CreateValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nonnull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IssueService.CreateValidationResult originalResult, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ApplicationUser user, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IssueInputParameters issueInputParameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { log.trace(<span class="hljs-string"><span class="hljs-string">"Executing validate of IssueServiceValidateCreateValidatorAggregator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Collection&lt;ServiceReference&lt;IssueServiceValidateCreateValidator&gt;&gt; serviceReferences = bundleContext.getServiceReferences(IssueServiceValidateCreateValidator.class, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); log.debug(<span class="hljs-string"><span class="hljs-string">"Found services: {}"</span></span>, serviceReferences); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> applyValidations(originalResult, serviceReferences, user, issueInputParameters); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidSyntaxException e) { log.warn(<span class="hljs-string"><span class="hljs-string">"Exception on getting IssueServiceValidateCreateValidator"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> originalResult; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IssueService.<span class="hljs-function"><span class="hljs-function">CreateValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyValidations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nonnull IssueService.CreateValidationResult originalResult, Collection&lt;ServiceReference&lt;IssueServiceValidateCreateValidator&gt;&gt; serviceReferences, ApplicationUser user, IssueInputParameters issueInputParameters)</span></span></span><span class="hljs-function"> </span></span>{ IssueService.CreateValidationResult result = originalResult; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ServiceReference&lt;IssueServiceValidateCreateValidator&gt; serviceReference : serviceReferences) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IssueServiceValidateCreateValidator service = bundleContext.getService(serviceReference); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (service != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { result = service.validate(result, user, issueInputParameters); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.debug(<span class="hljs-string"><span class="hljs-string">"Failed to get service from {}"</span></span>, serviceReference); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything is ready - we collect, we establish </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test validation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To test the approach, we implement the simplest test: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@ExportAsService</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestIssueServiceCreateValidator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IssueServiceValidateCreateValidator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Nonnull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IssueService.<span class="hljs-function"><span class="hljs-function">CreateValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nonnull IssueService.CreateValidationResult originalResult, ApplicationUser user, IssueInputParameters issueInputParameters)</span></span></span><span class="hljs-function"> </span></span>{ originalResult.getErrorCollection().addError(IssueFieldConstants.ASSIGNEE, <span class="hljs-string"><span class="hljs-string">"This validation works"</span></span>, ErrorCollection.Reason.VALIDATION_FAILED); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> originalResult; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We are trying to create a new task and voila! </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e45/390/934/e45390934d8d4124a0e2cab8c49260f5.PNG"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we can delete and reinstall any addon from the developed ones - the behavior of JIRA changes correctly. </font></font><br><br><h3>  <font color="#9cc2ce">Conclusion</font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we have obtained a tool for dynamic extension of the application API, in this case JIRA. </font><font style="vertical-align: inherit;">Of course, before using such an approach in production, thorough testing is required, but in my opinion, the solution is not completely crumbled, and with proper elaboration, this approach can be used to solve ‚Äúhopeless tasks‚Äù - fixing long-lived thirdparty defects, for API expansion, etc. . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full code of the project itself can be viewed on </font></font><a href="https://github.com/dzharikhin/jira-instrumentation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - use on health! </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ps </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order not to complicate the article, I did not describe the details of the assembly of the project and the features of the development of add-ons for JIRA - see this </font></font><a href="https://developer.atlassian.com/docs/getting-started"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/316124/">https://habr.com/ru/post/316124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316112/index.html">Operating system from scratch (almost)</a></li>
<li><a href="../316116/index.html">Why does a good design start earlier than the first pictures?</a></li>
<li><a href="../316118/index.html">Publisher Peter. Black Friday 2016</a></li>
<li><a href="../316120/index.html">Technologies from the ‚ÄúBlack Mirror‚Äù, which are already with us</a></li>
<li><a href="../316122/index.html">The entire collection of IT Black Friday + Cyber ‚Äã‚ÄãMonday IT discounts in one post ... And let no one leave offended</a></li>
<li><a href="../316126/index.html">Interweaving the narrative into the procedural worlds</a></li>
<li><a href="../316128/index.html">TCP puzzles</a></li>
<li><a href="../316132/index.html">Google Chrome Developer Console: Ten Unobvious Utilities</a></li>
<li><a href="../316134/index.html">How to make the presentation interactive</a></li>
<li><a href="../316136/index.html">Pro Rendering Optimization - With Optimism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>