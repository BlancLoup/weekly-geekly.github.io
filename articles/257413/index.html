<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trojan-Downloader.Win32.Cabby.cemx - Part One - Unpacking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 I will say right away: I am not a virus analyst and do not do this activity professionally. I work as a network engineer in one of the co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trojan-Downloader.Win32.Cabby.cemx - Part One - Unpacking</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  I will say right away: I am not a virus analyst and do not do this activity professionally.  I work as a network engineer in one of the companies in the group of companies of three letters.  So please do not strictly judge and treat with understanding. <br><br>  The purpose of this article is not an express analysis of malware in order to write a report on the high-level logic of its work, but an immersion in reverse engineering with the head to enhance its knowledge and experience.  Therefore, we will go through the whole unpacking algorithm in detail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>I'll warn you right away that there will be a lot of pictures and listings of the disassembled code.</b> <br><br>  Ready for constructive criticism and I will be glad to your advice on optimizing my thoughts. <br><br>  In the recent past, a sensible CTB-Locker penetrated our company, which interested our information security service: why didn‚Äôt antivirus and web traffic filtering work?  What exactly this malware does is well described on the <a href="http://securelist.ru/analysis/obzor/21090/novoe-pokolenie-vymogatelej/">securelist</a> .  With this, everything is clear and it makes no sense to re-analyze what is described as well. <br><br>  In order to understand the causes of the incident, we consider the vector of the spread of this malware. <br><a name="habracut"></a><br>  How it looks from the user's point of view: <br><ol><li>  I received a letter with the attached .cab archive; </li><li>  The user opens the archive and runs from it .scr; </li><li>  A .rtf file opens with incomprehensible and uninteresting data; </li><li>  The user quietly closes the file and continues to work; </li><li>  After some time, a CTB-Locker window pops up on the desktop with sad user information. </li></ol><br><h2>  Decrypt </h2><br>  So, we get from the .cab archive the evil and biting .scr.  We open it in Immunity Debugger and, after pressing F9 a couple of times, we get to Entry Point 0x4021C6, without encountering any anti-debugging techniques on the way - this is already good. <br><br><img src="https://habrastorage.org/files/feb/371/033/feb371033bef4bc994749278c3060cf8.png"><br><br>  Having looked a little bit at a glance and having looked around the import, I did not find anything intelligible and ‚Äúuseful‚Äù.  Nothing related to networking activities - suggests that something is hidden deeper.  Packer? <br><br>  What PEiD will tell us about this: <br><br><img src="https://habrastorage.org/files/2c1/dfe/a35/2c1dfea355ab46cba0be6048eca78f04.png"><br><br>  No known packer found.  In addition, entropy analysis tells us that the file is most likely not packaged.  But let's look further ... <br><br>  Having traced a bit of code, we run into the first memory manipulation.  The variables passed to HeapCreate are not particularly cleverly veiled: <br><br><img src="https://habrastorage.org/files/e9b/43b/dda/e9b43bdda47249d390043e3f353a3303.png"><br><br>  Allocated memory size 0x6D0.  flOptions = 0x40000, which means that the memory area will be executable.  Ok, we are watching the allocated memory section, setting the Memory BP to it on the record, and we find a cycle for decrypting and copying data from the .data section to the allocated memory (by the way, it is located almost immediately after HeapCreate): <br><blockquote>  <font color="gray">00401F4A.</font>  <font color="gray">85DB TEST EBX, EBX</font> <font color="gray"><br></font>  <font color="gray">00401F4C.</font>  <font color="gray">0F84 67010000 JE g_r_pice.004020B9</font> <font color="gray"><br></font>  <font color="gray">00401F52.</font>  <font color="gray">01C0 ADD EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00401F54.</font>  <font color="gray">811D C8404000&gt; SBB DWORD PTR DS: [4040C8], 0CE</font> <font color="gray"><br></font>  <font color="gray">00401F5E.</font>  <font color="gray">82C4 40 ADD AH, 40</font> <font color="gray"><br></font>  <font color="gray">00401F61.</font>  <font color="gray">83C8 4A OR EAX, 4A</font> <font color="gray"><br></font>  <font color="gray">00401F64.</font>  <font color="gray">31F6 XOR ESI, ESI</font> <br>  00401F66.  0B37 OR ESI, DWORD PTR DS: [EDI] <font color="red">&lt;- Download data to decrypt from the body of the virus</font> <br>  <font color="gray">00401F68.</font>  <font color="gray">18E4 SBB AH, AH</font> <font color="gray"><br></font>  <font color="gray">00401F6A.</font>  <font color="gray">8315 28414000&gt; ADC DWORD PTR DS: [404128], 33</font> <font color="gray"><br></font>  <font color="gray">00401F71.</font>  <font color="gray">8115 E6404000&gt; ADC DWORD PTR DS: [4040E6], 0A3</font> <font color="gray"><br></font>  <font color="gray">00401F7B.</font>  <font color="gray">8315 95404000&gt; ADC DWORD PTR DS: [404095], 25</font> <font color="gray"><br></font>  <font color="gray">00401F82.</font>  <font color="gray">F8 CLC</font> <font color="gray"><br></font>  <font color="gray">00401F83.</font>  <font color="gray">83D7 04 ADC EDI, 4</font> <font color="gray"><br></font>  <font color="gray">00401F86.</font>  <font color="gray">34 F0 XOR AL, 0F0</font> <font color="gray"><br></font>  <font color="gray">00401F88.</font>  <font color="gray">1305 E9404000 ADC EAX, DWORD PTR DS: [4040E9]</font> <font color="gray"><br></font>  <font color="gray">00401F8E.</font>  <font color="gray">1905 48414000 SBB DWORD PTR DS: [404148], EAX</font> <font color="gray"><br></font>  <font color="gray">00401F94.</font>  <font color="gray">8335 A2414000&gt; XOR DWORD PTR DS: [4041A2], 2B</font> <font color="gray"><br></font>  <font color="gray">00401F9B.</font>  <font color="gray">3105 41414000 XOR DWORD PTR DS: [404141], EAX</font> <font color="gray"><br></font>  <font color="gray">00401FA1.</font>  <font color="gray">F8 CLC</font> <font color="gray"><br></font>  <font color="gray">00401FA2.</font>  <font color="gray">83DE 07 SBB ESI, 7</font> <font color="gray"><br></font>  <font color="gray">00401FA5.</font>  <font color="gray">8325 E0404000&gt; AND DWORD PTR DS: [4040E0], 6A</font> <font color="gray"><br></font>  <font color="gray">00401FAC.</font>  <font color="gray">82CC E9 OR AH, FFFFFFE9</font> <font color="gray"><br></font>  <font color="gray">00401FAF.</font>  <font color="gray">2105 68404000 AND DWORD PTR DS: [404068], EAX</font> <font color="gray"><br></font>  <font color="gray">00401FB5.</font>  <font color="gray">83C8 EE OR EAX, FFFFFFEE</font> <font color="gray"><br></font>  <font color="gray">00401FB8.</font>  <font color="gray">83F0 FF XOR EAX, FFFFFFFF</font> <font color="gray"><br></font>  <font color="gray">00401FBB.</font>  <font color="gray">F7DE NEG ESI</font> <font color="gray"><br></font>  <font color="gray">00401FBD.</font>  <font color="gray">810D 07414000&gt; OR DWORD PTR DS: [404107], 0C2</font> <font color="gray"><br></font>  <font color="gray">00401FC7.</font>  <font color="gray">C705 0D404000&gt; MOV DWORD PTR DS: [40400D], 0B8</font> <font color="gray"><br></font>  <font color="gray">00401FD1.</font>  <font color="gray">3105 C0404000 XOR DWORD PTR DS: [4040C0], EAX</font> <font color="gray"><br></font>  <font color="gray">00401FD7.</font>  <font color="gray">83C0 05 ADD EAX, 5</font> <font color="gray"><br></font>  <font color="gray">00401FDA.</font>  <font color="gray">29D6 SUB ESI, EDX</font> <font color="gray"><br></font>  <font color="gray">00401FDC.</font>  <font color="gray">11C0 ADC EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00401FDE.</font>  <font color="gray">1305 2D414000 ADC EAX, DWORD PTR DS: [40412D]</font> <font color="gray"><br></font>  <font color="gray">00401FE4.</font>  <font color="gray">83E8 2B SUB EAX, 2B</font> <font color="gray"><br></font>  <font color="gray">00401FE7.</font>  <font color="gray">1305 29404000 ADC EAX, DWORD PTR DS: [404029]</font> <font color="gray"><br></font>  <font color="gray">00401FED.</font>  <font color="gray">83D8 3E SBB EAX, 3E</font> <font color="gray"><br></font>  <font color="gray">00401FF0.</font>  <font color="gray">822D BA404000&gt; SUB BYTE PTR DS: [4040BA], - 79</font> <font color="gray"><br></font>  <font color="gray">00401FF7.</font>  <font color="gray">F8 CLC</font> <font color="gray"><br></font>  <font color="gray">00401FF8.</font>  <font color="gray">83D6 01 ADC ESI, 1</font> <font color="gray"><br></font>  <font color="gray">00401FFB.</font>  <font color="gray">83F0 B7 XOR EAX, FFFFFFB7</font> <font color="gray"><br></font>  <font color="gray">00401FFE.</font>  <font color="gray">3105 4E414000 XOR DWORD PTR DS: [40414E], EAX</font> <font color="gray"><br></font>  <font color="gray">00402004. 810D ED404000&gt; OR DWORD PTR DS: [4040ED], 0A5</font> <font color="gray"><br></font>  <font color="gray">0040200E.</font>  <font color="gray">31C0 XOR EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00402010. 31C0 XOR EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00402012. 29D2 SUB EDX, EDX</font> <font color="gray"><br></font>  <font color="gray">00402014. 29F2 SUB EDX, ESI</font> <font color="gray"><br></font>  <font color="gray">00402016. F7DA NEG EDX</font> <font color="gray"><br></font>  <font color="gray">00402018. 31C0 XOR EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">0040201A.</font>  <font color="gray">8335 DE414000&gt; XOR DWORD PTR DS: [4041DE], 64</font> <font color="gray"><br></font>  <font color="gray">00402021. 3105 66404000 XOR DWORD PTR DS: [404066], EAX</font> <font color="gray"><br></font>  <font color="gray">00402027. 31C0 XOR EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00402029. 83D0 CC ADC EAX, -34</font> <font color="gray"><br></font>  <font color="gray">0040202C.</font>  <font color="gray">2B05 33414000 SUB EAX, DWORD PTR DS: [404133]</font> <font color="gray"><br></font>  <font color="gray">00402032. C1C2 03 ROL EDX, 3</font> <font color="gray"><br></font>  <font color="gray">00402035. 1305 4D404000 ADC EAX, DWORD PTR DS: [40404D]</font> <font color="gray"><br></font>  <font color="gray">0040203B.</font>  <font color="gray">11C0 ADC EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">0040203D.</font>  <font color="gray">83C8 B4 OR EAX, FFFFFFB4</font> <font color="gray"><br></font>  <font color="gray">00402040. 19C0 SBB EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00402042. C1C2 05 ROL EDX, 5</font> <font color="gray"><br></font>  <font color="gray">00402045. 0105 4B404000 ADD DWORD PTR DS: [40404B], EAX</font> <font color="gray"><br></font>  <font color="gray">0040204B.</font>  <font color="gray">2B05 3C404000 SUB EAX, DWORD PTR DS: [40403C]</font> <font color="gray"><br></font>  <font color="gray">00402051. 1305 B0404000 ADC EAX, DWORD PTR DS: [4040B0]</font> <font color="gray"><br></font>  <font color="gray">00402057. C705 C4404000&gt; MOV DWORD PTR DS: [4040C4], 0B9</font> <font color="gray"><br></font>  <font color="gray">00402061. 56 PUSH ESI</font> <br>  00402062. 8F01 POP DWORD PTR DS: [ECX] <font color="red">&lt;- Saving to Allocated Memory</font> <br>  <font color="gray">00402064. 83E0 0E AND EAX, 0E</font> <font color="gray"><br></font>  <font color="gray">00402067. 1905 F8414000 SBB DWORD PTR DS: [4041F8], EAX</font> <font color="gray"><br></font>  <font color="gray">0040206D.</font>  <font color="gray">2905 45404000 SUB DWORD PTR DS: [404045], EAX</font> <font color="gray"><br></font>  <font color="gray">00402073. A3 8F404000 MOV DWORD PTR DS: [40408F], EAX</font> <font color="gray"><br></font>  <font color="gray">00402078. A3 AF404000 MOV DWORD PTR DS: [4040AF], EAX</font> <font color="gray"><br></font>  <font color="gray">0040207D.</font>  <font color="gray">83C1 04 ADD ECX, 4</font> <font color="gray"><br></font>  <font color="gray">00402080. 2905 18414000 SUB DWORD PTR DS: [404118], EAX</font> <font color="gray"><br></font>  <font color="gray">00402086. 19C0 SBB EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00402088. 83D0 D9 ADC EAX, -27</font> <font color="gray"><br></font>  <font color="gray">0040208B.</font>  <font color="gray">0905 3C404000 OR DWORD PTR DS: [40403C], EAX</font> <font color="gray"><br></font>  <font color="gray">00402091. 19C0 SBB EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">00402093. 8D5B FC LEA EBX, DWORD PTR DS: [EBX-4]</font> <font color="gray"><br></font>  <font color="gray">00402096. 83D8 12 SBB EAX, 12</font> <font color="gray"><br></font>  <font color="gray">00402099. 2105 15414000 AND DWORD PTR DS: [404115], EAX</font> <font color="gray"><br></font>  <font color="gray">0040209F.</font>  <font color="gray">C705 AE414000&gt; MOV DWORD PTR DS: [4041AE], 33</font> <font color="gray"><br></font>  <font color="gray">004020A9.</font>  <font color="gray">C705 18404000&gt; MOV DWORD PTR DS: [404018], 0DA</font> <font color="gray"><br></font>  <font color="gray">004020B3.</font>  <font color="gray">68 4A1F4000 PUSH g_r_pice.00401F4A</font> <font color="gray"><br></font>  <font color="gray">004020B8.</font>  <font color="gray">C3 RETN</font> <br></blockquote><br><br>  We tell the debugger to disassemble the target memory area and get the expected result - quite the executable code: <br><br><img src="https://habrastorage.org/files/b33/595/52e/b3359552e6ee493aa5ae33f7d61b08a4.png"><br><br>  The transition to the decoded code did not take long: <br><br><img src="https://habrastorage.org/files/45e/6bc/0e4/45e6bc0e4a6d4e698e9529a108a75af8.png"><br><br>  At the very beginning we find an interesting method for passing parameters to procedures.  Consider the example of the first such function.  As you can see, the LoadLibrary function is called, to which you need to transfer a string variable of the library name for loading. <br><blockquote>  <font color="gray">02120000 8B7424 04 MOV ESI, DWORD PTR SS: [ESP + 4]</font> <font color="gray"><br></font>  <font color="gray">02120004 55 PUSH EBP</font> <font color="gray"><br></font>  <font color="gray">02120005 E8 DF010000 CALL 021201E9</font> <font color="gray"><br></font>  <font color="gray">0212000A 58 POP EAX</font> <font color="gray"><br></font>  <font color="gray">0212000B 50 PUSH EAX</font> <br>  0212000C FFD6 CALL ESI;  kernel32.LoadLibraryA <br></blockquote><br>  Before this function, the procedure ‚ÄúCALL 021001E9‚Äù is called.  This is what it is: <br><blockquote>  <font color="gray">021201E9 58 POP EAX;</font>  <font color="gray">0210000A</font> <font color="gray"><br></font>  <font color="gray">021201EA FFD0 CALL EAX</font> <br></blockquote><br>  What happens at this moment?  When ‚ÄúCALL 021001E9‚Äù is called, the address of the instruction after this call to return from the procedure is placed on the stack.  After the call, the return address is retrieved from the stack and placed in EAX.  Next, the call "CALL EAX", which in turn pushes the address of the next instruction to return to the stack.  We look in the dump - we see the name of the library: <br><br><img src="https://habrastorage.org/files/1ac/ad2/c79/1acad2c797854d0aa1081cf125ff6e0e.png"><br><br>  Further on listing such method is encountered more than once. <br><br>  The next interesting point is the procedure for finding the necessary functions from the connected library.  Among the parameters passed to the procedure is a pointer to an incomprehensible set of bytes obtained by the method described above, then we will understand why and what it is.  So, the procedure itself: <br><blockquote> <font color="gray">0212034B 60 PUSHAD</font> <font color="gray"><br></font>  <font color="gray">0212034C EB 07 JMP SHORT 02120355</font> <br>  0212034E AD LODS DWORD PTR DS: [ESI] <font color="red">&lt;- Algorithm for</font> traversing <font color="red">DLL headers to search export table</font> <br>  0212034F ^ E2 FD LOOPD SHORT 0212034E <br>  02120351 8D3403 LEA ESI, DWORD PTR DS: [EBX + EAX] <br>  02120354 C3 RETN <br>  02120355 8BE8 MOV EBP, EAX <br>  02120357 8BF3 MOV ESI, EBX <br>  02120359 B9 10,000,000 MOV ECX, 10 <br>  0212035E E8 EBFFFFFF CALL 0212034E <br>  02120363 B9 1F000000 MOV ECX, 1F <br>  02120368 E8 E1FFFFFF CALL 0212034E <br>  0212036D 56 PUSH ESI <br>  0212036E B9 07000000 MOV ECX, 7 <br>  02120373 E8 D6FFFFFF CALL 0212034E <br>  02120378 8BD0 MOV EDX, EAX <br>  0212037A 8B3424 MOV ESI, DWORD PTR SS: [ESP] <br>  0212037D B9 09000000 MOV ECX, 9 <br>  02120382 E8 C7FFFFFF CALL 0212034E <br>  02120387 8BFE MOV EDI, ESI <br>  02120389 8BCA MOV ECX, EDX <br>  0212038B E8 BEFFFFFF CALL 0212034E <br>  <font color="gray">02120390 33C0 XOR EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">02120392 50 PUSH EAX</font> <br>  02120393 C1C8 07 ROR EAX, 7 <font color="red">&lt;- Calculation of a hash sum on behalf of a function from the DLL export table</font> <br>  02120396 C10424 0D ROL DWORD PTR SS: [ESP], 0D <br>  0212039A 010424 ADD DWORD PTR SS: [ESP], EAX <br>  0212039D AC LODS BYTE PTR DS: [ESI] <br>  0212039E 84C0 TEST AL, AL <br>  021203A0 ^ 75 F1 JNZ SHORT 02120393 <br>  <font color="gray">021203A2 58 POP EAX</font> <font color="gray"><br></font>  <font color="gray">021203A3 8BF7 MOV ESI, EDI</font> <br>  021203A5 3BC5 CMP EAX, EBP <font color="red">&lt;- Comparing the resulting hash sum with the value in memory</font> <br>  <font color="gray">021203A7 74 03 JE SHORT 021203AC</font> <font color="gray"><br></font>  <font color="gray">021203A9 4A DEC EDX</font> <font color="gray"><br></font>  <font color="gray">021203AA ^ 75 DD JNZ SHORT 02120389</font> <br>  021203AC 8B3424 MOV ESI, DWORD PTR SS: [ESP] <font color="red">&lt;- If the hash matches, then the address of the desired function is searched for and returned.</font> <br>  021203AF B9 0A000000 MOV ECX, 0A <br>  021203B4 E8 95FFFFFF CALL 0212034E <br>  021203B9 0FB70C56 MOVZX ECX, WORD PTR DS: [ESI + EDX * 2] <br>  021203BD 5E POP ESI <br>  021203BE 51 PUSH ECX <br>  021203BF B9 080000 MOV ECX, 8 <br>  021203C4 E8 85FFFFFF CALL 0212034E <br>  021203C9 59 POP ECX <br>  021203CA E8 7FFFFFFF CALL 0212034E <br>  021203CF 897424 1C MOV DWORD PTR SS: [ESP + 1C], ESI <br>  <font color="gray">021203D3 61 POPAD</font> <font color="gray"><br></font>  <font color="gray">021203D4 C3 RETN</font> <br></blockquote><br>  Now it is clear that this procedure receives a pointer to a certain hash sum and the address of the DLL in which the function should be searched.  Further, the logic in order: <br><ol><li>  The headers of PE calculate the address of the export table of the target DLL; </li><li>  The name of each function from the export table is taken and a certain hash sum is calculated; </li><li>  The coincidence of the calculated hash sum and that obtained in the parameter is checked; </li><li>  If the hash sums match, the address of the function found is calculated and returned. </li></ol><br>  As you search for the necessary functions, the original hash sums are rewritten to real addresses: <br><br><img src="https://habrastorage.org/files/c24/811/ee0/c24811ee01964569ba3d679cf566e31d.png"><br><br>  Then, using GetProcAddress, the addresses of three more functions are found: HeapAlloc, HeapFree, and GetTickCount. <br><blockquote>  <font color="gray">02120039 5F POP EDI</font> <font color="gray"><br></font>  <font color="gray">0212003A 83C7 0D ADD EDI, 0D</font> <font color="gray"><br></font>  <font color="gray">0212003D 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">0212003E 53 PUSH EBX</font> <br>  0212003F FF55 08 Call DWORD PTR SS: [EBP + 8] <br>  <font color="gray">02120042 8906 MOV DWORD PTR DS: [ESI], EAX</font> <font color="gray"><br></font>  <font color="gray">02120044 83C7 0A ADD EDI, 0A</font> <font color="gray"><br></font>  <font color="gray">02120047 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">02120048 53 PUSH EBX</font> <br>  02120049 FF55 08 CALL DWORD PTR SS: [EBP + 8] <br>  <font color="gray">0212004C 8946 04 MOV DWORD PTR DS: [ESI + 4], EAX</font> <font color="gray"><br></font>  <font color="gray">0212004F 83C7 09 ADD EDI, 9</font> <font color="gray"><br></font>  <font color="gray">02120052 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">02120053 53 PUSH EBX</font> <br>  02120054 FF55 08 CALL DWORD PTR SS: [EBP + 8];  kernel32.GetProcAddress <br>  <font color="gray">02120057 8946 08 MOV DWORD PTR DS: [ESI + 8], EAX</font> <br></blockquote><br>  Found addresses are added to the end of the already formed array of addresses used by API: <br><br><img src="https://habrastorage.org/files/b2e/155/9f3/b2e1559f3e63469f9c69af72914c75b0.png"><br><br>  The array of functions used is formed, after which its use begins immediately with the allocation of a new memory area of ‚Äã‚Äãthe same size as last time - 0x6D0: <br><br><img src="https://habrastorage.org/files/16d/a64/fb7/16da64fb7024432492b09826136eb570.png"><br><br>  flProtect = 0x40, which again indicates the possibility of executing code in the allocated memory. <br>  After ‚ÄúVirtualAlloc‚Äù we immediately meet the cycle of copying the current memory location to a new one, while saving the return address for the ‚ÄúRETN‚Äù to the 0x81 offset: <br><br><img src="https://habrastorage.org/files/747/4ea/6f9/7474ea6f9aba41689db0f7ed32f9aba2.png"><br><br>  "RETN" transfers the execution of the code to a new memory area, which looks like this: <br><blockquote>  00220081 E8 CB050000 CALL 00220651 <br>  <font color="gray">00220086 5D POP EBP</font> <font color="gray"><br></font>  <font color="gray">00220087 5E POP ESI</font> <font color="gray"><br></font>  <font color="gray">00220088 873424 XCHG DWORD PTR SS: [ESP], ESI</font> <font color="gray"><br></font>  <font color="gray">0022008B 56 PUSH ESI</font> <br>  0022008C E8 2E050000 CALL 002205BF <br>  00220091 E8 6C050000 CALL 00220602 <br></blockquote><br>  ‚ÄúCALL 00220651‚Äù is a procedure already known to us, which in an artful manner returns us the address of an array with the addresses of the restored functions. <br>  "CALL 002205BF" - checks the validity of the process loaded into memory by the signatures "MZ" and "PE". <br><blockquote>  <font color="gray">002205BF 66: 33F6 XOR SI, SI</font> <font color="gray"><br></font>  <font color="gray">002205C2 66: BA 4D5A MOV DX, 5A4D</font> <font color="gray"><br></font>  <font color="gray">002205C6 66: AD LODS WORD PTR DS: [ESI]</font> <font color="gray"><br></font>  <font color="gray">002205C8 66: 33D0 XOR DX, AX</font> <font color="gray"><br></font>  <font color="gray">002205CB 74 08 JE SHORT 002205D5</font> <font color="gray"><br></font>  <font color="gray">002205CD 81EE 02100000 SUB ESI, 1002</font> <font color="gray"><br></font>  <font color="gray">002205D3 ^ EB ED JMP SHORT 002205C2</font> <font color="gray"><br></font>  <font color="gray">002205D5 8D5E FE LEA EBX, DWORD PTR DS: [ESI-2]</font> <font color="gray"><br></font>  <font color="gray">002205D8 84FF TEST BH, BH</font> <font color="gray"><br></font>  <font color="gray">002205DA ^ 75 F1 JNZ SHORT 002205CD</font> <font color="gray"><br></font>  <font color="gray">002205DC 8B76 3A MOV ESI, DWORD PTR DS: [ESI + 3A]</font> <font color="gray"><br></font>  <font color="gray">002205DF 66: BA 5045 MOV DX, 4550</font> <font color="gray"><br></font>  <font color="gray">002205E3 8D341E LEA ESI, DWORD PTR DS: [ESI + EBX]</font> <font color="gray"><br></font>  <font color="gray">002205E6 66: AD LODS WORD PTR DS: [ESI]</font> <font color="gray"><br></font>  <font color="gray">002205E8 66: 33D0 XOR DX, AX</font> <font color="gray"><br></font>  <font color="gray">002205EB ^ 75 E0 JNZ SHORT 002205CD</font> <font color="gray"><br></font>  <font color="gray">002205ED C3 RETN</font> <br></blockquote><br>  "CALL 00220602" - allocates a new chunk of memory in size 0x2C00 (now read-write only), finds the full name of the file that started the current process and opens the file for reading <br><blockquote>  <font color="gray">00220602 8B7D 70 MOV EDI, DWORD PTR SS: [EBP + 70]; SS: [002206C4] = 00002C00</font> <font color="gray"><br></font>  <font color="gray">00220605 6A 04 PUSH 4</font> <font color="gray"><br></font>  <font color="gray">00220607 68 00100000 PUSH 1000</font> <font color="gray"><br></font>  <font color="gray">0022060C 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">0022060D 6A 00 PUSH 0</font> <br>  0022060F FF55 10 CALL DWORD PTR SS: [EBP + 10];  kernel32.VirtualAlloc <br>  <font color="gray">00220612 8BF0 MOV ESI, EAX</font> <font color="gray"><br></font>  <font color="gray">00220614 81EC 04010000 SUB ESP, 104</font> <font color="gray"><br></font>  <font color="gray">0022061A 8BFC MOV EDI, ESP</font> <font color="gray"><br></font>  <font color="gray">0022061C 68 04010000 PUSH 104</font> <font color="gray"><br></font>  <font color="gray">00220621 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">00220622 53 PUSH EBX; 00400000</font> <br>  00220623 FF55 20 CALL DWORD PTR SS: [EBP + 20];  kernel32.GetModuleFileNameA <br>  <font color="gray">00220626 6A 00 PUSH 0</font> <font color="gray"><br></font>  <font color="gray">00220628 68 80000000 PUSH 80</font> <font color="gray"><br></font>  <font color="gray">0022062D 6A 03 PUSH 3</font> <font color="gray"><br></font>  <font color="gray">0022062F 6A 00 PUSH 0</font> <font color="gray"><br></font>  <font color="gray">00220631 6A 01 PUSH 1</font> <font color="gray"><br></font>  <font color="gray">00220633 68 00000080 PUSH 80000000</font> <font color="gray"><br></font>  <font color="gray">00220638 57 PUSH EDI</font> <br>  00220639 FF55 24 CALL DWORD PTR SS: [EBP + 24];  kernel32.CreateFileA <br>  <font color="gray">0022063C 81C4 04010000 ADD ESP, 104</font> <font color="gray"><br></font>  <font color="gray">00220642 C3 RETN</font> <br></blockquote><br><br>  After returning the handle to the open file, the pointer is set at offset 0x6263: <br><blockquote>  <font color="gray">00220096 8BF8 MOV EDI, EAX</font> <font color="gray"><br></font>  <font color="gray">00220098 6A 00 PUSH 0</font> <font color="gray"><br></font>  <font color="gray">0022009A 6A 00 PUSH 0</font> <br>  0022009C FF75 6C PUSH DWORD PTR SS: [EBP + 6C]; SS: [002206C0] = 00006263 <br>  <font color="gray">0022009F 57 PUSH EDI</font> <br>  002200A0 FF55 28 CALL DWORD PTR SS: [EBP + 28];  kernel32.SetFilePointer <br></blockquote><br>  In the HEX editor, you can see that some data is actually stored on this offset, most likely encrypted: <br><img src="https://habrastorage.org/files/7ba/5ff/059/7ba5ff05904346438277cd65afe056e0.png"><br><br>  Reading data from a file of 0x2C00 size at the specified offset into the previously created memory segment: <br><blockquote>  <font color="gray">002200A3 8B4D 70 MOV ECX, DWORD PTR SS: [EBP + 70]; SS: [002206C4] = 00002C00</font> <font color="gray"><br></font>  <font color="gray">002200A6 6A 00 PUSH 0</font> <font color="gray"><br></font>  <font color="gray">002200A8 54 PUSH ESP</font> <font color="gray"><br></font>  <font color="gray">002200A9 58 POP EAX</font> <font color="gray"><br></font>  <font color="gray">002200AA FF3424 PUSH DWORD PTR SS: [ESP]; Stack SS: [0018FF28] = 0000005C</font> <font color="gray"><br></font>  <font color="gray">002200AD 50 PUSH EAX</font> <font color="gray"><br></font>  <font color="gray">002200AE 51 PUSH ECX</font> <br>  002200AF 56 PUSH ESI; 00230000 <br>  <font color="gray">002200B0 57 PUSH EDI</font> <br>  002200B1 FF55 2C CALL DWORD PTR SS: [EBP + 2C];  kernel32.ReadFile <br></blockquote><br><br>  Next, the decryption procedure for the copied data is called: <br><br><img src="https://habrastorage.org/files/942/272/c89/942272c8946d49cd8710e00dbf545b2a.png"><br><br>  I will not show the whole listing of the procedure, here is the decryption cycle: <br><blockquote>  <font color="gray">00220505 3B75 60 CMP ESI, DWORD PTR SS: [EBP + 60]</font> <font color="gray"><br></font>  <font color="gray">00220508 75 0D JNZ SHORT 00220517</font> <font color="gray"><br></font>  <font color="gray">0022050A 0375 64 ADD ESI, DWORD PTR SS: [EBP + 64]</font> <font color="gray"><br></font>  <font color="gray">0022050D 037D 64 ADD EDI, DWORD PTR SS: [EBP + 64]</font> <font color="gray"><br></font>  <font color="gray">00220510 2B4D 64 SUB ECX, DWORD PTR SS: [EBP + 64]</font> <font color="gray"><br></font>  <font color="gray">00220513 85C9 TEST ECX, ECX</font> <font color="gray"><br></font>  <font color="gray">00220515 74 12 JE SHORT 00220529</font> <br>  00220517 AD LODS DWORD PTR DS: [ESI] <font color="red">&lt;- read, decrypt, write</font> <br>  00220518 50 PUSH EAX <br>  00220519 05 224AFE8D ADD EAX, 8DFE4A22 <br>  0022051E 0FC8 BSWAP EAX <br>  00220520 33C2 XOR EAX, EDX <br>  00220522 5A POP EDX <br>  00220523 AB STOS DWORD PTR ES: [EDI] <br>  <font color="gray">00220524 83E9 03 SUB ECX, 3</font> <font color="gray"><br></font>  <font color="gray">00220527 ^ E2 DC LOOPD SHORT 00220505</font> <br></blockquote><br><br>  After decoding in the dump you can see the following picture: <br><br><img src="https://habrastorage.org/files/309/dc9/0be/309dc90bea624ea080551a50f5dba7b4.png"><br><br>  The signatures "MZ" and "PE" suggest that we are close to the goal. <br><br>  Formation of new headers and sections of the current process. <br>  After decryption, 512 bytes in the ImageBase of the current process are overwritten with the decrypted data (of course, after changing the rights to the target memory area to RW): <br><br><img src="https://habrastorage.org/files/b7c/7de/2cd/b7c7de2cd02248acb79409d820d447d2.png"><br><br>  The result is that the old headings and section table are rewritten by new ones.  As can be seen from the new section table - there will be two sections ".text" and ".rsrc": <br><br><img src="https://habrastorage.org/files/5ab/b92/d09/5abb92d09f0d462f9706224ed1240241.png"><br><br>  Next, go to the following code: <br><blockquote>  <font color="gray">00220101 0349 3C ADD ECX, DWORD PTR DS: [ECX + 3C]</font> <font color="gray"><br></font>  <font color="gray">00220104 8D79 18 LEA EDI, DWORD PTR DS: [ECX + 18]</font> <font color="gray"><br></font>  <font color="gray">00220107 8B57 20 MOV EDX, DWORD PTR DS: [EDI + 20]</font> <font color="gray"><br></font>  <font color="gray">0022010A 0FB741 14 MOVZX EAX, WORD PTR DS: [ECX + 14]</font> <font color="gray"><br></font>  <font color="gray">0022010E 03F8 ADD EDI, EAX</font> <font color="gray"><br></font>  <font color="gray">00220110 0FB749 06 MOVZX ECX, WORD PTR DS: [ECX + 6]</font> <br>  00220114 60 PUSHAD <font color="red">&lt;- the beginning of the cycle of formation of new sections</font> <br>  <font color="gray">00220115 8B47 08 MOV EAX, DWORD PTR DS: [EDI + 8]</font> <font color="gray"><br></font>  <font color="gray">00220118 85C0 TEST EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">0022011A 74 42 JE SHORT 0022015E</font> <font color="gray"><br></font>  <font color="gray">0022011C E8 CD040000 CALL 002205EE</font> <font color="gray"><br></font>  <font color="gray">00220121 8BC8 MOV ECX, EAX</font> <font color="gray"><br></font>  <font color="gray">00220123 8B47 24 MOV EAX, DWORD PTR DS: [EDI + 24]</font> <font color="gray"><br></font>  <font color="gray">00220126 E8 AA020000 CALL 002203D5</font> <font color="gray"><br></font>  <font color="gray">0022012B 0377 14 ADD ESI, DWORD PTR DS: [EDI + 14]</font> <font color="gray"><br></font>  <font color="gray">0022012E FF77 10 PUSH DWORD PTR DS: [EDI + 10]</font> <font color="gray"><br></font>  <font color="gray">00220131 8B7F 0C MOV EDI, DWORD PTR DS: [EDI + C]</font> <font color="gray"><br></font>  <font color="gray">00220134 03FB ADD EDI, EBX</font> <font color="gray"><br></font>  <font color="gray">00220136 5B POP EBX</font> <font color="gray"><br></font>  <font color="gray">00220137 50 PUSH EAX</font> <font color="gray"><br></font>  <font color="gray">00220138 8BD4 MOV EDX, ESP</font> <font color="gray"><br></font>  <font color="gray">0022013A 52 PUSH EDX</font> <font color="gray"><br></font>  <font color="gray">0022013B 50 PUSH EAX</font> <font color="gray"><br></font>  <font color="gray">0022013C 51 PUSH ECX</font> <font color="gray"><br></font>  <font color="gray">0022013D 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">0022013E 51 PUSH ECX</font> <font color="gray"><br></font>  <font color="gray">0022013F 52 PUSH EDX</font> <font color="gray"><br></font>  <font color="gray">00220140 6A 04 PUSH 4</font> <font color="gray"><br></font>  <font color="gray">00220142 51 PUSH ECX</font> <font color="gray"><br></font>  <font color="gray">00220143 57 PUSH EDI</font> <font color="gray"><br></font>  <font color="gray">00220144 FF55 0C CALL DWORD PTR SS: [EBP + C]</font> <font color="gray"><br></font>  <font color="gray">00220147 59 POP ECX</font> <font color="gray"><br></font>  <font color="gray">00220148 33C0 XOR EAX, EAX</font> <font color="gray"><br></font>  <font color="gray">0022014A 57 PUSH EDI</font> <br>  0022014B F3: AA REP STOS BYTE PTR ES: [EDI] <font color="red">&lt;- reset the main memory area of ‚Äã‚Äãthe process</font> <br>  <font color="gray">0022014D 5F POP EDI</font> <font color="gray"><br></font>  <font color="gray">0022014E 85F6 TEST ESI, ESI</font> <font color="gray"><br></font>  <font color="gray">00220150 74 08 JE SHORT 0022015A</font> <font color="gray"><br></font>  <font color="gray">00220152 85DB TEST EBX, EBX</font> <font color="gray"><br></font>  <font color="gray">00220154 74 04 JE SHORT 0022015A</font> <font color="gray"><br></font>  <font color="gray">00220156 8BCB MOV ECX, EBX</font> <br>  00220158 F3: A4 REP MOVS BYTE PTR ES: [EDI], BYTE PTR DS: [ESI] <font color="red">&lt;- Record New Section</font> <br>  <font color="gray">0022015A FF55 0C CALL DWORD PTR SS: [EBP + C]</font> <font color="gray"><br></font>  <font color="gray">0022015D 58 POP EAX</font> <font color="gray"><br></font>  <font color="gray">0022015E 61 POPAD</font> <font color="gray"><br></font>  <font color="gray">0022015F 83C7 28 ADD EDI, 28</font> <font color="gray"><br></font>  <font color="gray">00220162 ^ E2 B0 LOOPD SHORT 00220114</font> <br></blockquote><br>  At the very beginning, a section table is searched.  Next on the cycle is RawData and VirtualSize each section, resetting the main memory sections and writing new sections.  Thus, a new ‚Äúbody‚Äù of the current process is formed. <br><br>  Further we meet the procedure call: <br><blockquote>  <font color="gray">00220169 E8 AE000000 CALL 0022021C</font> <br></blockquote><br>  It performs IAT (Import Address Table) recovery at the beginning of the ".text" section.  The result of the procedure: <br><img src="https://habrastorage.org/files/373/f34/619/373f346193f248a69e4430f4209ccb66.png"><br><br>  Then, the memory is freed in which the data were previously stored to form a new process environment (0x00230000): <br><blockquote>  <font color="gray">002201BD FF55 14 CALL DWORD PTR SS: [EBP + 14];</font>  <font color="gray">kernel32.VirtualFree</font> <br></blockquote><br><br>  Come to the epilogue - extract OEP: <br><br><img src="https://habrastorage.org/files/322/d99/d6e/322d99d6ec10422d803f4dfc9b828692.png"><br><br>  And the transition to OEP: <br><br><img src="https://habrastorage.org/files/eab/3ed/b37/eab3edb3712e42e5a45af139a57ffe2e.png"><br><br>  We tell the debugger to analyze the code and get a beautiful and readable listing of the already unpacked downloader, in which the lines used to load the main function module are already distinguishable: <br><br><img src="https://habrastorage.org/files/37c/604/900/37c6049005574b8e80c690451899d28f.png"><br><br><h2>  General decryptor logic </h2><br><img src="https://habrastorage.org/files/9e5/ad2/673/9e5ad26732bd43cca9f66a024467d308.png"><br><br><ol><li>  Memory allocation with RWE rights, size 0x6D0 (1744 bytes) using HeapCreate.  Decryption and copying data from the .data section (0x00408E63 - 0x00409532) to the allocated memory; </li><li>  Transfer of code execution to zero offset of allocated memory; </li><li>  Search for necessary API functions and create an array with their addresses at offset 0x654 in the current memory area; </li><li>  Creating a new section of memory with RWE rights, of the same size 0x6D0 (1744 bytes) using VirtualAlloc.  Copying the contents of the current memory to a new one; </li><li>  Transfer of code execution to a new memory location at offset 0x81 using the ‚ÄúPUSH - RETN‚Äù method; </li><li>  Allocation of a new memory area of ‚Äã‚Äã0x2C00 (11 264 bytes) with RW rights; </li><li>  Open source file for reading.  Copying data (with file offset 0x6263 - 0x8E62) from a file to a new memory location; </li><li>  Decryption of copied data; </li><li>  Formation of a new process environment; </li><li>  Transition to OEP (0x004019BA). </li></ol><br><br><h2>  Process dump </h2><br>  It remains to make a process dump to get the executable unpacked virus file.  In order not to do manual fix after a dump, I used the OllyDumpEx plugin for Immunity Debugger: <br><br><img src="https://habrastorage.org/files/d05/659/0f7/d056590f7a454583871096b8b7a3495a.png"><br><br>  The resulting executable file at startup has the following structure: <br><br><img src="https://habrastorage.org/files/9ae/9f6/ffa/9ae9f6ffa5e140eca0d0573274835d3c.png"><br><br><h2>  Conclusion </h2><br>  In the course of the work done, they got the unpacked Downloader executable file.  Yes, it would be possible to shorten the description, going over the key points of copying and decrypting data and moving to OEP.  In combat conditions, when analyzing malware, they rarely understand the decryptor's logic in detail.  But let me remind you, the purpose of the article is to immerse in reversing and, as a bonus, understand how malware protectors work. <br><br>  The goal that I could not achieve in this article is the localization of the main points of the tread, which are responsible for the ‚Äúdeception‚Äù of the antivirus emulator.  These constructs are certainly present in the decryptor.  If someone tells you how to identify them, I will be grateful. <br><br>  In the second part of the article, we will look at the functional load of the Downloader and how the CTB-Locker cryptographer itself is launched.  I do not promise that it will appear the other day, because  I am limited in time, and I don‚Äôt deny my little experience in this field - I figure out with some points in the course of writing articles, which also takes time. </div><p>Source: <a href="https://habr.com/ru/post/257413/">https://habr.com/ru/post/257413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257401/index.html">We get acquainted with Fabric.js. Part 4</a></li>
<li><a href="../257403/index.html">The first 6 lectures of the online school Android developers</a></li>
<li><a href="../257405/index.html">Recognizing users' physical activity with examples on R</a></li>
<li><a href="../257407/index.html">We issue a digital certificate and verify the signature using BouncyCastle</a></li>
<li><a href="../257409/index.html">Discrete Fourier Transform of the Fractal Brownian Motion</a></li>
<li><a href="../257415/index.html">Typographer - the story continues</a></li>
<li><a href="../257417/index.html">120 servers in 30 days: tenders and other nuances of working with government agencies</a></li>
<li><a href="../257421/index.html">Interview about testing + screenshots of applications working in ReactOS, sent by testers</a></li>
<li><a href="../257425/index.html">Why not RemoteFX, as well as more information about NVIDIA GRID VGPU technology</a></li>
<li><a href="../257427/index.html">Adjustable power supply from ATX power supply to TL494. Part 1 - iron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>