<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ASP.NET application caching module</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When working on a large, high-load project, it is often necessary to cache a number of pages. This helps to reduce the load, eliminating the re-execut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ASP.NET application caching module</h1><div class="post__text post__text-html js-mediator-article">  When working on a large, high-load project, it is often necessary to cache a number of pages.  This helps to reduce the load, eliminating the re-execution of pages and, as a result, re-loading data.  Also a necessary condition is the ability to check the validity of the cache on a specific condition or set of conditions.  In principle, the task looks standard, but, as we will see later, its solution is far from trivial. <br><a name="habracut"></a><br><br>  After several hours of research, the following methods were found to solve this problem: <br><br>  1) Declarative declaration of the ‚ÄúOutputCache‚Äù directive on the page to be cached. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs">&lt;%@ OutputCache Duration=<span class="hljs-string"><span class="hljs-string">"600"</span></span> VaryByParam=<span class="hljs-string"><span class="hljs-string">"*"</span></span> VaryByCustom=<span class="hljs-string"><span class="hljs-string">"custom"</span></span> %&gt;</code> </pre> <br>  2) Setting the caching parameters of the Response.Cache object in the ‚ÄúcoudeBehind‚Äù page: <br><br><pre> <code class="cs hljs"> HttpCachePolicy policy = Response.Cache; policy.SetCacheability(HttpCacheability.Server); policy.SetExpires(app.Context.Timestamp.AddSeconds((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)<span class="hljs-number"><span class="hljs-number">600</span></span>)); policy.SetMaxAge(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeSpan(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>)); policy.SetValidUntilExpires(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); policy.SetLastModified(app.Context.Timestamp); policy.VaryByParams.IgnoreParams = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Both of these approaches have significant drawbacks, such as: <br><ul><li>  lack of flexibility </li><li>  the need to set parameters on each page </li></ul><br>  The first desire that arose in my analysis of the task was to create a universal caching module, which we will now do. <br><br>  First, you need to create a new project.  This will allow us to implement our module as a library, which will make it possible to connect it to various projects and make it absolutely universal. <br><br><h4>  Module implementation </h4><br>  Create a class ‚ÄúOutputCacheModule‚Äù implementing interface ‚ÄúIHttpModule‚Äù, and implement two methods ‚ÄúDispose‚Äù and ‚ÄúInit‚Äù.  In our case, the ‚ÄúDispose‚Äù method can be left without implementation, and the ‚ÄúInit‚Äù method will be considered closer. <br>  The ‚ÄúInit‚Äù method accepts ‚ÄúHttpApplication‚Äù, this allows you to access global application events, which you need to use by subscribing to several events of interest to us: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpApplication app</span></span></span><span class="hljs-function">)</span></span> { app.PreRequestHandlerExecute += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler(OnApplicationPreRequestHandlerExecute); app.PostRequestHandlerExecute += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler(OnPostRequestHandlerExecute); }</code> </pre><br>  The ‚ÄúPostRequestHandlerExecute‚Äù method is called immediately after the page being called or another handler has finished processing the request.  At this stage, we check a number of conditions and decide on the need for caching and add the necessary ‚Äúheaders‚Äù: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPostRequestHandlerExecute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { HttpApplication app = (HttpApplication)sender; Int32 duration = CacheHelper.GetCacheDuration(app.Context.Request); HttpCachePolicy policy = app.Response.Cache; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!InverseContext.User.IsAuthenticated &amp;&amp; duration &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { policy.SetCacheability(HttpCacheability.Server); policy.SetExpires(app.Context.Timestamp.AddSeconds(duration )); policy.SetMaxAge(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeSpan(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, duration )); policy.SetValidUntilExpires(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); policy.SetLastModified(app.Context.Timestamp); policy.VaryByParams[<span class="hljs-string"><span class="hljs-string">"*"</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { policy.SetCacheability(HttpCacheability.NoCache); policy.SetExpires(app.Context.Timestamp.AddSeconds(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } }</code> </pre><br>  This approach allows you to quite flexibly manage caching conditions and select the configuration required for each individual page, if necessary. <br><br>  And now we will return to the first method ‚ÄúPreRequestHandlerExecute‚Äù, which we deliberately missed, so as not to violate the linearity of the narration.  The ‚ÄúPreRequestHandlerExecute‚Äù method is called just before the page being called or another handler starts to execute the request.  And at this stage we need to specify the ‚Äúcallback‚Äù method to check the validity of the pages in our cache: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnApplicationPreRequestHandlerExecute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { HttpApplication app = (HttpApplication) sender; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!InverseContext.User.IsAuthenticated) { app.Context.Response.Cache.AddValidationCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpCacheValidateHandler(Validate), app); } }</code> </pre><br>  This entry means literally the following - every time a page in the cache is requested, the ‚Äúcallback‚Äù method will be called first, which will check all necessary conditions and either return the cached version of the page or initiate a new page processing cycle.  Let's look at the code for this method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Validate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context, Object data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HttpValidationStatus status</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InverseContext.User.IsAuthenticated) { status = HttpValidationStatus.IgnoreThisRequest; context.Response.Cache.AddValidationCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpCacheValidateHandler(Validate), <span class="hljs-string"><span class="hljs-string">"somecustomdata"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { status = HttpValidationStatus.Valid; } }</code> </pre><br>  In this example, a very simple condition is implemented; if the user is not logged in, he will get the page from the cache.  As you can see, the number of conditions is limited only by our needs.  But even in this method there is an aspect to which attention should be paid, namely: <br>  ‚ÄúHttpValidationStatus‚Äù - determines the status of cached data, has three possible values: <br><ul><li>  IgnoreThisRequest - the page will work again, but the version lying in the cache will remain valid. </li><li>  Invalid - the page will work again, the version in the cache will be recognized as not valid and will be replaced with a new one that has been worked out in this query. </li><li>  Valid - the cache is valid, the answer is the version of the page from the cache. </li></ul><br><br>  During the testing period, it will be convenient to get service information about the caching parameters that were actually set for this page.  To do this, in the ‚ÄúInit‚Äù method, you should additionally subscribe to the ‚ÄúApplication_EndRequest‚Äù event, since at this moment all stages of processing the request have already been completed, and theoretically, no one should change the ‚Äúheaders‚Äù anymore.  To display information, you can use a similar method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintServiceInformation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpApplication app</span></span></span><span class="hljs-function">)</span></span> { app.Context.Response.Write(<span class="hljs-string"><span class="hljs-string">"Rendered at "</span></span> + DateTime.Now + <span class="hljs-string"><span class="hljs-string">"&lt;br/&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cacheability = app.Context.Response.Cache.GetType().GetField(<span class="hljs-string"><span class="hljs-string">"_cacheability"</span></span>, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(app.Context.Response.Cache); app.Context.Response.Write(<span class="hljs-string"><span class="hljs-string">"HttpCacheability = "</span></span> + cacheability); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expires = app.Context.Response.Cache.GetType().GetField(<span class="hljs-string"><span class="hljs-string">"_utcExpires"</span></span>, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(app.Context.Response.Cache); app.Context.Response.Write(<span class="hljs-string"><span class="hljs-string">"&lt;br/&gt; UtcExpires = "</span></span> + expires); }</code> </pre><br>  There is no reflexion without magic here.  But this is only for the testing phase.  In the future, you should abandon the use of this method. <br><br><h5>  Microsoft's last witchcraft </h5><br>  1) Do not use the ‚ÄúResponce.Flush ()‚Äù method in places where caching is supposed to be used, since this method calls the ‚ÄúSetCacheability ()‚Äù method with the ‚ÄúHttpCacheability.Private‚Äù parameter while the site is running under the IIS server control, and rub it not possible (see point 2). <br><br>  2) The caching parameters in ASP.Net cannot be rubbed, because when you try to set ‚ÄúHttpCacheability‚Äù, the method performs a check <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_cacheabilityValues[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)cacheability] &lt; s_cacheabilityValues[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_cacheability])</code> </pre><br>  And ‚Äúenum‚Äù looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HttpCacheability { NoCache = <span class="hljs-number"><span class="hljs-number">1</span></span>, Private = <span class="hljs-number"><span class="hljs-number">2</span></span>, Server = <span class="hljs-number"><span class="hljs-number">3</span></span>, ServerAndNoCache = <span class="hljs-number"><span class="hljs-number">3</span></span>, Public = <span class="hljs-number"><span class="hljs-number">4</span></span>, ServerAndPrivate = <span class="hljs-number"><span class="hljs-number">5</span></span>, }</code> </pre> <br>  So it is impossible to deliver a larger value by ‚Äúint‚Äù than what is already worth it.  The ‚ÄúSetExpires‚Äù method works in the same way. </div><p>Source: <a href="https://habr.com/ru/post/150758/">https://habr.com/ru/post/150758/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150753/index.html">Results of the transformation contest</a></li>
<li><a href="../150754/index.html">CapsLock as an additional modifier</a></li>
<li><a href="../150755/index.html">Application Authorization</a></li>
<li><a href="../150756/index.html">OAuth2 Security</a></li>
<li><a href="../150757/index.html">ASN.1 in simple terms (REAL type encoding)</a></li>
<li><a href="../150759/index.html">An example of using macros in the mcedit editor</a></li>
<li><a href="../150760/index.html">Customizing radiobutton without js</a></li>
<li><a href="../150762/index.html">Zend Framework, subjective impressions</a></li>
<li><a href="../150763/index.html">Work in the style of Smart - or why we really love to work</a></li>
<li><a href="../150765/index.html">New data sources for Teiid, part 1: use DDL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>