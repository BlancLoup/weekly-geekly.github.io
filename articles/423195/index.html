<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in JPA 2.2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All the holiday! 

 It so suddenly happened that the start of the second group ‚ÄúJava Enterprise Developer‚Äù coincided with the 256th day of the year. C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in JPA 2.2</h1><div class="post__text post__text-html js-mediator-article">  All the holiday! <br><br>  It so suddenly happened that the start of the second group <a href="https://otus.pw/fTM4/">‚ÄúJava Enterprise Developer‚Äù</a> coincided with the 256th day of the year.  <s>Coincidence?</s>  <s>I do not think.</s> <br><br>  Well, we are sharing the penultimate interesting thing: what new JPA 2.2 brought - streaming of results, improved date conversion, new annotations are just a few examples of useful improvements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Go! <br><br>  The Java Persistence API (JPA) is a fundamental Java EE specification that is widely used in the industry.  Regardless of whether you are developing for the Java EE platform or for an alternative Java framework, JPA is your choice for saving data.  JPA 2.1 improved the specification, allowing developers to solve problems such as automatic generation of database schemas and efficient work with the procedures stored in the database.  The latest version, JPA 2.2, improves the specification based on these changes. <br>  In this article I will talk about the new functionality and give examples that will help start working with it.  As a sample, I use the ‚ÄúJava EE 8 Playground‚Äù project, which is on <a href="https://github.com/juneau001/JavaEE8-Playground">GitHub</a> .  The sample application is based on the Java EE 8 specification and uses the JavaServer Faces framework (JSF), Enterprise JavaBeans (EJB), and JPA for persistence.  To understand what this is about, you need to be familiar with JPA. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Using JPA 2.2</b> <br><br>  JPA 2.2 is part of the Java EE 8 platform. It is worth noting that only Java EE 8 compatible application servers provide a specification ready for use out of the box.  At the time of this writing (late 2017), there were quite a few such application servers.  However, using JPA 2.2 when using Java EE7 is easy.  First you need to download the appropriate JAR files using <a href="">Maven Central</a> and add them to the project.  If you use Maven in your project, add coordinates to the Maven POM file: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Then, choose the JPA implementation you want to use.  Starting with JPA 2.2, both EclipseLink and Hibernate have compatible implementations.  As examples in this article, I use <a href="">EclipseLink</a> , adding the following dependency: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  If you are using a Java EE 8 compatible server, such as GlassFish 5 or Payara 5, you should be able to specify the ‚Äúprovided‚Äù area for these dependencies in the POM file.  Otherwise, specify the ‚Äúcompile‚Äù area to include them in the project build. <br><br>  <b>Date and Time Support Java 8</b> <br><br>  Perhaps one of the most positively met additions is support for the Java 8 Date and Time API.  Since the release of Java SE 8 in 2014, developers have used workarounds to use the Date and Time API with JPA.  Although most workarounds are fairly simple, the need to add basic support for the updated Date and Time API has long been brewing.  JPA support for the Date and Time API includes the following types: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  For better understanding, first I will explain how the support for the Date and Time API works without JPA 2.2.  JPA 2.1 can only work with older date constructs, such as <code>java.util.Date</code> and <code>java.sql.Timestamp</code> .  Therefore, you need to use the converter to convert the date stored in the database into the old design, which is supported by the JPA 2.1 version, and then convert to the updated Date and Time API for use in the application.  The date converter to JPA 2.1, capable of such a conversion, may look something like the one shown in Listing 1. The converter in it is used to convert between <code>LocalDate</code> and <code>java.util.Date</code> . <br><br>  <i>Listing 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  In JPA 2.2, it is no longer necessary to write such a converter, since you are using the supported date-time types.  Support for these types is built-in, so you can simply specify the supported type in the class field of an entity without additional code.  The code snippet below demonstrates this concept.  Note that there is no need to add annotation to the <code>@Temporal</code> code, because type mapping happens automatically. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Since the supported date-time types are first class objects in JPA, they can be specified without additional ceremonies.  In JPA 2.1, the <code>@Temporal</code> annotation should be described in all permanent fields and properties such as <code>java.util.Date</code> and <code>java.util.Calendar</code> . <br><br>  It is worth noting that only some of the date-time types are supported in this version, but the attribute converter can be easily generated to work with other types, for example, to convert <code>LocalDateTime</code> to <code>ZonedDateTime</code> .  The biggest problem in writing such a converter is to determine how best to convert between different types.  To make things even easier, attribute converters can now be implemented.  I will give an example implementation below. <br><br>  The code in Listing 2 shows how to convert the time from <code>LocalDateTime</code> to <code>ZonedDateTime</code> . <br><br>  <i>Listing 2</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Specifically, this example is very straightforward, because <code>ZonedDateTime</code> contains methods that are easy to convert.  The conversion is done by calling the <code>toLocalDateTime()</code> method.  The inverse transform can be performed by calling the <code>ZonedDateTimeOf()</code> method and passing the <code>LocalDateTime</code> value along with <code>ZoneId</code> for use by the time zone. <br><br>  <b>Implemented Attribute Converters</b> <br><br>  Attribute converters were a very nice addition to JPA 2.1, as they allowed attribute types to be more flexible.  The JPA 2.2 update adds a useful ability to make attribute converters implemented.  This means that you can embed Contexts and Dependency Injection (CDI) resources directly into the attribute converter.  This modification is consistent with other CDI enhancements in Java EE 8 specifications, for example, with improved JSF converters, since they can now also use CDI embedding. <br><br>  To take advantage of this new feature, simply embed CDI resources in the attribute converter, as needed.  Listing 2 gives an example of an attribute converter, and now I will analyze it, explaining all the important details. <br><br>  The converter class must implement the <code>javax.persistence.AttributeConverter</code> interface by passing X and Y values. The X value corresponds to the data type in the Java object, and the Y value must match the column type of the database.  Then, the converter class should be annotated with <code>@Converter</code> .  Finally, the class must override the <code>convertToDatabaseColumn()</code> and <code>convertToEntityAttribute()</code> methods.  An implementation in each of these methods should convert values ‚Äã‚Äãfrom certain types and back to them. <br><br>  To automatically apply the converter each time the specified data type is used, add ‚Äúautomatic‚Äù, as in <code>@Converter(autoApply=true)</code> .  To apply a converter to a single attribute, use the @Converter annotation at the attribute level, as shown here: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  The converter can also be applied at the class level: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Suppose I want to encrypt the values ‚Äã‚Äãcontained in the <code>creditLimit</code> field of the <code>Customer</code> entity when it is saved.  To implement such a process, the values ‚Äã‚Äãmust be encrypted before being saved and decrypted after being extracted from the database.  This can be done with a converter and, using JPA 2.2, I can embed an encryption object in the converter to achieve the desired result.  Listing 3 is an example. <br><br>  <i>Listing 3</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  In this code, the process is performed by embedding the <code>CreditLimitEncryptor</code> class in the converter and its subsequent use to assist the process. <br><br>  <b>Streaming Query Results</b> <br><br>  Now you can easily take full advantage of the Java SE 8 streams features when working with query results.  Streams not only simplify reading, writing and maintaining code, but also help improve query performance in some situations.  Some stream implementations also help to avoid an excessively large number of requests for data at the same time, although in some cases using <code>ResultSet</code> pagination may work better than streams. <br><br>  To enable this feature, the <code>getResultStream()</code> method was added to the <code>Query</code> and <code>TypedQuery</code> .  This minor change allows JPA to simply return a result stream instead of a list.  Thus, if you are working with a large <code>ResultSet</code> , it makes sense to compare the performance between the new implementation of the threads and the scrollable <code>ResultSets</code> or pagination.  The reason is that the implementations of the threads extract all the records at the same time, save them to the list and then return.  Scrollable <code>ResultSet</code> and pagination techniques extract data in parts, which may be better for large data sets. <br><br>  Persistence providers may decide to override the new <code>getResultStream()</code> method <code>getResultStream()</code> improved implementation.  Hibernate already includes a stream () method that uses a scrollable <code>ResultSet</code> to parse the results of records instead of returning them completely.  This allows Hibernate to work with very large data sets and to do it well.  Other providers can be expected to override this method to provide similar features that benefit JPA. <br><br>  In addition to performance, the ability to stream results is a nice addition to JPA, which provides a convenient way to work with data.  I will demonstrate a couple of scenarios where this can be useful, but the possibilities themselves are endless.  In both scenarios, I request the <code>Job</code> entity and return the stream.  First, let's take a look at the following code, where I simply analyze the stream of <code>Jobs</code> for a specific <code>Customer</code> , calling the <code>Query</code> <code>getResultStream()</code> interface method.  Then, I use this stream to output the details regarding the <code>customer</code> and <code>work date</code> Job'a. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  This method can be slightly modified to return a list of results using the <code>Collectors .toList()</code> method as follows. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  In the following scenario, shown below, I find a <code>List</code> tasks related to pools of a particular form.  In this case, I return all tasks that match the form submitted as a string.  Similar to the first example, first I return a stream of <code>Jobs</code> records.  Then, I filter the records based on the form of the customer pool.  As you can see, the resulting code is very compact and easy to read. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  As I mentioned earlier, it is important to remember about performance in scenarios where large amounts of data are returned.  There are conditions in which threads are more useful in querying databases, but there are also those where they can cause performance degradation.  A good rule of thumb is that if data can be queried within a SQL query, it makes sense to do just that.  Sometimes the benefits of using elegant thread syntax do not outweigh the best performance that can be achieved using standard SQL filtering. <br><br>  <b>Support for Duplicate Annotations</b> <br><br>  When Java SE 8 was released, duplicate annotations became possible, allowing you to reuse the annotation in the declaration.  Some situations require the use of the same annotation on a class or field several times.  For example, there may be more than one <code>@SqlResultSetMapping</code> annotation for a given entity class.  In such situations, when re-annotation support is required, container annotation should be used.  Repeated annotations not only reduce the requirement to wrap collections of identical annotations in a container annotation, but can also make the code easier to read. <br><br>  It works like this: An annotation class implementation must be labeled with a <code>@Repeatable</code> meta-annotation to indicate that it can be used more than once.  The <code>@Repeatable</code> meta annotation accepts a container annotation class type.  For example, the <code>NamedQuery</code> annotation <code>NamedQuery</code> now marked with an <code>@Repeatable(NamedQueries.class)</code> annotation.  In this case, the container annotation is still used, but you don‚Äôt have to think about it when using the same annotation on the declaration or class, because <code>@Repeatable</code> abstracts this part. <br><br>  Let's give an example.  If you want to add more than one <code>@NamedQuery</code> annotation to an entity class in JPA 2.1, you need to encapsulate them inside the <code>@NamedQueries</code> annotation, as shown in Listing 4. <br><br>  <i>Listing 4</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  However, in JPA 2.2 everything is different.  Since <code>@NamedQuery</code> is a repeating annotation, it may appear in the entity class more than once, as shown in Listing 5. <br><br>  <i>Listing 5</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  List of duplicate annotations: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Conclusion</b> <br><br>  JPA 2.2 is a bit of a change, but the improvements included are significant.  Finally, JPA aligns with Java SE 8, allowing developers to use features such as the Date and Time API, streaming query results, and repeated annotations.  This release also improves consistency with CDI, adding the ability to embed CDI resources in attribute converters.  Now JPA 2.2 is available and is part of Java EE 8, I think you will enjoy using it. <br><br>  THE END <br><br>  As always, we are waiting for questions and comments. </div><p>Source: <a href="https://habr.com/ru/post/423195/">https://habr.com/ru/post/423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423185/index.html">Do not eat it! Useful 3D sugar printing</a></li>
<li><a href="../423187/index.html">Root and intermediate certificates of authorized Certification Authorities of Russia</a></li>
<li><a href="../423189/index.html">Research: half the companies patch vulnerabilities during the month - why?</a></li>
<li><a href="../423191/index.html">Launching elements of offshore platforms. Part 1</a></li>
<li><a href="../423193/index.html">Configure Web Push Notifications using pywebpush step by step</a></li>
<li><a href="../423197/index.html">LOLWUT: artwork in the DB team</a></li>
<li><a href="../423203/index.html">A cool team lead will be responsible for the service.</a></li>
<li><a href="../423205/index.html">Storage project on MS SQL Server, integration with 1C 7.7 and development automation in SSDT</a></li>
<li><a href="../423207/index.html">How to make an automatic update of the client online game</a></li>
<li><a href="../423209/index.html">Killer Form 2? MoonRay S100 3D Printer Review for Dentists</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>