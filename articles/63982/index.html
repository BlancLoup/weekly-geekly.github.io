<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Assignment task</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The problem of the best distribution of a certain number of works between the same number of performers. When solving it, an optimal assignment is sou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Assignment task</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="http://sac-coworking.com/wp-content/uploads/2008/09/officecubes1.jpg"><br>  The problem of the best distribution of a certain number of works between the same number of performers.  When solving it, an optimal assignment is sought from the condition of maximum overall performance, which is equal to the sum of the performers' performance.  The most effective method of solving it is the Hungarian method.  The assignment problem has many interpretations: the distribution of work between mechanisms, the distribution of targets between fire means to maximize the mathematical expectation of the number of targets hit or average damage, etc. <br><br><a name="habracut"></a><br><br><br><h3>  1. Task (wording). </h3><br>  We will be simpler (in terms).  =) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>Imagine a task:</strong> you need to effectively implement some relatively large project.  For the project was selected a team of first-class developers, versed in various fields.  And so lucky that there is information (accumulated statistics) about the degree (efficiency) of technology ownership for everyone.  But, unfortunately, there are not so many developers in the team, or rather, as many as there will be technologies used in the project. <br><br>  <strong>Necessary: ‚Äã‚Äãthe</strong> most effective way to use the largest number of technologies, assigning each developer their own task.  those.  optimally distribute among them the areas of responsibility for technology, taking into account their personal abilities. <br><br><h3>  2. Approach to the solution </h3><br><img align="left" src="http://img513.imageshack.us/img513/3580/pic1e.jpg">  <em>In the end, all words can be reduced to three words: people, product, and profits ¬©</em> .  If we try to depict the task set for us and the task on a piece of paper, then we will certainly get a similar illustration, as in the figure (with such <a href="http://www.pinvoke.com/">pictures</a> ). <br><br>  It turned out - the <strong>graph</strong> .  Vertices on the left are developers, vertices on the right are technologies (tasks).  The ribs that connect them - mean how much the developer understands it.  These numbers, i.e.  The degree of ownership of the developer of this technology is very important, but we turn to them a little later.  In the meantime, we have already correctly identified the direction in which this task is being effectively solved: <br><br><br><br><br><h3>  3. Counts </h3><br>  The very basics of the graphs were presented in the article ( <a href="http://habrahabr.ru/blogs/algorithm/61884/">max cost</a> ), so I will immediately turn to terminology relating to this task: <br><br>  <strong>A bipartite graph</strong> is a graph for which there is a partition of the set of vertices into two parts (parts) such that the ends of each edge belong to different parts.  There is also a clear separation in our task: some vertices are developers, others are tasks, and connections (efficiency of ownership) are only between developers and tasks. <br>  <strong>A mapping of</strong> an undirected graph G is a subset M of its edges E, chosen so that no two edges of M are adjacent, that is,  do not have a common vertex.  In terms of our task, synonym for this would be <em>‚Äúassignment‚Äù</em> , so that each involved developer takes on a separate task.  And it did not happen that two developers are working on one problem, or one ‚Äúpoor man‚Äù was responsible for two tasks. <br><br>  In graph theory, our problem, oddly enough, is called <em>the Assignment Task (MF)</em> .  =) It is a special case of the problem of finding the maximum matching.  In fact, we are trying to maximize the use of resources so that the maximum number of technologies is worked out at the same time, so in terms of graphs we are trying to find the ‚Äúmaximum matching‚Äù, to make up the maximum number of developer-task pairs. <br><br><h3>  4. Maximum matching </h3><br>  To simplify our lives, we are not paying attention to people's abilities.  Just want everyone to find a job.  Several first-hand developers to offer to work with the familiar technology will not be a problem.  Continuing in the same vein, we will distribute several more tasks, but the matching constructed in such a way is unlikely to be maximal.  The situation is possible as the one shown in the figure: <br><br><div style="text-align:center;"><img src="http://img172.imageshack.us/img172/130/pic2a.jpg"></div><br><br><h4>  How to increase matchings (appointments)? </h4><br>  Select an untapped developer who has not yet been assigned a task.  Let's see what he could handle, i.e.  familiar to him technology.  If you find a free one among them, great, this is what we were looking for.  Assign.  And if the task is already "busy" by another developer?  Let's try a busy developer to find another free technology, because in this case we would assign this to our unused ward.  In general, from the top of an untapped developer or developer to whom we are trying to reassign a task, we scan all the familiar technologies for the presence of a free one: <br><ul><li>  if you find a free one, the search is complete </li><li>  if the task has already been assigned to someone, then having passed along this edge of the matching, we will try to ‚Äúreassign‚Äù the technology to the developer participating in this assignment </li></ul><br>  In the course of such a traversal of the graph, we are trying to get into the "free task" from the "untapped developer".  Thus, the search "unfolds" in the following tree: <br><br><div style="text-align:center;"><img src="http://img509.imageshack.us/img509/4470/pic3y.jpg"></div><br><br>  Add some more terminology from graph theory, in simple words: <br><br>  <strong>An exposed vertex</strong> is a vertex that does not participate in the current matching.  Those.  either "untapped developer" or "free task". <br>  <strong>An alternating chain</strong> is a chain whose edges alternately lie or do not lie in a matching.  (... - technology ownership - assigned task - technology ownership - assigned task - ...) <br>  <strong>An alternating tree</strong> - a tree of alternating chains <br>  <strong>An augmental chain</strong> is such an alternating chain, the initial and final vertices of which are exposed.  This is what we are looking for!  =) <br>  <strong>An augmental tree</strong> is a tree, respectively, in which at least one of the branches is an augmental chain. <br><br>  So we found a way to increase matching, trying to get the maximum.  You need to build an altera-tree.  When it becomes augmental, look for augmental chains from the ‚Äúuntapped developer‚Äù to the ‚Äúfree task‚Äù and then ‚Äúreassign‚Äù the tasks along them.  It is beneficial because  increases the number of "tasks in processing" by 1: <br><br><div style="text-align:center;"><img src="http://img291.imageshack.us/img291/5084/pic4n.jpg"></div><br><br>  Now we can already use the most technologies in the project.  It's time to take into account another important condition of the problem we are facing: the efficiency of technology ownership.  We want to <strong>optimally</strong> assign tasks to all. <br><br><h3>  5. Hungarian method. </h3><br>  Find a solution with the maximum total efficiency (cost).  It sounds, in a sense, like the task of optimal packing of a backpack.  Makes me think.  Now, if we had the opportunity to act on the principle of "greedy algorithms." <br><br>  We would have to start all the developers to stop assigned tasks in accordance with their maximum abilities.  If all the developers managed to distribute the tasks right away - great.  But this does not happen often.  Suddenly two people optimally possess the same technology, who will get it and what to do in this situation?  One of the developers will need to find another free task, also the most appropriate to his abilities.  If under the current (maximum requirements) conditions there is no free problem, then we will need to try to find among the tasks, having a little underestimated our requirements.  How to artificially underestimate the ability of developers in the graph.  If under such conditions we find a free problem, we obtain an augmental tree.  "Change" in the matching chain, after which it will be +1.  And we will continue to appoint in such an optimal way until we find a job for everyone. <br><br><h4>  The strategy is clear. </h4><br>  We almost guessed the principle of the Hungarian algorithm.  But how can we build a solution based on the principle of ‚Äúgreedy algorithms‚Äù: assign to max abilities according to max abilities, then slightly lower the capabilities and add new tasks to the analysis, assign them to the limit, underestimate ... etc.?  How to assess the ability and optimality of the current assignment? <br><br>  The whole "trick" of this algorithm is as follows.  We are given only one parameter in the graph - the effectiveness of the solution of a specific task by the developer, which is indicated on the edges.  This value is assigned to the developer-task pairs.  We "divide" (separate from pairs) these values ‚Äã‚Äãby two.  Artificially add two additional parameters.  Some values ‚Äã‚Äãwill be assigned to task tops, others to developer tops. <br><br>  I will try to give this interpretation: <br><ul><li>  for developers, we indicate their <strong>‚Äúabilities‚Äù</strong> , let's say in units of ‚Äúforces‚Äù, simply indicating how effectively we can use them or use them. </li><li>  for tasks, we will indicate their <strong>‚Äúknowledge‚Äù</strong> , or, if I may say so, ‚Äúoversupply‚Äù.  This parameter will also be measured in the "force".  An overabundance of attention to the problem arises in the following situation.  If we are a developer ‚Äúunderloaded‚Äù, i.e.  he is able to solve a problem on 5, and he only got on 3. Then he still has 2 ‚Äúforces‚Äù that he, in principle, can devote to some of his familiar tasks.  To run between cabinets, advise on the phone, give advice to those who are engaged in his beloved technology. </li></ul><br><br><div style="text-align:center;"><img src="http://img403.imageshack.us/img403/6458/pic5f.jpg"></div><br><br>  Thus, the values ‚Äã‚Äãindicated on the edges we ‚Äúdivide‚Äù into 2 values ‚Äã‚Äãassigned to the vertices: the efficiency of the solution of the problem = the developer's ability + the knowledge of the problem.  In principle, it is logical.  The more capable the developer or the more well-known the technology, the better this part will be implemented in the project.  More effective. <br><br>  <em>In the end, after we find a solution, we will of course consider only the values ‚Äã‚Äãon the edges, but now this "trick" will help us find a solution.</em>  <em>=)</em> <br><br><h3>  6. Description of the algorithm </h3><br>  Initialize the graph.  Being ‚Äú <em>stubborn optimists</em> ‚Äù, for each developer we will calculate his maximum ‚Äúability‚Äù according to the technologies familiar to him, and assign this number to him.  <em>He is the best suited ¬©</em> .  Nothing is known about the tasks yet, therefore we initialize their ‚Äúknowledge‚Äù with zeros. <br><br>  When searching for a ‚Äúfree task‚Äù for an ‚Äúuntapped developer‚Äù, we now confine ourselves only to (we call them) the optimal edges of the graph, i.e.  those for which the equality is fulfilled: the <font>efficiency of the solution of the problem (edge) = the ability of the developer (vertex) + knowledge of the problem (vertex)</font> . <br><br><div style="text-align:center;"><img src="http://img30.imageshack.us/img30/5559/pic6h.jpg"></div><br><br>  Further, we do the same as in the search for the maximum matching.  We seize unused developers in turn and, looking for free tasks for them, we build an alternating tree (consisting of alternating chains), but only along the optimal edges.  Then there are 2 possible situations: <br><ul><li>  It was possible to find a free task.  The tree became augmental.  "Reassign" tasks, increasing the matching.  We begin to build the alternating tree again, because  you never know how the graph has changed </li><li>  We did not find (did not reach) the free problem on optimal edges.  And she is, because  After all, we started with a free developer, and in the graph we have the same number of tasks and developers.  The resulting alternating tree becomes the so-called <strong>Hungarian</strong> (the whole method is also called).  In this case, we will need to slightly lower our requirements for developers and start the search again.  <em>Failure is to intelligently (again) this time more intelligently (c)</em> . </li></ul><br><br><div style="text-align:center;"><img src="http://img403.imageshack.us/img403/1504/pic7a.jpg"></div><br><br>  That came to the last moment of the Hungarian method for which all these additional parameters and "abilities" were conceived.  Suppose that by building on the alternating tree, we ended up with a Hungarian tree.  Consider which vertices fall into this tree: <br><ul><li>  Uninvolved developers, because  it is with them that we begin to cost a tree </li><li>  Developers and tasks to which you can reach the optimal edges from unused developers.  Because  it is through their ‚Äúreassignment‚Äù that we are trying to employ the latter. </li></ul><br>  Outside this tree, in the remaining column will be present: <br><ul><li>  Developers and tasks that are in the matching, but inaccessible from free vertices (developers).  Found them work - there is nothing to touch them. </li><li>  Tasks that are unattainable by optimal edges - and we need to get to them.  Therefore, when building a tree, we will mark the peaks that we managed to hit.  And these tasks, accordingly, will remain unmarked. </li></ul><br>  Further in the cycle, we will run along the ‚Äúborder‚Äù of the tree: along those edges that connect unaffected developers or developers that are reachable from them (maybe they can be ‚Äúreassigned‚Äù) to adjacent tasks (along non-optimal edges).  For these edges, we calculate the currently minimal ‚Äúmismatch‚Äù of the developer‚Äôs abilities so that he can proceed to this task: <font>delta = min (developer‚Äôs ability (vertex) + task knowledge (vertex) - efficiency of problem solution (edge))</font> . <br><br><div style="text-align:center;"><img src="http://img30.imageshack.us/img30/5469/pic8w.jpg"></div><br><br>  Then inside the Hungarian tree we: <br><ul><li>  Reduce the ability of developers on delta to ‚Äújoin‚Äù in the least painless way, at least one edge to the alternating tree, which next time we will continue to search for a free task </li><li>  Let us increase the ‚Äúknowledge‚Äù of the tasks on delta, so that the edges of the already constructed augmental graph are optimal.  Those.  to maintain equality: the efficiency of solving the problem (edge) = the ability of the developer (vertex) + knowledge of the problem (vertex) </li></ul><br>  Mini-interpretation: we reduce the ability of developers to subsequently "attach" at least one of them.  We will attach it, but it will not work in accordance with their qualifications.  He could have more.  Therefore, he has released some amount of time to advise colleagues on the task in which he is most competent.  She becomes more studied in the team.  She, in turn, probably was engaged in another developer, who is now also able to be replaced in case of anything.  You can also reduce its competence on the study of the problem.  And so on, ‚Äúalong the chain‚Äù in the team, the ‚Äúknowledge‚Äù of the tasks increases and the developers' abilities to find some purpose for them are slightly reduced. <br><br><div style="text-align:center;"><img src="http://img262.imageshack.us/img262/9715/pic9s.jpg"></div><br><br>  Everything.  All steps of this method are considered.  We continue in the same vein ... <em>It is the courage to continue that counts</em> . <br><br><div style="text-align:center;"><img src="http://img403.imageshack.us/img403/2975/pic10s.jpg"></div><br><br><h3>  7. Algorithm words, very briefly. </h3><br>  Now let's collect everything to the heap: <br><ul><li>  Initialization.  To developers - max abilities.  Tasks - not studied. </li><li>  Not all developers have found the tasks yet. <ul><li>  So far it is possible to construct an augmental tree (to find free problems) along optimal edges. <ul><li>  "Reassign" tasks, increasing matching </li></ul></li><li>  Not achieved free task.  Hungarian tree. <ul><li>  We lower developers abilities by min </li></ul></li></ul></li></ul><br><br><h3>  8. Listing </h3><br>  The code, of course, will be shorter than all my description.  =) <br><br>  I took it <a href="http://e-maxx.ru/algo/assignment_hungary">here</a> .  In my opinion, very good implementation.  The only difference is that the author has a code for the method of minimizing appointments (if, for example, the salary is on the ribs), and in the article we distributed tasks in order to obtain maximum efficiency.  Therefore, slightly modifying the code, here is the implementation of the maximum method: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> n; <br> vector &lt; vector&lt; <font color="#0000ff">int</font> &gt; &gt; a; <font color="#008000">//   a[][]</font> <br> vector&lt; <font color="#0000ff">int</font> &gt; xy, yx; <font color="#008000">// : xy[], yx[]</font> <br> vector&lt; <font color="#0000ff">char</font> &gt; vx, vy; <font color="#008000">//   vx[], vy[]</font> <br> vector&lt; <font color="#0000ff">int</font> &gt; maxrow, mincol; <font color="#008000">// , </font> <br> <br> <font color="#0000ff">bool</font> dotry ( <font color="#0000ff">int</font> i) { <br> <font color="#0000ff">if</font> (vx[i]) <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> vx[i] = <font color="#0000ff">true</font> ; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j=0; j&lt;n; ++j) <br> <font color="#0000ff">if</font> (a[i][j]-maxrow[i]-mincol[j] == 0) <br> vy[j] = <font color="#0000ff">true</font> ; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j=0; j&lt;n; ++j) <br> <font color="#0000ff">if</font> (a[i][j]-maxrow[i]-mincol[j] == 0 &amp;&amp; yx[j] == -1) { <br> xy[i] = j; <br> yx[j] = i; <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j=0; j&lt;n; ++j) <br> <font color="#0000ff">if</font> (a[i][j]-maxrow[i]-mincol[j] == 0 &amp;&amp; dotry (yx[j])) { <br> xy[i] = j; <br> yx[j] = i; <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <br> <font color="#0000ff">int</font> main() { <br> <br> <font color="#008000">// ...  a ...</font> <br> <br> mincol.assign (n, 0); <br> minrow.assign (n, 0); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;n; ++i) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j=0; j&lt;n; ++j) <br> maxrow[i] = max (maxrow[i], a[i][j]); <br> <br> xy.assign (n, -1); <br> yx.assign (n, -1); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> c=0; c&lt;n; ) { <br> vx.assign (n, 0); <br> vy.assign (n, 0); <br> <font color="#0000ff">int</font> k = 0; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;n; ++i) <br> <font color="#0000ff">if</font> (xy[i] == -1 &amp;&amp; dotry (i)) <br> ++k; <br> c += k; <br> <font color="#0000ff">if</font> (k == 0) { <br> <font color="#0000ff">int</font> z = INF; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;n; ++i) <br> <font color="#0000ff">if</font> (vx[i]) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j=0; j&lt;n; ++j) <br> <font color="#0000ff">if</font> (!vy[j]) <br> z = min (z, maxrow[i]+mincol[j]-a[i][j]); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;n; ++i) { <br> <font color="#0000ff">if</font> (vx[i]) maxrow[i] -= z; <br> <font color="#0000ff">if</font> (vy[i]) mincol[i] += z; <br> } <br> } <br> } <br> <br> <font color="#0000ff">int</font> ans = 0; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;n; ++i) <br> ans += a[i][xy[i]]; <br> printf ( <font color="#A31515">"%d\n"</font> , ans); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;n; ++i) <br> printf ( <font color="#A31515">"%d "</font> , xy[i]+1); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h3>  9. Total </h3><br>  <font color="gray">If someone sees Hungarian for the first time.</font>  <font color="gray">And after reading the description, and the listing behind it, there will be a sure impression ‚Äúyes here on the listing and without these descriptions everything is clear that it was a rattle‚Äù.</font>  <font color="gray">I would still hope that at least in part the description added understanding to the operation of the algorithm.</font>  <font color="gray">I will be sincerely happy for you!</font>  <font color="gray">and in turn, it will give me a little sense that I wrote, probably, for good reason.</font>  <font color="gray">=)</font> <br><br></div><p>Source: <a href="https://habr.com/ru/post/63982/">https://habr.com/ru/post/63982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../63974/index.html">This text will disappear after 60 seconds.</a></li>
<li><a href="../63975/index.html">Russian-language video lectures</a></li>
<li><a href="../63976/index.html">The first screenshots of Google Chrome OS</a></li>
<li><a href="../63978/index.html">Neurons in action</a></li>
<li><a href="../63980/index.html">Buddofon</a></li>
<li><a href="../63983/index.html">Corner rounding on pure CSS with anti-aliasing</a></li>
<li><a href="../63984/index.html">Beer cartridge belt</a></li>
<li><a href="../63986/index.html">I'm a felon</a></li>
<li><a href="../63989/index.html">RAO against the use of music in football matches</a></li>
<li><a href="../63991/index.html">TouchScreen to the masses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>