<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Office lighting control over Wi-Fi. Part 2: Q-touch sensor technology</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue our ambitious ‚ÄúHello, World!‚Äù On the Atmel SAMD21 Xplained debug card, launched in the first part , which described the operation with the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Office lighting control over Wi-Fi. Part 2: Q-touch sensor technology</h1><div class="post__text post__text-html js-mediator-article">  We continue our ambitious ‚ÄúHello, World!‚Äù On the Atmel SAMD21 Xplained debug card, launched in the <a href="http://geektimes.ru/company/rainbow/blog/266368/">first part</a> , which described the operation with the WINC1500 Wi-Fi module. <br>  Today we will demonstrate an example of processing touch buttons and a slider using the Q-touch library. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/n-qHjWmsnro%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhilbFk24_ssyJjn6-AzvZbji0m0QA" frameborder="0" allowfullscreen=""></iframe><br>  In the third part of the cycle, as promised, the data from these sensors will be ‚Äúpacked‚Äù into the ModBus TCP package and transmitted via Wi-Fi to the lighting control system in our office. <a name="habracut"></a><br><br>  To begin with, let's see what kind of Q-touch.  This is the atmelovsky implementation of the processing technology of resistive touch buttons and sliders, followed by a library to simplify working with them.  And in all SAMD microcontrollers, a hardware Q-touch controller (so-called peripheral touch controller (PTC)) is implemented.  It allows both to minimize the number of used microcontroller pins and the load on the computational core. <br>  As sensors, we will use the <a href="http://www.atmel.com/tools/ATQT1-XPRO.aspx">ATQT1-XPRO</a> expansion module, which, as mentioned in the last article, can be installed on any debugging board from the Xplained Pro series. <br>  Qtouch technology supports the following types of sensors: buttons, sliders, rotors, and proximity detection. <br><img src="https://habrastorage.org/files/4da/9c4/df3/4da9c4df378946669da6e28a386f7951.png"><br><br><h4>  Qtouch and QMatrix Technologies </h4><br>  QTouch is based on measuring its own capacity, and QMatrix on measuring joint. <br>  Measurement using our own capacitance implies charging a sensitive electrode of unknown capacitance to a known potential.  The resulting charge is transferred to the measuring circuit.  Using charge-and-transfer cycles, you can measure the capacitance of a sensitive plate. <br>  Measurement using a joint capacitance is carried out using two electrodes.  One of the electrodes acts as an emitter, which takes charge, which is transmitted by logical pulses in a sequential (burst) mode.  The second electrode acts as a receiver, which communicates with the emitter through the dielectric from which the touch panel is made.  When a finger touches the panel, the joint field is reduced, and the touch is detected. <br><table><tbody><tr><th>  Qtouch </th><th>  Qmatrix </th></tr><tr><td>  Own capacity </td><td>  Joint capacity </td></tr><tr><td>  Reliable and simple electrode design </td><td>  Well defined pressure detection area </td></tr><tr><td>  Ideal for a small number of sensors. </td><td>  Ideal for a large number of sensors (more than 10) </td></tr><tr><td>  Good definition of approximation, at a greater distance </td><td>  Well adaptable to humidity and environment </td></tr><tr><td>  Any form of electrode is theoretically possible. </td><td>  Passive tracking - longer paths are possible. </td></tr><tr><td>  Easy to adjust sensitivity </td><td>  Well adaptable to noise and noise on the ground </td></tr></tbody></table><br>  In the SAMD20 and 21 series of controllers, QTouch / QMatrix technology is embedded.  The special unit that is responsible for it is the peripheral touch controller (PTC).  The scheme of the entire system is shown in the figure below. <br><img src="https://habrastorage.org/files/f95/fcd/433/f95fcd433f2c47dead136911ad041cfa.png"><br><h4>  Create a project </h4><br>  For the development of new periphery it is very convenient to use example projects.  And for QTouch there is also a special plugin QTouch Composer, which makes the development of visual.  But if you need to embed the touch buttons in an existing project, you need to understand the entire sequence of actions and settings.  Now this is what we do. <br>  The general scheme of the library is shown in the block diagram: <br><img src="https://habrastorage.org/files/def/421/503/def421503fe9446ca0a9405f81245107.png"><br>  We add to the project using a PTC and RTC wizard. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The configuration is configured in the file touch_config_samd.h.  Let's walk through the main parameters. <br>  First you need to choose the method of determining the touch: own capacity or joint.  The selection is made by setting the values ‚Äã‚Äãof the corresponding constants. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_TOUCH_MUTLCAP (1u) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_TOUCH_SELFCAP (0u)</span></span></code> </pre> <br>  The priority of interrupts from the PTC controller at the end of the conversion can be from 0 to 3 (0 is the highest priority).  And installed using defajna: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_TOUCH_PTC_ISR_LVL (1u)</span></span></code> </pre><br>  As mentioned above, to determine the touch using a joint capacitance, you need two lines: X and Y. The samd21 has 16 lines X and Y. In this case (using debugging with an expansion card) we have no choice on which pair of lines which button / slider / rotor wind up.  The order of specifying output pairs sets the channel numbers.  For a rotor / slider, it is imperative to use the same Y line for all channels.  The indication of lines is carried out using an appropriate define: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_NODES X(8), Y(10), X(9), Y(10), X(2), Y(12), X(3), Y(12), \ X(8), Y(12), X(9), Y(12), X(2), Y(13), X(3), Y(13), \ X(8), Y(13), X(9), Y(13)</span></span></code> </pre><br>  Specify the number of channels (for the button is always 1 channel, for the rotor / slider from 3 to 8).  In our case, 2 buttons and 4 channels per rotor and slider are used, a total of 10 channels: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_NUM_CHANNELS (10) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Total number of channels */</span></span></span></span></code> </pre><br>  Specify the number of sensors (we have 2 buttons, one slider and one rotor total 4): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_NUM_SENSORS (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Total number of sensors */</span></span></span></span></code> </pre><br>  Specify the number of rotors / sensors (we have one slider and one rotor total 2): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_NUM_ROTORS_SLIDERS (2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of rotor sliders */</span></span></span></span></code> </pre><br>  We proceed to the indication of the transformation parameters. <br>  The level of filtering affects the accuracy and speed of the conversion.  The higher the level (from 1 to 64), the more samples there are in 1 conversion, which improves the noise / signal ratio, but increases the conversion time. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_FILTER_LEVEL FILTER_LEVEL_32 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Filter level */</span></span></span></span></code> </pre><br>  Amplification of the signal from the sensors is configured per channel.  Values ‚Äã‚Äãrange from 1 to 32. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_GAIN_PER_NODE GAIN_1, GAIN_1, GAIN_1, GAIN_1, GAIN_1, \ GAIN_1, GAIN_1, GAIN_1, GAIN_1, GAIN_1</span></span></code> </pre><br>  Set the polling period in milliseconds. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_TOUCH_MEASUREMENT_PERIOD_MS 20u</span></span></code> </pre><br>  As for the mechanical buttons, for the touch has a kind of anti-bounce.  It lies in the fact that you specify during the course of measurement cycles the signal level must exceed the threshold level for detecting the touch of a button / rotor / slider. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_DI 4u</span></span></code> </pre><br>  It happens that some object touches the sensor for a long time.  In this case, it is necessary after some time to recalibrate the sensor taking into account the new working conditions.  To set the time after which the recalibration takes place, a special constant is used.  The time is set in units of 200 ms (i.e. a value of 5 corresponds to 1 second).  If the time is set to 0, then automatic recalibration will not be carried out. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_MAX_ON_DURATION 0u</span></span></code> </pre><br>  You can enable or disable debug output for Qtouch Analyzer: <br><pre> <code class="cpp hljs">&lt;cut /&gt;<span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_TOUCH_QDEBUG_ENABLE 0u</span></span></code> </pre><br>  For some strange reasons, Atmel did not include the standard PTC initialization functions (as with other peripherals) and the definition of several necessary constants.  Therefore, all this must be done independently.  What we now do. <br>  First of all, we need to initialize the RTC, because the interrupts from it will check the button triggering in our case.  We configure RTC, register callback, write code for callback.  RTC will generate interrupts every 1 ms, if as many ms have passed as we have an interval between reading the buttons, then set the appropriate flag, which will be checked in the main. <br>  Required Ads: <br><div class="spoiler">  <b class="spoiler_title">Timer Functions</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// RTC Interrupt timing definition #define TIME_PERIOD_1MSEC 33u /* ! QTouch Library Timing info. */ touch_time_t touch_time; volatile uint16_t touch_time_counter = 0u; struct rtc_module rtc_instance;  : void rtc_overflow_callback(void) { /* Do something on RTC overflow here */ if(touch_time_counter == touch_time.measurement_period_ms) { touch_time.time_to_measure_touch = 1u; touch_time.current_time_ms = touch_time.current_time_ms + touch_time.measurement_period_ms; touch_time_counter = 0u; } else { touch_time_counter++; } } void configure_rtc_callbacks(void) { /* register callback */ rtc_count_register_callback(&amp;rtc_instance, rtc_overflow_callback, RTC_COUNT_CALLBACK_OVERFLOW); /* Enable callback */ rtc_count_enable_callback(&amp;rtc_instance,RTC_COUNT_CALLBACK_OVERFLOW); } void configure_rtc_count(void) { struct rtc_count_config config_rtc_count; rtc_count_get_config_defaults(&amp;config_rtc_count); config_rtc_count.prescaler = RTC_COUNT_PRESCALER_DIV_1; config_rtc_count.mode = RTC_COUNT_MODE_16BIT; config_rtc_count.continuously_update = true; /* initialize rtc */ rtc_count_init(&amp;rtc_instance,RTC,&amp;config_rtc_count); /* enable rtc */ rtc_count_enable(&amp;rtc_instance); } void timer_init(void) { /* Configure and enable RTC */ configure_rtc_count(); /* Configure and enable callback */ configure_rtc_callbacks(); /* Set Timer Period */ rtc_count_set_period(&amp;rtc_instance,TIME_PERIOD_1MSEC); }</span></span></code> </pre><br></div></div><br>  Now you need to configure PTC itself.  First we add the necessary structures: <br><div class="spoiler">  <b class="spoiler_title">Structures for PTC</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">touch_mutlcap_config_t</span></span> mutlcap_config = { DEF_MUTLCAP_NUM_CHANNELS, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap number of channels. */</span></span> DEF_MUTLCAP_NUM_SENSORS, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap number of sensors. */</span></span> DEF_MUTLCAP_NUM_ROTORS_SLIDERS, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap number of rotors and sliders. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap GLOBAL SENSOR CONFIGURATION INFO. */</span></span> { DEF_MUTLCAP_DI, <span class="hljs-comment"><span class="hljs-comment">/* uint8_t di; Sensor detect integration (DI) limit. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Interchanging Negative and Positive Drift rate, since Signal increases on Touch. */</span></span> DEF_MUTLCAP_ATCH_DRIFT_RATE, <span class="hljs-comment"><span class="hljs-comment">/* uint8_t neg_drift_rate; Sensor negative drift rate. */</span></span> DEF_MUTLCAP_TCH_DRIFT_RATE, <span class="hljs-comment"><span class="hljs-comment">/* uint8_t pos_drift_rate; Sensor positive drift rate. */</span></span> DEF_MUTLCAP_MAX_ON_DURATION, <span class="hljs-comment"><span class="hljs-comment">/* uint8_t max_on_duration; Sensor maximum on duration. */</span></span> DEF_MUTLCAP_DRIFT_HOLD_TIME, <span class="hljs-comment"><span class="hljs-comment">/* uint8_t drift_hold_time; Sensor drift hold time. */</span></span> DEF_MUTLCAP_ATCH_RECAL_DELAY, <span class="hljs-comment"><span class="hljs-comment">/* uint8_t pos_recal_delay; Sensor positive recalibration delay. */</span></span> DEF_MUTLCAP_CAL_SEQ1_COUNT, DEF_MUTLCAP_CAL_SEQ2_COUNT, DEF_MUTLCAP_ATCH_RECAL_THRESHOLD, <span class="hljs-comment"><span class="hljs-comment">/* recal_threshold_t recal_threshold; Sensor recalibration threshold. */</span></span> }, { mutlcap_gain_per_node, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap channel gain setting. */</span></span> DEF_MUTLCAP_FREQ_MODE, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap noise counter measure enable/disable. */</span></span> DEF_MUTLCAP_CLK_PRESCALE, DEF_MUTLCAP_SENSE_RESISTOR, DEF_MUTLCAP_CC_CAL_CLK_PRESCALE, DEF_MUTLCAP_CC_CAL_SENSE_RESISTOR, mutlcap_freq_hops, DEF_MUTLCAP_FILTER_LEVEL, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap filter level setting. */</span></span> DEF_MUTLCAP_AUTO_OS, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap auto oversamples setting.*/</span></span> }, mutlcap_data_blk, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap data block index. */</span></span> PRIV_MUTLCAP_DATA_BLK_SIZE, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap data block size. */</span></span> mutlcap_xy_nodes, <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap channel nodes. */</span></span> DEF_MUTLCAP_QUICK_REBURST_ENABLE, DEF_MUTLCAP_FILTER_CALLBACK <span class="hljs-comment"><span class="hljs-comment">/* Mutual Cap filter callback function pointer. */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">touch_config_t</span></span> touch_config = { &amp;mutlcap_config, <span class="hljs-comment"><span class="hljs-comment">/* Pointer to Mutual Cap configuration structure. */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, DEF_TOUCH_PTC_ISR_LVL, <span class="hljs-comment"><span class="hljs-comment">/* PTC interrupt level. */</span></span> };</code> </pre><br></div></div><br>  Macros: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GET_MUTLCAP_SENSOR_STATE(SENSOR_NUMBER) p_mutlcap_measure_data-&gt; \ p_sensor_states[(SENSOR_NUMBER / \ 8)] &amp; (1 &lt;&lt; (SENSOR_NUMBER % 8))</span></span></code> </pre><br>  Defaults: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_CAL_SEQ1_COUNT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_CAL_SEQ2_COUNT 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_CC_CAL_CLK_PRESCALE PRSC_DIV_SEL_8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_CC_CAL_SENSE_RESISTOR RSEL_VAL_100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_MUTLCAP_QUICK_REBURST_ENABLE 1u #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PTC_APBC_BITMASK (1u &lt;&lt; 19u)</span></span></code> </pre><br>  Variables: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mutlcap_data_blk[PRIV_MUTLCAP_DATA_BLK_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mutlcap_xy_nodes[DEF_MUTLCAP_NUM_CHANNELS * <span class="hljs-number"><span class="hljs-number">2</span></span>] = {DEF_MUTLCAP_NODES}; <span class="hljs-keyword"><span class="hljs-keyword">gain_t</span></span> mutlcap_gain_per_node[DEF_MUTLCAP_NUM_CHANNELS]= {DEF_MUTLCAP_GAIN_PER_NODE}; <span class="hljs-keyword"><span class="hljs-keyword">freq_hop_sel_t</span></span> mutlcap_freq_hops[<span class="hljs-number"><span class="hljs-number">3u</span></span>] = {DEF_MUTLCAP_HOP_FREQS};</code> </pre><br>  PTC clocking configuration function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touch_configure_ptc_clock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">system_gclk_chan_config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gclk_chan_conf</span></span></span><span class="hljs-class">;</span></span> system_gclk_chan_get_config_defaults(&amp;gclk_chan_conf); gclk_chan_conf.source_generator = GCLK_GENERATOR_3; system_gclk_chan_set_config(PTC_GCLK_ID, &amp;gclk_chan_conf); system_gclk_chan_enable(PTC_GCLK_ID); system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, PTC_APBC_BITMASK); }</code> </pre><br>  Sensor configuration: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">touch_ret_t</span></span> touch_sensors_config(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">touch_ret_t</span></span> touch_ret = TOUCH_SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sensor_id_t</span></span> sensor_id; touch_ret = touch_mutlcap_sensor_config(SENSOR_TYPE_KEY, CHANNEL_0, CHANNEL_0, NO_AKS_GROUP, <span class="hljs-number"><span class="hljs-number">20u</span></span>, HYST_6_25, RES_8_BIT,<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;sensor_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touch_ret != TOUCH_SUCCESS) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); touch_ret = touch_mutlcap_sensor_config(SENSOR_TYPE_KEY, CHANNEL_1, CHANNEL_1, NO_AKS_GROUP, <span class="hljs-number"><span class="hljs-number">20u</span></span>, HYST_6_25, RES_8_BIT,<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;sensor_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touch_ret != TOUCH_SUCCESS) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); touch_ret = touch_mutlcap_sensor_config(SENSOR_TYPE_ROTOR, CHANNEL_6, CHANNEL_9, NO_AKS_GROUP, <span class="hljs-number"><span class="hljs-number">20u</span></span>, HYST_6_25, RES_8_BIT,<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;sensor_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touch_ret != TOUCH_SUCCESS) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); touch_ret = touch_mutlcap_sensor_config(SENSOR_TYPE_SLIDER, CHANNEL_2, CHANNEL_5, NO_AKS_GROUP, <span class="hljs-number"><span class="hljs-number">20u</span></span>, HYST_6_25, RES_8_BIT,<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;sensor_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touch_ret != TOUCH_SUCCESS) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (touch_ret); }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Initialization of sensors and common parameters</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">touch_ret_t</span></span> touch_sensors_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">touch_ret_t</span></span> touch_ret = TOUCH_SUCCESS; <span class="hljs-comment"><span class="hljs-comment">/* Setup and enable generic clock source for PTC module. */</span></span> touch_configure_ptc_clock(); touch_time.measurement_period_ms = DEF_TOUCH_MEASUREMENT_PERIOD_MS; <span class="hljs-comment"><span class="hljs-comment">/* Initialize touch library for Mutual Cap operation. */</span></span> touch_ret = touch_mutlcap_sensors_init(&amp;touch_config); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (touch_ret != TOUCH_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1u</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Check API Error return code. */</span></span> } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEF_TOUCH_QDEBUG_ENABLE == 1 QDebug_Init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* configure the touch library sensors. */</span></span></span><span class="hljs-meta"> touch_ret = touch_sensors_config(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch_ret != TOUCH_SUCCESS) { while (1u); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Check API Error return code. */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Auto Tuning setting for calibration. * * AUTO_TUNE_PRSC: When Auto tuning of pre-scaler is selected * the PTC uses the user defined internal series resistor setting * (DEF_MUTLCAP_SENSE_RESISTOR) and the pre-scaler is adjusted * to slow down the PTC operation to ensure full charge transfer. * * AUTO_TUNE_RSEL: When Auto tuning of the series resistor is * selected the PTC runs at user defined pre-scaler setting speed * (DEF_MUTLCAP_CLK_PRESCALE) and the internal series resistor is * tuned automatically to the optimum value to allow for full * charge transfer. * * AUTO_TUNE_NONE: When manual tuning option is selected (AUTO_TUNE_NONE), * the user defined values of PTC pre-scaler and series resistor is used * for PTC operation as given in DEF_MUTLCAP_CLK_PRESCALE and * DEF_MUTLCAP_SENSE_RESISTOR * */</span></span></span><span class="hljs-meta"> touch_ret = touch_mutlcap_sensors_calibrate(AUTO_TUNE_RSEL); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch_ret != TOUCH_SUCCESS) { while (1u); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Check API Error return code. */</span></span></span><span class="hljs-meta"> } return (touch_ret); }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Measurement and interrupt handler at the end of measurement</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touch_mutlcap_measure_complete_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEF_TOUCH_QDEBUG_ENABLE == 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Send out the Touch debug information data each time when Touch * measurement process is completed . * The Touch Signal and Touch Delta values are always sent. * Touch Status change, Rotor-Slider Position change and Sensor * Reference * values can be optionally sent using the masks below. */</span></span></span><span class="hljs-meta"> QDebug_SendData( TOUCH_CHANNEL_REF_CHANGE | TOUCH_ROTOR_SLIDER_POS_CHANGE | TOUCH_STATUS_CHANGE ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* QT600 two-way QDebug communication application Example. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Process any commands received from QTouch Studio. */</span></span></span><span class="hljs-meta"> QDebug_ProcessCommands(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(p_mutlcap_measure_data-&gt;acq_status &amp; TOUCH_BURST_AGAIN)) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Set the Mutual Cap measurement done flag. */</span></span></span><span class="hljs-meta"> p_mutlcap_measure_data-&gt;measurement_done_touch = 1u; } } touch_ret_t touch_sensors_measure(void) { touch_ret_t touch_ret = TOUCH_SUCCESS; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (touch_time.time_to_measure_touch == 1u) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Start a touch sensors measurement process. */</span></span></span><span class="hljs-meta"> touch_ret = touch_mutlcap_sensors_measure( touch_time.current_time_ms, NORMAL_ACQ_MODE, touch_mutlcap_measure_complete_callback); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((touch_ret != TOUCH_ACQ_INCOMPLETE) &amp;&amp; (touch_ret == TOUCH_SUCCESS)) { touch_time.time_to_measure_touch = 0u; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((touch_ret != TOUCH_SUCCESS) &amp;&amp;(touch_ret != TOUCH_ACQ_INCOMPLETE)) { while (1); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Reaching this point can be due to - * 1. The api has retured an error due to a invalid * input parameter. * 2. The api has been called during a invalid Touch * Library state. */</span></span></span><span class="hljs-meta"> } } return (touch_ret); }</span></span></code> </pre><br></div></div><br>  In main, you need to initialize the RTC timer, initialize PTC, configure sleep mode (if necessary), and enable global interrupts: <br><div class="spoiler">  <b class="spoiler_title">Initialization in main</b> <div class="spoiler_text">  system_interrupt_enable_global (); <br>  // Initialize timer.  (RTC actually <br>  timer_init (); <br>  // Initialize QTouch library and configure touch sensors. <br>  touch_sensors_init (); <br>  NVMCTRL-&gt; CTRLB.bit.SLEEPPRM = 3; <br>  system_set_sleepmode (SYSTEM_SLEEPMODE_STANDBY); <br></div></div><br>  Suppose, in the simplest case, we have LEDs touching the button and the position of the slider.  The rotor will not touch. <br>  In while (1) it is necessary to add the function of falling asleep (if necessary), the function of handling touch and ignition of the corresponding LEDs to indicate the touch: <br><div class="spoiler">  <b class="spoiler_title">Code for while (1)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Goto STANDBY sleep mode, unless woken by timer or PTC interrupt. system_sleep(); // Start touch sensor measurement, if touch_time.time_to_measure_touch flag is set by timer. touch_sensors_measure(); if ((p_mutlcap_measure_data-&gt;measurement_done_touch == 1u)) { p_mutlcap_measure_data-&gt;measurement_done_touch = 0u; // Get touch sensor states button1_state = GET_MUTLCAP_SENSOR_STATE(0); button2_state = GET_MUTLCAP_SENSOR_STATE(1); rotor_state = GET_MUTLCAP_SENSOR_STATE(2); slider_state = GET_MUTLCAP_SENSOR_STATE(3); if (button1_state) { if(button_pressed!=1) { port_pin_set_output_level(LED_8_PIN, 0); button_pressed=1; } } else { port_pin_set_output_level(LED_8_PIN, 1); if (button_pressed==1) { button_pressed=0; } } if (button2_state) { if(button_pressed!=2) { port_pin_set_output_level(LED_9_PIN, 0); button_pressed=2; } } else { port_pin_set_output_level(LED_9_PIN, 1); if (button_pressed==2) { button_pressed=0; } } // Clear all slider controlled LEDs port_pin_set_output_level(LED_0_PIN, 1); port_pin_set_output_level(LED_1_PIN, 1); port_pin_set_output_level(LED_2_PIN, 1); port_pin_set_output_level(LED_3_PIN, 1); port_pin_set_output_level(LED_4_PIN, 1); port_pin_set_output_level(LED_5_PIN, 1); port_pin_set_output_level(LED_6_PIN, 1); port_pin_set_output_level(LED_7_PIN, 1); // If slider is activated if(slider_state) { // Parse slider position slider_position = GET_MUTLCAP_ROTOR_SLIDER_POSITION(1); slider_position = slider_position &gt;&gt; 5u; switch(slider_position) { case 0: port_pin_set_output_level(LED_0_PIN, 0); break; case 1: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); break; case 2: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); break; case 3: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); break; case 4: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); break; case 5: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); port_pin_set_output_level(LED_5_PIN, 0); break; case 6: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); port_pin_set_output_level(LED_5_PIN, 0); port_pin_set_output_level(LED_6_PIN, 0); break; case 7: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); port_pin_set_output_level(LED_5_PIN, 0); port_pin_set_output_level(LED_6_PIN, 0); port_pin_set_output_level(LED_7_PIN, 0); break; default: port_pin_set_output_level(LED_0_PIN, 1); port_pin_set_output_level(LED_1_PIN, 1); port_pin_set_output_level(LED_2_PIN, 1); port_pin_set_output_level(LED_3_PIN, 1); port_pin_set_output_level(LED_4_PIN, 1); port_pin_set_output_level(LED_5_PIN, 1); port_pin_set_output_level(LED_6_PIN, 1); port_pin_set_output_level(LED_7_PIN, 1); break; } } }//measurement done flag</span></span></code> </pre><br></div></div><br>  Compile, fill, enjoy. </div><p>Source: <a href="https://habr.com/ru/post/275361/">https://habr.com/ru/post/275361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275347/index.html">Purple Encryption Machine</a></li>
<li><a href="../275351/index.html">Dynamic Interrupt Management in ARM</a></li>
<li><a href="../275353/index.html">HTML5 analog clock with JavaScript logic</a></li>
<li><a href="../275355/index.html">Anonymous Father Frost 2015-2016 - Post boasting New Year's gifts</a></li>
<li><a href="../275359/index.html">Office lighting control over Wi-Fi. Part 1: Atmel WINC1500 Wi-Fi Module</a></li>
<li><a href="../275369/index.html">USB bootloader on the microcontroller: firmware update from a flash drive</a></li>
<li><a href="../275371/index.html">Atmel Software Framework (ASF): how does it work?</a></li>
<li><a href="../275373/index.html">1-Wire slave on MK. Part 1: Iron</a></li>
<li><a href="../275375/index.html">Clocking Atmel microcontrollers SAMD20 / 21</a></li>
<li><a href="../275377/index.html">1-Wire slave on MK. Part 2: Implementing in code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>