<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic lights and shadows in my 2d game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am working on a game in the genre of stes-action, where shadows will play a big role in the gameplay. So I did dynamic lighting / shading using WebG...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic lights and shadows in my 2d game</h1><div class="post__text post__text-html js-mediator-article">  I am working on a game in the genre of stes-action, where shadows will play a big role in the gameplay.  So I did dynamic lighting / shading using WebGL shaders. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ZMyg5erp-vk%3Ffeature%3Doembed&amp;xid=17259,15700002,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhS9XDx02cE1IWfVtl_4RkODST9pg" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h3>  Part One: Dynamic Lighting </h3><br>  I was inspired to create it by a <a href="http://www.reddit.com/r/gamedev/comments/115f3y/how_to_dynamic_lighting_on_sprites/">post</a> on reddit, where aionskull used normal maps in Unity to dynamically illuminate their sprites.  And the user with the nickname gpillow posted in the comments that he did <a href="https://love2d.org/forums/viewtopic.php%3Ff%3D5%26t%3D11076">something similar</a> in Love2D.  Here is an <a href="">8-mb gif</a> with results.  For her, thanks to jusksmit. <br><br>  So what is dynamic lighting?  This is a technique in 3D graphics, where the light source illuminates objects on the scene.  Dynamic because it is updated in real time when the source moves.  Pretty standard thing in the 3D world and easily applicable to 2D, of course, if you can take advantage of shaders. <br><br>  You can make dynamic lighting knowing that the angle of incidence of light on the plane determines its illumination, and you can determine the illumination by recognizing the normal vector, which shows where the plane ‚Äúlooks‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/b92/126/469/b921264697fb1d775d01b7baf8179317.gif"><br><br>  In the picture above, this is an arrow sticking out from the center of the panel.  You can see that when the rays of light go at a large angle (to the normal), the panel is lit much worse.  So, in the end, the algorithm is quite simple - the larger the angle, the less light the panel receives.  The easiest way to calculate illumination is to calculate the scalar product between the vector from the light source and the normal vector. <br><br>  Ok, everything is very cool, but how to get the normal vectors in a 2d game?  Here, in general, there are no volumetric objects ... However, here additional textures (the same normal maps) can help us, in which the necessary information will be recorded.  I created 2 such maps for two houses in the video above and used them to calculate the lighting, here is an example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/71f/45e/fae71f45e48f4a8ccb1f79ee87b338fa.png" alt="image"><br><br>  In the beginning, you see a normal house sprite without shading.  On the second part of the picture is his normal map, encoding the normal vector in the texture color.  The vector has (x, y, z) coordinates, and the pixel of the texture has r, g, and b components, so it's normal to encode the normal: Take the front of the house, which faces south.  Its normal will be a vector with coordinates [x: 0, y: 0.5, z: 0].  <i>(For good, the normal should be equal to (0, 1, 0), but since we define the vector from -1 to +1, and it is necessary to encode in the range from 0 to 1, then, apparently, the author decided not to steam and immediately count normals from -0.5 to +0.5. approx. transl.)</i> <br><br>  RGB values ‚Äã‚Äãcannot be negative, so we move all values ‚Äã‚Äãto 0.5: [x: 0.5, y: 1, z: 0.5].  Well, RGB is usually represented in the number from 0 to 255, so we multiply by 255 and get [x: 128, y: 255, z: 128], or, in other words, the ‚Äúsouth‚Äù vector will be <a href="http://www.colorhexa.com/80ff80">this light green</a> on the normal map. <br><br>  Now that we have normals, we can let the graphics card do its magic. <br>  I use <a href="http://www.impactjs.com/">ImpactJS</a> , it has good compatibility with <a href="https://github.com/gameclosure/webgl-2d">WebGL2D</a> .  <i>(It is paid, I recommend pixi.js or any other graphics library with a webgl renderer. If you know more analogs - write in comments! Comment. Transl.)</i> Using WebGL2D we can easily add a pixel shader for lighting: <br><br><pre><code class="hljs mel">#ifdef GL_ES precision highp <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; #endif varying vec2 vTextureCoord; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 lightDirection; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec4 lightColor; void main(void) { <span class="hljs-comment"><span class="hljs-comment">//      vec4 rawNormal = texture2D(uSampler, vTextureCoord); //  -  ,    : if(rawNormal.a == 0.0) { gl_FragColor = vec4(0, 0, 0, 0); } else { //   RGB  ,    0..1  -0.5..+0.5 rawNormal -= 0.5; //    float lightWeight = dot(normalize(rawNormal.xyz), normalize(lightDirection)); lightWeight = max(lightWeight, 0.0); //     gl_FragColor = lightColor * lightWeight; } }</span></span></code> </pre> <br><br>  A couple of notes: We get pixel-by-pixel lighting, which is slightly different from the vertex lighting (usually in 3d).  There is no special choice, since the vertices in 2d are meaningless (there are only 4 of them to display the plane on the stage).  But, in general, this is not a problem, per-pixel lighting is much more accurate.  It should also be noted that the shader renders only the lighting, without the main sprite.  I‚Äôll have to admit, I‚Äôm cheating a little, because in fact I don‚Äôt light up my sprite, but rather shade it and in <b>lightColor</b> I give it a dark gray color.  True pixel illumination, namely increased brightness, looks worse; pixels appear to be wiped out.  This problem has solutions, but now it is not fundamental. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad3/287/678/ad3287678e9e57c5b2b8063bc0df6fb8.png" alt="image"><br><br><h3>  Part two: drawing shadows. </h3><br>  Dropping shadows in 3D is a well-studied problem with well-known solutions, such as <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25B9">ray tracing</a> or <a href="http://en.wikipedia.org/wiki/Shadow_mapping">shadow-mapping</a> .  However, I found it difficult to find any acceptable ready-made solution for 2d, I had to do it myself, I think it turned out fine, although it also has a couple of flaws. <br><br>  In short, we will draw a line from the pixel on the stage to the sun and check if there is any obstacle.  If there is - then a pixel in the shadow, if not - in the sun, so, in principle, nothing complicated. <br><br>  The shader takes <b>xyAngle</b> and <b>zAngle</b> , which are responsible for where the sun is.  Since it is very far away, the rays of light will be parallel, and, accordingly, these two angles will be the same for all pixels.  Also, the shader will receive a <b>map of the heights of the</b> world.  It will show the height of all objects, buildings, trees, etc.  If the pixel belongs to the building, then the pixel value will be approximately 10, and it means that the height of the building at this point is 10 pixels. <br><br>  So, the shader will start in the pixel that needs to be illuminated and, using the <b>xyAngle</b> vector, will move towards the sun in small steps.  On each of them we will check if there is anything in this pixel of the height map. <br><img src="https://habrastorage.org/getpro/habr/post_images/116/3b3/7fe/1163b37fecb0bc55b4578dafe7de548e.gif" alt="image"><br>  As soon as we find an obstacle, we will determine its height, and how high it must be at a given point in order to block the sun (using <b>zAngle</b> ). <br><img src="https://habrastorage.org/getpro/habr/post_images/1fd/008/4e5/1fd0084e5de0874c81df5f6bf2a21ec6.gif" alt="image"><br>  If the value in the height map is larger, then everything is a pixel in the shadow.  If not, we will continue to search.  But sooner or later we will give up and declare that the pixel is lit by the sun.  In the example, I zahardkodil 100 steps, while it works fine. <br><br>  Here is the shader code in simplified / pseudo form: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isInShadow()) { alpha = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, alpha); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isInShadow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height = getHeight(currentPixel); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; ++i) { distance += moveALittle(); vec2 otherPixel = getPixelAt(distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> otherHeight = getHeight(otherPixel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(otherHeight &gt; height) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> traceHeight = getTraceHeightAt(distance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(traceHeight &lt;= otherHeight) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><br>  And here is the whole code: <br><br><pre> <code class="hljs mel">#ifdef GL_ES precision highp <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; #endif vec2 <span class="hljs-keyword"><span class="hljs-keyword">extrude</span></span>(vec2 other, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">angle</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> length) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = length * <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">angle</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = length * <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">angle</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec2(other.x + x, other.y + y); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> getHeightAt(vec2 texCoord, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xyAngle, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance, sampler2D heightMap) { vec2 newTexCoord = <span class="hljs-keyword"><span class="hljs-keyword">extrude</span></span>(texCoord, xyAngle, distance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture2D(heightMap, newTexCoord).r; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> getTraceHeight(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zAngle, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance * <span class="hljs-keyword"><span class="hljs-keyword">tan</span></span>(zAngle) + height; } bool isInShadow(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xyAngle, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zAngle, sampler2D heightMap, vec2 texCoord, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> otherHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> traceHeight; height = texture2D(heightMap, texCoord).r; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; ++i) { distance = step * <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(i); otherHeight = getHeightAt(texCoord, xyAngle, distance, heightMap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(otherHeight &gt; height) { traceHeight = getTraceHeight(height, zAngle, distance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(traceHeight &lt;= otherHeight) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> true; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> false; } varying vec2 vTextureCoord; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uHeightMap; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uXYAngle; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uZAngle; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uMaxShadowSteps; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTexStep; void main(void) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isInShadow(uXYAngle, uZAngle, uHeightMap, uMaxShadowSteps, vTextureCoord, uTexStep)) { alpha = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, alpha); }</code> </pre><br><br>  In uTexStep recorded the length of the step to check the pixels.  Usually, 1 / heightMap.width or 1 / heightMap.height is enough, because in OpenGL the texture coordinates are from 0 to 1, so 1 / resolution will give us the size of one pixel. <br><br><h3>  Conclusion </h3><br>  In truth, there are a few small details that I omitted in the code above, but the basic idea should be clear.  <i>(For example, the idea that the height map! = The normal map reached me only now. Approx. Transl.).</i>  In this method there is a big drawback associated with the fact that each pixel on the scene can have only one height.  Therefore, for example, there are difficulties with trees.  The engine will not be able to correctly display the shadow from them in the form of a thin trunk and a magnificent crown - there will be either thick cylindrical shadows or thin sticks from the trunks, because the void between the leaves and the ground is not recorded in the height map. <br><br><img src="http://www.mattgreer.org/articles/dynamic-lighting-and-shadows/shadow1.png"><img src="http://www.mattgreer.org/articles/dynamic-lighting-and-shadows/shadow2.png" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/272427/">https://habr.com/ru/post/272427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272417/index.html">How to cope with problems in an inherited project after 3 other teams</a></li>
<li><a href="../272419/index.html">Alloy Navigator: Co-pilot for IT Infrastructure</a></li>
<li><a href="../272421/index.html">Acquaintance with the programming language Deluge. Creating an arbitrary function in the Zoho CRM system</a></li>
<li><a href="../272423/index.html">Experience of developing an arcade for Android in C ++ and Qt</a></li>
<li><a href="../272425/index.html">Development of trading systems for FPGA: Pros, cons and analysis of the architecture of the existing library</a></li>
<li><a href="../272429/index.html">Moore's Law and Storage Technology</a></li>
<li><a href="../272431/index.html">Mobile search inside apps ... which you don't have!</a></li>
<li><a href="../272433/index.html">Software overview and demonstration - HP ONE VIEW and HP Data Protector</a></li>
<li><a href="../272435/index.html">Review of Managing HP 3PAR StoreServ technologies in the MUK classroom</a></li>
<li><a href="../272441/index.html">12 tips for those who want to get a PMP certificate (Project Management Professional)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>