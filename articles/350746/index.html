<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift vs. Kotlin. Differences are important</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is a free translation of the article Swift vs. Kotlin - the differences that matter by Krzysztof Turek 


 You have probably seen this compa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift vs. Kotlin. Differences are important</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/6n/qu/4p6nqu3uwvhhnx3uxypdz-0bm3y.jpeg"></div><br><p>  <em>This post is a free translation of the article <a href="https://blog.indoorway.com/swift-v-kotlin-the-differences-that-matter-50b2d393f526">Swift vs.</a></em>  <em><a href="https://blog.indoorway.com/swift-v-kotlin-the-differences-that-matter-50b2d393f526">Kotlin - the differences that matter</a> by <a href="https://blog.indoorway.com/%40kturek">Krzysztof Turek</a></em> </p><br><p>  <b>You have probably seen this comparison between Swift and Kotlin: <a href="http://nilhcem.com/swift-is-like-kotlin/">http://nilhcem.com/swift-is-like-kotlin/</a> .</b>  <b>Pretty interesting, right?</b>  <b>I agree that there are many similarities in these languages, but in this article I will focus on some aspects that still separate them.</b> </p><br><p><a name="habracut"></a>  I have been developing Android since 2013 and most of the time I developed Java applications.  Recently, I also had the opportunity to try iOS and Swift.  I was impressed that Swift was able to write very cool code.  If you make an effort, your code will be like a poem. </p><br><p>  After seven months, I returned to Android.  But instead of Java, I began to code on Kotlin.  Google announced on Google IO 2017 that Kotlin is now the official language for Android.  And I decided to teach him.  It did not take me long to notice the similarities between Kotlin and Swift.  But I would not say that they are very similar.  Below I will show the differences between them.  I will not describe everything, but only those that are interesting to me.  Consider the examples. </p><br><h1>  Structures vs.  Data classes.  Values ‚Äã‚Äãand references </h1><br><p>  Structures and Data Classes are simplified versions of classes.  They are similar in use, it looks like this </p><br><p>  Kotlin: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  Swift: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><p>  But the class is still a class.  This type is passed by reference.  But the structure - by value.  "So what?"  you ask.  I will explain with an example. </p><br><p>  Let's create our data class in Kotlin and the structure in Swift, and then compare the results. </p><br><p>  Kotlin: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo1 = Foo(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo2 = foo1 foo1.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Swift: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo1 = Foo(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo2 = foo1 foo1.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  What is <b>data</b> for <b>foo2</b> in both cases?  Answer 4 for the Kotlin data class and 2 for the structure on Swift. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/sx/5l/kxsx5l-4jc9amnu6nk8fettbi_m.png"></div><br><p>  The results are different, because <em>var foo2 = foo1</em> in Swift creates a copy of the structure instance (more detailed <a href="https://developer.apple.com/swift/blog/%3Fid%3D10">here</a> ), and in Kotlin another link to the same object ( <a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value/40523">more detailed here</a> ) </p><br><p>  If you're working with Java, you're probably familiar with the <em>Defensive Copy</em> pattern.  If not - we catch up.  <a href="http://www.javapractices.com/topic/TopicAction.do%3FId%3D15">Here</a> you will find more information on the topic. </p><br><p>  In general: there is the possibility of changing the state of an object from inside or outside.  The first option is preferable and more common, but the second is not.  Especially when you work with a reference type and do not expect changes in its state.  This can complicate the search for bugs.  To prevent this problem, you should create a protected copy of the mutable object before transferring it to somewhere.  Kotlin is much more useful in such situations than Java, but through negligence problems can still arise.  Consider a simple example: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Page</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Book</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pages</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MutableList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Page</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutableListOf</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Page</span></span></span><span class="hljs-class">(‚Äú</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Chapter</span></span></span><span class="hljs-class"> 1‚Äù), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Page</span></span></span><span class="hljs-class">(‚Äú</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Chapter</span></span></span><span class="hljs-class"> 2‚Äù)) }</span></span></code> </pre> <br><p>  I declared <em>pages</em> as <em>MutableList</em> , because I want to change them inside this object (add, delete, etc.).  <em>Pages are</em> not <em>private</em> , because I need access to their state from the outside.  So far, everything is going fine. </p><br><pre> <code class="hljs lisp">val book = Book() print(‚Äú$book‚Äù) // Book(<span class="hljs-name"><span class="hljs-name">pages=</span></span>[Page(<span class="hljs-name"><span class="hljs-name">title=Chapter</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>), Page(<span class="hljs-name"><span class="hljs-name">title=Chapter</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)])</code> </pre> <br><p>  Now I have access to the current state of the book: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bookPages = book.pages</code> </pre> <br><p>  I add a new page in <em>bookpages</em> : </p><br><pre> <code class="hljs cs">bookPages.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Page(‚ÄúChapter <span class="hljs-number"><span class="hljs-number">3</span></span>‚Äù))</code> </pre> <br><p>  Unfortunately, I also changed the state of the source book.  And this is not what I wanted. </p><br><pre> <code class="hljs lisp">print(‚Äú$book‚Äù) // Book(<span class="hljs-name"><span class="hljs-name">pages=</span></span>[Page(<span class="hljs-name"><span class="hljs-name">title=Chapter</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>), Page(<span class="hljs-name"><span class="hljs-name">title=Chapter</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>), Page(<span class="hljs-name"><span class="hljs-name">title=Chapter</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)])</code> </pre> <br><p>  We can use a protected copy to avoid this.  It is very easy in Kotlin. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">book</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pages</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.toMutableList</span></span>()</code> </pre> <br><p>  Now we are fine.  :) </p><br><p>  And what about Swift?  Everything works out of the box.  Yes, arrays are structures.  Structures are passed by value, as we mentioned above, so when you write: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bookPages = book.pages</code> </pre> <br><p>  You are working with a copy of the list of pages. </p><br><p>  Thus, we are dealing with data transfer by value.  This is very important for understanding differences, if you do not want to experience a headache during debugging.  :) Many "objects" are structures in Swift, for example Int, CGPoint, Array, etc. </p><br><h1>  Interfaces and Protocols and Extensions </h1><br><p>  This is my favorite topic.  : D </p><br><p>  Let's start by comparing the interface and protocol.  In principle, they are identical. </p><br><ul><li>  Both may require the implementation of certain methods in the class / structure; </li><li>  Both may require the declaration of a specific property.  The property can be read / write or read only. </li><li>  Both * allow you to add a default implementation of the method. </li></ul><br><p>  In addition, protocols may require a specific initializer (constructor in Kotlin). </p><br><p>  Kotlin: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVariable: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myReadOnlyProperty: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethodWithBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// implementation goes here } }</span></span></code> </pre> <br><p>  Swift: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(parameter: <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVariable: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myReadOnlyProperty: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethodWithBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethodWithBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// implementation goes here } }</span></span></code> </pre> <br><p>  * Please note that you cannot add the default implementation of the method directly inside the protocol.  That's why I added a star to the last item in the list.  You need to add an extension for this.  And this is a good way to go to the more interesting part - extensions! </p><br><p>  Extensions allow you to add functionality to existing classes (or structures;)) without inheriting them.  It is so simple.  Agree, this is a cool opportunity. </p><br><p>  This is something new for Android developers, so we like to use it all the time!  Create extensions in Kotlin - do not launch rockets into space. </p><br><p>  You can create extensions for properties: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Calendar.yearAhead: Calendar <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(Calendar.YEAR, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre> <br><p>  or for functions: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Context.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDrawableCompat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@DrawableRes</span></span></span></span><span class="hljs-function"><span class="hljs-params"> drawableRes: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Drawable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ContextCompat.getDrawable(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, drawableRes) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NullPointerException(<span class="hljs-string"><span class="hljs-string">"Can not find drawable with id = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$drawableRes</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><p>  As you can see, we have not used any keywords here. </p><br><p>  Kotlin has some predefined extensions that are quite steep, for example "orEmpty ()" for optional strings: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maybeNullString: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span> titleView.setText(maybeNullString.orEmpty())</code> </pre> <br><p>  This useful extension looks like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ?: <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br><p>  '?:' tries to get a value from 'this' (which is the current value of our string).  If there is a null, an empty string will be returned instead. </p><br><p>  So, now let's look at the Swift extensions. </p><br><p>  They have the same definition, so I will not repeat as a broken record. </p><br><p>  If you search for an extension like "orEmpty ()", I have bad news for you.  But you can add it, right?  Let's try! </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">? </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ?? <span class="hljs-string"><span class="hljs-string">""</span></span> } }</code> </pre> <br><p>  but here's what you see: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ab/yj/ir/abyjir8cuw2rurddg5bdfx9cepo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/bw/iq/w2bwiqnktjtzrujxb3roc9mukeq.png"></div><br><p>  The optional in Swift is a generic enumeration, with a given type of <b>Wrapped</b> .  In our case, <b>Wrapped</b> is a string, so the extension will look like this: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optional</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .some(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> } } }</code> </pre> <br><p>  and in </p><br><pre> <code class="hljs lisp">let page = Page(<span class="hljs-name"><span class="hljs-name">text</span></span>: maybeNilString.orEmpty())</code> </pre> <br><p>  It looks harder than the Kotlin counterpart, right?  And, unfortunately, there is also a disadvantage.  As you know, the option in Swift is a generic enumeration, so your extension will be available for all optional types.  It doesn't look very good: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9l/u4/qb/9lu4qb5s7mhreggihvw26i16svi.png"></div><br><p>  However, the compiler will protect you and will not compile this code.  But if you add more of these extensions, your self-help will be littered with garbage. </p><br><p>  So Kotlin extensions are more convenient than Swift?  I would say that Swift extensions are meant for other purposes;).  Android developers, hold on! </p><br><p>  Protocols and extensions are created to work together.  You can create your own protocol and extension for the class to match this protocol.  It sounds crazy, but that's not all!  There is such a thing as <em>conditional compliance with the protocol</em> .  This means that a class / structure may conform to the protocol when certain conditions are met. </p><br><p>  Suppose we have a lot of places where you need to show a pop-up alert.  We like the principle of DRY and we do not want copy-paste code.  We can solve this problem using protocol and extension. </p><br><p>  First, create a protocol: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlertPresentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentAlert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: String)</span></span></span></span> }</code> </pre> <br><p>  Then, the extension with the default implementation: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlertPresentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentAlert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> alert = <span class="hljs-type"><span class="hljs-type">UIAlertController</span></span>(title: ‚Äú<span class="hljs-type"><span class="hljs-type">Alert</span></span>‚Äù, message: message, preferredStyle: .alert) alert.addAction(<span class="hljs-type"><span class="hljs-type">UIAlertAction</span></span>(title: ‚Äú<span class="hljs-type"><span class="hljs-type">OK</span></span>‚Äù, style: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, handler: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) } }</code> </pre> <br><p>  So, the presentAlert method only creates an alert, but does not show anything.  We need a link to the view controller for this.  Can we pass it as a parameter to this method?  Not a good idea.  Let's use the where condition! </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlertPresentable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentAlert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> alert = <span class="hljs-type"><span class="hljs-type">UIAlertController</span></span>(title: ‚Äú<span class="hljs-type"><span class="hljs-type">Alert</span></span>‚Äù, message: message, preferredStyle: .alert) alert.addAction(<span class="hljs-type"><span class="hljs-type">UIAlertAction</span></span>(title: ‚Äú<span class="hljs-type"><span class="hljs-type">OK</span></span>‚Äù, style: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, handler: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.present(alert, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre> <br><p>  What do we have here?  We have added a specific requirement for expanding our protocol.  It is intended only for UIViewController.  Because of this, we can use the UIViewController methods in the presentAlert method.  This allows us to display an alert on the screen. </p><br><p>  Go ahead: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlertPresentable</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Now all UIViewController has a new feature: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/ev/i0/uhevi0yqdjfunuehdztls-qo5zs.png"></div><br><p>  Also, a combination of protocols and extensions is very useful for testing.  Guys, how many times have you tried to test the Android final class in your application?  This is not a problem for Swift. </p><br><p>  Look at this situation and assume that we have a final class in Swift.  If we know the method signature, we can create a protocol with the same method, and then add an extension that implements this protocol to our final class, and voila!  Instead of using this class directly, we can use the protocol and easily test it.  Sample code instead of a thousand words. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameworkMap</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ‚Ä¶ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSomethingOnMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">: FrameworkMap)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.drawSomething() } }</code> </pre> <br><p>  In the test, we need to check whether the drawSomething method is called on the map object when the drawSomethingOnMap method is tested.  This can be difficult even with the Mockito (a well-known test library for Android).  But with protocol and extension, it will look like this: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameworkMap</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  And now your drawSomethingOnMap method uses a protocol instead of a class. </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSomethingOnMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Map)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.drawSomething() } }</code> </pre> <br><h1>  Sealed classes - listing on steroids </h1><br><p>  Finally, I would like to mention the listings. </p><br><p>  There are no differences between Java transfers and Kotlin transfers, so there is nothing to add here.  But we have something new in return, and these ‚Äúsuper-listings‚Äù are sealed classes.  Where does the term "super-listing" come from?  Refer to the <a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Kotlin documentation</a> : </p><br><blockquote>  <i>"... They are, in a sense, extensions for enum classes: the set of possible values ‚Äã‚Äãfor enums is also limited, but each enum constant exists only in a single instance, while the heir to the sealed class can have many instances that can store state . "</i> </blockquote><p>  Okay, cool, they can keep state, but how can we use it? </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderStatus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AwaitPayment</span></span></span><span class="hljs-class"> </span></span>: <span class="hljs-type"><span class="hljs-type">OrderStatus</span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InProgress</span></span></span><span class="hljs-class"> </span></span>: <span class="hljs-type"><span class="hljs-type">OrderStatus</span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Completed</span></span></span><span class="hljs-class"> </span></span>: <span class="hljs-type"><span class="hljs-type">OrderStatus</span></span>() data <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canceled</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val reason: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span></span>: <span class="hljs-type"><span class="hljs-type">OrderStatus</span></span>() }</code> </pre> <br><p>  This is a sealed class, which is an order status model.  Very similar to the way we work with transfers, but with one reservation.  The Canceled value contains the reason for the cancellation.  Reasons for cancellation may be different. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> orderStatus = <span class="hljs-type"><span class="hljs-type">OrderStatus</span></span>.<span class="hljs-type"><span class="hljs-type">Canceled</span></span>(reason = <span class="hljs-string"><span class="hljs-string">"No longer in stock"</span></span>) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> orderStatus = <span class="hljs-type"><span class="hljs-type">OrderStatus</span></span>.<span class="hljs-type"><span class="hljs-type">Canceled</span></span>(reason = <span class="hljs-string"><span class="hljs-string">"Not paid"</span></span>)</code> </pre> <br><p>  We cannot do so with ordinary transfers.  If the enumeration value is created, it will not be changed. </p><br><p>  Did you notice other differences?  I used another chip sealed-class.  This is related data of different types.  Classical enumeration involves the transfer of related data for all variants of enumeration values, and all values ‚Äã‚Äãmust be of the same type. </p><br><p>  Swift has the equivalent of a sealed class and it is called ... an enumeration.  Enumeration in Kotlin is just a relic of Java, and you will use sealed classes for 90% of the time.  It is difficult to distinguish the sealed class from the Swift enumeration.  They differ only in name and, of course, the sealed class is passed by reference, and enumeration in Swift - by value.  Please correct me if I'm wrong. </p><br><h1>  We do not say goodbye </h1><br><p>  There are also nuances of the influence of memory management on the way code is written.  I know that I didn‚Äôt cover all aspects, and that‚Äôs because I‚Äôm still learning.  If you guys notice any other differences between these two languages ‚Äã‚Äã- let me know.  I am always open to new things! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350746/">https://habr.com/ru/post/350746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350734/index.html">As I wrote my VNC, and then no</a></li>
<li><a href="../350738/index.html">802.11ax - details (webinar, english)</a></li>
<li><a href="../350740/index.html">Create your cryptocics (Part 1)</a></li>
<li><a href="../350742/index.html">Optimization of the code in the mind, or "Well, just as definitely faster"</a></li>
<li><a href="../350744/index.html">SSO and Kibana: Kibana integration with integrated Windows authentication (Single Sign-On)</a></li>
<li><a href="../350748/index.html">How not to become a Python-developer</a></li>
<li><a href="../350750/index.html">How to write a one-page application (SPA) using Vue.js</a></li>
<li><a href="../350752/index.html">FastTrack Training. "Network Basics". "The structure of routers, routing platforms from Cisco." Eddie Martin December 2012</a></li>
<li><a href="../350754/index.html">SIP <-> Telegram: sip.tg</a></li>
<li><a href="../350756/index.html">AI.Hack - a series of hackathons in Moscow and St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>