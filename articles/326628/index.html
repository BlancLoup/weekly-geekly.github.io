<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SDAccel - first acquaintance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDAccel is an OpenCL programming system for Xilinx FPGAs. Currently, the problem of developing projects for FPGAs in the traditional languages ‚Äã‚Äãof th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SDAccel - first acquaintance</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/098/023/1fd/0980231fd44a4c28947cb7c0174c14cb.jpg"></div><br>  SDAccel is an OpenCL programming system for Xilinx FPGAs.  Currently, the problem of developing projects for FPGAs in the traditional languages ‚Äã‚Äãof the hardware description, such as VHDL / Verilog, is becoming more and more acute.  One of the methods to solve the problem is to use the C ++ language.  OpenCL is one of the options for using the C ++ language to develop FPGA firmware. <br><a name="habracut"></a><br><h1>  A small introduction about phase transitions </h1><br>  I had to do programming FPGA back in 2000.  At that time, computers were not very powerful, and FPGAs were very small.  I worked with FPGA MAX7000 series from Altera.  For the development of firmware used a great system MaxPlus II.  The main tool there was a graphics editor.  VHDL and Verilog support were already there, but were very weak.  Only the synthesized subset of VHDL, Verilog, was supported.  But it was possible to get the VHDL model of the finished FPGA with a sdf file of time delays.  And the ratio of PC power and FPGA volume allowed for modeling the entire FPGA project with time delays.  Now you can only dream about it.  Around this time, a phase transition began in the development of FPGA projects.  It was a transition from schematic input to using VHDL / Verilog to simulate individual nodes and the entire project.  In our company, it coincided with the transition from Altera and MaxPlus II to Xilinx and ISE.  We have completed this transition in 2004. <br><br>  At the moment there is a second phase transition.  It is associated with the transition of FPGA project development from VHDL / Verilog to C ++.  The fact is that with a modern ratio of PC power and FPGA volume, it is almost impossible to conduct a FPGA project simulation session on VHDL / Verilog.  A simulation session can last from several hours to several days.  Such time can be allowed for the final verification of the project, but not for development. <br><br><h1>  What is OpenCL? </h1><br>  The OpenCL system was proposed in 2008 by Apple.  In the future, the Khronos Group was organized, which included leading companies such as INTEL, NVIDIA, AMD, ARM, GOOGLE, SONY, SAMSUNG and many others.  In addition to OpenCL, other systems are also developing there, for example, OpenXR, a virtual reality system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      OpenCL is a C ++ based design system for heterogeneous systems such as: <br><br><ul><li>  conventional processors </li><li>  multiprocessor clusters </li><li>  graphics processors </li><li>  FPGA </li></ul><br>  OpenCL defines the system model, C ++ language extensions, the library of functions for the computer HOST. <br><br>  Large simulation time associated with the simulation at the level of the clock frequency.  Using the C language removes the clock signal from the project description.  Only data operations remain in the project.  This allows you to increase the speed of modeling and development by several orders of magnitude. <br><br>  One of the first notable C programming systems is Mentor Graphics's Catapult system.  This system appeared in 2004 and is successfully used, including by Microsoft, to implement its Bing search server using Altera FPGAs. <br><br>  The company Xilinx approximately in 2013 released Vivado HLS, which allows you to develop individual components in C ++ and subsequently incorporate them into the main project.  Several more products are created on the basis of Vivado HLS: <br><br><ul><li>  SDSoc - acceleration of individual functions.  The system is designed only for Zynq (this is a chip in which in one case there is a FPGA and an AWS processor).  The system is already available. </li><li>  SDAccel is an OpenCL programming system.  The system is available, but not all. </li><li>  SDNet is a network application design system.  Not yet available and talking about it is still early. </li></ul><br>  SDSoc and SDAccel are characterized by the fact that the FPGA project already fades into the background.  In the foreground - the algorithm.  Both systems allow you to carry out modeling at the level of the original algorithm written in C / C ++ and then transfer it to the FPGA.  This allows you to dramatically increase the complexity of the algorithm.  And it is not by chance that now both of these systems are being introduced into image processing. <br><br>  If we compare the programming for the FPGA on VHDL / Verilog and on C / C ++, then the analogy between programming for conventional C / C ++ and assembler processors suggests.  Yes, assembly language can be made more compact and fast code.  But in C / C ++ you can write a more complex program. <br><br><h1>  Calculator model </h1><br><img src="https://habrastorage.org/files/742/e33/750/742e337501ad4a1cbd972ac86c0b5ccb.png"><br><br>  The system consists of HOST computer and computer, which are interconnected by bus.  In most cases, this is a PCI Express bus.  However, Altera already offers solutions for its FPGAs with an integrated workstations processor.  In this case, the AXI bus is used.  According to some rumors, Intel (which bought Altera) is developing a Xeon processor with integrated FPGA.  The main design system there will be OpenCL, and QPI will be used for interaction between the processor and FPGA. <br><br>  Inside the computer there is one or several ‚ÄúCompute Unit‚Äù blocks, each of which consists of one or several ‚ÄúProcessing Element‚Äù.  At this level there is a fundamental difference between graphics processors and FPGAs.  If the number of ‚ÄúProcessing Element‚Äù is defined in the graphics processor (although it is different in different models), then in the FPGA this may vary depending on the task. <br><br>  The standard defines several memory classes: <br><br><ul><li>  HOST Memory - the memory available to the application on the HOST computer.  Usually this is the computer's RAM. </li><li>  Global Memory - the memory available for HOST and for the calculator.  Usually it is a dynamic memory connected to the FPGA or to the graphics processor. </li><li>  Global Constant Memory - read and write memory for HOST and read-only on the computer. </li><li>  Local Memory - memory available only within one ‚ÄúCompute Unit‚Äù </li><li>  Private Memory - memory available only within the same ‚ÄúProcessing element‚Äù </li></ul><br>  Additionally, Xilinx introduces "Global OnChip Memory" - a memory available to all "Compute Unit". <br>  Simplified work algorithm: <br><br><ol><li>  HOST initializes the device. </li><li>  HOST loads the program into the calculator </li><li>  HOST prepares data in HOST Memory </li><li>  HOST launches DMA channel to transfer data from HOST Memory to Global Memory and waits for DMA completion. </li><li>  HOST starts a calculator and waits for the completion of the calculation. </li><li>  HOST starts the DMA channel to transfer the result from Global Memory to HOST Memory and waits for the DMA to complete. </li><li>  HOST uses the results of the calculation. </li></ol><br>  It is important to note the following - all communication between HOST and the calculator goes through Global Memory.  In more complex algorithms, it is possible to transmit data for the next cycle in parallel with the calculations. <br><br><h1>  What is a kernel? </h1><br>  Kernel is the basic concept of OpenCL.  As a matter of fact, this is a function that is performed on one ‚ÄúProcessing Element‚Äù.  Multiple kernels can run within the same Compute Unit.  This is the main way to ensure parallel operations for GPUs. <br>  Example of function definition: <br><br><pre><code class="hljs cs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">krnl_vadd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* b, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Unlike the usual description, new keywords appear here, they are defined in the OpenCL standard. <br><br><ul><li>  __kernel - defines the function that will be executed on the calculator. </li><li>  __global - determines that data is located in global memory. </li></ul><br>  SDAccel offers three ways to implement the kernel: <br><br><ul><li>  OpenCL standard </li><li>  C ++ - this will use all the features of Vivado HLS </li><li>  VHDL / Verilog - this will use all the features of the FPGA </li></ul><br><h1>  The main difference in the implementation for the GPU and FPGA </h1><br>  Using the example of a simple addition function of two vectors, it is very convenient to trace the main difference in the effective implementation of the code for graphics processors and for FPGAs. <br><br>  The addition function for the GPU will look like this: <br><br><pre> <code class="hljs cs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">krnl_vadd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* b, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); c[idx] = a[idx] + b[idx]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  And for FPGA like this: <br><br><pre> <code class="hljs matlab">__kernel void __attribute__ ((reqd_work_group_size(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))) krnl_vadd( __global int* a, __global int* b, __global int* c, const int <span class="hljs-built_in"><span class="hljs-built_in">length</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">length</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++){ c[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = a[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + b[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  Please note that the version for the GPU does not use the length parameter.  It is assumed that for each element of the vector will be running its own copy of the kernel.  Each instance will receive its idx number and perform the addition.  The number of simultaneously running instances will be determined by the capabilities of this GPU.  If the vector is too large, there will be several starts.  For FPGA this can also be done, but it is not very effective.  The best results are given by the variant in which only one ‚ÄúCompute Unit‚Äù and one ‚ÄúProcessing Elenet‚Äù are used.  Note that before the function declaration, the reqd_work_group_size (1, 1, 1) attribute was added, and there is a loop inside the function itself.  The attribute value 1,1,1 means that only one kernel will be used.  And this knowledge will be used to optimize the computational structure.  The cycle itself with the help of additional attributes can be expanded into a parallel computing structure.  The best result will be achieved if the length is constant. <br><br><h1>  SDAccel </h1><br>  Starting with version 2016.3, SDAccel and SDSoc are combined into one package called SDx.  SDSoc works in Windows and Linux.  SDAccel only works under some versions of Linux, in particular - CentOs 6.8;  There are no reasonable explanations for such restrictions, I hope in the future SDAccel will work under Windows.  The SDx package is based on Eclipse.  It adds the project type "Xilinx SDx".  When you create a project, you must select a platform.  While the selection is small.  The figure shows a view of the platform selection window: <br><br><img src="https://habrastorage.org/files/4c3/236/01a/4c323601ad9b43028d62ef3adbb3df12.png"><br><br>  The platform will determine the module and basic firmware FPGA.  SDAccel uses Partial Reconfiguration technology.  A correspondence is required between the base firmware, which is loaded into the FPGA and the one on the basis of which the SDAccel project is formed.  This correspondence is supported by the name and version of the platform.  Please note that the top line is the FMC126P module.  I try to create a platform for it, while unsuccessfully. <br><br>  Another important screenshot is the project properties: <br><br><img src="https://habrastorage.org/files/4fd/7fc/308/4fd7fc308ba04dadb75561f6dd0987ac.png"><br><br>  Pay attention to the ‚ÄúHW Functions‚Äù field. <br><br><ul><li>  binary_container_1 is what will be loaded into the FPGA. </li><li>  kernel-vadd is the name of the function </li><li>  Column "Comput Units" - in fact, this is the number of parallel implementations of the function </li><li>  ‚ÄúMax Memory Ports‚Äù column - allowing additional optimization when accessing global memory </li></ul><br>  Very important is the upper right field: "Active build configuration".  In fact, the whole essence of this system is here.  Three options are possible: <br><br><ul><li>  Emulation CPU - OpenCL implementation on a processor </li><li>  Emulation-HW - OpenCL implementation on Vivado simulator </li><li>  System - the implementation of OpenCL on the selected hardware platform </li></ul><br>  The result of the compilation will be the executable file, by the way, it has the extension .exe, and the file with the extension .xclbin;  This is a binary_container with the implementation of kernel functions. <br><br>  For the three embodiments, a different OpenCL runtime environment is formed.  Emulation CPU option is the fastest to run.  Compilation and launch are very fast.  It is in this mode that the algorithm must be checked. <br><br>  Emulation-HW is a longer option to compile and execute.  In this mode, Vivado HLS is invoked, the code for VHDL / Verilog / SystemC is synthesized and the Vivado simulator is started to execute the kernel.  By compiling the results, you can determine the resources occupied and evaluate the execution delays.  Simulation can be long, since there is already a clock frequency and we get all the related problems.  Although surely for PCI Express and SODIMM used simplified models, which increases the speed of modeling. <br><br>  Option System is working.  Compilation includes FPGA tracing, which is quite a long process.  A small project for ADM-PCIE-KU3 gets divorced for about an hour.  To start, you need to install the device driver that comes with the platform.  At startup, binary_container is loaded into the FPGA using the Partial Reconfiguration technology.  The download itself is also not fast, about a minute.  What is the reason I can not explain. <br><br><h1>  Program for HOST </h1><br>  The OpenCL standard defines an API.  On the Khronos Group website, all functions are well described.  But it all looks quite gloomy.  However, Xilinx here also simplified our lives.  The vector_addition example includes the xcl.h and xcl.cpp files, which describe the most necessary functions for working with one device.  Here they are: <br><br><ul><li>  xcl_world_single (), xcl_world_release () - initialization and shutdown of the device </li><li>  xcl_malloc () - allocating a buffer in global memory on the device </li><li>  xcl_import_binary () - binary_container download </li><li>  xcl_set_kernel_arg () - setting arguments for the kernel function </li><li>  xcl_memcpy_to_device () - transfer data to device </li><li>  xcl_memcpy_from_devce () - transfer data from device </li><li>  xcl_run_kernel3d () - function launch for execution </li></ul><br>  Of course, the program for HOST may not be one.  It is quite possible to make a separate project and connect any Unit testing system, for example Google Test, to test the implementation of functions on the FPGA. <br><br><h1>  And what's inside FPGA? </h1><br>  In the catalog of components there is such a nice element "SDAccel OpenCL Programmable Region" <br><br><img src="https://habrastorage.org/files/a5f/b7e/74d/a5fb7e74db204a1781ee18d25611b2a2.png"><br><br>  That's exactly what binary_container will be loaded into.  It is seen that the element has an extremely small number of links.  There is a S_AXI bus for control, a M_AXI bus for accessing global memory, and of course clock and reset signals.  It is assumed that the FPGA has a DMA node, a dynamic memory controller, and axi_interconnect central node. <br><br>  The SDAccel unit can be opened, inside it will look like this: <br><br><img src="https://habrastorage.org/files/753/c6c/cb2/753c6ccb288043c1afe8d3c2ab69a74a.png"><br><br>  Not very good, but it is clear that there are two axi_interconnect blocks, and between them there are four kernel blocks.  From this structure, it is recommended not to use a large amount of kernel, since each block will require its own AXI bus.  It is not recommended to use more than 16 tires. <br><br><h1>  Potential advantages and real disadvantages </h1><br>  The main advantage of the system is the possibility of implementing complex algorithms for working with large data arrays.  Of course, the concepts of "complex algorithm" and "large array" are conditional.  In my subjective opinion, the application of the system will be effective for those algorithms that require more than 1 MB of test data to check.  First of all, of course, image processing algorithms. <br><br>  Another potential advantage is the possibility of switching to other equipment.  For example, with Xilinx FPGA on Altera FPGA. <br><br>  The main disadvantages are: <br><br><ul><li>  This is a new system, for sure there are still unexplained bugs </li><li>  Work only under a limited number of options for Linux.  Under Windows - does not work. </li><li>  The efficiency of translation from C ++ to VHDL / Verilog is in question.  Although it is possible to implement a kernel on VHDL / Verilog. </li></ul><br><h1>  The first acquaintance took place, what's next </h1><br>  Upon further study of SDAccel, I plan the following: <br><br><ol><li>  The study of effective methods of working with memory, measuring the speed of work </li><li>  Development platform for the module FMC126P </li><li>  Implementation of the convolution node based on the FPFFTK library by Alexander Kapitanov ( <a href="https://habrahabr.ru/users/capitanov/" class="user_link">capitanov</a> ) </li></ol><br>  PS By the way, OpenCL does not support <code>&lt;stdio.h&gt;</code> , however there is a printf there.  Including printf works when implemented on the FPGA. </div><p>Source: <a href="https://habr.com/ru/post/326628/">https://habr.com/ru/post/326628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326618/index.html">K-Meleon 76 Pro - a new Russian browser assembly for oldfags and true connoisseurs.</a></li>
<li><a href="../326620/index.html">Got 1.2K stars on github with terrible architecture. How?</a></li>
<li><a href="../326622/index.html">VulnHub: New series - hackfest2016 Quaoar</a></li>
<li><a href="../326624/index.html">Financial mechanics startups. Startup School from Y Combinator 2017 (Part One)</a></li>
<li><a href="../326626/index.html">Own cryptocurrency on ethereum</a></li>
<li><a href="../326632/index.html">Under the hood of the development environment. Basic models</a></li>
<li><a href="../326634/index.html">Bash on Windows: Practical Experiments in Crossing Hedgehogs and Snacks</a></li>
<li><a href="../326636/index.html">Moving XenForo Forum to the modern platform</a></li>
<li><a href="../326640/index.html">How to cram your sensor in Android OS</a></li>
<li><a href="../326642/index.html">Recipe interface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>