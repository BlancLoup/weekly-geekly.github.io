<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rip network dictionaries using Node.js, part 2: dynamic pages; connect nw.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous section , basic operations and related tasks were described when copying online dictionaries using Node.js. This part describes the us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rip network dictionaries using Node.js, part 2: dynamic pages; connect nw.js</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habrahabr.ru/post/274475/">previous section</a> , basic operations and related tasks were described when copying online dictionaries using <i>Node.js.</i>  This part describes the use of an important additional tool for converting web sources of particular level of complexity. <br><br><h1>  I. Why do we need <i>NW.js</i> ? </h1><br>  <b>1.</b> The more complex the structure of the web pages of the dictionary, the more reason to rely on the full range of possibilities provided by the sophisticated browser engine.  <a href="https://github.com/tmpvar/jsdom"><i>JSDOM</i></a> is a fairly advanced library, but even it doesn‚Äôt compare to the full set of tools from <i>Chromium</i> . <br><br>  <b>2.</b> People involved in the creation and conversion of digital dictionaries are, to a large extent, humanities, who have been brought into the IT sphere by the will of fate.  Sometimes it‚Äôs more comfortable for them to work with the GUI than with the command line interface, especially if they don‚Äôt write the utilities themselves, but rather use the ready-made designs of their colleagues.  <i>NW.js</i> provides easy ways to create GUI to trivial applications for analyzing, processing and converting web pages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As an example for a brief description of this tool, I chose the site <a href="http://www.wordspy.com/">www.wordspy.com</a> . <a name="habracut"></a>  <i>Word Spy</i> is a constantly growing dictionary of English neologisms that have already become part of the language.  That is, they were not created and once used by authors for private needs (such words are called "occasionalisms"), but they "appeared" in several printed and network sources of different origin.  Compared to the <i>Urban Dictionary</i> , which served as an illustration for the first article, <i>Word Sp</i> y has two significant differences: the contents of the pages are formed by the asynchronous operation of scripts, and the structure of these pages is largely unpredictable and complex (whereas in the <i>Urban Dictionary</i> a small set of tags, and their order and combination were uniform).  This was the decisive reason to turn to <i>NW.js.</i> <br><br>  I do not plan to repeat here parts of the <a href="http://docs.nwjs.io/">official documentation</a> , which is already quite complete and systematic - if you are not familiar with <i>NW.js</i> , it‚Äôs better to start with it (then you can scroll through the <a href="https://github.com/nwjs/nw.js/wiki">wiki pages</a> on GitHub - although many of them are already outdated, there is still there is something interesting not mentioned in the main documentation).  I will confine myself only to notes on the application of the project to the selected task. <br><br><h1>  Ii.  Preparatory stage </h1><br><h3>  1. Getting a list of addresses of entries </h3><br>  Basically, the first preparatory script will largely resemble the program from the first article.  For the time being, we will not even connect <i>NW.js</i> , since we will only need to pull out the necessary links from the pages, and <i>JSDOM</i> will successfully cope with this. <br><br>  <a href="https://gist.github.com/vsemozhetbyt/986e37613d921087eb53"><code> </code></a> <br><br>  I denote only significant differences. <br><br>  <b>but.</b>  Because by the time the page loads and the function that reacts to this event of the <code>window</code> and <code>document</code> objects are not ready for the page, we will need to enter an additional cycle of checks (since the page is filled with asynchronous script operation, tracking the <code>load</code> event will not give us anything; hang event handlers for <i>DOM</i> changes, but in this situation, this seems like an unnecessary complication.  After analyzing the work of site scripts, we find some significant element of the page, the presence of which means the completion of the construction of the structure we need (in this case, a block with a list of references to dictionary entries).  We define the selector of this element in addition to the variables we already know ( <code>selectorsToCheck</code> in the initial code block; in the future case when different check elements are required for different pages, we will make this variable an array).  The second addition will be the number of milliseconds, which determines the frequency of checking the key element ( <code>checkFrequency</code> ). <br><br>  <b>b.</b>  <i>Word Spy</i> contains convenient two-level content of the entire dictionary: 1) a list of all tags, divided into several thematic blocks;  2) a link to each of the tags opens a list of all the vocables related to this tag.  We will add to our dictionary both the first list of tags, and all the lists of vocables under the tags.  To do this, in our initial array of addresses ( <code>tocURLs</code> ), which will be the source of the list of entries, we will add the mentioned starting page with tags.  Also, unlike the script from the first article, where this array was called <code>abc</code> , we will immediately turn it into a URL list, and we will not form it on the fly from the alphabet, since the tagged address does not fit into a single URL pattern. <br><br>  <b>at.</b>  Something in our current task will be simplified: <i>Word Spy</i> is a dictionary that is orders of magnitude smaller in comparison with the <i>Urban Dictionary</i> , therefore the address lists and vocabulary entries are one-page.  We will not have to check for the presence of multipage continuations in this script or in the script for saving the dictionary itself, which will simplify the construction of the URL and the corresponding sections of the code. <br><br>  <b>d.</b> In the <code>getDoc</code> function, the <code>getDoc</code> library query changes slightly: the <i>Urban Dictionary</i> was a static dictionary, but here we will have to require loading and executing scripts on the pages, which is displayed in the request options. <br><br>  Since there is another asynchronous moment in our code, we divide the old <code>processDoc</code> function into two: in the <code>checkDoc</code> function <code>checkDoc</code> we will check both possible errors and the end of the site scripts, and transfer the finished document to the delayed <code>processDoc</code> function.  The test cycle performs a certain number of iterations (for example, until 5 seconds has passed).  If during this time there is a verification element, we move on to the document processing function.  If there is no item after the timeout, we check if there was a redirect: if not, you can suspect a hitch on the server and repeat the request if the server redirects us somewhere, all that remains is to issue a warning to the user and temporarily terminate the program.  Experience has shown that, in most cases, it took 100‚Äì400 milliseconds to work out site scripts, although sometimes the delay was several seconds and only occasionally exceeded the timeout (in such cases, one repeated request was enough). <br><br>  <b>e.</b> Processing the finished page and extracting the necessary links is not significantly different from those described in the first article, unless we take care of adding the address with a thematic list of all tags to the list of dictionary entries URL so that this general content is then saved for ease of navigation in future dictionary. <br><br><h3>  2. Making a list of tags </h3><br>  Since the structure of the pages of the selected dictionary is complex and predictable only up to a certain level, we will try to add a preliminary pass through all the necessary pages to the process of saving in order to collect information on the types and frequency of tags used.  To do this, we will create a script, in many respects similar to the dictionary preservation script, except for extracting extremely simple information for the time being (therefore, we will still limit <i>ourselves</i> to <i>JSDOM</i> ). <br><br>  <a href="https://gist.github.com/vsemozhetbyt/e1ff91c8a18154375811"><code> </code></a> <br><br>  This script can be called a partial hybrid of the script familiar to us in saving the <i>Urban Dictionary</i> and the script described just above: it will read the finished address list (first or from the place where it was stopped and which it indicated before stopping in a special log) load the page, run its scripts and wait until they build all the necessary contents of the dictionary entry.  We denote only a few new parts. <br><br>  <b>but.</b>  When saving the dictionary, we created three files: the dictionary code itself, the process log with the recording of saved addresses, and the error log.  In this case, two files are enough for us: we will keep records of tags so that the file with them, if necessary, could play the role of the log of the work done for recovery after the break. <br><br>  <b>b.</b>  The array of selectorsToCheck key <code>selectorsToCheck</code> will now contain two elements: for ordinary dictionary pages and for pages with a list of tags (or vocabulums combined by one tag). <br><br>  <b>at.</b>  In order not to overload the analysis with unnecessary information, according to a rough preliminary assessment, we will define some elements that we will not save to the dictionary and which we can now not disassemble into tags: we will select selectors of these elements in the <code>selectorsToDelete</code> variable to remove the unnecessary before parsing. <br><br>  <b>d. The</b> analysis of each page will consist in extracting all tags from the element of interest to us, registering their names in the summing <code>tags</code> object (with a constant increase in statistics for each tag), writing the page address to the file and the list of tags on it.  At the end of the script, the final <code>tags</code> object is also written to the file.  Thus, we get both the general statistics of the tags and their distribution among the pages, which gives us the opportunity to see examples of the use of the tag by opening any of the addresses under which this tag is written.  If the work of the script is interrupted, we can restore the statistical <code>tags</code> object using the information already written to the file.  These two similar processes - reading pages and reading extracts from the log - we see in two appropriate places of the script: in the initial part (under the line <code>console.log('Reading the tag file...');</code> ) and in the <code>processDoc</code> function. <br><br>  The rest of the program code does not contain anything unfamiliar. <br><br><h1>  Iii.  Saving dictionary </h1><br>  Programs on <i>NW.js</i> consist of at least two files: a service file in <i>JSON format</i> that describes the main parameters of the program, and an <i>HTML</i> page that describes the GUI and contains scripts.  The latter can be transferred to a separate file (s) and referenced to them at a local or network address. <br><br><h3>  1. <code>package.json</code> </h3><br>  Here is the minimum content of our service file: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"NW.WordSpy.get_dic"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"WordSpy.get_dic.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"window"</span></span>: { <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Save WordSpy.com"</span></span> } }</code> </pre> <br><br>  Programs on <i>NW.js</i> at the first start create their own subfolder in the system folder for user data, and its name will be formed by the name of the program from the <code>name</code> field. <br><br>  The <code>main</code> field contains the path to the main file with GUI elements and the main script of the program. <br><br>  The optional subsection of the <code>window</code> contains the parameters of the program window being created, and for the time being we will limit ourselves to the title. <br><br>  More information about the format and components of the service file can be <a href="http://docs.nwjs.io/en/v0.13.0-beta6/References/Manifest%2520Format/">found in the help</a> . <br><br><h3>  2. <code>WordSpy.get_dic.html</code> </h3><br>  The window of our program will be relatively simple and in some ways even resemble a console application. <br><br>  <a href="https://gist.github.com/vsemozhetbyt/d7135dac03d6dfc8967d"><code> HTML-</code></a> . <br><br>  In the header of the markup, in addition to the necessary minimum, you can add an arbitrary block of <i>CSS</i> .  Here it is purely illustrative, and we will not dwell on it. <br><br>  The first elements of our GUI will be two fields for parameters that we previously set through command line switches: the input file with the addresses of the dictionary pages (we used to set the folder with the input file, and the file name was set in the code so that the key is shorter - now this is not necessary, and we can select the content file directly) and the folder in which the output files will be created - the dictionary itself, the log of the saved pages and the error log.  More information about the features of the file fields in <i>NW.js</i> can be read <a href="http://docs.nwjs.io/en/v0.13.0-beta6/References/Changes%2520to%2520DOM/">here</a> . <br><br>  Next comes the button that launches the main action of the program, followed by the field for displaying information.  With <i>CSS</i> and some script tweaks we will make it look like a console output window to keep in touch with the usual console versions of our scripts. <br><br>  The invisible element of <code>audio</code> will serve to attract user attention - we used to use a console player for this.  The address of the sound file can be any other, I used one of the system files of the standard sound event scheme. <br><br>  Finally, the last element will play the key role of the ‚Äúbrowser‚Äù - we will load our pages into this embedded frame to analyze and extract data.  About the features of frames in <i>NW.js</i> and some precautions related to them can be read <a href="http://docs.nwjs.io/en/v0.13.0-beta6/References/Changes%2520to%2520DOM/">on the link already familiar to us</a> . <br><br>  The program view at the beginning and at the end of the process of saving the dictionary can be estimated by the screenshots: <br><br><img src="https://habrastorage.org/files/079/f11/f86/079f11f864cd4dbe8905c70f0ad640e3.png"><br><br><img src="https://habrastorage.org/files/52a/442/c38/52a442c38f434c32a2e7ed0dc99b25f1.png"><br><br>  We brought the script part of the program to a separate file for convenience.  It is better to refer to it at the end of the page, so that at the time of launching the script can find all the necessary window elements and start interacting with them. <br><br><h3>  3. <code>WordSpy.get_dic.js</code> </h3><br>  <a href="https://gist.github.com/vsemozhetbyt/bfa76deac0d374b6b276"><code> </code></a> <br><br>  In the comments, I will try to dwell only on the differences and innovations compared to the console script from the previous article, because both the main structure and many code sections will be common. <br><br>  <b>but.</b>  The first difference we see at the beginning of the introductory part.  Variables appear for the window and document of the program itself (so it will be easier not to confuse them with the variables of the window and document of the loaded pages), and then for each GUI element.  Since the file paths will be built dynamically (not once and for all by command line keys, but in response to user actions), we will store them as changeable properties of the <code>io</code> object, and not as a separate set of constants.  Another difference is the sets of selectors for different purposes for more convenient manipulations with a complex structure of the document (they are already familiar to us from the previous script for analyzing tags).  Finally, as interactivity increases, at the end of the introductory part, we will create several indicator variables for the current state of the program and user commands. <br><br>  <b>b.</b>  When working with the GUI, the temptation to close the window at the wrong time is more than when working with the console.  Therefore, we will create a slightly larger system of fuses against incorrect termination of the program.  To begin with, let's assign an <code>onExit()</code> function to the window closing handler, about which actions we will say later. <br><br>  <b>at.</b>  As we could see from the help, the standard precautions of <i>HTML 5</i> remained valid, and we cannot set the final addresses of files using the attributes or properties of our file fields ‚Äî this can only be done by custom action through the dialog box.  But we can reduce the time and effort of the user by saving the path to the folder in which the user is asked to select a file (and if the file is a folder, the preliminary and final address will coincide miraculously).  To do this, we will use another service file in <i>JSON format</i> - <code>config.json</code> , in which we will store an object with two properties, according to the number of paths we need.  At the beginning of the program, the program will check for the presence of this file: if it exists, it will read the contents into the <code>config</code> object and write the desired paths in the <code>nwworkingdir</code> properties for both fields.  If there is no file, the object will be empty and the initial directory will be defined in the usual way for the browser. <br><br>  <b>d.</b> After checking the saved settings file, we set event handlers for all interactive elements and launch the first one to force the elements into the correct initial state. <br><br>  <b>e.</b> The <code>checkDirs()</code> function checks the definition of all necessary paths: if at least one of them is not defined, it displays a message in the information block, otherwise writes data to the file of saved settings and removes the lock from the main process launch button. <br><br>  <b>e.</b> The <code>onStop()</code> function responds to the interrupt command of the main process: it merely translates the indicator of this command to the on position so that the process can then be interrupted at a convenient time. <br><br>  <b>.</b>  The <code>onExit()</code> function reacts to an attempt to close the program window.  If a dictionary is saved at this time, it asks a verification question.  Upon confirmation, the indicators for process interruption and exit from the program are transferred to the on position for subsequent actions at a convenient time.  If the user does not confirm the action, it is ignored.  If the save is not made, the program closes without any questions. <br><br>  <b>g.</b>  In the <code>setSpeedInfo()</code> function, a significant change only affected the sound signal.  So far, I have left the update frequency and the format of information about the speed of work at the same level (once an hour), but if necessary, they can be corrected (because the <i>Urban Dictionary</i> lasted for many days, and <i>Word Spy</i> - about an hour and a half, so the frequency of conversion and the unit of measurement raise to minutes). <br><br>  <b>h</b>  The <code>updateInfo(str)</code> function is responsible for likening the console information block.  We set the buffer size to 10 lines and cut off the extra lines first (the oldest information there), scrolling the block to the last line.  Through this function, we display continuously current information in the process of saving.  With small dictionaries, this behavior can be disabled (then the entire rip protocol will be preserved), but with a long process, such restrictions save memory and remove redundancy (especially since everything necessary is written to the logs). <br><br>  <b>and.</b>  The <code>logError(evt)</code> function is designed to respond to an <code>error</code> event inside the embedded frame window.  It has never worked for me yet. <br><br>  <b>y.</b>  The <code>secureLow(str)</code> function serves the low-level text processing of the loaded pages to bring it to the requirements of DSL, namely, to escape special characters.  Whereas <code>secureHigh</code> is used to process text blocks (removing extra spaces, inserting indents before the body of vocabulary DSL entries, special insertion to save blank lines).  In the console version of the first article we managed with one function, but here our order of extracting and formatting information will change somewhat, and we will have to separate this processing. <br><br>  <code>saveDic()</code> - the main function of the program, launched when you click on the button to save the dictionary.  It largely corresponds to the initial, procedural part of our console script from the first article, but there are a number of differences.  First of all, we turn on the variable-indicator of the preservation process and change the appearance and behavior of the main button: now it will be responsible for interrupting the process.  Also disable the file fields that performed their role.  Then we perform already familiar file manipulations: we check for the presence of the address list, create dictionary vocabulary and reports, read the address list, read the information about already saved pages when there is one in the save log and, if necessary, shorten the task, finally start the save cycle, requesting the first page in list.  New in this code segment will be the task of the event handlers <code>load</code> and <code>error</code> for the window of the embedded frame, necessary for the operation of our cycle. <br><br>  <b>l</b>  <code>getDoc(url)</code> - the starting link of the circular chain of conservation.  We call this function at the beginning of the cycle and after processing each page.  It starts by checking the interrupt indicator: if it was turned on, the cycle is interrupted and the process stops running.  If it is turned off, after familiar operations we change the frame address, forcing it to load a new page. <br><br>  The <code>checkDoc()</code> function starts automatically in response to a full page load in our built-in browser.  She is partially familiar to us from the previous scripts of this article.  Only now we start it with the creation of variables, allowing us not to confuse the main objects of the program window and the window of the loaded page.  Then follows the familiar cycle of checking the readiness of the page content.  Depending on its results, we either proceed to processing the information, or reload the page, or exit with a message about an unknown error. <br><br>  <b>n</b>  The <code>processDoc(iWin, iDoc, iLoc, iter)</code> function <code>processDoc(iWin, iDoc, iLoc, iter)</code> contains the extraction, processing, and saving of the page's dictionary data.  It is the most different from the corresponding console part of the code - and because of the differences in the dictionary, and because of the features of the new tool. <br><br>  We start by cleaning the unnecessary parts of a dictionary entry.  Then we define its key element, get a list of all its text parts (the <i>XPath</i> capabilities will allow us to get exactly the final text nodes, without nested HTML elements, so that we can change their contents without risking damage to the structure of the document), and then subject all these elements of the above-mentioned low-level cleaning - so from the very beginning we get the escaping of special characters throughout the text of the article, and further adding of DSL tags can be done without serious consequences over this text. <br><br>  Then we form the title of the future dictionary entry. <br><br>     ,       ,       ,    (   ,          ,     ).           <i>NW.js</i> :   <code>innerText</code> .      <i>JSDOM</i> ( <a href="https://github.com/tmpvar/jsdom/issues/1245"> </a> ),       <code>textContent</code> ,         (-    ( HTML)   ).  <code>innerText</code>       :          ,       (   ,           ).            ( , ,          ):     ,         (   ,       ). <br><br>        ,   ‚Äî     ,    ¬´# ¬ª.  ,         ¬´# Tags by Category¬ª,   ,   , ‚Äî    ¬´# acronyms and abbreviations¬ª  .. <br><br>          .  ,    ,      ,        .      :        ,       . <br><br>          <code>insertAdjacentHTML()</code> ,          . <br><br> ,       ,  ,  :      ,     <code>innerText</code>     ;   <code>hr</code>   ;    (  , , )         . <br><br>      .    .   .     (,      <code>smirk</code>  <code>flame</code>             ).    ,      <code>CSS</code>        <code>innerText</code> . <br><br>          <i>DSL</i> . <br><br>        .      ,          ,   <i>CSS</i> .   -     (          ),  -     :        <code>span</code>  ,          .                (   HTML,  DSL   ) ‚Äî         ,         <i>DOM</i> . <br><br>   ‚Äî        . <br><br>   : ,  ,    ;        <i>DSL</i> ;      URL (           ,    <i>DSL</i>       ,     ). <br><br>         (     ,         ‚Äî         ). <br><br> ,        (..     ). <br><br>       :    <i>HTML</i> ,    ‚Äî  <i>DSL</i> ,       .      <code>innerText</code> ,  HTML     ,    DSL,        . <br><br>          ,       <code>secureHigh</code> .            (        ,       ),      ,        ,     . <br><br> <b>.</b>  <code>endSaving()</code>      ,           .      ,    /,     ,     .      ,        . <br><br><h3> 4.  </h3><br>   <i>NW.js</i> ,   ,        ,  -    .  ,   ,   ,   ,    .          138 .        ‚Äî       (     -    ). <br><br>     ,              ,      .  ,    /        <a href="">  </a> . <br><br>  (    16.02.2016)   <a href="http://rghost.net/6gp6RGsmJ">rghost.net</a>  <a href="https://drive.google.com/open%3Fid%3D0B494lZkk4eqIY0w5RTdWOU5hSXc">drive.google.com</a> .   DSL-   UTF-8  UTF-16,     LSD      ABBYY Lingvo. : 5827; : 3419;  : 9311. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/277513/">https://habr.com/ru/post/277513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277499/index.html">API for working with services: Basic moments</a></li>
<li><a href="../277501/index.html">Audio advertising: asked - we answer</a></li>
<li><a href="../277505/index.html">9 secrets of online payments. Part 2: regular payments</a></li>
<li><a href="../277509/index.html">Material on working with Apache Lucene and creating a simple fuzzy search</a></li>
<li><a href="../277511/index.html">List of machine learning resources. Part 1</a></li>
<li><a href="../277515/index.html">Creating a system of placing objects by level using the blueprint editor</a></li>
<li><a href="../277517/index.html">How I transferred the working Ubuntu MATE 14.04 system to a new SSD disk</a></li>
<li><a href="../277519/index.html">About MongoDB Online University</a></li>
<li><a href="../277521/index.html">Setting Safebrowsing from Yandex to Firefox</a></li>
<li><a href="../277525/index.html">Bidirectional rendering with diacritics support</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>