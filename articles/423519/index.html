<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wandering monster: how to get rid of problems on the map</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Already in the process of creating The Witness has become one of my favorite games. I started to play it from the moment when Jonathan Blow began its ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wandering monster: how to get rid of problems on the map</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png" alt="image"></div><br>  Already in the process of creating <a href="http://the-witness.net/news/">The Witness</a> has become one of my favorite games.  I started to play it from the moment when <a href="http://number-none.com/blow/">Jonathan Blow</a> began its development, and could not wait for its release. <br><br>  Unlike John <a href="https://en.wikipedia.org/wiki/Braid_%2528video_game%2529">Braid‚Äôs</a> previous game, <a href="http://the-witness.net/news/">The Witness‚Äôs</a> resources and programming were much closer to AAA projects than to indie games.  Everyone who works on such projects, it is known that the amount of work when choosing such a path increases significantly.  More people worked on <a href="http://the-witness.net/news/">The Witness</a> than on <a href="https://en.wikipedia.org/wiki/Braid_%2528video_game%2529">Braid</a> , but as is the case with any project of this level, there are many aspects that require more attention than the project management can afford. <br><br>  So I always wanted to find some free time to help create <a href="http://the-witness.net/news/">The Witness</a> when it came to the release of the game.  Therefore, one day at Thanksgiving, John and I sat down and looked at the list of things in the code base that would benefit from the extra effort of another programmer.  Having decided on the relative importance of the list items, we decided that the gameplay would benefit the most if we make improvements to the player‚Äôs movement code. <br><a name="habracut"></a><br><h2>  Walkmonster in wall </h2><br>  In the context of <a href="http://the-witness.net/news/">The Witness</a> , the task of the player‚Äôs movement code is to be as unobtrusive as possible.  The player must fully immerse himself in an alternate reality, and in this gaming experience every detail is important.  The last thing we wanted was for the player to notice that he was sitting at the computer and moving the virtual camera. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, the movement code of the player must be absolutely reliable.  If a player clings to corners, gets stuck in the walls, falls through the floor, descends a hill without being able to go back, etc., this will instantly destroy the illusion of immersion and remind the player that he is inside an artificial gameplay, which is hampered by an unreliable system. displacements.  In some circumstances, this can even lead to disastrous consequences for the player if he does not have the opportunity to solve the problem by restarting the game or reloading (probably very old) ‚Äúsaved‚Äù.  If you often play games, you must have encountered problems of this type, and you know what I mean. <br><br>  After our discussion, I began to work on this task.  First of all, I decided to write integrated tools for working with the player‚Äôs movement code, so that we could analyze it and observe its current behavior.  Having opened the project, I ran into a serious problem already known to me: how to name the first file of the source code?  This is always the most important part of any project ( <a href="http://www.gbv.com/inter4.html">as Bob Pollard once said about the names of bands and albums</a> ).  If you give the source file a suitable name, then further work will be clear and smooth.  Choose the wrong - you can destroy the whole project. <br><br>  But how to call a system to ensure the quality of the player‚Äôs movement code?  I have never had to write such code before.  When I thought about it, I realized that I personally saw an example of such a code only once: when playing in the early <a href="https://en.wikipedia.org/wiki/Quake_(video_game)">Quake</a> beta.  It contained bugs with the location of monsters, and in the console window you could see error messages saying that monsters, instead of being created on the surface of the earth, are created, partially intersecting with the geometry of the levels.  Each debugging message began with the phrase "walkmonster in wall at ..." <br><br>  Bingo!  It‚Äôs hard to pick a better name for the code file than ‚Äúwalk_monster.cpp‚Äù.  And I was almost sure that from now on, the code will be created without problems. <br><br><h2>  Movement to the point </h2><br>  When you want to test a system, the most important thing is <i>to actually test the system</i> .  Although this rule looks simple, people who write tests often fail to observe it. <br><br>  In our particular case, it is very easy to <i>imagine</i> that we are testing the player‚Äôs movement code without actually testing it.  Here is one example: you can perform an analysis of the volume of collisions and surfaces along which you can move in the game, look for small surfaces, gaps, etc.  By eliminating all these problems, you can say that the player is now able to safely move and walk around the world. <br><br>  But in fact, we tested the data, not the code.  It is very likely that there will be bugs in the movement code that lead to bad behavior even with quality data. <br><br>  To avoid such a trap, I wanted the testing system to be as close as possible to the behavior of the person actually controlling the movement of the character in the game.  I began by writing two procedures that would become the building blocks of such testing. <br><br>  The first procedure is closest to the real actions of a person.  This is an update call that connects to <a href="http://the-witness.net/news/">The Witness</a> input processing system and sends synthesized keyboard and mouse events to it.  It is capable of simple things that a person can do: look around, go towards a point, look at a point, and so on.  The procedure performs these actions with a simple emulation of user interaction with the keyboard and mouse, so I was sure that when processing input from <a href="http://the-witness.net/news/">The Witness,</a> everything would be done exactly the same way as during testing.  In the following articles I will discuss in more detail about this system and its use. <br><br>  The second procedure is one step that is not used at this level.  This is a function called <i>DriveTowardPoint</i> , which receives two points of the world and, causing an already existing system of player collisions, tries to seamlessly move from one point to another.  By returning, she transmits information about the attempt: what obstacles did she encounter on the way and whether she managed to reach the end point. <br><br>  This function is not as reliable as the method of testing with synthesized input, because it eliminates from testing a part of the player‚Äôs movement system.  For example, any erroneous condition related to the player‚Äôs location in case of problems with the collision system will not affect testing with this feature.  Nevertheless, I considered this level of testing valuable, because it can test vast areas much faster, because it does not require the execution of the entire game cycle, that is, it can be used more often and throughout the world, and not just in individual test runs . <br><br>  It is also worth noting that the physical input data is not transferred to this function;  for example, no speeds are indicated for the starting point.  This is done because <i>The Witness</i> is not an action game, so the player has few significant physical properties.  Players can not jump, run on the walls, include "bullet time".  You can support such behaviors with the help of systems that I will describe later, but they add levels of complexity that were not required in our project. <br><br>  Anyway, after implementing <i>DriveTowardPoint,</i> I could begin to solve the first task of the system: determining where the player can move on <i>The Witness</i> Island. <br><br><h2>  Rapidly Exploring Random Trees </h2><br>  Where can players move?  It seems that this is a simple question, but you will be surprised to know how many games were released when the development team did not know the real answer.  If this is possible, then I wanted <a href="http://the-witness.net/news/">The Witness to</a> be one of those few games in which the developers knew exactly where the player could and could not get to before the release - no surprises. <br><br>  This makes problem statement (but probably not its solution) very simple: with the <i>DriveTowardPoint</i> function, which reliably determines whether a player can move in a straight line between two points, create a coverage map that shows where the player can be. <br><br>  For some reason, I, without having written a single line of code, for some reason thought that it would be best to use <a href="http://msl.cs.uiuc.edu/rrt">Rapidly Exploring Random Tree</a> .  For those who are unfamiliar with this algorithm, I will explain: this is a very simple process in which we record all the points we visited with reference to the point from which we came.  To add a point to the tree, we take a random target point anywhere in the world, select the point closest to it, which is already in the tree, and try to get from this point to the target.  The place where we ended up becoming the next sampling point. <br><br>  Usually, this algorithm is used to search for paths: alternately for random points, we always select the same point as the target.  This inclines the exploration of space towards the target point, and this is what is required when our only task is to reach the goal.  But in this case, I wanted to create a complete map of the places that a player can fall into, so I use only random samples. <br><br>  After the implementation of this algorithm (fortunately, it is very simple and didn‚Äôt take much time), I saw that it did quite a good job of exploring the space (the white paths show the paths studied, and the vertical red lines indicate the places where the algorithm collided with an obstacle) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed2/ca3/fe3/ed2ca3fe3dbfe02cb7c9779af50f9ca6.png"></div><br>  However, after observing his behavior, I realized that in fact I didn‚Äôt need such an algorithm.  For example, even after many iterations, he is barely able to explore similar to the rooms shown below, despite the dense coverage of the areas outside of them.  This is because it is simply not able to select fairly random points inside the rooms: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/2d4/5a5/9832d45a5c14dc13df9a03cf5216697f.png" width="1280" height="720"></div><br>  If I thought about this before starting work, I would understand that the advantage of algorithms like the Rapidly Exploring Random Tree is that they efficiently explore high-dimensional spaces.  In fact, this is usually the main reason for using them.  But there are no high spaces in <a href="http://the-witness.net/news/">The Witness</a> .  We have a two-dimensional space (yes, distributed over a complex manifold, but this is still a two-dimensional space). <br><br>  In this low-dimensional space, the advantages of the Rapidly Exploring Random Tree manifest weakly, and its disadvantage is crucial for my task: the algorithm is designed for finding the most efficient paths to connected pairs of points in space, and not for effectively finding all the achievable points of this space.  If you have such a task, then in fact Rapidly Exploring Random Tree will take a huge amount of time to solve it. <br><br>  Therefore, I quickly realized that I need to look for an algorithm that effectively completely covers low-dimensional spaces. <br><br><h2>  3D Flood Filling </h2><br>  When I really thought about choosing an algorithm, it became obvious that in fact I needed something like the good old two-dimensional fill that is used to populate areas of a bitmap.  For any starting point, I just had to fill in the entire space, exhaustively checking every possible path.  Unfortunately, for many reasons, the decision for <a href="http://the-witness.net/news/">The Witness</a> will be much more difficult than for a two-dimensional bitmap. <br><br>  Firstly, we do not have a clear concept of a finite connectivity of a point.  All space is continuous.  This is for a pixel, we can easily list 4 possible places that can be reached from a given point, and check each of them in turn. <br><br>  Secondly, there is no fixed size position in space, like a pixel on a bitmap.  The surfaces on which the player moves, and obstacles can be anywhere, they do not have a maximum or minimum topological size, as there is no binding to any external grid. <br><br>  Thirdly, although movement through the space of <a href="http://the-witness.net/news/">The Witness</a> can be locally considered as moving along a plane, space itself is in fact a deeply interconnected and changing variety, in which the areas passed for the player are directly above other areas (sometimes there are several levels located one above the other) .  In addition, there are connections that vary depending on the states of the world (open / closed doors, ascending / descending elevators, etc.). <br><br>  Taking into account the described difficulties, it is very easy to come up with your own implementation variant for the fill, which as a result will turn out to be filled with intersecting areas, missing important routes, erroneous information about connections in difficult places of diversity.  In the end, the algorithm will be too cumbersome to use, because to take into account changes in the state of the world, it must be restarted. <br><br>  Immediately I did not think of any good solution, so I decided to start with simple experiments.  Using the <a href="http://msl.cs.uiuc.edu/rrt">Rapidly Exploring Random Tree</a> code I wrote, I changed the choice of target points from random to very controlled.  Each time I added a new point to the tree, I indicated that the points are at a unit distance along the main directions from the point that will be considered the future target point, as is the case in simple two-dimensional filling. <br><br>  But of course, if you are not careful, it will create a useless sampling cycle.  The point will branch into the neighboring 8 points around it, but these 8 points will then try again to return to the starting point, and this will continue forever.  Therefore, in addition to the controlled selection of target points, I need a simple constraint: any target point that is not within a certain minimum useful distance from an existing target point will not be taken into account.  To my surprise, these two simple rules create a fairly successful fill: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/591/cf6/446/591cf6446fdcc8281f7ebd9449c48703.png"></div><br>  Not bad for a fairly simple experiment.  But the algorithm suffers from what I call the ‚Äúboundary echo‚Äù.  This effect can be seen in the following screenshot taken during the map exploration process: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/fd0/25f/58efd025f80d2b96274ed849d3e4c568.png"></div><br>  In areas without obstacles, the algorithm works well, performing samples at relatively equal distances.  But when they hit the intersection border, they create points that are ‚Äúoutside the grid‚Äù, that is, not aligned in accordance with the sampling pattern, according to which the algorithm fills the adjacent open area.  The reason why the points ‚Äúin the grid‚Äù do not create excessively dense tessellation is that each new point trying to return to one of the previous ones finds the previous point there and refuses to recalculate it again.  But when creating new points on the border, they are not aligned at all, so nothing can prevent them from returning to the already explored space.  This leads to the creation of a wave of displaced samples, which continues until it reaches a random line of points somewhere else, which will be close enough for the algorithm to find it coinciding with the moving front of points. <br><br>  Although this does not seem to be a serious problem, in fact it is critical.  The whole point of such algorithms is to concentrate the samples in areas where they are most likely to produce productive results.  The more time we spend on sampling and resampling vast open areas, the less time we spend on marking the very edges of this area, which are the information we need.  Since we are dealing with continuous space, and its true form can only be described by an infinite number of samples, the ratio of significant to insignificant samples is literally a measure of the efficiency of the algorithm in creating the surface passed for the player. <br><br>  However, there is a simple solution to this particular problem: you need to expand the distance at which the two points are considered ‚Äúclose enough.‚Äù  By doing this, we will reduce the sampling density in places that are <i>not important to</i> us, but will also lose sampling density in places that are <i>important to</i> us, for example, the areas around the borders, which we want to carefully check for the presence of ‚Äúholes‚Äù. <br><br><h2>  Localized directional sampling </h2><br>  Probably because I started with the Rapidly Exploring Random Tree, my brain ousted all other ideas except the idea of ‚Äã‚Äãproximity.  All previous algorithms for completing their task used proximity, for example, in order to determine a new point that needs to be considered next, or to choose a point from which to start in order to get to a new target point. <br><br>  But after reflecting on the task for a while, I came to the realization that everything becomes more logical if we think not only about proximity, but also about <i>directionality</i> .  Then it becomes obvious, but if you worked on similar tasks, you know that it is easy to fall into the trap of narrowly focused thinking and not see the big picture, even if it turns out to be simpler.  That is exactly what happened to me. <br><br>  When I changed my view of things, the right approach to sampling seemed obvious.  Every time I wanted to expand the study of space from a point, I made a request for the existence of the nearest points in the local environment.  However, instead of using the distance to these points for research, I will classify them according to their directions (before that, I used only eight main directions, but I wanted to experiment with other cores). <br><br>  In any direction in which I do not ‚Äúsee‚Äù a point, I travel a given distance and add a point at any place where I stopped (regardless of whether I ran into something or not).  If I see a point in one of the directions, then I move there and check if I can get there.  If I can, then I simply add a visible edge so that the user can easily see that the points are connected.  If I can not, then I add a new point at the point of collision, defining the boundary of the obstacle. <br><br>  This sampling method worked just fine.  It allows us to control sampling very precisely with the help of convenient adjustable parameters, to save all the necessary points and to avoid unnecessary tessellation, which leads to a very fast fill of space: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/e45/60e/699e4560ef50242ff48ba0682554248a.png"></div><br>  Since the algorithm performs a search along directions, rather than simply using proximity, it is protected from boundary echo and limits over-sampling only to the boundaries we need: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/673/618/6f3673618d182bb1810e2577c18ab1ef.png"></div><br>  Moreover, the algorithm is completely unaffected by state transitions or problems with complex manifolds.  It deals only with points, and these points can be anywhere, and new ones can be added at any time.  If you have already mapped an area with the door closed, then after opening the door, you simply place a single point of investigation on the other side of the door and order the algorithm to continue expanding this map, after which it will correctly connect and properly examine the entire area behind the door. <br><br>  You can also change the basic parameters at any time, and the system will continue to work.  Want to sample the area with higher density?  Just lower the default distance value.  This can be done already in the process of building a map, and the algorithm will begin sampling with greater density without having to reset previous results (which may take some time). <br><br><h2>  Rudimentary rib check </h2><br>  By default, the algorithm carefully samples the boundaries, because the intersections create additional points that are not included in the sampling pattern, but it does not necessarily check them with the care I need, because it does not perform any special actions when encountering obstacles.  I realized that since I knew which of the points were created during collisions, the two detected points of collisions are connected by an edge and we can call for additional sampling in order to try to find more boundary points in the neighborhood. <br><br>  I didn‚Äôt actively investigate this approach, but I created a rudimentary method for testing this theory, and it seemed promising to me.  Taking any two points of collision connected by an edge, I move to the midpoint of the edge and try to conduct the outward-facing perpendicular to the edge.  If it does not intersect with the border at a very short distance, then I assume that the border is more complicated, and add a new target point to continue the search in this area. <br><br>  Even this simple scheme creates very high-quality dense sampling along the border without undue sampling of neighboring open areas.  Here is an area with several borders, but without edge checking: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/c9f/f6d/6dcc9ff6d78ddb981413ed4b795dcd5b.png"></div><br>  But the same area with the verification of the edges: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png"></div><br>  No matter how satisfied I am with this result, I was surprised at the lack of significantly better algorithms for sampling the boundary, and I will try to select a few more methods in the future. <br><br><h2>  Quick wins </h2><br>  Even by investing just a little time in the development and creating a fairly simple code, I achieved that Walk Monster was already creating quite useful output data that could detect real problems in the game.  Here are examples of problems that I found during the development of the algorithm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ed/6f6/823/4ed6f6823ba2de2886a0fd83f702aa97.png"></div><br>  The slopes on the sides of this platform should not be passable, but the player can walk on them.  This happened because the pathology of the player‚Äôs movement has a pathological poor way to handle oblique geometry.  Now I know that he is there, and I will correct him when it comes to ensuring his reliability. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c38/b83/530c38b83fd5762238c3210d45e72d86.png"></div><br>  <a href="http://the-witness.net/news/">The Witness</a> was supposed to be a contemplative game, but wondering why it seems that there is a stone, although it does not exist, was not one of its koans.  As you can guess, this problem arose because someone left in the game the amount of collision after removing the geometry that indicates it.  This can easily happen, and it‚Äôs very good that we have a tool that can quickly recognize such mistakes so that people don‚Äôt have to do it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/233/c86/122233c86cd7f7cf4f08e69cbb76404a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/616/377/012616377b5515b2ee23d71da78bdeeb.png"></div><br>  These objects were supposed to become impassable rocks, but Walk Monster discovered that this did not happen.  Worse, Walk Monster found that for some reason we only walk the path in one direction (in the screenshot, from left to right), but this should not happen.  I made sure that the player can really do it (I managed).  It is very interesting to observe the occurrence of such errors! <br><br><h2>  Open questions </h2><br>  When you see good results that can be developed further, it is inspiring.  As I said, if you select the appropriate name for the source files, then everything will go like clockwork!  But all this work was done in just a few days, so it is far from exhaustive, and a lot has been done completely improvised.  If I have enough time to further develop these systems, then it is worth answering a few questions. <br><br>  First, what kind of post-processing needs to be done with the data to make it easier to visualize?  It will be difficult for people to understand the raw network of points and edges, but if we improve the description of the data, then this may make it difficult at first glance to assess the complex traversed areas. <br><br>  Secondly, how can sampling patterns be improved around borders to ensure that the maximum number of ‚Äúholes‚Äù is found?  Are there any good ways to characterize the information of the figures in the lattice, and are there any qualitative tessellation schemes that maximize the probability of crossing and passing through these figures? <br><br>  Third, which sampling patterns are better for filling spaces ‚Äî regular or randomized?  I can easily change the criteria for selecting target points to create more randomized patterns, but it‚Äôs not very clear if you should do this, and if so, which types of randomized patterns will be better. <br><br>  Fourth, what other information we want to get from the maps of passable areas, if we have already learned how to build them?  For example, it is very easy to expand an existing system with functions such as searching for paths or distance maps so that the user can select a point and request the shortest path between it and some other point, or see the heat map of the distance between the point and other points of the map.  Would such queries be helpful?  What other queries can I use? <br><br>  At the moment, visualizations of passable areas obtained with the help of Walk Monster are more than enough to show that the player‚Äôs movement code is rather bad.  I planned to go over to creating a system for nightly testing cards using the method of simulating user input, but it is obvious that we already have enough problems without this step to solve.  Therefore, the next step is to increase the reliability of the player‚Äôs movement code.      ,    ,       - ,     Walk Monster      . </div><p>Source: <a href="https://habr.com/ru/post/423519/">https://habr.com/ru/post/423519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423505/index.html">Zuckerberg sells Facebook shares for $ 13 billion so that ‚Äúour children never have to be sick‚Äù</a></li>
<li><a href="../423507/index.html">How to save memory on browser tabs, but not to lose their contents. Experience team Yandex. Browser</a></li>
<li><a href="../423511/index.html">Interception of the installation of Firefox and Chrome in Windows 10</a></li>
<li><a href="../423513/index.html">We save on RAID-controller, or how to feed</a></li>
<li><a href="../423515/index.html">Is DRY good or can it break the SOLID O?</a></li>
<li><a href="../423521/index.html">Seven rules of thumb for experimenting with websites</a></li>
<li><a href="../423523/index.html">Combined sensor, with preference and poetess</a></li>
<li><a href="../423527/index.html">Children's apps massively collect personal data and pass it on to third parties.</a></li>
<li><a href="../423529/index.html">What do you need for the whole team to work? How to tighten all the project management system?</a></li>
<li><a href="../423531/index.html">Evolution of the Reddit Mobile Architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>