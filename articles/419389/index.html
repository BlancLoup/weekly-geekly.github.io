<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular 6 and Ivy rendering engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, colleagues. We are considering whether to update the book " Angular and TypeScript. Website Building for Professionals " by Jacob Fine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular 6 and Ivy rendering engine</h1><div class="post__text post__text-html js-mediator-article"><a href="https://habr.com/company/piter/blog/419389/"><img src="https://habrastorage.org/webt/wl/x_/u9/wlx_u9fwbjqm0in1o-f790lshsg.jpeg" align="left" alt="image"></a>  Good afternoon, colleagues.  We are considering whether to update the book " <a href="https://www.piter.com/product_by_id/98497639">Angular and TypeScript. Website Building for Professionals</a> " by Jacob Fine and Anton Moiseyev.  <a href="https://www.manning.com/books/angular-development-with-typescript-second-edition">The new edition is</a> coming out this fall and includes material on Angular 5 and 6. <br><br>  At first we thought to publish material about the Ivy engine, which will probably be the most interesting innovation in Angular 6, but then we stopped on a more overview publication from Cedric Exbrayat (the original was released in May). <br><br>  In Angular 6, there are quite a few serious innovations, and the most important of them cannot be called a feature: this is Ivy, a new rendering engine.  Since the engine is still experimental, we'll talk about it at the end of this article, and start with other new features and revolutionary changes. <br><a name="habracut"></a><br>  <b>Tree-shakeable providers</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now there is a new, recommended way of registering the provider, directly in the decorator <code>@Injectable()</code> , using the new attribute <code>providedIn</code> .  It takes <code>'root'</code> as the value of any module of your application.  When using <code>'root'</code> object being injected will be registered in the application as a loner, and you will not need to add it to the providers in the root module.  Similarly, when using <code>providedIn: UsersModule</code> object being <code>providedIn: UsersModule</code> is registered as the <code>UsersModule</code> provider, and is not added to the module providers. <br><br><pre> <code class="javascript hljs">@Injectable({ <span class="hljs-attr"><span class="hljs-attr">providedIn</span></span>: <span class="hljs-string"><span class="hljs-string">'root'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  This new method was introduced for better removal of non-functional code in the application (tree-shaking).  Currently, the situation is such that the service added to the providers of the module will be in the final set, even if it is not used in the application - and it‚Äôs a little sad to admit.  If you use a lazy load, you can fall into several traps at once, or find yourself in a situation where the service will be listed in the wrong set. <br><br>  Such a situation in applications is unlikely to happen often (if you write a service, then use it), but in third-party modules sometimes we offer services that we don‚Äôt need - as a result we have a whole heap of useless JavaScript. <br><br>  So, this feature will be especially useful for library developers, but now it is recommended to register injected objects in this way - this also applies to application developers.  The new CLI now even applies the default <code>providedIn: 'root'</code> scaffolding when working with services. <br><br>  In the same vein, you can now declare the <code>InjectionToken</code> , directly register it with <code>providedIn</code> and add the <code>factory</code> here: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectionToken&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'baseUrl'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { providedIn: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'root'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, factory: (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'http://localhost:8080/'</span></span> });</code> </pre> <br>  Note: this also simplifies unit testing.  For the purposes of such testing, we are accustomed to register the service with the test module providers.  Here‚Äôs how we did before: <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({ <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [UserService] }));</code> </pre><br>  Now, if the UserService uses <code>providedIn: 'root'</code> : <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({}));</code> </pre> <br>  Just do not worry: all services registered with <code>providedIn</code> are not loaded into the test, but are lazily instantiated, only in cases when they are really needed. <br><br>  <b>RxJS 6</b> <br><br>  Angular 6 now uses RxJS 6 internally, so you will need to update the application to reflect this. <br><br>  And ... RxJS 6 changes the approach to import! <br><br>  In RxJS 5, you could write: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/operator/map'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n);</code> </pre> <br>  Pipeable operators appeared in RxJS 5.5: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre><br>  And in RxJS 6.0, imports have changed: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre> <br>  So, one day you will have to change the imports within the entire application.  I am writing ‚Äúonce,‚Äù not ‚Äúright now,‚Äù because rxjs-compat library was released in RxJS, allowing you to upgrade to RxJS version 6.0, even if the old versions are still used in your entire application or in one of the libraries used syntax. <br><br>  The Angular team wrote <a href="">a whole document</a> on this topic, and it is absolutely necessary to read it before migrating to Angular 6.0. <br><br>  Notice: there is a very cool tslint ruleset called <code>rxjs-tslint</code> .  There are only 4 rules in it, and if you add them to the project, the system will automatically migrate all your imports and the RxJS code, and this is done with the simplest <code>tslint --fix</code> !  After all, if you still do not know, <code>tslint</code> has a <code>fix</code> option that automatically fixes all errors it finds!  It can be used even more simply: install <code>rxjs-tslint</code> and run <code>rxjs-5-to-6-migrate -p src/tsconfig.app.json</code> .  I tried <code>rxjs-tslint</code> on one of our projects, and it worked quite well (run it at least twice to also minimize all imports).  Check out the README of this project if you want to learn more: <a href="https://github.com/ReactiveX/rxjs-tslint">github.com/ReactiveX/rxjs-tslint</a> . <br><br>  If you are interested in further studying RxJS 6.0, I recommend the <a href="https://www.youtube.com/watch%3Fv%3DJCXZhe6KsxQ">following</a> Ben Lesch <a href="https://www.youtube.com/watch%3Fv%3DJCXZhe6KsxQ">report</a> on ng-conf. <br><br>  <b>i18n</b> <br><br>  The most important i18n perspective is the ability to do ‚Äúi18n at runtime‚Äù without having to build an application separately for each local point.  So far this feature is unavailable (there are only prototypes), and its operation will require the Ivy engine (more about it below). <br><br>  Another i18n change has already taken place and is available.  The currency channel has been optimized in the most efficient way: it now rounds all currencies not up to 2 characters, as before, but to the required number of characters (for example, up to 3 in the case of a Bahraini dinar or to 0 in the Chilean peso). <br><br>  If required, this value can be retrieved programmatically using the new i18n <code>getNumberOfCurrencyDigits</code> function. <br><br>  In general, other convenient formatting functions also appeared, such as <code>formatDate</code> , <code>formatCurrency</code> , <code>formatPercent</code> and <code>formatNumber</code> . <br><br>  It is quite convenient if you want to apply the same transformations that are done in the channels, but do it from the TypeScript code. <br><br>  <b>Animations</b> <br><br>  In Angular 6.0, animations are already possible without a <code>web-animations-js</code> polyfill, unless you are using <code>AnimationBuilder</code> .  Your application can win several precious bytes!  In case the browser does not support the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/animate"><code>element.animate</code></a> API, Angular 6.0 rolls back to the use of CSS keyframes. <br><br>  <b>Angular Elements</b> <br><br>  Angular Elements is a project that allows wrapping Angular components in the form of web components and embedding them in an application that does not use Angular.  At first, this project existed only in ‚ÄúAngular Laboratory‚Äù (that is, it is still experimental).  With the release of v6, it comes to the fore a little bit and is officially included in the framework.  This is a big topic that deserves a separate article. <br><br>  <b>ElementRef &lt;T&gt;</b> <br><br>  If you want to take a link to an element in your template, you can use <code>@ViewChild</code> or <code>@ViewChildren</code> , or even embed an <code>ElementRef</code> directly.  The disadvantage in this case is this: in Angular 5.0 or lower, the specified <code>ElementRef</code> will receive the type <code>any</code> for the <code>nativeElement</code> property. <br><br>  In Angular 6.0, you can type ElementRef more strictly if you wish: <br><br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'loginInput'</span></span>) loginInput: ElementRef&lt;HTMLInputElement&gt;; ngAfterViewInit() { <span class="hljs-comment"><span class="hljs-comment">// nativeElement  `HTMLInputElement` this.loginInput.nativeElement.focus(); }</span></span></code> </pre> <br>  <b>What is considered undesirable, and what is fundamentally changing</b> <br><br>  Let's talk about what you need to keep in mind when embarking on migration! <br><br>  <i><b><code>preserveWhitespaces</code> : default is <code>false</code></b></i> <br><br>  In the ‚Äútroubles that may occur during the update‚Äù section, we note that preserveWhitespaces is now <code>false</code> by default.  This option appeared in Angular 4.4, and if you are wondering what to expect at the same time - here is <a href="https://blog.ninja-squad.com/2017/09/18/what-is-new-angular-4.4/">a whole post</a> on this topic.  Spoiler: everything can do, and can completely break your templates. <br><br>  <i><b><code>ngModel</code> and reactive forms</b></i> <br><br>  Previously, it was possible to provide the same form field with both <code>ngModel</code> and <code>formControl</code> , but today this practice is considered undesirable and will no longer be supported in Angular 7.0. <br><br>  There is a little confusion, and the whole mechanism worked, perhaps, not as you expected ( <code>ngModel</code> - this was not a familiar directive for you, but the input / output of the <code>formControl</code> directive, which performs almost the same but not identical task). <br><br>  So now, if we apply the code: <br><br><pre> <code class="javascript hljs">&lt;input [(ngModel)]=<span class="hljs-string"><span class="hljs-string">"user.name"</span></span> [formControl]=<span class="hljs-string"><span class="hljs-string">"nameCtrl"</span></span>&gt;</code> </pre> <br>  then we get a warning. <br><br>  You can configure the application so that it gives a warning <code>always</code> (always), <code>once</code> (once) or <code>never</code> (never).  The default is <code>always</code> . <br><br><pre> <code class="javascript hljs">imports: [ ReactiveFormsModule.withConfig({ <span class="hljs-attr"><span class="hljs-attr">warnOnNgModelWithFormControl</span></span>: <span class="hljs-string"><span class="hljs-string">'never'</span></span> }); ]</code> </pre> <br>  Anyway, in preparation for the transition to Angular 7, you need to adapt the code to use either template-oriented forms or reactive forms. <br><br>  <b>Project Ivy: new (new) rendering engine in Angular</b> <br><br>  Soooo ...  This is the 4th major release of Angular (2, 4, 5, 6), and the rendering engine is being rewritten for the 3rd time! <br><br>  Remember: Angular compiles your templates into equivalent TypeScript code.  Then this TypeScript is compiled along with the TypeScript that you have written in JavaScript, and the result is available to the user.  And we already have the 3rd version of this rendering engine in Angular (the first was in the original release of Angular 2.0, and the second was in Angular 4.0). <br><br>  In this new version of the rendering engine, the approach to writing templates does not change, however, it optimizes a number of indicators, in particular: <br><br><ul><li>  Assembly time </li><li>  Set size </li></ul><br>  All this is still deeply experimental, and the new Ivy rendering engine is enabled by the check box, which you yourself must enter in the compiler options (in the <code>tsconfig.json</code> file) if you want to try. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Consider that this mechanism is probably not very reliable, so do not use it in production yet.  Perhaps he still does not earn.  But in the near future, it will be accepted as the default option, so you should try it once, see if it works in your application, and what you gain from it. <br><br>  Let's discuss in more detail how Ivy differs from the older rendering engine. <br><br>  <b>The code generated by the old engine</b> <br><br>  Consider a small example: let us have a <code>PonyComponent</code> component that accepts a <code>PonyModel</code> model (with <code>name</code> and <code>color</code> parameters) as input and displays a pony image (depending on the suit), as well as a pony name. <br><br>  Looks like that: <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div&gt; &lt;ns-image [src]="getPonyImageUrl()"&gt;&lt;/ns-image&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;`</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ @Input() ponyModel: PonyModel; getPonyImageUrl() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`images/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.ponyModel.color}</span></span></span><span class="hljs-string">.png`</span></span>; } }</code> </pre> <br>  The rendering engine, which appeared in Angular 4, generated for each template a class called <code>ngfactory</code> .  The class usually contained (code simplified): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">View_PonyComponent_0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, [ elementDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ns-image"</span></span>, View_ImageComponent_0), directiveDef(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">49152</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, i2.ImageComponent, { <span class="hljs-attr"><span class="hljs-attr">src</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"src"</span></span>] }), elementDef(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]) ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_0 = component.getPonyImageUrl(); check(view, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_0); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_1 = component.ponyModel.name; check(view, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_1); }); }</code> </pre> <br>  It is difficult to read, but the main parts of this code are described as: <br><br><ul><li>  The structure of the created DOM, which contains the definitions of the elements ( <code>figure</code> , <code>img</code> , <code>figcaption</code> ), their attributes and the definitions of text nodes.  Each element of the DOM structure in an array of view definitions is represented by its own index. </li><li>  Change detection functions;  the code they contain checks whether the expressions used in the template result in the same values ‚Äã‚Äãas before.  Here the result of the <code>getPonyImageUrl</code> method is <code>getPonyImageUrl</code> and, if it changes, the input value for the image component will be updated.  The same applies to the nickname of a pony: if it changes, the text node containing this name will be updated. </li></ul><br>  <b>Ivy generated code</b> <br><br>  If we work with Angular 6, and the <code>enableIvy</code> flag <code>enableIvy</code> set to <code>true</code> , then in the same example a separate <code>ngfactory</code> will not be generated;  information will be embedded directly into the static field of the component itself (simplified code): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = defineComponent({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: PonyComponent, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: [[<span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>]], <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PonyComponent(), <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag, component</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Create</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'figure'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'ns-image'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'div'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Update</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">property</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'src'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.getPonyImageUrl(</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolate(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.ponyModel.name, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">)); } }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputs</span></span></span><span class="hljs-function">: { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">: '</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">' }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">directives</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> [ImageComponent]; }); <span class="hljs-comment"><span class="hljs-comment">// ...   }</span></span></code> </pre> <br>  Now everything is contained in this static field.  The <code>template</code> attribute contains the equivalent of the usual <code>ngfactory</code> , with a slightly different structure.  The <code>template</code> function, as before, will be launched for any change, but now it has two modes: <br><br><ul><li>  Creation mode: the component is only created, it contains the static DOM nodes that need to be created </li><li>  The rest of the function is performed with each change (if necessary, updates the source of the image and the text node). </li></ul><br>  <b>What does it change?</b> <br><br>  Now all decorators are embedded directly in their classes (the same for <code>@Injectable</code> , <code>@Pipe</code> , <code>@Directive</code> ), and to generate them you only need to know about the current decorator.  In Angular, this phenomenon is called the ‚Äúlocality principle‚Äù: you do not need to re-analyze the application to recompile a component. <br><br>  The generated code is slightly reduced, but more importantly, it is possible to eliminate a number of dependencies, thus speeding up recompilation if one of the parts of the application changes.  In addition, with modern collectors, for example, Webpack, everything turns out much nicer: the non-functional code is reliably cut off, those parts of the framework that you do not use.  For example, if you have no channels in the application, then the framework needed to interpret them is not even included in the final set. <br><br>  We are used to the Angular code that gets heavy.  It happens, it is not scary, but Hello World weighing 37 kb after minification and compression is too much.  When Ivy is responsible for generating the code, the non-functional code is cut off much more efficiently.  Now Hello World after minification is compressed to 7.3 kb, and after compression - just up to 2.7 kb, and this is a big difference.  The TodoMVC application after compression is only 12.2 kb.  This is data from the Angular team, and the others could not work with us, since in order for Ivy to work as described here, you still need to patch it manually. <br><br>  If you are interested in details, watch this <a href="https://www.youtube.com/watch%3Fv%3DdIxknqPOWms">performance</a> with ng-conf. <br><br>  <b>Compatible with existing libraries</b> <br><br>  You might be interested: what will happen to libraries that are already published in the old format, if you use Ivy in your project?  Do not worry: the engine will make an Ivy-compatible version of the dependencies of your project, even if they were compiled without Ivy.  I won't tell you the interior right now, but all the details should be transparent. <br><br>  <i><b>New opportunities</b></i> <br><br>  Consider what new features we will have when working with this display engine. <br><br>  <i>Private properties in templates</i> <br><br>  New engine adds new feature or potential change. <br>  This situation is directly related to the fact that the template function is embedded in the static field of the component: now we can use the private properties of our components in the templates.  Previously, this was impossible, which is why we were forced to keep public all fields and component methods used in the template, and they fell into a separate class ( <code>ngfactory</code> ).  When accessing a private property from another class, TypeScript compilation would fail.  Now it is in the past: since the template function is in a static field, it opens access to the private properties of the component. <br><br>  I saw a comment from the members of the Angular team about the fact that it is not recommended to use private properties in templates, although this is now possible - since it may be again prohibited in the future ... therefore, it is probably wiser to use only public fields in templates!  In any case, writing unit tests is now easier, because the test can check the status of a component, even without generating or checking for this DOM. <br><br>  <i>i18n at runtime</i> <br><br>  Pay attention: the new rendering engine finally opens up a long-awaited opportunity for us and gives ‚Äúi18n during execution‚Äù.  At the time of this writing, she was still not quite ready, but we saw several commits at once, and this is a good sign! <br>  The great thing is that you don‚Äôt have to pretty much change your application if you are already working with i18n.  But now you no longer need to build the application again for each locale that you plan to support - it will be enough just to load JSON with translations for each locale, and Angular will take care of the rest! <br><br>  <i>Libraries with AoT code</i> <br><br>  At the moment, a library released in NPM must publish the file metadata.json and cannot publish the AoT code of its components.  This is sad because the costs associated with such an assembly are passed on to our application.  With Ivy, there is no need for a metadata file, and library authors will now be able to publish their AoT code directly to NPM! <br><br>  <i>Improved Statistics</i> <br><br>  Now the generated code should give improved patterns, if you have a problem with your templates - result in a neat error indicating the template line in which it occurred.  You can even set breakpoints in templates and track what is actually happening in Angular. <br><br>  <i><code>NgModule</code> disappear?</i> <br><br>  This is still a distant prospect, but perhaps in the future it will be possible to do without NgModules.  The first signs of such changes are tree-shakeable providers, and it is logical to assume that Ivy has all the necessary basic blocks for those who are ready to gradually abandon NgModules (or at least make them less successful).  True, all this is still in perspective, we will be patient. <br><br>  In this release there will not be many new features, but Ivy is definitely interesting for the future.  Experiment with it - I wonder how you like it! </div><p>Source: <a href="https://habr.com/ru/post/419389/">https://habr.com/ru/post/419389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419373/index.html">Comparing React and Vue on a practical example</a></li>
<li><a href="../419379/index.html">Why Tesla and Deutsche Bank refuse paper contracts</a></li>
<li><a href="../419381/index.html">How guys from Storyline returned from Silicon Valley to Minsk with $ 770 thousand for a startup</a></li>
<li><a href="../419383/index.html">New attack technique WPA2, does not require a client on the AP</a></li>
<li><a href="../419385/index.html">Heart surgery: how we rewrote the main component of the DLP system</a></li>
<li><a href="../419391/index.html">Power, money and open source. We describe how the community works on the example of Apache Ignite</a></li>
<li><a href="../419393/index.html">Create a simple API gateway in ASP.NET Core</a></li>
<li><a href="../419395/index.html">Explanation of lambda expressions</a></li>
<li><a href="../419397/index.html">How we made a mobile application for six countries</a></li>
<li><a href="../419399/index.html">OpenAI Five defeated a team of people in an exhibition match Dota 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>