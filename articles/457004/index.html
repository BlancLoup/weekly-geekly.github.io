<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple Go Program Optimization Techniques</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I always care about performance. I don't know exactly why. But I just get pissed off by slow services and programs. Looks like I'm not alone . 

 In A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple Go Program Optimization Techniques</h1><div class="post__text post__text-html js-mediator-article">  I always care about performance.  I don't know exactly why.  But I just get pissed off by slow services and programs.  Looks like <a href="http://glinden.blogspot.com/2006/11/marissa-mayer-at-web-20.html">I'm not alone</a> . <br><br><blockquote>  <i>In A / B tests, we tried to slow down the page output in 100 millisecond increments and found that even very small delays lead to a significant drop in revenue.</i>  - Greg Linden, Amazon.com </blockquote><br>  By experience, low productivity is manifested in one of two ways: <br><br><ul><li>  Operations that are well executed on a small scale become unviable with an increase in the number of users.  These are usually O (N) or O (N¬≤) operations.  When the user base is small, everything works fine.  Product rush to market.  As the base grows, more and more unexpected pathological situations arise - and the service stops. <br></li><li>  Many separate sources of non-optimal work, "death from a thousand cuts." </li></ul><a name="habracut"></a><br>  For most of my career, I either did data science with Python, or created services on Go.  In the second case, I have much more experience in optimization.  Go is usually not a bottleneck in the services I write - programs when working with databases are often limited to I / O.  However, in the batch machine learning pipelines that I developed, the program is often limited to CPU.  If the Go program over-uses the processor, there are various strategies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article explains some of the techniques that can be used to significantly increase productivity without much effort.  I deliberately ignore methods that require significant effort or large changes in the program structure. <br><br><h1>  Before you start </h1><br>  Before making any changes to the program, take the time to create a suitable baseline for comparison.  If you do not do this, you will wander in the dark, wondering if there is any benefit from the changes made.  First write benchmarks and take <a href="https://blog.golang.org/profiling-go-programs">profiles</a> for use in pprof.  The best way <a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">to write a benchmark is also on Go</a> : it simplifies the use of pprof and memory profiling.  Also use benchcmp: a useful tool for comparing the difference in performance between tests. <br><br>  If the code is not very compatible with benchmarks, just start with something that can be measured.  You can profile the code manually using <a href="https://golang.org/pkg/runtime/pprof/">runtime / pprof</a> . <br><br>  So, let's begin! <br><br><h3>  Use sync.Pool to reuse previously selected objects. </h3><br>  sync.Pool implements <a href="https://en.wikipedia.org/wiki/Free_list">the release list</a> .  This allows you to reuse previously selected structures and depreciates the distribution of the object for many uses, reducing the work of the garbage collector.  The API is very simple.  Implement a function that allocates a new instance of an object.  The API will return a pointer type. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bufpool = sync.Pool{ New: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;buf }}</code> </pre> <br>  After that, you can make <code>Get()</code> objects from the pool and <code>Put()</code> them back when you're done. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sync.Pool returns a interface{}: you must cast it to the underlying type // before you use it. b := *bufpool.Get().(*[]byte) defer bufpool.Put(&amp;b) // Now, go do interesting things with your byte buffer. buf := bytes.NewBuffer(b)</span></span></code> </pre> <br>  There are nuances.  Before Go 1.13, the pool was cleaned up with every garbage collection.  This can adversely affect the performance of programs that allocate a lot of memory.  Starting from 1.13, <a href="https://go-review.googlesource.com/c/go/%2B/162919/">more objects seem to survive the GC</a> . <br><br>  <b>!!!</b>  <b>Before returning the object to the pool, it is necessary to reset the structure fields.</b> <br><br>  If you do not do this, you can get a dirty object from the pool that contains data from a previous use.  This is a serious security threat! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AuthenticationResponse { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } rsp := authPool.Get().(*AuthenticationResponse) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> authPool.Put(rsp) <span class="hljs-comment"><span class="hljs-comment">// If we don't hit this if statement, we might return data from other users! if blah { rsp.UserID = "user-1" rsp.Token = "super-secret } return rsp</span></span></code> </pre> <br>  The safe way to always guarantee zero memory is to do it explicitly: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// reset resets all fields of the AuthenticationResponse before pooling it. func (a* AuthenticationResponse) reset() { a.Token = "" a.UserID = "" } rsp := authPool.Get().(*AuthenticationResponse) defer func() { rsp.reset() authPool.Put(rsp) }()</span></span></code> </pre> <br>  The only time this is not a problem is when you use the memory to which you recorded.  For example: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( r io.Reader w io.Writer ) <span class="hljs-comment"><span class="hljs-comment">// Obtain a buffer from the pool. buf := *bufPool.Get().(*[]byte) defer bufPool.Put(&amp;buf) // We only write to w exactly what we read from r, and no more. nr, er := r.Read(buf) if nr &gt; 0 { nw, ew := w.Write(buf[0:nr]) }</span></span></code> </pre> <br><h3>  Avoid using structures containing pointers as keys for a large map. </h3><br>  Whew, I was too verbose.  I apologize.  Often talked (including my former colleague <a href="https://twitter.com/philpearl">Phil Pearl</a> ) about Go performance with a <a href="https://syslog.ravelin.com/further-dangers-of-large-heaps-in-go-7a267b57d487">large heap size</a> .  During garbage collection, the runtime scans objects with pointers and tracks them.  If you have a very large <code>map[string]int</code> , then GC should check every line.  This happens with every garbage collection, since the lines contain pointers. <br><br>  In this example, we write 10 million items in <code>map[string]int</code> and measure the duration of the garbage collection.  We allocate our map in the package area to ensure heap memory allocation. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[strconv.Itoa(i)] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Running the program, we will see the following: <br><br><pre>  inthash ‚Üí go install &amp;&amp; inthash
 gc took: 98.726321ms
 gc took: 105.524633ms
 gc took: 102.829451ms
 gc took: 102.71908ms
 gc took: 103.084104ms
 gc took: 104.821989ms </pre><br>  This is quite a long time in a computer country! <br><br>  What can be done for optimization?  A good idea seems to be to delete pointers everywhere so as not to load the garbage collector.  <a href="https://www.reddit.com/r/golang/comments/4ologg/why_is_byte_used_as_a_string_type/d4e6gy8/">There are pointers in the rows</a> ;  so let's implement this as <code>map[int]int</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[i] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Running the program again, we will see: <br><br><pre>  inthash ‚Üí go install &amp;&amp; inthash
 gc took: 3.608993ms
 gc took: 3.926913ms
 gc took: 3.955706ms
 gc took: 4.063795ms
 gc took: 3.91519ms
 gc took: 3.75226ms </pre><br>  Much better.  We sped up garbage collection 35 times.  When used in production, you will need to hash the strings into integers before inserting them into the map. <br><br>  By the way, there are still many ways to avoid GC.  If you allocate giant arrays of meaningless structures, ints or bytes, <a href="https://medium.com/%40rf_14423/did-the-big-allocations-of-ram-contain-pointers-directly-or-indirectly-actual-pointers-strings-76ed28c0bc92">GC will not scan it</a> : that is, you save on GC time.  Such methods usually require substantial processing of the program, so today we will not go into this topic. <br><br>  As with any optimization, the effect may vary.  See the <a href="https://twitter.com/dgryski/status/1140685755578118144">tweet thread from Damien Gryski</a> with an interesting example of how removing rows from a large map in favor of a smarter data structure actually <i>increased</i> memory consumption.  In general, read everything that he publishes. <br><br><h3>  Generate marshaling code to avoid reflection in runtime. </h3><br>  Marshaling and unmarshaling your structure into various serialization formats, such as JSON, is a typical operation, especially when creating microservices.  Many microservices have a single job at all.  Functions like <code>json.Marshal</code> and <code>json.Unmarshal</code> rely on <code>json.Unmarshal</code> <a href="https://blog.golang.org/laws-of-reflection">reflection</a> to serialize structure fields to bytes and vice versa.  This can be slow: reflection is not as efficient as explicit code. <br><br>  However, there are optimization options.  The marshaling mechanics in JSON looks like this: <br><br><pre> <code class="json hljs">package json // Marshal take an object and returns its representation in JSON. func Marshal(obj interface{}) ([]byte, error) { // Check if this object knows how to marshal itself to JSON // by satisfying the Marshaller interface. if m, is := obj.(json.Marshaller); is { return m.MarshalJSON() } // It doesn't know how to marshal itself. Do default reflection based marshallling. return marshal(obj) }</code> </pre> <br>  If we know the marshalling process in JSON, we have a hook to avoid being reflected in runtime.  But we don‚Äôt want to manually write all the marshalling code, what to do?  Instruct the computer to generate this code!  Code generators like <a href="https://github.com/mailru/easyjson">easyjson</a> look at the structure and generate highly optimized code that is fully compatible with existing marshaling interfaces, such as <code>json.Marshaller</code> . <br><br>  Load the package and write the following command to <code>$file.go</code> containing the structures for which you want to generate code. <br><br><pre>  easyjson -all $ file.go </pre><br>  The file <code>$file_easyjson.go</code> must be generated.  Since <code>easyjson</code> implemented the <code>json.Marshaller</code> interface for you, instead of the default reflection, these functions will be called.  Congratulations: you just sped up your JSON code three times.  There are many tricks to further increase productivity. <br><br>  I recommend this package because I myself have used it before, and successfully.  But beware.  Please do not take this as an invitation to start an aggressive debate with me about the fastest JSON packages. <br><br>  You should ensure that the marshaling code is re-generated when the structure changes.  If you forget to do this, the new fields you add will not be serialized, which will lead to confusion!  You can use <code>go generate</code> for these tasks.  To keep it in sync with the structures, I prefer to put <code>generate.go</code> at the root of the package, which causes <code>go generate</code> for all package files: this can help when you have a lot of files that need to generate such code.  General advice: to ensure that the structures are updated, call <code>go generate</code> in CI and check that there are no differences with the registered code. <br><br><h3>  Use strings.Builder to build strings. </h3><br>  In Go, strings are immutable: present them as read-only bytes.  This means that each time you create a string, you allocate memory and potentially create more work for the garbage collector. <br><br>  Go 1.10 implemented <a href="https://golang.org/pkg/strings/">strings.Builder</a> as an effective way to create strings.  Internally, it writes to the byte buffer.  Only when calling <code>String()</code> in the builder, a string is actually created.  It relies on some unsafe tricks to return the base bytes as a zero-distributed string: see <a href="https://syslog.ravelin.com/byte-vs-string-in-go-d645b67ca7ff">this blog</a> for further study on how this works. <br><br>  Let's compare the performance of two approaches: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import "strings" var strs = []string{ "here's", "a", "some", "long", "list", "of", "strings", "for", "you", } func buildStrNaive() string { var s string for _, v := range strs { s += v } return s } func buildStrBuilder() string { b := strings.Builder{} // Grow the buffer to a decent length, so we don't have to continually // re-allocate. b.Grow(60) for _, v := range strs { b.WriteString(v) } return b.String() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var str string func BenchmarkStringBuildNaive(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrNaive() } } func BenchmarkStringBuildBuilder(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrBuilder() }</span></span></code> </pre> <br>  Here are the results on my Macbook Pro: <br><br><pre>  strbuild ‚Üí go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strbuild
 BenchmarkStringBuildNaive-8 5000000 255 ns / op 216 B / op 8 allocs / op
 BenchmarkStringBuildBuilder-8 20000000 54.9 ns / op 64 B / op 1 allocs / op </pre><br>  As you can see, <code>strings.Builder</code> is 4.7 times faster, causes eight times less selections and takes up four times less memory. <br><br>  When performance is important, use <code>strings.Builder</code> .  In general, I recommend using it everywhere except in the most trivial cases of string construction. <br><br><h3>  Use strconv instead of fmt </h3><br>  <a href="https://golang.org/pkg/fmt/">fmt</a> is one of Go's most famous packages.  You probably used it in your first program to display ‚Äúhello, world‚Äù.  But when it comes to converting integers and floats to strings, it is not as effective as its younger brother, <a href="https://golang.org/pkg/strconv/">strconv</a> .  This package shows decent performance with very few API changes. <br><br>  <code>fmt</code> basically accepts <code>interface{}</code> as function arguments.  There are two drawbacks: <br><br><ul><li>  You lose type safety.  It is very important for me. <br></li><li>  This may increase the amount of excreta needed.  Passing a type without a pointer as <code>interface{}</code> usually results in a heap allocation.  <a href="https://www.darkcoding.net/software/go-the-price-of-interface/">This blog</a> explains why this is so. </li><li>  The following program shows the performance difference: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import ( "fmt" "strconv" ) func strconvFmt(a string, b int) string { return a + ":" + strconv.Itoa(b) } func fmtFmt(a string, b int) string { return fmt.Sprintf("%s:%d", a, b) } func main() {}</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var ( a = "boo" blah = 42 box = "" ) func BenchmarkStrconv(b *testing.B) { for i := 0; i &lt; bN; i++ { box = strconvFmt(a, blah) } a = box } func BenchmarkFmt(b *testing.B) { for i := 0; i &lt; bN; i++ { box = fmtFmt(a, blah) } a = box }</span></span></code> </pre> <br>  Benchmarks on Macbook Pro: <br><br><pre>  strfmt ‚Üí go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strfmt
 BenchmarkStrconv-8 30000000 39.5 ns / op 32 B / op 1 allocs / op
 BenchmarkFmt-8 10000000 143 ns / op 72 B / op 3 allocs / op </pre><br>  As you can see, the strconv variant is 3.5 times faster, causes three times less discharge and takes up half the memory. <br><br><h3>  Highlight cut-off capacity with make to avoid redistribution. </h3><br>  Before proceeding to improve performance, let's quickly update the information on cuts in memory.  The cut is a very useful design in Go.  It provides a scalable array with the ability to take different views in the same base memory without redistribution.  If you look under the hood, the slice consists of three elements: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pointer to underlying data in the slice. data uintptr // the number of elements in the slice. len int // the number of elements that the slice can // grow to before a new underlying array // is allocated. cap int }</span></span></code> </pre> <br>  What are these fields? <br><br><ul><li>  <code>data</code> : pointer to basic data in the slice <br></li><li>  <code>len</code> : current number of elements in the slice <br></li><li>  <code>cap</code> : the number of elements to which the slice can grow before redistribution </li></ul><br>  Under the hood, sections are arrays of fixed length.  When the maximum value ( <code>cap</code> ) is reached, a new array is allocated with a double value, the memory is copied from the old slice to a new one, and the old array is discarded. <br><br>  I often see a code like this where a slice with a zero boundary capacity is allocated, if the cut capacity is known in advance: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userIDs []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  In this case, the cut starts with the zero size <code>len</code> and the zero boundary capacity <code>cap</code> .  After receiving the answer, we add elements to the slice, while reaching the boundary capacity: a new base array is allocated, where the <code>cap</code> doubled and the data is copied into it.  If we have 8 elements in response, this leads to 5 redistributions. <br><br>  The following method is much more effective: <br><br><pre> <code class="go hljs">userIDs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rsp.Users) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Here we explicitly allocated a cutoff capacity with make.  Now we can safely add data there, without additional redistribution and copying. <br><br>  If you do not know how much memory to allocate, because the capacity is dynamic or is calculated later in the program, measure the final distribution of the size of the slice after the program is running.  I usually take the 90th or 99th percentile and hard code the value in the program.  In cases when CPU is more expensive for you than RAM, set this value higher than you think you need. <br><br>  The tip also applies to cards: <code>make(map[string]string, len(foo))</code> will allocate enough memory to avoid redistribution. <br><br>  See <a href="https://blog.golang.org/go-slices-usage-and-internals">this article</a> on how slices work in reality. <br><br><h3>  Use methods to transfer byte slices. </h3><br>  When using packets, use methods that allow the transfer of a byte slice: these methods usually give more control over the distribution. <br><br>  A good example is the comparison of <a href="https://golang.org/pkg/time/">time.Format</a> and <a href="https://golang.org/pkg/time/">time.AppendFormat</a> .  The first returns a string.  Under the hood, it allocates a new byte slice and calls <code>time.AppendFormat</code> on it.  The second one takes a byte buffer, writes a formatted time representation, and returns an extended byte slice.  This is often found in other packages of the standard library: see <a href="https://golang.org/pkg/strconv/">strconv.AppendFloat</a> against <a href="https://golang.org/pkg/bytes/">bytes.NewBuffer</a> . <br><br>  Why does this increase productivity?  Well, now you can transfer byte slices that you received from <code>sync.Pool</code> , instead of allocating a new buffer each time.  Or, you can increase the initial buffer size to a value that is more appropriate for your program to reduce the number of repeated copies of the slice. <br><br><h1>  Summary </h1><br>  All these methods can apply to your code base.  Over time, you will build a mental model to talk about performance in Go programs.  This will greatly help in their design. <br><br>  But apply them depending on the situation.  These are tips, not the gospel.  Measure and check everything with benchmarks. <br><br>  And know when to stop.  Increasing productivity is a good exercise: the task is interesting, and the results are immediately visible.  However, the utility of improving performance depends on the situation.  If your service responds in 10 ms, and the network delay is 90 ms, you should probably not try to reduce the 10 ms to 5 ms: you still have 95 ms.  Even if the service is ultimately optimized to 1 ms, the total delay will still be 91 ms.  Probably there is a bigger fish. <br><br>  Optimize wisely! <br><br><h3>  Links </h3><br>  If you want to know more, here are some great sources of inspiration: <br><br><ul><li>  <a href="https://syslog.ravelin.com/further-dangers-of-large-heaps-in-go-7a267b57d487">Further hazards of big heaps in Go</a> <br></li><li>  <a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/">Distribution Efficiency in Go High Performance Services</a> <br></li><li>  <a href="https://blog.twitch.tv/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2">How I stopped worrying and loved a bunch</a> <br></li><li>  <a href="https://syslog.ravelin.com/bytes-buffer-i-thought-you-were-my-friend-4148fd001229">bytes.Buffer, I thought you were my friend</a> <br></li><li>  <a href="https://syslog.ravelin.com/gc-is-bad-and-you-should-feel-bad-e9bdd9324f0">GC is bad, but you shouldn't feel bad</a> <br></li><li>  <a href="https://www.youtube.com/watch%3Fv%3DxxDZuPEgbBU">Go Profiling and Optimization</a> <br></li><li>  <a href="https://www.cockroachlabs.com/blog/memory-usage-cockroachdb/">CockroachDB memory usage</a> <br></li><li>  <a href="https://blog.gopheracademy.com/advent-2018/avoid-gc-overhead-large-heaps/">Eliminate GC delays in large heaps</a> <br></li><li>  <a href="https://syslog.ravelin.com/making-something-faster-56dd6b772b83">Seven steps to 100 times acceleration</a> </li></ul></li></ul></div><p>Source: <a href="https://habr.com/ru/post/457004/">https://habr.com/ru/post/457004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45699/index.html">Microsoft distributes gifts for the new year?</a></li>
<li><a href="../456992/index.html">Some useful tips for those who decide to learn English on their own</a></li>
<li><a href="../456996/index.html">Three white horses</a></li>
<li><a href="../457/index.html">Habrahabr in attendance caught Webplanet. Can you congratulate?</a></li>
<li><a href="../4570/index.html">Google asks its programmers to slow down</a></li>
<li><a href="../457008/index.html">Antiquities: Three Stories about the Palm Company</a></li>
<li><a href="../457010/index.html">Why I don't use web components</a></li>
<li><a href="../45702/index.html">Eclipse, colorer and theme conversion</a></li>
<li><a href="../45703/index.html">Need ly on Habrre reviews of devices that have no special relationship to IT?</a></li>
<li><a href="../45704/index.html">iBreath-breathalyzer for iPod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>