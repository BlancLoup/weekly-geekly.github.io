<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Advanced Gulp and Browserify: interesting tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of weeks ago, I started a cycle about how a non-profit musical project was doing (the first post is in ‚ÄúI am PR‚Äù, I will not put links), but,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Advanced Gulp and Browserify: interesting tricks</h1><div class="post__text post__text-html js-mediator-article">  A couple of weeks ago, I started a cycle about how a non-profit musical project was doing (the first post is in ‚ÄúI am PR‚Äù, I will not put links), but, unfortunately, I got carried away in the very first article, and instead of telling me about how I did it specifically, I began to recall effective tricks from other projects.  Apparently, this, together with the prescribed emphasis on the project itself, led to the fact that a UFO flew behind me and the post. <br><br>  However, all that was in the article was at least little known, and half of it was unique at all, as I am sure, and each of these tips can significantly facilitate the work with gulp, so I really would be sorry if this material was irretrievably lost. would. <br><br>  Therefore, I tried to remove all references to the project and re-publish (with revisions and corrections) an article that no one has yet seen.  If you are a grunt fan - read at least the second part: just because you don‚Äôt like gulp doesn‚Äôt mean that you don‚Äôt like browserify. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Summary: <br><ol><li>  A simple way to handle errors; </li><li>  Universal structure for storing source files; </li><li>  Combining multiple threads (for example, compiled coffee and js) into one; </li><li>  Creating a stream from text; </li><li>  creating your own plugins for Browserify; </li><li>  creating plugins from Gulp plugins for Browserify. </li></ol><br><a name="habracut"></a><br><img src="https://habrastorage.org/files/7c6/6de/180/7c66de180e8849998a8e73fcea46b691.jpg"><br><br>  I switched to <b>gulp</b> while working on one video portal.  Now they are doing well, they are developing, and it seems that my build system is still with them. <br>  Then I switched to the <b>stylus</b> . <br><br>  Why?  Extremely fast. <br>  I cite many figures from memory, so I can lie a little, but the proportions are the same, I remember them exactly. <br><br>  Introductory: <br><ul><li>  grunt; </li><li>  There is a large number (73, if not confusing) of style files that are almost unrelated to each other, the assembly is glued together.  Basically styles are components and page hooks and layouts, so that they are independent of each other, in almost everyone only a set of variables is connected; </li><li>  There are a large number of scripts that stick together in one.  CoffeeScript is compiled, normal js does not change.  Each file turns into a closure; </li><li>  There is an application file that is assembled from a large number of precompiled jade templates through some specialized plug-in that made an object with all the templates from the folder in global space, plus it was glued to the main application engine.  In fact, the output is also a js-file; </li><li>  The assembly time for each item is about 10 seconds on a Macbook Air 2013, i5, for a total of about 30-40 seconds.  I remind you that the MBA is SSD, which is connected via PCIe and gives the speed of work with the hard disk, which seems to be basically unattainable on a regular sata connection.  On computers with HDD assembly time may take more than a minute. </li></ul><br><br>  Everything indicates that there is a plug in the work with the hard disk, and in only one of the three tasks, everything can be solved by some kind of cache. <br><br>  Studying the problem also indicated that styles compiled the longest. <br><br>  The solution to the problem was as follows: <br><br><ul><li>  replace grunt with gulp.  The problem is solved with the compilation, and then by gluing together styles and scripts - the step of writing each individual file to disk is removed; </li><li>  replace sass with stylus, translate everything in the global file.  Compiling styles is accelerated to less than a second.  Apparently, the transfer of each file from node to Ruby ate a lot of resources.  And ruby-sass is not very fast yet.  The transfer, by the way, happened without any problems at all - sass was used basic, without mixins and functions, and from a certain point of view the sass format can be called a subset of the stylus format; </li><li>  Translate all coffeescript to JS to speed up compilation - good, these were mostly old widgets; </li><li>  Translate js build for application to browserify for caching. </li></ul><br><br>  As a result, the assembly of the entire project began to take 3-4 seconds, some types of files - about a second. <br>  Watchdog was working on it all instantly, of course. <br><br>  Since then I have been using the gulp + browserify stack. <br><br>  One of the advantages of browser browsing is wrapping the widgets into a closure, plus, in fact, the simplest validation of the code - it will not miss the code that cannot be parsed. <br><br>  However, it was hampered by the fact that the failure code forced the collector to crash.  This was not the case, of course. <br><br><h4>  Error processing </h4><br>  At first the decision was something like: <br><br><pre><code class="javascript hljs">gulp.task(<span class="hljs-string"><span class="hljs-string">'build-html'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... .pipe(plugins.jade()).on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log.bind(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>)) ...</code> </pre> <br><br>  But, as it turned out, this is not very good: the stream ‚Äúfreezes‚Äù and does not restart after the update. <br>  Why is this happening?  The fact is that the task is not completed, but it remains to hang in this state, and in the gulp, it seems that restarting is impossible without ending the previous execution. <br><br>  I have been looking for a good solution for this question for a long time, but over time I wrote my function to solve this problem: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([ <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">"----------ERROR MESSAGE START----------"</span></span>.bold.red.underline, (<span class="hljs-string"><span class="hljs-string">"["</span></span> + error.name + <span class="hljs-string"><span class="hljs-string">" in "</span></span> + error.plugin + <span class="hljs-string"><span class="hljs-string">"]"</span></span>).red.bold.inverse, error.message, <span class="hljs-string"><span class="hljs-string">"----------ERROR MESSAGE END----------"</span></span>.bold.red.underline, <span class="hljs-string"><span class="hljs-string">''</span></span> ].join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.end(); } gulp.task(<span class="hljs-string"><span class="hljs-string">'build-html'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... .pipe(plugins.jade()).on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, log) ...</code> </pre><br><br>  It also closes the stream (this.end ()), causing the completion of the task. <br><br>  If desired, you can add, for example, growl alerts, but I personally have enough. <br><br>  The function requires the preset npm package color and gives a very nice output.  If you do not want to put extra packages - you can remove the methods from the flowers. <br><br>  The most important thing here is the last line. <br><br>  When we execute this.end (), the particular gulp task completes its work.  Yes, it is a little shattered in memory, but watchdog-task will be able to re-launch your style assembly when you update them. <br><br>  It looks like this: <br><br><img src="https://habrastorage.org/files/8ff/316/c23/8ff316c237b74fbb845bfdae036402e6.png" alt="image"><br><br><h4>  Folders and files </h4><br>  If everything is neatly arranged in daddies like: <br><ul><li>  assets </li><li>  styles </li><li>  scripts </li><li>  templates </li></ul><br><br>  So I congratulate you. <br><br>  But for me personally, everything is lying around like this: <br><br><img src="https://habrastorage.org/files/9ed/ace/bb8/9edacebb884e4d67bcb657e0c6368347.png"><br><br>  And it is convenient, much more convenient than it was before.  Why?  Yes, because I had the opportunity to structure the files into each other in any logical way, without changing anything in the collector. <br>  You write @require in styles, layouts and inclusions in templates and browserify for scripts, everything just works. <br><br>  As a result, all this is going to index.html, app.js and style.css - the very basis for any project. <br><br>  How did I get it? <br><br>  In all projects, I try to stick with this scheme: <br><br><pre> <code class="javascript hljs">gulp.task(<span class="hljs-string"><span class="hljs-string">'build-js'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gulp.src(<span class="hljs-string"><span class="hljs-string">'src/**/[^_]*.js'</span></span>) ... gulp.task(<span class="hljs-string"><span class="hljs-string">'build-html'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gulp.src(<span class="hljs-string"><span class="hljs-string">'src/**/[^_]*.jade'</span></span>) ... gulp.task(<span class="hljs-string"><span class="hljs-string">'build-css'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gulp.src(<span class="hljs-string"><span class="hljs-string">'src/**/[^_]*.styl'</span></span>) ...</code> </pre><br><br>  What is this glob path like that? <br>  This is a selection of all files that do not begin with an underscore.  At any depth.  Accordingly, if you name the file src / lib / _some_lib.js, it will not be compiled by yourself.  But require him to pick up with pleasure. <br><br><h4>  Pasting results of different tasks </h4><br>  Now I do not use this technique, because I switched to the scheme with the inclusions of everything and everything in the code, I write mostly from memory, so I can lie a little. <br><br>  But it is very interesting, and in due time I did not find it anywhere. <br><br>  When I needed to solve a task like ‚Äúglue all the CoffeeScript files and js files from the vendor folder, and then from the main one,‚Äù at first I was upset because I didn‚Äôt know what to do.  Why such a sequence - I think it is clear - vendor scripts should be loaded first, and if you do it somehow else, everything will be mixed up. <br><br>  But I knew that if there was something in memory, then it could be used, and I began to dig.  Still, gulp uses native nodejs streams, which means you can do something about it. <br><br>  Came to a homemade solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> es = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'event-stream'</span></span>); gulp.task(<span class="hljs-string"><span class="hljs-string">'build'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> es.concat( gulp.src(<span class="hljs-string"><span class="hljs-string">'scripts/vendor/*.coffee'</span></span>).pipe(coffee()), gulp.src(<span class="hljs-string"><span class="hljs-string">'scripts/vendor/*.js'</span></span>), gulp.src(<span class="hljs-string"><span class="hljs-string">'scripts/*.coffee'</span></span>).pipe(coffee()), gulp.src(<span class="hljs-string"><span class="hljs-string">'scripts/*.js'</span></span>) ) .pipe(concat()) .pipe(dest(...)); })</code> </pre><br><br>  <b>Please note</b> : judging by the new event-stream documentation, the concat method has been renamed to merge.  I did this last half a year ago, so now the method may have new subtleties of use - the code is taken from a real, relatively old project that works with the old version of EventStream. <br><br><h4>  Plug-in connection </h4><br>  When you have 10-20 plug-ins, it becomes somewhat tedious to prescribe them manually. <br><br>  To do this, there is another plugin that creates a plugins object with plug-in methods, but all the same can be made much clearer and simpler: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gulp = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gulp'</span></span>), plugins = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./package.json'</span></span>)[<span class="hljs-string"><span class="hljs-string">'devDependencies'</span></span>]) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pkg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pkg.indexOf(<span class="hljs-string"><span class="hljs-string">'gulp-'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>; }) .forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pkg</span></span></span><span class="hljs-function">) </span></span>{ plugins[pkg.replace(<span class="hljs-string"><span class="hljs-string">'gulp-'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>).replace(<span class="hljs-regexp"><span class="hljs-regexp">/-/g</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>)] = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(pkg); });</code> </pre><br><br>  If someone doesn‚Äôt understand what exactly this code does, it opens the contents of devDependencies in package.json and all elements that begin with gulp- in it connects as plugins [pluginName].  If the plugin is called something like gulp-css-base64, it will be available via plugins.css_base64. <br><br><h4>  How to create a stream from text </h4><br>  Sometimes you need to create something in memory and send it to the stream (but at least with the same gluing).  Again, there is a plugin for this, but why?  If you can write everything yourself in three lines. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gutil = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gulp-util'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_from_src</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename, string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>).Readable({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); src._read = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> gutil.File({<span class="hljs-attr"><span class="hljs-attr">cwd</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">base</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: filename, <span class="hljs-attr"><span class="hljs-attr">contents</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(string)})); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> src; }</code> </pre><br><br>  It works all over Vynil FS from gulp-util, but what difference does it make to us? <br><br><h4>  Browserify Plugins </h4><br>  Why browserify in a post about gulp?  Yes, because it can be called a meta-assembly system, which is used in other systems.  Its capabilities have long since gone beyond the simple gluing of js-modules, and in the next part of the post everything will come together. <br><br>  If you use browserify and commonJS modules - tell me honestly, did you ever want to write like that? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./templates/_app.html.jade'</span></span>), ...</code> </pre><br><br>  This is the real code from the project itself, for the post about which a UFO came flying behind me, by the way. <br><br>  As it turned out, rip your browserify plugins - elementary. <br><br>  The real task for building JS looks like this: <br><br><pre> <code class="javascript hljs">gulp.task(<span class="hljs-string"><span class="hljs-string">'build-js'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gulp.src(<span class="hljs-string"><span class="hljs-string">'src/**/[^_]*.js'</span></span>) .pipe(plugins.browserify( { <span class="hljs-attr"><span class="hljs-attr">transform</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./lib/html-jadeify'</span></span>), <span class="hljs-string"><span class="hljs-string">'es6ify'</span></span>], <span class="hljs-attr"><span class="hljs-attr">debug</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span> } )).on(<span class="hljs-string"><span class="hljs-string">"error"</span></span>, log) .pipe(gulp.dest(<span class="hljs-string"><span class="hljs-string">"build"</span></span>)); });</code> </pre><br><br>  What is this ... and how does it work?  Yes, very simple. <br><br>  The simplest wrapper looks something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> through = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'through'</span></span>), jade = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jade'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Jadify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/\.html\.jade$/</span></span>.test(file) === <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> through(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> through(write, end); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ data += buf; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ compile(file, data, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) stream.emit(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, error); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stream.queue(result); stream.queue(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file, data, callback</span></span></span><span class="hljs-function">) </span></span>{ callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'module.exports = "'</span></span> + jade.render(data, {<span class="hljs-attr"><span class="hljs-attr">filename</span></span>: file})+ <span class="hljs-string"><span class="hljs-string">'"\n'</span></span>; ); } Jadify.compile = compile; Jadify.sourceMap = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// use source maps by default module.exports = Jadify;</span></span></code> </pre><br><br>  In the future, I will quote only the compile function - to save space. <br><br>  If there are browserify Ninjas who already know all the plugins to intrigue, they will ask "so what?" <br>  Yes, nothing. <br>  In this form, plugins already exist. <br><br>  But the trick is that we can change the syntax. <br>  For example: <br><br><pre> <code class="javascript hljs">callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'module.exports = "'</span></span> + jade.render(data, {<span class="hljs-attr"><span class="hljs-attr">filename</span></span>: file}) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/"/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'\\"'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\n/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'\\n'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/@inject '([^']*)'/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'"+require("$1")+"'</span></span>) + <span class="hljs-string"><span class="hljs-string">'"\n'</span></span> );</code> </pre><br><br>  And now in the jade template we can write <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">style</span></span> <span class="hljs-variable"><span class="hljs-variable">@inject</span></span> <span class="hljs-string"><span class="hljs-string">'./_font_styles.styl'</span></span></code> </pre><br><br>  As a result, we can include templates on jade in js, and styles in templates on jade. <br><br>  We can connect several collectors at once, for example: <br><br><pre> <code class="javascript hljs">callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'module.exports = '</span></span> + dot.template(jade.render(data, { <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: file })) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>);</code> </pre><br><br>  This is what we are doing the JS function of the template on DoT (handlebars-like templating engine over HTML) wrapped in Jade. <br><br>  And we can even ... <br>  ‚Ä¶ drumroll‚Ä¶ <br>  ... use gulp plugins to create browserify plugins that we can connect as a gulp task <br><img src="https://habrastorage.org/files/85b/124/499/85b1244995c5446c9cff149730a9c53b.jpg"><br><br>  and finally the denouement of the whole post.  We can turn this data string into a stream (which I just talked about in the middle of the post), which can be used with gulp.  We take the function I showed above and get ... <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_src</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename, string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>).Readable({ <span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); src._read = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> gutil.File({ <span class="hljs-attr"><span class="hljs-attr">cwd</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">base</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: filename, <span class="hljs-attr"><span class="hljs-attr">contents</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(string) })); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> src; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path, data, cb</span></span></span><span class="hljs-function">) </span></span>{ string_src(path, data) .pipe(gulp_stylus()) .pipe(gulp_css_base64({<span class="hljs-attr"><span class="hljs-attr">maxWeightResource</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>})) .pipe(gulp_autoprefixer()) .pipe(gulp_cssmin()) .on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">)</span></span>{ cb(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"module.exports = \""</span></span>+ file.contents.toString() .replace(<span class="hljs-regexp"><span class="hljs-regexp">/"/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'\\"'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\n/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'\\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); }) .on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, cb); }</code> </pre><br><br>  Once again, very carefully: <br><br><pre> <code class="javascript hljs"> string_src(path, data) .pipe(gulp_stylus()) .pipe(gulp_css_base64({<span class="hljs-attr"><span class="hljs-attr">maxWeightResource</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>})) .pipe(gulp_autoprefixer()) .pipe(gulp_cssmin()) .on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">)</span></span>{ cb(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"module.exports = \""</span></span>+ file.contents.toString() .replace(<span class="hljs-regexp"><span class="hljs-regexp">/"/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'\\"'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\n/mg</span></span>, <span class="hljs-string"><span class="hljs-string">'\\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); })</code> </pre><br><br>  We just skipped a bunch of gulp plugins that went into browserify. <br><br>  Yes, it turns out a little hemorrhoids.  But the result is worth it. <br><br>  What for?  <s>To the glory of Satan, of course,</s> because it was impossible to simply assemble and configure Stylus-styles in a browserify that would also suck out base64-pictures, and pass through autoprefixer and minification. <br><br><h4>  Conclusion </h4><br>  gulp is an amazingly elegant system that can be customized for most cases.  And the fact that its plugins can be used in browserify (and, therefore, other projects) is generally brilliant.  Yes, a little hemorrhoids, but this is something. <br><br>  I hope you learned something new.  More precisely, I am sure of this, but I wanted to say beautifully. <br><br>  And I hope that the UFO will return me to Habr and give you a talk about neural networks inside Web Workers and algorithms that can produce accurate recommendations on the user's musical preferences based on an extremely small amount of data. </div><p>Source: <a href="https://habr.com/ru/post/242379/">https://habr.com/ru/post/242379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242369/index.html">How we did analytics for a high load site</a></li>
<li><a href="../242371/index.html">As I wrote a physical puzzle on Libgdx</a></li>
<li><a href="../242373/index.html">Pixel Perfect Precision: how good are your pixels?</a></li>
<li><a href="../242375/index.html">Notes self-taught art director: do not growl at the programmer</a></li>
<li><a href="../242377/index.html">Thermoweder running Arduino and LabVIEW</a></li>
<li><a href="../242381/index.html">Underwater cabling. How it's done</a></li>
<li><a href="../242383/index.html">RAD Studio XE7 World Tour in Minsk, Nizhny Novgorod and Krasnoyarsk</a></li>
<li><a href="../242385/index.html">Report from SQA Days - Test design: easier to read or easier to write</a></li>
<li><a href="../242387/index.html">How to make profitable design development sites (part 3)</a></li>
<li><a href="../242389/index.html">Economy of developing countries. Cambodia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>