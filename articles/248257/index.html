<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Categories big and small</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the fourth article in the series "Theory of Categories for Programmers." 

 Understand the benefits of categories by studying various examples...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Categories big and small</h1><div class="post__text post__text-html js-mediator-article">  <i>This is the fourth article in the series "Theory of Categories for Programmers."</i> <br><br>  Understand the benefits of categories by studying various examples.  Categories come in all shapes and sizes and often appear in unexpected places.  We will start with the simplest. <br><br><h4>  No objects </h4><br>  The simplest category is without objects and, as a result, without morphisms. <a name="habracut"></a>  This is a very sad category, but it is important in the context of other categories, for example, in the category of all categories (yes, there is one).  If you think that the empty set is meaningful, then why not be an empty category? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Simple graphs </h4><br>  You can build categories by simply connecting objects with arrows.  Start with any directed graph and turn it into a category simply by adding more arrows.  First, add a single arrow on each node.  Then, for any two arrows, such that the end of one coincides with the beginning of the other (in other words, any two composable arrows), you need to add a new arrow, which will be their composition.  Every time you add a new arrow, you need to consider its composition with all the other arrows (except single ones).  As a rule, it turns out an infinite number of arrows, but this is normal. <br><br>  This process can be viewed as both the creation of a category in which there is one object for each node of the graph, and all possible chains of composable edges as morphisms.  (You can look at single morphisms like chains of length zero.) <br><br>  This category is called the free category generated by this graph.  This is an example of a free construction, the process of supplementing a structure by expanding it with a minimum number of elements in order to satisfy the laws of construction (in this case, the laws of the category).  Then we will see more examples of this design. <br><br><h4>  Orders </h4><br>  And now something completely different!  A category in which morphisms are relations between objects: the ratio is less or equal.  Let's check if this is really a category.  Do we have singular morphisms?  Every object is less than or equal to itself!  Do we have a composition?  If A &lt;= B and B &lt;= C, then A &lt;= C!  Is the composition associative?  Yes!  A set with this relation is called a preorder, and we have shown that the preorder is a category. <br><br>  You can also take a stronger dependence that satisfies the additional condition that if A &lt;= B and B &lt;= A then A must be the same as B. This is called partial order. <br><br>  Finally, you can impose the condition that any two objects are connected with each other, then you get a linear or full order. <br><br>  We characterize these ordered sets as categories.  A preorder is a category where there is no more than one morphism from any object A to any object B. Another name for this category is ‚Äúthin‚Äù.  Preorder is a subtle category. <br><br>  The set of morphisms from object a to object b in the category C is called the hom set and is written as C (a, b) (or, sometimes, HomC (a, b)).  Thus, each hom-set in the preorder is either empty or single-element, including the hom-set C (a, a), the set of morphisms from a to itself, which must be one-element and contain only a single morphism.  In the preorder, you can have cycles, in a partial order, they are prohibited. <br><br>  One can easily verify that any oriented acyclic graph generates a partial order in its free category. <br><br>  It is very important to be able to recognize preorders, partial and complete orders due to sorting.  Sorting algorithms, for example, quick sorting, bubble sorting, merge sorting, etc., can work correctly only on full orders.  Partial orders can be sorted using topological sorting. <br><br><h4>  Monoid as many </h4><br>  The monoid is a surprisingly simple, but surprisingly powerful concept.  This concept underlies arithmetic: both addition and multiplication form a monoid.  Monoids are widespread in programming.  They appear in the form of strings, lists, collapsible data structures, futures in parallel programming, events in functional reactive programming, and so on. <br><br>  Traditionally, a monoid is defined as a set with a binary operation.  All that is required of this operation is its associativity, and the presence of a single special element that behaves as a unit in relation to this operation. <br><br>  For example, natural numbers with addition and zero form a monoid.  Associativity means that: <br><pre><code class="haskell hljs">(a + b) + c = a + (b + c)</code> </pre> <br>  (In other words, we can omit the brackets when adding numbers.) <br><br>  The neutral element is zero because: <br><pre> <code class="haskell hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> + a = a</code> </pre><br>  and <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> = a</code> </pre><br>  The second equation is superfluous because addition is commutative (a + b = b + a), but commutativity is not part of the definition of a monoid.  For example, concatenation is not commutative, but it forms a monoid.  The neutral element for concatenating strings, by the way, will be an empty string that can be attached on either side of the string without changing it. <br><br>  In Haskell, we can define a type class for monoids ‚Äî a type for which there is a neutral element called mempty and a binary operation called mappend: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> m </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> mempty :: m mappend :: m -&gt; m -&gt; m</code> </pre><br>  The type signature for the function of two arguments, m -&gt; m -&gt; m, may look strange at first glance, but it will become clear after we talk about currying. <br>  You can interpret a signature with several arrows in two main ways: as a function with several arguments, with the rightmost type as returned, or as a function of one argument (leftmost), which returns the function.  The last interpretation can be underlined with the help of brackets (which are redundant, since the arrow is right associative), for example: m -&gt; (m -&gt; m).  We will return to this interpretation a little later. <br><br>  Note that in Haskell there is no way to express the monoidal properties of mempty and mappend (that is, that mempty is neutral and that mappend is associative).  The responsibility for this lies with the programmer.  <i>(comment of the translator: GHC has a similar mechanism intended for another purpose, but it can be used as a comment known to the compiler: <a href="https://www.haskell.org/haskellwiki/GHC/Using_rules">www.haskell.org/haskellwiki/GHC/Using_rules</a> )</i> <br><br>  Haskell classes are not as intrusive as C ++ classes.  When you define a new type, you do not need to specify its class in advance.  You can be lazy and declare that this type will be an instance of some class much later.  As an example, let's declare that the String type is a monoid, providing the implementation of mempty and mappend (this, in fact, was done for you in the standard Prelude): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> mempty = <span class="hljs-string"><span class="hljs-string">""</span></span> mappend = (++)</code> </pre><br>  Here we reused the list concatenation operator (++) because the string is, in fact, a list of characters. <br><br>  A little about Haskell syntax: any infix operator can be turned into a two-argument function by enclosing it in brackets.  Having two strings, you can combine them by pasting ++ in between: <br><pre> <code class="haskell hljs"><span class="hljs-string"><span class="hljs-string">"Hello "</span></span> ++ <span class="hljs-string"><span class="hljs-string">"world!"</span></span></code> </pre><br>  or passing them as two arguments to the (++) function: <br><pre> <code class="haskell hljs">(++) <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> <span class="hljs-string"><span class="hljs-string">"world!"</span></span></code> </pre><br>  Note that function arguments are not separated by commas and are not surrounded by parentheses.  (This is probably the hardest thing to get used to while learning Haskell.) <br><br>  It is worth noting that Haskell makes it possible to express the equality of functions directly: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mappend</span></span> = (++)</code> </pre><br>  Conceptually, this is not the same as the equality of the values ‚Äã‚Äãreturned by the function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mappend</span></span> s1 s2 = (++) s1 s2</code> </pre><br>  The first represents the equality of morphisms in the Hask category (or Set, if you ignore the bottom).  Such equations are not only more capacious, but are often generalized to other categories.  The second is called extensional equality, and states the fact that for any two input lines, the results of mappend and (++) are equal.  Since argument values ‚Äã‚Äãare sometimes called points (for example: the value of f at point x), this is called dotted notation.  Functional equality without specifying arguments is called pointless notation.  (By the way, equations in pointless notation often include a composition of functions, which is designated as a point, so this name may seem strange to newbies.) <br><br>  The closest analogue to a monoid declaration in C ++ is the proposed syntax for concepts. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mempty</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delete</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mappend</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">) = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delete</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">concept</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monoid</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requires</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) {</span></span> { mempty&lt;M&gt; } -&gt; M; { mappend(m, m); } -&gt; M; };</code> </pre><br>  The first definition uses a template value (also proposed in the standard).  A polymorphic value is a family of values, a different value for each type. <br><br>  The delete keyword means that the default value is undefined: they must be specified individually for each case.  Also, there is no default implementation for mappend. <br><br>  The concept Monoid is a predicate (hence the type bool), which checks whether the corresponding definitions of mempty and mappend exist for a given type M. <br><br>  You can implement the Monoid concept by providing the appropriate specializations and overloads: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> mempty&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; = {<span class="hljs-string"><span class="hljs-string">""</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mappend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s1, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1 + s2; }</code> </pre><br><h4>  Monoid as a category </h4><br>  It was a ‚Äúfamiliar‚Äù definition of a monoid in terms of the elements of a set.  But, as you know, in the theory of categories we try to get away from the sets and their elements, and instead talk about objects and morphisms.  So let's change our line of thought a bit, and think about using a binary operator as ‚Äúmixing‚Äù or ‚Äúshifting‚Äù within a set. <br><br>  For example, there is an operation to add 5 to any natural number.  It displays 0 to 5, 1 to 6, 2 to 7, and so on.  This is a function defined on the set of natural numbers.  This is good: we have a function and a lot.  In general, for any number n, there is a function to add n - the ‚Äúadder‚Äù n. <br><br>  How to compile these adders?  The composition of a function that adds 5, with a function that adds 7, is a function that adds 12. Thus, the composition of adders satisfies the rules that are equivalent to the rules of addition.  This is also good: we can replace addition with composition of functions. <br><br>  But that's not all: there is also an adder for the neutral element, zero.  Adding zero does not change the elements, so it is a single function in the set of natural numbers. <br><br>  Instead of giving you the traditional rules of addition, I could give you the rules of composition adders without losing information.  Note that the composition of adders is associative, since the composition of functions is associative;  and we have a zero adder corresponding to a single function. <br><br>  An astute reader might have noticed that the mapping of integers to adders follows from the second interpretation of a mappend signature: m -&gt; (m -&gt; m).  The type tells us that mappend maps an element of the monoid set to a function acting on this set. <br><br>  Now I want you to forget that you are dealing with a set of natural numbers and just think of it as a single object, a blob with a bunch of morphisms - adders.  A monoid is a category of one object.  In fact, the name of the monoid comes from the Greek mono - it means lonely.  Each monoid can be described as a category with one object and a set of morphisms that follow the corresponding rules of composition. <br><br><div style="text-align:center;"><img width="236" height="300" src="https://habrastorage.org/getpro/habr/post_images/9c9/fa7/89a/9c9fa789a3b4ffee1aa9db00a2839b39.jpg" alt="image"></div><br><br>  Concatenation of strings is interesting because we have the choice of right or left append.  The models are mirror reverse to each other.  You can easily make sure that adding ‚Äúbar‚Äù to ‚Äúfoo‚Äù on the right corresponds to adding ‚Äúrab‚Äù to ‚Äúoof‚Äù on the left. <br><br>  You may ask the question: Does each categorical monoid ‚Äî the category of one object ‚Äî determine a unique set with a binary operator?  It turns out that we can always extract a lot from the category of a single object.  This will be a set of morphisms - adders in our example.  In other words, we have a hom set M (m, m) of one object m in category M. We can easily define a binary operator in this set: the monoidal product of the two elements of this set is an element corresponding to the composition of the corresponding morphisms.  If you give me two elements M (m, m) corresponding to the morphisms f and g, their product will correspond to the composition g‚àòf.  Composition always exists because the source and result of these morphisms is one and the same object.  And it is associative by category rules.  The identical morphism is the neutral element of this work.  Thus, we can always recover a monoid set from a categorical monoid.  They are practically the same thing. <br><br><div style="text-align:center;"><img width="300" height="197" src="https://habrastorage.org/getpro/habr/post_images/a46/aec/49b/a46aec49b795d894b2b940b2f84447d1.jpg" alt="image"></div><br><br>  There is only one small problem for mathematicians: morphisms are not required to form a multitude.  There are more things in the world of categories than sets.  A category in which morphisms between any two objects form a set is called locally small.  As promised, I will ignore such subtleties, but I decided that I need to mention this fact. <br><br>  Many interesting phenomena in category theory are due to the fact that elements of a hom-set can be considered both as morphisms that follow the rules of composition and as elements of a set.  Here the composition of morphisms in M ‚Äã‚Äãcorresponds in the monoidal product in the set M (m, m). <br><br>  <a href="http://habrahabr.ru/post/245797/">Category Theory for Programmers: Preface</a> <br>  <a href="http://habrahabr.ru/post/246009/">Category: essence of composition</a> <br>  <a href="http://habrahabr.ru/post/247765/">Types and functions</a> <br>  Categories big and small <br>  <a href="http://habrahabr.ru/post/249113/">Categories</a> </div><p>Source: <a href="https://habr.com/ru/post/248257/">https://habr.com/ru/post/248257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248243/index.html">Full customization of select without using JS</a></li>
<li><a href="../248249/index.html">Ubuntu Make - a developer to help</a></li>
<li><a href="../248251/index.html">15 most popular IoT gadgets in 2014</a></li>
<li><a href="../248253/index.html">C ++ in 2015</a></li>
<li><a href="../248255/index.html">‚ÄúLove and Hate‚Äù on the map of Russia, winter 2014-2015: fourth study of the emotional state of 35 million social media users</a></li>
<li><a href="../248261/index.html">Right now there is a live broadcast of the seminar: ‚ÄúAdministration of the Data Domain system‚Äù</a></li>
<li><a href="../248263/index.html">Quick voice dialing on Asterisk</a></li>
<li><a href="../248267/index.html">Equivalent transformations of Maxwell equations</a></li>
<li><a href="../248269/index.html">We build a backdoor in the RSA public key</a></li>
<li><a href="../248271/index.html">Electronic signature on Russian regulations: practical use in enterprises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>