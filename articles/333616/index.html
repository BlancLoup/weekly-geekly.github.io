<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transition to embedded PostgreSQL in unit tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In applications that work with databases, there naturally arises the need for tests that verify the correctness of query results. Various built-in dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Transition to embedded PostgreSQL in unit tests</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c90/c7d/45e/c90c7d45ef184b7794a3f9cccec50d74.jpg"><br><p>  In applications that work with databases, there naturally arises the need for tests that verify the correctness of query results.  Various built-in databases come to the rescue.  In this article I will talk about how we transferred unit tests from HSQLDB to PostgreSQL: why it started, what difficulties we encountered and what it gave us. </p><a name="habracut"></a><br><p> If the tests need to check the performance of sql queries, it is convenient to use the so-called embedded database.  The database is created when the test is started and deleted when it is completed - thus, its life cycle is limited by the process in which it was launched (which is why they are called embedded ‚Äî that is, embedded in the testing process).  The advantage of such databases is that they allow you to work with a limited set of test data, which, as a rule, is much less than the amount of data even on a test server.  In addition, the creation of the database, filling in the tables and the subsequent deletion of the entire infrastructure is completely transparent to the programmer: there is no need to raise and configure the test server, as well as take care of the relevance of the data, which also has a positive effect on the speed of development. <br><br>  For our company, HSQLDB has historically been used for unit testing.  And everything would be fine, but PostgreSQL is on the production, and it turned out that the tests do not fully reflect what is happening on the prod.  Some features had to be left without testing: for example, requests using window functions could not be tested.  For some tests, it was necessary to make quite clever crutches: a vivid example is the different implementation of mapping a custom array type to SQL in PostgreSQL and HSQLDB (below I will tell about this in more detail).  We also faced the problem implementation of <code>exists</code> - there were cases when, for no reason at all, the test fell from <code>NPE</code> somewhere in the depths of HSQLDB. <br><br>  All these problems could have been avoided if we used PostgreSQL as a database for tests.  Currently, there are two implementations of PostgreSQL embedded: the <strong>postgresql-embedded</strong> library from <strong>yandex-qatools</strong> and <strong>otj-pg-embedded</strong> , provided by <strong>OpenTable</strong> .  Both projects are actively developing, as evidenced by regular commits in the repository, as well as easy to use: libraries can be downloaded from the maven repository, both work under Windows, which is important for the company, where some of the developers have chosen to work.  As a result, we decided to stop at otj-pg-embedded for several reasons: </p><br><ul><li>  First, the OpenTable library turned out to be much faster: the launch time for the downloaded distribution is about 2 seconds, while yandex-qatools runs within 7.5 seconds - almost 4 times slower!  It turned out that most of the time was spent on unarchiving the distribution at every start, while on Windows machines the start time increased to a few minutes. </li><li>  Secondly, it is enough just to change the PostgreSQL version if you need to use an older version or a custom build with extensions.  By default, otj-pg-embedded 0.7.1 comes with PostgreSQL 9.5 (in version 0.8.0, currently relevant, PostgreSQL 9.6).  It is not entirely clear how you can put a custom assembly in yandex-qatools. </li><li>  otj-pg-embedded is quite an old project (the first commit was in February 2012), the maintener responds promptly to requests in github. </li><li>  At yandex-qatools there are more options for configuration, at the same time otj-pg-embedded is a small library that is easy to understand, while it provides enough opportunities for configuration. </li><li>  In the OpenTable library, you can run a database instance ‚Äúin one line‚Äù, which is very convenient and intuitive.  In addition, in version 0.8.0, at startup, a fairly informative log is displayed showing the settings with which PostgreSQL is running. </li></ul><br><p>  So, having decided on the library and decisive gesture, replacing all dependencies on hsql with otj-pg-embedded, we happily launched tests and ... </p><br><h2 id="pervye-grabli">  First rake </h2><br><h3 id="po-raznomu-obrabatyvaetsya-sql-tip-date">  The <code>DATE</code> sql type is handled differently. </h3><br><p>  First of all, it turned out that the tests that worked with the <code>Date</code> sql type (not the <code>Timestamp</code> , namely <code>Date</code> ) dropped.  For example, when searching for resumes according to a certain criterion, the query returns all resumes for which the date of change is later than the specified date: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sessionFactory.getCurrentSession().createQuery( <span class="hljs-string"><span class="hljs-string">"FROM ResumeViewHistory "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE resumeId=:resumeId AND date IN "</span></span> + <span class="hljs-string"><span class="hljs-string">" (SELECT max(date) FROM ResumeViewHistory "</span></span> + <span class="hljs-string"><span class="hljs-string">" WHERE resumeId=:resumeId AND date&gt;:date)"</span></span>) .setInteger(<span class="hljs-string"><span class="hljs-string">"resumeId"</span></span>, resumeId) .setDate(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, from) .list();</code> </pre> <br><p>  In the test, a resume with the current date was created and then it was checked that there is no resume with a date slightly older than the one just created: </p><br><pre> <code class="java hljs">assertTrue(resumeViewHistoryDao.findByResumeLastView( resume.getResumeId(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime().plusMinutes(<span class="hljs-number"><span class="hljs-number">1</span></span>).toDate()) .isEmpty());</code> </pre> <br><p>  This test, like all other tests with a similar test, in PostgreSQL fell from <code>AssertionError</code> .  The thing is that the date and time were compared in HSQLDB, so a one minute difference was considered significant.  And in PostgreSQL, the time was reset to zero, simply turning into a date, and the query found a resume for itself, because it was created on the same day! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, we practically at first faced with the situation when the test checked the sql query, assuming certain behavior under the specified conditions, and this behavior worked on HSQLDB and did not work on PostgreSQL.  That is, in fact, this test was not only useless, because it did not give any information about the work of the query on the productive base, but was even harmful: the developer, reading the test code and seeing that there is a test for an empty result for an object created a minute later, could to think that at the <code>DAO</code> level the <code>setTimestamp()</code> method is used, and I would be very surprised to see <code>setDate()</code> . </p><br><h3 id="like--acronym-titlecommon-table-expressionscteacronym">  LIKE + <acronym>CTE</acronym> </h3><br><p>  The following problem was thrown by the <code>LIKE</code> operator in conjunction with common table expressions.  CTE (Common Table Expressions) are expressions that define temporary tables for use in a more complex query.  These temporary tables are created only for the current query, which is convenient for the short-term presentation of data in one form or another.  For example, the <code>Employer</code> (employer, or client) ‚Äîone of the central entities ‚Äî can be represented as a more specialized object with a reduced set of fields using CTE. <br><br>  Suppose we need to find duplicate customers - that is, companies that have matches for several parameters, for example, the address of registration or the url of the site.  Among other things, there is a check for the coincidence of the name of the company (or its part), then the <code>LIKE</code> operator comes in just here: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> clients(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ‚Ä¶) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employer.employer_id <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> employerId, employer.name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> employerName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employer <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> employer <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> clients <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> clients <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> employer.name <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%'</span></span> || clients.name || <span class="hljs-string"><span class="hljs-string">'%'</span></span></code> </pre> <br><p>  So, for the following list of clients: </p><br><ul><li>  Alice </li><li>  Bob </li><li>  Headhunter </li><li>  Customer </li><li>  Alice cooper </li><li>  Bob marley </li></ul><br><p>  the result of the query was very different depending on what was inserted into the <code>WITH</code> statement (see table). </p><br><img src="https://habrastorage.org/web/ccd/d3c/e6d/ccdd3ce6d7104411843eaf26a1224beb.png"><br><br><p>  It seems that PostgreSQL always gives a predictable result, and HSQLDB has problems in all cases when more than one value falls into the temporary table, which should be joined by join.  As a result, we had to correct the source data in the test, because, as can be seen from the table, PostgreSQL and HSQLDB react differently to multiple values ‚Äã‚Äãin the temporary table, and in the test several clients were checked. </p><br><h3 id="raznaya-reakciya-na-nekorrektnyy-sql">  Different reaction to incorrect SQL </h3><br><p>  In our data model, there are objects that store sql code that is executed in order to find out if an object is suitable for certain conditions.  Naturally, there is a desire to check the behavior of the system when it encounters incorrect sql code, so we have the appropriate test: the incorrect sql is passed to the object, and then the method that this sql executes is called. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> user_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> user111 <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> employer_id = :employerId</code> </pre> <br><p>  Of course, the <code>user111</code> table <code>user111</code> not exist - this is the erroneous writing of the <code>user</code> table.  At attempt of execution of incorrect sql <code>RuntimeException</code> processed, excepting object from further process;  It is this behavior that was tested by dough.  Indeed, when executing on HSQLDB, the code fell with an <code>SQLException</code> error (inherited from <code>Exception</code> ), which was then converted to <code>JDBCException</code> (inherited from <code>RuntimeException</code> ), this exception, in turn, was processed in the service method, removing the object being checked from the results, then additional operations were performed successfully for processed objects - and the test was completed correctly. <br><br>  When the test was run on PostgreSQL, the error was still intercepted, converted to <code>JDBCException</code> and sent further, the incorrect object was excluded from processing, and everything would be fine, but the following actions were interrupted due to the fact that when an error of this kind occurred in the request - namely, when attempting to access a table that does not exist, PostgreSQL aborts the transaction, and other requests are no longer processed, which ultimately led to an incorrect end of the test. </p><br><h3 id="problemy-s-sortirovkoy">  Sorting problems </h3><br><p>  Here we can distinguish two classes of problems.  The first is the inconsistency of the order of the entities in the test code and as a result of the request.  For example, in a test there is a list of several instances, which are then created in the database and unloaded from it also as a list.  So, in HSQLDB, the order in which objects were loaded from the database always coincided with the order in the source list.  In PostgreSQL, the order did not coincide slightly less than in all tests where a similar construct was used, which led to the need to either use explicit sorting of the source and result lists, or compare lists without taking into account the order of elements (by the way, for these purposes it is quite convenient to use the <code>arrayContainingInAnyOrder</code> method from matcher framework Hamcrest). <br><br>  The second problem turned out to be more serious: some tests in which database sorting was used ( <code>ORDER BY</code> ) stopped working.  And the sorting behaved differently when running on different environments: after replacing the names of a couple of jobs, the test began to work correctly on Linux, but still did not work when running on MacOS and Windows. <br><br>  Naturally, the suspicion fell on the locale settings in PostgreSQL ‚Äî namely, the one that is responsible for sorting the rows in the database ‚Äî <code>LC_COLLATE</code> .  This setting does not depend on the encoding specified when creating the database: if you do not specify this parameter explicitly when the database is initialized in <code>createdb</code> or <code>initdb</code> , PostgreSQL will take the value from the operating system (by the way, you cannot change it after the database is initialized).  Sorting rules can be very different: for example, take into account or not take into account spaces, as well as determining the priority of lowercase or uppercase letters. <br><br>  Thus, we received tests, the results of which depend on the operating system ‚Äî that is, a rather lousy situation.  It would be possible to use a setting that allows sorting according to rules independent of the OS, using the standard sorting supplied with PostgreSQL, <code>LC_COLLATE=C</code> , but this option did not work, because in the implementation of embedded-pg from OpenTable there is no possibility to pass parameters to <code>initdb</code> .  In the current implementation, you can change the server configuration at the start of the database, but you cannot set the <code>collate</code> settings there, so the problematic tests temporarily went to <code>@Ignore</code> .  By the way, the OpenTable maintainer recognized the need for this feature, so after a brief discussion we created a PR in which we added the ability to initialize the database with different locale settings.  Releases occur infrequently, but we hope that in the next version of embedded-pg this problem will be solved. </p><br><h2 id="problema-meppinga-polzovatelskih-tipov">  Problem of mapping custom types </h2><br><p>  As it is known, in Hibernate for storing fields of type ‚Äúarray‚Äù in the database, you need to write a custom type that implements the <code>UserType</code> interface.  All you need to do is implement the necessary methods, including <code>sqlTypes()</code> , which determines the SQL type of the column in the database, as well as <code>nullSafeSet()</code> and <code>nullSafeGet()</code> , and add the <code>@Type</code> annotation indicating the custom type to the field declaration in the entity class (or by specifying this type in the mapping file). <br><br>  In our projects, <code>java.sql.Array</code> was originally used to read and write objects of the array type, which works fine in conjunction with PostgreSQL in production.  But, since mapping did not work in this way in HSQLDB, it was necessary to test entities that have arrays in their composition, we changed the implementation of user types a little.  Direct implementation of <code>nullSafeSet()</code> and <code>nullSafeGet()</code> now managed strategies: the default code used was <code>PostgreSQLArrayStrategy</code> , which works with <code>java.sql.Array</code> , and during the execution of tests a custom <code>HsqldbArrayStrategy</code> strategy was passed to the user types, which used the <code>HsqldbArrayStrategy</code> pass to the user types to use the special types <code>HsqldbArrayStrategy</code> , which used the <code>HsqldbArrayStrategy</code> transfer the user types to send the <code>HsqldbArrayStrategy</code> special types <code>HsqldbArrayStrategy</code> . <code>java.sql.Blob</code> . <br><br>  After translating the tests to PostgreSQL, we naively hoped that it would be easy to remove everything related to HSQLDB and the mapping will work by itself, but, of course, it was not so simple.  In production, the class <code>AbstractJdbcConnection</code> used to get the sql type corresponding to the java type, which correctly resolves the types of arrays without any additional settings.  Unfortunately, in the case of tests, this approach worked only half: the <code>connection</code> used only when performing the tests directly.  At the same time, when creating a test base, another type definition mechanism works, namely, their mapping occurs during the creation of the <code>SessionFactory</code> , when metadata that represents the ORM model is initialized.  This mechanism still needed to explicitly specify the type of arrays in the dialect description, otherwise Hibernate simply could not create a table with an array field: <br><br> <code>org.hibernate.MappingException: No Dialect mapping for JDBC type: 2003</code> <br> <br>  The problem was that we could not specify the sql type for the arrays in the dialect file, because we had two ( <code>String</code> and <code>Integer</code> ), and only one type could be connected in this way, for example: </p><br><pre> <code class="java hljs">registerColumnType(Types.ARRAY, <span class="hljs-string"><span class="hljs-string">"integer[$l]"</span></span>);</code> </pre> <br><p>  I had to look for a workaround: for each user-defined type, an array type identifier was created, for example, string arrays were associated with type <code>200301</code> , and arrays of integers ‚Äî with type <code>200302</code> .  This identifier was returned in the <code>sqlTypes()</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumArrayUserTypeString</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumArrayUserType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VARCHAR_ARRAY_SQL_TYPE = <span class="hljs-number"><span class="hljs-number">200301</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] sqlTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {VARCHAR_ARRAY_SQL_TYPE}; } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Then the types were registered in a dialect: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HHPostgreSQLDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostgreSQL9Dialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HHPostgreSQLDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ registerColumnType(EnumArrayUserTypeString.VARCHAR_ARRAY_SQL_TYPE, <span class="hljs-string"><span class="hljs-string">"varchar[$l]"</span></span>); registerColumnType(EnumArrayUserTypeInteger.INT_ARRAY_SQL_TYPE, <span class="hljs-string"><span class="hljs-string">"integer[$l]"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  After these manipulations, Hibernate was finally satisfied and created the necessary tables without any problems. </p><br><h2 id="problemy-s-proizvoditelnostyu">  Performance issues </h2><br><p>  For a snack - the most burning question: what happened to the test performance?  After all, HSQLDB was located directly in the memory, and embedded-pg - although the built-in, but in fact, full-fledged database, which creates a whole bunch of files at the start! <br><br>  The first results were quite depressing: on machines with SSD, when running all the tests in the module, the speed dropped by 25‚Äì30%, on older machines with SATA everything was even worse (slowing down to 40%).  The situation became noticeably better if the tests were run in several threads: <br><br> <code>mvn clean test -T C1</code> <br> <br>  - but still did not cause delight, especially among those who had previously banished tests in multi-threaded mode. <br><br>  We noticed suspicious logs when testing a project consisting of several modules: as soon as surefire started testing the next module, a new database instance was launched, with all the consequences: creating a data schema, filling in tables with test data - in general, many expensive I / O-operations.  This seemed strange because the singleton holder was responsible for creating the base instance, which was written according to all the rules, including the volatile field for the instance storage and double-check locking in the receive method.  What was our surprise when it turned out that this singleton was not exactly a singleton when the maven-surefire-plugin was involved! <br><br>  By default, when testing the next module, surefire creates a new JVM process.  In this process, all tests related to the module are performed;  when testing is complete, surefire moves on to the next module that will be executed in the new JVM.  The configuration of this behavior is controlled by the <code>forkCount</code> parameter, which by default is 1 (one new JVM per module).  If this parameter is set to 0, then all modules will be executed in the same JVM. <br><br>  It became clear that when using <code>forkCount=1</code> we received a new PostgreSQL instance at the start of each module.  Then it was decided to try to use one JVM for all tests, but in this case it turned out that an instance is created every time the next module starts!  The reason for this was the so-called Isolated Classloader, which was used by surefire in the case of <code>forkCount=0</code> .  Despite the explicit instructions to use the system classifier ( <code>useSystemClassloader=true</code> ), in this case the surefire switches to isolated (by the way, reporting this in the logs, and the documentation on this behavior emphasizes - see <a href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/class-loading.html">Class Loading and Forking in Maven Surefire</a> ).  So, for each module, a separate classifier is created, which loads all the classes anew and, accordingly, re-creates our singleton instance with reference to the base instance.  Thus, the problem was due to the internal mechanism of work surefire, and we decided to focus on those aspects of performance that could be corrected. </p><br><h3 id="vremennye-fayly-v-ram">  Temporary files in ram </h3><br><p>  First, we decided to transfer temporary files that embedded-pg creates during its operation from disks to memory, that is, to place them in a partition mounted as RAM FS.  This approach was supposed to improve the situation at least on machines with slow disks, especially since by that time it was already used in tests to speed up another DBMS, <a href="http://cassandra.apache.org/">Apache Cassandra</a> - so there was no need to reinvent the wheel, it was necessary only to slightly expand and unify the code .  The only "but": the old code was guided only by Linux, which supports the <a href="https://ru.wikipedia.org/wiki/Tmpfs">tmpfs</a> file system.  On Macs, there is also an analogue tmpfs, but, unlike Linux, MacOS does not have a partition that is created with such a default file system, like <code>/dev/shm</code> or <code>/run</code> in Linux.  It's pretty easy to create, but it required the actions of developers, and I wanted everything to work transparently.  Windows    :  ,        (    ,      ),   RAM FS ‚Äú ‚Äù     ,       , , RamDisk,        PostgreSQL. ,        ,  ,  ,      ( 5%),     . </p><br><h3 id="pul-soedineniy">   </h3><br><p> ,    ,   :    HSQLDB,     in-memory database ‚Äî  ,     , PostgreSQL     ‚Äî      jdbc url  !       ,         <code>Connection</code> , ,  ,   ?      c3p0 ‚Äî      ,          HSQLDB.      ,          ,   . </p><br><h3 id="nastroyki-postgresql">  PostgreSQL </h3><br><p>       PostgreSQL: </p><br><ul><li>  <code>autovacuum</code>     ; </li><li>    ( <code>preparedThreshold=X</code> )      ‚Äî     1  4; </li><li>       , , <code>shared_buffers</code>  <code>effective_cache_size</code>      (     ,   ).  ,          ,     ‚Äî         ,         RAM,       . </li></ul><br><h2 id="chto-v-itoge">  What is the result? </h2><br><p>   HSQLDB  PostgreSQL,         ,     .      ,    ,      ,    ‚Äî  ,        ,        ,    . <br><br>    ,     : -    ,          ,       . -    ‚Äî ,     maven-surefire-plugin    PostgreSQL.        :      ,  ,       - -    . <br><br> <strong>UPD:</strong>   ,  yandex-qatools   " ¬´¬ª" ‚Äî       ‚Äî         .  <a href="https://habrahabr.ru/users/lanwen/" class="user_link">Lanwen</a>  ! </p></div><p>Source: <a href="https://habr.com/ru/post/333616/">https://habr.com/ru/post/333616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333606/index.html">7 best device farm for mobile app testing</a></li>
<li><a href="../333608/index.html">MBLTdev 2017 is coming. Registration is open</a></li>
<li><a href="../333610/index.html">TamTam: how we made a new messenger</a></li>
<li><a href="../333612/index.html">Deep Learning, now in OpenCV</a></li>
<li><a href="../333614/index.html">Why Python Networker</a></li>
<li><a href="../333618/index.html">Solid RealTime on React and Socket.io</a></li>
<li><a href="../333622/index.html">Dereferencing null pointers is no longer a problem.</a></li>
<li><a href="../333624/index.html">Apple will spend a billion on Chinese data center</a></li>
<li><a href="../333626/index.html">Creating servlets for dummies. Walkthrough</a></li>
<li><a href="../333628/index.html">Analyzing NHL players careers with Survival Regression and Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>