<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search strings and related questions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear community! Recently on Habr√© a good overview article about different substring search algorithms in a string jumped. Unfortunately, there ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search strings and related questions</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear community!  Recently on Habr√© a good overview <a href="http://habrahabr.ru/blogs/algorithm/111449/">article</a> about different substring search algorithms in a string jumped.  Unfortunately, there were no detailed descriptions of any of the mentioned algorithms.  I decided to fill this gap and describe at least a couple of those that can potentially be remembered.  Those who still remember the course of algorithms from the institute, apparently, will not find anything new for themselves. <br><a name="habracut"></a><br>  At first I would like to prevent the question ‚Äúwhy the hell is this necessary?  everything is already written. ‚Äù  Yes, it is written.  But firstly, it is useful to know how the tools you use work at a lower level in order to better understand their limitations, and secondly, there are quite large adjacent areas where the strstr () function working from the box will not be enough.  And thirdly, you may not be able to drive and will have to develop a mobile platform with an inferior runtime, and then it‚Äôs better to know what you are signing up for if you decide to supplement it yourself (to make sure that this is not a spherical problem in a vacuum, just try wcslen () and wcsstr () from Android NDK). <br><br><h4>  And is it just impossible to search? </h4><br>  The fact is that the obvious way, which formulates everything as ‚Äútake and search‚Äù, is by no means the most effective, but for such a low-level and relatively part-called function, this is important.  So, the plan is: <br><ol><li>  Problem Statement: here are the definitions and conventions. </li><li>  The solution "in the forehead": it will be described here how to do it is not necessary and why. </li><li>  Z-function: the simplest version of the correct implementation of the search for substrings. </li><li>  Knuth-Morris-Pratt algorithm: another version of the correct search. </li><li>  Other search tasks: briefly run through them without a detailed description. <br></li></ol><br><br><h4>  Formulation of the problem </h4><br>  The canonical version of the problem looks like this: we have the string <b>A</b> ( <i>text</i> ).  It is necessary to check whether there is a substring <b>X</b> ( <i>pattern</i> ) in it, and if so, where it begins.  That is exactly what the strstr () function does in C. In addition, you can also ask to find all the occurrences of the sample.  Obviously, the problem makes sense only if <b>X is</b> not longer than <b>A.</b> <br>  For simplicity, further explanation will introduce a couple of concepts at once.  What a <i>string</i> everyone probably understands is a sequence of characters, perhaps an empty one.  <i>Symbols</i> , or letters, belong to a certain set, which is called the <i>alphabet</i> (this alphabet, generally speaking, may not have anything in common with the alphabet in the everyday sense).  <i>Line length</i> |  <b>A</b> |  - this is obviously the number of characters in it.  <i>The prefix of the string</i> <b>A [</b> ..i <b>]</b> is a string of i first characters of the string <b>A.</b>  <i>The string suffix</i> <b>A [</b> j .. <b>]</b> is the string from |  <b>A</b> | -j + 1 last characters.  The substring from <b>A</b> will be denoted as <b>A [</b> i..j <b>]</b> , and <b>A [</b> i <b>]</b> - the i-th character of the string.  Question about empty suffixes and prefixes, etc.  do not touch - it is not difficult to deal with them in place.  There is also such a thing as <i>seninel</i> , a unique symbol not found in the alphabet.  It is denoted by the $ symbol and complements the allowable alphabet with such a symbol (this is in theory, in practice it is easier to apply additional checks than to invent such a symbol that could not appear in the input strings). <br>  In the calculations we will count the characters in the string from the first position.  Code writing is traditionally easier to count from zero.  The transition from one to another is not difficult. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Head to Head Solution </h4><br>  Direct search, or, as it is often said, ‚Äújust take and search‚Äù is the first solution that comes to the mind of an inexperienced programmer.  The point is simple: follow the tested string <b>A</b> and look for the occurrence of the first character of the search string <b>X in it</b> .  When we find, we make a hypothesis that this is the very desired entry.  It then remains to check in turn all subsequent characters of the pattern for matching with the corresponding characters of string <b>A.</b>  If they all matched, then here it is, right in front of us.  But if any of the characters did not match, then nothing remains but to recognize our hypothesis as incorrect, which brings us back to the character following the occurrence of the first character from <b>X.</b> <br>  Many people are mistaken at this point, considering that they should not go back, but it is possible to continue processing line <b>A</b> from the current position.  Why it is not so easy to demonstrate by the example of the search <b>X</b> = <i>"AAAB"</i> in <b>A</b> = <i>"AAAAB"</i> .  The first hypothesis will lead us to the fourth symbol <b>A</b> : <i>"AAAAB"</i> , where we will find a discrepancy.  If you do not roll back, then the entry, we will not find, although it is. <br>  Incorrect hypotheses are inevitable, and due to such rollbacks under bad circumstances, it may turn out that we checked every character in <b>A</b> about |  <b>X</b> |  time.  That is, the computational complexity is the complexity of the algorithm O (| <b>X</b> || <b>A</b> |).  So the search for a phrase in a paragraph may be delayed ... <br>  To be fair, it should be noted that if the lines are small, then such an algorithm can work faster than the ‚Äúcorrect‚Äù algorithms at the expense of a more predictable processor behavior. <br><br><h4>  Z-function </h4><br>  One of the categories of correct ways to search for a string is reduced to calculating in some sense the correlation of two strings.  First, we note that the task of comparing two lines began is simple and clear: we compare the corresponding letters until we find a discrepancy or one of the lines ends.  Consider the set of all suffixes of the string <b>A</b> : <b>A [</b> |  <b>A</b> | .. <b>]</b> <b>A [</b> |  <b>A</b> | -1 .. <b>]</b> , ... <b>A [</b> 1 .. <b>]</b> .  We will compare the beginning of the string itself with each of its suffixes.  Comparison can reach the end of the suffix, or break on some character due to a mismatch.  The length of the matched part is called the component of the <a href="http://ru.wikipedia.org/wiki/Z-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">Z-function</a> for a given suffix. <br>  That is, a Z-function is a vector of lengths of the greatest common prefix of a string with its suffix.  Wow!  An excellent phrase when you need to confuse or assert oneself, but to understand what it is, it is better to look at an example. <br>  The original string is <i>"ababcaba"</i> .  By comparing each suffix with the line itself, we get a label for the Z-function: <br><table><tbody><tr><th>  suffix </th><th>  line </th><th></th><th>  Z </th></tr><tr><td>  ababcaba </td><td>  ababcaba </td><td>  -&gt; </td><td>  eight </td></tr><tr><td>  babcaba </td><td>  ababcaba </td><td>  -&gt; </td><td>  0 </td></tr><tr><td>  abcaba </td><td>  ababcaba </td><td>  -&gt; </td><td>  2 </td></tr><tr><td>  bcaba </td><td>  ababcaba </td><td>  -&gt; </td><td>  0 </td></tr><tr><td>  caba </td><td>  ababcaba </td><td>  -&gt; </td><td>  0 </td></tr><tr><td>  aba </td><td>  ababcaba </td><td>  -&gt; </td><td>  3 </td></tr><tr><td>  ba </td><td>  ababcaba </td><td>  -&gt; </td><td>  0 </td></tr><tr><td>  a </td><td>  ababcaba </td><td>  -&gt; </td><td>  one </td></tr></tbody></table><br><br>  The suffix prefix is ‚Äã‚Äãnothing more than a substring, and the Z-function is the length of the substrings that occur simultaneously in the beginning and in the middle.  Considering all the values ‚Äã‚Äãof the components of the Z-function, you can notice some regularities.  First, it is obvious that the value of the Z-function does not exceed the length of the string and coincides with it only for the ‚Äúfull‚Äù suffix <b>A [</b> 1 .. <b>]</b> (and therefore this value does not interest us - we will omit it in our reasoning).  Secondly, if there is a single character in the string, it can only match itself, which means it divides the line into two parts, and the value of the Z-function can never exceed the length of the shorter part. <br>  It is proposed to use these observations as follows.  Suppose in the line <i>"ababcabacacab"</i> we want to search for <i>"abca"</i> .  We take these lines and concatenate, inserting the Sentinel between them: <i>‚Äúabca $ ababcabacacab‚Äù</i> .  The vector of the Z-function looks like this: <br><table><tbody><tr><td>  a b c a $ a b a b c a b with a c a b </td></tr><tr><td>  17 0 0 1 0 2 0 4 0 0 4 0 0 1 0 2 0 </td></tr></tbody></table><br><br>  If we discard the value for the full suffix, then the presence of the centinela limits Z <sub>i to the</sub> length of the desired fragment (it is the smaller half of the line in the sense of the problem).  But if this maximum is reached, it is only in the positions of the substring entry.  In our example, the quadruples mark <u>all the</u> positions of the occurrence of the search string (note that the found plots are located overlapping with each other, but all the same, our reasoning remains true). <br>  Well, that means if we can quickly build a vector of the Z-function, then a search with it for all occurrences of a string is reduced to finding the value of its length in it.  That's just if you calculate the Z-function for each suffix, then it will be clearly not faster than the solution "in the forehead."  It helps us that the value of the next element of the vector can be found based on the previous elements. <br>  Suppose we somehow calculated the values ‚Äã‚Äãof the Z-function up to the corresponding i-1st symbol.  Consider a certain position r &lt;i, where we already know Z <sub>r</sub> . <br>  So Z <sub>r</sub> characters from this position are exactly the same as at the beginning of the line.  They form the so-called Z-block.  We will be interested in the rightmost Z-block, that is, the one who ends the farthest (the very first does not count).  In some cases, the rightmost block may be zero length (when none of the non-empty blocks cover i-1, then the rightmost one will be i-1st, even if Z <sub>i-1</sub> = 0). <br><img src="https://habrastorage.org/storage/habraeffect/e4/b6/e4b684fdf01d477d799715fc8a7c4ae2.png" alt="Z-block layout"><br>  When we consider the subsequent characters inside this Z-box, it makes no sense to compare the next suffix from the very beginning, since part of this suffix has already been encountered at the beginning of the line, which means it has already been processed.  It will be possible to immediately skip the characters right up to the end of the Z-block. <br><img src="https://habrastorage.org/storage/habraeffect/c9/9b/c99bad7e0f77757718763de8a853f4e7.png" alt="Suffix skip"><br><img src="https://habrastorage.org/storage/habraeffect/48/96/4896d7662002e343927b7bcf9c77a6a6.png" alt="Previous results"><br>  Namely, if we consider the i-th character in the Zr-block, that is, the corresponding character at the beginning of the line at position k = i-r + 1.  The function Z <sub>k</sub> is already known.  If it is less than the distance Z <sub>r</sub> - (ir) remaining to the end of the Z-block, then we can immediately be sure that the whole area of ‚Äã‚Äãcoincidence for this symbol lies inside the r-block of the Z-block and the result will be the same as in the beginning of the line: Z <sub>i</sub> = Z <sub>k</sub> .  If Z <sub>k</sub> &gt; = Z <sub>r</sub> - (ir), then Z <sub>i is</sub> also greater than or equal to Z <sub>r</sub> - (ir).  To find out how much more it is, we will need to check the symbols following the Z-block.  Moreover, in case of coincidence of these characters with the corresponding at the beginning of the line, Z <sub>i is</sub> increased by h: Z <sub>i</sub> = Z <sub>k</sub> + h.  As a result, we may have a new right-most Z-block (if h&gt; 0). <br><img src="https://habrastorage.org/storage/habraeffect/14/a0/14a0d223bc40ece1d203aa4bcfb20945.png" alt="Outside Z-block"><br>  Thus, we have to compare characters only to the right of the rightmost Z-block, and due to successful comparisons, the block ‚Äúmoves‚Äù to the right, and unsuccessful ones report that the calculation for this position is over.  This provides us with the construction of the entire vector of the Z-function in a time linear in the line length. <br>  Applying this algorithm to search for substrings we obtain the complexity of the time O (| <b>A</b> | + | <b>X</b> |), which is much better than the product, which was in the first version.  True, we had to store the vector for the Z-function, which would take additional memory of order O (| <b>A</b> | + | <b>X</b> |).  In fact, if you do not need to find all occurrences, but only one is enough, then you can get by with O (| <b>X</b> |) memory, since the length of the Z-block still cannot be more than |  <b>X</b> |, except that you can not continue processing the string after the first occurrence. <br>  Finally, an example of a function that calculates the Z-function.  Just a model option without any tricks. <br><pre> <code class="hljs vbscript">void z_preprocess(vector&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; &amp; Z, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; str) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size_t <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = str.size(); Z.clear(); Z.resize(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>) return; Z[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t curr = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; curr &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; ++curr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curr &gt;= <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>) { size_t off = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( curr + off &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &amp;&amp; str[curr + off] == str[off] ) ++off; Z[curr] = off; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> = curr + Z[curr]; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = curr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size_t equiv = curr - <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z[equiv] &lt; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> - curr) Z[curr] = Z[equiv]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { size_t off = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> + off &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &amp;&amp; str[<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> - curr + off] == str[<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> + off] ) ++off; Z[curr] = <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> - curr + off; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span> += off; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = curr; } } } } <br></code> </pre> <code>void z_preprocess(vector&lt;int&gt; &amp; Z, const string &amp; str) { const size_t len = str.size(); Z.clear(); Z.resize(len); if (0 == len) return; Z[0] = len; for (size_t curr = 1, left = 0, right = 1; curr &lt; len; ++curr) { if (curr &gt;= right) { size_t off = 0; while ( curr + off &lt; len &amp;&amp; str[curr + off] == str[off] ) ++off; Z[curr] = off; right = curr + Z[curr]; left = curr; } else { const size_t equiv = curr - left; if (Z[equiv] &lt; right - curr) Z[curr] = Z[equiv]; else { size_t off = 0; while ( right + off &lt; len &amp;&amp; str[right - curr + off] == str[right + off] ) ++off; Z[curr] = right - curr + off; right += off; left = curr; } } } } <br></code> <br><br><h4>  Knuth-Morris-Pratt Algorithm (CMP) </h4><br>  Despite the logical simplicity of the previous method, a more popular is another algorithm, which in some sense is the inverse of the Z-function - <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">the Knut-Morris-Pratt algorithm</a> (CMP).  We introduce the concept of <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">prefix function</a> .  The prefix function for the i-th position is the length of the maximum string prefix, which is shorter than i and which matches the suffix of the prefix of length i.  If the definition of the Z-function didn‚Äôt hit the opponent outright, then with this combo you will definitely be able to put it in place :) And in human language it looks like this: take every possible string prefix and look at the longest match beginning with the end of the prefix (disregarding the trivial match with myself).  Here is an example for <i>ababcaba</i> : <br><table><tbody><tr><th>  prefix </th><th>  prefix </th><th>  p </th></tr><tr><td>  a </td><td>  a </td><td>  0 </td></tr><tr><td>  ab </td><td>  ab </td><td>  0 </td></tr><tr><td>  ab <b>a</b> </td><td>  <b>a</b> ba </td><td>  one </td></tr><tr><td>  ab <b>ab</b> </td><td>  <b>ab</b> ab </td><td>  2 </td></tr><tr><td>  ababc </td><td>  ababc </td><td>  0 </td></tr><tr><td>  ababc <b>a</b> </td><td>  <b>a</b> babca </td><td>  one </td></tr><tr><td>  ababc <b>ab</b> </td><td>  <b>ab</b> abcab </td><td>  2 </td></tr><tr><td>  ababc <b>aba</b> </td><td>  <b>aba</b> bcaba </td><td>  3 </td></tr></tbody></table><br><br>  Again, we observe a number of properties of the prefix function.  First, the values ‚Äã‚Äãare bounded above by their number, which follows directly from the definition - the prefix length must be greater than the prefix function.  Secondly, the unique symbol in the same way divides the string into two parts and limits the maximum value of the prefix-function to the length of the smaller part - because everything that is longer will contain a unique, nothing else equal symbol. <br>  From here we get the conclusion that interests us.  Suppose we did reach at some element of this theoretical ceiling.  This means that such a prefix has ended here, that the initial part coincides with the final part and one of them represents the ‚Äúcomplete‚Äù half.  It is clear that in the prefix the complete half should be in front, which means with this assumption it should be the shorter half, the maximum we reach on the longer half. <br>  Thus, if, as in the previous part, we concatenate the desired line with the one in which we are looking through the Sentinel, then the point of entry of the length of the required substring in the component of the prefix function will correspond to the place where the entry ends.  Take our example: in the string <i>‚Äúababcabacacab‚Äù</i> we are looking for <i>‚Äúabca‚Äù</i> .  The concatenated version <i>of abca $ ababcabacacab</i> .  The prefix function looks like this: <br><table><tbody><tr><td>  a b c a $ a b a b c a b with a c a b </td></tr><tr><td>  0 0 0 1 0 1 2 1 2 3 2 2 3 4 0 1 2 </td></tr></tbody></table><br><br>  Again, we found all occurrences of the substring in one fell swoop - they end in four positions.  It remains to understand how to effectively calculate this prefix function.  The idea of ‚Äã‚Äãthe algorithm is slightly different from the idea of ‚Äã‚Äãconstructing a Z-function. <br><img alt="KMP" src="https://habrastorage.org/storage/habraeffect/2c/14/2c142d3ba02a29b5c925d855fbce49c4.png"><br>  The very first value of the prefix function is obviously 0. Suppose we calculated the prefix function to the i-th position inclusive.  Consider the i + 1st character.  If the value of the prefix function in the i-th position is P <sub>i</sub> , then the prefix <b>A [</b> ..P <sub>i</sub> <b>]</b> coincides with the substring <b>A [</b> iP <sub>i</sub> + 1..i <b>]</b> .  If the symbol <b>A [</b> P <sub>i</sub> +1 <b>]</b> coincides with <b>A [</b> i + 1 <b>]</b> , then we can safely write down that Pi <sub>+ 1</sub> = Pi + 1.  But if not, then the value can be either less or the same.  Of course, when P <sub>i</sub> = 0 there is no place to decrease much, so in this case P <sub>i + 1</sub> = 0.  Suppose that P <sub>i</sub> &gt; 0.  Then there is the prefix <b>A [</b> ..P <sub>i</sub> <b>]</b> in the string, which is equivalent to the substring <b>A [</b> iP <sub>i</sub> + 1..i <b>]</b> .  The desired prefix function is formed within these equivalent sections plus the character being processed, which means we can forget about the entire line after the prefix and leave only the given prefix and i + 1st character - the situation will be identical. <br><img alt="KMP" src="https://habrastorage.org/storage/habraeffect/f8/86/f88603d37028316f1c8727d4abca1193.png"><br>  The task at this step has been reduced to a task for a line with a cut out center line: <b>A [</b> ..P <sub>i</sub> <b>] A [</b> i + 1 <b>]</b> , which can be solved recursively in the same way (although tail recursion is not a recursion at all, but a cycle).  That is, if <b>A [</b> P <sub>P <sub>i</sub></sub> +1 <b>]</b> coincides with <b>A [</b> i + 1 <b>]</b> , then P <sub>i + 1</sub> = P <sub>P <sub>i</sub></sub> +1, otherwise, we again throw out part of the line from consideration, etc.  Repeat the procedure until we find a match or do not reach 0. <br><img alt="KMP" src="https://habrastorage.org/storage/habraeffect/97/25/9725ee29bae85d1861f0c1a339d5273a.png"><br>  The repetition of these operations should be alerted - it would seem that there are two nested cycles.  But it is not.  The fact is that a nested loop with a length of k iterations reduces the prefix function in the i + 1 position by at least k-1, and in order to increase the prefix function to such a value, you need at least k-1 times successfully match the letters by processing k-1 characters.  That is, the cycle length corresponds to the interval between the execution of such cycles and therefore the complexity of the algorithm is still linear in the length of the processed line.  With memory, this is the same situation as with the Z-function - linear in the length of the line, but there is a way to save.  In addition, there is a convenient fact that the characters are processed sequentially, that is, we are not obliged to process the entire line if we have already received the first entry. <br>  Well, for example, a snippet of code: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_prefix_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp; prefix_func, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> str_length = str.size(); prefix_func.clear(); prefix_func.resize(str_length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == str_length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; prefix_func[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> current = <span class="hljs-number"><span class="hljs-number">1</span></span>; current &lt; str_length; ++current) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> matched_prefix = current - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> candidate = prefix_func[matched_prefix]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (candidate != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[current] != str[candidate]) { matched_prefix = prefix_func[matched_prefix] - <span class="hljs-number"><span class="hljs-number">1</span></span>; candidate = prefix_func[matched_prefix]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate == <span class="hljs-number"><span class="hljs-number">0</span></span>) prefix_func[current] = str[current] == str[<span class="hljs-number"><span class="hljs-number">0</span></span>] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> prefix_func[current] = candidate + <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <br></code> </pre> <code>void calc_prefix_function(vector&lt;int&gt; &amp; prefix_func, const string &amp; str) { const size_t str_length = str.size(); prefix_func.clear(); prefix_func.resize(str_length); if (0 == str_length) return; prefix_func[0] = 0; for (size_t current = 1; current &lt; str_length; ++current) { size_t matched_prefix = current - 1; size_t candidate = prefix_func[matched_prefix]; while (candidate != 0 &amp;&amp; str[current] != str[candidate]) { matched_prefix = prefix_func[matched_prefix] - 1; candidate = prefix_func[matched_prefix]; } if (candidate == 0) prefix_func[current] = str[current] == str[0] ? 1 : 0; else prefix_func[current] = candidate + 1; } } <br></code> <br>  Despite the fact that the algorithm is more intricate, its implementation is even simpler than for the Z-function. <br><br><h4>  Other Search Tasks </h4><br>  Then there will be just a lot of letters that do not limit the search tasks to strings and that there are other tasks and other solutions, so if anyone is not interested, then you can not read further.  This information is just for reference, in case of need, at least to realize that ‚Äúeverything is already stolen before us‚Äù and not reinvent the bicycle. <br>  Although the above algorithms guarantee linear execution time, the title of the ‚Äúdefault <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">algorithm</a> ‚Äù was given to <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">the Boyer-Moore algorithm</a> .  On average, it also gives linear time, but also has a better constant for this linear function, but that is on average.  There are ‚Äúbad‚Äù data on which he is no better than the simplest ‚Äúhead-on‚Äù comparison (well, just like with qsort).  It is extremely confused and will not be considered - all the same I do not remember.  There are a number of exotic algorithms that are focused on natural language processing and rely in their optimizations on the statistical properties of words in a language. <br>  Well, well, we have an algorithm that somehow or another O (| <b>X</b> | + | <b>A</b> |) is looking for a substring in the string.  Now imagine that we are writing a guest book engine.  We have a list of forbidden swear words (it is clear that this will not help, but the task is just for example).  We are going to filter messages.  We will look for each of the forbidden words in the message and ... this will take O (| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + n | <b>A</b> |).  Somehow so-so, especially if the dictionary of "mighty expressions" of "great and mighty" is very "mighty."  For this case, there is a way to pre-process the dictionary of the required strings, that the search will occupy only O (| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + | <b>A</b> |), and this can be significantly less, especially if the messages are long. <br>  Such preprocessing is reduced to building a boron (trie) from a dictionary: a tree starts at some fictitious root, nodes correspond to letters of words in a dictionary, the depth of a tree node corresponds to the number of a letter in a word.  The nodes where the word from the dictionary ends is called terminal and is labeled in some way (in red in the figure). <br><img alt="Trie" src="https://habrastorage.org/storage/habraeffect/ed/54/ed54a3dfc08d2721c69533cb9c653873.png"><br>  The resulting tree is an analogue of the prefix function of the CMP algorithm.  With it, you can find all occurrences of all vocabulary words in a phrase.  It is necessary to go through the tree, checking for the presence of the next symbol in the form of a tree node, simultaneously noting the encountered terminal vertices - these are occurrences of words.  If there is no corresponding node in the tree, then, like in the ILC, a rollback takes place higher up the tree using special links.  This algorithm is called <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2590%25D1%2585%25D0%25BE-%25D0%259A%25D0%25BE%25D1%2580%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BA">the Aho-Corasica algorithm</a> .  The same scheme can be used to search during input and prediction of the next character in electronic dictionaries. <br>  In this example, the construction of boron is simple: we simply add words to the boron in turn (nuances only with additional references for ‚Äúkickbacks‚Äù).  There are a number of optimizations aimed at reducing the memory use of this tree (the so-called boron compression - skipping sections without branching).  In practice, these optimizations are almost optional.  The disadvantage of this algorithm is its alphabet dependence: the time to process the node and the memory occupied depends on the number of potential children, which is equal to the size of the alphabet.  For large alphabets, this is a serious problem (imagine a set of Unicode characters?).  You can read more about all this in this <a href="http://habrahabr.ru/blogs/algorithm/111874/">habratopic</a> or using GoogleIndex - the benefit of information on this subject is a lot. <br>  Now look at another task.  If in the previous one we knew in advance what we would have to find in the incoming data later, here it is exactly the opposite: we were given a line in advance, in which we would be searched, but what they would be looking for was unknown, but they would be searched a lot.  A typical example is a search engine.  The document in which the word is searched is known in advance, but the words that are searched there, are strewn on the go.  The question is, again, how instead of O (| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + n | <b>A</b> |) get O (| <b>X <sub>1</sub></b> | + | <b>X <sub>2</sub></b> | + ... + | <b>X <sub>n</sub></b> | + | <b>A</b> |)? <br>  It is proposed to build a bur in which will be all possible suffixes of the existing string.  Then the search for a pattern will be reduced to checking the presence of a path in the tree corresponding to the desired pattern.  If you build such a forest by searching all the suffixes, then this procedure can take O (| <b>A</b> | <sup>2</sup> ) time, and there is a lot of memory.  But, fortunately, there are algorithms that allow you to build such a tree at once in a compressed form - a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">suffix tree</a> , and to do it in O (| <b>A</b> |).  Recently on Habr√© was about this <a href="http://habrahabr.ru/blogs/algorithm/111675/">article</a> , so that those interested can read about the <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">algorithm Ukkonen</a> there. <br>  Poorly in a suffix tree, as usual, there are two things: the fact that it is a tree and the fact that the nodes of the tree are alphabetically dependent.  The <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D0%25B2">suffix array is</a> spared from these shortcomings.  The essence of the suffix array is that if all the suffixes of the string are sorted, then the search for the substring will be reduced to the search for a group of adjacent suffixes by the first letter of the desired pattern and further refinement of the range by the subsequent ones.  At the same time, there is no need to keep the suffixes in sorted form, it is enough to store the positions in which they begin in the original data.  True, the time dependences of this structure are somewhat worse: a single search will do O (| <b>X</b> | + log | <b>A</b> |) if you think and do everything neatly, and O (| <b>X</b> | log | <b>A</b> |) if you do not bother.  For comparison, in a tree for a fixed alphabet O (| <b>X</b> |).  But the fact that this is an array, and not a tree, can improve the situation with memory caching and make it easier for the predictor of processor transitions.  A suffix array is built in linear time using the K√§rkk√§inen-Sanders algorithm (sorry, but I have no idea how it should sound in Russian).  Today it is one of the most popular methods of indexing strings. <br>  We will not touch on the issues of approximate search for strings and analysis of the degree of similarity here - it is too big an area to be stuffed into this article.  Just to mention that people there did not eat bread for nothing, and came up with many different approaches, so if you run into a similar task, find and read.  Quite possibly this problem has already been solved. <br><br>  Thanks to those who read!  And for those who read to here, thank you very much! <br><br>  <b>UPD:</b> Added a <a href="http://habrahabr.ru/blogs/algorithm/111874/">link</a> to the informative article about boron (it‚Äôs a ray, it‚Äôs a prefix tree, it‚Äôs a loaded tree, it‚Äôs a trie). </div><p>Source: <a href="https://habr.com/ru/post/113266/">https://habr.com/ru/post/113266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113258/index.html">Creating a simple bot for the online game world of warcraft</a></li>
<li><a href="../113260/index.html">The second normal form in the examples</a></li>
<li><a href="../113263/index.html">We build Code Coverage collection in CruiseControl.NET</a></li>
<li><a href="../113264/index.html">Boot phone</a></li>
<li><a href="../113265/index.html">The idea of ‚Äã‚Äãwatching live broadcasts from phone to computer (YouTubeLive example)</a></li>
<li><a href="../113267/index.html">On foreign films can enter tax</a></li>
<li><a href="../113268/index.html">Do we need a language?</a></li>
<li><a href="../113269/index.html">Putting order in the old rubbish, or a tale about how accidentally collected a mini BP</a></li>
<li><a href="../113270/index.html">Recens CP - samopisnaya beta server control panel</a></li>
<li><a href="../113271/index.html">Creating a simple bot for WoW: continued</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>