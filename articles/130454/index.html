<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a shader on AGAL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's no secret that Flash Player 11 has support for GPU graphics acceleration. The new version introduces the Molehill API, allowing you to work with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a shader on AGAL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/256/82c/c53/25682cc536a50295f8bc4ff0b452f77e.png" align="right">  It's no secret that Flash Player 11 has support for GPU graphics acceleration.  The new version introduces the Molehill API, allowing you to work with a video card at a fairly low level, which, on the one hand, gives you full imagination, on the other hand, requires a deeper understanding of the principles of modern 3D graphics. <br><a name="habracut"></a><br>  This article <b>focuses</b> on the shader writing language - <b>AGAL</b> (Adobe Graphics Assembly Language).  It is assumed that the reader is familiar with the basic fundamentals of modern real-time 3D graphics, and ideally has experience with <b>OpenGL</b> or <b>Direct3D</b> .  For the rest I will spend a little digression: <br><ul><li>  in each frame everything is rendered anew, approaches with partial screen redrawing are extremely undesirable </li><li>  2D - a special case of 3D </li><li>  the graphics card can rasterize triangles and nothing else </li><li>  triangles are built on vertices </li><li>  each vertex contains attributes (coordinate, normal, weight, etc.) </li><li>  the order in which the vertices in the triangle are defined is determined by the indices </li><li>  vertex and index data is stored in the vertex and index buffers respectively </li><li>  Shader - a program executed by a video card </li><li>  each vertex passes through the vertex shader, and each pixel during rasterization through a fragment (pixel) </li><li>  the video card does not know how to work with integers, but it works fine with 4D vectors </li></ul><br><h5>  Syntax </h5><br>  In the current implementation of AGAL, ‚Äã‚Äãthe Shader Model 2.0 trim is used, i.e.  iron fitchist limited to 2005.  But it is worth remembering that this restriction is only the capabilities of the shader program, but not the performance of the hardware.  Perhaps in future versions of Flash Player, the bar will be raised to SM 3.0, and we can render several textures at once and make a texture sample directly from the vertex shader, but taking into account the Adobe policy, this will happen not earlier than the next generation of mobile devices. <br><br>  Any program on AGAL is essentially a low-level assembly language.  The language itself is very simple, but it requires a fair amount of attentiveness.  The shader code is represented by a set of instructions like: <br><pre><code class="cpp hljs">opcode [dst], [src1], [src2]</code> </pre>  what in the free interpretation means ‚Äúto execute the opcode command with the src1 and src2 parameters, returning the value in dst‚Äù.  A shader can contain up to 256 instructions.  As dst, src1 and src2 are the names of registers: va, vc, fc, vt, ft, op, oc, v, fs.  Each of these registers, with the exception of fs, is a four-dimensional (xyzw or rgba) vector.  It is possible to work with individual components of the vector, including swizzling (a different order): <br><pre> <code class="cpp hljs">dp4 ft0.x, v0.xyzw, v0.yxww</code> </pre> <br>  Consider each of the types of registers in more detail. <br><br><h6>  Register output </h6><br>  As a result of the calculation, the vertex shader is obliged to write the value of the window position of the vertex to the <b>op</b> (output position) register, and the fragment shader - to <b>oc</b> (output color) the value of the final pixel color.  In the case of a fragment shader, it is possible to cancel the <b>kil</b> instruction, which will be described below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Register attribute </h6><br>  A vertex can contain up to 8 vector attributes, which are accessed from the shader via the <b>va</b> registers, whose position in the vertex buffer is specified by the <b>Context3D.setVertexBufferAt</b> function.  Attribute data can be in FLOAT_1, FLOAT_2, FLOAT_3, FLOAT_4 and BYTES_4 formats.  The number in the title indicates the number of components of the vector.  It should be noted that in the case of BYTES_4, the component values ‚Äã‚Äãare normalized, i.e.  are divided by 255. <br><br><h6>  Interpolator register </h6><br>  In addition to writing to the <b>op</b> register, the vertex shader can transfer up to 8 vectors to the fragment shader via the <b>v</b> registers.  The values ‚Äã‚Äãof these vectors will be linearly interpolated over the entire area of ‚Äã‚Äãthe polygon during rasterization.  We illustrate the work of interpolators using the example of a triangle, at the vertices of which the attribute displayed by the fragment shader is stored: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex mov op, va0 //   -  mov v0, va1 //        // fragment mov oc, v0 //      </span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/b57/b4e/ae3/b57b4eae3b9369c39d5b5a63490978aa.png"><br><br><h6>  Register Variable </h6><br>  In the vertex and fragment shaders, up to 8 registers <b>vt</b> and <b>ft are available</b> for storing intermediate calculation results.  For example, in a fragmentary shader, you must calculate the sum of four vectors taken from the vertex program (v0..v3 registers): <br><pre> <code class="cpp hljs">add ft0, v0, v1 <span class="hljs-comment"><span class="hljs-comment">// ft0 = v0 + v1 add ft0, ft0, v2 // ft0 = ft0 + v2 add ft0, ft0, v3 // ft0 = ft0 + v3</span></span></code> </pre> <br>  As a result, ft0 will store the amount we need, and everything seems to be great, but there is a seemingly unobvious optimization possibility that is directly related to the architecture of the video card software pipeline and is partly the reason for its high performance. <br><br>  The basis of shaders laid the concept of <b>ILP</b> (Instruction-level parallelism), which, judging from the name, allows you to perform several instructions simultaneously.  The main condition for using this mechanism is the independence of instructions from each other.  In relation to the example above: <br><pre> <code class="cpp hljs">add ft0, v0, v1 <span class="hljs-comment"><span class="hljs-comment">// ft0 = v0 + v1 add ft1, v2, v3 // ft1 = v2 + v3 add ft0, ft0, ft1 // ft0 = ft0 + ft1</span></span></code> </pre> <br>  The first two instructions will be executed at the same time, since  work with independent registers.  It follows that the key role in the performance of your shader is played not so much by the number of instructions as by their independence from each other. <br><br><h6>  Register-constant </h6><br>  Storage of numerical constants directly in the shader code is not allowed, i.e.  all the constants necessary for operation should be passed to the shader before the <b>Context3D.drawTriangles</b> call, and will be available in the <b>vc</b> (128 vectors) and <b>fc</b> registers (28 vectors).  It is possible to refer to the register by its index using square brackets, which is very convenient when implementing skeletal animation or indexing materials.  It is important to remember that the operation of specifying shader constants is relatively expensive and should be avoided if possible.  For example, it makes no sense to transfer to the shader the projection matrix in front of the render of each object, if it does not change in the current frame. <br><br><h6>  Sampler Register </h6><br>  Up to 8 textures can be passed to the fragment shader using the <b>Context3D.setTextureAt</b> function, which are accessed via the corresponding <b>fs</b> registers, which are used exclusively in the tex statement.  Let's slightly change the example with a triangle, and as the second attribute of the vertex, we will transfer the texture coordinates, and in the fragment shader we will make a texture sample using these already interpolated coordinates: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex mov op, va0 //  mov v0, va1 //   -   // fragment tex oc, v0, fs0 &lt;2d,linear&gt; //   </span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/e77/a8c/d7f/e77a8cd7f24fb01beedafd21c6c5f69a.png"><br><br><h5>  Operators </h5><br>  At the moment (October 2011), AGAL implements the following operators: <br><pre> <code class="bash hljs"> mov dst = src1 neg dst = -src1 abs dst = abs(src1) add dst = src1 + src2 sub dst = src1 ‚Äì src2 mul dst = src1 * src2 div dst = src1 / src2 rcp dst = 1 / src1 min dst = min(src1, src2) max dst = max(src1, src2) sat dst = max(min(src1, 1), 0) frc dst = src1 ‚Äì floor(src1) sqt dst = src1^0.5 rsq dst = 1 / (src1^0.5) pow dst = src1^src2 <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> dst = log2(src1) exp dst = 2^src1 nrm dst = normalize(src1) sin dst = sine(src1) cos dst = cosine(src1) slt dst = (src1 &lt; src2) ? 1 : 0 sge dst = (src1 &gt;= src2) ? 1 : 0 dp3   dst = src1.x*src2.x + src1.y*src2.y + src1.z*src2.z dp4       dst = src1.x*src2.x + src1.y*src2.y + src1.z*src2.z + src1.w*src2.w crs   dst.x = src1.y * src2.z ‚Äì src1.z * src2.y dst.y = src1.z * src2.x ‚Äì src1.x * src2.z dst.z = src1.x * src2.y ‚Äì src1.y * src2.x m33     33 dst.x = dp3(src1, src2[0]) dst.y = dp3(src1, src2[1]) dst.z = dp3(src1, src2[2]) m34     34 dst.x = dp4(src1, src2[0]) dst.y = dp4(src1, src2[1]) dst.z = dp4(src1, src2[2]) m44     44 dst.x = dp4(src1, src2[0]) dst.y = dp4(src1, src2[1]) dst.z = dp4(src1, src2[2]) dst.w = dp4(src1, src2[3]) kil       ,   src1  ,     alpha-test,       . tex       dst     src1   src2    ,   , : tex ft0, v0, fs0 &lt;2d,repeat,linear,miplinear&gt;     :   2d, cube  nearest, linear  nomip, miplinear, mipnearest  clamp, repeat</code> </pre><br>  The remaining operators, including conditional jumps and loops, are planned to be implemented in future versions of Flash Player.  But this does not mean that now even the usual if cannot be used, the slt and sge instructions are quite suitable for these tasks. <br><br><h5>  Effects </h5><br>  We got acquainted with the basics, now the most interesting part of the article is the practical application of new knowledge.  As mentioned at the very beginning, the ability to write a shader completely untie the hands of a graphics programmer, i.e.  the actual limitations are only in the imagination and mathematical ingenuity of the developer.  Previously, it was possible to make sure that the assembly language itself is simple, but behind the simplicity lies the complexity of ‚Äútasting‚Äù in the already forgotten code.  Therefore, I highly recommend commenting on key sections of the shader code in order to quickly navigate in it if necessary. <br><br><h6>  Stocking </h6><br>  The starting point for all the following examples will be a small ‚Äúblank‚Äù in the form of a teapot.  Unlike the example with a triangle, we need a matrix of projection and transformation of the camera, to create the effect of perspective and rotation around the object.  We will pass it to the constant registers.  Here it is important to remember that the 4x4 matrix occupies exactly 4 registers, and when writing it to the vc0 register, v0..v3 will be occupied.  We also need a constant vector of numbers often used in the shader (0.0, 0.5, 1.0, 2.0). <br>  Total, the base code of the shader will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex m44 op, va0, vc0 //  viewProj  // fragment mov ft0, fc0.xxxz //   ft0    mov oc, ft0 //  ft0    </span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/e2a/b77/c30/e2ab77c30e92693eb4cb0ef1de2517af.png"><br><br><h6>  Texture mapping </h6><br>  Up to 8 textures are possible in the shader, with an almost unlimited number of samples.  This means that this limit does not matter when using atlases or cubic textures.  Let's improve our example and, instead of setting the color in the fragment shader, we will get it from the texture by the interpolator texture coordinates adopted from the vertex shader: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex ... mov v0, va1 //       // fragment tex ft0, v0, fs0 &lt;2d,repeat,linear,miplinear&gt;</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/a97/342/130/a973421303c686de5c63e85cafcd6f5b.png"><br><br><h6>  Lambert shading </h6><br>  The most primitive lighting model imitating the real.  Based on the position that the intensity of light falling on a surface linearly depends on the cosine of the angle between the falling vectors and the normal to the surface.  From the school course of mathematics we recall that the scalar product of unit vectors gives the cosine of the angle between them, therefore, our Lambert lighting formula will look like: <br>  <i>Lambert = Diffuse * (Ambient + <b>max</b> (0, <b>dot</b> (LightVec, Normal)))</i> <i><br></i>  <i>Color = Lambert</i> <br>  where <i>Diffuse</i> is the color of the object at a point (taken from a texture for example), <br>  <i>Ambient</i> - background color <br>  <i>LightVec</i> - a unit vector from a point to a light source <br>  <i>Normal</i> - perpendicular to the surface <br>  <i>Color</i> - the final color of the pixel <br><br>  The shader will take two new constant parameters: the position of the source and the value of the background light: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex ... mov v1, va2 // v1 = normal sub v2, vc4, va0 // v2 = lightPos - vertex (lightVec) // fragment ... nrm ft1.xyz, v1 // normal ft1 = normalize(lerp_normal) nrm ft2.xyz, v2 // lightVec ft2 = normalize(lerp_lightVec) dp3 ft5.x, ft1.xyz, ft2.xyz // ft5 = dot(normal, lightVec) max ft5.x, ft5.x, fc0.x // ft5 = max(ft5, 0.0) add ft5, fc1, ft5.x // ft5 = ambient + ft5 mul ft0, ft0, ft5 // color *= ft5</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/85c/212/d9a/85c212d9adaa1105aed6181a39427cbc.png"><br><br><h6>  Phong shading </h6><br>  Introduces the concept of glare from a light source into a Lambert lighting model.  It implies that the intensity of the flare is determined by the power function of the cosine of the angle between the vector to the source and the direction resulting from the reflection of the observer's vector relative to the normal to the surface. <br>  <i>Phong = <b>pow</b> ( <b>max</b> (0, <b>dot</b> (LightVec, <b>reflect</b> (-ViewVec, Normal))), SpecularPower) * SpecularLevel</i> <i><br></i>  <i>Color = Lamber + Phong</i> <br>  where <i>ViewVec</i> is an observer view vector <br>  <i>SpecularPower</i> - the degree that determines the size of the flare <br>  <i>SpecularLevel</i> - the intensity level of the flare or its color <br>  <i>reflect</i> - the function of calculating the reflection f (v, n) = 2 * n * dot (n, v) - v <br><br>  For complex models, it is customary to use Specular and Gloss maps, which determine the color / intensity (SpecularLevel), as well as the size of the flare (SpecularPower) on different parts of the textural space of the model.  In our case, we will manage constant values ‚Äã‚Äãof a degree and intensity.  In the vertex shader, we will pass a new parameter - the position of the observer for the subsequent calculation of ViewVec: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex ... sub v3, va0, vc5 // v3 = vertex - viewPos (viewVec) // fragment ... nrm ft3.xyz, v3 // viewVec ft3 = normalize(lerp_viewVec) //    reflect(-viewVec, normal) dp3 ft4.x, ft1.xyz ft3.xyz // ft4 = dot(normal, viewVec) mul ft4, ft1.xyz, ft4.x // ft4 *= normal add ft4, ft4, ft4 // ft4 *= 2 sub ft4, ft3.xyz, ft4 // reflect ft4 = viewVec - ft4 // phong dp3 ft6.x, ft2.xyz, ft4.xyz // ft6 = dot(lightVec, reflect) max ft6.x, ft6.x, fc0.x // ft6 = max(ft6, 0.0) pow ft6.x, ft6.x, fc2.w // ft6 = pow(ft6, specularPower) mul ft6, ft6.x, fc2.xyz // ft6 *= specularLevel add ft0, ft0, ft6 // color += ft6</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/efd/e63/281/efde632819b0ed7fb5a537ca67c24138.png"><br><br><h6>  Normal mapping </h6><br>  A relatively simple method to simulate surface relief using normal textures.  The direction of the normal in such a texture is usually given in the form of an RGB value obtained from reducing its coordinates to the range of 0..1 (xyz * 0.5 + 0.5).  Normals can be represented both in the object space (Object Space) and in relative space (Tangent Space), built on the basis of texture coordinates and the normal to the vertex.  The first one has a number of sometimes significant drawbacks in the form of a large memory consumption for textures due to the impossibility of tiling and mirror-texturing, but it allows saving on the number of instructions.  In the example, we will use a more flexible and generic version with Tangent Space, for which, in addition to the normal, we will need two more additional vectors of the basis Tangent and Binormal.  The implementation is reduced to transferring the viewVec and lightVec vectors to the TBN (Tangent, Binormal, Normal) basis, and further sampling the relative normal from the texture in the fragment shader. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex ... // transform lightVec sub vt1, vc4, va0 // vt1 = lightPos - vertex (lightVec) dp3 vt3.x, vt1, va4 dp3 vt3.y, vt1, va3 dp3 vt3.z, vt1, va2 mov v2, vt3.xyzx // v2 = lightVec // transform viewVec sub vt2, va0, vc5 // vt2 = vertex - viewPos (viewVec) dp3 vt4.x, vt2, va4 dp3 vt4.y, vt2, va3 dp3 vt4.z, vt2, va2 mov v3, vt4.xyzx // v3 = viewVec // fragment tex ft1, v0, fs1 &lt;2d,repeat,linear,miplinear&gt; // ft1 = normalMap(v0) // 0..1 to -1..1 add ft1, ft1, ft1 // ft1 *= 2 sub ft1, ft1, fc0.z // ft1 -= 1 nrm ft1.xyz, ft1 // normal ft1 = normalize(normal) ...</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/020/a2c/6b0/020a2c6b04a34f47d528e412f317d1f2.png"><br><br><h6>  Toon shading </h6><br>  A type of non-photorealistic lighting model that simulates a cartoon shading layout.  It is implemented in a variety of ways, the simplest of which is to select a color from a 1D texture along the cosine of an angle from the Lambert model.  In our case, use the 16x1 texture as an example: <br><img src="https://habrastorage.org/getpro/habr/post_images/708/ac8/adc/708ac8adc5cab59e4b87a527103531a1.png"><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// fragment ... dp3 ft5.x, ft1.xyz, ft2.xyz // ft5 = dot(normal, lightVec) tex ft0, ft5.xx, fs3 &lt;2d,nearest&gt; // color = toonMap(ft5)</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/ed8/a7e/e9f/ed8a7ee9fef338941cc9e0bb2d4dccdb.png"><br><br><h6>  Sphere mapping </h6><br>  The easiest option to simulate reflection, often used for the effect of chromium metal.  Represents the environment as a texture with a spherical fish eye distortion, as shown below: <br><img src="https://habrastorage.org/getpro/habr/post_images/c5b/7cd/c25/c5b7cdc2547f5970f2afcd4b05d13f7f.png"><br>  The main task is to convert the coordinates of the reflection vector to the corresponding texture coordinates: <br>  <i>uv = (xy / <b>sqrt</b> (x ^ 2 + y ^ 2 + (z + 1) ^ 2)) * 0.5 + 0.5</i> <br>  Multiplication and shift by 0.5 are needed to bring the normalized result to the space of textural coordinates 0..1.  In the simple case, for a perfectly reflective surface, the effect of the map is additive, and for more complex cases when a diffuse component is required, it is customary to use the <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D1%258B_%25D0%25A4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B5%25D0%25BB%25D1%258F">Fresnel</a> formula approximation.  Also for complex models, Reflection maps are often used, indicating the intensity of reflection of different parts of the model texture. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// fragment ... add ft6, ft4, fc0.xxz // ft6 = reflect (x, y, z + 1) dp3 ft6.x, ft6, ft6 // ft6 = ft6^2 rsq ft6.x, ft6.x // ft6 = 1 / sqrt(ft6) mul ft6, ft4, ft6.x // ft6 = reflect / ft6 mul ft6, ft6, fc0.y // ft6 *= 0.5 add ft6, ft6, fc0.y // ft6 += 0.5 tex ft0, ft6, fs2 &lt;2d,nearest&gt; // color = reflect(ft6)</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/933/47a/46d/93347a46d87289ad105d458313a2f08f.png"><br>  On this probably finish.  The examples presented here, for the most part, describe the properties of the object's material, but the shaders find their application in other tasks, such as skeleton animation, shadows, water, and other relatively complex tasks (including non-visual ones).  And with proper leveling up of skills, they allow to implement fairly complex things in a short time by the type: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/a5lojhTl88o%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhj0o_J3YZl6xUOo3OK7caZlUbli1Q" frameborder="0" allowfullscreen=""></iframe><br><br><h5>  Conclusion </h5><br>  Flash games are easy!  <a href="http://mentalx.org/files/AGAL.html"><b>an example of an article</b></a> . </div><p>Source: <a href="https://habr.com/ru/post/130454/">https://habr.com/ru/post/130454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130441/index.html">Suspending the cloud for new users</a></li>
<li><a href="../130446/index.html">ReactOS: PI operation</a></li>
<li><a href="../130448/index.html">Google sends another pack of products under the knife</a></li>
<li><a href="../130450/index.html">Automatic recycling of old phones for money</a></li>
<li><a href="../130452/index.html">What are you sitting at while working at the computer?</a></li>
<li><a href="../130457/index.html">Google AI Challenge 2011 is already available in the Beta-version.</a></li>
<li><a href="../130459/index.html">ABBYY FlexiLayout Studio: we train flexibility</a></li>
<li><a href="../130460/index.html">KDE 15 years</a></li>
<li><a href="../130463/index.html">How to increase the ARPU operator local communications</a></li>
<li><a href="../130464/index.html">Refueling on the road - mobile USB charging</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>