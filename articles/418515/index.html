<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Override Equals and GetHashCode. Do you need it?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are familiar with C #, you most likely know that you must always override Equals , as well as GetHashCode , to avoid performance GetHashCode . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Override Equals and GetHashCode. Do you need it?</h1><div class="post__text post__text-html js-mediator-article"> If you are familiar with C #, you most likely know that you must always override <code>Equals</code> , as well as <code>GetHashCode</code> , to avoid performance <code>GetHashCode</code> .  But what happens if this is not done?  Today, let's compare the performance with the two settings and consider the tools to help avoid errors. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  How serious is this problem? </h2><br>  Not every potential performance issue affects the execution time of an application.  The <code>Enum.HasFlag</code> method <code>Enum.HasFlag</code> not very effective (*), but if you don‚Äôt use it on a resource-intensive piece of code, there will be no serious problems in the project.  This is also true for <a href="https://blogs.msdn.microsoft.com/seteplia/2018/05/03/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/">protected copies</a> created by non-readonly struct types in a readonly context.  The problem exists, but is unlikely to be noticeable in ordinary applications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>(*) Fixed in .NET Core 2.1, and, as I mentioned <a href="https://blogs.msdn.microsoft.com/seteplia/2018/06/12/dissecting-new-generics-constraints-in-c-7-3/">in a previous post</a> , now the effects can be mitigated using self-configured HasFlag for older versions.</i> <br><br>  But the problem that we will talk about today is special.  If the structure does not create the <code>Equals</code> and <code>GetHashCode</code> methods, then their standard versions from <code>System.ValueType</code> .  And they can significantly reduce the performance of the final application. <br><br><h2>  Why are standard versions slow? </h2><br>  The CLR authors tried their best to make the standard versions of Equals and GetHashCode as efficient as possible for value types.  But there are several reasons why these methods lose in the effectiveness of a user version written for a particular type manually (or generated by the compiler). <br><br>  1. Distribution of packaging-transformation.  The CLR is designed in such a way that each call to an element defined in the <code>System.ValueType</code> or <code>System.Enum</code> types starts a wrapping (**). <br><br>  <i>(**) If the method does not support JIT compilation.</i>  <i>For example, in Core CLR 2.1, the JIT compiler recognizes the <code>Enum.HasFlag</code> method and generates suitable code that does not start wrapping.</i> <br><br>  2. Potential conflicts in the standard version of the <code>GetHashCode</code> method.  When implementing a hash function, we are faced with a dilemma: do a hash function distribution well or quickly.  In some cases, both can be done, but in the <code>ValueType.GetHashCode</code> type this is usually difficult. <br><br>  A traditional hash function of type "struct" combines the hash codes of all fields.  But the only way to get the field hash code in the <code>ValueType</code> method is to use reflection.  That is why the CLR authors decided to sacrifice speed for the sake of distribution, and the standard version of <code>GetHashCode</code> only returns the hash code of the first non-zero field and <a href="">‚Äúspoils‚Äù it with a type identifier</a> (***) (for more details, see the coreclr repo on the coreclr repo on github). <br><br>  <i>(***) Judging by the comments in the CoreCLR repository, the situation may change in the future.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  This is a reasonable algorithm until something goes wrong.  But if you are unlucky and the value of the first field of your struct type is the same in most instances, then the hash function will always produce the same result.  As you may have guessed, if you save these instances in a hash set or hash table, then the performance will drop dramatically. <br><br>  3. The speed of implementation based on reflection is low.  Very low.  Reflection is a powerful tool if used correctly.  But the consequences will be terrible if you run it on a resource-intensive code section. <br><br>  Let's take a look at how an unsuccessful hash function, which can result from (2) and reflection-based implementation, affects performance: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  If the value of the first field is always the same, then by default the hash function returns an equal value for all elements and the hash set is effectively converted into a linked list with O (N) insert and search operations.  The number of operations to fill the collection becomes O (N ^ 2) (where N is the number of inserts with complexity O (N) for each insert).  This means that inserting 1000 elements into the set will yield almost 500,000 calls to <code>ValueType.Equals</code> .  Here are the consequences of the method that uses reflection! <br><br>  As the test shows, the performance will be acceptable if you are lucky and the first element of the structure is unique (in the case of <code>Position_Path_DefaultEquality</code> ).  But if this is not the case, then the performance will be extremely low. <br><br><h2>  Real problem </h2><br>  I think now you can guess what problem I recently encountered.  A couple of weeks ago, I received an error message: the execution time of the application I am working on increased from 10 to 60 seconds.  Fortunately, the report was very detailed and contained a trace of Windows events, so the problem place was discovered quickly - <code>ValueType.Equals</code> loaded in 50 seconds. <br><br>  After a quick scan of the code, it became clear what the problem was: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  I used a tuple that contained a custom type of struct with the standard version of <code>Equals</code> .  And, unfortunately, it had an optional first field, which almost always was <code>String.equals</code> .  Performance remained high until the number of elements in the set increased significantly.  Within minutes, a collection with tens of thousands of elements was initialized. <br><br><h2>  Does the implementation of <code>ValueType.Equals/GetHashCode</code> always work slowly by default? </h2><br>  Both for <code>ValueType.Equals</code> , and for <code>ValueType.GetHashCode</code> there are special optimization methods.  If the type does not have ‚Äúpointers‚Äù and it is packaged correctly (I will show an example in a minute), then optimized versions are used: <code>GetHashCode</code> iterations are performed on instance blocks, 4-byte XOR is used, <code>Equals</code> method compares two instances using <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  The check itself is performed in <code>ValueTypeHelper::CanCompareBits</code> , it is called from the iteration <code>ValueType.Equals</code> , and from the iteration <code>ValueType.GetHashCode</code> . <br><br>  But optimization is a very insidious thing. <br><br>  Firstly, it is difficult to understand when it is turned on;  even minor changes to the code can turn it on and off: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  For more information about the structure of memory, see my blog <a href="https://blogs.msdn.microsoft.com/seteplia/2017/09/21/managed-object-internals-part-4-fields-layout/">"Internal elements of a managed object, part 4. Structure of fields</a> . <a href="https://blogs.msdn.microsoft.com/seteplia/2017/09/21/managed-object-internals-part-4-fields-layout/">"</a> <br><br>  Secondly, a comparison of memory does not necessarily give you the correct result.  Here is a simple example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code> and <code>+0,0</code> are equal, but have different binary representations.  This means that <code>Double.Equals</code> is correct, and <code>MyDouble.Equals</code> is false.  In most cases, the difference is insignificant, but imagine how many hours you will spend on correcting the problem caused by this difference. <br><br><h2>  How to avoid a similar problem? </h2><br>  You can ask me how the above mentioned can happen in a real situation?  One of the obvious ways to run the <code>Equals</code> and <code>GetHashCode</code> methods in struct types is to use the FxCop <a href="https://msdn.microsoft.com/en-us/library/ms182276.aspx">CA1815 rule</a> .  But there is one problem: this is too strict an approach. <br><br>  An application for which performance is critical can have hundreds of struct types that are not necessarily used in hash sets or dictionaries.  Therefore, application developers can disable the rule, which will backfire if the struct type uses modified functions. <br><br>  A more correct approach is to warn the developer if a ‚Äúinappropriate‚Äù type of struct with equal values ‚Äã‚Äãof default elements (defined in an application or a third-party library) is stored in a hash set.  Of course, I'm talking about <a href="">ErrorProne.NET</a> and the rule I added there as soon as I ran into this problem: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  The ErrorProne.NET version is not perfect and will ‚Äúblame‚Äù the correct code if the constructor uses a custom equality mapper: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  But I still think it is worth warning if the type of struct with equal elements by default is not used when produced.  For example, when I checked my rule, I realized that the <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> structure defined in mscorlib does not overwrite <code>Equals</code> and <code>GetHashCode</code> .  It is unlikely that today someone will define a variable of type <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> , but I believe that even the BCL can break the rule.  Therefore, it is useful to discover this before it is too late. <br><br><h2>  Conclusion </h2><br><ul><li>  Implementing the default equality for struct types can have serious consequences for your application.  This is a real, not a theoretical problem. </li><li>  The default equality elements for value types are based on reflection. </li><li>  The distribution performed by the standard version of <code>GetHashCode</code> will be very bad if the first field of many instances has the same value. </li><li>  There are optimized versions for the standard methods <code>Equals</code> and <code>GetHashCode</code> , but you shouldn‚Äôt rely on them, because even a small code change can turn them off. </li><li>  Use the FxCop rule to ensure that each type of struct overrides the elements of equality.  However, it is better to prevent the problem with the analyzer if the ‚Äúinappropriate‚Äù structure is stored in a hash set or in a hash table. </li></ul><br><h2>  Additional resources </h2><br><ul><li>  <a href="">ErrorProne.NET on github</a> </li><li>  <a href="https://marketplace.visualstudio.com/items%3FitemName%3DSergeyTeplyakov.EPNS01">ErrorProne.NET Structs in the store</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/418515/">https://habr.com/ru/post/418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418503/index.html">After 2020, the UK will get the first spaceport - in Scotland</a></li>
<li><a href="../418505/index.html">Review and Comparison of Gateway Quantum Software Platforms</a></li>
<li><a href="../418507/index.html">What did astronautics give us?</a></li>
<li><a href="../418509/index.html">Amazon Rekognition's face recognition system took 28 US congressmen for criminals</a></li>
<li><a href="../418513/index.html">How to write only good code</a></li>
<li><a href="../418517/index.html">Code Coverage: How to Improve Test Quality</a></li>
<li><a href="../418519/index.html">What can be found in someone else's code? Selection of useful materials on .NET</a></li>
<li><a href="../418521/index.html">A veil of secrecy over the launch from Alaska</a></li>
<li><a href="../418523/index.html">Why do retailers "overhear" their employees and why else use audio technologies</a></li>
<li><a href="../418525/index.html">Opera went public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>