<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Signed Distance Field or how to make a vector out of raster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about the generation of images with a distance map (Signed Distance Field). This type of images is remarkable in that it actually a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Signed Distance Field or how to make a vector out of raster</h1><div class="post__text post__text-html js-mediator-article">  Today we will talk about the generation of images with a distance map (Signed Distance Field).  This type of images is remarkable in that it actually allows you to get "vector" graphics on a video accelerator, and for nothing.  One of the first methods of rasterization proposed by Valve in the game Team Fortress 2 for scalable decals in 2007, but still it is not very popular, although it allows rendering fonts of excellent quality using a texture of only 256x256 pixels.  This method is perfect for modern high-definition screens and allows you to seriously save on textures in games, it is not picky about hardware and works great on smartphones. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41b/ad6/4c8/41bad64c88d9a859d2ba0eb3b7b437bf.png"><br><br>  The trick is to create such a specially prepared distance map, that when using the simplest shader, an ideal vector image is obtained.  Moreover, using shaders, you can get the effects of shadow, glow, volume, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      How to create such images?  Very simply, <a href="http://www.imagemagick.org/">ImageMagick</a> allows you to do this in one command: <br><br><pre><code class="bash hljs">convert in.png -filter Jinc -resize 400% -threshold 30% \( +<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> -negate -morphology Distance Euclidean -level 50%,-50% \) -morphology Distance Euclidean -compose Plus -composite -level 45%,55% -resize 25% out.png</code> </pre> <br>  At this one could put an end, but so a full-fledged topic will not work.  Well, under the cut - a description of the fast algorithm for calculating the SDF, an example in C + + and a few shaders for OpenGL. <br><a name="habracut"></a><br><h4>  What was that spell? </h4><br>  The first command at the beginning of this post is a recipe for generating SDF from any black and white raster contour.  It is based on the new feature of ImageMagick: <a href="http://www.imagemagick.org/Usage/morphology/">morphology</a> .  Among the morphological transformations present and the calculation of the <a href="http://www.imagemagick.org/Usage/morphology/">map of distances</a> . <br><br>  Calculation of the distance map is the simplest algorithm.  It works on monochrome images, where the pixel is either black or white.  We consider one of the colors internal, the other - external (as you like, in this picture with a cheetah, the black pixel will be internal).  Sometimes they are called the background and foreground colors.  For each ‚Äúinternal‚Äù pixel of the image, you need to find the ‚Äúexternal‚Äù pixel closest to it and set the brightness value of this pixel as the <a href="http://ru.wikipedia.org/wiki/%25D0%2595%25D0%25B2%25D0%25BA%25D0%25BB%25D0%25B8%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0_%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0">Euclidean distance</a> to the nearest ‚Äúexternal‚Äù pixel.  That is, you need to calculate the distance to all the "external" pixels of the image and select the smallest of them.  The resulting distance map is called Distance Field (DF), but so far it does not suit us.  To get the SDF (Signed DF), we invert the image, repeat the algorithm, invert again and add to the previous result. <br><br>  The intensity value does not have to be set exactly to the distance value: you can scale the ‚Äúvagueness‚Äù of the image depending on your needs.  In particular, for rendering sharp contours it is better to use a less blurred map, and for such special effects as a shadow or a glow it is better to increase the distance map: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46c/d56/5d4/46cd565d443a24129294d92a551aba3c.png"><br><br>  And although ImageMagick is not the fastest and easiest way to make such a map, I think this is the best option, since ImageMagick is present on almost all operating systems and is often used by developers for pipelining sprites.  It is enough to finish the script a bit and put the generation of images on the stream. <br><br>  Consider how this works.  If you just take and apply the morphology operation to our image, we will not get the best result: <br><br><pre> <code class="bash hljs">convert nosdf.png -morphology Distance Euclidean sdf.png</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/726/d03/fb0/726d03fb035158958906812afef9ce88.png"><br><br>  Malevich?  No, just <s>blacks steal coal at night, there is</s> not enough contrast, you can quickly pull it out with the <code>-auto-level</code> parameter: <br><br><pre> <code class="bash hljs">convert nosdf.png -morphology Distance Euclidean -auto-level sdf.png</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/beb/1ee/5d0/beb1ee5d0204212f932df99fb9e30afb.png"><br><br>  Immediately striking disadvantage: the distance map is generated only outside.  This is a consequence of the fact that the algorithm itself is also two-pass, we repeat the same for the negative: <br><br><pre> <code class="bash hljs">convert nosdf.png -negate -morphology Distance Euclidean -auto-level sdf.png</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/adb/861/8f6/adb8618f6859c7316dafca3318221176.png"><br><br>  Now the opposite situation - not enough cards outside. <br><br>  It remains to combine these two algorithms, using the intermediate layer, tighten the contrast and get a furious script from the beginning of the post: <br><br><pre> <code class="bash hljs">convert in.png -filter Jinc -resize 400% -threshold 30% \( +<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> -negate -morphology Distance Euclidean -level 50%,-50% \) -morphology Distance Euclidean -compose Plus -composite -level 45%,55% -resize 25% out.png</code> </pre><br>  Some explanations: <br>  <code>-resize 400%</code> - increase the original image to eliminate jagged edges.  The algorithm works only for black and white images and I would like to somehow take anti-aliasing into account.  But I would recommend to always have on hand an original of four times the size or more.  Valve, for example, uses a 4K image for the demonstration, from which it receives a 64x64 SDF.  This is certainly a bust.  I find an acceptable ratio of 8: 1. <br>  <code>-level 45%,55%</code> - you can adjust the degree of blurring of the distance map, by default it is very vague. <br>  <code>-filter Jinc</code> and <code>-threshold 30%</code> - experimentally, this filter and the threshold provide the best fit to the original image.  Under the spoiler script and source for those who want to check. <br><div class="spoiler">  <b class="spoiler_title">Script to find the best PSNR metrics</b> <div class="spoiler_text">  Naturally, the only right option can not be, but I left Jinc 30% as the most average option, which gives an acceptable result. <br><br>  Picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/264/f71/cc7264f713b005f5de6d18a0ff846bcb.png"><br>  Script: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh convert orig.png -resize 25% .orig-downscaled.png convert orig.png -threshold 50% .orig-threshold.png SIZE=$(identify orig.png| cut -d' ' -f3) MAX=0.0 MAXRES="" for filter in $(convert -list filter) do for threshold in $(seq 1 99) do convert .orig-downscaled.png -filter $filter -resize $SIZE! -threshold $threshold% .tmp.png PSNR=$(compare -metric PSNR .orig-threshold.png .tmp.png /dev/null 2&gt;&amp;1) if [ "$(echo "$MAX &lt; $PSNR" | bc -l)" = "1" ] then MAXRES="$PSNR $filter $threshold" echo $MAXRES MAX=$PSNR fi rm .tmp.png done done rm .orig-threshold.png .orig-downscaled.png</span></span></code> </pre><br></div></div><br><br>  Well, if there is a higher resolution original - then you can do without a stunt with the scale and scale down only: <br><pre> <code class="bash hljs">convert in.png -threshold 50% \( +<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> -negate -morphology Distance Euclidean -level 50%,-50% \) -morphology Distance Euclidean -compose Plus -composite -level 45%,55% -filter Jinc -resize 10% out.png</code> </pre><br>  Please note that the Jinc filter ‚Äúmoved‚Äù to the end of the chain, as it is designed to improve the quality of sampling while reducing the size of the card.  Also, do not remove <code>-threshold 50%</code> - Euclidean does not work correctly for non-monochrome images. <br><br>  <b>Some controversial issues</b> . <br><br>  <b>Does it make sense to "pull" the contrast?</b>  In general, theoretically, as the contrast increases, the delta of samples increases, from which antialiasing is then calculated by hardware interpolation.  In short, you need to pull out, especially if you plan to display clear smoothed outlines and effects like shadows are not so important.  If the original card not only stretches, but also shrinks, you should not get too carried away - otherwise, if you reduce the image, anti-aliasing will deteriorate, achieved due to the blurred edges of the SDF. <br><br>  <b>How does the quality depend on the resolution of the SDF card?</b>  I tried to build a graph of PSNR dependence on the resolution of the map and contrast.  In general, the quality increases, but still strongly depends on the contrast of the card.  Rate dependencies can be on the graph: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/97c/349/a1c/97c349a1cc29ab92cedf2da0e4348bc2.png"><br>  Here Scale is the scale as a percentage of the source, Level - how much the contrast was ‚Äústretched‚Äù.  It can be concluded that the dependence on the scale is not very linear, 30% would be a very compromise option, and the contrast rather strongly affects the quality of the contour. <br><br>  <b>How much does quality affect the size of the Euclidean filter</b> ?  Increasing the size of the filter gives a gain of 0.1 dB + - a penny, in my opinion it is insignificant. <br><br>  <b>How much can you ‚Äúshrink‚Äù the original image?</b>  It strongly depends on the shape.  SDF does not like sharp corners, and such a smooth picture as a cheetah from the example feels excellent even on a miniature scale: <br><br><img src="http://1450828574576495356649"><br><br><h4>  Implementing a fast C ++ algorithm </h4><br>  The algorithm is simple, but its implementation "head on" will work for hours: in fact, you need to scan the entire image for each pixel.  O (N ^ 2) does not suit us at all.  But smart people have already thought and came up with an algorithm for the exact (!) Calculation of DF, which works for O (N).  It remains to extend the task to the SDF, which is quite simple (see the previous example). <br><br>  The bottom line.  Instead of counting the distance for each pixel, we make two consecutive passes through the image, simply incrementing the distance under certain conditions.  This is reminiscent of the fast Box-Blur algorithm.  Matan can be learned from [2], but I will try to explain on the fingers. <br><br>  Pixel p I will call the element of the array N * M, composed of the original image.  Pixel is the following structure: <br><pre> <code class="cpp hljs">{ x, y -    f -    }</code> </pre><br>  As you can see, there is nothing about brightness, etc.  - it is not necessary.  The array is formed as follows: <br>  If the pixel of the original image is bright, then <br><pre> <code class="bash hljs">x = y = 9999 f = 9999 * 9999</code> </pre><br>  If the pixel of the original image is dark, then <br><pre> <code class="bash hljs">x = y = f = 0</code> </pre><br>  Each pixel has 8 neighbors, we number them like this: <br><pre> <code class="bash hljs">2 3 4 1 p 5 8 7 6</code> </pre><br>  Next, we introduce two auxiliary functions.  The function h is needed to calculate the Euclidean distance between the pixel and the neighbor, the function G - to calculate the new value of the distance over the components. <br><pre> <code class="bash hljs">h(p, q) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> q -  1  5 {<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 2 * qx + 1} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> q -  3  7 {<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 2 * qy + 1}    {<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 2 * (qx + qy + 1)} }</code> </pre><br><pre> <code class="bash hljs">G(p, q) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> q -  1  5 {<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> (1, 0)} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> q -  3  7 {<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> (0, 1)}    {<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> (1, 1)} }</code> </pre><br>  <b>The first pass</b> .  This pass is performed in direct order (from the upper left corner of the image to the lower right).  Pseudocode: <br><pre> <code class="bash hljs">   p  {    q  1  4 { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h(p, q) + qf &lt; pf) { pf = h(p, q) + qf (px, py) = (qx + qy) + G(p, q) } } }</code> </pre><br>  <b>The second pass</b> .  This pass is performed in reverse order (from the lower right corner of the image to the upper left).  Pseudocode: <br><pre> <code class="bash hljs">   p  {    q  5  8 { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h(p, q) + qf &lt; pf) { pf = h(p, q) + qf (px, py) = (qx + qy) + G(p, q) } } }</code> </pre><br>  The algorithm must be repeated to negative the original image.  Then for the two obtained cards, you need to make the final calculation of the distance and subtraction to combine the two DF cards into one SDF: <br><br><pre> <code class="bash hljs">d1 = sqrt(p1.f + 1); d2 = sqrt(p2.f + 1); d = d1 - d2;</code> </pre><br>  Initially, in the structure, we kept the square of the Euclidean distance, so you need to root out.  Why do I need to add a unit - do not ask, the result is empirical and without it it turns out crooked :) The final SDF card is the result of subtracting the second from the first, then you need to scale the value as you like. <br><br>  In my opinion, even an attempt to explain on fingers how it works looks very confusing, so I will provide the source code in C ++.  As an input image, I used QImage from Qt so as not to spoil the visibility of the process.  The source is based on the source [3], but there are bugs. <br><br><div class="spoiler">  <b class="spoiler_title">Source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt; #include &lt;stdio.h&gt; #include &lt;math.h&gt; struct Point { short dx, dy; int f; }; struct Grid { int w, h; Point *grid; }; Point pointInside = { 0, 0, 0 }; Point pointEmpty = { 9999, 9999, 9999*9999 }; Grid grid[2]; static inline Point Get(Grid &amp;g, int x, int y) { return g.grid[y * (gw + 2) + x]; } static inline void Put(Grid &amp;g, int x, int y, const Point &amp;p) { g.grid[y * (gw + 2) + x] = p; } static inline void Compare(Grid &amp;g, Point &amp;p, int x, int y, int offsetx, int offsety) { int add; Point other = Get(g, x + offsetx, y + offsety); if(offsety == 0) { add = 2 * other.dx + 1; } else if(offsetx == 0) { add = 2 * other.dy + 1; } else { add = 2 * (other.dy + other.dx + 1); } other.f += add; if (other.f &lt; pf) { pf = other.f; if(offsety == 0) { p.dx = other.dx + 1; p.dy = other.dy; } else if(offsetx == 0) { p.dy = other.dy + 1; p.dx = other.dx; } else { p.dy = other.dy + 1; p.dx = other.dx + 1; } } } static void GenerateSDF(Grid &amp;g) { for (int y = 1; y &lt;= gh; y++) { for (int x = 1; x &lt;= gw; x++) { Point p = Get(g, x, y); Compare(g, p, x, y, -1, 0); Compare(g, p, x, y, 0, -1); Compare(g, p, x, y, -1, -1); Compare(g, p, x, y, 1, -1); Put(g, x, y, p); } } for(int y = gh; y &gt; 0; y--) { for(int x = gw; x &gt; 0; x--) { Point p = Get(g, x, y); Compare(g, p, x, y, 1, 0); Compare(g, p, x, y, 0, 1); Compare(g, p, x, y, -1, 1); Compare(g, p, x, y, 1, 1); Put(g, x, y, p); } } } static void dfcalculate(QImage *img, int distanceFieldScale) { int x, y; int w = img-&gt;width(), h = img-&gt;height(); grid[0].w = grid[1].w = w; grid[0].h = grid[1].h = h; grid[0].grid = (Point*)malloc(sizeof(Point) * (w + 2) * (h + 2)); grid[1].grid = (Point*)malloc(sizeof(Point) * (w + 2) * (h + 2)); /* create 1-pixel gap */ for(x = 0; x &lt; w + 2; x++) { Put(grid[0], x, 0, pointInside); Put(grid[1], x, 0, pointEmpty); } for(y = 1; y &lt;= h; y++) { Put(grid[0], 0, y, pointInside); Put(grid[1], 0, y, pointEmpty); for(x = 1; x &lt;= w; x++) { if(qGreen(img-&gt;pixel(x - 1, y - 1)) &gt; 128) { Put(grid[0], x, y, pointEmpty); Put(grid[1], x, y, pointInside); } else { Put(grid[0], x, y, pointInside); Put(grid[1], x, y, pointEmpty); } } Put(grid[0], w + 1, y, pointInside); Put(grid[1], w + 1, y, pointEmpty); } for(x = 0; x &lt; w + 2; x++) { Put(grid[0], x, h + 1, pointInside); Put(grid[1], x, h + 1, pointEmpty); } GenerateSDF(grid[0]); GenerateSDF(grid[1]); for(y = 1; y &lt;= h; y++) for(x = 1; x &lt;= w; x++) { double dist1 = sqrt((double)(Get(grid[0], x, y).f + 1)); double dist2 = sqrt((double)(Get(grid[1], x, y).f + 1)); double dist = dist1 - dist2; // Clamp and scale int c = dist * 64 / distanceFieldScale + 128; if(c &lt; 0) c = 0; if(c &gt; 255) c = 255; img-&gt;setPixel(x - 1, y - 1, qRgb(c,c,c)); } free(grid[0].grid); free(grid[1].grid); }</span></span></span></span></code> </pre></div></div><br><br>  The trick is used here: since both passes use a 1-pixel ‚Äúwindow‚Äù, I add a single-pixel border around the original image to avoid checking borders.  For a negative border, you also need to change to the opposite value, which was not considered in [3]. <br><br>  A full-fledged working algorithm can be viewed in the open source <a href="https://github.com/scriptum/UBFG">UBFG</a> raster font generator.  Example result: <br><br><img src="//habrastorage.org/files/e63/7bd/2cf/e637bd2cf0424bc2991848765e19b5bf.png"><br><br><h4>  Shader </h4><br>  The idea of ‚Äã‚Äãthe inverse transformation (from SDF to raster contour) is based on increasing the contrast to such an extent that the ‚Äúblurred‚Äù edges will not be visible.  By changing the contrast of the SDF you can get various effects, as well as adjust the quality of the anti-aliasing of the image.  As an example, take the source: <br><br><img src="http://1450828574576495356649"><br><br>  This is also an SDF, just heavily compressed and reduced in size.  Increase it 16 times: <br><br><img src="//habrastorage.org/files/f9f/963/443/f9f963443d164c52b0a347a4b3b2af6a.png"><br><br>  Now, to get a beautiful outline, increase the contrast.  I used GIMP for this purpose: <br><br><img src="//habrastorage.org/files/56c/c18/462/56cc184627964797b10b34687180a24b.gif"><br><br>  To see the result of using SDF in real time, you cannot do without shaders.  The simplest alpha test can also be used, but it cuts anti-aliasing at the root.  However, the shader used is just a couple of instructions and does not actually affect performance.  Moreover, considering that the shaders are now cheap, and the memory / cache is expensive - you can get a good acceleration by saving video memory. <br><br>  Now let's see how this thing can be used in OpenGL.  All examples will be given in the form of pure GLSL source code.  You can try in any shader editor.  I tested all the examples in the <a href="http://www.kickjs.org/example/shader_editor/shader_editor.html">Kick.js editor</a> , since this is the only editor that allows you to load your textures. <br><br><h5>  The simplest quick option </h5><br><pre> <code class="hljs cs">precision highp <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; uniform sampler2D tex; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> contrast = <span class="hljs-number"><span class="hljs-number">40.</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { vec3 c = texture2D(tex,gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256.</span></span>, <span class="hljs-number"><span class="hljs-number">128.</span></span>)*<span class="hljs-number"><span class="hljs-number">.3</span></span>).xxx; gl_FragColor = vec4((c<span class="hljs-number"><span class="hljs-number">-0.5</span></span>)*contrast,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  Here we simply draw the contrast relative to the average value (0.5).  The strength of the contrast should vary depending on the scale of the texture and the smearing of the DF card ‚Äî the parameter is chosen experimentally and is set in uniform with a scale multiplier. <br><br>  You can slightly improve the quality with a <code>smoothstep</code> filter: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">precision</span></span> highp float; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D tex; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> float threshold = .<span class="hljs-number"><span class="hljs-number">01</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main(void) { <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c = texture2D(tex,gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256</span></span>., <span class="hljs-number"><span class="hljs-number">128</span></span>.)*.<span class="hljs-number"><span class="hljs-number">3</span></span>).xxx; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> res = smoothstep(.<span class="hljs-number"><span class="hljs-number">5</span></span>-threshold, .<span class="hljs-number"><span class="hljs-number">5</span></span>+threshold, c); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(res,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Here the threshold also needs to be picked up.  <code>smoothstep</code> slightly slower on older video cards and phones. <br><br><h5>  Effect outline </h5><br>  To get this effect, you need to take two thresholds and invert the color: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">precision</span></span> highp float; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D tex; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> float contrast = <span class="hljs-number"><span class="hljs-number">20</span></span>.; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main(void) { <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c = texture2D(tex,gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256</span></span>., <span class="hljs-number"><span class="hljs-number">128</span></span>.)*.<span class="hljs-number"><span class="hljs-number">35</span></span>).xxx; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c1 = (c-.<span class="hljs-number"><span class="hljs-number">45</span></span>) * contrast; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c2 = <span class="hljs-number"><span class="hljs-number">1</span></span>.-(c-.<span class="hljs-number"><span class="hljs-number">5</span></span>) * contrast; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> res = mix(c1, c2, (c-.<span class="hljs-number"><span class="hljs-number">5</span></span>)*contrast); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(res,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Result: <br><img src="//habrastorage.org/files/b04/be5/adc/b04be5adc27f4da88c356aa8925f1628.png"><br><h5>  Glow and shadow effect </h5><br>  Just pohimichit above the previous example - and we get a glow effect: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">precision</span></span> highp float; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D tex; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> float contrast = <span class="hljs-number"><span class="hljs-number">20</span></span>.; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> float glow = <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main(void) { <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c = texture2D(tex,gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256</span></span>., <span class="hljs-number"><span class="hljs-number">128</span></span>.)*.<span class="hljs-number"><span class="hljs-number">35</span></span>).xxx; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c1 = clamp((c-.<span class="hljs-number"><span class="hljs-number">5</span></span>)*contrast,<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">1</span></span>.); <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c2 = clamp(<span class="hljs-number"><span class="hljs-number">1</span></span>.-(c-.<span class="hljs-number"><span class="hljs-number">5</span></span>)/glow, <span class="hljs-number"><span class="hljs-number">0</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>.); <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> res = <span class="hljs-number"><span class="hljs-number">1</span></span>.-mix(c1, c2, (c-.<span class="hljs-number"><span class="hljs-number">5</span></span>)*contrast); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(res,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  To make a shadow, you need to take the color for the glow with an offset: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">precision</span></span> highp float; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D tex; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> float contrast = <span class="hljs-number"><span class="hljs-number">20</span></span>.; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> float glow = <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main(void) { <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c = texture2D(tex,gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256</span></span>., <span class="hljs-number"><span class="hljs-number">128</span></span>.)*.<span class="hljs-number"><span class="hljs-number">35</span></span>).xxx; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> gc = texture2D(tex,gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256</span></span>., <span class="hljs-number"><span class="hljs-number">128</span></span>.)*.<span class="hljs-number"><span class="hljs-number">35</span></span> + vec2(-<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">02</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">02</span></span>)).xxx; <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c1 = clamp((c-.<span class="hljs-number"><span class="hljs-number">5</span></span>)*contrast,<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">1</span></span>.); <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> c2 = clamp(<span class="hljs-number"><span class="hljs-number">1</span></span>.-(gc-.<span class="hljs-number"><span class="hljs-number">5</span></span>)/glow, <span class="hljs-number"><span class="hljs-number">0</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>.); <span class="hljs-attribute"><span class="hljs-attribute">vec3</span></span> res = <span class="hljs-number"><span class="hljs-number">1</span></span>.-mix(c1, c2, (c-.<span class="hljs-number"><span class="hljs-number">5</span></span>)*contrast); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(res,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Result: <br><img src="//habrastorage.org/files/bb1/d68/299/bb1d682992c04f7c8b8a9e212fec6163.png"><br><br>  The result may not seem so hot, but this is because I used a too small map: <br><br><img src="http://1450828574576495356649"><br><br><h4>  Links </h4><br>  [1] <a href="http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf">Improved Alpha-Tested Magnification for Vector Textures and Special Effects</a> - that same article from Valve. <br>  [2] <a href="http://perso.ensta-paristech.fr/~manzaner/Download/IAD/Shih_Wu_04.pdf">Frank Y. Shih, Yi-Ta Wu.</a>  <a href="http://perso.ensta-paristech.fr/~manzaner/Download/IAD/Shih_Wu_04.pdf">Fast Euclidean distance scans using a 3x3 neighborhood</a> - Chinese?  No, just the University of New Jersey. <br>  [3] <a href="http://www.codersnotes.com/notes/signed-distance-fields">www.codersnotes.com/notes/signed-distance-fields</a> - this is also a fairly fast algorithm, but unfortunately its author made several errors and there is multiplication, which is slightly slower than the algorithm presented in this article. <br>  [4] <a href="http://contourtextures.wikidot.com/">contourtextures.wikidot.com</a> is another implementation of the SDF calculation, but its advantage is that it can take edge smoothing into account to determine the nearest points.  Nothing is said about performance, but it's good when there is no possibility to get a high resolution original (on the other hand, you can just do the trick with upscale).  If there was an experience of use - unsubscribe in the comments. <br>  [5] <a href="http://gpuhacks.wordpress.com/2013/07/08/signed-distance-field-rendering-of-color-bit-planes/">gpuhacks.wordpress.com/2013/07/08/signed-distance-field-rendering-of-color-bit-planes</a> - a method for rendering color vector images (suitable for a small number of colors). <br>  [6] <a href="http://distance.sourceforge.net/">distance.sourceforge.net</a> is an interesting resource where various SDF calculation algorithms are compared. <br><br>  <b>upd</b> .  Thanks to the remark of Bas1l, the algorithm is still not entirely accurate and may give errors in calculating the distance to the nearest neighbors due to an error in the proof.  <a href="http://onlinelibrary.wiley.com/doi/10.1002/tee.21858/abstract">This article</a> presents an improved version of the algorithm. <br><br>  <b>upd2</b> .  From user achkasov note on the part of the shaders.  In case of abrupt transitions on the SDF card, heats and uneven anti-aliasing may appear.  Learn more about the effect and how to deal with it: <a href="http://iquilezles.org/www/articles/distance/distance.htm">iquilezles.org/www/articles/distance/distance.htm</a> <br><br>  Changing the shader, we get a significant improvement in the area, ahem, tail: <br><br><img src="//habrastorage.org/files/1ce/e51/468/1cee51468ec34ec9854a7178323b0786.gif"><br><br><div class="spoiler">  <b class="spoiler_title">GLSL code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">precision</span></span> highp <span class="hljs-type"><span class="hljs-type">float</span></span>; uniform sampler2D tex; const <span class="hljs-type"><span class="hljs-type">float</span></span> contrast = <span class="hljs-number"><span class="hljs-number">2.</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> f(vec2 p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture2D(tex,p).x - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } vec2 grad(vec2 p) { vec2 h = vec2( <span class="hljs-number"><span class="hljs-number">4.</span></span>/<span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec2( f(p+h.xy) - f(ph.xy), f(p+h.yx) - f(ph.yx) )/(<span class="hljs-number"><span class="hljs-number">2.0</span></span>*hx); } <span class="hljs-type"><span class="hljs-type">void</span></span> main(<span class="hljs-type"><span class="hljs-type">void</span></span>) { vec2 p = gl_FragCoord.xy/vec2(<span class="hljs-number"><span class="hljs-number">256.</span></span>, <span class="hljs-number"><span class="hljs-number">128.</span></span>)*<span class="hljs-number"><span class="hljs-number">.35</span></span>; //<span class="hljs-type"><span class="hljs-type">float</span></span> c = texture2D(tex,p).x; <span class="hljs-type"><span class="hljs-type">float</span></span> v = f(p); vec2 g = grad(p); <span class="hljs-type"><span class="hljs-type">float</span></span> c = (v)/length(g); <span class="hljs-type"><span class="hljs-type">float</span></span> res = c * <span class="hljs-number"><span class="hljs-number">300.</span></span>; gl_FragColor = vec4(res,res,res, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/215905/">https://habr.com/ru/post/215905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215883/index.html">Micro issue SDSM. Preparing a laboratory for multicasts in GNS3</a></li>
<li><a href="../215887/index.html">Does Wargaming have a lot of analytics to do?</a></li>
<li><a href="../215889/index.html">Portaller</a></li>
<li><a href="../215895/index.html">A miniature tricopter with a 1080p HD camera on a Kickstarter collected almost $ 1 million instead of 35 thousand</a></li>
<li><a href="../215901/index.html">NASA: 715 new planets found, 4 of them may be suitable for life</a></li>
<li><a href="../215907/index.html">Simple strategy game 2048</a></li>
<li><a href="../215909/index.html">The Chinese lunar rover ‚ÄúYuytu‚Äù successfully ‚Äúwoke up‚Äù after the third moon night</a></li>
<li><a href="../215911/index.html">Once again about dial gauges (and completely without MK)</a></li>
<li><a href="../215913/index.html">Flappy Bot for Flappy Bird</a></li>
<li><a href="../215921/index.html">Chameleon virus spreads via WiFi networks as a common cold among people</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>