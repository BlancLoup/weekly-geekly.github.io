<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js web scraping and bot protection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the third article in the series on creating and using scripts for web scraping using Node.js: 


1. Web scraping with Node.js 
2. Web scraping...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js web scraping and bot protection</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/d43/f1e/7a6/d43f1e7a68d6478ea178a74728daf291.png" align="right">  This is the third article in the series on creating and using scripts for web scraping using Node.js: </p><br><ol><li>  <a href="https://habrahabr.ru/post/301426/">Web scraping with Node.js</a> </li><li>  <a href="https://habrahabr.ru/post/302766/">Web scraping on Node.js and problem sites</a> </li><li>  <strong>Node.js web scraping and bot protection</strong> </li><li>  <a href="https://habrahabr.ru/post/304708/">Web scraping updated data with Node.js</a> </li></ol><br><p>  The <a href="https://habrahabr.ru/post/301426/">first article</a> dealt with the basic aspects of web-scraping, such as getting and parsing pages, recursive passage through links, and queuing queries.  The <a href="https://habrahabr.ru/post/302766/">second article</a> dealt with the analysis of the site, working through Ajax, fine-tuning the request queue and handling some server errors. </p><br><p>  The second article also touched upon the topic of session initialization, but it dealt with a very simple case, when it is enough to execute one additional request and save cookies. </p><br><p>  This article deals with a more complicated case - initialization of sessions with authorization by login and password and with the overcoming of a rather sophisticated protection against bots.  As usual, using the example of a real (and very popular among the scraper) tasks. </p><br><div class="spoiler">  <b class="spoiler_title">Important note</b> <div class="spoiler_text"><p>  In most cases, protection from bots on the site is not directed against scrippers, but against such things as fraud, cheating or comment spam.  However, it is always an extra reason to think about the legality and ethics of scrapping of this particular site.  In this article, for example, a site was chosen, about which it is well known that its owners normally refer to scraping (although they prefer it to be performed through a special API).  Simple rules: if the site has an open API, then its owners are happy with the scraper, and if the site is large and ultra-visited, the load from scraping around the API will not disturb it. </p></div></div><br><p>  In past articles, the goal was to show the entire process of creating and using a script, from setting the task to obtaining the final result.  In this article, most aspects of web scraping are bypassed, and instead, a variety of approaches to solving a single, rather narrow problem are shown.  Various methods and tools, their pros and cons, subjective assessments, code examples, this is all. </p><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br><p> <a href=""><img src="https://habrastorage.org/files/268/6e2/a21/2686e2a21aca401c9640beee0e52da4d.png" align="left"></a>  This time the customer is another web scraper who needed the help of a colleague.  He wants to get (for his customer) data from a well-known Amazon site.  Some of the data he needs is given only to authorized users.  Of course, the customer has an account on Amazon, but the problem is that this site is protected against automatic authorization.  The customer needs a module on Node.js, which passes this protection.  Naturally, we are talking about a tool to automatically authorize your account at your own risk, and not about hacking someone else's account, for example. </p><br><p>  The customer has already performed an analysis of his part of the task.  He made sure that the data he needed is available if one header and two cookies are set in the http request (or all, if it‚Äôs too lazy to separate these two from the authorized session).  The header is always the same, and cookies can be easily obtained in the browser from the page of an authorized Amazon user (using DevTools or a similar tool).  Cookies do not become outdated immediately, so that once you receive them, you can run quite a few authorized requests. </p><br><p>  For example, this code should display an email address that is accessible only to authorized Amazon users: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> needle = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'needle'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testURL = <span class="hljs-string"><span class="hljs-string">'http://www.amazon.com/gp/profile/A14ZQ17DIPJ6UB/customer_email'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cookies = { <span class="hljs-string"><span class="hljs-string">'session-id'</span></span>: <span class="hljs-string"><span class="hljs-string">'111-2222222-3333333'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   session-id 'ubid-main': '444-5555555-6666666', //   ubid-main }; work(cookies); function work(cookies){ var options = { headers: { 'X-Requested-With': 'XMLHttpRequest' }, cookies: cookies }; needle.get(testURL, options, function(err, res){ if (err) throw err; console.log(res.body.data.email); }); }</span></span></code> </pre> <br><p>  Accordingly, the customer needs a module that receives the login and password from the account as input, and at the output gives the necessary cookies.  Something like that: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">email, password, work</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// magic work(cookies); }</span></span></code> </pre> <br><p>  The customer will use this module in his own script for Amazon web scraping.  It can even be screwed to its own scrapping framework.  It doesn't matter to us. </p><br><div class="spoiler">  <b class="spoiler_title">History reference</b> <div class="spoiler_text"><p>  Before proceeding to the analysis of the authorization interface on the Amazon site, it is worth noting one important point.  The fact is that this site works with money.  It is constantly attacked by intruders, and they are usually interested in not obtaining legal data to bypass the API, as our customer.  Not surprisingly, the protective mechanisms of this site are constantly being improved.  I still remember the times when automatic authorization on Amazon was carried out with one POST request.  This was long before Node.js appeared (I was then scraping on Perl).  Then there were gradually added such things as redirects, hidden form fields, one-time addresses and the like.  On the network, you can still find examples of authorization on Amazon (using, for example, PHP Curl), which implements approximately the following algorithm: </p><br><ol><li>  We get a page with a one-time link to the page with the login form; </li><li>  We save cookies (which are suitable for this one-time link); </li><li>  Parsim the page and get the desired link; </li><li>  Make a request for this link (using the saved cookies) and get the page; </li><li>  We save cookies (they are already different, yes); </li><li>  Parsim the page and get the values ‚Äã‚Äãof all hidden login form fields; </li><li>  Add email and password fields; </li><li>  We imitate a POST request from the form (using the last saved cookies); </li><li>  We receive the answer with the code 302 and the address in the Location header; </li><li>  Save cookies (third option already) </li><li>  We get the page to the address from the Location (again using cookies) </li><li>  Finally, we get the cookies we need and use them for authorized requests. </li></ol><br><p>  Experienced scrippers may notice that this algorithm is simple.  Such a task can force to work two hours where it is paid for one, but it is unlikely to break the deadline. </p><br><p>  Unfortunately, this algorithm is outdated.  Since he last worked, the protection against automatic authorization has changed at least twice on Amazon.  Now, at the eighth step, before sending the form, the script changes its data, so the simple analysis of http-traffic and the creation of requests does not solve the problem.  After these changes, the topic of automatic authorization on Amazon is gradually moving from amateur forums to professional freelancing exchanges. </p><br><p>  It's hard to say when and how the protection of Amazon will change again, but you can definitely say that this will certainly happen.  Therefore, when considering this task, a specific working code is less valuable than understanding the relevant approaches and tools. </p></div></div><br><h2>  Overview of Methods </h2><br><p>  All methods for solving such problems can be divided into three categories: </p><br><ol><li>  Browser imitation: execution of requests based on data obtained by hacking methods, such as traffic analysis, reverse engineering of scripts, and so on. </li><li>  Automatic use of the browser.  This includes control from the script with real browsers (for example, Chrome) through a special API (for example, using Selenium WD), as well as the use of headless browsers (for example, PhantomJS). </li><li>  Use the browser manually.  This does not necessarily mean a complete abandonment of scrapping automation, but implies that the live operator will see real pages and perform real actions on them through the user interface. </li></ol><br><p>  The choice of these three points is not obvious and at least subjective.  All three categories have their pros and cons, and each of them allows us to solve our problem, so we consider them in turn. </p><br><h2>  Browser imitation </h2><br><p>  Something similar is described in the two previous articles.  To perform the scrapping we send the correct http requests to the server.  ‚ÄúCorrect‚Äù are those that would be sent by the browser if the scraping was done entirely by hand.  To find out exactly what to send in each individual request, we analyze the headers of requests and responses in the browser, as well as look at the source pages.  The task from this article is not fundamentally different from the two previous ones except for one thing: in this case, the concept of ‚Äúpage sources‚Äù also means connected scripts.  We need to understand how much of the code adds data to requests, where this data comes from, and so on.  Regular reverse engineering in relation to site scripts. </p><br><p>  The main advantage of this approach is its versatility.  If the protection is passed through a standard bundle from a person and a browser, then an algorithm for its passage can be found by reverse engineering.  Theoretically, there are no exceptions to this rule.  In the world of web scraping, there are problems that can be solved exclusively by reverse engineering. </p><br><p>  The main disadvantage of this approach is its unlimited labor input.  This is the way for the strong in spirit and not particularly limited in time.  In real life, reverse engineering of a single complex website can take time, in which you can write scripts for scrapping thousands of ‚Äúregular‚Äù websites.  In theory, a protection manufacturer can spend as much time on it, and his qualification may require that an experienced and talented hacker engage in reverse engineering.  Simply put, at a certain level of complexity, it becomes more profitable for the customer to hire a copy-clerk instead of a cool hacker.  Or refuse the order altogether and do without this data. </p><br><p>  It is worth noting that not every scraper has hacker skills at all or has a hacker team.  Having met with the need to understand the scripts on the site, most refuse to order or choose a method from another category.  Well, or hires another professional. </p><br><p>  In the case when the protection algorithm is not viewed when analyzing traffic and HTML, it is worth starting with other approaches.  If the algorithm may change unexpectedly at any time (like on Amazon), I recommend considering reverse engineering as the last thing to consider.  Besides, it seems to me that if the Amazon security code, obtained by reverse engineering, is laid out, for example, on Habr, then you can write next to it that this code is outdated - this will quickly become true. </p><br><p>  In this article, code examples will describe other methods. </p><br><h2>  Automatic use of the browser </h2><br><p>  This approach is popular with novice scrippers so much that they switch to it every time they encounter difficulties when analyzing a site.  Hard Deadline Professionals also love this approach. </p><br><p>  The main advantage of this approach is the simplicity of scripting protection, since there is no need to understand the site scripts - they will simply be executed in the browser and do the same thing as if the user did not run your code, but the user with the mouse and keyboard.  Your code will resemble instructions for a close-up copy-clerk.  It will be easy to read and edit when necessary. </p><br><p>  The main disadvantage of this approach is that you run someone else‚Äôs code on your computer.  This code may, for example, contain additional protection from very different types of automation, from detectors of headless browsers to intelligent analysis of user behavior.  Of course, you can use, for example, a proxy server that replaces the script with the detector, but this will require the same reverse engineering, and then it‚Äôs not at all clear why bother with browsers. </p><br><p>  <em>(Note: an example of the technology for analyzing user behavior can be viewed on <a href="http://areyouahuman.com/">AreYouaHuman</a> website, and you can learn more about headless browser detectors from the <a href="http://www.slideshare.net/SergeyShekyan/shekyan-zhang-owasp">excellent presentation</a> that <a href="https://habrahabr.ru/users/kirill3333/" class="user_link">kirill3333</a> has in the commentary to the article before.)</em> </p><br><p>  Another disadvantage of this approach is that browsers consume much more resources than regular scraper scripts.  For scraping thousands (and even more so, millions) of pages is a bad idea.  Our customer wants a module whose code will be executed once and send only a few requests, so we don‚Äôt have to worry about resources. </p><br><p>  To automatically use the browser from a script on Node.JS there are many popular tools.  Here I briefly go through the main ones (if I have forgotten someone for nothing, please tell me in the comments): </p><br><p>  <strong><a href="http://www.seleniumhq.org/projects/webdriver/">Selenium WD</a></strong> - the most famous and popular tool for automatic use of the browser.  Does not need additional presentation.  The network has a lot of examples and tips.  Anyone who even thinks about scrapping professionally is worth trying Selenium WD. </p><br><p>  Unfortunately, Selenium WD is not suitable for solving our problem.  In order to work with it, you will need to install and configure Java, Selenium WD itself (Java application), browser, browser driver and module for accessing Selenium WD from the selected programming language (in our case, from Node.js).  This is not the easiest way, given that our customer needs a simple Node.js module that works out of the box (well, in the extreme case, it requires something like ' <code>npm install</code> '). </p><br><p>  <strong><a href="http://phantomjs.org/">PhantomJS</a></strong> is a <a href="https://webkit.org/">WebKit</a> -based headless browser.  It runs the sites in a real browser, only does not show the user the pages, and instead of the user interface uses scripts in Javascript.  The browser in PhantomJS is so complete that it even has a driver for Selenium WD and this bundle works fine. </p><br><p>  From the point of view of our task, the main thing to know about PhantomJS is that even though it uses the same Javascript language as Node.js, it is NOT Node.js.  It looks like, but not that.  You cannot make a module on Node.js that directly uses PhantomJS.  You can make a separate script on PhantomJS, and for it to make a module wrapper that will run a separate process and receive its data through <code>stdout</code> .  In the simplest case, it looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sys = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sys'</span></span>), exec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>).exec; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ exec(<span class="hljs-string"><span class="hljs-string">'phantomjs script.js'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, stdout</span></span></span><span class="hljs-function">)</span></span>{ callback(err === <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? stdout : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); };</code> </pre> <br><p>  In order not to bother with <code>stdout</code> and work through a convenient interface, it makes sense to use one of the ready (and carefully tested by someone) wrappers over PhantomJS. </p><br><p>  <strong><a href="https://slimerjs.org/">SlimerJS</a></strong> - roughly speaking, this is the same PhantomJS, just not on WebKit, but on <a href="https://developer.mozilla.org/ru/docs/Mozilla/Gecko">Gecko</a> .  In our case, it is important that SlimerJS is supported by fewer wrappers than PhantomJS. </p><br><p>  <strong><a href="http://casperjs.org/">CasperJS</a></strong> is the most famous Node.js wrapper over PhantomJS and SlimerJS.  About why CasperJS is better than naked PhantomJS is well written, for example, in <a href="http://code-epicenter.com/why-is-casperjs-better-than-phantomjs/">this article</a> (in English).  But in <a href="http://code-epicenter.com/how-to-login-to-amazon-using-casperjs-working-example/">this article</a> (also in English) you can see an example of authorization passing on Amazon using CasperJS.  It is a working solution, but this is not the best option (estimate, at least, the amount of code in the example).  I recommend instead of CasperJS to pay attention to the following list item: </p><br><p>  <strong><a href="http://www.horsemanjs.org/">Horseman.js</a></strong> is a very good wrapper over PhantomJS.  Ideal for writing modules like ours.  Does not require any complicated installation and configuration steps.  It is enough to add <code>phantomjs-prebuilt</code> and <code>node-horseman</code> to our dependencies in our module and that's it.  Horseman.js interface is extremely concise, flexible and easy to read.  This is how the working code of our module written using Horseman.js will look like: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Horseman = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-horseman'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> horseman = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Horseman(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startURL = <span class="hljs-string"><span class="hljs-string">'https://www.amazon.com/gp/css/homepage.html/'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">email, password, work</span></span></span><span class="hljs-function">)</span></span>{ horseman .userAgent(<span class="hljs-string"><span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36'</span></span>) .open(startURL) .click(<span class="hljs-string"><span class="hljs-string">'#nav-tools&gt;a'</span></span>) .waitForNextPage() .type(<span class="hljs-string"><span class="hljs-string">'form [name=email]'</span></span>, email) .type(<span class="hljs-string"><span class="hljs-string">'form [name=password]'</span></span>, password) .click(<span class="hljs-string"><span class="hljs-string">'#signInSubmit'</span></span>) .waitForNextPage() .cookies() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cookies</span></span></span><span class="hljs-function">)=&gt;</span></span>{ work(cookies); }) .close(); }</code> </pre><br><p>  This code can be read without looking at the documentation.  And it works. </p><br><p>  <strong><a href="http://nwjs.io/">NW</a></strong> is another managed browser (formerly node-webkit).  Allows you to control the <a href="http://www.chromium.org/blink">Blink</a> engine from scripts on Node.js.  The main purpose is to create desktop applications using web technologies, but it can also work as headless.  On NW, you can make full applications for scraping.  For example, such as in <a href="https://habrahabr.ru/post/277513/">this article</a> from <a href="https://habrahabr.ru/users/vmb/" class="user_link">vmb</a> .  Tools like NW are especially good when the customer is afraid of the command line and wants a window with buttons.  In our case, NW is not the best choice. </p><br><p>  <strong><a href="http://electron.atom.io/">Electron</a></strong> is another tool for creating desktop applications based on web technologies.  In fact, this is a young and promising competitor to NW and with its help you can also make scrapping applications with excellent indication.  In addition, Electron can easily be used as a headless browser, but connecting it to our module is better not directly, but through a wrapper. </p><br><p>  <strong><a href="http://www.nightmarejs.org/">Nightmare</a></strong> is the most famous wrapper over Electron.  Despite the name makes a very good impression.  Designed so smoothly that some novice scrippers manage to use Nightmare without knowing anything about Electron.  The interface is very similar to Horseman.js (and almost as good).  This is how the working code of our module written using Nightmare will look like: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Nightmare = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'nightmare'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nightmare = Nightmare() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startURL = <span class="hljs-string"><span class="hljs-string">'https://www.amazon.com/gp/css/homepage.html/'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">email, password, work</span></span></span><span class="hljs-function">)</span></span>{ nightmare .goto(startURL) .click(<span class="hljs-string"><span class="hljs-string">'#nav-tools&gt;a'</span></span>) .wait(<span class="hljs-string"><span class="hljs-string">'#signInSubmit'</span></span>) .type(<span class="hljs-string"><span class="hljs-string">'form [name=email]'</span></span>, email) .type(<span class="hljs-string"><span class="hljs-string">'form [name=password]'</span></span>, password) .click(<span class="hljs-string"><span class="hljs-string">'#signInSubmit'</span></span>) .wait(<span class="hljs-string"><span class="hljs-string">'#nav-tools'</span></span>) .cookies.get() .end() .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cookies</span></span></span><span class="hljs-function">) </span></span>{ work(cookies); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'Authorization failed:'</span></span>, error); }); }</code> </pre> <br><p>  In principle, everything is the same as in the case of Horseman.js.  Under the hood, Electron instead of PhantomJS, but it does not catch the eye. </p><br><p>  <strong><a href="https://github.com/deanmao/node-chimera">Chimera</a></strong> is a regular module for Node.js with a minimum of dependencies (in fact, only <code>request</code> ).  It allows you to load the page, execute the script in its context and process its result in the context of Node.js.  Among those who came to scraping from the frontend, there are lovers of this module, but in my opinion it is too minimalist.  At least, if the customer rests and demands the module without the browser engine attached to it, then you can use not the Chimera, but the following option: </p><br><p>  <strong><a href="http://zombie.js.org/">ZombieJS</a></strong> - this module is often positioned as an analogue of PhantomJS, which can be run directly from Node.js.  ZombieJS does not use any browser engines, dispensing with such usual tools as <code>request</code> , <code>jsdom</code> or <code>ws</code> .  Compared to Horseman.js, the ZombieJS code looks cumbersome, but after Chimera it is a sample of convenience and brevity: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Browser = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'zombie'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Browser(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startURL = <span class="hljs-string"><span class="hljs-string">'https://www.amazon.com/gp/css/homepage.html/'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">email, password, work</span></span></span><span class="hljs-function">)</span></span>{ browser.visit(startURL, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ browser.clickLink(<span class="hljs-string"><span class="hljs-string">'#nav-tools&gt;a'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ browser.fill(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, email); browser.fill(<span class="hljs-string"><span class="hljs-string">'password'</span></span>, password); browser.pressButton(<span class="hljs-string"><span class="hljs-string">'#signInSubmit'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cookies = browser.saveCookies().split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newCookies = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cookies.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cookie = cookies[i].split(<span class="hljs-string"><span class="hljs-string">';'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].split(<span class="hljs-string"><span class="hljs-string">'='</span></span>); newCookies[cookie[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = cookie[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } browser.tabs.closeAll(); work(cookies); }); }); }); }</code> </pre> <br><p>  The obvious disadvantages of ZombieJS include bad documentation.  Previously, it was good, but then the developer has greatly changed it for the worse.  I will not build conspiracy theories about why he did it, but here are a couple of links to you on which you can figure out ZombieJS: <a href="https://docs.omniref.com/js/npm/zombie/1.0.0/files/API">examples</a> and <a href="http://zqdevres.qiniucdn.com/data/20110811173813/index.html">API</a> . </p><br><p>  <em>Interestingly, many sites perceive PhantomJS, Electron and ZombieJS differently, so that one tool is protected and the other is blocked.</em>  <em>This is a serious reason to be ready to use any of these three tools.</em>  <em>Although, of course, such complex cases are rare.</em>  <em>With the Amazon site, for example, all three scripts work.</em>  <em>Well ... while working.</em> </p><br><h2>  Using the browser manually </h2><br><p>  It may seem that this paragraph is given here for fun, but it is not.  There are situations when this approach is not only justified, but also optimal.  For example, when you need to perform an operation that is difficult to automate once, and then many times automatically perform something simple.  For example, log in to Amazon, and then scrap it for a long time. </p><br><p>  The main disadvantage of this approach is the need for a live user for each script run.  That is, you can't just start scrapping on <code>cron</code> , you need someone to look at the pages and do something with them. </p><br><p>  The main advantage of this approach is the visibility of the process.  The user sees what is happening on the page and will notice if something goes wrong.  And maybe he can fix it.  For example, if a site suddenly starts asking for a captcha (as Amazon does, if you strain it for a long time with automatic authorization). </p><br><p>  The easiest way to manually add a browser to your script is to write instructions for the user.  Clear text explaining, for example, how to take cookies from the browser and place them in the text of the script is the same program, but not for a computer, but for a person.  Many programmers are able to write such programs well, and many customers are easy to make such a compromise to save time and money.  Unfortunately, our customer needs a module that does not require user instructions. </p><br><p>  Another way is to write your own browser, which will be launched only for authorization on Amazon, and then closed.  For example, based on Electron.  It is not so difficult to do.  If in our script on Nightmare to make a small change, the script will show the pages with which it works.  The user will see the script fill out the form fields and submit it.  You just need to initialize Nightmare with an additional parameter.  Like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nightmare = Nightmare({ <span class="hljs-attr"><span class="hljs-attr">show</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre> <br><p>  For example, you can see that the site began to request a captcha, which is not so rare.  Moreover, the user can enter the captcha directly in the Electron window and everything will work.  Only the waiting time in the script is worth putting more, otherwise the user may not have time.  In general, you can remove the automatic filling of form fields and provide it to the user.  Then you can not store the password in the text of the script.  Moreover, then it will be possible at different times to grab on behalf of different users. </p><br><p>  On the other hand, Nightmare can be taught to recognize a captcha request and pass it using services such as <a href="http://www.deathbycaptcha.com/">Death by Captcha</a> , but we have no such requirement in the task. </p><br><h2>  Conclusion </h2><br><p>         ,    -   .        ,      ,   ,       .                   ,  ,     . ,              ,          .      ,     (   ),   ‚Äú‚Äù    . </p><br><p>           ,    ,  ,        .        . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/303726/">https://habr.com/ru/post/303726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303714/index.html">Building perfect optics in Zemax</a></li>
<li><a href="../303716/index.html">HL7: Your HL7 CDA document does not comply with the standard</a></li>
<li><a href="../303718/index.html">Comments on the problem in Bitrix24 with commit for Mercurial</a></li>
<li><a href="../303722/index.html">QtQuick / QML as a game UI</a></li>
<li><a href="../303724/index.html">Full list of tools and utilities for Microsoft SQL Server</a></li>
<li><a href="../303730/index.html">My experience using WebRTC in an iOS application</a></li>
<li><a href="../303732/index.html">Mobius 2016: a new way of mobile development</a></li>
<li><a href="../303734/index.html">ONLYOFFICE: open like never before</a></li>
<li><a href="../303736/index.html">Now your HTTPS will be monitored, and you must install the certificate for MitM yourself.</a></li>
<li><a href="../303738/index.html">Practice successful monetization API based on Azure API Management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>