<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive applications with the RxPM pattern. Goodbye MVP and MVVM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a long time, I have been pondering over the RxPM pattern and even successfully applying it in production. I planned to first speak with this topic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive applications with the RxPM pattern. Goodbye MVP and MVVM</h1><div class="post__text post__text-html js-mediator-article"><p>  For a long time, I have been pondering over the RxPM pattern and even successfully applying it in production.  I planned to first speak with this topic on <a href="https://mobiusconf.com/">Mobius</a> , but the program committee refused, so I am publishing an article now to share my vision of the new pattern with the Android community. </p><br><p>  Everyone is familiar with MVP and MVVM, but few know that MVVM is a logical development of the <a href="https://www.martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> pattern.  After all, the only difference between MVVM and PM is the automatic data binding ( <em>databinding</em> ). </p><br><p>  This article focuses on the Presentation Model pattern with a reactive implementation of binding.  Some people mistakenly call it RxMVVM, but it would be correct to call it RxPM, because it is a modification of the Presentation Model template. </p><br><p>  This pattern is convenient to use in projects with <a href="http://reactivex.io/">Rx</a> , as it allows you to make the application truly reactive.  In addition, he does not have many of the problems of other patterns.  The diagram below shows the various options and classifications for presentation templates: </p><br><p><img src="https://habrastorage.org/files/1f2/2c1/6bd/1f22c16bd5ab47f5b317d1cae555a170.jpg"></p><br><a name="habracut"></a><br><p>  Before turning to the description of the RxPM pattern, let's consider the most popular of them - MVP (Passive View) and MVVM.  A detailed description of all the patterns and their differences, you can read in the previous <a href="https://habrahabr.ru/company/mobileup/blog/313538/">article</a> . </p><br><h1 id="mvp-vs-pm-vs-mvvm">  MVP vs PM vs MVVM </h1><br><p>  The general pattern of patterns can be represented as a diagram: </p><br><p><img src="https://habrastorage.org/files/db9/da5/2a1/db9da52a10774616a3bcc03495ebf2e1.jpg"></p><br><p>  At first glance it may seem that there is no fundamental difference between them.  But this is only at first glance.  The differences are in the duties of the mediator and his method of communicating with the View.  The model looks the same in all patterns.  Its design is a complex and extensive topic, we will not dwell on it now.  Let's start with the most popular pattern - MVP in the Passive View version.  Consider his main problems. </p><br><h3 id="mvp">  MVP </h3><br><p>  In the classic MVP, the responsibility for maintaining and restoring the state of the UI lies with the View.  Presenter only tracks changes in the model, updates the View through the interface and, conversely, accepts commands from View and modifies the Model. </p><br><p>  However, when implementing complex interfaces, in addition to the data state in the model, there are additional UI states that are in no way associated with the data.  For example, which element of the list is highlighted on screen or with what data the input form, information about the progress of the download process or requests to the network are filled.  Restoration and preservation of the UI-state in the View presents major problems, since View is used to ‚Äúdie‚Äù.  And information about network requests View in principle can not save.  While View is disconnected from the presenter, the request is likely to end with some result. </p><br><p>  Therefore, the work of restoring the state of the UI is carried out to the presenter.  To do this, it is required to store in the presenter additional data and flags about the current state and to reproduce it every time the View is attached. </p><br><p> The second problem arises from the same condition that the View can be disconnected from the presenter at any time, for example, when the screen is rotated.  Accordingly, the link to the View interface in the presenter will be reset.  Therefore, you should always check for <code>null</code> when you need to update the View.  This is rather tedious and cluttering up the code. </p><br><p>  The third problem: it is necessary to describe the View interface in some detail, since it should be as stupid as possible.  And the presenter has to call a lot of methods to bring the View to the desired state.  This increases the amount of code. </p><br><h3 id="pm">  PM </h3><br><p>  There is another pattern called Presentation Model, <a href="https://www.martinfowler.com/eaaDev/PresentationModel.html">described by</a> Martin Fowler.  The essence of this pattern is that a special model is introduced, called the ‚Äúview model‚Äù, which stores the state of the UI and contains the UI logic.  PresentationModel should be considered as an abstract presentation that does not depend on any GUI framework.  PresentationModel stores the state as a property ( <em>property</em> ), which then reads the View and displays on the screen.  The main problem of the pattern is the synchronization of the PresentationModel and View states.  You will have to take care of this yourself by applying the <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BB%25D1%258E%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">‚ÄúObserver‚Äù</a> pattern.  Most likely, you will need to track changes to each property in order not to update the entire UI.  It turns out quite a lot of boring and repetitive code. </p><br><h3 id="mvvm">  MVVM </h3><br><p>  As you can see, MVVM is very similar to the Presentation Model.  Not surprising, because it is its development.  Only PresentationModel is called ViewModel, and the synchronization of the ViewModel and View state is performed using automatic data binding, i.e. databinding.  But this pattern is not without flaws.  For example, it is problematic to "cleanly" implement any animations or do something with the View from the code.  You can read more about this in the <a href="https://habrahabr.ru/company/mobileup/blog/312548/">article of</a> my colleague <a href="https://habrahabr.ru/users/jeevuz/" class="user_link">Jeevuz</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Going a little ahead, here is his comment from our discussions of MVVM and RxPM</b> <div class="spoiler_text"><blockquote>  <em>Starting to discuss and think about RxPM, I realized that this pattern combines what I liked in MVVM - the concept of a ViewModel'i as an interface over View, but at the same time does not contain the main drawback - duality.</em>  <em>Which is logical, because there is no databinding.</em>  <em>But at the same time, binding with Rx is not much more complicated than automatic binding with the Databinding Library, and it is very well suited for use in reactive applications.</em> <em><br></em>  <em>As a consequence, RxPM solves the problem of states.</em>  <em>Remember the rubik cube from my article?</em>  <em>I described that a state can be described either by a set of fields or a set of actions ... So, RxPM combines these two ways in an interesting way: PresentationModel stores View states as a set of fields, but since these fields are represented by BehaviorSubjects (which emit the last event when subscribing), they are at the same time ‚Äúactions‚Äù.</em>  <em>And it turns out that any event that occurred in the background (not yet View) will arrive during the subscription.</em>  <em>Fine!</em> </blockquote></div></div><br><p>  But the most important and decisive disadvantage of all the above-mentioned patterns is that the interaction between the View and the mediator is carried out in the imperative style.  Whereas our goal is to write reactive applications.  The UI layer is a fairly large source of data flow, especially in dynamic interfaces, and it would be rash to use Rx only for asynchronous work with the model. </p><br><h1 id="reaktivnyy-presentation-model">  Reactive Presentation Model </h1><br><p>  We have already found out that the main problem of the Presentation Model pattern is state synchronization between PresentationModel and View.  Obviously, it is necessary to use <em>observable property</em> - a property that can notify about its changes.  In solving this problem, RxJava will help us, and at the same time we will get all the advantages of the reactive approach. </p><br><p>  To begin with, we will look at the pattern scheme and then we will understand the implementation details: <br><img src="https://habrastorage.org/files/58f/f9e/e3a/58ff9ee3a76f4f2e9aebed8520e93abb.jpg"></p><br><p>  So, the key element of RxPM is the reactive <em>property</em> .  The first candidate for the role of Rx-property suggests <a href="http://reactivex.io/documentation/subject.html"><strong>BehaviorSubject</strong></a> .  It stores the last value and gives it every time you subscribe. </p><br><p>  In general, <strong>Subjects are</strong> unique in nature: on the one hand, they are extensions of the Observable, and on the other, they implement the Observer interface.  That is, we can use the <strong>Subject</strong> as an outgoing data stream for the View, and in PresentationModel it will be the consumer of the incoming data stream. </p><br><p>  However, <strong>Subject</strong> 's have flaws that are unacceptable to us.  Under the Observable contract, they can terminate with the <strong>onComplete</strong> and <strong>onError events</strong> .  Accordingly, if the <strong>Subject</strong> is subscribed to something that ends with an error, the entire chain will be stopped.  View will stop receiving events and will have to subscribe again.  In addition, by definition, Rx-property cannot send <strong>onComplete</strong> and <strong>onError events</strong> , as it is just a source of data (state) for the View.  This is <a href="https://github.com/JakeWharton/RxRelay">where</a> Jake Wharton comes to the rescue with his <a href="https://github.com/JakeWharton/RxRelay">RxRelay</a> library.  <em>What would we do without him?</em>  <strong>Relay</strong> 'and lack the described disadvantages. </p><br><p>  In the arsenal we have several subclasses: </p><br><ul><li><p>  <strong>BehaviorRelay</strong> - stores the last value received and sends it every time you subscribe.  Best for storing and changing states. </p><br></li><li><p>  <strong>PublishRelay</strong> is just a hot Observable.  Suitable for any commands or events for the View.  For example, to show a dialog or start an animation.  Also used to receive commands (events) from View. </p><br></li><li>  <strong>ReplayRelay</strong> - saves all received items to the buffer and plays them all when subscribing.  Extremely rarely used, but can help for compound states.  An example comes to mind with drawing: draw a line, then a circle, etc. </li></ul><br><p>  But we cannot provide View access to <strong>Relay</strong> pits directly.  Since it can accidentally put a value in a property or subscribe to a <strong>Relay</strong> , which is intended to receive commands from View.  Therefore, it is required to present properties as <a href="">Observable</a> , and event listeners from View as <a href="">Consumer</a> .  Yes, encapsulation will require more code, but on the other hand it will be immediately clear where the properties are, and where the commands are.  Example of loading progress to PresentationModel (pm): </p><br><pre> <code class="hljs xml">//State private val progress = BehaviorRelay.create<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Int</span></span></span><span class="hljs-tag">&gt;</span></span>() //    property val progressState: Observable<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Int</span></span></span><span class="hljs-tag">&gt;</span></span> = progress.hide() //    ,      fun progress(): Observable<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Int</span></span></span><span class="hljs-tag">&gt;</span></span> = progress.hide() //Action private val downloadClicks = PublishRelay.create<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Unit</span></span></span><span class="hljs-tag">&gt;</span></span>() //    property val downloadClicksConsumer: Consumer<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Unit</span></span></span><span class="hljs-tag">&gt;</span></span> = downloadClicks //    ,      fun downloadClicks(): Consumer<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Unit</span></span></span><span class="hljs-tag">&gt;</span></span> = downloadClicks</code> </pre> <br><p>  Now that we have defined the states and actions, we can only attach to them in View.  For this we need another library of Jake Worton - <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> .  <em>When does he sleep at all?</em> </p><br><pre> <code class="hljs mel">pm.progressState.subscribe { <span class="hljs-keyword"><span class="hljs-keyword">progressBar</span></span>.progress() } <span class="hljs-comment"><span class="hljs-comment">//    downloadButton.clicks().subscribe { pm.downloadClicksConsumer } //    PM</span></span></code> </pre> <br><p>  If there is no suitable Observable, then you can call <code>consumer.accept()</code> - directly from the widget's listener. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">pm</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.downloadClicksConsumer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.accept</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Unit</span></span>)</code> </pre> <br><h3 id="a-teper-na-praktike">  And now in practice </h3><br><p>  Now we collect all of the above in a bunch and analyze by example.  PresentationModel design can be divided into the following steps: </p><br><ol><li>  Determine which states of PresentationModel will be required for the View: data, loading status, errors to be displayed, etc. </li><li>  Determine what events can occur in View: clicks on buttons, filling in input fields, etc. </li><li>  When creating a PresentationModel, associate states, commands, and a model in a declarative style, as Rx allows. </li><li>  Bind View to PresentationModel. </li></ol><br><p>  Take for example the task of finding words in the text: </p><br><ul><li>  There is an input field for the text in which we will search. </li><li>  There is an input field for the word / part that will be searched. </li><li>  By clicking on the button we start the search. </li><li>  We display the progress during the search, for which we block the button. </li><li>  After receiving the answer display a list of found words. </li></ul><br><p>  The search algorithm is hidden behind the facade of the interactor: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchParams</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SearchParams</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Single&lt;List&lt;String&gt;&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InteractorImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interactor { override fun findWords</span></span></span></span>(params: SearchParams): Single&lt;List&lt;String&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Single .just(params) .map { (text, query) -&gt; text .split(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"?"</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>, ignoreCase = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .filter { it.contains(query, ignoreCase = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } .subscribeOn(Schedulers.computation()) } }</code> </pre> <br><p>  In a specific example, it would be possible to do without Single and Rx at all, but we will keep the interfaces monotonous.  Especially in real applications there could be a request to the network through <a href="http://square.github.io/retrofit/">Retrofit</a> . </p><br><p>  Next, we design PresentationModel. </p><br><p>  States for View: list of found words, download status, search button activity flag.  The enabled state for the button can be tied to the upload flag in PresentationModel, but for the View we have to provide a separate property.  Why not just bind to the loading flag in View?  Here we have to determine that we have two states: loading and enabled, but in this case it so coincided that PresentationModel binds them.  Although in general they can be independent.  For example, if it were necessary to block a button until the user enters the minimum number of characters. </p><br><p>  Events from View: enter text, enter a search query and click on the button.  Everything is simple: we filter the texts, combine the text and the search string into one object - SearchParams.  By clicking on the button we do a search query. </p><br><p>  Here is how it looks in code: </p><br><pre> <code class="hljs cmake">class TextSearchPresentationModel { private val interactor: Interactor = InteractorImpl() // --- States --- private val foundWords = BehaviorRelay.create&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt;&gt;() val foundWordState: Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt;&gt; = foundWords.hide() private val loading = BehaviorRelay.createDefault&lt;Boolean&gt;(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) val loadingState: Observable&lt;Boolean&gt; = loading.hide() val searchButtonEnabledState: Observable&lt;Boolean&gt; = loading.map { !it }.hide() // -------------- // --- UI-events --- private val searchQuery = PublishRelay.create&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt;() val searchQueryConsumer: Consumer&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt; = searchQuery private val inputTextChanges = PublishRelay.create&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt;() val inputTextChangesConsumer: Consumer&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>&gt; = inputTextChanges private val searchButtonClicks = PublishRelay.create&lt;Unit&gt;() val searchButtonClicksConsumer: Consumer&lt;Unit&gt; = searchButtonClicks // --------------- private var disposable: Disposable? = null fun onCreate() { val filteredText = inputTextChanges.filter(<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>::isNotEmpty) val filteredQuery = searchQuery.filter(<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>::isNotEmpty) val combine = Observable.combineLatest(filteredText, filteredQuery, BiFunction(::SearchParams)) val requestByClick = searchButtonClicks.withLatestFrom(combine, BiFunction&lt;Unit, SearchParams, SearchParams&gt; { _, params: SearchParams -&gt; params }) disposable = requestByClick .filter { !isLoading() } .doOnNext { showProgress() } .delay(<span class="hljs-number"><span class="hljs-number">3</span></span>, TimeUnit.SECONDS) //      .flatMap { interactor.findWords(it).toObservable() } .observeOn(AndroidSchedulers.mainThread()) .doOnEach { hideProgress() } .subscribe(foundWords) } fun onDestroy() { disposable?.dispose() } private fun isLoading() = loading.value private fun showProgress() = loading.accept(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) private fun hideProgress() = loading.accept(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) }</code> </pre> <br><p>  In the role of View, we will have a fragment: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextSearchFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pm = TextSearchPresentationModel() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> composite = CompositeDisposable() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputText: EditText <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryEditText: EditText <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> searchButton: Button <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> progressBar: ProgressBar <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultText: TextView <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) retainInstance = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">//     pm.onCreate() } // ... onCreateView override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // ... init widgets onBindPresentationModel() } fun onBindPresentationModel() { // --- States --- pm.foundWordState .subscribe { if (it.isNotEmpty()) { resultText.text = it.joinToString(separator = "\n") } else { resultText.text = "Nothing found" } } .addTo(composite) pm.searchButtonEnabledState .subscribe(searchButton.enabled()) .addTo(composite) pm.loadingState .subscribe(progressBar.visibility()) .addTo(composite) // --------------- // --- Ui-events --- queryEditText .textChanges() .map { it.toString() } .subscribe(pm.searchQueryConsumer) .addTo(composite) inputText .textChanges() .map { it.toString() } .subscribe(pm.inputTextChangesConsumer) .addTo(composite) searchButton.clicks() .subscribe(pm.searchButtonClicksConsumer) .addTo(composite) //------------------ } fun onUnbindPresentationModel() { composite.clear() } override fun onDestroyView() { super.onDestroyView() onUnbindPresentationModel() } override fun onDestroy() { super.onDestroy() pm.onDestroy() } } //   RxKotlin /** * Add the disposable to a CompositeDisposable. * @param compositeDisposable CompositeDisposable to add this disposable to * @return this instance */ fun Disposable.addTo(compositeDisposable: CompositeDisposable): Disposable = apply { compositeDisposable.add(this) }</span></span></code> </pre> <br><p>  You can see a complete example on <a href="https://github.com/dmdevgo/RxPM-Demo">GitHub</a> . </p><br><h1 id="podvedem-itogi">  Let's sum up </h1><br><p>  We met with the new RxPM pattern and took apart the minuses of other presentation templates.  But I do not want to say unequivocally that MVP and MVVM are worse or better than RxPM.  I also, like many, love MVP for its simplicity and straightforwardness.  And MVVM is good in having automatic databing, although the code in the layout is an amateur. </p><br><p>  But in modern applications with dynamic UI, a lot of event and asynchronous code.  Therefore, my choice is leaning toward the reactive approach and RxPM.  Let me give you the words from the <a href="https://speakerdeck.com/jakewharton/exploring-rxjava-2-for-android-gotocph-october-2016%3Fslide%3D34">presentation of</a> Jake Whorton, why our applications should be reactive: </p><br><blockquote>  <em>It is a single asynchronous source breaks imperative programming.</em> <br>  <em>If you cannot simulate the entire system synchronously, then even one asynchronous source breaks imperative programming.</em> </blockquote><br><h5 id="razumeetsya-u-rxpm-est-kak-plyusy-tak-i-minusy">  Of course, RxPM has both advantages and disadvantages. </h5><br><p>  Pros: </p><br><ul><li>  Allows you not to break Observable jet chains and pull them from model to View and vice versa.  This eliminates the imperative interaction with the View. </li><li>  Declarative description of logic in PresentationModel. </li><li>  PresentationModel is an abstraction of View, not tied to specific widgets. </li><li>  No need to worry about whether the View is attached or not.  Just change the value of Rx-property.  The view will automatically get a state when it signs. </li><li>  Events from View are obtained in a reactive style, it is convenient to use the Rx operators to filter, merge, etc. </li></ul><br><p>  Minuses: </p><br><ul><li>  It is necessary to write binding code, but with Rx it is easy. </li><li>  It is required to encapsulate Relay'i, to represent them for View in the form of Observable and Consumer.  This is the only thing that strains me. </li><li>  Abundance rx.  Can be considered as a minus, and as a plus.  Reactivity is another paradigm, so it‚Äôs not surprising that when you start using Rx, you have to use it everywhere.  Nobody trumpets about a variety of objects when programming in Java - this is the OO paradigm. </li></ul><br><p>  This is probably not a complete list.  Write in the comments, what you see the pros and cons, it will be interesting to know your opinion. </p><br><p>  So, if you feel confident with Rx and want to write reactive applications, if you are tired of MVP and MVVM with <em>databinding</em> , then you should try RxPM.  Well, if you are already comfortable, I will not persuade you <em>;)</em> </p><br><h1 id="p-s">  PS </h1><br><p>  The sophisticated Android developer most likely noticed that I didn‚Äôt say anything about the life cycle and about saving the PresentationModel during the turn.  This problem is not specific to this pattern and deserves separate consideration.  In my article, I wanted to focus on the very essence of the pattern: its pros and cons compared to MVP and MVVM.  Also, such important topics as bilateral <em>databinding</em> , navigation between screens in the context of RxPM and some others were not touched upon.  In the next <a href="https://habrahabr.ru/company/mobileup/blog/342850/">article,</a> we will try to talk with <a href="https://habrahabr.ru/users/jeevuz/" class="user_link">Jeevuz</a> about how to start using RxPM in a real project and present some library solution that simplifies its use. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326962/">https://habr.com/ru/post/326962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326952/index.html">Brainstorming for the lazy or Individual intellectual activity, or Basics of divergent thinking in practice</a></li>
<li><a href="../326954/index.html">Open broadcast of the main conference room Mobius 2017: Let's talk about the architecture of mobile applications and something else</a></li>
<li><a href="../326956/index.html">The uWSGI Spooler</a></li>
<li><a href="../326958/index.html">From weekly sysadmin: unpack NetApp FAS 9000</a></li>
<li><a href="../326960/index.html">Duck says ‚Äúquack-krya‚Äù, the cow says ‚Äúmu-mu‚Äù, ‚ÄúRunn Me!‚Äù - another PHP framework * tells us. Part 1</a></li>
<li><a href="../326964/index.html">Mobile Device Manager Plus - long-awaited perfection or is it still not?</a></li>
<li><a href="../326966/index.html">Hallucinate like Trump, or mini-analysis of Recurrent Neural Networks</a></li>
<li><a href="../326968/index.html">Network Attacks with Kali Linux</a></li>
<li><a href="../326970/index.html">Domestic Linux distribution - ‚ÄúOS‚Äù for server and desktop systems: the new BolgenOS of the national scale?</a></li>
<li><a href="../326972/index.html">How to grow: 7 lessons, which gives the history of WeChat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>