<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sberbank's Dao Integration: From Local Area Networks to Kafka and Streaming Development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Mikhail Golovanov, in Sbertech I am engaged in technical architecture and advanced developments. We, like any modern bank, have a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sberbank's Dao Integration: From Local Area Networks to Kafka and Streaming Development</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  My name is Mikhail Golovanov, in Sbertech I am engaged in technical architecture and advanced developments.  We, like any modern bank, have a lot of systems that support different aspects of the bank‚Äôs operations: deposits, accounts, crediting money, lending, financial markets, stocks, etc.  Whenever a new system appears, we start the next level of an exciting game called Integration.  And each next level is more complicated than the previous one - after all, the systems need to be covered more and more.  This post is what is called walkthrough in gaming circles: first we will go over local networks and then go through the message queues to the large-scale stage of streaming computing through Apache Kafka in widely distributed networks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01b/50f/e9e/01b50fe9e5174829e1f05bb6867fb1f1.png"><br><a name="habracut"></a><br>  First, a bit of theory - we will list what we value in integration, taking into account banking specifics: <br><br><ul><li>  <b>Performance</b> .  It's simple: the higher the better. <br></li><li>  <b>Latency -</b> information transfer delays.  Acceptable latency depends on the systems we are dealing with.  If you come to an ATM to withdraw money from the card, then an extra second of weather will not do.  And if they make you wait 30 seconds, you will hardly like it.  There are operations in which latency is not so important.  If you are applying for a loan, then you can wait for the decision for ten minutes - and then 30 seconds are not crucial.  But in principle, the lower the better. <br></li><li>  <b>Scaling</b> .  Scaling is of two kinds.  With vertical scaling, you add capacity on a single machine, and your performance increases.  With horizontal - put next to the machine even the nth number of the same. <br></li><li>  <b>Fault tolerance</b> .  This is very important for us.  If something fails in the bank and customers are not served - this is very bad for everyone.  This can be attributed to another important indicator - the recovery time. <br></li><li>  <b>Consistency</b>  Suppose the transfer of money has passed, but there is no write-off.  And you need to tamper balance.  The second example: you send a transfer, and your money has been deducted from the card, and the person to whom you transfer them is not credited.  This means that the system is in inconsistent state.  And causes a lot of inconvenience.  It is highly desirable that all data be in a consistent state. <br></li></ul><br><h2>  Beginning of the story </h2><br>  The first was the stage of local networks - the formation of the classical two-tier architecture and the dawn of database servers (MS SQL, Oracle and others).  Sberbank had a large, powerful database server that served the entire organization.  Client machines on the local network connected to it, received and recorded information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Then began the active spread of Internet technology.  The number of users of business applications began to grow very quickly.  We rested on the capabilities of the database server and moved to the three-tier scheme.  The database served as the repository.  The application server contained business logic ‚Äî rules for the manipulation of information.  The thin client ‚Äî the browser ‚Äî connected to the application server and interacted with the end user. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b9/851/49b/1b985149bf5561b978befa01fca50b4f.png"><br><br>  This architecture has many advantages: <br><br><ul><li>  There is no need to install client software on the machines and update the programs - it is enough to update the application server and the database, and immediately a new version becomes available to all customers. <br></li><li>  The database relationally stores all the data of the organization - due to the verification of keys and support of transactions, we automatically obtain consistency. <br></li><li>  JEE application servers are well clustered, scaled, and take over most of the business logic work. <br></li><li>  Interfaces of JavaScript-based web applications are getting closer to the native ones in terms of saturation and capabilities. <br></li></ul><br>  10-15 years ago it was very cool and made life much easier. <br><br>  The next stumbling block was the synchronous interaction of the system components.  The client requested information from the application server and blocked - waited until he received a response.  And server components also expected responses from each other.  Here the performance seriously subsided. <br><br>  To solve problems with synchronous exchange, middleware is used to create message queues.  After writing to such a queue, the calling component does not wait for a response and can perform other useful work.  The processing component reads incoming messages to the queue and generates responses.  Which caller listens in a separate thread. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a6/d71/212/7a6d712126463aa54f3939506e67102d.png" width="550" height="546"><br><br>  The advantages of this architecture: <br><br><ul><li>  Asynchronous exchange significantly improves system performance. <br></li><li>  If your server is stopped for a while, the client will not know about it.  It will simply throw requests for processing while the queue is available.  At this time, you can quickly and quietly raise the server part, deduct from the queue and process what has been received in the last few minutes.  As a result, the client will notice almost nothing. <br></li><li>  If you centralize the queue in the message broker, you can get a single point of information flow management in the enterprise. <br></li></ul><br>  So we built our internal information processing architecture about seven years ago.  Everything was great. <br><br><h2>  We meet Kafka </h2><br>  Two years ago, we decided to switch from paid products of large vendors to a more functional open source.  We looked at what can be done with message queues, decided to leave the integration architecture unchanged, and transfer message queues to open source.  We scanned the market and stumbled upon Apache Kafka, a distributed open source messaging software broker written in Scala and Java (in the bank this is our main technological stack).  Then Kafka versions 0.8‚Äì0.9 were relevant. <br><br>  The pilot was quickly deployed: <b>Kafka's performance was at least several times higher than</b> our solution, tens of thousands of messages per second, or even more, about a hundred.  Existing lines on the same equipment pulled out at best 5-7 thousand. <br><br>  In our previous Message Queue (MQ), building a cluster required a lot of non-trivial actions.  The topology turned out to be complicated: there were gateways that distributed the load, ensured the operation of the Message Queue cluster, etc.  With Kafka, everything turned out to be simpler: we put a new machine, raise Kafka on it, register the Kafka node number in the cluster, and the node connects to the cluster itself.  If you need to turn off the machine, it is enough just to stop Kafka on the node - the broker will exit the cluster himself.  This way you can easily scale in both directions.  <b>At the same time, the scaling is close to linear</b> : put a second broker - it will process twice as much, if the third is three.  Ten knots were put on the pilot, and this dependence persisted. <br><br>  Kafka supports two unified interaction styles at once. <br><br><ul><li>  Point-to-point - someone lays out the handler information, the handler takes it, and only these two sides interact with each other. <br></li><li>  Publish-subscribe - when someone puts out information, and many consumers read it at once. <br></li></ul><br>  In the old JMS paradigms, these were two different interfaces, but in Kafka everything is unified, and there is no difference between Point-to-point and Publish-subscribe, including in the API for the programmer.  This is a big simplification. <br><br>  In Kafka, <b>all messages are persistent</b> , that is, written to disk.  In queues, it works differently.  When all messages in the queue are stored in RAM, everything works quite quickly - several thousand messages per second.  As soon as we turn on the persistence mode - writing messages to the disk - the performance drops several times.  However, this mode is indispensable, because the information in the RAM is erased as soon as the machine is turned off.  And we have a lot of data that you don‚Äôt want to lose - for example, data on money transfer.  In Kafka, messages are persistent out of the box, and everything works quickly. <br><br><h2>  Moving from JMS to Kafka </h2><br>  Faster, more convenient, and even free.  Hurray, throw JMS, moving to Kafka!  Previously, we had the usual queues, and now Kafka-topics.  The essence is the same: they wrote it down in a topic and forgot it, but someone on the other side reads asynchronously. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bca/c80/3ac/bcac803acc2eb249c83ffa3d0c1dbfff.png"></div><br>  How is all this inside?  Kafka, in fact, is an append-only distributed log, that is, a log whose entry always goes to the end.  To ensure scaling, the topic is divided into partitions.  In each partition there is always a start offset (the number of the first recorded message) and end offset (the number of the last recorded message).  The recording always occurs at the end of the log, and the numbers of the messages continuously monotonically increase.  Sequential recording to disk is carried out with good speed and provides persistence - in contrast to writing to an arbitrary part of the file, especially slow on the HDD. <br><br>  What happens on the side of the reader?  When creating a reader, a group is assigned at creation, according to which the reader subscribes to topics - sets of partitions (logs). <br><br>  The reader endlessly carries out a call (poll), that is, requests data from Kafka.  If something was recorded, Kafka gives this data.  The reader processes them, commit reports in response, and the pointer moves forward one message.  So in the topic you can make a lot of partitions and put a lot of readers.  One partition in one group is read by one reader, and this is a fairly simple and clear scaling scheme.  If we want everything to work faster, we increase the number of partitions in the topic and readers in the group, and due to the parallelization, everything works faster.  In Kafka, writers are called producers, and readers are consumer salesmen. <br><br><h2>  Problems with message bundles </h2><br>  An experienced booth at Kafka pleased everyone, except for some unpleasant moment: the same messages began to be duplicated.  Immediately thought that the point is who writes.  But no, the recording went once, and the reading - two, three, sometimes even four times.  As a result, performance fell in Kafka and a large number of duplicates appeared. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84b/b73/2ae/84bb732aecb43b5b49665716c100ac66.png"></div><br>  It turns out that groups of readers work a little differently.  Within a single polling cycle, the handler immediately receives a stack of messages.  Then he begins to process it and must commit message processing.  In our case, in processing there were not only single messages - some collected a bundle of information in themselves, many business events.  The handler receives such a bundle, for example, from 200 events and sequentially starts processing each of them. <br><br>  Meanwhile, the broker starts counting a timeout - a certain time interval after which, without receiving a message processing commit, he starts to consider the handler dead, throws him out of the group and puts one of the living instead.  If during one poll two or three large bursts of messages were received, the time-out time often expired and the consumer threw out.  A rebalance started in Kafka - rebuilding a group of consyumers when they added a new one or, as in our case, threw away the old one.  Instead of the supposedly dead, Kafka substituted the neighboring, supposedly lively concierge.  Bundles of messages began to kill the whole group in a circle.  After some time, in the server‚Äôs opinion, there were no live users at all, and the reading stopped. <br><br>  What to do?  The first option: let's not send packs.  But the system that transmitted them, otherwise could not work, because it was not very online.  Maybe create a separate message pool?  But then we break the reading and processing of messages, and the scheme will become fragile. <br><br>  At this moment, the tenth version of Kafka came out with some very useful features for us: <br><br><ul><li>  KIP-62 - heartbeat in a separate thread.  It used to be a confirmation that the handler was live and the processing itself was going in one thread.  In the tenth, Kafka introduced a separate message ‚ÄúI am alive‚Äù, which can be thrown not mainly in a separate background thread.  And these messages go much faster than processing the main bundle.  Rebalance does not occur, and we can scroll through large messages for quite a long time. <br></li><li>  KIP-41 - the maximum number of messages in one poll.  Previously, it was limited only by available memory.  If someone wrote a lot, the handler could immediately take 10, 30, 50 messages.  With the tenth of Kafka, you can set the exact number: messages to be read for one poll. <br></li><li>  Setting timeout settings. <br></li></ul><br>  With the new settings, the system began to work stably, and the massive doubles stopped.  But still not to the end.  At this moment we understood: Kafka is not exactly a queue.  This is another data structure, <b>partitioned log</b> . <br><br>  What is the difference?  In the queue, all readers are competitive in reading messages, and therefore it is not always orderly.  In Kafka, within the framework of partitions, the reading proceeds sequentially, and the partition is always streamlined.  The messages in the queue are deleted after reading, but not in Kafka - the pointer of the read messages simply moves.  After some time (timeout) in Kafka, the entire file is deleted, and writing to the new file (segment) begins.  Messages are deleted in batches, like files from the file system - it turns out to be much less expensive than with queues that delete each message.  And, as we described above, turning on / off one of the consumer meters in reading mode affects the rest.  There is a rebalance, and for some time the broker does not give readers any messages until the rebalance occurs. <br><br><h2>  We achieve doubles </h2><br>  The lesson was learned, the system was stabilized, the doubles were reduced to fractions of a percent, but we didn‚Äôt get rid of them completely.  The duplicates arose because of the rebalances that could not be avoided - at least they occurred when a new customer clerk entered the topology, or if Kafka decided that some optimization was needed. <br><br>  We began to think what to do with the remaining takes.  There were three options: <br><br><ul><li>  Nothing to do.  There are such tasks where doubles are not at all terrible.  For example, you monitor a business process for a certain stage.  If you twice received information about this, do not worry.  Or, for example, if a client requests a balance on his card and receives it twice. <br></li><li>  Fight with the consequences.  There are two main approaches: deduplication and compensation logic. <br></li><li>  Eliminate the cause - to make such a system where doubles will not arise.  This is the most correct, but the most difficult way. <br></li></ul><br>  If you do nothing, then the key concept is <b>idempotency</b> .  Idempotency is if the operation is repeated several times, and this does not affect the system from the point of view of an outside observer, from the point of view of the data state. <br><br>  Idempoddentnymi can be read or monitor operations.  There are ways to make business transactions idedentary, even if they are not.  For example, when transferring money, we generate a unique ID ‚Äî enter a unique identifier for the operation.  After the first processing of the ID, we changed the balance on the account and saved information about it.  In the future, by ID, we determine that the transfer has already been made, and we do not move money.  However, for this, it is necessary to rework logic every time, to do an analysis of the tasks - in general, the method is expensive. <br><br>  The second approach is the creation of a deduplicator.  You can put the shared storage, and when the message comes a second time, ignore it.  But here it is necessary to build additional storage for call traffic ‚Äî on large volumes it can become a point of failure and a cause of a drop in performance.  And since usually the storage is remote, we receive an additional one network call and an increase in latency.  At low loads, the deduplicator is quite a working scheme, but this is not our case. <br><br>  The third approach is to make compensation at the level of business logic.  Our application programmers will have to remember all the time that the operation can be repeated.  How to determine whether it was repeated due to integration, or does the user really try to transfer five rubles to someone every second?  This is time consuming and can cause many errors, so compensation logic is an extreme option. <br><br>  The idea was to add transactions to transactions.  Then repeated operations will be rejected, because there will be a repeat of the transaction.  Java even has a distributed transaction technology (XA transaction).  However, in Kafka, it is not supported and is unlikely to be supported. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/fa4/bd0/d02fa4bd07424270d11df997ad0d2444.png"></div><br>  As expected, it remains to deal with the cause. <br><br><h2>  We transfer commit before processing </h2><br>  When the group is rebalanced, then sending the message to the old consumer is no longer possible.  There is an error stating that this consumer no longer works with this partition.  We have always done commit after processing, but you can transfer commit before processing.  Then the consumer will read the message from Kafka and immediately confirm the reading. <br><br>  But what if at the moment when we are already commited, but not yet processed, there will be a failure in the handler?  In this case, we will lose this message, because Kafka believes that we have already given it to us, but the handler has not yet worked to the end.  This message processing guarantee is called <i>at most once</i> , that is, ‚Äú <i>at most once</i> ‚Äù.  It can be used for some not very important operations.  But not for operations related to money, because no one wants to lose a transfer. <br><br><h2>  We assign topics to handlers </h2><br>  It is possible not to use the mechanism of auto-balancing groups of readers, but to explicitly assign a handler to each partition by calling the assign method.  This is when we explicitly say: you are a handler, here is your topic, here is your partition, work with it.  In this case, you can make an early commit - at most once, or you can, for a guarantee, a late commit at least once.  Due to the fact that only one handler makes commits and processing, if you try hard, you can do it exactly once - that is, exactly once. <br><br>  But what is bad assign?  You nailed the handler to the partition.  Now, if he died, something needs to be done with him: restart, watch what he last handled, and so on.  For the system administrator, this is quite laborious: you need to make sure that the handlers are alive, manually restart them, and so on.  That is, we begin to do the work of a consumer group.  And if a person appears in the process, you can forget about the quick recovery time of the system, since he immediately has a desire to figure out what was processed and what was not.  People react at best in minutes, computers in a split second.  We get exactly once, but we lose a lot in fault tolerance.  And we will have to spend a lot on operation. <br><br><h2>  Revaluation of distributed networks </h2><br>  As a result, we then postponed the final conquest of Kafka.  Returned to the question after a year and a half.  We were satisfied with performance, scalability, fault tolerance.  That's just the consistency of trouble - damned doubles.  It is unlikely that experienced Kafka developers could ignore such a problem.  Perhaps we misused it?  Not.  The decision was hidden at an even deeper level than could have been supposed. <br><br>  As it turned out, in a large distributed environment, some principles on which our design of IT systems used to be held simply do not work.  These principles are dedicated to the work of L. Peter Deutsch ‚ÄúFallacies of distributed computing‚Äù, written in 1994-1997. <br><br><ol><li>  The network is no longer as reliable as it used to be.  Due to the large number of elements, it cannot always work quickly and reliably. <br></li><li>  Information transfer delays are no longer zero, as in a local network.  Yes, the speed of access between the memory is the highest.  If we contact disks several dozen times, the performance drops in the same way.  And if we also connect with the network, the slowdown happens a hundred times.  We can not neglect the delay in the interaction between the distributed components. <br></li><li>  The throughput is finite.  With large volumes of network, we quickly rest on the ceiling, especially when interacting with remote servers. <br></li><li>  The network is no longer secure.  When working via the Internet, it is impossible to control everything, I can hack something somewhere. <br></li><li>  Topology is changing all the time.  Some cars are always on or off.  Among the thousands of Google servers, about a dozen are always in inoperable condition. <br></li><li>  The administrator is no longer alone.  There may be hundreds of them; each manages his own part of the system in his own way. <br></li></ol><br>  Having accepted these truths, we formulated three main characteristics of a distributed system: <br><br>  <b>1. Failures are the norm.</b> <br><br>  If the failure of one machine was an extraordinary event, then when you have a lot of machines, something is constantly not working all the time.  The system's inoperability is a deviation from some characteristics or a complete failure.  A malfunction is a failure.  Failure is a self-eliminating failure.  And we need to make such systems so that we experience failures.  The larger the system, the more failures in it are more diverse and more frequent.  It is necessary to ensure that failures turn into failures, so that failures can be eliminated.  Because you can run around the whole big system and fix everything with your hands - you can go crazy. <br><br>  <b>2. Coordination is difficult</b> <br><br>  The more machines, the harder it is to ensure coordination, especially through the network.  Coordination is difficult.  Network latency between nodes, unreliability of communication, changeable topology ‚Äî you cannot fight this; you just need to try to avoid it.  The smaller the different parts of the system are coordinated with each other, the better.  If they manage independently, this is ideal. <br><br>  <b>3. Time is not uniform.</b> <br><br>  In different parts of the system due to delays different times.  And on different computers, too, at different times.  Very often, when designing, three things are confused: time, duration and order of messages.  For example, if you are doing a chat, it is not the specific time, but the order that matters.  If you sent a question, and you answered it, it is important that everyone sees the question first, and the second - the answer.  It happens that duration is important, not order.  For example, if you measure timeout. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/48a/053/1d448a0532057c420a321f2f9424a1ec.png"></div><br>  But the worst thing is that time floats.  Even the most accurate atomic clocks also float.  Ordinary quartz watches on a local machine can go astray for a couple of milliseconds due to the heating of the machine and other physical causes.  Synchronizing the time between machines gives tens of milliseconds.  With this you need to accept and understand that in different parts of your system time is different. <br><br>  Given the new conditions, we had to overestimate the issue of information processing.  Up to this point, we had two main options: <br><br><ul><li>  Batch.  You accumulate a certain array of information and run the ‚Äúthresher‚Äù, which performs calculations offline and gives the result.  The calculation may take minutes, hours, days, but we can safely process large volumes.  If something broke or we realized that we had an error in the algorithm, the input array of information does not change - that is good.  We can eliminate errors, run again and get an answer that suits us.  This is not online and the result is always deterministic.  If the input array and the algorithm have not changed, you will certainly get the same results. <br></li><li>  Request-Reply.  This online option is used when you need to get results quickly, as in a web browser, for example.  You give some database queries and quickly get an answer.  But since these calls are in no way ordered, you can no longer reproduce this.  In the next second, the state of the database may change, and, throwing the same query, you will get a completely different result.  That is, the result is non-deterministic, but it can be obtained quickly. <br></li></ul><br>  In each case, one has to make sacrifices.  Is it possible and accurate and fast?  For a number of cases we found a way. <br><br><h2>  Stream architecture </h2><br>  So, we live in a distributed system with its own characteristics.  Kafka has limitations related to doubles.  A centralized relational database cannot be inflated forever - there are limitations in scaling.  What to do?  Let's try to implement some of the tasks in the stream architecture.  Our acquaintance with her began with the article ‚ÄúIntroducing Kafka Streams: Stream Processing Made Simple‚Äù by Jay Kreps, the current CEO of Confluent, the developer of Kafka. <br><br>  Streaming architecture is based on the concept of stream.  A stream is a time-ordered set of immutable messages.  Everything that happens in our system is consistently written to the journal as events occur over time.  If the event is recorded in the log, it can no longer be changed.  If you have created a user, you can not go back and cancel the action.  You can only post a new user adjustment event or something like that.  In general, it is very similar to our lives.  When something happens, we can no longer go back and change what happened.  We can only respond to what happened and create a new event. <br><br>  Business event modules exchange messages asynchronously through event streams.  Accordingly, if a module wants to interact with new modules, it sends an event to their event logs.  Thus, the entire system is the modules and the relationship between them in the event logs. <br><br>  The flow of events is infinite, they are strictly ordered in time, and this order after recording never changes.  Module state is the result of processing a specific stream.  If we bring the module to the initial state X and lose a certain flow, we will get the state Y. Doing this each time we will get the same final state, since the initial state is fixed, the flow of events is the same, the processing algorithm is the same. <br><br>  How to scale such a system?  With the help of partitions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f82/eb4/6d0/f82eb46d0dc9474ae35a2b28dcb011b4.png"><br><br>  In the example above, three partitions are created.  Events are distributed according to them according to the keys that we assign to events.  K1 ‚Äì K3 in the first partition, K4 ‚Äì K6 in the second and K7 ‚Äì K9 in the third.  Events within one partition are ordered by time.  A handler is attached to each partition, which sequentially processes the events.  Processed one - went to the next.  That is, he manages his local database.  The state of the handler is determined by the initial state and the flow.  The overall speed of the system depends on the number and speed of handlers. <br><br>  In this scheme there is no central base and coordination, because each processor handles its own partition and knows nothing about the others.  We just throw in the event stream.  Different events may relate to the change of one entity and be logically related.  If such events fall into different partitions, then due to the independence of the handlers in time, we will have a run-up and the results will fall into the wrong handlers and everything will be bad. <br><br>  All logically related events must appear in the same partition in order to continue to go to the same developer instance.  How to do it?  There are two approaches. <br><br>  The first approach is partitioning the stream while writing.  This method is used in Kafka Streams.  We must generate some key from the recorded information by which the partition is determined.  Writing this key, we can safely work on and be sure that logically related events will fall into one handler.  The disadvantage of the method is that if the topology of the topic changes, it is necessary to carry out repartitioning - the redistribution of data by partitions, which is very resource-intensive. <br><br>  The second approach is partitioning the stream while reading.  It can be implemented using the operator available in Apache Flink and similar engines.  In it, logically related events can fall into different partitions.  But then the entire topic is read in one cluster, which, when reading each event, calculates its key.  Having calculated the key, it understands where the required handler is in the cluster topology and sends the event there.  :   .       ,      ,     . <br><br>       ,         . <br><br><h2>     </h2><br> ,        ,          .              .     stateless processing. <br>        ‚Äî ,  ‚Äî     ,   .        .      key-value.           ,          key-value . <br><br>     ?       -   ‚Äî  .          offset ,    .       ,      .      ,        offset,   ,        .       : <br><br><ul><li>    . ,  -       ,       .       ,  ,    ,  ,    ‚Äî ,  . <br></li><li>   .         .       . <br></li></ul><br>       .       .     : <br><br><ol><li>      .    Kafka Streams.    ,   key-value       .   ,         .      ,  ‚Äî ,      .      ,     ,   ,     ,    . <br></li><li>         ‚Äî ,  Hadoop    .     ,         .    ,    . <br></li></ol><br>       . Kafka    .  ,    . <br><br><h2>    ? </h2><br> ,      ,  . -   , - . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ce/bde/20c/3cebde20c3fb5e3d8652a9be578a854e.png"><br> <i>    ,   : K2, K4  K7.</i> <br><br>           -  ,     .      ,      ,            ,       .     eventual consistency.  ,     ,        .   ,    . <br><br>   ‚Äî  ,       .   ,     .   ,     ,    :     .      . ,   ,     . <br><br>    ? ,     ,     .      ,        .    ,     .   ,    . <br><br>  The idea is good.    ,            .    , ,          .                 . <br><br><h2>   </h2><br>         .      ‚Äî   ‚Äî       . ,      . ,   ,  ,    ,       - .    -  , , ‚Ä¶  . <br><br>   ?         ‚Äî   .         ,     . ,        ,      . <br><br>      ‚Äî tumbling window ‚Äî         .   , ,         .    ?     .          ,      ,   ‚Äî     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/786/c48/845/786c48845e645275f8591a7f3f2d313f.png"><br><br>          K1.   ,            K1.           (  ),     ,    .    ,         .       ,     . <br><br>     ,   ,    ,             . <br><br><h2>      </h2><br>     ,     .       ,   ,       ,       . ,   ,    -    ,        .      ,      . ,         - ,   ,   ,   .       : ,        ,       . <br><br>   ,  ,       ‚Äî        .      ,   ,     .          ,       . <br><br>     ,     .     ‚Äî      ‚Äî  (watermarks). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3db/5f6/413/3db5f6413674516eb6a692527fe6e71d.png"><br><br>      ,    ,       .    .  ,     ‚Äî ,       ..           ,  ,   . <br><br>      time-based  .        ,    .    ,    ‚Äî .     ,  ,  . <br><br>   :      .   : <br><br>     ,   .  .  -,      .    ,        .      . <br><br>  ,      ,    .              ,     ?     .     ,    ,      .   ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d67/9da/112/d679da112fb386da2357887fcbbfb589.png"><br><br>    ?      -     .       .     ,   ,      .             .             . <br><br>       ,     . Processing Time ‚Äî     . Event Time ‚Äî ,     . Ingestion Time ‚Äì      (    ). <br><br> ,          ‚Äî       .     eventual consistency.              ,  .            . <br><br><h2>   .    </h2><br>   ‚Äî        IT-.     ,      .     ,    : <br><br><ol><li>        ad-hoc ‚Äî     ..    ‚Äî       ‚Äî     .                .          .      ,    ,    . <br></li><li>       - .             push.    ‚Äî   push, ,   . <b>-       </b> ‚Äî      ,       . <br></li></ol><br> ,        ‚Äî      .  There are several approaches. <br><br> 1. <b>Queryable state</b> ‚Äî      .    query. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c58/251/071/c5825107152485636ee8e381a338ef12.png"><br><br>  ,     ‚Äî  Query Controller.   , SQL  - .       .   ,    ,     query controller.        ,   .       ‚Äî CQRS, Command-Query Responsibility Segregation,       .    ,   ‚Äî    ,  Query Controller. <br><br>    ,    .             ,      .      ,     .    ,      .          .      , ,   ,      ,      .    queryable state. <br><br> 2. <b>Copy by request</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e63/5b0/be3/e635b0be3893ad6bae5f893c7270a8dd.png"><br><br>  queryable state       ,       .    ,           ,   ‚Äî  ,    .    .            .          queryable controller ‚Äî     ,     .         ‚Äî           .      . <br><br>           ‚Äî   ,       ,    .         ,       .    ‚Äî   copy by request   queryable state. <br><br> 3. <b>Continuous distribution</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cd/8fc/cfb/4cd8fccfbb5d9cc67622172857652d9a.png"><br><br>       ‚Äî       -.      ,          .  ,    ,     ,         . ,       -  ‚Äî key-value ‚Äî    .    ,     .       ,      - . <br><br>   ‚Äî ,      .  ‚Äî   -         ,    .    -    - ,         ,      ,     . <br><br>               ,        .  ,     ,   continuous distribution    . <br><br><h2>    ? </h2><br>   .   : <br><br><ul><li> Kafka   JMS   . <br></li><li> Kafka        . <br></li><li> Eventual consistency ‚Äî       . <br></li><li>              ,       <br></li></ul><br>        , ,      -.   .       ,        .     ,   ,      . </div><p>Source: <a href="https://habr.com/ru/post/353608/">https://habr.com/ru/post/353608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353596/index.html">Creating a game on Lua and L√ñVE - 7</a></li>
<li><a href="../353600/index.html">Digital events in Moscow from 16 to 22 April</a></li>
<li><a href="../353602/index.html">The perfect way to offline from online</a></li>
<li><a href="../353604/index.html">Synergistic organizations and Pokupo. How do we work and where does Ethereum?</a></li>
<li><a href="../353606/index.html">DotVVM - First Look</a></li>
<li><a href="../353610/index.html">The dispute about the ‚Äúright to oblivion‚Äù: whether to consider the work of search engines as journalism?</a></li>
<li><a href="../353612/index.html">Manage your browser with PHP and Selenium</a></li>
<li><a href="../353614/index.html">Internet Marketing and Web Analytics Strategy Avinash Koshyk</a></li>
<li><a href="../353616/index.html">We manage a big long project: why is it important to speak with words</a></li>
<li><a href="../353618/index.html">Reservoir Dogs: Angular 2 vs React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>