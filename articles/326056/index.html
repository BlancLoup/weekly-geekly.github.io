<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The dark side of using CSS polyfills</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last year, I wrote an article about Houdini for Smashing Magazine and called it "the most awesome CSS project you've never heard of." In this article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The dark side of using CSS polyfills</h1><div class="post__text post__text-html js-mediator-article">  Last year, I wrote <a href="https://habrahabr.ru/company/mailru/blog/282027/">an article</a> about <a href="https://github.com/w3c/css-houdini-drafts/wiki">Houdini</a> <a href="https://habrahabr.ru/company/mailru/blog/282027/">for Smashing Magazine</a> and called it "the most awesome CSS project you've never heard of."  In this article I will explain that the Houdini API set will allow (among other things) to extend CSS functions through polyfills in a way that is simply impossible today. <br><br>  Although that article was generally well received, the same question was constantly asked me in letters and twitter.  The main essence of the question: <br><br><blockquote>  What's so complicated about CSS polyfills?  I use a lot of CSS polyfills, and they work fine for me. </blockquote><br>  And I understood - of course, people have such questions.  If you have never tried to write a CSS polyfill yourself, you probably never experienced this pain. <br><a name="habracut"></a><br>  So the best way to answer this question ‚Äî and to explain why Houdini impresses me so much ‚Äî is to show clearly why it is so difficult to use CSS polyfills. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And the best way to do this is to write a polyfill yourself. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZskP7cvj3WA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Note:</b> This article is a text version of the <a href="http://www.thedotpost.com/2016/12/philip-walton-the-dark-side-of-polyfilling-css">lecture</a> , which I read at dotCSS on December 2, 2016.  The article covers a bit more details, but if you prefer to watch the video, I also inserted it here. <br><br>
<h1>  Keyword <code>random</code> </h1><br>  The function from which we want to make a polyfill is the new (suppose it is new) keyword <code>random</code> , which returns a number between 0 and 1 (just like <code>Math.random()</code> in JavaScript). <br><br>  Here is an example of using random: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">hsl</span></span>(calc(random * 360), <span class="hljs-number"><span class="hljs-number">50%</span></span>, <span class="hljs-number"><span class="hljs-number">50%</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: random; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(random * 100%); }</code> </pre> <br>  As you can see, since <code>random</code> returns a dimensionless number, you can use it with <code>calc()</code> to turn it into almost any value.  And since it can have any value, it can be applied with any property (for example, <code>color</code> , <code>opacity</code> , <code>width</code> , etc.). <br><br>  Throughout the rest of the article we will work with the <a href="https://philipwalton.github.io/talks/2016-12-02/demos/1/">demo page</a> , which I showed in my lecture.  Here's what she looks like: <br><br> <a href="https://philipwalton.github.io/talks/2016-12-02/demos/1/"><img src="https://habrastorage.org/getpro/habr/post_images/566/763/c5b/566763c5bce8580a63874bdb22d63b22.png"></a> <br>  <i><a href="https://philipwalton.github.io/talks/2016-12-02/demos/1/">An example of</a> what a site might look like where the <code>random</code> keyword is used.</i> <br><br>  This is the basic ‚ÄúHello World‚Äù page from the Bootstrap start template, where four <code>.progress-bar</code> elements are added to the top of the content area. <br><br>  In addition to <code>bootstrap.css</code> , it contains another CSS file with the following rule: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.progress-bar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(random * 100%); }</code> </pre> <br>  Although my demo page clearly indicates the widths of the progress bars, the idea is that when using polyfills, each time the page loads, these indicators will have a different, random width. <br><br><h1>  How polyfills work </h1><br>  In JavaScript, polyfills are relatively easy to write, because the language is so dynamic and allows you to change embedded objects in real time. <br><br>  For example, if you want to make a polyfill from <code>Math.random()</code> , then write something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random != <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Implement polyfill here... }; }</span></span></code> </pre> <br>  CSS, on the other hand, is not so dynamic.  It is impossible (at least for the time being) to change the execution environment in such a way as to inform the browser about a new function that it does not natively support. <br><br>  This means that in order to use a polyfill with a function in CSS that the browser <i>does not</i> support, you have to dynamically change the CSS in order to fake the behavior of the function with the help of CSS functions that the browser <i>supports</i> . <br><br>  In other words, you need to turn it: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(random * 100%); }</code> </pre> <br>  into something like this that is randomly generated during the execution of the code in the browser: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(0.35746 * 100%); }</code> </pre> <br><h3>  CSS change </h3><br>  Now we know that we need to change the existing CSS and add new style rules that mimic the behavior of the function from the polyfill. <br><br>  The most natural place where you could suggest such an action would be the CSS Object Model (CSSOM), available through <code>document.styleSheets</code> .  The code might look something like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">stylesheet</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">of</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.styleSheets</span></span>) { // Flatten nested rules (@media blocks, etc.) into a single array. const rules = [...stylesheet.rules].reduce((prev, next) =&gt; { return prev.concat(next.cssRules ? [...next.cssRules] : [next]); }, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>); // <span class="hljs-selector-tag"><span class="hljs-selector-tag">Loop</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">through</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">each</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">of</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">the</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flattened</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rules</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">and</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">replace</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">the</span></span> // <span class="hljs-selector-tag"><span class="hljs-selector-tag">keyword</span></span> `<span class="hljs-selector-tag"><span class="hljs-selector-tag">random</span></span>` <span class="hljs-selector-tag"><span class="hljs-selector-tag">with</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">random</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">number</span></span>. <span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rule</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">of</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rules</span></span>) { for (const property of Object.keys(rule.style)) { const value = rule.style[property]; if (value.includes('random')) { rule.style[property] = value.replace('random', Math.random()); } } } }</code> </pre> <br>  <b>Note:</b> in this polyfill, you will not use the simple search and replace function of the word <code>random</code> , because it can be present in different forms, and not only in the keyword (for example, in the URL, in the name of a property, in the quoted text in the property <code>content</code> , etc.).  The real code in the final demo version uses a more reliable replacement mechanism, but for simplicity I use the simplified version here. <br><br>  If you load <a href="https://philipwalton.github.io/talks/2016-12-02/demos/2/">demo No. 2</a> , insert the above code into the JavaScript console and run it, it will actually do what it should do, but after executing it, you will not see any progress indicators of a random width. <br><br>  The reason is that in CSSOM there are <i>no</i> rules with the keyword <code>random</code> ! <br><br>  As you probably already know, if a browser encounters a CSS rule that does not understand, then simply ignore it.  In most cases, this is good, because this way you can load CSS into old browsers and don‚Äôt break the page.  Unfortunately, this also means that if you need access to the original, unmodified CSS, you will have to get it yourself. <br><br><h3>  Manually Retrieving Page Styles </h3><br>  You can add CSS rules to a page using either the <code>&lt;style&gt;</code> or <code>&lt;link rel="stylesheet"&gt;</code> elements, so you can use <code>querySelectorAll()</code> on the document to get the original, unchanged CSS and manually extract the contents of any <code>&lt;style&gt;</code> tags or apply <code>fetch()</code> , getting the resource URL for all <code>&lt;link rel="stylesheet"&gt;</code> tags. <br><br>  The following code defines the <code>getPageStyles</code> function, which should return the full CSS code for all page styles: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getPageStyles = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Query the document for any element that could have styles. var styleElements = [...document.querySelectorAll('style, link[rel="stylesheet"]')]; // Fetch all styles and ensure the results are in document order. // Resolve with a single string of CSS text. return Promise.all(styleElements.map((el) =&gt; { if (el.href) { return fetch(el.href).then((response) =&gt; response.text()); } else { return el.innerHTML; } })).then((stylesArray) =&gt; stylesArray.join('\n')); }</span></span></code> </pre> <br>  If you open <a href="https://philipwalton.github.io/talks/2016-12-02/demos/3/">demo No. 3</a> and paste the above code into the JavaScript console to install the <code>getPageStyles()</code> function, then you can run the code below to get the full text CSS log: <br><br><pre> <code class="javascript hljs">getPageStyles().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cssText</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(cssText); });</code> </pre> <br><h3>  Parsing extracted styles </h3><br>  When you get the original CSS text, you need to parse. <br><br>  You might think that if the browser already has a built-in parser, then you can call some function and parse the CSS.  Unfortunately, this will not work.  And even if the browser had access to the <code>parseCSS()</code> function, this does not negate the fact that the browser does not understand the <code>random</code> keyword, so the <code>parseCSS()</code> function <code>parseCSS()</code> probably not work anyway (there is hope that future parsing specifications allow processing unfamiliar keywords that are otherwise compatible with the existing syntax). <br><br>  There are some good open source CSS parsers, and for the purposes of this demo we will use <a href="http://postcss.org/">PostCSS</a> (since it works as a browser and supports a plugin system, which will come in handy later). <br><br>  If you run <code>postcss.parse()</code> on the following CSS text: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.progress-bar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(random * 100%); }</code> </pre> <br>  then we get something like this: <br><br><pre> <code class="css hljs">{ "type": "root", "nodes": [ { "type": "rule", "selector": ".progress-bar", "nodes": [ { "type": "decl", "prop": "width", "value": "calc(random * 100%)" } ] } ] }</code> </pre> <br>  This is what is known as an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (ASD), and you can present it as your own version of CSSOM. <br><br>  Now we have a utility function for getting the full text of CSS and a function for parsing it, then this is what our polyfill looks like at the moment: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">postcss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> '<span class="hljs-selector-tag"><span class="hljs-selector-tag">postcss</span></span>'; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">getPageStyles</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> './<span class="hljs-selector-tag"><span class="hljs-selector-tag">get-page-styles</span></span>'; <span class="hljs-selector-tag"><span class="hljs-selector-tag">getPageStyles</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>((<span class="hljs-selector-tag"><span class="hljs-selector-tag">css</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">postcss</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.parse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">css</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>((<span class="hljs-selector-tag"><span class="hljs-selector-tag">ast</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ast</span></span>));</code> </pre> <br>  If you open the <a href="https://philipwalton.github.io/talks/2016-12-02/demos/4/">demo number 4</a> and look in the JavaScript console, you will see the object log containing the full ASD for PostCSS for all styles on the page. <br><br><h1>  Polyfill implementation </h1><br>  So far we have written a lot of code, but surprisingly, it is completely unrelated to the actual functionality of our polyfill.  It was just a necessary platform for manually doing a lot of things that the browser had to do for us. <br><br>  To actually implement the logic of a polyfill, we need: <br><br><ul><li>  Change CSS CSS, replace <code>random</code> met <code>random</code> number. </li><li>  Insert the modified ASD in string form back into CSS. </li><li>  Replace existing page styles with changed styles. </li></ul><br><h3>  Modifying the abstract CSS syntax tree </h3><br>  PostCSS comes with a good plugin system with many helper functions for modifying the abstract CSS syntax tree.  We can use these functions to replace the <code>random</code> encountered with <code>random</code> numbers: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomKeywordPlugin = postcss.plugin(<span class="hljs-string"><span class="hljs-string">'random-keyword'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">css</span></span></span><span class="hljs-function">) =&gt;</span></span> { css.walkRules(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rule</span></span></span><span class="hljs-function">) =&gt;</span></span> { rule.walkDecls(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">decl, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decl.value.includes(<span class="hljs-string"><span class="hljs-string">'random'</span></span>)) { decl.value = decl.value.replace(<span class="hljs-string"><span class="hljs-string">'random'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()); } }); }); }; });</code> </pre> <br><h3>  Insert an ASD in string form back into CSS </h3><br>  Another nice feature of using PostCSS plugins is that they already have built-in logic for inserting an ASD in string form back into CSS.  All you need to do is create a PostCSS instance, pass it to the plugin (or plugins) that you want to use, and run <code>process()</code> , which should return an object with CSS in string form: <br><br><pre> <code class="javascript hljs">postcss([randomKeywordPlugin]).process(css).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result.css); });</code> </pre> <br><h3>  Replacing page styles </h3><br>  To replace page styles, we can write a utility function (similar to <code>getPageStyles()</code> ) that finds all <code>&lt;style&gt;</code> and <code>&lt;link rel="stylesheet"&gt;</code> elements and deletes them.  It also creates a new <code>&lt;style&gt;</code> and sets the style content to any CSS text that is passed to the function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replacePageStyles = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">css</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Get a reference to all existing style elements. const existingStyles = [...document.querySelectorAll('style, link[rel="stylesheet"]')]; // Create a new &lt;style&gt; tag with all the polyfilled styles. const polyfillStyles = document.createElement('style'); polyfillStyles.innerHTML = css; document.head.appendChild(polyfillStyles); // Remove the old styles once the new styles have been added. existingStyles.forEach((el) =&gt; el.parentElement.removeChild(el)); };</span></span></code> </pre> <br><h1>  Putting it all together </h1><br>  Armed with our PostCSS plugin to change the CSS CSS and two utility functions to retrieve and update page styles, our polyfill code now looks like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">postcss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> '<span class="hljs-selector-tag"><span class="hljs-selector-tag">postcss</span></span>'; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">getPageStyles</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> './<span class="hljs-selector-tag"><span class="hljs-selector-tag">get-page-styles</span></span>'; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">randomKeywordPlugin</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> './<span class="hljs-selector-tag"><span class="hljs-selector-tag">random-keyword-plugin</span></span>'; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">replacePageStyles</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> './<span class="hljs-selector-tag"><span class="hljs-selector-tag">replace-page-styles</span></span>'; <span class="hljs-selector-tag"><span class="hljs-selector-tag">getPageStyles</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>((<span class="hljs-selector-tag"><span class="hljs-selector-tag">css</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">postcss</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[randomKeywordPlugin]</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.process</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">css</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>((<span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span>) =&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">replacePageStyles</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span>));</code> </pre> <br>  If you open <a href="https://philipwalton.github.io/talks/2016-12-02/demos/5/">demo number 5</a> , you can see it in action.  Refresh the page several times to feel the real chance! <br><br>  ... hmmmmmm, not exactly what you expected, is it? <br><br><h1>  Something went wrong </h1><br>  Although the plugin works technically, it inserts the same random value for each element that corresponds to the replacement function. <br><br>  This is completely logical, if we think about what we have done - we simply replaced the only property with a single rule. <br><br>  The truth is that even the simplest CSS polyfills require more than rewriting individual property values.  Most of them require more knowledge of the DOM, as well as specific details (size, contents, order, etc.) of individual elements that meet the requirements.  That is why preprocessors and server solutions for this problem will never be enough in themselves. <br><br>  But an important question arises: <i>how do we update the polyfill to identify individual elements?</i>  . <br><br><h1>  Definition of individual relevant elements </h1><br>  In my experience, there are three options for defining individual DOM elements, but they are not good enough. <br><br><h3>  Option number 1: inline styles </h3><br>  As practice shows, most often the authors of polyfills define the problem of defining individual elements using the CSS rules selector in order to find suitable elements on the page and directly apply inline styles to them. <br><br>  Here's how to change our PostCSS plugin in this way: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... rule.walkDecls((decl, i) =&gt; { if (decl.value.includes('random')) { const elements = document.querySelectorAll(rule.selector); for (const element of elements) { element.style[decl.prop] = decl.value.replace('random', Math.random()); } } }); // ...</span></span></code> </pre> <br>  <a href="https://philipwalton.github.io/talks/2016-12-02/demos/6/">Demo number 6</a> shows this code in action. <br><br>  At first, it seems to be working fine, but, unfortunately, it is easy to knock him down.  Suppose we have updated CSS and added another rule after our <code>.progress-bar</code> rule. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.progress-bar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(random * 100%); } <span class="hljs-selector-id"><span class="hljs-selector-id">#some-container</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.progress-bar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: auto; }</code> </pre> <br>  The code at the top declares that the elements of all loading indicators on the pages should have a random width, except for those loading indicators elements that depend on the element with the identifier <code>#some-container</code> .  In this case, the width should <i>not</i> be random. <br><br>  Of course, this does not work, because we apply inline styles directly to the element.  This means that these styles will be more specific than the styles defined in <code>#some-container .progress-bar</code> . <br><br>  This means that our polyfill does not correspond to some fundamental assumptions about working with CSS (so I personally find this method unacceptable). <br><br><h3>  Option number 2: inline styles </h3><br>  The second option assumes that in many cases of real use the first option does not work, so he tries to correct the situation.  In particular, in the second version we update our implementation in order to: <br><br><ul><li>  Check the rest of the CSS for relevant rules, then replace the random keyword with a random number and apply these declarations as inline styles only if this is the last matching rule. <br><br></li><li>  Wait, it doesn't work, because you need to take into account the specificity, so you have to manually parse each selector for the calculation.  Then we can sort the relevant rules in ascending order of specificity and apply declarations only from the specific selector itself. <br><br></li><li>  Oh, and there are still <code>@media</code> elements, so here you also need to manually check the match. <br><br></li><li>  And if we talk about violations of the rules, then there are <code>@supports</code> - let's not forget about it. <br><br></li><li>  One last thing: you need to take into account the inheritance of properties, so for each element you have to walk through the DOM tree and check all parent elements to get the full set of calculated properties. <br><br></li><li>  Oh, sorry, one more thing: you must also take into account the declaration <code>!important</code> , which is calculated for each property, and not for each rule.  Therefore, it is required to save a separate card for them in order to find out which declaration will ultimately win. </li></ul><br>  Yes, if you do not understand, I just described the cascade, the execution of which implies a dependence on the browser. <br><br>  Although it is definitely <i>possible to</i> re-implement such a cascade in JavaScript, there will be a lot of work, so I would definitely look at what is in option 3. <br><br><h3>  Option number 3: rewrite the CSS to define the individual corresponding elements, preserving the cascade order </h3><br>  The third option - which I consider the best among the worst - is to rewrite the CSS and convert the rules with one selector, which matches many elements, into several rules, each of which will correspond only to one element, without changing the final set of elements. <br><br>  Since the last sentence does not look very meaningful, let me illustrate this with an example.  Consider a CSS file that is included in the page and contains three paragraph elements: <br><br><pre> <code class="css hljs">* { <span class="hljs-attribute"><span class="hljs-attribute">box-sizing</span></span>: border-box; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Will match 3 paragraphs on the page. */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: random; } <span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: initial; }</code> </pre> <br>  If we add a unique data attribute to each paragraph in the DOM, we can rewrite the CSS as follows to define each paragraph with our own, individual rule: <br><br><pre> <code class="css hljs">* { <span class="hljs-attribute"><span class="hljs-attribute">box-sizing</span></span>: border-box; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-pid="1"]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">23421</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-pid="2"]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">82305</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-pid="3"]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">31178</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: initial; }</code> </pre> <br>  Of course, if you notice, this option still does not work very well, because it affects the specificity of these selectors, which is likely to lead to unintended side effects.  <i>However</i> , we can ensure the preservation of the correct cascade order by increasing the specificity of <i>all the other selectors</i> on the page by the same amount, using such a smart hack: <br><br><pre> <code class="css hljs">*‚Äã<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(.z)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">box-sizing</span></span>: border-box; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-pid="1"]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">23421</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-pid="2"]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">82305</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-pid="3"]</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: .<span class="hljs-number"><span class="hljs-number">31178</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(.z)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: initial; }</code> </pre> <br>  The changes above apply the pseudo-class function selector <code>:not()</code> and pass it the name of a class that is definitely not in the DOM (in this case, I chose <code>.z;</code> so if you use the class <code>.z;</code> in the DOM, you will have to choose another name).  And since <code>:not()</code> always corresponds to a non-existent element, it can be used to increase the specificity of a selector without changing its conformity. <br><br>  <a href="https://philipwalton.github.io/talks/2016-12-02/demos/7/">Demo number 7</a> shows the result of the implementation of such a strategy, and you can view the <a href="">source code of the demo</a> and examine the complete set of changes in the <code>random-keyword</code> plugin. <br><br>  The best thing about the third option is that it continues to give the browser a cascade, which is really good for the browser.  This means that you can use media queries <code>@support</code> declarations, non-standard properties, <code>@support</code> rules or any CSS functions, and everything will work fine. <br><br><h1>  disadvantages </h1><br>  It may seem that the way number 3, I solved all the problems with CSS polyfills, but this is very far from the truth.  There are still many problems, some of which can be solved (by spending a lot of extra time), while others are impossible, and therefore they are inevitable. <br><br><h3>  Unsolved problems </h3><br>  First of all, I deliberately ignored some parts of CSS that may exist on the page, but are not available for DOM requests for the <code>&lt;style&gt;</code> and <code>&lt;link rel="stylesheet"&gt;</code> tags: <br><br><ul><li>  Inline styles </li><li>  Shadow DOM </li></ul><br>  We <i>can</i> update our polyfill for these cases, but this will require a lot of additional work, which I would not like to discuss in this article. <br><br>  We also didn‚Äôt even consider what happens when the DOM changes.  In the end, we rewrite our CSS according to the DOM structure.  This means that we have to rewrite every time the DOM changes. <br><br><h3>  Inevitable problems </h3><br>  In addition to the problems described above (which are difficult but solvable), there are some problems that cannot be avoided: <br><br><ul><li>  A <i>huge amount of</i> additional code is required. </li><li>  The method does not work with cross-origin style sheets (non-CORS). </li><li>  A polyfill works terribly when / when changes are needed (for example, DOM changes, scroll / resize handlers, etc.). </li></ul><br>  Our polyfill for the <code>random</code> keyword is a fairly simple example.  But I am sure that you can easily imagine polyfills for something like <code>position: sticky</code> , and then all the logic described here will need to be restarted every time the user scrolls the page, which will have a <i>terrible</i> effect on performance. <br><br><h4>  Opportunities for improvement </h4><br>  One solution that I missed in my lecture (due to time constraints) can potentially mitigate the first two of the above three problems.  This is parsing and fetching CSS on the server side during the build phase. <br><br>  Then, instead of loading a CSS file with styles, you load a JavaScript file that contains an ASD.  Then the first thing you do is translate the SDA into a string view and add styles to the page.  You can even enable the <code>&lt;noscript&gt;</code> , which refers to the original CSS file if the user has disabled JavaScript. <br><br>  For example, instead of this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  you will have this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">noscript</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">noscript</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  As I mentioned, this solves the problem of having to include a full CSS parser in your JavaScript suite and also allows you to parse CSS in advance, but does not solve all performance problems. <br><br>  But in any case, you always have to rewrite the CSS as soon as changes are required. <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Understanding Performance Implications </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To understand why polyfill performance is so low, you really need to understand the browser rendering pipeline ‚Äî especially those rendering steps that you have access to as a developer. </font></font><br><br><img src="https://habrastorage.org/files/17d/b6d/790/17db6d7909204bfe8e7d31e398410671.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript access to the rendering pipeline in the browser</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you can see, the only real entry point is the DOM, which our polyfill used by querying elements corresponding to the CSS selector, as well as by updating the CSS text in the tag </font></font><code>&lt;style&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But given the current mechanism for accessing JavaScript to the rendering pipeline in the browser, this is the way to choose our polyfill. </font></font><br><br><img src="https://habrastorage.org/files/b99/f9a/e17/b99f9ae175b04cf1b72be4f0f8527017.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyfill entry points to browser rendering pipeline</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, JavaScript cannot interfere with the source rendering pipeline after creating the DOM, so any changes made by the polyfill will force the rendering process to start over. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that the CSS polyfills cannot work at 60 fps at all, since all updates lead to subsequent rendering and therefore to a subsequent frame.</font></font><br><br><h1>  Summarizing </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would like you to understand from this article that creating CSS polyfills is especially difficult, because all our work as developers consists in circumventing the limitations of the styles and layout of the modern web. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a list of things that our polyfill should do on its own - these are things that the browser already does, but we, as developers, do not have access to these functions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CSS sample </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CSS parsing </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating CSSOM </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cascade processing </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Style Invalidation </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repeated style validation </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is exactly what fascinates me in </font></font><a href="https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Houdini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Without Houdini software interfaces, developers will have to resort to hacks and workarounds, which leads to lower productivity and user convenience. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this means that polyfills will definitely be either:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Too big </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Too slow </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Too wrong </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, we cannot get rid of all three shortcomings. </font><font style="vertical-align: inherit;">You have to choose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without low-level styling primitives, innovation will move at the speed of the slowest browser. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Developers from the JavaScript community complain about the greater rate of innovation. </font><font style="vertical-align: inherit;">But you will never hear that in CSS. </font><font style="vertical-align: inherit;">And partly due to the limitations described in the article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think we need to change this. </font><font style="vertical-align: inherit;">I think we need </font></font><a href="https://twitter.com/hashtag/makecssfatigueathing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#makecssfatigueathing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/326056/">https://habr.com/ru/post/326056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326046/index.html">Everything new is well forgotten old</a></li>
<li><a href="../326048/index.html">Games for HTC Vive that can already be played</a></li>
<li><a href="../326050/index.html">Simplify working with CloudKit, or synchronization in the spirit of Zen</a></li>
<li><a href="../326052/index.html">The book "Swift. Basics of developing applications for iOS and macOS. 3rd ed. supplemented and revised "</a></li>
<li><a href="../326054/index.html">Azure microservice application</a></li>
<li><a href="../326058/index.html">Not only cash desk: how the IT infrastructure of modern stores is arranged</a></li>
<li><a href="../326060/index.html">How to make Telegram and Telephony even faster</a></li>
<li><a href="../326062/index.html">Improving the reliability of Kubernetes: how to quickly notice that the node fell</a></li>
<li><a href="../326064/index.html">Courses Computer Science Club, spring 2017</a></li>
<li><a href="../326068/index.html">How to write TK on the system or revision of the 1C system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>