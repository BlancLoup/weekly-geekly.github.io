<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How method scheduling in Ruby works</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Notes: 

 Hello. This article is a free translation (link at the end). I do not pretend to any 100% correct translation. However, I belie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How method scheduling in Ruby works</h1><div class="post__text post__text-html js-mediator-article">  <b>Translator's Notes:</b> <br><br>  Hello.  This article is a free translation (link at the end).  I do not pretend to any 100% correct translation.  However, I believe that the general essence of what is happening is conveyed completely. <br><br>  <u>Who can this article be useful for?</u>  Most likely for beginners Ruby on Rails developers who are just curious to understand some points in the work of Ruby. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <u>For whom this article may be useless?</u>  Most likely for purebred Ruby programmers and hardened Ruby on Rails developers.  Chances are that you already know this. <br><br>  <u>Why did I do the translation?</u>  This article seemed to me interesting and I simply had a desire to share it with all the Russian-speaking (mb badly knowing English) community. <br><br>  PS If you know English, just follow the link at the end. <br><a name="habracut"></a><br>  <b>The following is the translation text:</b> <br><br>  The other day, I asked everyone if anyone knew a good and short explanation regarding objects in Ruby and the method dispatching system.  And the answer of some people was "no, you should write about it."  So here is the article.  I'm going to explain how the system of objects in Ruby works, including method searching, inheritance, super classes, classes, mixins, and singleton methods.  My understanding came not from reading MRI sources, but from re-implementing this system, once in JavaScript and once in Ruby.  If you want to read a small but almost correct implementation, then this is a good place to start. <br><br>  Due to the fact that I did not really read the sources, this article will explain what is happening in Ruby from the point of view of logic, and not from the point of view of what is really happening.  This is just a model with which you can understand some things. <br><br>  Let's start over.  You can create a system of cut objects almost completely only from modules.  Think of modules as bags of methods.  For example, module A contains the method foo and bar. <br><br><pre><code class="ruby hljs">+----------+ <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> A |</span></span> +----------+ <span class="hljs-params"><span class="hljs-params">| def foo |</span></span> <span class="hljs-params"><span class="hljs-params">| def bar |</span></span> +----------+</code> </pre> <br><br>  When you write def foo ... end inside a ruby ‚Äã‚Äãmodule, you add this method to the module, that's all.  A module can have multiple parents.  When you write: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  All you do is add And as a parent to B. No methods are copied, we simply create a pointer from B to A. <br><br><pre> <code class="ruby hljs"> +-----------+ <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> A |</span></span> +-----------+ <span class="hljs-params"><span class="hljs-params">| def foo |</span></span> <span class="hljs-params"><span class="hljs-params">| def bar |</span></span> +-----------+ ^ <span class="hljs-params"><span class="hljs-params">| +-----+-----+ |</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> | +-----------+ | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hello</span></span></span><span class="hljs-class"> | | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bye</span></span></span><span class="hljs-class"> | +-----------+</span></span></code> </pre><br><br>  A module can have multiple parents, thereby forming a tree.  For example, these modules: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hello</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bye</span></span></span><span class="hljs-function"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  They form this tree, in accordance with the order of their inclusion. <br><br><pre> <code class="ruby hljs"> +-----------+ <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> B |</span></span> +-----------+ <span class="hljs-params"><span class="hljs-params">| def hello |</span></span> <span class="hljs-params"><span class="hljs-params">| def bye |</span></span> +-----------+ ^ +-----------+ +-----+-----+ <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> A |</span></span> <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> C |</span></span> +-----------+ +-----------+ <span class="hljs-params"><span class="hljs-params">| def foo |</span></span> <span class="hljs-params"><span class="hljs-params">| def start |</span></span> <span class="hljs-params"><span class="hljs-params">| def bar |</span></span> <span class="hljs-params"><span class="hljs-params">| def stop |</span></span> +-----------+ +-----------+ ^ ^ +-------------------+-------------------+ <span class="hljs-params"><span class="hljs-params">| +-----+-----+ |</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> | +-----------+</span></span></code> </pre><br><br>  An important point that explains how Ruby finds the place to define a method lies in the "genealogy" of models (module's 'ancestry').  You can ask the module to provide you with its ‚Äúpedigree‚Äù and it will provide you with it in the form of an array of modules: <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> D.ancestors =&gt; [D, C, B, A]</code> </pre><br><br>  The important thing is that it is a pedigree in the form of a simple chain, instead of being in the form of a tree.  This chain determines the order in which we iterate over the modules to find a method.  To build this list, we start with D and dive deeper, looking all the parents from right to left.  Therefore, the order of include calls is very important.  Parents of the module are arranged in order and this determines the order in which they will be searched. <br><br>  When we want to find a place to define a method, we look at the chain of inheritance until we find the first module in which it is defined.  If none of the modules contain this method, we search again, but this time we are looking for a method called method_missing.  If none of the modules contain a method, then a NoMethodError exception is thrown.  The chain of module inheritance solves the problem when two modules contain the same method.  That method whose module is the first in the inheritance chain will be called. <br><br>  We can use Ruby's capabilities to determine whose method was used when we called it. <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> D.instance_method(<span class="hljs-symbol"><span class="hljs-symbol">:foo</span></span>) =&gt; #&lt;UnboundMethod: D(A)#foo&gt; &gt;&gt; D.instance_method(<span class="hljs-symbol"><span class="hljs-symbol">:hello</span></span>) =&gt; #&lt;UnboundMethod: D(B)#hello&gt; &gt;&gt; D.instance_method(<span class="hljs-symbol"><span class="hljs-symbol">:start</span></span>) =&gt; #&lt;UnboundMethod: D(C)#start&gt;</code> </pre><br><br>  UnboundMethod is simply a representation of a method from a model, before it is associated with an object.  When you see D (A) #foo, it means that D inherits the #foo method from A. If you call #foo on an object that includes D, you will get the method defined in A. <br><br>  Speaking of objects, why have we not done one yet?  What good is a bag with methods, if there is no object to which we could apply it.  What this is where the class comes into action.  In Ruby, a class is a subclass of a module, which sounds weird, but remember that they are all data structures that store methods.  A class is almost like a module, from the point of view that it stores methods and may include other modules, but it has some additional features.  One of which is the ability to create objects. <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span></span></code> </pre><br><br>  We again have the opportunity to determine where the object's methods come from. <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> k.method(<span class="hljs-symbol"><span class="hljs-symbol">:start</span></span>) =&gt; #&lt;Method: K(C)#start&gt;</code> </pre><br><br>  This shows that when we call k.start, we get the #start method from module C. You notice that when you call the module instance_method, it returns the UnboundMethod, and in the case of the Method object.  The difference is that Method is associated with an object.  When you call #call on an object, the behavior will be the same as in the case of k.start.  UnboundMethods cannot be called directly, because  they do not have an object that could call them. <br><br>  It looks like we are looking for a method starting from the class to which the object belongs, then we look through the entire chain of inheritance until we find the place to define the method.  Well, it's almost true, but Ruby has another trick up his sleeve: singleton methods.  You can add new methods to an object, and only to this object, without adding it to the class.  See: <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mart</span></span></span><span class="hljs-function"> ;</span></span> end &gt;&gt; k.method(<span class="hljs-symbol"><span class="hljs-symbol">:mart</span></span>) =&gt; #&lt;Method: #&lt;K:0x00000001f78248&gt;.mart&gt;</code> </pre><br><br>  We can also add them to the modules, since  modules are just one of the object types. <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roll</span></span></span><span class="hljs-function"> ;</span></span> end &gt;&gt; B.method(<span class="hljs-symbol"><span class="hljs-symbol">:roll</span></span>) =&gt; #&lt;Method: B.roll&gt;</code> </pre><br><br>  If the name of the method is (.) Instead of the hash (#), it means that the method exists only for this object, instead of being in a module.  However, we said earlier that Ruby uses modules to store methods;  simple old objects had no such possibility.  So where are the singleton methods stored? <br><br>  Each object in Ruby (and remember, modules and classes are also objects) have so-called metaclasses, also known as singleton classes, eigenclass or virtual classes.  The work of these classes is to simply store the object's singleton methods.  Initially, they do not contain any methods and have an object class as their only parent.  So for our object k, the inheritance chain will look like this: <br><br><pre> <code class="ruby hljs"> +-----------+ <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> B |</span></span> +-----------+ ^ +-----------+ +-----+-----+ <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> A |</span></span> <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span><span class="hljs-params"> C |</span></span> +-----------+ +-----------+ ^ ^ +-------------------+-------------------+ <span class="hljs-params"><span class="hljs-params">| +-----+-----+ |</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> | +-----------+ ^ +-----+-----+ | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class"> | +-----------+ ^ +-----+-----+ +---+ | </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">metaclass</span></span></span><span class="hljs-class"> |&lt;~~~~~~~~+ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class"> | +-----------+ +---+</span></span></code> </pre><br><br>  We can ask Ruby to show the object's metaclass.  Here we see that the metaclass is an anonymous class attached to the object k, and it has an instance #mart method which does not exist in the K class. <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> k.singleton_class =&gt; #&lt;Class:#&lt;K:0x00000001f78248&gt;&gt; &gt;&gt; k.singleton_class.instance_method(<span class="hljs-symbol"><span class="hljs-symbol">:mart</span></span>) =&gt; #&lt;UnboundMethod: #&lt;Class:#&lt;K:0x00000001f78248&gt;&gt;<span class="hljs-comment"><span class="hljs-comment">#mart&gt; &gt;&gt; K.instance_method(:mart) NameError: undefined method `mart' for class `K'</span></span></code> </pre><br><br>  One point to which you should pay attention is that the metaclass is not displayed in the chain of inheritance, but you should understand that it still participates in the chain of searching for the place where the method is defined. <br><br>  When we call the object method k, the object asks its metaclass if it does not contain this method and the metaclass further scans the chain of inheritance in order to determine the location of the method.  Singleton methods are in metaclass and they have an advantage over methods defined in the class of the object and all its parents. <br><br>  Now, we are approaching the second special class property, besides their ability to create objects.  Classes have a special form of inheritance called ‚Äúsubclassing‚Äù.  Each class has one and only one superclass, the default is Object.  From the point of view of the method call, you can think of superclasses as the first parent module of the class: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> &lt; Bar </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extras</span></span></span><span class="hljs-class"> =~ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extras</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  Thus, the inheritance chain gives us [Foo, Extras, Bar], in both cases, and it, as it was before, determines the order of the search method.  (In fact, it looks like [Foo, Extras, Bar, Object, Kernel, BasicObject], but we will look at it in a minute).  Note that Ruby violates Liskov's principle of substitution, not allowing classes to be included (include), only modules can be used in a similar way, not their subtypes.  The snippet shown above shows how subclassing affects the search order of a method, and the code on the right will not work if Bar is a class. <br><br>  If subclassing is the same as inclusion (include), why do we need both of these features?  Well, it gives us another opportunity.  Classes inherit singleton methods from their superclasses, and this is not the case with modules. <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Z</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">z</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:z</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:bar</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> &lt; Bar </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Z</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Singleton methods from Bar work on Foo ... &gt;&gt; Bar.bar =&gt; :bar &gt;&gt; Foo.bar =&gt; :bar # ... but singleton methods from Z don't &gt;&gt; Zz =&gt; :z &gt;&gt; Foo.z NoMethodError: undefined method `z' for Foo:Class</span></span></span></span></code> </pre><br><br>  We can model this in terms of parenting, saying that subclasses of metaclasses have superclass metaclasses as their parents. <br><br><pre> <code class="ruby hljs"> +-----+ +--------------+ <span class="hljs-params"><span class="hljs-params">| Bar +~~~~~~~~&gt;|</span></span> <span class="hljs-comment"><span class="hljs-comment">#&lt;Class:Bar&gt; | +-----+ +--------------+ ^ ^ | | +--+--+ +-------+------+ | Foo +~~~~~~~~&gt;| #&lt;Class:Foo&gt; | +-----+ +--------------+</span></span></code> </pre><br><br>  Indeed, if we look at Foo, we will see that its #bar method comes from the metaclass Bar. <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> Foo.method(<span class="hljs-symbol"><span class="hljs-symbol">:bar</span></span>) =&gt; #&lt;Method: Foo(Bar).bar&gt; &gt;&gt; Foo.singleton_class.instance_method(<span class="hljs-symbol"><span class="hljs-symbol">:bar</span></span>) =&gt; #&lt;UnboundMethod: #&lt;Class:Bar&gt;<span class="hljs-comment"><span class="hljs-comment">#bar&gt;</span></span></code> </pre><br><br>  We have seen how inheritance and the order of searching for a method in Ruby can be depicted as a tree of modules, with inclusion and subclassing creating different parental relationships.  We also explained the single and multiple inheritance methods of objects and singleton methods.  Now let's look at a few things that are on the back of this model. <br><br>  The first is the Object # extend method.  By calling object.extend (M), we make the methods from module M available in the object.  We do not copy methods, we simply add M as the parent of the metaclass of this object.  If the object has a class of Thing, we get the following relation: <br><br><pre> <code class="ruby hljs"> +-------+ +-----+ <span class="hljs-params"><span class="hljs-params">| Thing |</span></span> <span class="hljs-params"><span class="hljs-params">| M |</span></span> +-------+ +-----+ ^ ^ +-------+-----+ <span class="hljs-params"><span class="hljs-params">| +--------+ +---------+-------+ |</span></span> object +~~~~~~~~&gt;<span class="hljs-params"><span class="hljs-params">| #&lt;Class:object&gt; |</span></span> +--------+ +-----------------+</code> </pre><br><br>  Thus, the extension of an object using a module is the same as the inclusion of this module in the metaclass of an object.  (Actually, there is some difference, but this does not apply to this topic).  Looking at this tree, we see that when we call the object method, the method dispatching system will prefer the methods defined in module M to those in Thing (the method from M will be used), and, in turn, the methods found in object metaclass will be prioritized than M and Thing. <br><br>  This context is important: we cannot say that methods in M ‚Äã‚Äãtake precedence over Thing in a general sense, but only when we are talking about calling the method of an object.  The chain of inheritance where the method is looked for is what matters.  And this shows up when we examine the work of super.  Take a look at the following set of modules: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call</span></span></span><span class="hljs-class"> ;</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:x</span></span>] ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> + [<span class="hljs-symbol"><span class="hljs-symbol">:y</span></span>] ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br><br>  The inheritance chain for Test is as follows: [Test, Y, X], so if we call Test.new.call, we call the #call method from Y. But, what happens when Y calls super?  Y does not have its own chain of inheritance, that is, there is no one on whom Y could call this method, right? <br><br>  And no.  When we were faced with a super call, what is important is that we made a method call for the object's inheritance chain, that's all.  You can imagine the search for a method as the search for all the definitions of a given method in the inheritance chains of an object's metaclass. <br><br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> t = Test.new &gt;&gt; t.singleton_class.ancestors.map { <span class="hljs-params"><span class="hljs-params">|m|</span></span> m.instance_methods(false).include?(<span class="hljs-symbol"><span class="hljs-symbol">:call</span></span>) ? m.instance_method(<span class="hljs-symbol"><span class="hljs-symbol">:call</span></span>) : nil }.compact =&gt; [#&lt;UnboundMethod: Y#call&gt;, #&lt;UnboundMethod: X#call&gt;]</code> </pre><br><br>  To determine the location of the method, we call the first method in the inheritance chain.  If this method calls super, we jump to the next one, and so on, until we finish the search.  If Test did not include the module X, there would be no implementation of #call other than that defined in Y, so the call to super would lead to an error. <br><br>  In fact, in our case, Test.new.call will return [: x,: y]. <br><br>  We are almost done, but I promised to tell you what Object, Kernel, and BasicObject are.  BasicObject is the root class of the entire system;  This is a class without a superclass.  Object is inherited from BasicObject, and is the base superclass for all user classes.  The difference between them is that BasicObject has almost no methods, while Object has quite a lot: Ruby kernel methods, such as: # ==, #__send__, #dup, #inspect, #instance_eval, #is_a ?, # method, #respond_to ?, and #to_s.  Although, in fact, Object itself does not contain all these methods, it gets them from Kernel.  Kernel is just a module with a set of all the methods of an object from the ruby ‚Äã‚Äãkernel.  Therefore, if we try to display the Ruby kernel object system, we get the following: <br><br><pre> <code class="ruby hljs"> +---------------+ +------------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| +-----------+----------+ +-------------+ +--------+ +--------+--------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-comment"><span class="hljs-comment">#&lt;Class:BasicObject&gt; |&lt;~~~~+ BasicObject | | Kernel +~~~~&gt;| #&lt;Class:Kernel&gt; | | | +----------------------+ +-------------+ +--------+ +-----------------+ | | ^ ^ ^ | | | +-------+--------+ | | | | | | +--------+--------+ +----+---+ | | | #&lt;Class:Object&gt; |&lt;~~~~~~~~~~~~~~~~+ Object | | | +-----------------+ +--------+ | | ^ ^ | | | | | | +--------+--------+ +----+---+ | | | #&lt;Class:Module&gt; |&lt;~~~~~~~~~~~~~~~~+ Module |&lt;-----------------------------------+ | +-----------------+ +--------+ | ^ ^ | | | | +--------+--------+ +----+---+ | | #&lt;Class:Class&gt; |&lt;~~~~~~~~~~~~~~~~+ Class | | +-----------------+ +--------+ | ^ | | +-----------------------------------------------+</span></span></code> </pre><br><br>  This diagram shows the modules and classes of the Ruby kernel: BasicObject, Kernel, Object, Module, and Class, their metaclasses, and how they are all related.  Yes, BasicObject.singleton_class.superclass is Class.  Ruby makes a little voodoo magic to make this barrel organ (note of the translator).  In any case, if you want to understand the dispatching methods in Ruby, just remember: <br><br><ul><li>  A module is a bag with methods. </li><li>  A module can have many parents. </li><li>  A class is a module that can create objects. </li><li>  Each object has a metaclass that has an object class as its parent. </li><li>  Subclassing refers to linking two classes and their metaclasses. </li><li>  Methods are searched through immersion in the tree of the "pedigree", looking through the branches from right to left </li></ul><br><br>  No, I do not know all the subtleties of this work.  Nobody knows. <br><br>  Original article: <a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/">blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works</a> </div><p>Source: <a href="https://habr.com/ru/post/274979/">https://habr.com/ru/post/274979/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274959/index.html">Android IDE Template Format</a></li>
<li><a href="../274961/index.html">On the revision of the results of the competition in programming on JS</a></li>
<li><a href="../274967/index.html">Monitoring SSL certificate and domain expiration</a></li>
<li><a href="../274975/index.html">Monte Carlo method and its accuracy</a></li>
<li><a href="../274977/index.html">HL7 C-CDA Rendering Tool Challenge (competition from HL7)</a></li>
<li><a href="../274981/index.html">Microsoft and Adobe have fixed vulnerabilities in their products.</a></li>
<li><a href="../274983/index.html">Making a wireless network bridge for 2 Mikrotik</a></li>
<li><a href="../274985/index.html">I knew how to validate an email address. Not yet read the RFC</a></li>
<li><a href="../274987/index.html">By the year 2060, programmers will not be needed</a></li>
<li><a href="../274989/index.html">IBM Watson improves its cognitive abilities and offers new opportunities for developers.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>