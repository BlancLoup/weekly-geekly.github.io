<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing your own solution: risks and responsibilities</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! This article will discuss how we at Mail.Ru Group approach code writing; when to use ready-made solutions, and when it is better to write yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing your own solution: risks and responsibilities</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  This article will discuss how we at Mail.Ru Group approach code writing;  when to use ready-made solutions, and when it is better to write yourself;  Well, and most importantly - what steps need to be done so that your work does not prove fruitless and benefits others.  All these nuances will be considered on the example of the task of creating our internal JSSDK, which arose because of the need to merge the code base of the two projects. <br><br><img src="https://habrastorage.org/files/532/716/8b6/5327168b609c42c19349e1575fe67f0b.jpg"><br>  <a href="http://www.theworldofmichaelparkes.com/cm/Home.html">Michael Parkes</a> illustration <br><a name="habracut"></a><br>  We constantly hear that reinventing bicycles is bad, but where is the line between the bicycle and the finished product?  At what stage <a href="http://backbonejs.org/">did Backbone</a> , <a href="http://emberjs.com/">Ember</a> or <a href="http://angular.ru/">Angular</a> cease to be?  This is rarely talked about.  It so happened that for the last four years I have been continuously developing various kinds of ‚Äúbicycles‚Äù - not because I like it (and I really like it), just some solutions are outdated, others are tied to a specific technology (for example, on the same <a href="https://jquery.com/">jQuery</a> ), not necessary to us, and tearing off which is equivalent to writing from scratch.  But the main problem lies in the narrow specialization and lack of opportunities for expansion.  There are a lot of solutions on the same githaba, but not everyone has a future.  Therefore, if you decide to urgently accomplish the task, having written what you think is an excellent thing, then do not waste time and take pity on other people who need to support this after you.  With a 99% chance they will overwrite everything.  So when can and even need to reinvent your own bike? <br><br>  <b>Start with the task, evaluate it:</b> <br><ul><li>  potential (is there a scope and development prospects, perhaps tomorrow it will not be necessary anymore); </li><li>  generalization (possibility of application in other tasks and projects); </li><li>  alienability (independence from internal infrastructure). </li></ul><br>  These simple points apply to almost any task, be it the development of a framework or a jQuery plugin. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our story began three years ago: the task was to ‚Äúdevelop mail for touch devices‚Äù, which required choosing a technology on the basis of which everything was done.  There were three options: <br><br><ol><li>  use the best practices of the mail; </li><li>  take a popular framework; </li><li>  write by yourself. </li></ol><br>  It was not possible to use the big mail code - 17 years of history make themselves known.  Therefore, it remains to either write by yourself or look for ready-made tools.  Developing a framework for such a task is very difficult, even taking into account our experience, this one has practically no potential, since it is very likely that this will be a highly specialized solution that is strictly tied to the wheelbarrow.  Approximately imagining what we need, we chose the appropriate solutions for our task (and most importantly - the teams): <br><br><ul><li>  Grunt - project build; </li><li>  RequireJS - organization of modules; </li><li>  Backbone - model, view, routing; </li><li>  Fest - template engine. </li></ul><br>  These simple tools allowed us to quickly develop a project and begin its implementation.  Everything was good, until the touch-mail started to catch up with a lot of functionality.  Because of this, many product features were made twice - first at the big post, and then at touch.mail.ru, although the differences in implementation were minimal and were configurable.  The situation was aggravated by the introduction of a new backend API, which was no longer enough just to "pull and get" the answer: <br><br><img src="https://habrastorage.org/files/2ff/627/0dc/2ff6270dc7044dca81bf6a5db3072afa.png"><br><br>  Having looked at all this, we decided that it was impossible to continue to live like this - double development, double bugs, double testing, again bugs ... And there are other internal projects that want to integrate some piece of Mail functionality. <br><br>  Everything spoke of the need for a common code base, which would be located in a separate repository, and within which the common components would be implemented. <br><br>  Summing up our knowledge of projects, we have defined a basic set of packages: <br><br><ul><li>  Emitter - event emitter; </li><li>  Promise - promises; </li><li>  Request - sending HTTP requests to the server; </li><li>  RPC - is responsible for the logic of working with the server API; </li><li>  Model - model class; </li><li>  RPCModel - an extended model for working through RPC; </li><li>  Model.List - class for working with the list of models (collection). </li></ul><br>  Next thing is small: on what to build these components: <br><br><ul><li>  choose ready libraries / frameworks; </li><li>  write by yourself. </li></ul><br>  To answer this question, for myself, I formulated the following steps: <br><br><ol><li>  drawing up a list of ready-made solutions (even those that are not fully suitable); </li><li>  studying the list (about a week, then look at the code, support, tasks on github, if any, etc.); </li><li>  if the solution does not fit the task, we try to change the task (we go to the manager / designer, we offer an alternative, but not ‚Äúthis is impossible, all fools‚Äù); </li><li>  if nothing came up, are you ready ... (more on that later). </li></ol><br><br><h3>  Search for ready-made solutions </h3><br>  The first thing to start with is, of course, the definition of the requirements for a solution.  This should be a list of features required for a specific task (which you have already sorted out before), plus extensibility.  Do not engage in overengineering, since it will not lead to anything good, but will only confuse and lead you away from the goal. <br><br><img src="https://habrastorage.org/files/242/e55/390/242e553903154a10a4e53925af65122d.jpg"><br><br>  So, the first thing was to decide what to do with the models, on the basis of what to build them.  However, please note that the solution must have the following capabilities: <br><br><ul><li>  Dot notation - access to model properties through dot notation, for example, model.get ('foo.bar.baz'); </li><li>  Getters - access to properties without `get`, model.foo // {bar: {baz: true}}; </li><li>  Caching - the ability to recover data from localStorage or IndexedDB; </li><li>  Persist model - the integrity of the model. </li></ul><br>  As I said, touch-mail, as well as a number of other projects built on Backbone, is a good foundation that gives you Emitter, Model, Collection, Router and View.  This can cover all our needs. <br><br>  Everything rested only on the big mail, which was not Backbone, but those models that were, had a similar interface (get / set). <br><br><table><tbody><tr><th></th><th>  Backbone </th><th>  post office </th></tr><tr><td>  Depencies </td><td>  jQuery, undescore </td><td>  jQuery </td></tr><tr><td>  Dot notation </td><td>  - </td><td>  + </td></tr><tr><td>  Getters </td><td>  - </td><td>  + </td></tr><tr><td>  Caching </td><td>  - </td><td>  - </td></tr><tr><td>  Persist model </td><td>  - </td><td>  + </td></tr></tbody></table><br>  As you can see, it turned out that the basic capabilities that have a big mail, was not in Backbone.  But!  Backbone is a well-established tool, time-tested and has a huge community and active support, so almost any missing features can be covered with an extension that has long been written and tested. <br><br>  So the dot notation can be obtained by using: <br><br><ul><li>  <a href="https://github.com/afeld/backbone-nested">Backbone Nested</a> ; </li><li>  <a href="https://github.com/powmedia/backbone-deep-model">Backbone Deep Model</a> . </li></ul><br>  To implement getters there are <a href="https://github.com/asciidisco/Backbone.Mutators">https://github.com/asciidisco/Backbone.Mutators</a> (but only with get). <br><br>  And so on.  Alas, no matter how I searched, I could not find an extension to support the ‚Äúintegrity of the model‚Äù out of the box, when such an opportunity was the cornerstone of a large mail. <br><br><h3>  What is ‚Äúmodel integrity‚Äù? </h3><br>  Consider an example of receiving a letter: <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dfd = $.Deferred(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Backbone.Model({<span class="hljs-attr"><span class="hljs-attr">id</span></span>: id}); model.fetch({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: dfd.resolve, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: dfd.error }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dfd.promise(); } <span class="hljs-comment"><span class="hljs-comment">// -   #1 findOne(123).then(function (model) { model.on("change:flag", function () { //   console.log(model.get("flag")); }); }); // - #2 findOne(123).then(function (model) { model.set("flag", true); //     });</span></span></code> </pre> <br><br>  At first glance, the problem can be corrected by modifying, for example, the findOne method, so that it remembers the promise and returns it: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _promises = {}; <span class="hljs-comment"><span class="hljs-comment">//   //   function findOne(id) { if (_promises[id] === undefined) { var dfd = $.Deferred(); var model = new Backbone.Model({id: id}); model.fetch({ success: dfd.resolve, error: dfd.reject }); _promises[id] = dfd.promise(); } return _promises[id]; }</span></span></code> </pre><br><br>  But besides searching for models by id, there is also a list of models (collections).  And wherever I get a collection, it must consist of references to instances of the same models, to maintain integrity at any point in the application. <br><br>  Of course, this can be wound on top of Backbone, but the problem is not only this.  For example, after executing any collection method, we get an array on output. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     id var ids = collection .where({ flag: true }) .pluck("id"); // TypeError: undefined is not a function</span></span></code> </pre><br><br>  So in order for Backbone to do what we want, we need to: <br><br><ul><li>  <b>Dot notation</b> - connect the Nested / Deep Model or write it yourself; </li><li>  <b>Learning</b> - I did not find anything intelligible; </li><li>  <b>Persist model</b> - write by yourself. </li><li>  And also: logging, moki and other trifles </li></ul><br>  Even if it were possible to find some extensions that realize the necessary capabilities, I would not risk building anything on this hodgepodge - the likelihood of bugs and conflicts between these extensions, as well as a significant performance failure, is very high.  Such capabilities should be integrated into the core of the framework itself. <br><br><div class="spoiler">  <b class="spoiler_title">A little bit about logging</b> <div class="spoiler_text">  A long time ago we wanted to get high-quality logging, which could help the developer to follow the action from the beginning to the end.  In order for the log entries to have connections, not just an array, but most importantly, for the main functionality, logging should work out of the box <br><br>  Now our logger looks like this, let's look at an example: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    Folder.find({limit: 50}).then(function (folders) { logger.add('folders', {length: folders.length}); //   ¬´¬ª     return folders.filter({type: Folder.TYPE_SMAP})[0].save({name: 'Bulk'}); });</span></span></code> </pre><br><br>  And log output: <br><img src="https://habrastorage.org/files/3f1/62e/9fd/3f162e9fde09414c84bf90777db94d36.png"><br><br>  As you can see, the log turned out to be nested, and in addition, each entry is tied to a line of code, which allows you to view the log directly in the context of the code through specials.  interface (even if the code is minified): <br><br>  <a href="http://rubaxa.github.io/Error.stack/">rubaxa.github.io/Error.stack</a> <br><img src="https://habrastorage.org/files/6a7/990/506/6a79905067a043569d6ceda13b391d3b.png"><br></div></div><br><br>  Well, well, we will write the models ourselves.  Let's try to find at least solutions for other components.  (It was still possible to fork Backbone, such as <a href="https://parse.com/docs/js/guide">Parse.com</a> , and I even planned it, but the scope of our changes is comparable to the volume of the models themselves.) <br><br><h3>  Emitter </h3><br>  Going to github and setting the ‚Äú <a href="https://github.com/search%3Fo%3Ddesc%26q%3Devent%2Bemitter%26s%3Dstars%26type%3DRepositories%26utf8%3D%25E2%259C%2593">Event Emitter</a> ‚Äù, you will find the following libraries: <br><br><ul><li>  <a href="https://github.com/Olical/EventEmitter">EventEmitter</a> - 1,240 (stars) / 170 (forks) </li><li>  <a href="https://github.com/asyncly/EventEmitter2">EventEmitter2</a> - 1 <a href="https://github.com/asyncly/EventEmitter2">220/128</a> (as well as <a href="https://github.com/primus/eventemitter3">EventEmitter3</a> , which is also gaining popularity) </li><li>  <a href="">microevent</a> - <a href="">531/88</a> </li><li>  and <a href="https://github.com/search%3Fo%3Ddesc%26q%3Devent%2Bemitter%26s%3Dstars%26type%3DRepositories%26utf8%3D%25E2%259C%2593">others</a> </li></ul><br><table><tbody><tr><th></th><th>  on / off / emit </th><th>  tests </th><th>  handleEvent </th><th>  event object </th></tr><tr><td>  EventEmitter2 </td><td>  + </td><td>  + </td><td>  - </td><td>  - </td></tr><tr><td>  EventEmitter </td><td>  + </td><td>  + </td><td>  - </td><td>  - </td></tr><tr><td>  microevent </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><td>  jQuery </td><td>  + </td><td>  + </td><td>  - </td><td>  + </td></tr></tbody></table><br>  As you can see, none of them support such things as <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html">handleEvent</a> and the event object, and they are not very productive in speed.  But in general, are suitable and can be used as a turnkey solution. <br><br><h3>  Promise </h3><br><ul><li>  Native <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> + <a href="https://github.com/jakearchibald/es6-promise">Polyfil</a> ; </li><li>  <a href="https://api.jquery.com/category/deferred-object/">jQuery.Deferred;</a> </li><li>  <a href="https://github.com/kriskowal/q">Q</a> , <a href="https://github.com/cujojs/when">when</a> and others / </li></ul><br>  Q, when and others - not only promises, but also a car and a cart of different functional, but we need only promises.  So Native + polyfil are perfect if not for one big but: native promises are incompatible with jQuery (all because of <a href="">this</a> piece of code). <br><br><h3>  Request </h3><br>  Here is a boundless sea of ‚Äã‚Äãsolutions, which, all as one, are similar and do not have: <br><br><ul><li>  events (start, end, error, loss of WiFi authorization, etc.); </li><li>  timings (start and end time, duration of the request); </li><li>  error handling and result modification; </li><li>  retry request, for example, in case of an error. </li></ul><br>  The closest fit option is jQuery.ajax only. <br><br>  So, every solution we found for various reasons does not fit our requirements.  For example: <br><br><ul><li>  Emitter - does not support handleEvent and / or event object; </li><li>  Promise - incompatible with jQuery; </li><li>  Request is the closest analogue to jQuery. </li></ul><br>  Of course, you could take one of the solutions, cut yourself off by the possibilities and get involved in jQuery.  But these modules are not so voluminous, and the presence of jQuery did not inspire optimism. <br><br>  And at this moment we return to point number 4: If nothing has come up to you, then are you ready ... <br><br>  <b>Are you ready ...</b> <br><ol><li>  To write a common solution, and not to solve a narrow problem. </li><li>  Write tests and documentation. </li><li>  Maintain 7/24. </li><li>  Do it all for free. </li></ol><br>  The last point may seem strange to someone, but do not rush - in fact this is an important point.  In fact, it doesn‚Äôt matter to the business that you are under the hood - it is concerned about profit (I‚Äôm talking now in general), so if you insisted and even managed to seize the time for implementation, the support will be at your expense, and it will be honest - this was your choice, your decision.  Many people underestimate this point, and it seems to me that this is why the githab was filled with decisions whose support died the very next day.  You need to be ready for two or three tasks a week (and then a day), and what is the maximum for you will be thanked for what is already good (and this is not counting the bugs that will be, even with tests). <br><br>  So you have decided where to start?  The main thing is not to code!  You need to start with the project infrastructure. <br><br><h3>  Infrastructure </h3><br><ol><li>  Build <a href="http://gruntjs.com/">grunt</a> or <a href="http://gulpjs.com/">gulp</a> . </li><li>  Code style. </li><li>  Tests, control coatings and <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25BF%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">CI</a> . </li><li>  JS, CS, TS or ES6 / Babel. </li><li>  Automation of change control. </li><li>  Documenting code and documentation. </li><li>  Method of distribution (github, bitbucket, etc.). </li></ol><br>  Remember that each of the items solves a specific problem and outlines the rules that will guide users. <br><br>  <b>For us, I chose the following stack</b> : <br><br><ol><li>  <a href="http://gruntjs.com/">GruntJS</a> to build the project; </li><li>  <a href="http://jshint.com/">JSHint</a> and <a href="http://editorconfig.org/">.editconfig</a> - remove all questions and extra holivars about coding style or tab vs.  space, you can not argue with the robot; </li><li>  <a href="https://qunitjs.com/">QUnit</a> + <a href="https://github.com/gotwarlost/istanbul">Istanbul</a> - tests not only improve the quality of the product, but also speed up the development and refactoring process.  The coverage will provide an opportunity to see how well your tests cover the capabilities that you lay in the api.  As CI was <a href="https://travis-ci.org/">Travis</a> , now <a href="https://ru.atlassian.com/software/bamboo/">Bamboo</a> ; </li><li>  ES5 + Polyphils - one of the most important points.  <a href="http://www.typescriptlang.org/">TS</a> , <a href="http://coffeescript.org/">CS</a> or ES6 are not just technologies.  This choice will greatly influence the decision whether to use your decision by another developer or not; </li><li>  git pre-commit-hook (JSHint) + git pre-push-hook (QUnit + Istanbul) - automate what can be automated, as well as installing hooks via preinstall or postinstall in <a href="https://docs.npmjs.com/misc/scripts">package.json</a> ; </li><li>  <a href="https://github.com/jsdoc3/jsdoc">JSDoc3</a> - document and comment on the code, modern IDEs are able to build autocomplete by JSSDK, but the main thing is that another developer, having read the comment or parameter descriptions, will penetrate your code and its logic more quickly. </li></ol><br><br><h3>  Where does the developer start? </h3><br>  Comes on github and sees: <br><br><img src="https://habrastorage.org/files/a73/0c1/8df/a730c18df4614c3a90c4fe826f7a767c.png"><br><br>  As you can see, here are the steps that the developer needs to perform if he wants to use or develop the project. <br><br>  We proceed directly to the development. <br><br>  In JSSDK, each module is a separate folder containing four files.  For example, Model: <br><ul><li>  Model.js - module code; </li><li>  Model.tests.js - tests; </li><li>  Model.bench.js - performance tests (if needed); </li><li>  README.md - documentation (generated by JSDoc3). </li></ul><br>  As I already wrote, automate everything that can be automated.  Therefore, to create a module, we have a separate grunt task. <br><br>  So, for example, the creation of the mail.Folder model, which inherits the RPCModel, will look like: <br><pre> <code class="bash hljs">&gt; grunt model:create:mail/Folder:RPCModel   ¬´mail/Folder¬ª..OK  ¬´Folder¬ª  boot.js .. OK JSSDK/mail/Folder/Folder.js .. OK JSSDK/mail/Folder/Folder.test.js .. OK JSSDK/mail/Folder/Folder.bench.js .. OK JSSDK/mail/Folder/README.md .. OK</code> </pre><br><br>  When developing, first of all tests are written and only then the code.  After making changes or writing a new module, the most interesting part begins - commit and push: <br><br><img src="https://habrastorage.org/files/fb7/687/551/fb7687551e9b4136ab44e81a9489cd8c.png"><br><br>  <code>git commit -am"..."</code> - runs <code>grunt jshint</code> <br>  <code>git push original master</code> - <code> grunt test</code> <br><br>  If the task executes with an error, then commit or push will not work, it allows you to keep the code in the master always working.  Zavomit non-working code can only be in a branch other than master.  In any other thread, errors will simply be displayed.  Also, a push may not pass from a weak test coverage.  Weakly consider everything that is less than 100% (currently it is 1,635 assertions). <br><br><h3>  Test coverage </h3><br>  Coverage tests - not a panacea for all ills, it does not give a 100% guarantee of the absence of bugs.  The main thing that gives coverage is the ability to assess how much your tests affect all the possibilities, and sometimes allows you to rethink the final implementation of a particular piece of code. <br><br>  The developer starts <code>grunt dev-server</code> and sees the following picture: <br><br><img src="https://habrastorage.org/files/e86/84a/f4f/e8684af4f7c04535ac6c0708326a3dac.png"><br><br>  But the code itself and its coverage: <br><br><img src="https://habrastorage.org/files/095/3c9/f92/0953c9f92a904ed3ac9ad5db4bdcc147.png"><br><br><h3>  Documentation </h3><br>  The final touch is the generation of documentation.  For this we use the official JSDoc3 and our publisher (in fact, npm is full of similar solutions).  The final documentation exists in two forms, it is: <br><ul><li>  README.md; </li><li>  <a href="http://127.0.0.1/">127.0.0.1</a> : 1625 / - dev-server with documentation. </li></ul><br><br>  This is what the module's README.md looks like: <br><img src="https://habrastorage.org/files/4b1/3c5/79b/4b13c579b18b4c709f6b8e1c8e63a09f.png"><br><br><img src="https://habrastorage.org/files/025/ffc/fa9/025ffcfa960c4bafb9d99b6a5fed84dd.png"><br><br>  Here we immediately see examples and descriptions of methods, as well as references to impurities.  Each item can be given a link, in addition, by clicking on the name of the method, you can quickly go to the code. <br><br>  README.md is convenient because it can be viewed from anywhere, without any additional effort.  But for everyday use, there is also a web interface for viewing documentation that can be picked up locally.  It looks like this: <br><br><img src="https://habrastorage.org/files/60e/3ab/f0e/60e3abf0eb9641a398d835578c0e3db4.png"><br><br><img src="https://habrastorage.org/files/e56/927/859/e569278595464301ab3e69297dddbee8.png"><br><br>  All content is based on md-files, so it is also always relevant.  But the most important thing is a one-page application that has a kind of fuzzy search, which allows you to quickly switch to the desired method. <br><br><img src="https://habrastorage.org/files/6c2/eb4/a68/6c2eb4a68d4242eaaf170cac65c2976b.png"><br><br>  The main thing is that all this not only does not slow down the development process, but also helps a lot.  There is an opinion that tests and documentation take time.  Sometimes it seems to me that those who have not tried to write them say so.  But let's not talk about it.  Personally, they allowed me to not only improve the quality of the code, but also significantly reduce development time.  The second common myth is that comments are not needed by the code, since the code must be expressive and speak for itself ... Yes, that's right, but in most cases it is simpler and, most importantly, faster to read like a human being than to build an interpreter. <br><br>  In conclusion, I will say it again: always look for a ready-made solution!  If nothing good is found, think about how to change the task.  If you decide to write from scratch - do everything possible so that the decision could live without your participation.  And most importantly - write tools, not bicycles.  Test and document!  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/271689/">https://habr.com/ru/post/271689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271679/index.html">What's new in the field of data storage</a></li>
<li><a href="../271681/index.html">Young hackers 414s</a></li>
<li><a href="../271683/index.html">Come November 26th to Visual Studio Workshop</a></li>
<li><a href="../271685/index.html">Spreadsheets under the hood</a></li>
<li><a href="../271687/index.html">Httplug - abstraction from HTTP client for PHP</a></li>
<li><a href="../271693/index.html">We write software for generating music card data. Part one: parse the MIDI file</a></li>
<li><a href="../271695/index.html">Developer Economics Tenth Study</a></li>
<li><a href="../271697/index.html">Machine Learning Hackathon: Come. To train a model. To win</a></li>
<li><a href="../271699/index.html">Professional test on the knowledge of the realities of the market for customized development and digital communications</a></li>
<li><a href="../271701/index.html">Design prototypes of cells in the same XIB with UITableView</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>