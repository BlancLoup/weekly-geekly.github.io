<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenOffice Automation: The Beginning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At work, I needed to develop a mechanism for loading and unloading data from Excel using free mechanisms working under different operating systems. 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenOffice Automation: The Beginning</h1><div class="post__text post__text-html js-mediator-article">  At work, I needed to develop a mechanism for loading and unloading data from Excel using free mechanisms working under different operating systems. <br>  Because  it was necessary for the service to work under Linux, the interaction mechanism through OLE did not fit. <br>  OpenOffice was chosen for implementation with direct access to the API via C ++. <br><br><img src="https://habrastorage.org/storage/f6c1a872/981b959c/3f62b3f0/a7637cdf.png" alt="Open Office api on Linux"><br><br>  The documentation turned out to be very scarce, and there were almost no examples of work through OLE.  So I decided to combine all my research in one article on Habr√©. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Approximate plan of the article:</b> <br>  1. Getting started with the OpenOffice API via C ++ <br>  1.1.  Header generation <br>  1.2.  Generating an RDB Type File <br>  1.3.  Visual Studio 2008 Setup <br>  1.4.  We collect dynamic DLL <br>  2. Reuse DLL in your program <br>  2.1.  An example of a small program for uploading data <br><br>  In principle, if the capabilities of the DLL are sufficient, then repeating the actions of p. 1 is not necessary. <br><br><a name="habracut"></a><br><h4>  1. Getting started with the OpenOffice API via C ++ </h4><br>  This section is described in some detail in the office wiki: <a href="http://wiki.services.openoffice.org/wiki/SDKInstallation">wiki.services.openoffice.org/wiki/SDKInstallation</a> . <br><br>  To get started with the API, you need to download the SDK from the <a href="http://download.services.openoffice.org/files/stable/">download.services.openoffice.org/files/stable</a> address.  It is important that the SDK version matches the version of the installed office. <br>  Install the SDK in any directory. <br>  Install auxiliary utilities gnu make, zip (if necessary) <br><br><h5>  1.1.  Header generation </h5><br>  Inside the directory with the SDK, there should be a setsdkenv_windows.bat batch file that generates another batch file. <br>  We carry it out by answering questions. <br>  A batch file will be generated with the settings of environment variables. <br>  We open the console, execute the generated batch file, and in the same prepared console we generate header files for a specific office version. <br><br>  <i>Generation Team:</i> <br> <code>cppumaker -Gc -BUCR -O "c:\Program Files\OpenOffice_SDK\sdk\inludecpp" "c:\Program Files\OpenOffice.org 3\URE\misc\types.rdb" "c:\Program Files\OpenOffice.org 3\Basis\program\offapi.rdb" <br></code> <br>  where <br>  c: \ Program Files \ OpenOffice_SDK \ sdk \ inludecpp - the folder where we will generate <br>  c: \ Program Files \ OpenOffice.org 3 \ - path to the office <br><br><h5>  1.2.  Generate RDB file types. </h5><br>  Also, to get started, you need to generate an RDB file specifically for your office version. <br>  An RDB file is something like a file with descriptions of the types and interfaces of a particular version of OpenOffice. <br><br>  <i>This is done by the command:</i> <br> <code>"C:\Program Files\OpenOffice.org 3\URE\bin\regmerge" "d:\oo\OOAPI\Debug\OOAPI.rdb" / "c:\Program Files\OpenOffice.org 3\URE\misc\types.rdb" <br></code> <br>  where C: \ Program Files \ OpenOffice.org 3 \ is the path to the office <br>  d: \ oo \ OOAPI \ Debug \ - the path where the file will be generated <br><br>  <i>After that we register it with the commands:</i> <br> <code>"C:\Program Files\OpenOffice.org 3\URE\bin\regcomp" -register -r "d:\oo\OOAPI\Debug\OOAPI.rdb" -c connector.uno.dll <br> "C:\Program Files\OpenOffice.org 3\URE\bin\regcomp" -register -r "d:\oo\OOAPI\Debug\OOAPI.rdb" -c remotebridge.uno.dll <br> "C:\Program Files\OpenOffice.org 3\URE\bin\regcomp" -register -r "d:\oo\OOAPI\Debug\OOAPI.rdb" -c bridgefac.uno.dll <br> "C:\Program Files\OpenOffice.org 3\URE\bin\regcomp" -register -r "d:\oo\OOAPI\Debug\OOAPI.rdb" -c uuresolver.uno.dll <br></code> <br><br><h5>  1.3.  Visual Studio 2008 Setup </h5><br>  We connect heading files and: <br><br>  Tools -&gt; Options-&gt; Projects-&gt; VC ++ Directories -&gt; Include Files <br>  Add the folder with the generated header files: &lt;oo_sdk_path&gt; \ inludecpp <br>  Tools -&gt; Options-&gt; Projects-&gt; VC ++ Directories -&gt; Library files <br>  add &lt;oo_sdk_path&gt; \ lib directory <br><br>  Tools -&gt; Options-&gt; Projects-&gt; VC ++ Directories -&gt; Executable files <br>  add &lt;office_programm_dir&gt; \ program directory <br><br>  Project properties: <br>  Change the configuration to "All Configurations" <br>  Add extras <br>  Properties-&gt; Linker-&gt; ComandLine in Additional Options <br>  add if: <br>  isal.lib icppu.lib icppuhelper.lib isal.lib isalhelper.lib ireg.lib irmcxt.lib stlport_vc71.lib <br><br>  Everything is ready to create console programs for working with the office. <br><br><h5>  1.4.  We collect dynamic DLL </h5><br>  Many useful examples can be found here: <a href="http://wiki.services.openoffice.org/wiki/Calc/API/Programming">wiki.services.openoffice.org/wiki/Calc/API/Programming</a> <br><br>  The work plan of the DLL is like this: <br>  - When the program starts, we check the presence of the RDB file, if it is not there, then it is generated. <br>  <i>Functions connect, genRdb</i> <br>  If there are no administrator rights on the computer, then it is better to generate the RDB in advance for the standard office version. <br>  - We start the OpenOffice server, set the port for listening to it <br>  <i>startServer, the address of the office server is obtained from the registry by the getOOPath function</i> <br>  - The program connects to the server office <br>  - a new office frame is created: a new file or an xls file is imported. <br>  - After that, you can send commands to manage the content <br>  - export xls file to disk <br>  <i>exportToUrl function</i> <br>  - the reverse mechanism is also possible: imls xls file and reading data from it <br>  <i>functions getVal, getText</i> <br><br>  I am attaching the DLL code, I hope comments will be enough.  The full project can be downloaded <a href="http://narod.ru/disk/8667253001/OOAPI3.zip.html">here</a> . <br><br>  <i>ooapi.h:</i> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    #define OOAPI3 __declspec(dllexport) #define WNT 1 #include &lt;stdio.h&gt; #include &lt;wchar.h&gt; #include &lt;sal/main.h&gt; #include &lt;cppuhelper/bootstrap.hxx&gt; #include &lt;osl/file.hxx&gt; #include &lt;osl/process.h&gt; // ,    #include &lt;com/sun/star/beans/XPropertySet.hpp&gt; #include &lt;com/sun/star/bridge/XUnoUrlResolver.hpp&gt; #include &lt;com/sun/star/frame/XComponentLoader.hpp&gt; #include &lt;com/sun/star/lang/XMultiComponentFactory.hpp&gt; #include &lt;com/sun/star/registry/XSimpleRegistry.hpp&gt; #include &lt;com/sun/star/sheet/XSpreadsheetDocument.hpp&gt; #include &lt;com/sun/star/sheet/XSpreadsheet.hpp&gt; #include &lt;com/sun/star/container/XIndexAccess.hpp&gt; #include &lt;com/sun/star/table/XCellRange.hpp&gt; #include &lt;com/sun/star/table/BorderLine.hpp&gt; #include &lt;com/sun/star/table/CellHoriJustify.hpp&gt; #include &lt;com/sun/star/table/XColumnRowRange.hpp&gt; #include &lt;com/sun/star/table/XMergeableCell.hpp&gt; #include &lt;com/sun/star/table/XMergeableCellRange.hpp&gt; #include &lt;com/sun/star/table/TableBorder.hpp&gt; #include &lt;com/sun/star/beans/XPropertySet.hpp&gt; #include &lt;com/sun/star/frame/XStorable.hpp&gt; #include &lt;com/sun/star/util/XMergeable.hpp&gt; #include &lt;string&gt; #include &lt;locale&gt; #include &lt;io.h&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; using namespace rtl; using namespace std; using namespace com::sun::star::uno; using namespace com::sun::star::lang; using namespace com::sun::star::beans; using namespace com::sun::star::bridge; using namespace com::sun::star::frame; using namespace com::sun::star::registry; using namespace com::sun::star::sheet; using namespace com::sun::star::table; using namespace com::sun::star::container; using namespace com::sun::star::util; //  OOAPI3 bool connect(const char *file, bool hidden); OOAPI3 void disconnect(); OOAPI3 bool selectSheet(short sheet); OOAPI3 void setVal(int, int, double); OOAPI3 void setText(int x, int y, const wchar_t *text); OOAPI3 bool setBold(int x, int y); OOAPI3 bool setFontColor(int x, int y, int r, int g, int b); OOAPI3 bool setBgColor(int x, int y, int r, int g, int b); OOAPI3 bool setFontSize(int x, int y, short size); OOAPI3 bool setItalic(int x, int y); OOAPI3 bool setHoriz(int x, int y, short hor); OOAPI3 bool setBorders(int x, int y, bool lft, bool tp, bool rt, bool dn, short r, short g, short b); OOAPI3 bool setColWidth(int col, long width); OOAPI3 bool mergeRange(const char *range); OOAPI3 bool exportToUrl(const wchar_t *url); OOAPI3 double getVal(int x, int y); OOAPI3 wchar_t* getText(int x, int y); OOAPI3 bool isWin(); OOAPI3 bool isInstall();</span></span></code> </pre><br><br>  <i>ooapi.cpp:</i> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  wine, ,     bool isWin() { // wine #ifdef ISWIN return ISWIN; #endif HMODULE h = LoadLibrary(L"ntdll.dll"); bool win = (h != NULL); if(h != NULL) { win = GetProcAddress(h, "wine_get_version") == NULL; FreeLibrary(h); } #define ISWIN win printf("module load on win: %u\n", win); return win; } //    ,     string getOOPath() { //   ,        #ifdef OOPATH return OOPATH; #endif string path; //     HKEY hKey = NULL; wchar_t * buf = NULL; ULONG dim = 0; RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\opendocument.CalcDocument.1\\protocol\\StdFileEditing\\server"), 0, KEY_ALL_ACCESS, &amp;hKey ); RegQueryValueEx(hKey, TEXT(""), NULL, NULL, NULL, &amp;dim); buf = new wchar_t[dim + 1]; RegQueryValueEx(hKey, TEXT(""), NULL, NULL, (UCHAR*)buf, &amp;dim); RegCloseKey(hKey); // unicode  string wstring upath(buf); ostringstream stm ; const ctype&lt;char&gt;&amp; ctfacet = use_facet&lt; ctype&lt;char&gt; &gt;( stm.getloc() ) ; for( size_t i=0 ; i &lt; upath.size() ; ++i ) stm &lt;&lt; ctfacet.narrow( upath[i], 0 ) ; path = stm.str(); delete buf; if(path == "") return ""; // ,     path = path.substr(0, path.length()-20); printf("server path: %s\n", path.c_str()); #define OOPATH path return path; } //  void createProcess(string app) { STARTUPINFO StartupInfo; ZeroMemory(&amp;StartupInfo,sizeof(StartupInfo)); StartupInfo.cb = sizeof(StartupInfo); StartupInfo.dwFlags = STARTF_USESHOWWINDOW; StartupInfo.wShowWindow = SW_MAXIMIZE; PROCESS_INFORMATION ProcessInfo; // //      wine,    RDB    int len = lstrlenA(app.c_str()); BSTR utext = SysAllocStringLen(NULL, len); ::MultiByteToWideChar(CP_ACP, 0, app.c_str(), len, utext, len); ::SysFreeString(utext); //  if (CreateProcess(NULL, utext,NULL,NULL,false,CREATE_NO_WINDOW|NORMAL_PRIORITY_CLASS, NULL,NULL,&amp;StartupInfo,&amp;ProcessInfo)) { if (ProcessInfo.hProcess != NULL) { //,     while (WaitForSingleObject(ProcessInfo.hProcess,200) == WAIT_TIMEOUT) { Sleep(100); } } } } //  RDB   void genRDB() { string rdb = "OOAPI.rdb"; if(access("OOAPI.rdb",0) != -1) { //rdb   return; } printf("generate RDB\n"); //    wine // RDB  string oopath = getOOPath(); string oogen = "\"" + oopath + "\\URE\\bin\\regmerge\" \"" + rdb + "\" / \"" + oopath + "\\URE\\misc\\types.rdb\" \"" + oopath + "\\Basis\\program\\offapi.rdb\""; createProcess(oogen); // string regpath; regpath = "\"" + oopath + "\\URE\\bin\\regcomp\" -register -r \"" + rdb + "\" -c connector.uno.dll"; createProcess(regpath); regpath = "\"" + oopath + "\\URE\\bin\\regcomp\" -register -r \"" + rdb + "\" -c remotebridge.uno.dll"; createProcess(regpath); regpath = "\"" + oopath + "\\URE\\bin\\regcomp\" -register -r \"" + rdb + "\" -c bridgefac.uno.dll"; createProcess(regpath); regpath = "\"" + oopath + "\\URE\\bin\\regcomp\" -register -r \"" + rdb + "\" -c uuresolver.uno.dll"; createProcess(regpath); } //  ,      ,   -  :) bool isInstall() { return getOOPath() != ""; } // ,      void startServer() { string server_path; server_path = "\"" + getOOPath() + "\\program\\soffice\" \"-accept=socket,host=localhost,port=2083;urp;StarOffice.ServiceManager\""; //createProcess(server_path); //  WinExec(server_path.c_str(), SW_HIDE); } //#########   // Reference&lt; XComponent &gt; xComponent; //  Any rSheet; Reference&lt; XMultiComponentFactory &gt; xMultiComponentFactoryClient_copy; //  ,        bool connect(const char *file, bool hidden) { //    SAL_IMPLEMENT_MAIN_WITH_ARGS //  sal_main() sal_detail_initialize(NULL, NULL); //  ,     OUString sConnectionString(RTL_CONSTASCII_USTRINGPARAM("uno:socket,host=localhost,port=2083;urp;StarOffice.ServiceManager")); //  OUString sFileString = OUString::createFromAscii(file); //     genRDB(); //   startServer(); printf("init server start OK\n"); // RDB  Reference&lt; XSimpleRegistry &gt; xSimpleRegistry(::cppu::createSimpleRegistry() ); xSimpleRegistry-&gt;open( OUString( RTL_CONSTASCII_USTRINGPARAM( "OOAPI.rdb") ), sal_True, sal_False ); printf("init rdb OK\n"); //-  , //           UNO  open office Reference&lt; XComponentContext &gt; xComponentContext(::cppu::bootstrap_InitialComponentContext( xSimpleRegistry ) ); Reference&lt; XMultiComponentFactory &gt; xMultiComponentFactoryClient( xComponentContext-&gt;getServiceManager() ); xMultiComponentFactoryClient_copy = xMultiComponentFactoryClient; Reference&lt; XInterface &gt; xInterface = xMultiComponentFactoryClient-&gt;createInstanceWithContext( OUString::createFromAscii( "com.sun.star.bridge.UnoUrlResolver" ), xComponentContext ); Reference&lt; XUnoUrlResolver &gt; resolver( xInterface, UNO_QUERY ); printf("init OK\n"); // ,       -     int i = 200; while(i &gt; 0) { try { Sleep(300); xInterface = Reference&lt; XInterface &gt;( resolver-&gt;resolve( sConnectionString ), UNO_QUERY ); i = 0; } catch ( Exception&amp; e ) { i--; if(i == 0) { //    printf("can not connect to server FAIL\n"); return false; } } } printf("connect to server OK\n"); Reference&lt; XPropertySet &gt; xPropSet( xInterface, UNO_QUERY ); xPropSet-&gt;getPropertyValue( OUString::createFromAscii("DefaultContext") ) &gt;&gt;= xComponentContext; Reference&lt; XMultiComponentFactory &gt; xMultiComponentFactoryServer( xComponentContext-&gt;getServiceManager() ); Reference &lt; XComponentLoader &gt; xComponentLoader( xMultiComponentFactoryServer-&gt;createInstanceWithContext( OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.frame.Desktop" ) ), xComponentContext ), UNO_QUERY ); printf("before create OK\n"); string fl = file; if(fl.find(".xls") != string::npos) { // xls  Sequence&lt;PropertyValue&gt; props(2); props[0].Name = OUString::createFromAscii( "FilterName" ); props[0].Value &lt;&lt;= OUString::createFromAscii( "MS Excel 97" ); // wine ,     if(hidden) { props[1].Name = OUString::createFromAscii( "Hidden" ); props[1].Value &lt;&lt;= hidden; } xComponent = xComponentLoader-&gt;loadComponentFromURL(sFileString, OUString( RTL_CONSTASCII_USTRINGPARAM("_blank") ), 0, props); } else { //         Sequence&lt;PropertyValue&gt; props(1); if(hidden) { props[0].Name = OUString::createFromAscii( "Hidden" ); props[0].Value &lt;&lt;= hidden; } //   xComponent = xComponentLoader-&gt;loadComponentFromURL(sFileString, OUString( RTL_CONSTASCII_USTRINGPARAM("_blank") ), 0, props); } printf("create oocalc OK\n"); return true; } //   bool selectSheet(short sheet) { //  Reference&lt; XSpreadsheetDocument &gt; rSheetDoc (xComponent, UNO_QUERY); Reference&lt; XSpreadsheets &gt; rSheets = rSheetDoc-&gt;getSheets(); //    Reference&lt; XIndexAccess &gt; rSheetsByIndex (rSheets, UNO_QUERY); try { rSheet = rSheetsByIndex-&gt;getByIndex( (short)sheet ); } catch( Exception &amp;e ) { disconnect(); return false; } return true; } //   void setVal(int x, int y, double val) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); //   Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); //   rCell-&gt;setValue(val); } //    void setText(int x, int y, const wchar_t *text) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); rCell-&gt;setFormula(OUString::OUString(text)); } //    bool setBold(int x, int y) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); try { Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); Any mPropVal; mPropVal &lt;&lt;= makeAny((short)150); rCellProps-&gt;setPropertyValue(OUString::createFromAscii("CharWeight"), mPropVal); return true; } catch( Exception &amp;e ) { return false; } } //  bool setItalic(int x, int y) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); try { Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); Any mPropVal4; mPropVal4 &lt;&lt;= makeAny((short)2); rCellProps-&gt;setPropertyValue(OUString::createFromAscii("CharPosture"), mPropVal4); return true; } catch( Exception &amp;e ) { return false; } } //   bool setFontColor(int x, int y, int r, int g, int b) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); try { Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); Any mPropVal1; mPropVal1 &lt;&lt;= makeAny(RGB(b,g,r)); rCellProps-&gt;setPropertyValue(OUString::createFromAscii("CharColor"), mPropVal1); return true; } catch( Exception &amp;e ) { return false; } } //   bool setBgColor(int x, int y, int r, int g, int b) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); try { Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); Any mPropVal1; mPropVal1 &lt;&lt;= makeAny(RGB(b,g,r)); rCellProps-&gt;setPropertyValue(OUString::createFromAscii("CellBackColor"), mPropVal1); return true; } catch( Exception &amp;e ) { return false; } } //   bool setFontSize(int x, int y, short size) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); try { Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); Any mPropVal3; mPropVal3 &lt;&lt;= makeAny((short)size); rCellProps-&gt;setPropertyValue(OUString::createFromAscii("CharHeight"), mPropVal3); return true; } catch( Exception &amp;e ) { return false; } } //    bool setHoriz(int x, int y, short hor) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); try { Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); Any mPropVal5; mPropVal5 &lt;&lt;= makeAny((short)hor); rCellProps-&gt;setPropertyValue(OUString::createFromAscii("HoriJustify"), mPropVal5); return true; } catch( Exception &amp;e ) { return false; } } //    bool setBorders(int x, int y, bool lft, bool tp, bool rt, bool dn, short r, short g, short b) { try { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); Reference&lt; XPropertySet &gt; rCellProps (rCell, UNO_QUERY); BorderLine bl; bl.Color = RGB(b,g,r); //rgb   ? bl.OuterLineWidth = 10; TableBorder b; if(lft) b.LeftLine = bl; if(tp) b.TopLine = bl; if(rt) b.RightLine = bl; if(dn) b.BottomLine = bl; b.VerticalLine = b.HorizontalLine = bl; b.IsVerticalLineValid = true; b.IsHorizontalLineValid = true; b.IsLeftLineValid = lft; b.IsRightLineValid = rt; b.IsTopLineValid = tp; b.IsBottomLineValid = dn; rCellProps-&gt;setPropertyValue(OUString::createFromAscii("TableBorder"),makeAny(b)); return true; } catch( Exception &amp;e ) { return false; } } //     bool setColWidth(int col, long width) { try { Reference&lt; XColumnRowRange &gt; rSheetColRange (rSheet, UNO_QUERY); Reference&lt; XTableColumns &gt; rSheetColumns = rSheetColRange-&gt;getColumns(); Any rCol = rSheetColumns-&gt;getByIndex(col); Reference&lt; XPropertySet &gt; rColProps (rCol, UNO_QUERY); rColProps-&gt;setPropertyValue(OUString::createFromAscii("Width"),makeAny(width*100)); return true; } catch( Exception &amp;e ) { return false; } } //  bool mergeRange(const char *range) { try { Reference&lt; XCellRange &gt; rSheetCellRange (rSheet, UNO_QUERY); Reference&lt; XCellRange&gt; rCellRange = rSheetCellRange-&gt;getCellRangeByName(OUString::createFromAscii(range)); Reference&lt; XMergeable &gt; rSheetCellMerge (rCellRange, UNO_QUERY); rSheetCellMerge-&gt;merge(true); return true; } catch( Exception &amp;e ) { return false; } } // xls    bool exportToUrl(const wchar_t *url) { try { Reference&lt;XStorable&gt; xStore (xComponent, UNO_QUERY); Sequence&lt;PropertyValue&gt; storeProps(1); storeProps[0].Name = OUString::createFromAscii( "FilterName" ); storeProps[0].Value &lt;&lt;= OUString::createFromAscii( "MS Excel 97" ); xStore-&gt;storeToURL( OUString::OUString(url), storeProps ); return true; } catch( Exception &amp;e ) { return false; } } //    double getVal(int x, int y) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); return rCell-&gt;getValue(); } //    () wchar_t* getText(int x, int y) { Reference&lt; XSpreadsheet &gt; rSpSheet (rSheet, UNO_QUERY); Reference&lt; XCell &gt; rCell = rSpSheet-&gt;getCellByPosition(x, y); OUString buf = rCell-&gt;getFormula(); return buf.pData-&gt;buffer; } // void disconnect() { Reference&lt; XComponent &gt;::query( xMultiComponentFactoryClient_copy )-&gt;dispose(); sal_detail_deinitialize(); }</span></span></span></span></code> </pre><br><br>  <a href="https://habr.com/blogs/cpp/116228/">Final chat: use a DLL to load and unload into Excel.</a> </div><p>Source: <a href="https://habr.com/ru/post/116151/">https://habr.com/ru/post/116151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116142/index.html">Accelerate Website Database</a></li>
<li><a href="../116145/index.html">Property again</a></li>
<li><a href="../116147/index.html">Qt Creator 2.2 Beta Released</a></li>
<li><a href="../116148/index.html">YouTube Create, or talking robots</a></li>
<li><a href="../116150/index.html">The Open Networking Foundation has been created</a></li>
<li><a href="../116153/index.html">Zenith - A Film by Anonymous</a></li>
<li><a href="../116155/index.html">Site about browsers from Yandex and how you can use it</a></li>
<li><a href="../116157/index.html">Nortel sells its IPv4 address range</a></li>
<li><a href="../116158/index.html">500+ fatalities in 115 minutes</a></li>
<li><a href="../116160/index.html">JBFD: Brainfuck to Java decompiler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>