<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why your first FizzBuzz implementation on Rust may not work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The full original title of the article : "Although you might not like it)" 

 tl; dr; -version : At first glance, some aspects of Rust may seem strang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why your first FizzBuzz implementation on Rust may not work</h1><div class="post__text post__text-html js-mediator-article">  <b>The full original title of the article</b> : "Although you might not like it)" <br><br>  <b>tl; dr; -version</b> : At first glance, some aspects of Rust may seem strange and even uncomfortable, however, they turn out to be very successful for a language that is positioned as a system language.  The concepts of ownership and lifetime make it possible to bring strong static guarantees into the language and make the programs effective and safe both in memory and in time. <br><br>  <b>License</b> : <a href="http://creativecommons.org/licenses/by/3.0/">CC-BY</a> by <a href="http://chrismorgan.info/">Chris Morgan</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Why your first FizzBuzz implementation may not work: exploring some of the features of Rust that initially shock, but in fact are its best sides (although you may still not like them) </h1><img align="right" src="http://chrismorgan.info/media/images/rust-fizzbuzz.svg" alt="http://chrismorgan.info/media/images/rust-fizzbuzz.svg">  FizzBuzz is supposed to be a simple task for a beginner, but in Rust there are several pitfalls that you should know about.  These pitfalls are not Rust problems, but rather differences from what most programmers are familiar with, restrictions that may seem very tough at first glance, but in reality they give huge advantages at a low price. <br><br>  <em>Rust is a "moving target", however, the language becomes more stable.</em>  <em>The code from the article works with version 0.12.</em>  <em>If something breaks, please <a href="http://chrismorgan.info/">contact me</a> .</em>  <em>Regarding the code in Python, it will work in both deuce and triple.</em> <br><a name="habracut"></a><br><h2>  Simple implementation </h2><br>  Ok, I said in the title that your first implementation of FizzBuzz might not work, well, it may work.  You could write it as in the example below.  For brevity, omit <code>fn main() { ‚Ä¶ }</code> .  If you are worried that the Python code is shorter than Rust, then there is a special form of Python code for you, it is available by clicking on the checkbox.  ( <i>Note: in the original article there is a checkbox that switches the Python code into a ‚Äúspecial form‚Äù <code>from __future__ import braces</code> , something like Easter eggs from the author</i> ). <table><caption>  Implementing FizzBuzz with separate <code>print</code> instructions: everything just works. </caption><tbody><tr><th>  Python </th><th>  Rusty </th></tr><tr><td><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">'FizzBuzz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Buzz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Fizz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(i)</code> </pre><br></td><td><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, i); } }</code> </pre><br></td></tr></tbody></table><br>  Both programs produce the desired result, and they are obviously very similar.  The main thing that is worth mentioning here is that in Rust <code>println!()</code> <sup><a href="https://habr.com/ru/post/240617/">[1]</a></sup> requires a string literal as the first argument, a format string;  the corresponding Python code will look like this: <code>print('{}'.format(i))</code> . <br><br>  But what if we want to get rid of the duplication of the <code>print</code> call in the code?  Here‚Äôs how it might look: <table><caption>  FizzBuzz with one <code>print</code> instruction. </caption><tbody><tr><th>  Python </th><th>  Rust (will not compile) </th></tr><tr><td><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: result = <span class="hljs-string"><span class="hljs-string">'FizzBuzz'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: result = <span class="hljs-string"><span class="hljs-string">'Buzz'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: result = <span class="hljs-string"><span class="hljs-string">'Fizz'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result = i print(result)</code> </pre><br></td><td><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, result); }</code> </pre><br></td></tr></tbody></table><br><blockquote>  Notice how in Rust we can use the whole <code>if</code> block as an expression.  Even the result of the assignment is not really needed, we could just shove the entire block into the construct where it is used.  This is a very familiar approach for rubists, but not for pythonists, because in Python everything is an instruction, not an expression.  If you are skeptical of this approach, I understand;  when I started to get acquainted with Rust, his bias in expressions and the ability to omit the <code>return</code> instruction seemed to me wonderful.  But using Rust, I realized that this was not the case.  Actually it's great. <br><br>  Python was my favorite language for five years, but despite the fact that I continue to write professionally in this language (although I would like to switch to Rust), I discovered that I‚Äôve increasingly lacked chips from Rust.  When working with Rust, I don‚Äôt feel the same lack of anything from Python, apart from the need for libraries that are not yet in Rust.  In general, Rust has greatly degraded Python in my eyes. <br></blockquote><br>  The code on Rust looks good, but in reality it does not work because of the strict typing rules in this language.  So what is the type of the <code>result</code> variable?  The first three <code>if</code> branches return strings, and the fourth, an integer: <br><br><pre> f.rs:7:12: 11: 6 error: if and then have incompatible types: expected `&amp; 'static str`, found` int` (expected &amp; -ptr, found int)
 f.rs:7} else if i% 3 == 0 {
 f.rs:8 "Fizz"
 f.rs:9} else {
 f.rs:10 i
 f.rs:11};
 error: aborting due to previous error
</pre><br>  This does not work.  How about turning a number into a string? <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i.to_string() }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, result); }</code> </pre><br>  Here we drew off the chip, which many are familiar with from other programming languages ‚Äã‚Äã( <code>to_string</code> ) and applied it in a field that not many people understand.  In general, this does not work. <br><br><pre>  f.rs:7:12: 11: 6 error: if and else have incompatible types: expected `static str`, found` collections :: string :: String` (expected &amp; -ptr, found struct collections :: string :: String)
 f.rs:7} else if i% 3 == 0 {
 f.rs:8 "Fizz"
 f.rs:9} else {
 f.rs:10 i.to_string ()
 f.rs:11};
 error: aborting due to previous error
</pre><br>  ‚ÄúWhat?‚Äù I can hear you say, ‚Äúaren't they all lines now?  What's the deal with this <code>&amp;'static str</code> (yes how the hell do you even say it?) And <code>collections::string::String</code> ? ‚Äù.  At this stage, we need to take a more careful approach to analyzing the types of values ‚Äã‚Äãproduced by the branches: the first three branches do not produce just some kind of "string", they produce <code>&amp;'static str</code> , and the fourth branch does not produce just "whole", and <code>int</code> .  In languages ‚Äã‚Äãlike Python, Ruby and JavaScript, the types of integers are combined (and JS went even further, and completely combined all numeric types), while C #, Java, Go have many types of integers that differ in size.  But even languages ‚Äã‚Äãlike C #, Java, Go have only one type for a string. <br><br>  And Rust is not.  He has two of them. <br><br><h2>  Two types of strings?  What is this anyway? </h2><br>  Here we could restrict ourselves to a simple explanation and go further, but since we went down so deeply, why not go down to the end, and understand <i>what</i> was done and why it was absolutely worth it.  So why C‚ôØ, Java and Go could be satisfied with one string type, but Rust did not?  To answer this question we must descend to the level of memory management. <br><br>  Both C‚ôØ, Java and Go are all <i>managed languages</i> <sup><a href="https://habr.com/ru/post/240617/">[2]</a></sup> (also known as <i>garbage collection</i> languages).  That is, they have a mechanism in runtime that manages the allocation and freeing of memory at the appropriate time: when no one else uses the string, it can be specially born.  Thus, they can return a link to a string without worrying about its lifetime: strings that are still in use will not be singled out. <br><br>  There is also one assignment for these languages.  As a rule, they have immutable (immutable) lines - if you concatenate two lines, memory allocation (allocation) for a new line of the desired size will occur.  (This also means that for a solution that will concatenate Fizz and Buzz in appropriate cases, there will be two allocations for numbers divisible by 15. True, some languages ‚Äã‚Äãmay slightly smooth out this negative effect by applying what is called a <i><a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2583%25D0%25BB%2520%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA">string pool</a></i> or <i>internment</i> The success of this mechanism depends on the optimizer and how the code is written. I suppose the lines are immutable because, as an alternative, we will have more of the evils - changing the line may affect other lines depending on it.  This strongly beats the correctness of the program and can lead to <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5%2520%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25BA%25D0%25B8">race conditions</a> in what is essentially a primitive type. <br>  Also, for unicode strings, this can lead to the appearance of incorrect line slices.  Of course, these problems also arise in other places, but having them in lines can be much worse.  (I said that these languages ‚Äã‚Äãhave the same string type, but this is not quite the case - there are also specialized string types, for example, both Java and .NET have a mechanism called <code>StringBuilder</code> ). <br><br>  The Rust model differs from the one used in garbage collection languages ‚Äã‚Äãand is based on the concept of ownership.  In this model, each object has one owner ( <i>approx. Ln. Is owned</i> ) in one place at one time, and in other places you can safely receive a pointer to it, <i>borrow</i> (borrow). <br><br>  <code>collections::string::String</code> is a type with <i>ownership</i> .  This means that he has the exclusive right to own the contents of the effluent.  When an object of this type leaves its scope, the string is freed.  Therefore, any substring cannot be of type <code>String</code> , because there will be no connection between the string and the substring, and when the first leaves its scope, the second will become incorrect.  Instead, substrings (or <i>string sections</i> ) use a type that is a reference to an object owned by someone else - <code>&amp;str</code> .  Rust, thanks to the concept of the lifetime of an object, is able to ensure that not a single string cut survives its original string, thus maintaining memory security. <br><br>  There is a more detailed explanation <a href="http://doc.rust-lang.org/guide-ownership.html">in the life time guide</a> .  Here, if you see the construction of <code>'_</code> after the reference type, know that this is how the link lifetime is determined.  There is a special lifetime of <code>'static</code> , which means that the object exists for the entire duration of the program.  Such objects are baked directly into the executable file, as well as string literals that are found in the code ‚Äî that is, the type of the string literal <code>&amp;'static str</code> . <br><br><blockquote>  Earlier, when the type <code>~T</code> was what <code>Box&lt;T&gt;</code> , and <code>str</code> was fake, type <code>~str</code> was a string type resizable.  It kept the current (size) and maximum (capacity) size as the current type of <code>String</code> (which replaced <code>~str</code> ).  It was assumed that all types of wrappers will work this way.  Now, <code>Box&lt;T&gt;</code> is a simple wrapped value.  That is why it is not used - without additional capacity, he would need to re-allocate the memory each time he writes to the line.  <code>String</code> able to re-allocate memory and does it by default.  Therefore, the difference between <code>Box&lt;str&gt;</code> and <code>&amp;str</code> significant. <br><br>  I can add that during this change, the new type wore the name <code>StrBuf</code> .  In fact, the situation is not much different from that in other languages.  In fact, this is the effect of the lack of mandatory garbage collection, which makes some applications of <code>&amp;str</code> stupid.  In Rust, you have to access the string buffer more often than in other languages, simply because <i>other languages</i> allow you to treat your <i>main</i> string type more frivolously. <br></blockquote><br><br><h2>  Back to fizzbuzz </h2><br>  That is, the problem is that in one branch we have a line with ownership, and the lines in the other three are just static string sections (links to statically defined lines).  How do we solve this problem?  Maybe we can try to make them all in string sections (yes, yes, the type <code>&amp;str</code> any lifetime <code>'a</code> we can implicitly result in <code>'b</code> , if <code>'a</code> longer than <code>'b</code> . Since <code>'static</code> longer than anything, the compiler can freely convert it to a suitable lifetime): <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i.to_string().as_slice() }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, result); }</code> </pre><br>  Looks like a good idea, huh?  Sorry, that won't work either: <br><pre> f.rs:10:9: 10:22 error: borrowed value does not live long enough
 f.rs:10 i.to_string (). as_slice ()
                 ^ ~~~~~~~~~~~~
 f.rs:2:25: 13: 2 note: reference must be valid for the block at 2:24 ...
 f.rs:2 for i in range (1i, 101) {
 f.rs Called result = if i% 15 == 0 {
 f.rs:4 "FizzBuzz"
 f.rs.12} else if i% 5 == 0 {
 f.rs:6 "Buzz"
 f.rs:7} else if i% 3 == 0 {
        ...
 f.rs:9:12: 11: 6 note: ... but borrowed value is only valid for the expression at 9:11
 f.rs:9} else {
 f.rs:10 i.to_string (). as_slice ()
 f.rs:11};
 error: aborting due to previous error
</pre><br>  Here we run into a lifetime: the string spawned in <code>i.to_string()</code> not stored for sufficient time and is freed at the end of the block.  Thus, the link to it also cannot leave the block.  This is a potential bug related to the reference to non-valid memory that the Rust compiler successfully caught.  In some languages, this is called ‚Äúdangling index‚Äù and it is very bad. <br><br>  Here we can simply raise the string variable per block, it is enough for us that the string be valid during the body of the loop.  Sometimes you will be confronted with situations in which this will be enough, but often not. <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = i.to_string(); x.as_slice() }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, result); }</code> </pre>  <i>We place the link in the covering block, it works.</i> <br><h2>  How about making everything a <code>String</code> ? </h2><br>  We can go in the opposite direction, obliging all branches to return rows with ownership: <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>.to_string() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>.to_string() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>.to_string() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i.to_string() }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, result); }</code> </pre>  <i>We do everything in rows, but not for free for runtime.</i> <br><br>  This approach works well, but it means that memory will be allocated for <i>each</i> iteration, not only for those in which we get a number. <br><br><h2>  Write the function </h2><br>  We passed as much as we could in this direction, without rolling the code into absurdity.  How about changing the very formulation of the problem, namely, that we do not <i>print the</i> result, but <i>return</i> it from the function? <br><br>  Let's start with this code: <table><caption>  The <code>fizz_buzz</code> function that returns a <code>String</code> . </caption><tbody><tr><th>  Python </th><th>  Rusty </th></tr><tr><td><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fizz_buzz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'FizzBuzz'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Buzz'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Fizz'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>): print(fizz_buzz(i))</code> </pre><br></td><td><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fizz_buzz</span></span></span></span>(i: int) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>.to_string() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>.to_string() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>.to_string() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i.to_string() } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, fizz_buzz(i)); }</code> </pre><br></td></tr></tbody></table>  Now we have an extra level of encapsulation.  It demonstrates just the case when a decision with the removal of a variable to a higher level will not work, because the variable will leave the function itself. <br>  ( <a href="http://is.gd/vd6Amb">You can try it yourself</a> ; the return value of the function cannot be represented in the Rust type system, since there is no suitable lifetime - <code>x</code> will not get a <code>'static</code> lifetime, and there is nothing to which we could tie it.) <br><br>  Also, since we put the code in a function, we allocate new lines for those cases when it is not needed. <br><br><h2>  Let's <code>SendStr</code> </h2><br>  Fortunately, Rust supports <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9%2520%25D1%2582%25D0%25B8%25D0%25BF%2520%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">algebraic data types</a> (also known as <code>enum</code> ).  Also, in the standard library there is a suitable type that can describe an object that is either a string cut or a possession string. <br><br>  Below is the definition of this type (without a description of the methods that make it even more useful): <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MaybeOwned</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Slice(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>), Owned(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendStr</span></span></span></span> = MaybeOwned&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;;</code> </pre><br>  Definitions of <u><a href="http://doc.rust-lang.org/std/str/enum.MaybeOwned.html"><code>MaybeOwned</code></a></u> and <u><a href="http://doc.rust-lang.org/std/str/type.SendStr.html"><code>SendStr</code></a></u> from <u><a href="http://doc.rust-lang.org/std/str/index.html"><code>std::str</code></a></u> . <br><br>  <code>Send</code> is a restriction that indicates that an object can be safely transferred between tasks (that is, between threads, while not losing memory security);  this also implies that the object is self-sufficient, and can be returned from a function.  Let there be a string like <code>&amp;'static str</code> , as in the definition of <code>SendStr</code> ;  it does not contain references to any objects inside the function, is it?  Therefore, it can exist as long as it takes.  The same is true for <code>String</code> .  Therefore, either of these two objects can be captured inside an <code>enum</code> type, which says that we own one or another object.  Therefore, <code>SendStr</code> satisfies the <code>Send</code> condition.  This type stores a value in it and the user can <a href="http://doc.rust-lang.org/std/str/enum.MaybeOwned.html">perform various operations on it</a> .  Now the most remarkable fact is that we can extract a string cut from this type using <code>as_slice()</code> .  This type also implements <code>std::fmt::Show</code> , which means that we can use it in formatted output directly, specifying <code>{}</code> (type <code>Show</code> is a direct analog of <code>__str__()</code> in Python or <code>to_s()</code> , <code>toString()</code> , <code>&amp;c</code> in other languages, but it works directly with the <code>writer</code> object, which makes it possible to get rid of the intermediate string object. Calling <code>to_string()</code> on any type that implements <code>Show</code> also calls this mechanism). <br><br>  Here is the application: <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>::SendStr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fizz_buzz</span></span></span></span>(i: int) -&gt; SendStr { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>.into_maybe_owned() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>.into_maybe_owned() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>.into_maybe_owned() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i.to_string().into_maybe_owned() } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, fizz_buzz(i)); }</code> </pre><br>  The fizz_buzz function returns <u><a href="http://doc.rust-lang.org/std/str/type.SendStr.html"><code>SendStr</code></a></u> .  It works. <br>  ( <code>.into_maybe_owned()</code> taken from <u><a href="http://doc.rust-lang.org/std/str/trait.IntoMaybeOwned.html"><code>IntoMaybeOwned</code></a></u> and <a href="http://doc.rust-lang.org/std/prelude/index.html">is available by default</a> ) <br><br>  Cool!  Now we have reduced the amount of work the computer needs to do and have made our well-known example faster. <br>  But can we go further? <br><br><h2>  Writing your own <code>enum</code> type and implementing the type <code>std::fmt::Show</code> </h2><br>  Of course, what we convey is not really a ‚Äústring‚Äù, these are some meanings of ‚ÄúFizz‚Äù, ‚ÄúBuzz‚Äù, ‚ÄúFizzBuzz‚Äù, or a number.  We simply converted all the options into a string in advance;  we can easily do it lazily, avoiding unnecessary allocations (in fact, all allocations here can be avoided). <br><br>  Let's make our own <code>enum</code> . <br>  In the process, we also implement <code>std::fmt::Show</code> for it, which will allow outputting it directly to <code>stdout</code> , without the need for an intermediate line. <table><caption>  Use an isolated data type to effectively represent possible values. </caption><tbody><tr><th>  similar to Python (extremely tight) </th><th>  Rusty </th></tr><tr><td><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FizzBuzzItem</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self._value = value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Fizz: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Buzz: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> self <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FizzBuzz: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(self._value) <span class="hljs-comment"><span class="hljs-comment"># ,     Fizz = FizzBuzzItem(object()) Buzz = FizzBuzzItem(object()) FizzBuzz = FizzBuzzItem(object()) def Number(number): return FizzBuzzItem(number) def fizz_buzz(i): if i % 15 == 0: return FizzBuzz elif i % 5 == 0: return Buzz elif i % 3 == 0: return Fizz else: return Number(i) for i in range(1, 101): print(fizz_buzz(i))</span></span></code> </pre><br></td><td><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FizzBuzzItem</span></span></span></span> { Fizz, Buzz, FizzBuzz, Number(int), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> fmt::Show <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> FizzBuzzItem { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> fmt::Formatter) -&gt; fmt::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { Fizz =&gt; f.write(<span class="hljs-string"><span class="hljs-string">b"Fizz"</span></span>), Buzz =&gt; f.write(<span class="hljs-string"><span class="hljs-string">b"Buzz"</span></span>), FizzBuzz =&gt; f.write(<span class="hljs-string"><span class="hljs-string">b"FizzBuzz"</span></span>), Number(num) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">write!</span></span>(f, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>, num), } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fizz_buzz</span></span></span></span>(i: int) -&gt; FizzBuzzItem { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">15</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { FizzBuzz } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">5</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { Buzz } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { Fizz } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Number(i) } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">101</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, fizz_buzz(i)); }</code> </pre><br></td></tr></tbody></table><br>  Please note that this is a really good way to present data, although we could not bother so much in this case and simply replace the first three branches with the <code>Word(&amp;'static str)</code> type <code>Word(&amp;'static str)</code> : <code>Word("FizzBuzz")</code> so on.  (In truth, this was the first version I wrote in this step. Even I was turned to using strings where it is not required!) <br><br>  We could go further by writing a separate iterator, but considering how iterators work in Rust, this is not necessary at all - you can simply write <code>range(1, 101).map(fizz_buzz)</code> . <code>range(1, 101).map(fizz_buzz)</code> .  This will give much more flexibility.  Once <code>Iterator&lt;int&gt;</code> is implemented somewhere, you can simply add <code>.map(fizz_buzz)</code> to the end and you will get a type that implements <code>Iterator&lt;FizzBuzzItem&gt;</code> . <br><br>  The cycle can be rewritten once or twice in this style: <table><caption>  We use the <code>fizz_buzz</code> function on the integer iterator. <br></caption><tbody><tr><th>  Python </th><th>  Rusty </th></tr><tr><td><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> map(fizz_buzz, range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>)): print(f)</code> </pre><br></td><td><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>).map(fizz_buzz) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, f); }</code> </pre><br></td></tr></tbody></table><br>  Whichever way we choose, as a result we get the good old FizzBuzz exhaust. <br><br><h2>  Conclusion </h2><br>  Now you know why your first implementation of FizzBuzz on Rust might not work.  Some of the difficulties described in the article are typical for statically-typed languages, some relate to the specifics of Rust.  (Actually, the situation is similar to the same in C ++, with the difference that C ++ allows you to make a bunch of silly mistakes and does not give any guarantees of working with memory. Do not argue with me about this, here I just quote other people, I I do not know C ++ properly.) <br><br>  We walked around the topic of ownership in Rust, and how it can prevent you from writing in the style you are used to, and why this is true (though without describing specific advantages).  We also mentioned the effective concept of <code>enum</code> types (algebraic data types), which allows us to describe data more strictly and efficiently. <br><br>  I hope you saw the power of all these things, and it interested you. <br><br>  Is the described additional meaning?  Yes. <br><br>  It is unpleasant?  Periodically.  (My experience says that all this saves from difficulties as often as it creates them.) <br><br>  Does this improve the effectiveness of your programs?  Of course, with full confidence.  Previously, these things required a loss of security and correctness, now in Rust, you do not need such compromises. <br><br>  Does it make it easier to code through?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In simple cases, like this one, there is not much difference, but in complex these mechanisms become real help. (I really lack them in Python.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summing up on these concepts, we can say that there are bad and good sides: sometimes you will love them, sometimes you hate them. But at least I hate them less often. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Should you use Rust? Well, I suggest at least try it. You may find it raw or unsuitable for your purposes because of its emphasis on system programming. For many high-level tasks, it can be somewhat cumbersome. But I believe that the time will come, and it will be a cool tool for things like web programming, which </font></font><a href="https://www.youtube.com/watch%3Fv%3DjVoFws7rp88"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I talked about at the report in StrangeLoop</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (you can also watch the slides, </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2MB SVG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, if you have little knowledge of Rust or have not understood some part of the article, I suggest that you familiarize yourself with the </font></font><a href="http://doc.rust-lang.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><a href="http://doc.rust-lang.org/intro.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The thirty-minute introduction to Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> describes the concept of ownership quite well, and the </font></font><a href="http://doc.rust-lang.org/guide.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reveals the </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types and more. </font><font style="vertical-align: inherit;">There are also </font></font><a href="http://doc.rust-lang.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more detailed guides on specific issues</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you still have questions, places like the </font></font><a href="http://irc//irc.mozilla.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> channel </font><a href="http://irc//irc.mozilla.org/"><font style="vertical-align: inherit;">on irc.mozilla.org</font></a><font style="vertical-align: inherit;"> can be a great help - I am there for a long time, my nickname is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChrisMorgan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, if you really love messing around with optimizing FizzBuzz </font></font></h2><br> <a href="http://www.reddit.com/r/rust/comments/27ziqs/some_issue_regarding_obsolete_tilde_syntax/ci5xlrq"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes please</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is the final version, with the minimum corrections necessary to compile with the up-to-date version of Rust, and the string version </font></font><code>OUT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for improved readability (!?):</font></font><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#![feature(asm, lang_items)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> libc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> OUT: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>] = <span class="hljs-string"><span class="hljs-string">b"\ 1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n\ 16\n17\nFizz\n19\nBuzz\nFizz\n22\n23\nFizz\nBuzz\n26\nFizz\n28\n29\nFizzBuzz\n\ 31\n32\nFizz\n34\nBuzz\nFizz\n37\n38\nFizz\nBuzz\n41\nFizz\n43\n44\nFizzBuzz\n\ 46\n47\nFizz\n49\nBuzz\nFizz\n52\n53\nFizz\nBuzz\n56\nFizz\n58\n59\nFizzBuzz\n\ 61\n62\nFizz\n64\nBuzz\nFizz\n67\n68\nFizz\nBuzz\n71\nFizz\n73\n74\nFizzBuzz\n\ 76\n77\nFizz\n79\nBuzz\nFizz\n82\n83\nFizz\nBuzz\n86\nFizz\n88\n89\nFizzBuzz\n\ 91\n92\nFizz\n94\nBuzz\nFizz\n97\n98\nFizz\nBuzz\n"</span></span>; <span class="hljs-meta"><span class="hljs-meta">#[start]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span></span>(_argc: int, _argv: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) -&gt; int { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { asm!( <span class="hljs-string"><span class="hljs-string">" mov $$1, %rax mov $$1, %rdi mov $0, %rsi mov $$0x19d, %rdx syscall "</span></span> : : <span class="hljs-string"><span class="hljs-string">"r"</span></span> (&amp;OUT[<span class="hljs-number"><span class="hljs-number">0</span></span>]) : <span class="hljs-string"><span class="hljs-string">"rax"</span></span>, <span class="hljs-string"><span class="hljs-string">"rdi"</span></span>, <span class="hljs-string"><span class="hljs-string">"rsi"</span></span>, <span class="hljs-string"><span class="hljs-string">"rdx"</span></span> : ); } <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[lang = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stack_exhausted"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack_exhausted</span></span></span></span>() {} <span class="hljs-meta"><span class="hljs-meta">#[lang = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eh_personality"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eh_personality</span></span></span></span>() {} <span class="hljs-meta"><span class="hljs-meta">#[lang = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fail_fmt"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail_fmt</span></span></span></span>() {}</code> </pre><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Translator's Notes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><a name="r1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Rust has a developed system of macros, in this case </font></font><code>println!</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in compile-time it is developed into a specialized call for a specific type </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><a name="r2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. When you read the original for the first time, you might get the impression that we are talking about </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D1%258F%25D0%25B5%25D0%25BC%25D1%258B%25D0%25B9%2520%25D0%25BA%25D0%25BE%25D0%25B4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">managed code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , however, here we mean </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">managed memory</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Despite the different wording within the brackets and outside, we are talking about the same thing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The material is quite large, quite possible stylistic or semantic errors of translation. </font><font style="vertical-align: inherit;">Also, due to the fact that I am not an expert in Rust and statically-typed languages, there may be inaccuracies in the description of some mechanisms. </font><font style="vertical-align: inherit;">In both cases, I will be grateful if you send me your corrections in personal messages.</font></font><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/240617/">https://habr.com/ru/post/240617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240603/index.html">Voting on projects for VoCore microcomputer (wi-fi, openwrt)</a></li>
<li><a href="../240607/index.html">Automatic search combinations in mechanical safe locks</a></li>
<li><a href="../240609/index.html">Comprehensive Registry Tweak for Windows 7 + Bonus: Migrate User Data</a></li>
<li><a href="../240611/index.html">Why do we need start-up accelerators: experience of Russian projects in the IIDF program</a></li>
<li><a href="../240615/index.html">Eight Lessons from Steve Ballmer</a></li>
<li><a href="../240619/index.html">MAU for Apple</a></li>
<li><a href="../240621/index.html">Have a good takeoff and soft landing. Landing page for end users</a></li>
<li><a href="../240623/index.html">Dive into Docker: Dockerfile and communication between containers</a></li>
<li><a href="../240625/index.html">The most geeky competition in the history of Habr: about prizes</a></li>
<li><a href="../240627/index.html">12 great examples of email lists for abandoned baskets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>