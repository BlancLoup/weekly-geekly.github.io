<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implement sampling, caching and drawing photos on a map</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I decided to describe how the functionality of sampling and displaying photos on a specific part of the map was implemented in our ph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implement sampling, caching and drawing photos on a map</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, I decided to describe how the functionality of sampling and displaying photos on a specific part of the map was implemented in our photo <em>service gfranq.com</em> . </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/storage2/709/48a/e52/70948ae52bacb687d1b882fa7405bed5.jpg"></div><p></p><br><p>  Since there were a lot of photos in our service and sending queries to the database every time the viewing window was changed was too resource-intensive, it was logical to split the map into areas where information about already retrieved data would be stored.  For obvious reasons, these areas have a rectangular shape (although the option with a hexagonal grid was also considered).  Since at large scales the areas become more spherical, the elements of spherical geometry and tools for working with it were also considered. </p><br><p>  The following issues were addressed in this article: </p><br><ul><li>  Storing and retrieving photos from the database and placing them in the server cache (SQL, C #, ASP.NET). </li><li>  Load the required photos on the client side and put them in the client cache (javascript). </li><li>  Recalculate the photos you want to hide or display each time you change the viewport. </li><li>  Elements of spherical geometry. </li></ul><a name="habracut"></a><br><h2 id="soderzhanie">  Content </h2><br><ul><li>  <a href="https://habr.com/ru/post/182532/">Server part</a> <br><ul><li>  <a href="https://habr.com/ru/post/182532/">Embedded Geotypes</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Normal sample</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Using an extra table with hashes</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Caching photos with multi-thread access</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/182532/">Client part</a> <br><ul><li>  <a href="https://habr.com/ru/post/182532/">Card Initialization</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Locate with HTML5</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Positioning using server information</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Calculation of partially visible rectangular areas</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Calculating the size of caching areas</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Using Delay on Redrawing</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Calculation of coordinates and hashes of partially visible areas</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Redrawing displayed photos</a> </li><li>  <a href="https://habr.com/ru/post/182532/">Distance on the map</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/182532/">Conclusion</a> </li></ul><br><h2 id="servernaya-chast">  Server part </h2><br><p>  The following methods of sampling and storage of geo-information in the database were invented: </p><br><ul><li>  Built-in geographic types of SQL Server. </li><li>  Normal sample with restrictions. </li><li>  Using an extra table. </li></ul><br><p>  Further, these methods will be discussed in detail. </p><br><h3 id="vstroennye-geotipy">  Embedded Geotypes </h3><br><p> As you know, SQL Server 2008 introduced support for geography and geometry types that allow you to specify geographic (on a sphere) and geometric (on a plane) information, such as points, lines, polygons <a href="http://technet.microsoft.com/ru-ru/library/bb933790.aspx">, etc.</a>  .  In order to get all the photos enclosed by a rectangle with coordinates ( <code>lngMin</code> <code>latMin</code> ) and ( <code>latMax</code> <code>lngMax</code> ), you can use the following query: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @h geography; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @p geography; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @rect = geography::STGeomFromText(<span class="hljs-string"><span class="hljs-string">'POLYGON((lngMin latMin, lngMax latMin, lngMax latMax, lngMin latMax, lngMin latMin))'</span></span>, <span class="hljs-number"><span class="hljs-number">4326</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @cound <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, image75Path, geoTag.Lat <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lat, geoTag.Long <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lng, popularity, width, height <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span>(IX_Photo_geoTag)) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> @rect.STContains(geoTag) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Note that the polygon is counterclockwise and the spatial index <code>IX_Photo_geoTag</code> , which is constructed according to the coordinates (by the way, spatial indexes work on the principle of <a href="http://ru.wikipedia.org/wiki/B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">B-trees</a> ). </p><br><p>  However, it turned out that in Microsoft SQL Server 2008 spatial indexes do not work if a column with geotypes can take <code>NULL</code> values, and a composite index cannot contain a column with a geography type, and this question was <a href="http://stackoverflow.com/q/15004850/1046374">raised on stackoverflow</a> .  Because of this, the performance of such queries (without indexes) becomes very low. </p><br><p>  As a solution to this problem, we can suggest the following: </p><br><ul><li>  Since <code>NULL</code> values ‚Äã‚Äãcannot be used, the default coordinates in this column are (0 0), which indicate a point in the Atlantic Ocean not far from Africa (From there the longitude and latitude begin).  However, at this point, as well as nearby, there can be real points, which means that photographs should not be somehow ignored on the map.  If we change the point (0 0) to (0 90), then everything will be much better, because latitude 90 indicates actually the edge of the map, which means excluding this latitude when building the grid (ie, build to 89). </li><li>  Change SQL Server version to 110 using the <code>ALTER DATABASE database_name SET COMPATIBILITY_LEVEL = 110</code> .  This version fixes a bug with indexing NULL geography types, as well as adds support for polygons of different orientations (in the query above, the polygon can be set both against and in a clockwise direction). </li></ul><br><p>  Despite the wide possibilities of geographic types (and they allow us to produce not only the simple sample indicated in the example above, but also use distances, various polygons), they were not used in our project. </p><br><h3 id="obychnaya-vyborka">  Normal sample </h3><br><p>  Selecting photos from the area bounded by the coordinates ( <code>lngMin</code> <code>latMin</code> ) and ( <code>latMax</code> <code>lngMax</code> ) is easy to implement using the following query: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> latitude &gt; @latMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &gt; @lngMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> latitude &lt; @latMax <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &lt; @lngMax <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  It is worth noting that for the <code>latitude</code> and <code>longitude</code> fields in this case, you can create any indexes (unlike the first option), since they are the usual types of float.  However, there are 4 comparisons in this sample. </p><br><h3 id="ispolzovanie-dopolnitelnoy-tablicy-s-heshami">  Using an extra table with hashes </h3><br><p>  The best solution to the problem of fetching photos from certain areas is to create an additional <code>Zooms</code> table that would hold rows containing area hashes for each zoom, as shown in the figure below. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/dd2/696/223/dd269622322fa5b688101ba38ef68f10.png"></div><br><p>  The SQL query thus takes the following form ( <code>zn</code> is the current zoom level): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> = (@latMin + <span class="hljs-number"><span class="hljs-number">90</span></span>) + (@lngMin + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">180</span></span> + (@latMax + <span class="hljs-number"><span class="hljs-number">90</span></span>) * <span class="hljs-number"><span class="hljs-number">64800</span></span> + (@lngMax + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">11664000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Zooms <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> zn = @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span>)</code> </pre> <br><p>  The disadvantage of this approach is that the additional table takes up additional space in memory. </p><br><p>  Despite the advantage of the latter method, the second version with the usual selection was implemented on the server, since it showed quite good performance. </p><br><h3 id="keshirovanie-fotografiy-pri-mnogopotochnom-dostupe">  Caching photos with multi-thread access </h3><br><p>  After the information has been retrieved from the database in some way, the photos are placed in the server cache as follows using a synchronization object to support multithreading: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SyncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); ... List&lt;Photo&gt; photos = (List&lt;Photo&gt;)CachedAreas[hash]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photos == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    ,           1 . lock (SyncObject) { photos = (List&lt;Photo&gt;)CachedAreas[hash]; if (photos == null) { photos = PhotoList.GetAllFromRect(latMin, lngMin, latMax, lngMax, count); //          2     . CachedAreas.Add(hash, photos, null, DateTime.Now.AddSeconds(120), Cache.NoSlidingExpiration, CacheItemPriority.High, null); } } } //   CachedAreas[hash]</span></span></code> </pre> <br><p>  In this section, the server functionality was described for retrieving photos from the database and saving them to the cache.  The next section will describe what happens on the client side of the browser. </p><br><h2 id="klientskaya-chast">  Client part </h2><br><p>  For visualization of maps and photos on it was used Google Maps API  To begin, the user‚Äôs card must be moved to a specific, suitable location corresponding to their geolocation. </p><br><h3 id="inicializaciya-karty">  Card Initialization </h3><br><p>  There are two ways to determine a location when initializing a map.  The first is to use the features of HTML5, and the second is to use pre-calculated coordinates for all regions. </p><br><h4 id="opredelenie-mestopolozheniya-s-pomoschyu-html5">  Locate with HTML5 </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectRegion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navigator.geolocation) { navigator.geolocation.getCurrentPosition(success); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map.setZoom(defaultZoom); map.setCenter(defaultPoint); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">position</span></span></span><span class="hljs-function">) </span></span>{ ... map.setZoom(defaultZoom); map.setCenter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng(position.coords.latitude, position.coords.longitude)); }</code> </pre> <br><p>  The disadvantage of this approach is that not all browsers support this HTML5 function, and the user may not allow access to geo-information on his device. </p><br><h4 id="opredelenie-mestopolozheniya-s-pomoschyu-informacii-s-servera">  Positioning using server information </h4><br><p>  The map is initialized in the next section of the source code, in which <code>bounds</code> are the coordinates of the region (locality, region or country) returned by the server.  The definition of the approximate zoom level is calculated using the algorithm provided in the <code>getZoomFromBounds</code> function (borrowed from <a href="http://stackoverflow.com/a/6055653/1046374">stackoverflow</a> ). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myOptions = { <span class="hljs-attr"><span class="hljs-attr">zoom</span></span>: getZoomFromBounds(northEast, southWest), <span class="hljs-attr"><span class="hljs-attr">center</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng((northEast.lat() + southWest.lat()) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (northEast.lng() + southWest.lng()) / <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-attr"><span class="hljs-attr">mapTypeId</span></span>: google.maps.MapTypeId.ROADMAP, <span class="hljs-attr"><span class="hljs-attr">minZoom</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxZoom</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> } map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.Map(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"map_canvas"</span></span>), myOptions);</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZoomFromBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ne, sw</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GLOBE_WIDTH = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a constant in Google's map projection var west = sw.lng(); var east = ne.lng(); var angle = east - west; if (angle &lt; 0) { angle += 360; } return Math.round(Math.log($('#map_canvas').width() * 360 / angle / GLOBE_WIDTH) / Math.LN2); }</span></span></code> </pre> <br><p>  On the server, the regions are calculated based on the user's IP.  For the aggregation of all coordinates of borders for each region, <a href="https://developers.google.com/maps/documentation/geocoding/%3Fhl%3Dru">google geocoding api was used</a> , although the use of such information offline is not legitimate, in addition there is a limit to 2500 queries per day.  For each city, region and country, a query was formed from our database that returned the desired bounds of <code>viewport</code> and <code>bounds</code> .  They differ only for large areas that cannot fully fit into the viewport.  Moreover, if the answer was returned with an error, then other requests were used in which the spelling was combined in the native language of the region or English, a part of the {Location}, etc. was removed. <code>http://maps.googleapis.com/maps/api/geocode/xml?address={},{/},{ }&amp;sensor=false</code> </p><br><p>  For example, for such a request: <a href="http://maps.googleapis.com/maps/api/geocode/xml%3Faddress%3D%25D0%25A0%25D0%25BE%25D1%2581%25D1%2581%25D0%25B8%25D1%258F,%25D0%2598%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F%2520%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D1%258C,%25D0%2598%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BE%26sensor%3Dfalse">http://maps.googleapis.com/maps/api/geocode/xml?address=Russia, Ivanovo% 20region, Ivanovo &amp; sensor = false</a> </p><br><div class="spoiler">  <b class="spoiler_title">The following coordinates will be returned (fragment)</b> <div class="spoiler_text"><pre> <code class="html hljs xml">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9951313<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.9796047<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span>APPROXIMATE<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre> </div></div><br><h3 id="raschet-chastichno-vidimyh-pryamougolnyh-oblastey">  Calculation of partially visible rectangular areas </h3><br><h4 id="raschet-razmera-keshiruyuschih-oblastey">  Calculating the size of caching areas </h4><br><p>  So, as noted earlier, all photos on both the client and server are cached in rectangular areas, the reference point of which is an arbitrary point (in our case, the point with coordinates (0, 0)), and the size is calculated depending on the current approximation level (zoom) as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    initMapSizeLat  initMapSizeLng var initDefaultDimX = 1000, var initDefaultDimY = 800; //     ,     . var currentDefaultDimX = 1080, var currentDefaultDimY = 500; var initMapSizeLat = 0.0003019; var initMapSizeLng = 0.00067055; //  () . var initRatio = 0.75; //               // .. initMapSizeLat  initMapSizeLng   . var initZoomSize = new google.maps.Size( initMapSizeLat / initDefaultDimX * currentDefaultDimX * initRatio, initMapSizeLng / initDefaultDimY * currentDefaultDimY * initRatio); //      ,     (     2,        1,     2 ,   -  4). function initZoomSizes() { zoomSizes = []; var coef = 1; for (var i = 21; i &gt;= 0; i--) { zoomSizes[i] = new google.maps.Size(initZoomSize.width * coef, initZoomSize.height * coef); coef *= 2; } }</span></span></code> </pre> <br><p>  Thus, at each zoom level, the size of a rectangular area over the area is <code>0.75^2=0.5625</code> from the current viewing window, if its width = 1080px and height = 500px. </p><br><h4 id="ispolzovanie-zaderzhki-pri-pererisovke">  Using Delay on Redrawing </h4><br><p>  Since redrawing all the photos on the map is not a very fast operation (as will be shown later), it was decided to do it with a certain delay after user input: </p><br><pre> <code class="javascript hljs">google.maps.event.addListener(map, <span class="hljs-string"><span class="hljs-string">'bounds_changed'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boundsChangedInverval != <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) clearInterval(boundsChangedInverval); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); boundsChangedInverval = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boundsChanged(); }, prevZoom === zoom ? moveUpdateDelay : zoomUpdateDelay); prevZoom = zoom; });</code> </pre> <br><h4 id="raschet-koordinat-i-heshey-chastichno-vidimyh-oblastey">  Calculation of coordinates and hashes of partially visible areas </h4><br><p>  The calculation of the coordinates and hashes of all the rectangles that overlap the visible window with coordinates ( <code>latMin</code> , <code>lngMin</code> ) and sizes, calculated according to the algorithm described earlier, is performed as follows: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/d8f/63a/bd7/d8f63abd76978f82b66bd0cc5a06311e.png"></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lat &lt;= maxlat) { lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lng &lt;= maxLng) { <span class="hljs-comment"><span class="hljs-comment">//  lat  normalizeLng(lng)    . //    - ,        180     -180. loadIfNeeded(lat, normalizeLng(lng)); lng += s.height; } lat += s.width; } function normalizeLng(lng) { var rtn = lng % 360; if (rtn &lt;= 0) rtn += 360; if (rtn &gt; 180) rtn -= 360; return rtn; }</span></span></code> </pre> <br><p>  Then for each region, the next function is called, which sends a request to the server if necessary.  The hash calculation formula returns a unique value for each region, because the point of reference and dimensions are fixed. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat, lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = calculateHash(lat, lng, zoom); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(hash <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items)) { <span class="hljs-comment"><span class="hljs-comment">//           . } else { //    . } } function calculateHash(lat, lng, zoom) { // lat: [-90..90] // lng: [-180..180] return (lat + 90) + ((lng + 180) * 180) + (zoom * 64800); }</span></span></code> </pre> <br><h3 id="pererisovka-otobrazhaemyh-fotografiy">  Redrawing displayed photos </h3><br><p>  After all photos are loaded or retrieved from the cache, some of them need to be redrawn.  With a large accumulation of photos, or rather markers, in one place, some of them should be hidden, but it becomes unclear exactly how many photos are located in this place.  To solve this problem, it was decided to support two types of markers: markers that display photographs, and markers that indicate that there are photographs in this place.  Also, if all markers are hidden when the borders change, and then re-display them, then flickering will be noticeable.  To solve the above problems, the following algorithm was developed: </p><br><ol><li>  Extract all visible photos from client cache to <code>visMarks</code> array.  The calculation of these areas with photographs has been described above. </li><li>  Sort received markers by popularity. </li><li>  Define overlapping markers using <code>markerSize</code> , <code>smallMarkerSize</code> , <code>minPhotoDistRatio</code> and the <code>pixelDistance</code> function. </li><li>  Create arrays of large markers with <code>maxBigVisPhotosCount</code> and small ones with <code>maxSmlVisPhotosCount</code> . </li><li>  Identify old markers that need to be hidden and entered into <code>smlMarksToHide</code> and <code>bigMarksToHide</code> using <code>refreshMarkerArrays</code> . </li><li>  Updating the visibility and depth index of <code>zIndex</code> for new markers that need to be displayed using <code>updateMarkersVis</code> . </li><li>  Add photos that have become visible at the current time, to the ribbon above using <code>addPhotoToRibbon</code> . </li></ol><br><div class="spoiler">  <b class="spoiler_title">Algorithm for recalculating visible markers</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ isRedrawing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visBigMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visSmlMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bigMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> smlMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photo; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds = map.getBounds(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMin = southWest.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMin = southWest.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMax = northEast.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMax = northEast.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ratio = (latMax - latMin) / $(<span class="hljs-string"><span class="hljs-string">"#map_canvas"</span></span>).height(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    . while (lat &lt;= latMax) { lng = beginLng; while (lng &lt;= lngMax) { var hash = calcHash(lat, normLng(lng), zoom); if (!(hash in curItems)) { } else { var item = curItems[hash]; for (photo in item.photos) { if (bounds.contains(item.photos[photo].latLng)) { visMarks[i] = item.photos[photo]; visMarks[i].overlapCount = 0; i++; } } } k++; lng += s.height; } lat += s.width; } //    . visMarks.sort(function (a, b) { if (b.priority !== a.priority) { return b.priority - a.priority; } else if (b.popularity !== a.popularity) { return b.popularity - a.popularity; } else { return b.id - a.id; } }); //     ,    . var curInd; var contains; var contains2; var dist; visBigMarks2 = []; visSmlMarks2 = []; for (i = 0; i &lt; visMarks.length; i++) { contains = false; contains2 = false; visMarker = visMarks[i]; for (j = 0; j &lt; visBigMarks2.length; j++) { dist = pixelDistance(visMarker.latLng, visBigMarks2[j].latLng, zoom); if (dist &lt;= markerSize * minPhotoDistRatio) { contains = true; if (contains &amp;&amp; contains2) break; } if (dist &lt;= (markerSize + smallMarkerSize) / 2) { contains2 = true; if (contains &amp;&amp; contains2) break; } } if (!contains) { if (visBigMarks2.length &lt; maxBigVisPhotosCount) { smlMarksToHide[smlMarksToHide.length] = visMarker; visBigMarks2[visBigMarks2.length] = visMarker; } } else { bigMarksToHide[bigMarksToHide.length] = visMarker; if (!contains2 &amp;&amp; visSmlMarks2.length &lt; maxSmlVisPhotosCount) { visSmlMarks2[visSmlMarks2.length] = visMarker; } else { visBigMarks2[j].overlapCount++; } } } //  ,     smlMarksToHide  bigMarksToHide . refreshMarkerArrays(visibleSmallMarkers, visSmlMarks2, smlMarksToHide); refreshMarkerArrays(visibleBigMarkers, visBigMarks2, bigMarksToHide); //         zIndex. var curZInd = maxBigVisPhotosCount + 1; curZInd = updateMarkersVis(visBigMarks2, bigMarksToHide, true, curZInd); curZInd = 0; curZInd = updateMarkersVis(visSmlMarks2, smlMarksToHide, false, curZInd); visibleBigMarkers = visBigMarks2; visibleSmallMarkers = visSmlMarks2; //     . trPhotosOnMap.innerHTML = ''; for (var marker in visBigMarks2) { addPhotoToRibbon(visBigMarks2[marker]); } isRedrawing = false; } function refreshMarkerArrays(oldArr, newArr, toHide) { for (var j = 0; j &lt; oldArr.length; j++) { contains = false; var visMarker = oldArr[j]; for (i = 0; i &lt; newArr.length; i++) { if (newArr[i].id === visMarker.id) { contains = true; break; } } if (!contains) { toHide[toHide.length] = visMarker; } } } function updateMarkersVis(showArr, hideArr, big, curZInd) { var marker; var bounds = map.getBounds(); for (var i = 0; i &lt; showArr.length; i++) { var photo = showArr[i]; if (big) { marker = photo.bigMarker; $('#divOvlpCount' + photo.id).html(photo.overlapCount); } else { marker = photo.smlMarker; } marker.setZIndex(++curZInd); if (marker.getMap() === null) { marker.setMap(map); } } for (i = 0; i &lt; hideArr.length; i++) { marker = big ? hideArr[i].bigMarker : hideArr[i].smlMarker; if (marker.getMap() !== null) { marker.setMap(null); marker.setZIndex(0); if (!bounds.contains(hideArr[i].latLng)) hideArr[i].priority = 0; } } return curZInd; } function addPhotoToRibbon(marker) { var td = createColumn(marker); if (isLatLngValid(marker.latLng)) { trPhotosOnMap.appendChild(td); } else { trPhotosNotOnMap.appendChild(td); if (photoViewMode == 'user') { var img = $("#photo" + marker.id).children()[0]; $('#photo' + marker.id).draggable({ helper: 'clone', appendTo: $('#map_canvas'), stop: function (e) { var mapBoundingRect = document.getElementById("map_canvas").getBoundingClientRect(); var point = new google.maps.Point(e.pageX - mapBoundingRect.left, e.pageY - mapBoundingRect.top); var latLng = overlay.getProjection().fromContainerPixelToLatLng(point); marker.latLng = latLng; marker.priority = ++curPriority; placeMarker(marker); }, containment: 'parent', distance: 5 }); } } }</span></span></code> </pre> </div></div><br><h4 id="rasstoyanie-na-karte">  Distance on the map </h4><br><p>  To get the distance between two points on the map in <em>pixels,</em> use the following function: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Offset = <span class="hljs-number"><span class="hljs-number">268435456</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Radius = <span class="hljs-number"><span class="hljs-number">85445659.4471</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">latLng1, latLng2, zoom</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = lonToX(latLng1.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y1 = latToY(latLng1.lat()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x2 = lonToX(latLng2.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y2 = latToY(latLng2.lat()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">21</span></span> - zoom); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lonToX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset + Radius * lng * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">latToY</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset - Radius * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.log((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>)) / (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>))) / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br><p>  This function was also found in the vast stackoverflow. </p><br><p>  To style the markers so that they look like circles with photos like <a href="https://github.com/googlemaps/js-rich-marker">VKontakte, the RichMarker</a> plugin was <a href="https://github.com/googlemaps/js-rich-marker">used</a> with the addition of an arbitrary style to the div element. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  As it turned out, in order for the photos on the map to be displayed quickly and correctly, it took quite some interesting and non-trivial tasks related to caching and spherical geometry.  Despite the fact that not all the methods used were actually used in our project, time was not wasted, since  The experience gained may be useful in other projects, and may also be useful for those who have read and understood this article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/182532/">https://habr.com/ru/post/182532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182520/index.html">Indexing nonatomic attributes</a></li>
<li><a href="../182522/index.html">Yandex's position on the new draft law on Internet regulation</a></li>
<li><a href="../182526/index.html">Bitbucket released a limited edition of branded T-shirts</a></li>
<li><a href="../182528/index.html">Ubuntu Phone already supports internet connection, social apps, calls and more</a></li>
<li><a href="../18253/index.html">Whistle from Yandex</a></li>
<li><a href="../18254/index.html">Who is Fox Jovovich?</a></li>
<li><a href="../182540/index.html">Intel has introduced the fastest "Thunderbolt flash drive" in the world</a></li>
<li><a href="../182544/index.html">How to evaluate firmware testing tools</a></li>
<li><a href="../182548/index.html">Reading the official data on the number of municipalities with text formatting options using the xlrd library</a></li>
<li><a href="../182554/index.html">Larry Page about the PRISM program: "What the ...?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>