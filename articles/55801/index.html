<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Seaside 2.9: Partial Sequels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, a topic about ‚Äúcontinuation‚Äù from HabraUser qmax skipped on Habr√© . He was very impressed with the idea, but it did not work out in det...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Seaside 2.9: Partial Sequels</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/8f5/5bd/efe/8f55bdefeeed6f772979b7b4c259746e.png">  <i>Some time ago, a <a href="http://habrahabr.ru/blogs/webdev/50204/">topic</a> about ‚Äúcontinuation‚Äù from HabraUser <a href="https://habrahabr.ru/users/qmax/" class="user_link">qmax</a> skipped on <a href="https://habrahabr.ru/users/qmax/" class="user_link">Habr√©</a> .</i>  <i>He was very impressed with the idea, but it did not work out in detail.</i>  <i>And recently, one of the developers of Seaside, <a href="http://blog.fitzell.ca/">Julian Fitsell,</a> wrote an article that was amazing in its clarity.</i>  <i>With his permission, I made her translation and would like to share it with the habrasoobschestvom.</i> <br><br>  <i>Immediately I would like to say about the terminology.</i>  <i>As a translation of the word continuation, I use the closest in meaning of the sequel.</i>  <i>The general terminology of an article for a developer who is inexperienced in Smalltalk may seem unusual.</i>  <i>So, instead of the call stack, a ‚Äúchain of contexts‚Äù is used, and instead of a flow, a ‚Äúprocess‚Äù.</i>  <i>If you still have questions after reading - feel free to ask them in the comments.</i>  <i>Thank.</i> <br><a name="habracut"></a><br>  This is the second post in a series of reviews of the upcoming Seaside release.  Take a look at the first post on <a href="http://blog.fitzell.ca/2008/12/seaside-29-exception-handling.html">exception handling</a> . <br><br><h1>  Seaside Sequels </h1><br>  Seaside is often referred to as a ‚Äúcontinuation-based‚Äù web framework, and indeed, at the dawn of development, sequels were used universally, depicting magic.  Seaside 2.8 still uses first-class extensions (which I mean later I'll explain) in three different cases: <br><ul><li>  to stop processing the request (request) and immediately return a response (response); </li><li>  to interrupt the execution of the code and continue it after the user clicks on the link or follows a redirect (for example, to set cookies for the user); </li><li>  to implement the call / answer scheme for components. </li></ul><br>  Nevertheless, the upcoming release of Seaside will completely eliminate the use of continuations in the core of the framework.  The first of these cases will be re-implemented using exceptions, and the code for the second and third cases will be moved to an optional, but installable package.  This means that you can install Seaside without using extensions at all.  This fact should improve portability between Smalltalk dialects, which currently do not support continuations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the same time, we will also replace the first class continuations with partial continuations, and this article should give an idea of ‚Äã‚Äãwhat this means and why we are making these changes.  All this can bring down the stalk (especially during debugging!), So do not worry, but let the information settle down, and then go back to it and reread.  I simplified several things by donating details, hoping to make this topic more understandable for people who are embarrassed by the very idea of ‚Äã‚Äãthe work of the sequels.  I accept any feedback on how I managed to keep this balance. <br><br><h1>  What is the sequel? </h1><br>  First of all, when I mention the continuations, I mean the continuations of the first class.  Seaside also uses the continuation transfer method to implement the rendering cycle (this is the _k parameter that you see in the URLs generated by Seaside).  This is a closely related concept, but not what I‚Äôm going to talk about next. <br><br>  Proceedings are often defined as ‚Äúresidual calculations,‚Äù but I consider it a bit vague if you don‚Äôt understand the essence of this phenomenon.  For me, the simplest explanation is that the continuation saves a ‚Äúsnapshot‚Äù of the running process, which can be continued later.  You call a method that calls another method, that calls another method and so on, and then you take a snapshot of this call chain and save the snapshot object somewhere.  In the future, you can restore it at any time by discarding the currently running code, and your program will continue from that very place, from that very method recorded in the ‚Äúsnapshot‚Äù.  This is the continuation of the first class. <br><br>  It is easier for Smalltalk users to understand this, because when you save a Smalltalk image and open it later, you see exactly the same picture as when you saved it.  You can open the saved image as many times as you like, and each time you will return to the same state.  If you save the image to a new file, you can return to the old one.  Proceedings, in principle, do the same thing, only instead of the whole image, they retain a single process. <br><br><h1>  Call and Answer Implementation </h1><br>  One of the most spectacular features of Seaside is the ability to write multistep tasks that require user participation in the usual iterative style: <br><blockquote><code>answer := self confirm: 'Do it?'. <br> answer ifTrue: [ self doItAlready ] <br></code> </blockquote><br>  This is just what becomes easier when using continuations: we want to stop in the middle of the method and ask the user to enter information.  If he answers, then we want to continue with the place where we left off.  And now let's see how first-class extensions can be used to achieve this. <br><br><h1>  How to read diagrams </h1><br>  A small digression.  The following diagrams depict chains of contexts (although they are rather abstract to call them a stack of frames).  Each time you call a method or execute a block, a new context is created at the ‚Äútop‚Äù of the chain.  Each time a method returns a value or a block is completed, the context from the ‚Äúvertex‚Äù is deleted.  The context of the method knows which method called it, for which object it was called, as well as the value of any variable defined in this method.  He also knows the context below it in the chain.  If you need help to understand this process, then take a look at the illustration, it is all shown step by step. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c7/63d/ae5/6c763dae58bc3a82fb82027fb375255d.png"></div><br><br>  The following diagrams represent a chain of processing contexts for a single HTTP request.  Each request is the result of a click on a link, generating the callback execution.  Each callback ultimately sends either <code>#call:</code> or <code>#answer:</code> <br><br>  The diagrams show a chain of contexts at the moment when <code>#call:</code> or <code>#answer</code> , and depict what happened next.  The upward arrows indicate progress as methods are called, and downwards as they are completed.  I depict exceptions in the form of a dotted arrow, the tail of which is in the place of the exception, and the head indicates the place of its processing.  In the case when the continuation is preserved, both chains are depicted in the diagram: the one that is being executed now and the saved one;  while the arrows are directed as usual.  Obviously, these are very simplified illustrations: I am more interested in describing a general idea than specific details. <br><br>  To bring clarity, a gray bar is marked on each diagram.  All that is above it is the user code: that part of the callback that will be executed.  Everything under the line is part of the framework: reading from a socket, session management, etc. <br><br><h1>  Na√Øve (fr.) Implementation </h1><br>  Okay, let's take a look at one of the possible implementations using continuations.  Imagine that a user is on a web page that contains a ‚Äúdo it‚Äù link.  Clicking the link performs the callback above as an example, which should ask the user ‚ÄúDo it?‚Äù.  During the processing of this request, the following occurs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be4/4f3/b96/be44f3b96d1b028b92b16d4bf8cd6e19.png"></div><br><ol><li>  The framework searches for the correct callback and executes it. </li><li>  During callback execution (inside the #inform: in the above example), the message is sent <code>#call:</code> </li><li>  The result in each context is saved in continuation for future use. </li><li>  An exception is thrown that stops the callback processing and returns control to the framework. </li><li>  The framework continues to work and returns a response to the browser (in Seaside, the rendering phase is performed to display the components in the response, but I simplify a little here). </li></ol><br><br>  As a result, the browser must display the ‚ÄúDo it?‚Äù Prompt and a link or button to confirm the action.  When the user clicks on this link (or button), the callback will be activated, which will perform a <code>self answer: true.</code>  .  And when the second request is received, the following will occur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/521/805/7f0521805e006da92ca270bff12b3b93.png"></div><br><br><ol><li>  The framework searches for the appropriate callback and executes it. </li><li>  Kolback sends the <code>#answer:</code> message. </li><li>  The current chain of contexts is discarded and the one that we saved in continuation is restored to its place.  Notice that this method does the return a second time.  This is of course strange, but no more strange than to keep the Smalltalk image right in the middle of the calculations.  Every time you open an image, you will see the result of the same calculation. </li><li>  Now that we have restored the old chain of contexts, execution will continue in the first callback as if our call to <code>#call:</code> (the place where we saved the continuation) has just ended </li><li>  The restored callback completes its execution (in our example, it checks the value of the user's response and sends <code>#doItAlready</code> ) </li><li>  The framework sends a response to the browser. </li></ol><br><br>  But there is a problem, and that is why I called this implementation na√Øve.  As you can see, the answer is incorrectly returned on the first request.  The socket associated with the first request for disaster has long been closed and the browser no longer waits for a response.  The browser expects to receive a response that apparently never comes in the socket associated with the request number two.  Woops! <br><br><h1>  (Almost) Work Call and Answer </h1><br>  So, the first implementation does not work, but I hope it showed what happens with the sequels.  The problem is that when we restore the continuation, we don‚Äôt want to throw out absolutely everything that the framework has done.  At a minimum, we need a context that will return the response to the correct socket. <br><br>  A simple way to limit the number of contexts captured by the continuation is to create a new process.  A new process starts with a new, empty chain of contexts, so when we create a continuation, only the contexts in this chain will be captured.  We can use the semaphore to make the first process wait until a new one processes the request.  When the second process is complete, it will light the semaphore, and the original process will return the response to the correct socket. <br><br>  The following diagram depicts this scheme (contexts of different processes are represented by different symbols): <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/8e4/460/a848e44606f6af4bee5728ca935ca3dc.png"></div><br><ol><li>  At some point in the framework code, a new process is created, and the original one is waiting for a semaphore signal. </li><li>  The new process finds and executes the corresponding callback. </li><li>  <code>#call:</code> sends the message <code>#call:</code> </li><li>  The continuation is saved (note that this time the continuation starts from the start point of the new process). </li><li>  An exception is thrown, the callback stops processing and returns control to the framework. </li><li>  The framework creates the response for the browser and lights the semaphore. </li><li>  The original process continues its execution and returns the response to the browser. </li></ol><br><br>  So far, the only advantage is that the sequel is less.  But when the second request comes, it becomes obvious how this approach solves our problem: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/746/a3f/d00746a3fe976eb0f4d88f4766af885a.png"></div><br><ol><li>  At some point in the framework code, a new process is created, and the original one is waiting for a semaphore signal. </li><li>  The new process finds and executes the corresponding callback. </li><li>  Kolback sends the <code>#answer:</code> message. </li><li>  The current chain of contexts is discarded and restored to the one that we saved in the continuation (but note that this time only the contexts in the child process are discarded, and the pending process remains unaffected). </li><li>  After we have restored the saved chain of contexts, the execution continues as if the call <code>#call:</code> just completed. </li><li>  Callback completes execution. </li><li>  The framework creates a response for the browser and lights the semaphore, informing the parent process of the completion of its work. </li><li>  The original process continues execution, this time correctly returning a response to the browser. </li></ol><br><br>  Now we not only made the sequel less, but also ensured that the answer to the second request was returned to its intended purpose.  This implementation was used in Seaside 2.8 and earlier versions. <br><br>  But there are a number of significant problems: <br><ol><li>  <b>Creating interprocess communication increases the complexity of the system.</b> </li><li>  <b>Exceptions can not overcome the boundary beyond which the new process was created.</b>  Indeed, if you throw out an exception, the first process will never know about it (technically, this can be overcome and you can simulate this behavior to some extent, but this complicates the system even more).  This means that error handling must be fully performed in the spawned process.  This also adds difficulty, for example, when working with a database that uses exceptions to mark objects as dirty, or to indicate the transaction status of the current process. </li><li>  <b>Exceptions thrown after recovery will continue to cross the restored chain of contexts.</b>  Also, when the exception is processed, the recovered chain of contexts will be promoted, and not the one that was dropped.  Look at the framework contexts colored in red on the last diagram: they will not have a chance to complete the execution and all the safety blocks they have identified will never be executed.  Believe me, when I say that it can generate some insidious bugs. </li><li>  <b>It is necessary to find a compromise between size and accuracy</b> in view of points 2 and 3. If you start a new process immediately before executing a callback, you will get a very small continuation and a shorter exception handling.  Unfortunately, your exceptions will not be able to be thrown far enough and the code will end up running in a completely different place, for example, during the rendering phase. </li><li>  <b>Debugging turns into a nightmare</b> (well, at least in Squeak), when the code depends on the running process.  I am not sure that debuggers will learn to proceed to the process in which the error occurred directly, but at least they will not be able to do it correctly. </li></ol><br><h1>  Partial sequels </h1><br>  Partial continuations imply that instead of saving the whole chain of contexts, we save only the part that is interesting to us.  And when we restore a partial continuation, we replace with them not the whole chain, but only the part that does not represent any interest.  Let's take a look at how this works. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e80/d53/7a0/e80d537a0987301286c2144e37b85c5a.png"></div><br><br>  When the first request arrives, everything happens exactly the same as in the first example, so I will not analyze it step by step, except for one thing: using partial continuations, we can specify the exact range of contexts to save in the continuation.  In this case, we save only those contexts that are part of the user code - callback.  Remember the problem from the first implementation?  The framework code processes one specific request;  these framework contexts will be absolutely useless when processing any other request (even for the same URL, there will still be a new request).  Since a callback can cover several HTTP requests in its execution, we only need to save such callback contexts (called request) contexts for later recovery. <br><br>  Remember also that the chain of contexts in real life can be much longer than shown in these diagrams: so we save 5 contexts instead of, say, 40!  Well, how?  Not a bad savings. <br><br>  And now let's take a look at how the second request is processed.  This illustration is slightly different and more complex, because the chain of contexts changes at runtime, so I will look at it step by step: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b4/21c/5fa/2b421c5fa778efcb4b4d6b2d26e94a7f.png"></div><br><br><ol><li>  The request goes to processing. </li><li>  The framework searches for an appropriate callback and executes it. </li><li>  Kolback sends the <code>#answer:</code> message. </li><li>  Then the saved partial continuation is searched instead of the existing callback code and the saved contexts are literally ‚Äútransplanted‚Äù to the current ones, rewriting the message senders.  I drive my hands in the air, dropping the details, but you have to believe me, everything actually happens that way.  The right side of the diagram shows the state after the completion of ‚Äútransplantation‚Äù.  Notice that all framework contexts are unaffected, and we are still within the scope of the original process. </li><li>  The saved callback continues to run as if the call to the <code>#call:</code> method <code>#call:</code> only would have completed. </li><li>  As soon as the restored callback finishes its execution, it will return control (because we replaced the senders) directly to the framework code that processes the current request. </li><li>  Next, a response will be generated and transmitted via the appropriate socket to the browser. </li></ol><br>  Magic!  I am sure that it looks that way, but it works just fine.  As a result, we have a short continuation and we do not need to create a new process, and all the framework code gets a chance to complete its execution successfully. <br><br><h1>  Conclusion </h1><br>  The partial continuation solution is currently implemented in the development version of Seaside and will be included in the next release.  Squeak and VisualWorks already support the implementation of partial continuations in the code.  GemStone is close to completing their implementation in its VM.  Dialects that cannot implement partial continuations have a choice: <br><ul><li>  can simulate partial continuations with varying degrees of completeness using first-class extensions; </li><li>  may continue to use a system similar to the one that was in Seaside 2.8; </li><li>  can leave them alone.  As I noted above, we have removed the use of Seaside sequels and cores: the platforms can simply stop supporting the call to <code>#call:</code> and this is now easy to do, just not provide the Seaside-Flow package. </li></ul><br>  I hope that this was a useful and interesting piece of reading and I would appreciate your comments on everything that seemed difficult or helpful to understand.  Happy Seasiding. </div><p>Source: <a href="https://habr.com/ru/post/55801/">https://habr.com/ru/post/55801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../55788/index.html">Creating a form with asynchronous validation on the server in Joomla 1.5</a></li>
<li><a href="../55791/index.html">Do not forget to turn the clock on the hour forward.</a></li>
<li><a href="../55797/index.html">How to taste smalltalk</a></li>
<li><a href="../55799/index.html">Javascript from A to‚Ä¶</a></li>
<li><a href="../55800/index.html">Formation of Excel-documents using PHP</a></li>
<li><a href="../55802/index.html">Yota expands: after Moscow and St. Petersburg - Sochi, Ufa and Krasnodar</a></li>
<li><a href="../55803/index.html">PowerShell is now available through Windows Update.</a></li>
<li><a href="../55805/index.html">Second higher education programmer. Where to go?</a></li>
<li><a href="../55808/index.html">30 of the richest Internet entrepreneurs</a></li>
<li><a href="../55809/index.html">Flush 0.4 released (GTK-based BitTorrent client)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>