<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We restore photos using neural networks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone, I work as a research programmer in the Mail.ru Group computer vision team. By the Victory Day this year, we decided to make a project ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We restore photos using neural networks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/333/44a/c78/33344ac788b63200841180799417f934.jpg"><br><br>  Hello everyone, I work as a research programmer in the Mail.ru Group computer vision team.  By the Victory Day this year, we decided to make a <a href="https://9may.mail.ru/">project for the restoration of military photographs</a> .  What is photo restoration?  It consists of three stages: <br><br><ul><li>  we find all the defects of the image: breaks, abrasions, holes; <br></li><li>  paint over defects found based on pixel values ‚Äã‚Äãaround them; <br></li><li>  color the image. <br></li></ul><br>  In this article, I will go through each of the restoration stages in detail and tell you how and where we took the data, what networks we were taught, what happened to us, what rake we stepped on. <br><a name="habracut"></a><br><h1>  Defect Search </h1><br>  We want to find all the pixels related to the defects in the loaded photo.  First we need to understand what photos of the war years people will upload.  We turned to the organizers of the project "Immortal Regiment", who shared data with us.  After analyzing them, we noticed that people often load portraits, single or group, with moderate or large number of defects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Then it was necessary to collect a training set.  The training set for the segmentation task is an image and a mask on which all defects are marked.  The easiest way is to put photos in markup to assessors.  Of course, people can find defects well, but the problem is that the markup is a very long process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5d/a19/892/d5da1989220f10bcaac3944d27d64276.png"><br><br>  It can take from one hour to a full working day to markup pixels related to defects in a single photo, so for several weeks it is difficult to collect a sample of more than 100 photos.  Therefore, we tried to somehow complement our data and wrote the defects ourselves: we took a clean photo, put artificial defects on it and got a mask showing us exactly which parts of the image were defective.  The main part of our training sample was 79 photos, marked up manually, of which we transferred 11 pieces to the test sample. <br><br>  The most popular approach for the segmentation task: take Unet with a pre-trained encoder and minimize the amount <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi><mi>c</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.854ex" height="2.057ex" viewBox="0 -780.1 1659.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-42" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-63" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-65" x="1193" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mi>c</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Bce </script>  ( <a href="https://pytorch.org/docs/stable/nn.html">binary cross-entropy</a> ) and <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.638ex" height="2.057ex" viewBox="0 -780.1 2858 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-44" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-49" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-43" x="1333" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-45" x="2093" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> DICE </script>  ( <a href="https://en.wikipedia.org/wiki/S%25C3%25B8rensen%25E2%2580%2593Dice_coefficient">S√∏rensen ‚Äì Dice coefficient</a> ). <br><br>  What problems arise with this approach in the problem of segmentation of defects? <br><br><ul><li>  Even if it seems to us that there are a lot of defects in a photo, that it is very dirty and is heavily battered by time, the area occupied by defects is still much less than the intact part of the image.  To solve this problem, you can increase the weight of the positive class in <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi><mi>c</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.854ex" height="2.057ex" viewBox="0 -780.1 1659.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-42" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-63" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-65" x="1193" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mi>c</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> Bce </script>  , and the optimal weight will be the ratio of the number of all pure pixels to the number of pixels belonging to defects. <br></li><li>  The second problem is that if we use Unet from the box with a pre-trained encoder, for example Albunet-18, then we lose a lot of positional information.  The first layer of Albunet-18 consists of a convolution with core 5 and stride equal to two.  This allows the network to work quickly.  We sacrificed the network time for better localization of defects: removed the max pooling after the first layer, reduced the stride to 1 and reduced the core of the bundle to 3. <br></li><li>  If we work with small images, for example, compressing the image to 256 x 256 or 512 x 512, then small defects will simply disappear due to interpolation.  Therefore, you need to work with a large picture.  Now in production, we are segmenting the defects in a 1024 x 1024 photograph. Therefore, it was necessary to train the neural network on large numbers of large images.  And because of this, there are problems with a small batch size on a single video card. <br></li><li>  During training, we have about 20 pictures per one card.  Because of this, the estimate of the mean and variance in the BatchNorm layers is inaccurate.  <a href="https://github.com/mapillary/inplace_abn">In-place BatchNorm</a> helps us solve this problem, which, firstly, saves memory, and secondly, it has a version of Synchronized BatchNorm, which synchronizes statistics between all the cards.  Now we consider the mean and variance not for 20 pictures on one card, but for 80 pictures with 4 cards.  This improves network convergence. <br></li></ul><br>  In the end, increasing the weight <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi><mi>c</mi><mi>e</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.854ex" height="2.057ex" viewBox="0 -780.1 1659.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-42" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-63" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-65" x="1193" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi><mi>c</mi><mi>e</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> Bce </script>  By changing the architecture and using In-place BatchNorm, we began to look for defects in the photo.  But cheaply you could have done a little better by adding Test Time Augmentation.  We can drive the network once on the input image, then mirror it and drive the network again, this can help us find small defects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/95b/702/c7595b702dcb921dac612b0218ce13e4.png"><br><br>  As a result, our network converged on four GeForce 1080Ti in 18 hours.  Inference takes 290 ms.  It turns out long enough, but it is a payment that we well look for small defects.  Validation <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.638ex" height="2.057ex" viewBox="0 -780.1 2858 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-44" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-49" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-43" x="1333" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-45" x="2093" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mi>I</mi><mi>C</mi><mi>E</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> DICE </script>  equal to 0.35, and <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi><mi>O</mi><mi>C</mi><mi>A</mi><mi>U</mi><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.596ex" height="2.057ex" viewBox="0 -780.1 4562 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-52" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-4F" x="759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-43" x="1523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-41" x="2283" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-55" x="3034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/453872/&amp;xid=17259,15700023,15700186,15700190,15700256,15700259&amp;usg=ALkJrhhVUKNLqGyDmX2agQr1rHUagFNRuA#MJMATHI-43" x="3801" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mi>O</mi><mi>C</mi><mi>A</mi><mi>U</mi><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> ROCAUC </script>  - 0.93. <br><br><h1>  Restoration of fragments </h1><br>  Unet helped us solve this problem again.  At the entrance we gave him the original image and a mask, on which we mark the spaces with pure units, and the zeroes - those pixels that we want to paint over.  We collected the data as follows: we took from the Internet a large dataset with pictures, for example, OpenImagesV4, and artificially added defects that are similar in shape to those found in real life.  And after that they trained the network to restore the missing parts. <br><br>  How can we modify Unet for this task? <br><br>  You can use Partial Convolution instead of the usual convolution.  Her idea is that when we collapse a region of a picture with some kind of core, we do not take into account the pixel values ‚Äã‚Äãrelated to defects.  This helps make the fill more accurate.  An example from an <a href="https://arxiv.org/abs/1804.07723">NVIDIA article</a> .  In the central picture, they used Unet with the usual convolution, and on the right - with Partial Convolution: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/280/a4b/5a5280a4be71695d16ab08af876c5d23.png"><br><br>  We trained the network for 5 days.  On the last day, we froze BatchNorm, which helped to make the borders of the part of the image being painted over less visible. <br><br>  The network processes 512 x 512 images in 50 ms.  Validation PSNR is 26.4.  However, in this task, you cannot completely trust metrics.  Therefore, we first chased several good models on our data, anonymized the results, and then voted for those that we liked more.  So we chose the final model. <br><br>  I mentioned that we artificially added defects to clean images.  When training, you need to very carefully monitor the maximum size of the superimposed defects, because with very large defects that the network has never seen in the training process, it will wildly fantasize and give an absolutely inapplicable result.  So, if you need to paint over large defects, when training, also submit large defects. <br><br>  Here is an example of the algorithm: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abd/6cb/c8c/abd6cbc8c05396042bf83c00516b630e.png"><br><br><h1>  Coloring </h1><br>  We have segmented defects and painted them, the third step is color reconstruction.  Let me remind you that among the photos of the "Immortal Regiment" there are a lot of single or group portraits.  And we wanted our network to work well with them.  We decided to make our colorization, because none of the services we know paints portraits quickly and well. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/015/bce/bf1/015bcebf15ef1ee069fdf08f16e00542.png"><br><br>  GitHub has a popular <a href="https://github.com/jantic/DeOldify">repository</a> for coloring photos.  On average, he does the job well, but he has a few problems.  For example, he loves to paint clothes in blue.  Therefore, we also rejected it. <br><br>  So, we decided to make a neural network for colorization.  The most obvious idea is to take a black and white image and predict three channels, red, green and blue.  But, generally speaking, we can simplify our work.  We can work not with the RGB color representation, but with the YCbCr representation.  The Y component is brightness (luma).  The downloaded black and white image is the Y channel, we will reuse it.  It remained to predict Cb and Cr: Cb is the difference of blue color and brightness, and Cr is the difference of red color and brightness. <br><br><img src="https://habrastorage.org/webt/k8/ke/l_/k8kel_xrjco6euolh8ypkchjm8g.jpeg"><br><br>  Why did we choose the YCbCr representation?  The human eye is more susceptible to changes in brightness than to changes in color.  Therefore, we reuse the Y-component (brightness), something to which the eye is initially well susceptible, and we predict Cb and Cr, in which we can make a little more mistake, because the person is less ‚Äúfalse‚Äù in colors.  This feature began to actively use at the dawn of color television, when the channel capacity was not enough to transmit all the colors completely.  The image was transferred to YCbCr, transferred to the Y-component without changes, and Cb and Cr were compressed twice. <br><br><h1>  How to build a baseline </h1><br>  You can again take Unet with a pre-trained encoder and minimize L1 Loss between real CbCr and predicted.  We want to paint portraits, so besides the photos from OpenImages, we need to add photos specific to our task. <br><br>  Where can I get color photos of people in uniform?  There are people on the Internet who paint old photos as a hobby or to order.  They do this very carefully, trying to fully observe all the nuances.  Painting the form, shoulder straps, medals, they turn to archival materials, so the result of their work can be trusted.  In total, we used 200 hand-painted photos.  The second useful source of data is the site of the <a href="http://rkka.ru/">Workers 'and Peasants' Red Army</a> .  One of its creators was photographed in almost all possible variants of the military uniform of the Great Patriotic War. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/999/7d9/f729997d9fd02755fd95967ff09d27ca.png"><br><br>  In some photographs, he repeated the poses of people from famous archival photographs.  It is especially good that it was shot on a white background, it allowed us to augment data very well, adding different natural objects to the background.  We also used ordinary modern portraits of people, complementing them with signs of distinction and other attributes of wartime clothing. <br><br>  We trained AlbuNet-50 - this is Unet, which uses AlbuNet-50 as an encoder.  The network began to produce adequate results: the skin is pink, the eyes are gray-blue, and the epaulets are yellowish.  But the problem is that she painted the pictures in spots.  This is due to the fact that from the point of view of the L1 error, it is sometimes more profitable not to do anything than to try to predict a certain color. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/435/4a9/63c/4354a963c4cd2789c434002e44fdda26.png"><br>  <i>We are comparing our result with a photo of Ground Truth - the artist‚Äôs hand- <a href="https://klimbim2014.wordpress.com/">colored</a> coloring under the nickname <a href="https://klimbim2014.wordpress.com/">Klimbim</a></i> <br><br>  How to solve this problem?  We need a discriminator: a neural network, which we will input images to the input, and it will tell you how realistic this image looks.  Below one photo is painted by hand, and the second is neural network.  What do you think, what? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/253/86a/abd/25386aabd9080c14daf71b60d9968453.png"><br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  Manually painted the left photo. <br></div></div><br>  As a discriminator, we use the discriminator from the <a href="https://arxiv.org/abs/1805.08318">Self-Attention GAN</a> article.  This is a small convolutional network, in the last layers of which the so-called Self-Attention is embedded.  It allows you to "pay attention" to the details of the image.  We also use spectral normalization.  Exact explanation and motivation can be found in the article.  We trained the network with a combination of L1-loss and the error returned by the discriminator.  Now the network better paints the details of the image, and the background will be more consistent.  Another example: on the left, the result of a network trained only with L1-loss, on the right ‚Äî with L1-loss and a discriminator error. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa4/724/ada/aa4724ada4e0bbdc52dbcaadd5bb3fdc.png"><br><br>  On four Geforce 1080Ti training took two days.  The network worked for 30 ms in the picture 512 x 512. Validation MSE - 34.4.  As in the inpainting task, metrics can be not completely believed.  Therefore, we selected 6 models that had the best metrics for validation, and blindly voted for the best model. <br><br>  After rolling out the model in production, we continued the experiments and came to the conclusion that it is better to minimize not per-pixel L1-loss, but perceptual loss.  To calculate it, you need to drive the network prediction and the original photo through the VGG-16 network, take the feature maps on the lower layers and compare them by MSE.  This approach paints more areas and helps to get a more colorful picture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db9/303/509/db93035094c4906cf82c246151432cbc.jpg"><br><br><h1>  Conclusions and Conclusion </h1><br>  Unet is a cool model.  In the first task of segmentation, we encountered a problem when learning and working with high-resolution pictures, so we use In-Place BatchNorm.  In the second task (Inpainting) instead of the usual convolution, we used Partial Convolution, this helped to achieve better results.  In the colorization task to Unet, we added a small discriminator network that penalized the generator for an unrealistic-looking image and used perceptual loss. <br><br>  The second conclusion - assessments are important.  And not only at the stage of marking pictures before training, but also to validate the final result, because in the tasks of painting over defects or colorization, you still need to validate the result with the help of a person.  We give the user three photos: the original one with the defects removed, colorized with the defects removed and just the colorized photo in case the algorithm for searching and painting defects is wrong. <br><br>  We took some photos of the <a href="http://waralbum.ru/">War Album</a> project and processed them with our neural networks.  Here are the results obtained: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a51/ade/15e/a51ade15e9cee54ec8269dc1e22df0af.jpg"><br><br>  And <a href="https://cloud.mail.ru/public/45sW/3tdE9yJrT">here</a> you can see them in the original resolution and at each stage of processing. </div><p>Source: <a href="https://habr.com/ru/post/453872/">https://habr.com/ru/post/453872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453862/index.html">Why you should use pathlib</a></li>
<li><a href="../453864/index.html">Using a mouse and keyboard on consoles is cheating?</a></li>
<li><a href="../453866/index.html">API Request with React Hooks, HOC or Render Prop</a></li>
<li><a href="../453868/index.html">Touch mini switch co with glass panel on nRF52832</a></li>
<li><a href="../453870/index.html">We write Reverse socks5 proxy on powershell. Part 1</a></li>
<li><a href="../453874/index.html">From Russian Roulette to secure LOTO: how to protect data center personnel</a></li>
<li><a href="../453876/index.html">How Yandex.Practicum won the front-end desync: acrobatic number with Redux-Saga, postMessage and Jupyter</a></li>
<li><a href="../45388/index.html">Flower router</a></li>
<li><a href="../453882/index.html">Big guide to the profession of decision architect (+ list of useful links)</a></li>
<li><a href="../453884/index.html">Google Camera - HYIP or replacement SLR?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>