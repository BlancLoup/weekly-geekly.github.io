<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing proteins in the cloud using Python and Transcriptic or How to create any protein for $ 360</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What if you have an idea for a cool, healthy protein, and you want to get it in reality? For example, do you want to create a vaccine against H. pylor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing proteins in the cloud using Python and Transcriptic or How to create any protein for $ 360</h1><div class="post__text post__text-html js-mediator-article">  What if you have an idea for a cool, healthy protein, and you want to get it in reality?  For example, do you want to create a vaccine against <i>H. pylori</i> (like the <a href="http://2008.igem.org/Team:Slovenia">Slovenian team at iGEM 2008</a> ) by creating a hybrid protein that combines <i>E. coli</i> flagellin fragments that stimulate the immune response with <i>H. pylori</i> flagellin? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9c/dd5/691/e9cdd5691f1bab368bb400a8818b6507.png"></div>  <i><font color="gray">Design of hybrid flagellin for H. pylori vaccine presented by the Slovenian team at iGEM 2008</font></i> <br><br>  Surprisingly, we are very close to creating any protein we want, without leaving the Jupyter notebook, thanks to the latest developments in genomics, synthetic biology and, more recently, in cloud laboratories. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I will show the Python code from the idea of ‚Äã‚Äãa protein to its expression in a bacterial cell, without touching the pipette or talking to any other person.  The total cost will be only a few hundred dollars!  Using the <a href="http://a16z.com/2015/11/18/bio-fund/">terminology of Vijay Pande of A16Z</a> , this is Biology 2.0. <br><a name="habracut"></a><br>  More specifically, in the article, the Python code of the cloud lab does the following: <br><br><ul><li>  <b>Synthesis of</b> a DNA sequence that encodes any protein that I want. <br></li><li>  <b>Cloning</b> this synthetic DNA into a <b>vector</b> that can express it. <br></li><li>  <b>Transformation of the</b> bacteria with this <b>vector</b> and confirmation that expression occurs. </li></ul><br><h1>  Python setup </h1><br>  First, the general Python settings that are needed for any Jupyter notepad.  We import some useful Python modules and create some utility functions, mainly for data visualization. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mpl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StringIO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Bio.Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Bio.Alphabet <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generic_dna <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> IPython.display <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> display, Image, HTML, SVG <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr)</span></span></span><span class="hljs-function">:</span></span> print(astr + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"-"</span></span>*len(astr)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_html</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> display(HTML(<span class="hljs-string"><span class="hljs-string">'{}'</span></span>.format(astr))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_svg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr, w=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, h=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> SVG_HEAD = <span class="hljs-string"><span class="hljs-string">'''&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;'''</span></span> SVG_START = <span class="hljs-string"><span class="hljs-string">'''&lt;svg viewBox="0 0 {w:} {h:}" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink"&gt;'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> display(SVG(SVG_HEAD + SVG_START.format(w=w, h=h) + astr + <span class="hljs-string"><span class="hljs-string">'&lt;/svg&gt;'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table_print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, header=True)</span></span></span><span class="hljs-function">:</span></span> html = [<span class="hljs-string"><span class="hljs-string">"&lt;table&gt;"</span></span>] html_row = <span class="hljs-string"><span class="hljs-string">"&lt;/td&gt;&lt;td&gt;"</span></span>.join(k <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rows[<span class="hljs-number"><span class="hljs-number">0</span></span>]) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;tr style='font-weight:{}'&gt;&lt;td&gt;{}&lt;/td&gt;&lt;/tr&gt;"</span></span>.format(<span class="hljs-string"><span class="hljs-string">'bold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> header <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span>, html_row)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rows[<span class="hljs-number"><span class="hljs-number">1</span></span>:]: html_row = <span class="hljs-string"><span class="hljs-string">"&lt;/td&gt;&lt;td&gt;"</span></span>.join(row) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;tr style='font-family:monospace;'&gt;&lt;td&gt;{:}&lt;/td&gt;&lt;/tr&gt;"</span></span>.format(html_row)) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;/table&gt;"</span></span>) show_html(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(html)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_seq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dna)</span></span></span><span class="hljs-function">:</span></span> dna = re.sub(<span class="hljs-string"><span class="hljs-string">"\s"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>,dna) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACGTN"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dna) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Seq(dna, generic_dna) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_aas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aas)</span></span></span><span class="hljs-function">:</span></span> aas = re.sub(<span class="hljs-string"><span class="hljs-string">"\s"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>,aas) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(aa <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACDEFGHIKLMNPQRSTVWY*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> aa <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> aas) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aas <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images, header=None, width=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"100%"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># to match Image syntax if type(width)==type(1): width = "{}px".format(width) html = ["&lt;table style='width:{}'&gt;&lt;tr&gt;".format(width)] if header is not None: html += ["&lt;th&gt;{}&lt;/th&gt;".format(h) for h in header] + ["&lt;/tr&gt;&lt;tr&gt;"] for image in images: html.append("&lt;td&gt;&lt;img src='{}' /&gt;&lt;/td&gt;".format(image)) html.append("&lt;/tr&gt;&lt;/table&gt;") show_html(''.join(html)) def new_section(title, color="#66aa33", padding="120px"): style = "text-align:center;background:{};padding:{} 10px {} 10px;".format(color,padding,padding) style += "color:#ffffff;font-size:2.55em;line-height:1.2em;" return HTML('&lt;div style="{}"&gt;{}&lt;/div&gt;'.format(style, title)) # Show or hide text HTML(""" &lt;style&gt; .section { display:flex;align-items:center;justify-content:center;width:100%; height:400px; background:#6a3;color:#eee;font-size:275%; } .showhide_label { display:block; cursor:pointer; } .showhide { position: absolute; left: -999em; } .showhide + div { display: none; } .showhide:checked + div { display: block; } .shown_or_hidden { font-size:85%; } &lt;/style&gt; """) # Plotting style plt.rc("axes", titlesize=20, labelsize=15, linewidth=.25, edgecolor='#444444') sns.set_context("notebook", font_scale=1.2, rc={}) %matplotlib inline %config InlineBackend.figure_format = 'retina' # or 'svg'</span></span></code> </pre> </div></div><br><h1>  Cloud labs </h1><br>  Like AWS or any computing cloud, the cloud lab has molecular biology equipment, as well as robots that it leases over the Internet.  You can issue instructions to your robots by clicking a few buttons in the interface or by writing code that programs them yourself.  It is not necessary to write your own protocols, as I will do here, a significant part of molecular biology is standard routine tasks, so it is usually better to rely on a reliable alien protocol that has shown good interaction with robots. <br><br>  Recently, a number of companies with cloud laboratories have appeared: <a href="https://www.transcriptic.com/">Transcriptic</a> , <a href="https://wla.bionano.autodesk.com/">Autodesk Wet Lab Accelerator</a> (beta, and built on the basis of Transcriptic), <a href="https://www.arcturus.io/">Arcturus BioCloud</a> (beta), <a href="http://emeraldcloudlab.com/">Emerald Cloud Lab</a> (beta), <a href="https://www.synthego.com/">Synthego</a> (not yet launched).  There are even companies built on top of cloud labs, such as <a href="http://desktopgenetics.com/">Desktop Genetics</a> , which specializes in CRISPR.  <a href="http://www.businesswire.com/news/home/20160216005377/en/Study-Shows-Transcriptic%25E2%2580%2599s-Robotic-Cloud-Laboratory-Removes">Scientific articles</a> about the use of cloud laboratories in real science are beginning to appear. <br><br>  At the time of writing this article, only Transcriptic is in open access, so we will use it  As I understand it, most of the Transcriptic business is built on automating common protocols, and writing your own protocols in Python (as I will do in this article) is less common. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/94e/38f/0a6/94e38f0a6f9ea9af3509a0278242b9b4.jpg"><br>  <i><font color="gray">Transcriptic "working cell" with refrigerators below and various laboratory equipment on the stand</font></i> <br><br>  I'll give Transcriptic robots instructions for the <a href="http://autoprotocol.org/">autoprotocol</a> .  Autoprotocol is a JSON-based language for writing protocols for laboratory robots (and people, as it were).  Autoprotocol is mostly done on <a href="https://github.com/autoprotocol/autoprotocol-python">this Python library</a> .  The language was originally created and is still supported by Transcriptic, but, as I understand it, it is completely open.  There is good <a href="https://developers.transcriptic.com/docs/how-to-write-a-new-protocol">documentation</a> . <br><br>  An interesting idea is that on the autoprotocol you can write instructions for people in remote laboratories ‚Äî say, in China or India ‚Äî and potentially get some advantages from using both people (their judgment) and robots (no judgment).  We need to mention <a href="https://www.protocols.io/">protocols.io here</a> , this is an attempt to standardize protocols to increase reproducibility, but for humans, not robots. <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"instructions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"well"</span></span>: <span class="hljs-string"><span class="hljs-string">"water/0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"volume"</span></span>: <span class="hljs-string"><span class="hljs-string">"500.0:microliter"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"op"</span></span>: <span class="hljs-string"><span class="hljs-string">"provision"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span> }, ... ]</code> </pre> <br>  <i><font color="gray">Example autoprotocol snippet</font></i> <br><br><h1>  Python settings for molecular biology </h1><br>  In addition to importing standard libraries, I will need some specific molecular biological utilities.  This code is mainly for autoprotocol and transcriptic. <br><br>  In the code, the concept of "dead volume" is often found.  This means the last drop of liquid that Transcriptic robots cannot take with a pipette from test tubes (because they don‚Äôt see!).  You have to spend a lot of time to make sure that there is a sufficient amount of material in the flasks. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> autoprotocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unit <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.container <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Container <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ref <span class="hljs-comment"><span class="hljs-comment"># "Link a ref name (string) to a Container instance." import requests import logging # Transcriptic authorization org_name = 'hgbrian' tsc_headers = {k:v for k,v in json.load(open("auth.json")).items() if k in ["X_User_Email","X_User_Token"]} # Transcriptic-specific dead volumes _dead_volume = [("96-pcr",3), ("96-flat",25), ("96-flat-uv",25), ("96-deep",15), ("384-pcr",2), ("384-flat",5), ("384-echo",15), ("micro-1.5",15), ("micro-2.0",15)] dead_volume = {k:Unit(v,"microliter") for k,v in _dead_volume} def init_inventory_well(well, headers=tsc_headers, org_name=org_name): """Initialize well (set volume etc) for Transcriptic""" def _container_url(container_id): return 'https://secure.transcriptic.com/{}/samples/{}.json'.format(org_name, container_id) response = requests.get(_container_url(well.container.id), headers=headers) response.raise_for_status() container = response.json() well_data = container['aliquots'][well.index] well.name = "{}/{}".format(container["label"], well_data['name']) if well_data['name'] is not None else container["label"] well.properties = well_data['properties'] well.volume = Unit(well_data['volume_ul'], 'microliter') if 'ERROR' in well.properties: raise ValueError("Well {} has ERROR property: {}".format(well, well.properties["ERROR"])) if well.volume &lt; Unit(20, "microliter"): logging.warn("Low volume for well {} : {}".format(well.name, well.volume)) return True def touchdown(fromC, toC, durations, stepsize=2, meltC=98, extC=72): """Touchdown PCR protocol generator""" assert 0 &lt; stepsize &lt; toC &lt; fromC def td(temp, dur): return {"temperature":"{:2g}:celsius".format(temp), "duration":"{:d}:second".format(dur)} return [{"cycles": 1, "steps": [td(meltC, durations[0]), td(C, durations[1]), td(extC, durations[2])]} for C in np.arange(fromC, toC-stepsize, -stepsize)] def convert_ug_to_pmol(ug_dsDNA, num_nts): """Convert ug dsDNA to pmol""" return float(ug_dsDNA)/num_nts * (1e6 / 660.0) def expid(val): """Generate a unique ID per experiment""" return "{}_{}".format(experiment_name, val) def ¬µl(microliters): """Unicode function name for creating microliter volumes""" return Unit(microliters,"microliter")</span></span></code> </pre> </div></div><br><h1>  DNA synthesis and synthetic biology </h1><br>  Despite the connection with modern synthetic biology, DNA synthesis is a rather old technology.  For decades we have been able to make olikonucleotides (that is, DNA sequences up to 200 bases).  However, it was always expensive, and chemistry never allowed for long DNA sequences.  Recently it has become possible to synthesize whole genes (up to thousands of bases) at a reasonable price.  This achievement really opens the era of "synthetic biology". <br><br>  Craig Venter's <a href="http://www.syntheticgenomics.com/">Synthetic Genomics has</a> advanced synthetic biology the furthest by <a href="https://en.wikipedia.org/wiki/Mycoplasma_laboratorium">synthesizing an entire body</a> ‚Äî over a million bases in length.  As the length of the DNA increases, the problem becomes not synthesis, but assembly (i.e., stitching together the synthesized DNA sequences).  With each assembly, you can double the length of DNA (or more), so after a dozen or so iterations a <a href="http://www.wolframalpha.com/input/%3Fi%3D200%2B*%2B2%255E12">rather long molecule is</a> obtained!  The distinction between synthesis and assembly should soon become clear to the end user. <br><br><h1>  Moore's Law? </h1><br>  The price of DNA synthesis falls quite quickly, from more than $ 0.30 per basis two years ago to about $ 0.10 today, but it develops more like bacteria than processors.  In contrast, DNA sequencing prices fall faster than Moore's law.  A target of <a href="https://twitter.com/twistbioscience/status/590886375572037632">$ 0.02 per base is scheduled as an inflection point</a> , where you can replace a lot of time consuming manipulations with DNA with simple synthesis.  For example, at this price you can synthesize a whole plasmid of 3kb for <a href="http://www.wolframalpha.com/input/%3Fi%3D3000%2Bbases%2Bat%2B2%2Bcents%252Fbase">$ 60</a> and skip a bunch of molecular biology.  Hopefully we will achieve this in a couple of years. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/373/b42/050/373b42050b870646857266bb3e07c7ed.png"><br>  <i><font color="gray">Prices for DNA synthesis compared to prices for DNA sequencing, price for 1 basis (Carlson, 2014)</font></i> <br><br><h1>  DNA synthesis companies </h1><br>  There are several large companies in the field of DNA synthesis: IDT is the largest producer of oliconucleotides, and can also produce longer (up to 2kb) ‚Äúgene fragments‚Äù ( <a href="https://www.idtdna.com/pages/products/genes/gblocks-gene-fragments">gBlocks</a> ).  <a href="https://www.gen9bio.com/">Gen9</a> , <a href="https://www.twistbioscience.com/">Twist,</a> and <a href="https://www.dna20.com/">DNA 2.0</a> usually specialize in longer DNA sequences ‚Äî these are gene synthesis companies.  There are also some interesting new companies, such as <a href="http://cambriangenomics.com/">Cambrian Genomics</a> and <a href="http://www.genesisdna.com/">Genesis DNA</a> , which are working on the next generation synthesis methods. <br><br>  Other companies, such as <a href="https://amyris.com/">Amyris</a> , <a href="http://www.zymergen.com/">Zymergen</a> and <a href="http://ginkgobioworks.com/">Ginkgo Bioworks</a> , use the DNA synthesized by these companies to work at the organism level.  <a href="http://www.syntheticgenomics.com/">Synthetic Genomics</a> also does this, but it itself synthesizes DNA. <br><br>  Ginkgo recently <a href="http://www.fiercebiotechit.com/story/flush-90m-vc-cash-twist-and-ginkgo-strike-massive-synthetic-dna-deal/2015-11-06">made a deal with Twist</a> to make 100 million bases: the biggest deal I saw.  This proves that we live in the future, Twist even advertised the promotional code on Twitter: when you buy 10 million bases of DNA (almost the entire yeast genome!), You get another 10 million for free. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e07/bfb/ac9/e07bfbac9c53ddb79634b63efc3fc0e7.png"><br>  <i><font color="gray"><a href="https://twitter.com/twistbioscience/status/621765539002740737">Twist</a> Niche <a href="https://twitter.com/twistbioscience/status/621765539002740737">Suggestion on Twitter</a></font></i> <br><br><h1>  Part One: Designing an Experiment </h1><br><h3>  Green fluorescent protein </h3><br>  In this experiment, we synthesize a DNA sequence for a simple, <a href="https://en.wikipedia.org/wiki/Green_fluorescent_protein">green fluorescent protein</a> (GFP).  GFP protein was first found in a <a href="https://en.wikipedia.org/wiki/Aequorea_victoria">jellyfish</a> that fluoresces under ultraviolet light.  It is an extremely useful protein because it is easy to detect its expression by simply measuring the fluorescence.  There are variations of GFP that produce yellow, red, orange, and other colors. <br><br>  It is interesting to see how different mutations affect protein color, and this is a potentially interesting machine learning problem.  Most recently, this would have to spend a lot of time in the lab, but now I will show you that it is (almost) as easy as editing a text file! <br><br>  Technically, my GFP is a superfolder variant (sfGFP) with some mutations to improve qualities. <br><br><img src="https://habrastorage.org/webt/tb/tm/_v/tbtm_vcly3elxlwhbcoknhsjpuo.jpeg"><br>  <i><font color="gray">In <a href="https://www.nature.com/articles/nbt1172">superfolder-GFP</a> (sfGFP), some mutations give it certain beneficial properties.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/645/232/c67/645232c67631f484ed6e8b30f6fa91eb.jpg"><br>  <i><font color="gray">GFP structure (rendered using <a href="http://dx.doi.org/10.5281/zenodo.20980">PV</a> )</font></i> <br><br><h3>  GFP Synthesis to Twist </h3><br>  I was lucky to get into the Twist alpha testing program, so I used their DNA synthesis service (they kindly placed my tiny order ‚Äî thanks, Twist!).  This is a new company in our field, with a new simplified synthesis process.  Prices are around <a href="https://groups.google.com/forum/%3Ffromgroups">$ 0.10 for the base or lower</a> , but they are <a href="https://www.twistbioscience.com/">still in beta</a> , and the alpha program in which I participated has closed.  Twist raised about $ 150 million, so their technology is lively enthusiastic. <br><br>  I sent my DNA sequence to Twist as an Excel spreadsheet (there is no API yet, but I guess it will be soon), and they sent the synthesized DNA directly to my box at the Transcriptic lab (I also used IDT for synthesis, but they didn't send DNA right in Transcriptic, which spoils the fun a bit). <br><br>  Obviously, this process has not yet become a typical use case and requires some support, but it worked, so the entire pipeline remains virtual.  Without this, I probably would need access to the laboratory ‚Äî many companies would not send DNA or reagents to their home address. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/378/b0b/734378b0b151d2ed64bbd3ebb6edf0f3.jpg"><br>  <i><font color="gray">GFP is harmless, so <a href="http://news.nationalgeographic.com/news/2009/05/photogalleries/glowing-animal-pictures/">any kind of</a> light is <a href="http://news.nationalgeographic.com/news/2009/05/photogalleries/glowing-animal-pictures/">highlighted</a></font></i> <br><br><h3>  Plasmid vector </h3><br>  To express this protein in bacteria, the gene needs to live somewhere, otherwise the synthetic DNA encoding the gene simply instantly degrades.  As a rule, in molecular biology we use a plasmid, a piece of circular DNA that lives outside the bacterial genome and expresses proteins.  Plasmids are a convenient way for bacteria to share useful, autonomous functional modules, such as antibiotic resistance.  There can be hundreds of plasmids in a cell. <br><br>  A widely used terminology is that the plasmid is a <b>vector</b> , and synthetic DNA is an insertion.  So here we are trying to clone the insertion into a vector, and then transform the bacteria with a vector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/9ae/d03/66c9aed037ae408c6f642433d9a2a130.jpg"><br>  <i><font color="gray">Bacterial genome and plasmid (not to scale!) ( <a href="https://en.wikipedia.org/wiki/Plasmid">Wikipedia</a> )</font></i> <br><br><h3>  pUC19 </h3><br>  I chose a fairly standard plasmid in the <a href="https://en.wikipedia.org/wiki/PUC19">pUC19</a> series.  This plasmid is very often used, and since it is available as part of the standard Transcriptic inventory, we do not need to send anything to them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f3/576/8f1/4f35768f17d5ff5506f7d1aca0b064a0.png"><br>  <i><font color="gray">Structure of pUC19: the main components are the ampicillin resistance gene, lacZŒ±, MCS / polylinker and the origin of replication (Wikipedia)</font></i> <br><br>  PUC19 has a pleasant function: since it contains the lacZŒ± gene, you can use the <a href="https://en.wikipedia.org/wiki/Blue%25E2%2580%2593white_screen">blue-white selection</a> method on it and see which colonies successfully inserted.  Two chemicals are needed: <a href="https://en.wikipedia.org/wiki/Isopropyl_%25CE%25B2-D-1-thiogalactopyranoside">IPTG</a> and <a href="https://en.wikipedia.org/wiki/X-gal">X-gal</a> , and the scheme works as follows: <br><br><ul><li>  IPTG induces the expression of lacZŒ±. <br></li><li>  If lacZŒ± is deactivated through DNA inserted into the multiple cloning site ( <a href="https://en.wikipedia.org/wiki/Multiple_cloning_site">MCS / polylinker</a> ) in lacZŒ±, then the plasmid cannot hydrolyze X-gal, and these colonies will be white instead of blue. <br></li><li>  Therefore, a successful insertion produces white colonies, and a failed insertion produces blue colonies. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/123/aac/aca/123aacacac400c6f96966d2f2caeb918.jpg"><br>  <i><font color="gray">Blue-white selection shows where lacZŒ± expression has been deactivated ( <a href="https://en.wikipedia.org/wiki/Blue_white_screen">Wikipedia</a> )</font></i> <br><br>  <a href="http://openwetware.org/images/f/f1/Dh5a_sub.pdf">The openwetware documentation</a> says: <br><br><blockquote>  E. coli DH5Œ± does not require IPTG to induce expression from the lac promoter, even if the Lac repressor is expressed in the strain.  The number of copies of most plasmids exceeds the number of repressors in the cells.  If you need the maximum level of expression, add IPTG to a final concentration of 1 mM. </blockquote><br><h1>  Synthetic DNA sequences </h1><br><h3>  SfGFP DNA sequence </h3><br>  It is easy to obtain a DNA sequence for sfGFP by taking <a href="http://www.ncbi.nlm.nih.gov/protein/532528641">a protein sequence</a> and <a href="https://www.idtdna.com/CodonOpt">encoding it with codons</a> suitable for the host organism (here, <i>E. coli</i> ).  This is a medium-sized protein with 236 amino acids, so at 10 cents per base, DNA synthesis costs about <a href="http://www.wolframalpha.com/input/%3Fi%3D236%2Bamino%2Bacids%2B*%2B3%2Bbase%2Bpairs%2Bper%2Bamino%2Bacid%2B*%2B10%2Bcents%2Bper%2Bbase">$ 70</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/9da/a41/2969daa417296779220366c36c02a0e5.png"><br>  <i><font color="gray">Wolfram Alpha, the calculation of the cost of synthesis</font></i> <br><br>  The first 12 bases of our sfGFP is the <a href="https://en.wikipedia.org/wiki/Shine-Dalgarno_sequence">Shine ‚Äì Dalgarno sequence</a> , which I added myself, which theoretically should increase the expression (AGGAGGACAGCT, then ATG ( <a href="https://en.wikipedia.org/wiki/Start_codon">start codon</a> ) starts the protein).  According to the computational tool developed by <a href="https://salislab.net/software/Results">Salis Lab</a> ( <a href="http://www.genscript.com/gsfiles/techfiles/Salis_Genscript.pdf">lecture slides</a> ), we can expect medium to high expression of our protein (translation initiation rate is 10,000 "arbitrary units"). <br><br><pre> <code class="python hljs">sfGFP_plus_SD = clean_seq(<span class="hljs-string"><span class="hljs-string">""" AGGAGGACAGCTATGTCGAAAGGAGAAGAACTGTTTACCGGTGTGGTTCCGATTCTGGTAGAACTGGA TGGGGACGTGAACGGCCATAAATTTAGCGTCCGTGGTGAGGGTGAAGGGGATGCCACAAATGGCAAAC TTACCCTTAAATTCATTTGCACTACCGGCAAGCTGCCGGTCCCTTGGCCGACCTTGGTCACCACACTG ACGTACGGGGTTCAGTGTTTTTCGCGTTATCCAGATCACATGAAACGCCATGACTTCTTCAAAAGCGC CATGCCCGAGGGCTATGTGCAGGAACGTACGATTAGCTTTAAAGATGACGGGACCTACAAAACCCGGG CAGAAGTGAAATTCGAGGGTGATACCCTGGTTAATCGCATTGAACTGAAGGGTATTGATTTCAAGGAA GATGGTAACATTCTCGGTCACAAATTAGAATACAACTTTAACAGTCATAACGTTTATATCACCGCCGA CAAACAGAAAAACGGTATCAAGGCGAATTTCAAAATCCGGCACAACGTGGAGGACGGGAGTGTACAAC TGGCCGACCATTACCAGCAGAACACACCGATCGGCGACGGCCCGGTGCTGCTCCCGGATAATCACTAT TTAAGCACCCAGTCAGTGCTGAGCAAAGATCCGAACGAAAAACGTGACCATATGGTGCTGCTGGAGTT CGTGACCGCCGCGGGCATTACCCATGGAATGGATGAACTGTATAAA"""</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Read in sfGFP plus Shine-Dalgarno: {} bases long"</span></span>.format(len(sfGFP_plus_SD))) sfGFP_aas = clean_aas(<span class="hljs-string"><span class="hljs-string">"""MSKGEELFTGVVPILVELDGDVNGHKFSVRGEGEGDATNGKLTLKFICTTGKLPVPWPTLVTTLTYG VQCFSRYPDHMKRHDFFKSAMPEGYVQERTISFKDDGTYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNFNSHNVYITADKQKN GIKANFKIRHNVEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSVLSKDPNEKRDHMVLLEFVTAAGITHGMDELYK"""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sfGFP_plus_SD[<span class="hljs-number"><span class="hljs-number">12</span></span>:].translate() == sfGFP_aas print(<span class="hljs-string"><span class="hljs-string">"Translation matches protein with accession 532528641"</span></span>)</code> </pre> <br><pre>  Read in sfGFP plus Shine-Dalgarno: 726 bases long
 Translation matches protein with accession 532528641 </pre><br><h3>  DNA sequence of pUC19 </h3><br>  First, I check that the <a href="https://www.neb.com/~/media/NebUs/Page%2520Images/Tools%2520and%2520Resources/Interactive%2520Tools/DNA%2520Sequences%2520and%2520Maps/Text%2520Documents/puc19fsa.txt">sequence pUC19, which I downloaded from the NEB</a> , is the correct length and includes the expected <a href="https://en.wikipedia.org/wiki/Multiple_cloning_site">polylinker</a> . <br><br><pre> <code class="python hljs">pUC19_fasta = !cat puc19fsa.txt pUC19_fwd = clean_seq(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(pUC19_fasta[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) pUC19_rev = pUC19_fwd.reverse_complement() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACGT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pUC19_fwd) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(pUC19_fwd) == <span class="hljs-number"><span class="hljs-number">2686</span></span> pUC19_MCS = clean_seq(<span class="hljs-string"><span class="hljs-string">"GAATTCGAGCTCGGTACCCGGGGATCCTCTAGAGTCGACCTGCAGGCATGCAAGCTT"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Read in pUC19: {} bases long"</span></span>.format(len(pUC19_fwd))) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pUC19_fwd print(<span class="hljs-string"><span class="hljs-string">"Found MCS/polylinker"</span></span>)</code> </pre> <br><pre>  Read in pUC19: 2686 bases long
 Found MCS / polylinker </pre><br>  We make some basic QC to make sure that EcoRI and BamHI are present in pUC19 only once (the following restriction enzymes are present in the Transcriptic inventory by default: <i>PstI</i> , <i>PvuII</i> , <i>EcoRI</i> , <i>BamHI</i> , <i>BbsI</i> , <i>BsmBI</i> ). <br><br><pre> <code class="python hljs">REs = {<span class="hljs-string"><span class="hljs-string">"EcoRI"</span></span>:<span class="hljs-string"><span class="hljs-string">"GAATTC"</span></span>, <span class="hljs-string"><span class="hljs-string">"BamHI"</span></span>:<span class="hljs-string"><span class="hljs-string">"GGATTC"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rename, res <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> REs.items(): <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (pUC19_fwd.find(res) == pUC19_fwd.rfind(res) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pUC19_rev.find(res) == pUC19_rev.rfind(res)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (pUC19_fwd.find(res) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pUC19_rev.find(res) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pUC19_fwd.find(res) == len(pUC19_fwd) - pUC19_rev.find(res) - len(res)) print(<span class="hljs-string"><span class="hljs-string">"Asserted restriction enzyme sites present only once: {}"</span></span>.format(REs.keys()))</code> </pre> <br>  Now we look at the lacZŒ± sequence and check that there is nothing unexpected.  For example, it must begin with Met and end with a stop codon.  It is also easy to confirm that this is a full 324bp lacZŒ± ORF by downloading the sequence pUC19 to the free <a href="http://www.snapgene.com/products/snapgene_viewer/">snapgene viewer</a> . <br><br><pre> <code class="python hljs">lacZ = pUC19_rev[<span class="hljs-number"><span class="hljs-number">2217</span></span>:<span class="hljs-number"><span class="hljs-number">2541</span></span>] print(<span class="hljs-string"><span class="hljs-string">"lacZŒ± sequence:\t{}"</span></span>.format(lacZ)) print(<span class="hljs-string"><span class="hljs-string">"r_MCS sequence:\t{}"</span></span>.format(pUC19_MCS.reverse_complement())) lacZ_p = lacZ.translate() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> lacZ_p[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">"M"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lacZ_p[:<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lacZ_p[<span class="hljs-number"><span class="hljs-number">-1</span></span>] == <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS.reverse_complement() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lacZ <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS.reverse_complement() == pUC19_rev[<span class="hljs-number"><span class="hljs-number">2234</span></span>:<span class="hljs-number"><span class="hljs-number">2291</span></span>] print(<span class="hljs-string"><span class="hljs-string">"Found MCS once in lacZ sequence"</span></span>)</code> </pre> <br><pre>  lacZ sequence: ATGACCATGATTACGCCAAGCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCGGGTACCGAGCTCGAATTCACTGGCCGTCGTTTTACAACGTCGTGACTGGGAAAACCCTGGCGTTACCCAACTTAATCGCCTTGCAGCACATCCCCCTTTCGCCAGCTGGCGTAATAGCGAAGAGGCCCGCACCGATCGCCCTTCCCAACAGTTGCGCAGCCTGAATGGCGAATGGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATGGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAG
 r_MCS sequence: AAGCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCGGGTACCGAGCTCGAATTC
 Found MCS once in lacZ sequence </pre><br><h1>  Gibson assembly </h1><br>  DNA assembly simply means stitching the fragments.  Usually you collect several DNA fragments into a longer segment, and then clone it into a plasmid or genome.  In this experiment, I want to clone one DNA segment into plasmid pUC19 downstream of the lac promoter for expression in <i>E. coli</i> . <br><br>  There are many ways to clone (for example, <a href="https://www.neb.com/applications/cloning-and-synthetic-biology">NEB</a> , <a href="http://openwetware.org/wiki/Janet_B._Matsen:Guide_to_Gibson_Assembly">openwetware</a> , <a href="https://www.addgene.org/plasmid-protocols/PCR-cloning/">addgene</a> ).  Here I will use the Gibson assembly ( <a href="https://en.wikipedia.org/wiki/Gibson_assembly">developed by Daniel Gibson</a> in Synthetic Genomics in 2009), which is not necessarily the cheapest method, but simple and flexible.  You only need to place the DNA that you want to collect (with appropriate overlaps) in a tube with the Gibson Assembly Master Mix, and it is going to be on its own! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8df/946/db5/8df946db53b725f89277be267d2e3ab9.jpg"><br>  <i><font color="gray">Gibson Assembly Review ( <a href="https://www.neb.com/products/e2611-gibson-assembly-master-mix">NEB</a> )</font></i> <br><br><h3>  Raw material </h3><br>  We start with 100 ng of synthetic DNA in 10 Œºl of liquid.  This equals 0.21 picomoles of DNA or a concentration of 10 ng / Œºl. <br><br><pre> <code class="python hljs">pmol_sfgfp = convert_ug_to_pmol(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, len(sfGFP_plus_SD)) print(<span class="hljs-string"><span class="hljs-string">"Insert: 100ng of DNA of length {:4d} equals {:.2f} pmol"</span></span>.format(len(sfGFP_plus_SD), pmol_sfgfp))</code> </pre> <br><pre>  Insert: 100ng of DNA of length 726 equals 0.21 pmol </pre><br>  According to <a href="https://www.neb.com/protocols/2012/12/11/gibson-assembly-protocol-e5510">the NEB assembly protocol</a> , this is enough source material: <br><br><blockquote>  NEB recommends a total of 0.02-0.5 picomoles of DNA fragments when 1 or 2 fragments are assembled into a vector, or 0.2-1.0 picomoles of DNA fragments when 4-6 fragments are assembled. <br><br>  0.02-0.5 pmol * X Œºl <br>  * Optimized cloning efficiency is 50-100 ng of vectors with a 2-3-fold excess of insertions.  Use 5 times more inserts if the size is less than 200 bps.  The total volume of unfiltered PCR fragments in a Gibson assembly reaction should not exceed 20%. </blockquote><br><h3>  NEBuilder for Gibson assembly </h3><br>  Biolab's NEBuilder is a really great tool for creating a Gibson assembly protocol.       PDF   .         pUC19  EcoRI,    PCR [,                ‚Äî . .]       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f5/d52/171/1f5d52171cb60c8e8b4cb83f24b0c8c8.png"><br><br><h1>  :   </h1><br>     : <br><br><ol><li>          . <br></li><li>     . <br></li><li>      . <br></li><li>      . </li></ol><br><h3>  1. PCR  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Gibson assembly depends on the DNA sequence that you are assembling, having some overlapping sequence (see the NEB protocol above for detailed instructions). In addition to simple amplification, PCR also allows you to add a flanking DNA sequence by simply inserting an additional sequence into the primers (you can also clone </font></font><a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3121328/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using only OE-PCR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We synthesize primers according to the NEB protocol above. I tried </font></font><a href="https://developers.transcriptic.com/docs/oligosynthesis-1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Quickstart protocol</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the Transcriptic website, but there is also </font><a href="http://autoprotocol-python.readthedocs.org/en/latest/autoprotocol.html"><font style="vertical-align: inherit;">an auto </font></a><a href="https://developers.transcriptic.com/docs/oligosynthesis-1"><font style="vertical-align: inherit;">protocol </font></a></font><a href="http://autoprotocol-python.readthedocs.org/en/latest/autoprotocol.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">command</font></font></a> . Transcriptic     ,   1-2           ( ,  -       ,     ). <br><br><pre> <code class="python hljs">insert_primers = [<span class="hljs-string"><span class="hljs-string">"aaacgacggccagtgTTTATACAGTTCATCCATTCCATG"</span></span>, <span class="hljs-string"><span class="hljs-string">"cgggtaccgagctcgAGGAGGACAGCTATGTCG"</span></span>]</code> </pre> <br><h3>   </h3><br>        <a href="https://www.idtdna.com/calc/analyzer">IDT OligoAnalyzer</a> .    PCR         <a href="https://en.wikipedia.org/wiki/Primer_dimer">primer dimer</a> ,   NEB       . <br><br><pre> Gene-specific portion of flank (uppercase)<font></font>
  Melt temperature: 51C, 53.5C<font></font>
Full sequence<font></font>
  Melt temperature: 64.5C, 68.5C<font></font>
  Hairpin: -.4dG, -5dG<font></font>
  Self-dimer: -9dG, -16dG<font></font>
  Heterodimer: -6dG </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I went through many PCR iterations before getting satisfactory results, including experiments with several different brands of PCR mixes. </font><font style="vertical-align: inherit;">Since each of these iterations can take several days (depending on the length of the queue to the laboratory), it is worthwhile to spend time in advance for debugging: it saves a lot of time in the long run. </font><font style="vertical-align: inherit;">As the capacity of the cloud lab increases, this problem should become less acute. </font><font style="vertical-align: inherit;">However, your first protocol is unlikely to succeed - there are too many variables.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">""" PCR overlap extension of sfGFP according to NEB protocol. v5: Use 3/10ths as much primer as the v4 protocol. v6: more complex touchdown pcr procedure. The Q5 temperature was probably too hot v7: more time at low temperature to allow gene-specific part to anneal v8: correct dNTP concentration, real touchdown """</span></span> p = Protocol() <span class="hljs-comment"><span class="hljs-comment"># --------------------------------------------------- # Set up experiment # experiment_name = "sfgfp_pcroe_v8" template_length = 740 _options = {'dilute_primers' : False, # if working stock has not been made 'dilute_template': False, # if working stock has not been made 'dilute_dNTP' : False, # if working stock has not been made 'run_gel' : True, # run a gel to see the plasmid size 'run_absorbance' : False, # check absorbance at 260/280/320 'run_sanger' : False} # sanger sequence the new sequence options = {k for k,v in _options.items() if v is True} # --------------------------------------------------- # Inventory and provisioning # https://developers.transcriptic.com/v1.0/docs/containers # # 'sfgfp2': 'ct17yx8h77tkme', # inventory; sfGFP tube #2, micro-1.5, cold_20 # 'sfgfp_puc19_primer1': 'ct17z9542mrcfv', # inventory; micro-2.0, cold_4 # 'sfgfp_puc19_primer2': 'ct17z9542m5ntb', # inventory; micro-2.0, cold_4 # 'sfgfp_idt_1ngul': 'ct184nnd3rbxfr', # inventory; micro-1.5, cold_4, (ERROR: no template) # inv = { 'Q5 Polymerase': 'rs16pcce8rdytv', # catalog; Q5 High-Fidelity DNA Polymerase 'Q5 Buffer': 'rs16pcce8rmke3', # catalog; Q5 Reaction Buffer 'dNTP Mixture': 'rs16pcb542c5rd', # catalog; dNTP Mixture (25mM?) 'water': 'rs17gmh5wafm5p', # catalog; Autoclaved MilliQ H2O 'sfgfp_pcroe_v5_puc19_primer1_10uM': 'ct186cj5cqzjmr', # inventory; micro-1.5, cold_4 'sfgfp_pcroe_v5_puc19_primer2_10uM': 'ct186cj5cq536x', # inventory; micro-1.5, cold_4 'sfgfp1': 'ct17yx8h759dk4', # inventory; sfGFP tube #1, micro-1.5, cold_20 } # Existing inventory template_tube = p.ref("sfgfp1", id=inv['sfgfp1'], cont_type="micro-1.5", storage="cold_4").well(0) dilute_primer_tubes = [p.ref('sfgfp_pcroe_v5_puc19_primer1_10uM', id=inv['sfgfp_pcroe_v5_puc19_primer1_10uM'], cont_type="micro-1.5", storage="cold_4").well(0), p.ref('sfgfp_pcroe_v5_puc19_primer2_10uM', id=inv['sfgfp_pcroe_v5_puc19_primer2_10uM'], cont_type="micro-1.5", storage="cold_4").well(0)] # New inventory resulting from this experiment dilute_template_tube = p.ref("sfgfp1_0.25ngul", cont_type="micro-1.5", storage="cold_4").well(0) dNTP_10uM_tube = p.ref("dNTP_10uM", cont_type="micro-1.5", storage="cold_4").well(0) sfgfp_pcroe_out_tube = p.ref(expid("amplified"), cont_type="micro-1.5", storage="cold_4").well(0) # Temporary tubes for use, then discarded mastermix_tube = p.ref("mastermix", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) water_tube = p.ref("water", cont_type="micro-1.5", storage="ambient", discard=True).well(0) pcr_plate = p.ref("pcr_plate", cont_type="96-pcr", storage="cold_4", discard=True) if 'run_absorbance' in options: abs_plate = p.ref("abs_plate", cont_type="96-flat", storage="cold_4", discard=True) # Initialize all existing inventory all_inventory_wells = [template_tube] + dilute_primer_tubes for well in all_inventory_wells: init_inventory_well(well) print(well.name, well.volume, well.properties) # ----------------------------------------------------- # Provision water once, for general use # p.provision(inv["water"], water_tube, ¬µl(500)) # ----------------------------------------------------- # Dilute primers 1/10 (100uM-&gt;10uM) and keep at 4C # if 'dilute_primers' in options: for primer_num in (0,1): p.transfer(water_tube, dilute_primer_tubes[primer_num], ¬µl(90)) p.transfer(primer_tubes[primer_num], dilute_primer_tubes[primer_num], ¬µl(10), mix_before=True, mix_vol=¬µl(50)) p.mix(dilute_primer_tubes[primer_num], volume=¬µl(50), repetitions=10) # ----------------------------------------------------- # Dilute template 1/10 (10ng/ul-&gt;1ng/ul) and keep at 4C # OR # Dilute template 1/40 (10ng/ul-&gt;0.25ng/ul) and keep at 4C # if 'dilute_template' in options: p.transfer(water_tube, dilute_template_tube, ¬µl(195)) p.mix(dilute_template_tube, volume=¬µl(100), repetitions=10) # Dilute dNTP to exactly 10uM if 'dilute_DNTP' in options: p.transfer(water_tube, dNTP_10uM_tube, ¬µl(6)) p.provision(inv["dNTP Mixture"], dNTP_10uM_tube, ¬µl(4)) # ----------------------------------------------------- # Q5 PCR protocol # www.neb.com/protocols/2013/12/13/pcr-using-q5-high-fidelity-dna-polymerase-m0491 # # 25ul reaction # ------------- # Q5 reaction buffer 5 ¬µl # Q5 polymerase 0.25 ¬µl # 10mM dNTP 0.5 ¬µl -- 1¬µl = 4x12.5mM # 10uM primer 1 1.25 ¬µl # 10uM primer 2 1.25 ¬µl # 1pg-1ng Template 1 ¬µl -- 0.5 or 1ng/ul concentration # ------------------------------- # Sum 9.25 ¬µl # # # Mastermix tube will have 96ul of stuff, leaving space for 4x1ul aliquots of template p.transfer(water_tube, mastermix_tube, ¬µl(64)) p.provision(inv["Q5 Buffer"], mastermix_tube, ¬µl(20)) p.provision(inv['Q5 Polymerase'], mastermix_tube, ¬µl(1)) p.transfer(dNTP_10uM_tube, mastermix_tube, ¬µl(1), mix_before=True, mix_vol=¬µl(2)) p.transfer(dilute_primer_tubes[0], mastermix_tube, ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(dilute_primer_tubes[1], mastermix_tube, ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.mix(mastermix_tube, volume="48:microliter", repetitions=10) # Transfer mastermix to pcr_plate without template p.transfer(mastermix_tube, pcr_plate.wells(["A1","B1","C1"]), ¬µl(24)) p.transfer(mastermix_tube, pcr_plate.wells(["A2"]), ¬µl(24)) # acknowledged dead volume problems p.mix(pcr_plate.wells(["A1","B1","C1","A2"]), volume=¬µl(12), repetitions=10) # Finally add template p.transfer(template_tube, pcr_plate.wells(["A1","B1","C1"]), ¬µl(1)) p.mix(pcr_plate.wells(["A1","B1","C1"]), volume=¬µl(12.5), repetitions=10) # --------------------------------------------------------- # Thermocycle with Q5 and hot start # 61.1 annealing temperature is recommended by NEB protocol # p.seal is enforced by transcriptic # extension_time = int(max(2, np.ceil(template_length * (11.0/1000)))) assert 0 &lt; extension_time &lt; 60, "extension time should be reasonable for PCR" cycles = [{"cycles": 1, "steps": [{"temperature": "98:celsius", "duration": "30:second"}]}] + \ touchdown(70, 61, [8, 25, extension_time], stepsize=0.5) + \ [{"cycles": 16, "steps": [{"temperature": "98:celsius", "duration": "8:second"}, {"temperature": "61.1:celsius", "duration": "25:second"}, {"temperature": "72:celsius", "duration": "{:d}:second".format(extension_time)}]}, {"cycles": 1, "steps": [{"temperature": "72:celsius", "duration": "2:minute"}]}] p.seal(pcr_plate) p.thermocycle(pcr_plate, cycles, volume=¬µl(25)) # -------------------------------------------------------- # Run a gel to hopefully see a 740bp fragment # if 'run_gel' in options: p.unseal(pcr_plate) p.mix(pcr_plate.wells(["A1","B1","C1","A2"]), volume=¬µl(12.5), repetitions=10) p.transfer(pcr_plate.wells(["A1","B1","C1","A2"]), pcr_plate.wells(["D1","E1","F1","D2"]), [¬µl(2), ¬µl(4), ¬µl(8), ¬µl(8)]) p.transfer(water_tube, pcr_plate.wells(["D1","E1","F1","D2"]), [¬µl(18),¬µl(16),¬µl(12),¬µl(12)], mix_after=True, mix_vol=¬µl(10)) p.gel_separate(pcr_plate.wells(["D1","E1","F1","D2"]), ¬µl(20), "agarose(10,2%)", "ladder1", "10:minute", expid("gel")) #--------------------------------------------------------- # Absorbance dilution series. Take 1ul out of the 25ul pcr plate wells # if 'run_absorbance' in options: p.unseal(pcr_plate) abs_wells = ["A1","B1","C1","A2","B2","C2","A3","B3","C3"] p.transfer(water_tube, abs_plate.wells(abs_wells[0:6]), ¬µl(10)) p.transfer(water_tube, abs_plate.wells(abs_wells[6:9]), ¬µl(9)) p.transfer(pcr_plate.wells(["A1","B1","C1"]), abs_plate.wells(["A1","B1","C1"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) p.transfer(abs_plate.wells(["A1","B1","C1"]), abs_plate.wells(["A2","B2","C2"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) p.transfer(abs_plate.wells(["A2","B2","C2"]), abs_plate.wells(["A3","B3","C3"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) for wavelength in [260, 280, 320]: p.absorbance(abs_plate, abs_plate.wells(abs_wells), "{}:nanometer".format(wavelength), exp_id("abs_{}".format(wavelength)), flashes=25) # ----------------------------------------------------------------------------- # Sanger sequencing: https://developers.transcriptic.com/docs/sanger-sequencing # "Each reaction should have a total volume of 15 ¬µl and we recommend the following composition of DNA and primer: # PCR product (40 ng), primer (1 ¬µl of a 10 ¬µM stock)" # # By comparing to the gel ladder concentration (175ng/lane), it looks like 5ul of PCR product has approximately 30ng of DNA # if 'run_sanger' in options: p.unseal(pcr_plate) seq_wells = ["G1","G2"] for primer_num, seq_well in [(0, seq_wells[0]),(1, seq_wells[1])]: p.transfer(dilute_primer_tubes[primer_num], pcr_plate.wells([seq_well]), ¬µl(1), mix_before=True, mix_vol=¬µl(50)) p.transfer(pcr_plate.wells(["A1"]), pcr_plate.wells([seq_well]), ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(water_tube, pcr_plate.wells([seq_well]), ¬µl(9)) p.mix(pcr_plate.wells(seq_wells), volume=¬µl(7.5), repetitions=10) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[0]).indices(), expid("seq1")) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[1]).indices(), expid("seq2")) # ------------------------------------------------------------------------- # Then consolidate to one tube. Leave at least 3ul dead volume in each tube # remaining_volumes = [well.volume - dead_volume['96-pcr'] for well in pcr_plate.wells(["A1","B1","C1"])] print("Consolidated volume", sum(remaining_volumes, ¬µl(0))) p.consolidate(pcr_plate.wells(["A1","B1","C1"]), sfgfp_pcroe_out_tube, remaining_volumes, allow_carryover=True) uprint("\nProtocol 1. Amplify the insert (oligos previously synthesized)") jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WARNING: root: Low volume for well sfGFP 1 / sfGFP 1: 2.0: microliter </font></font></pre><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sfGFP 1 / sfGFP 1 2.0: microliter {'dilution': '0.25ng / ul'}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sfgfp_pcroe_v5_puc19_primer1_10uM 75.0: microliter {}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sfgfp_pcroe_v5_puc19_primer2_10uM 75.0: microliter {}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consolidated volume 52.0: microliter</font></font><font></font>
<font></font>
Protocol 1. Amplify the insert (oligos previously synthesized)<font></font>
 -------------------------------------------------- -------------<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  11 instructions<font></font>
  8 containers<font></font>
  Total Cost: $32.18<font></font>
  Workcell Time: $4.32<font></font>
  Reagents &amp; Consumables: $27.86 </pre><br><h1> : PCR  </h1><br><h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the gel, you can estimate the correct </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size of the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> product after increasing the concentration (position of the strip in the gel) and the correct </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amount</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (darkness of the strip). The gel has a ladder corresponding to different lengths and quantities of DNA that can be used for comparison. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the gel photograph below the band D1, E1, F1 contain, respectively, 2 Œºl, 4 Œºl and 8 Œºl of the amplified product. I can estimate the amount of DNA in each lane compared to DNA in the ladder (50 ng of DNA per lane in the ladder). I think the results look very clean. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried to use </font><a href="http://www.frogdance.dundee.ac.uk/FrogDance_Software.html"><font style="vertical-align: inherit;">GelEval</font></a><font style="vertical-align: inherit;"> for image analysis and concentration </font></font><a href="http://www.frogdance.dundee.ac.uk/FrogDance_Software.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assessment.</font></font></a> ,   ,    ,    ,    .                .            GelEval  40 /. <br><br>  ,   <a href="http://forums.biotechniques.com/viewtopic.php%3Ff%3D2%26t%3D9105">    </a> ,    dNTP  , ,     12,5   ,     6   740bp  25 .         GelEval  40  x 25  (1   2 ),        ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74a/f5d/284/74af5d28463dbbd2279353a4651087f6.jpg"><br> <i><font color="gray">- EcoRI- pUC19,   (D1, E1, F1),   (D2)</font></i> <br><br><h3>   PCR </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recently, Transcriptic began to provide interesting and useful diagnostic data from its robots. </font><font style="vertical-align: inherit;">At the time of this writing, they are not available for download, so for now I only have an image of the temperatures during thermal cycling. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data looks good, without unexpected peaks or valleys. </font><font style="vertical-align: inherit;">A total of 35 PCR cycles, but some of these cycles are performed at a very high temperature within the </font></font><a href="https://en.wikipedia.org/wiki/Touchdown_polymerase_chain_reaction"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCR touchdown</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In my previous attempts to amplify this segment - of which there were several! </font><font style="vertical-align: inherit;">- there were problems with the hybridization of primers, so here PCR works a lot of time at high temperatures, which should improve the accuracy. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/9eb/1b8/8dc9eb1b85c382df68cc064583512707.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thermocyclic diagnostics for a touchdown PCR: temperature block, sample and cover for 35 cycles and 42 minutes</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 2. Cutting the plasmid </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To insert our sfGFP DNA into pUC19, you first need to cut the plasmid. </font><font style="vertical-align: inherit;">Following the NEB protocol, I do this using the </font></font><a href="https://en.wikipedia.org/wiki/EcoRI"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EcoRI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> restriction enzyme </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the standard Transcriptic inventory there are reagents that I need: these are the </font></font><a href="https://www.neb.com/products/r3101-ecori-hf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEB EcoRI and 10x CutSmart buffer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as the </font></font><a href="https://www.neb.com/products/n3041-puc19-vector"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NEB pUC19</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plasmid </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For information, lower prices from their inventory. </font><font style="vertical-align: inherit;">In fact, I pay only part of the price, since Transcriptic takes payment for the quantity actually consumed:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Item ID Amount Concentration Price</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
------------ ------ ------------- ----------------- - ----</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CutSmart 10x B7204S 5 ml 10 X $ 19.00</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EcoRI R3101L 50,000 units 20,000 units / ml $ 225.00</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pUC19 N3041L 250 ¬µg 1,000 ¬µg / ml $ 268.00 </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I followed the NEB protocol as much as possible: </font></font><br><br><blockquote>       .   10X  dH2O    1X.   ,  ,   , , .   50    5  10x NEBuffer       ,   dH2O. <br><br>      ,    1  Œª    1   37¬∞C     50 .  ,   5-10       10-20     1- . <br><br>   1      50 . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Protocol for cutting pUC19 with EcoRI."""</span></span> p = Protocol() experiment_name = <span class="hljs-string"><span class="hljs-string">"puc19_ecori_v3"</span></span> options = {} inv = { <span class="hljs-string"><span class="hljs-string">'water'</span></span>: <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "pUC19": "rs17tcqmncjfsh", # catalog; pUC19; cold_20 "EcoRI": "rs17ta8xftpdk6", # catalog; EcoRI-HF; cold_20 "CutSmart": "rs17ta93g3y85t", # catalog; CutSmart Buffer 10x; cold_20 "ecori_p10x": "ct187v4ea85k2h", # inventory; EcoRI diluted 10x } # Tubes and plates I use then discard re_tube = p.ref("re_tube", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) water_tube = p.ref("water_tube", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) pcr_plate = p.ref("pcr_plate", cont_type="96-pcr", storage="cold_4", discard=True) # The result of the experiment, a pUC19 cut by EcoRI, goes in this tube for storage puc19_cut_tube = p.ref(expid("puc19_cut"), cont_type="micro-1.5", storage="cold_20").well(0) # ------------------------------------------------------------- # Provisioning and diluting. # Diluted EcoRI can be used more than once # p.provision(inv["water"], water_tube, ¬µl(500)) if 'dilute_ecori' in options: ecori_p10x_tube = p.ref("ecori_p10x", cont_type="micro-1.5", storage="cold_20").well(0) p.transfer(water_tube, ecori_p10x_tube, ¬µl(45)) p.provision(inv["EcoRI"], ecori_p10x_tube, ¬µl(5)) else: # All "inventory" (stuff I own at transcriptic) must be initialized ecori_p10x_tube = p.ref("ecori_p10x", id=inv["ecori_p10x"], cont_type="micro-1.5", storage="cold_20").well(0) init_inventory_well(ecori_p10x_tube) # ------------------------------------------------------------- # Restriction enzyme cutting pUC19 # # 50ul total reaction volume for cutting 1ug of DNA: # 5ul CutSmart 10x # 1ul pUC19 (1ug of DNA) # 1ul EcoRI (or 10ul diluted EcoRI, 20 units, &gt;10 units per ug DNA) # p.transfer(water_tube, re_tube, ¬µl(117)) p.provision(inv["CutSmart"], re_tube, ¬µl(15)) p.provision(inv["pUC19"], re_tube, ¬µl(3)) p.mix(re_tube, volume=¬µl(60), repetitions=10) assert re_tube.volume == ¬µl(120) + dead_volume["micro-1.5"] print("Volumes: re_tube:{} water_tube:{} EcoRI:{}".format(re_tube.volume, water_tube.volume, ecori_p10x_tube.volume)) p.distribute(re_tube, pcr_plate.wells(["A1","B1","A2"]), ¬µl(40)) p.distribute(water_tube, pcr_plate.wells(["A2"]), ¬µl(10)) p.distribute(ecori_p10x_tube, pcr_plate.wells(["A1","B1"]), ¬µl(10)) assert all(well.volume == ¬µl(50) for well in pcr_plate.wells(["A1","B1","A2"])) p.mix(pcr_plate.wells(["A1","B1","A2"]), volume=¬µl(25), repetitions=10) # Incubation to induce cut, then heat inactivation of EcoRI p.seal(pcr_plate) p.incubate(pcr_plate, "warm_37", "60:minute", shaking=False) p.thermocycle(pcr_plate, [{"cycles": 1, "steps": [{"temperature": "65:celsius", "duration": "21:minute"}]}], volume=¬µl(50)) # -------------------------------------------------------------- # Gel electrophoresis, to ensure the cutting worked # p.unseal(pcr_plate) p.mix(pcr_plate.wells(["A1","B1","A2"]), volume=¬µl(25), repetitions=5) p.transfer(pcr_plate.wells(["A1","B1","A2"]), pcr_plate.wells(["D1","E1","D2"]), ¬µl(8)) p.transfer(water_tube, pcr_plate.wells(["D1","E1","D2"]), ¬µl(15), mix_after=True, mix_vol=¬µl(10)) assert all(well.volume == ¬µl(20) + dead_volume["96-pcr"] for well in pcr_plate.wells(["D1","E1","D2"])) p.gel_separate(pcr_plate.wells(["D1","E1","D2"]), ¬µl(20), "agarose(10,2%)", "ladder2", "15:minute", expid("gel")) # ---------------------------------------------------------------------------- # Then consolidate all cut plasmid to one tube (puc19_cut_tube). # remaining_volumes = [well.volume - dead_volume['96-pcr'] for well in pcr_plate.wells(["A1","B1"])] print("Consolidated volume: {}".format(sum(remaining_volumes, ¬µl(0)))) p.consolidate(pcr_plate.wells(["A1","B1"]), puc19_cut_tube, remaining_volumes, allow_carryover=True) assert all(tube.volume &gt;= dead_volume['micro-1.5'] for tube in [water_tube, re_tube, puc19_cut_tube, ecori_p10x_tube]) # --------------------------------------------------------------- # Test protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("Protocol {}\n\n{}".format(experiment_name, jprotocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> Volumes: re_tube:135.0:microliter water_tube:383.0:microliter EcoRI:30.0:microliter<font></font>
Consolidated volume: 78.0:microliter<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  12 instructions<font></font>
  5 containers<font></font>
  Total Cost: $30.72<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Workcell Time: $ 3.38</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Reagents &amp; Consumables: $ 27.34 </font></font></pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results: plasmid cutting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I conducted this experiment twice in slightly different conditions and with gels of different sizes, but the results are almost identical. </font><font style="vertical-align: inherit;">I like both gels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, I did not allocate enough space for a </font></font><a href="https://developers.transcriptic.com/docs/containers"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúdead‚Äù volume</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in test tubes 1.5 ml there is a dead volume of 15 Œºl!). </font><font style="vertical-align: inherit;">I think this explains the difference between D1 and E1 (these two bands should be identical). </font><font style="vertical-align: inherit;">The dead volume problem is easily solved by creating a proper working stock of diluted EcoRI at the beginning of the protocol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite this error, in both gels the bands D1 and E1 are strong bands in the correct position 2,6kb. </font><font style="vertical-align: inherit;">On the D2 band, uncut plasmid: as expected, it is not visible in one gel and is barely visible in another.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two gel photos look quite different. </font><font style="vertical-align: inherit;">This is partly due to the fact that Transcriptic has not yet automated this step. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f8/b9c/e3c/8f8b9ce3cc42de99099976a3c60a9ada.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two gels showing cut pUC19 (2,6kb) on the D1 and E1 bands, and uncut pUC19 on D2</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 3. Build by Gibson </font></font></h2><br>    ,       ‚Äî    ,    <a href="https://www.neb.com/faqs/2011/08/16/what-primers-should-i-use-to-sequence-an-insert-puc19-pneb193-litmus"> M13</a> (  )          <a href="https://en.wikipedia.org/wiki/Real-time_polymerase_chain_reaction">qPCR</a>  <a href="https://en.wikipedia.org/wiki/Gel_electrophoresis"></a> ,  ,   .      ,  ,     ,       . <br><br>     ,   M13  ,         M13. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Debugging transformation protocol: Gibson assembly followed by qPCR and a gel v2: include v3 Gibson assembly"""</span></span> p = Protocol() options = {} experiment_name = <span class="hljs-string"><span class="hljs-string">"debug_sfgfp_puc19_gibson_seq_v2"</span></span> inv = { <span class="hljs-string"><span class="hljs-string">"water"</span></span> : <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "M13_F" : "rs17tcpqwqcaxe", # catalog; M13 Forward (-41); cold_20 (1ul = 100pmol) "M13_R" : "rs17tcph6e2qzh", # catalog; M13 Reverse (-48); cold_20 (1ul = 100pmol) "SensiFAST_SYBR_No-ROX" : "rs17knkh7526ha", # catalog; SensiFAST SYBR for qPCR "sfgfp_puc19_gibson_v1_clone" : "ct187rzdq9kd7q", # inventory; assembled sfGFP; cold_4 "sfgfp_puc19_gibson_v3_clone" : "ct188ejywa8jcv", # inventory; assembled sfGFP; cold_4 } # --------------------------------------------------------------- # First get my sfGFP pUC19 clones, assembled with Gibson assembly # clone_plate1 = p.ref("sfgfp_puc19_gibson_v1_clone", id=inv["sfgfp_puc19_gibson_v1_clone"], cont_type="96-pcr", storage="cold_4", discard=False) clone_plate2 = p.ref("sfgfp_puc19_gibson_v3_clone", id=inv["sfgfp_puc19_gibson_v3_clone"], cont_type="96-pcr", storage="cold_4", discard=False) water_tube = p.ref("water", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) master_tube = p.ref("master", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) primer_tube = p.ref("primer", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) pcr_plate = p.ref(expid("pcr_plate"), cont_type="96-pcr", storage="cold_4", discard=False) init_inventory_well(clone_plate1.well("A1")) init_inventory_well(clone_plate2.well("A1")) seq_wells = ["B2","B4","B6", # clone_plate1 "D2","D4","D6", # clone_plate2 "F2","F4"] # control # clone_plate2 was diluted 4X (20ul-&gt;80ul), according to NEB instructions assert clone_plate1.well("A1").volume == ¬µl(18), clone_plate1.well("A1").volume assert clone_plate2.well("A1").volume == ¬µl(78), clone_plate2.well("A1").volume # -------------------------------------------------------------- # Provisioning # p.provision(inv["water"], water_tube, ¬µl(500)) # primers, diluted 2X, discarded at the end p.provision(inv["M13_F"], primer_tube, ¬µl(13)) p.provision(inv["M13_R"], primer_tube, ¬µl(13)) p.transfer(water_tube, primer_tube, ¬µl(26), mix_after=True, mix_vol=¬µl(20), repetitions=10) # ------------------------------------------------------------------- # PCR Master mix -- 10ul SYBR mix, plus 1ul each undiluted primer DNA (100pmol) # Also add 15ul of dead volume # p.provision(inv['SensiFAST_SYBR_No-ROX'], master_tube, ¬µl(11+len(seq_wells)*10)) p.transfer(primer_tube, master_tube, ¬µl(4+len(seq_wells)*4)) p.mix(master_tube, volume=¬µl(63), repetitions=10) assert master_tube.volume == ¬µl(127) # 15ul dead volume p.distribute(master_tube, pcr_plate.wells(seq_wells), ¬µl(14), allow_carryover=True) p.distribute(water_tube, pcr_plate.wells(seq_wells), [¬µl(ul) for ul in [5,4,2, 4,2,0, 6,6]], allow_carryover=True) # Template -- starting with some small, unknown amount of DNA produced by Gibson p.transfer(clone_plate1.well("A1"), pcr_plate.wells(seq_wells[0:3]), [¬µl(1),¬µl(2),¬µl(4)], one_tip=True) p.transfer(clone_plate2.well("A1"), pcr_plate.wells(seq_wells[3:6]), [¬µl(2),¬µl(4),¬µl(6)], one_tip=True) assert all(pcr_plate.well(w).volume == ¬µl(20) for w in seq_wells) assert clone_plate1.well("A1").volume == ¬µl(11) assert clone_plate2.well("A1").volume == ¬µl(66) # -------------------------------------------------------------- # qPCR # standard melting curve parameters # p.seal(pcr_plate) p.thermocycle(pcr_plate, [{"cycles": 1, "steps": [{"temperature": "95:celsius","duration": "2:minute"}]}, {"cycles": 40, "steps": [{"temperature": "95:celsius","duration": "5:second"}, {"temperature": "60:celsius","duration": "20:second"}, {"temperature": "72:celsius","duration": "15:second", "read": True}]}], volume=¬µl(20), # volume is optional dataref=expid("qpcr"), dyes={"SYBR": seq_wells}, # dye must be specified (tells transcriptic what aborbance to use?) melting_start="65:celsius", melting_end="95:celsius", melting_increment="0.5:celsius", melting_rate="5:second") # -------------------------------------------------------------- # Gel -- 20ul required # Dilute such that I have 11ul for sequencing # p.unseal(pcr_plate) p.distribute(water_tube, pcr_plate.wells(seq_wells), ¬µl(11)) p.gel_separate(pcr_plate.wells(seq_wells), ¬µl(20), "agarose(8,0.8%)", "ladder1", "10:minute", expid("gel")) # This appears to be a bug in Transcriptic. The actual volume should be 11ul # but it is not updating after running a gel with 20ul. # Primer tube should be equal to dead volume, or it's a waste assert all(pcr_plate.well(w).volume==¬µl(31) for w in seq_wells) assert primer_tube.volume == ¬µl(16) == dead_volume['micro-1.5'] + ¬µl(1) assert water_tube.volume &gt; ¬µl(25) # --------------------------------------------------------------- # Test and run protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> WARNING:root:Low volume for well sfgfp_puc19_gibson_v1_clone/sfgfp_puc19_gibson_v1_clone : 11.0:microliter </pre><br><pre> ‚úì Protocol analyzed<font></font>
  11 instructions<font></font>
  6 containers<font></font>
  Total Cost: $32.09<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Workcell Time: $ 6.98</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Reagents &amp; Consumables: $ 25.11 </font></font></pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results: qPCR for Gibson assembly </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I can access qPCR data in JSON format via the Transcriptic API. </font><font style="vertical-align: inherit;">This feature is not well </font></font><a href="https://developers.transcriptic.com/docs/get-specific-data"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documented</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but can be extremely useful. </font><font style="vertical-align: inherit;">The APIs even give you access to some diagnostic data from robots, which can aid in debugging. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we request the launch data:</font></font><br><br><pre> <code class="python hljs">project_id, run_id = <span class="hljs-string"><span class="hljs-string">"p16x6gna8f5e9"</span></span>, <span class="hljs-string"><span class="hljs-string">"r18mj3cz3fku7"</span></span> api_url = <span class="hljs-string"><span class="hljs-string">"https://secure.transcriptic.com/hgbrian/{}/runs/{}/data.json"</span></span>.format(project_id, run_id) data_response = requests.get(api_url, headers=tsc_headers) data = data_response.json()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we specify this id to get the qPCR ‚Äúpost-processing‚Äù data: </font></font><br><br><pre> <code class="python hljs">qpcr_id = data[<span class="hljs-string"><span class="hljs-string">'debug_sfgfp_puc19_gibson_seq_v1_qpcr'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>] pp_api_url = <span class="hljs-string"><span class="hljs-string">"https://secure.transcriptic.com/data/{}.json?key=postprocessed_data"</span></span>.format(qpcr_id) data_response = requests.get(pp_api_url, headers=tsc_headers) pp_data = data_response.json()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are the Ct values ‚Äã‚Äã(cycle threshold) for each tube. </font><font style="vertical-align: inherit;">Ct is just the point at which fluorescence exceeds a certain value. </font><font style="vertical-align: inherit;">She roughly says how much DNA there is at the moment (and, therefore, approximately where we started).</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Simple util to convert wellnum to wellname n_w = {str(wellnum):'ABCDEFGH'[wellnum//12]+str(1+wellnum%12) for wellnum in range(96)} w_n = {v: k for k, v in n_w.items()} ct_vals = {n_w[k]:v for k,v in pp_data["amp0"]["SYBR"]["cts"].items()} ct_df = pd.DataFrame(ct_vals, index=["Ct"]).T ct_df["well"] = ct_df.index f, ax = plt.subplots(figsize=(16,6)) _ = sns.barplot(y="well", x="Ct", data=ct_df)</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/32f/a42/de3/32fa42de3ad35392ac0bbf7ae6f595b3.png"><br><br>  ,       D2/4/6 (      ¬´v3¬ª),  B2/4/6 (  ¬´v1¬ª).   v1  v3     ,   v3  4X     NEB,     .      30    (F2, F4),   -,    ,         . <br><br>       qPCR,    . <br><br><pre> <code class="python hljs">f, ax = plt.subplots(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)) ax.set_color_cycle([<span class="hljs-string"><span class="hljs-string">'#fb6a4a'</span></span>, <span class="hljs-string"><span class="hljs-string">'#de2d26'</span></span>, <span class="hljs-string"><span class="hljs-string">'#a50f15'</span></span>, <span class="hljs-string"><span class="hljs-string">'#74c476'</span></span>, <span class="hljs-string"><span class="hljs-string">'#31a354'</span></span>, <span class="hljs-string"><span class="hljs-string">'#006d2c'</span></span>, <span class="hljs-string"><span class="hljs-string">'#08519c'</span></span>, <span class="hljs-string"><span class="hljs-string">'#6baed6'</span></span>]) amp0 = pp_data[<span class="hljs-string"><span class="hljs-string">'amp0'</span></span>][<span class="hljs-string"><span class="hljs-string">'SYBR'</span></span>][<span class="hljs-string"><span class="hljs-string">'baseline_subtracted'</span></span>] _ = [plt.plot(amp0[w_n[well]], label=well) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> well <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'B2'</span></span>, <span class="hljs-string"><span class="hljs-string">'B4'</span></span>, <span class="hljs-string"><span class="hljs-string">'B6'</span></span>, <span class="hljs-string"><span class="hljs-string">'D2'</span></span>, <span class="hljs-string"><span class="hljs-string">'D4'</span></span>, <span class="hljs-string"><span class="hljs-string">'D6'</span></span>, <span class="hljs-string"><span class="hljs-string">'F2'</span></span>, <span class="hljs-string"><span class="hljs-string">'F4'</span></span>]] _ = ax.set_ylim(<span class="hljs-number"><span class="hljs-number">0</span></span>,) _ = plt.title(<span class="hljs-string"><span class="hljs-string">"qPCR (reds=Gibson v1, greens=Gibson v3, blues=control)"</span></span>) _ = plt.legend(bbox_to_anchor=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">.75</span></span>), bbox_transform=plt.gcf().transFigure)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/88e/d2a/a19/88ed2aa19537b77b3214e6b36f55fdde.png"><br><br>  ,  qPCR  ,               .   v3    ,  v1,    . <br><br><h3> :     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The gel is also very clean, shows strong bands just below 1kb in bands B2, B4, B6, D2, D4, D6: this is exactly the size we expect (insertion is about 740bp, and primers M13 are about 40bp up and down). </font><font style="vertical-align: inherit;">The second bar corresponds to the primers. </font><font style="vertical-align: inherit;">You can be sure of this, since the F2 and F4 bands contain only primer DNA. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf7/509/629/cf750962951b700c8a9333ea1d747a94.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyacrylamide gel electrophoresis: with the Gibson v3 assembly shows stronger bands (D2, D4, D6), in accordance with the qPCR data given above</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 4. Transformation </font></font></h2><br> <a href="https://en.wikipedia.org/wiki/Transformation_(genetics)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the process of changing the body by adding DNA. </font><font style="vertical-align: inherit;">In this experiment, we </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transform </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E. coli</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the sfGFP-expressing plasmid pUC19. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use an easy-to-work strain </font></font><a href="http://www.zymoresearch.com/e-coli/chemically-competent-cells/strain-zymo5alpha"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zymo DH5Œ± Mix &amp; Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><a href="http://www.zymoresearch.com/downloads/dl/file/id/173/t3015i.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recommended protocol</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This strain is part of the standard Transcriptic inventory. </font><font style="vertical-align: inherit;">In general, transformations can be complex, since competent cells are quite fragile, so the simpler and more reliable the protocol, the better. </font><font style="vertical-align: inherit;">In ordinary molecular biology laboratories, these competent cells would probably be too expensive for general use. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/951/9a6/a57/9519a6a578f11d26c3c9a2ddda039539.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zymo Mix &amp; Go cells with simple protocol</font></font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem with robots </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This protocol is a good example of how difficult it is to adapt human protocols for use by robots and how it may unexpectedly fail. Protocols are sometimes surprisingly vague (‚Äúshake the tube from side to side‚Äù), based on the general context of molecular biologists, or they can suddenly request advanced image processing (‚Äúmake sure the sediment is stirred‚Äù). People do not mind such tasks, but the robots need clearer instructions.</font></font><br><br>        .   ,                  37¬∞C. ,      ,      ,  ,   Transcriptic     ‚Äî   ,      .     , ,       -    ,    . .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are usually reasonable solutions: sometimes you just need to use different reagents (for example, more durable cells, such as Mix &amp; Go above); </font><font style="vertical-align: inherit;">sometimes you just lay actions with a margin (for example, shake ten times instead of three); </font><font style="vertical-align: inherit;">Sometimes you need to come up with special tricks for robots (for example, use a PCR machine for heat stroke). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the big advantage is that, once the protocol has worked once, you can generally rely on it again and again. </font><font style="vertical-align: inherit;">You can even quantify how reliable the protocol is and improve it over time!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test transformation </font></font></h2><br>        ,    ,  ,      pUC19 (. .        sfGFP) . pUC19     ,         ,   . <br><br>       (¬´6-flat¬ª   Transcriptic),    ,  .  ,         , ,  .     . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Simple transformation protocol: transformation with unaltered pUC19"""</span></span> p = Protocol() experiment_name = <span class="hljs-string"><span class="hljs-string">"debug_sfgfp_puc19_gibson_v1"</span></span> inv = { <span class="hljs-string"><span class="hljs-string">"water"</span></span> : <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "DH5a" : "rs16pbj944fnny", # catalog; Zymo DH5Œ±; cold_80 "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "pUC19" : "rs17tcqmncjfsh", # catalog; pUC19; cold_20 } # Catalog transform_plate = p.ref("transform_plate", cont_type="96-pcr", storage="ambient", discard=True) transform_tube = transform_plate.well(0) # ------------------------------------------------------------------------------------ # Plating transformed bacteria according to Tali's protocol (requires different code!) # http://learn.transcriptic.com/blog/2015/9/9/provisioning-commercial-reagents # Add 1-5ul plasmid and pre-warm culture plates to 37C before starting. # # # Extra inventory for plating # inv["lb-broth-100ug-ml-amp_6-flat"] = "ki17sbb845ssx9" # (kit, not normal ref) from blogpost inv["noAB-amp_6-flat"] = "ki17reefwqq3sq" # kit id inv["LB Miller"] = "rs17bafcbmyrmh" # # Ampicillin and no ampicillin plates # amp_6_flat = Container(None, p.container_type('6-flat')) p.refs["amp_6_flat"] = Ref('amp_6_flat', {"reserve": inv['lb-broth-100ug-ml-amp_6-flat'], "store": {"where": 'cold_4'}}, amp_6_flat) noAB_6_flat = Container(None, p.container_type('6-flat')) p.refs["noAB_6_flat"] = Ref('noAB_6_flat', {"reserve": inv['noAB-amp_6-flat'], "store": {"where": 'cold_4'}}, noAB_6_flat) # # Provision competent bacteria # p.provision(inv["DH5a"], transform_tube, ¬µl(50)) p.provision(inv["pUC19"], transform_tube, ¬µl(2)) # # Heatshock the bacteria to transform using a PCR machine # p.seal(transform_plate) p.thermocycle(transform_plate, [{"cycles": 1, "steps": [{"temperature": "4:celsius", "duration": "5:minute"}]}, {"cycles": 1, "steps": [{"temperature": "37:celsius", "duration": "30:minute"}]}], volume=¬µl(50)) p.unseal(transform_plate) # # Then dilute bacteria and spread onto 6-flat plates # Put more on ampicillin plates for more opportunities to get a colony # p.provision(inv["LB Miller"], transform_tube, ¬µl(355)) p.mix(transform_tube, ¬µl(150), repetitions=5) for i in range(6): p.spread(transform_tube, amp_6_flat.well(i), ¬µl(55)) p.spread(transform_tube, noAB_6_flat.well(i), ¬µl(10)) assert transform_tube.volume &gt;= ¬µl(15), transform_tube.volume # # Incubate and image 6-flat plates over 18 hours # for flat_name, flat in [("amp_6_flat", amp_6_flat), ("noAB_6_flat", noAB_6_flat)]: for timepoint in [6,12,18]: p.cover(flat) p.incubate(flat, "warm_37", "6:hour") p.uncover(flat) p.image_plate(flat, mode="top", dataref=expid("{}_t{}".format(flat_name, timepoint))) # --------------------------------------------------------------- # Analyze protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("Protocol {}\n\n{}".format(experiment_name, protocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> ‚úì Protocol analyzed<font></font>
  43 instructions<font></font>
  3 containers<font></font>
  $45.43 </pre><br><h3> :   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the following photos, we see that without the antibiotic (the plate on the left), growth is observed on all six plates, although strongly to varying degrees, which causes concern. It seems that Transcriptic robots do not really cope with the uniform distribution, which requires some dexterity.</font></font><br><br>    ( )   ,    .       ,   , , ,    55        10     .               .        ,    .        ,       ,         . <br><br> (          ,        ,    ,        <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E. coli</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Growth is much weaker on plates with ampicillin, although there are much more bacteria, as expected). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the transformation worked well enough to continue, although there are some flaws. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/c9b/7e2/296c9b7e28b653015159907b8a2bb59e.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plates of cells transformed with pUC19, after 18 hours: without antibiotic (left) and with antibiotic (right)</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Product Transformation After Assembly </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the Gibson assembly and simple transformation of pUC19 seem to work, you can now try the transformation with a fully assembled plasmid expressing sfGFP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the assembled insertion, I will also add some IPTG and X-gal to the plates to see a successful transformation using the </font></font><a href="https://en.wikipedia.org/wiki/Blue_white_screen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blue-white selection</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This additional information is useful, because if a transformation with the usual pUC19, which does not contain sfGFP, goes through, it will still give resistance to antibiotics.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absorption and fluorescence </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to this </font></font><a href="http://www.biotek.com/assets/tech_resources/Filter%2520Combinations.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sfGFP shines best at excitation wavelengths of 485 nm / 510 nm. </font><font style="vertical-align: inherit;">I found that 485/535 works better in Transcriptic. </font><font style="vertical-align: inherit;">I guess because 485 and 510 are too similar. </font><font style="vertical-align: inherit;">I measure bacterial growth at 600 nm ( </font></font><a href="https://en.wikipedia.org/wiki/OD600"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OD600</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ab/0d3/453/6ab0d345359a5b1d15f8f6341f1bee08.png"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A variety of GFP ( </font></font><a href="http://www.biotek.com/assets/tech_resources/Filter%2520Combinations.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biotek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPTG and X-gal </font></font></h4><br>  IPTG    1M    1:1000.   , X-gal   20 /    1:1000 (20 /). ,  2000¬µl LB    2  . <br><br>   <a href="http://www.bios.niu.edu/johns/recdna/blue_white.htm"></a>    40  X-gal   20 /  40  IPTG  0,1 mM ( 4  IPTG  1M),   30 .      ,     IPTG, X-gal        . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Full Gibson assembly and transformation protocol for sfGFP and pUC19 v1: Spread IPTG and X-gal onto plates, then spread cells v2: Mix IPTG, X-gal and cells; spread the mixture v3: exclude X-gal so I can do colony picking better v4: repeat v3 to try other excitation/emission wavelengths"""</span></span> p = Protocol() options = { <span class="hljs-string"><span class="hljs-string">"gibson"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-comment"><span class="hljs-comment"># do a new gibson assembly "sanger" : False, # sanger sequence product "control_pUC19" : True, # unassembled pUC19 "XGal" : False # excluding X-gal should make the colony picking easier } for k, v in list(options.items()): if v is False: del options[k] experiment_name = "sfgfp_puc19_gibson_plates_v4" # ----------------------------------------------------------------------- # Inventory # inv = { # catalog "water" : "rs17gmh5wafm5p", # catalog; Autoclaved MilliQ H2O; ambient "DH5a" : "rs16pbj944fnny", # catalog; Zymo DH5Œ±; cold_80 "Gibson Mix" : "rs16pfatkggmk5", # catalog; Gibson Mix (2X); cold_20 "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "pUC19" : "rs17tcqmncjfsh", # catalog; pUC19; cold_20 # my inventory "puc19_cut_v2": "ct187v4ea7vvca", # inventory; pUC19 cut with EcoRI; cold_20 "IPTG" : "ct18a2r5wn6tqz", # inventory; IPTG at 1M (conc semi-documented); cold_20 "XGal" : "ct18a2r5wp5hcv", # inventory; XGal at 0.1M (conc not documented); cold_20 "sfgfp_pcroe_v8_amplified" : "ct1874zqh22pab", # inventory; sfGFP amplified to 40ng/ul; cold_4 "sfgfp_puc19_gibson_v3_clone" : "ct188ejywa8jcv", # inventory; assembled sfGFP; cold_4 # kits (must be used differently) "lb-broth-100ug-ml-amp_6-flat" : "ki17sbb845ssx9", # catalog; ampicillin plates "noAB-amp_6-flat" : "ki17reefwqq3sq" # catalog; no antibiotic plates } # # Catalog (all to be discarded afterward) # water_tube = p.ref("water", cont_type="micro-1.5", storage="ambient", discard=True).well(0) transform_plate = p.ref("trn_plate", cont_type="96-pcr", storage="ambient", discard=True) transform_tube = transform_plate.well(39) # experiment transform_tube_L = p.ref("trn_tubeL", cont_type="micro-1.5", storage="ambient", discard=True).well(0) transctrl_tube = transform_plate.well(56) # control transctrl_tube_L = p.ref("trc_tubeL", cont_type="micro-1.5", storage="ambient", discard=True).well(0) # # Plating according to Tali's protocol # http://learn.transcriptic.com/blog/2015/9/9/provisioning-commercial-reagents # amp_6_flat = Container(None, p.container_type('6-flat')) p.refs[expid("amp_6_flat")] = Ref(expid("amp_6_flat"), {"reserve": inv['lb-broth-100ug-ml-amp_6-flat'], "store": {"where": 'cold_4'}}, amp_6_flat) noAB_6_flat = Container(None, p.container_type('6-flat')) p.refs[expid("noAB_6_flat")] = Ref(expid("noAB_6_flat"), {"reserve": inv['noAB-amp_6-flat'], "store": {"where": 'cold_4'}}, noAB_6_flat) # # My inventory: EcoRI-cut pUC19, oePCR'd sfGFP, Gibson-assembled pUC19, IPTG and X-Gal # if "gibson" in options: puc19_cut_tube = p.ref("puc19_ecori_v2_puc19_cut", id=inv["puc19_cut_v2"], cont_type="micro-1.5", storage="cold_20").well(0) sfgfp_pcroe_amp_tube = p.ref("sfgfp_pcroe_v8_amplified", id=inv["sfgfp_pcroe_v8_amplified"], cont_type="micro-1.5", storage="cold_4").well(0) clone_plate = p.ref(expid("clone"), cont_type="96-pcr", storage="cold_4", discard=False) else: clone_plate = p.ref("sfgfp_puc19_gibson_v3_clone", id=inv["sfgfp_puc19_gibson_v3_clone"], cont_type="96-pcr", storage="cold_4", discard=False) IPTG_tube = p.ref("IPTG", id=inv["IPTG"], cont_type="micro-1.5", storage="cold_20").well(0) if "XGal" in options: XGal_tube = p.ref("XGal", id=inv["XGal"], cont_type="micro-1.5", storage="cold_20").well(0) # # Initialize inventory # if "gibson" in options: all_inventory_wells = [puc19_cut_tube, sfgfp_pcroe_amp_tube, IPTG_tube] assert puc19_cut_tube.volume == ¬µl(66), puc19_cut_tube.volume assert sfgfp_pcroe_amp_tube.volume == ¬µl(36), sfgfp_pcroe_amp_tube.volume else: all_inventory_wells = [IPTG_tube, clone_plate.well(0)] if "XGal" in options: all_inventory_wells.append(XGal_tube) for well in all_inventory_wells: init_inventory_well(well) print("Inventory: {} {} {}".format(well.name, well.volume, well.properties)) # # Provisioning. Water is used all over the protocol. Provision an excess since it's cheap # p.provision(inv["water"], water_tube, ¬µl(500)) # ----------------------------------------------------------------------------- # Cloning/assembly (see NEBuilder protocol above) # # "Optimized efficiency is 50‚Äì100 ng of vectors with 2 fold excess of inserts." # pUC19 is 20ng/ul (78ul total). # sfGFP is ~40ng/ul (48ul total) # Therefore 4ul of each gives 80ng and 160ng of vector and insert respectively # def do_gibson_assembly(): # # Combine all the Gibson reagents in one tube and thermocycle # p.provision(inv["Gibson Mix"], clone_plate.well(0), ¬µl(10)) p.transfer(water_tube, clone_plate.well(0), ¬µl(2)) p.transfer(puc19_cut_tube, clone_plate.well(0), ¬µl(4)) p.transfer(sfgfp_pcroe_amp_tube, clone_plate.well(0), ¬µl(4), mix_after=True, mix_vol=¬µl(10), repetitions=10) p.seal(clone_plate) p.thermocycle(clone_plate, [{"cycles": 1, "steps": [{"temperature": "50:celsius", "duration": "16:minute"}]}], volume=¬µl(50)) # # Dilute assembled plasmid 4X according to the NEB Gibson assembly protocol (20ul-&gt;80ul) # p.unseal(clone_plate) p.transfer(water_tube, clone_plate.well(0), ¬µl(60), mix_after=True, mix_vol=¬µl(40), repetitions=5) return # -------------------------------------------------------------------------------------------------- # Transformation # "Transform NEB 5-alpha Competent E. coli cells with 2 Œºl of the # assembled product, following the appropriate transformation protocol." # # Mix &amp; Go http://www.zymoresearch.com/downloads/dl/file/id/173/t3015i.pdf # "[After mixing] Immediately place on ice and incubate for 2-5 minutes" # "The highest transformation efficiencies can be obtained by incubating Mix &amp; Go cells with DNA on # ice for 2-5 minutes (60 minutes maximum) prior to plating." # "It is recommended that culture plates be pre-warmed to &gt;20¬∞C (preferably 37¬∞C) prior to plating." # "Avoid exposing the cells to room temperature for more than a few seconds at a time." # # "If competent cells are purchased from other manufacture, dilute assembled products 4-fold # with H2O prior transformation. This can be achieved by mixing 5 Œºl of assembled products with # 15 Œºl of H2O. Add 2 Œºl of the diluted assembled product to competent cells." # def _do_transformation(): # # Combine plasmid and competent bacteria in a pcr_plate and shock # p.provision(inv["DH5a"], transform_tube, ¬µl(50)) p.transfer(clone_plate.well(0), transform_tube, ¬µl(3), dispense_speed="10:microliter/second") assert clone_plate.well(0).volume == ¬µl(54), clone_plate.well(0).volume if 'control_pUC19' in options: p.provision(inv["DH5a"], transctrl_tube, ¬µl(50)) p.provision(inv["pUC19"], transctrl_tube, ¬µl(1)) # # Heatshock the bacteria to transform using a PCR machine # p.seal(transform_plate) p.thermocycle(transform_plate, [{"cycles": 1, "steps": [{"temperature": "4:celsius", "duration": "5:minute"}]}, {"cycles": 1, "steps": [{"temperature": "37:celsius", "duration": "30:minute"}]}], volume=¬µl(50)) return def _transfer_transformed_to_plates(): assert transform_tube.volume == ¬µl(53), transform_tube.volume p.unseal(transform_plate) num_ab_plates = 4 # antibiotic places # # Transfer bacteria to a bigger tube for diluting # Then spread onto 6-flat plates # Generally you would spread 50-100ul of diluted bacteria # Put more on ampicillin plates for more opportunities to get a colony # I use a dilution series since it's unclear how much to plate # p.provision(inv["LB Miller"], transform_tube_L, ¬µl(429)) # # Add all IPTG and XGal to the master tube # 4ul (1M) IPTG on each plate; 40ul XGal on each plate # p.transfer(IPTG_tube, transform_tube_L, ¬µl(4*num_ab_plates)) if 'XGal' in options: p.transfer(XGal_tube, transform_tube_L, ¬µl(40*num_ab_plates)) # # Add the transformed cells and mix (use new mix op in case of different pipette) # p.transfer(transform_tube, transform_tube_L, ¬µl(50)) p.mix(transform_tube_L, volume=transform_tube_L.volume/2, repetitions=10) assert transform_tube.volume == dead_volume['96-pcr'] == ¬µl(3), transform_tube.volume assert transform_tube_L.volume == ¬µl(495), transform_tube_L.volume # # Spread an average of 60ul on each plate == 480ul total # for i in range(num_ab_plates): p.spread(transform_tube_L, amp_6_flat.well(i), ¬µl(51+i*6)) p.spread(transform_tube_L, noAB_6_flat.well(i), ¬µl(51+i*6)) assert transform_tube_L.volume == dead_volume["micro-1.5"], transform_tube_L.volume # # Controls: include 2 ordinary pUC19-transformed plates as a control # if 'control_pUC19' in options: num_ctrl = 2 assert num_ab_plates + num_ctrl &lt;= 6 p.provision(inv["LB Miller"], transctrl_tube_L, ¬µl(184)+dead_volume["micro-1.5"]) p.transfer(IPTG_tube, transctrl_tube_L, ¬µl(4*num_ctrl)) if "XGal" in options: p.transfer(XGal_tube, transctrl_tube_L, ¬µl(40*num_ctrl)) p.transfer(transctrl_tube, transctrl_tube_L, ¬µl(48)) p.mix(transctrl_tube_L, volume=transctrl_tube_L.volume/2, repetitions=10) for i in range(num_ctrl): p.spread(transctrl_tube_L, amp_6_flat.well(num_ab_plates+i), ¬µl(55+i*10)) p.spread(transctrl_tube_L, noAB_6_flat.well(num_ab_plates+i), ¬µl(55+i*10)) assert transctrl_tube_L.volume == dead_volume["micro-1.5"], transctrl_tube_L.volume assert IPTG_tube.volume == ¬µl(808), IPTG_tube.volume if "XGal" in options: assert XGal_tube.volume == ¬µl(516), XGal_tube.volume return def do_transformation(): _do_transformation() _transfer_transformed_to_plates() # ------------------------------------------------------ # Measure growth in plates (photograph) # def measure_growth(): # # Incubate and photograph 6-flat plates over 18 hours # to see blue or white colonies # for flat_name, flat in [(expid("amp_6_flat"), amp_6_flat), (expid("noAB_6_flat"), noAB_6_flat)]: for timepoint in [9,18]: p.cover(flat) p.incubate(flat, "warm_37", "9:hour") p.uncover(flat) p.image_plate(flat, mode="top", dataref=expid("{}_t{}".format(flat_name, timepoint))) return # --------------------------------------------------------------- # Sanger sequencing, TURNED OFF # Sequence to make sure assembly worked # 500ng plasmid, 1 ¬µl of a 10 ¬µM stock primer # "M13_F" : "rs17tcpqwqcaxe", # catalog; M13 Forward (-41); cold_20 (1ul = 100pmol) # "M13_R" : "rs17tcph6e2qzh", # catalog; M13 Reverse (-48); cold_20 (1ul = 100pmol) # def do_sanger_seq(): seq_primers = [inv["M13_F"], inv["M13_R"]] seq_wells = ["G1","G2"] p.unseal(pcr_plate) for primer_num, seq_well in [(0, seq_wells[0]),(1, seq_wells[1])]: p.provision(seq_primers[primer_num], pcr_plate.wells([seq_well]), ¬µl(1)) p.transfer(pcr_plate.wells(["A1"]), pcr_plate.wells(seq_wells), ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(water_tube, pcr_plate.wells(seq_wells), ¬µl(9)) p.mix(pcr_plate.wells(seq_wells), volume=¬µl(7.5), repetitions=10) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[0]).indices(), expid("seq1")) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[1]).indices(), expid("seq2")) return # --------------------------------------------------------------- # Generate protocol # # Skip Gibson since I already did it if 'gibson' in options: do_gibson_assembly() do_transformation() measure_growth() if 'sanger' in options: do_sanger_seq() # --------------------------------------------------------------- # Output protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("\nProtocol {}\n\n{}".format(experiment_name, jprotocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> Inventory: IPTG/IPTG/IPTG/IPTG/IPTG/IPTG 832.0:microliter {}<font></font>
Inventory: sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone 57.0:microliter {}<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  40 instructions<font></font>
  8 containers<font></font>
  Total Cost: $53.20<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Workcell Time: $ 17.35</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Reagents &amp; Consumables: $ 35.86 </font></font></pre><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collecting the colonies </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When colonies grow on an ampicillin plate, I can ‚Äúcollect‚Äù individual colonies and plant them on a 96-tube plate. </font><font style="vertical-align: inherit;">For this, there is a special command ( </font></font><a href="http://autoprotocol-python.readthedocs.org/en/latest/autoprotocol.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autopick</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">in the autoprotocol </font><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Pick colonies from plates and grow in amp media and check for fluorescence. v2: try again with a new plate (no blue colonies) v3: repeat with different emission and excitation wavelengths"""</span></span> p = Protocol() options = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(options.items()): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> options[k] experiment_name = <span class="hljs-string"><span class="hljs-string">"sfgfp_puc19_gibson_pick_v3"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plate_expid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""refer to the previous plating experiment's outputs"""</span></span> plate_exp = <span class="hljs-string"><span class="hljs-string">"sfgfp_puc19_gibson_plates_v4"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{}_{}"</span></span>.format(plate_exp, val) <span class="hljs-comment"><span class="hljs-comment"># ----------------------------------------------------------------------- # Inventory # inv = { # catalog "water" : "rs17gmh5wafm5p", # catalog; Autoclaved MilliQ H2O; ambient "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "IPTG" : "ct18a2r5wn6tqz", # inventory; IPTG at 1M (conc semi-documented); cold_20 # plates from previous experiment, must be changed every new experiment plate_expid("amp_6_flat") : "ct18snmr9avvg9", # inventory; Ampicillin plates with blue-white screening of pUC19 plate_expid("noAB_6_flat") : "ct18snmr9dxfw2", # inventory; no AB plates with blue-white screening of pUC19 } # Tubes and plates lb_amp_tubes = [p.ref("lb_amp_{}".format(i+1), cont_type="micro-2.0", storage="ambient", discard=True).well(0) for i in range(4)] lb_xab_tube = p.ref("lb_xab", cont_type="micro-2.0", storage="ambient", discard=True).well(0) growth_plate = p.ref(expid("growth"), cont_type="96-flat", storage="cold_4", discard=False) # My inventory IPTG_tube = p.ref("IPTG", id=inv["IPTG"], cont_type="micro-1.5", storage="cold_20").well(0) # ampicillin plate amp_6_flat = Container(None, p.container_type('6-flat')) p.refs[plate_expid("amp_6_flat")] = Ref(plate_expid("amp_6_flat"), {"id":inv[plate_expid("amp_6_flat")], "store": {"where": 'cold_4'}}, amp_6_flat) # Use a total of 50 wells abs_wells = ["{}{}".format(row,col) for row in "BCDEF" for col in range(1,11)] abs_wells_T = ["{}{}".format(row,col) for col in range(1,11) for row in "BCDEF"] assert abs_wells[:3] == ["B1","B2","B3"] and abs_wells_T[:3] == ["B1","C1","D1"] def prepare_growth_wells(): # # To LB, add ampicillin at ~1/1000 concentration # Mix slowly in case of overflow # p.provision(inv["LB Miller"], lb_xab_tube, ¬µl(1913)) for lb_amp_tube in lb_amp_tubes: p.provision(inv["Amp 100mgml"], lb_amp_tube, ¬µl(2)) p.provision(inv["LB Miller"], lb_amp_tube, ¬µl(1911)) p.mix(lb_amp_tube, volume=¬µl(800), repetitions=10) # # Add IPTG but save on X-Gal # http://openwetware.org/images/f/f1/Dh5a_sub.pdf # "If you are concerned about obtaining maximal levels of expression, add IPTG to a final concentration of 1 mM." # 2ul of IPTG in 2000ul equals 1mM # p.transfer(IPTG_tube, [lb_xab_tube] + lb_amp_tubes, ¬µl(2), one_tip=True) # # Distribute LB among wells, row D is control (no ampicillin) # cols = range(1,11) row = "D" # control, no AB cwells = ["{}{}".format(row,col) for col in cols] assert set(cwells).issubset(set(abs_wells)) p.distribute(lb_xab_tube, growth_plate.wells(cwells), ¬µl(190), allow_carryover=True) rows = "BCEF" for row, lb_amp_tube in zip(rows, lb_amp_tubes): cwells = ["{}{}".format(row,col) for col in cols] assert set(cwells).issubset(set(abs_wells)) p.distribute(lb_amp_tube, growth_plate.wells(cwells), ¬µl(190), allow_carryover=True) assert all(lb_amp_tube.volume == lb_xab_tube.volume == dead_volume['micro-2.0'] for lb_amp_tube in lb_amp_tubes) return def measure_growth_wells(): # # Growth: absorbance and fluorescence over 24 hours # Absorbance at 600nm: cell growth # Absorbance at 615nm: X-gal, in theory # Fluorescence at 485nm/510nm: sfGFP # or 450nm/508nm (http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2695656/) # hr = 4 for t in range(0,24,hr): if t &gt; 0: p.cover(growth_plate) p.incubate(growth_plate, "warm_37", "{}:hour".format(hr), shaking=True) p.uncover(growth_plate) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="485:nanometer", emission="535:nanometer", dataref=expid("fl2_{}".format(t)), flashes=25) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="450:nanometer", emission="508:nanometer", dataref=expid("fl1_{}".format(t)), flashes=25) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="395:nanometer", emission="508:nanometer", dataref=expid("fl0_{}".format(t)), flashes=25) p.absorbance(growth_plate, growth_plate.wells(abs_wells).indices(), wavelength="600:nanometer", dataref=expid("abs_{}".format(t)), flashes=25) return # --------------------------------------------------------------- # Protocol steps # prepare_growth_wells() batch = 10 for i in range(5): p.autopick(amp_6_flat.well(i), growth_plate.wells(abs_wells_T[i*batch:i*batch+batch]), dataref=expid("autopick_{}".format(i))) p.image_plate(amp_6_flat, mode="top", dataref=expid("autopicked_{}".format(i))) measure_growth_wells() # --------------------------------------------------------------- # Output protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚úì Protocol analyzed</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  62 instructions</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  8 containers</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Total Cost: $ 66.38</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Workcell Time: $ 57.59</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Reagents &amp; Consumables: $ 8.78 </font></font></pre><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results: collection of colonies </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The blue-white screen perfectly showed mainly white colonies on plates with antibiotics (1-4) and only blue ones on plates without antibiotics (5-6). This is exactly what I expected, and I was glad to see it, especially since I used my own IPTG and X-gal, which I sent to Transcriptic. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc4/d2b/c10/bc4d2bc102d423993907a021598257ef.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screening using white-blue plate selection with ampicillin (1-4) and without antibiotic (5-6)</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, the robot-collector of colonies did not work well with these white-blue colonies. The image below is created by subtracting consecutive photographs of the plates after each round of plate selection and increasing the contrast of the differences (in </font></font><a href="http://www.graphicsmagick.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraphicsMagick</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). In this way, I can visualize which colonies were collected (although not perfect, because the collected colonies are not completely removed).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also signed the image with the number of colonies collected by the Transcriptic robot. It was assumed that he will collect a maximum of 10 colonies from the first five plates. However, several colonies were generally collected, and these are usually blue colonies. The robot only managed to find ten colonies on a control plate with only blue colonies. My working theory is that a robot collecting colonies preferably collects blue colonies, since they are more contrasting. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8f/ee9/b71/c8fee9b710a214fdb7421dbc2d74e1b4.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screening plates for white-blue breeding with ampicillin (1-4) and without antibiotic (5-6), indicating the number of collected colonies</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The blue-white screening served a specific purpose. </font><font style="vertical-align: inherit;">He showed that most colonies are transformed correctly. </font><font style="vertical-align: inherit;">At least there is an insertion. </font><font style="vertical-align: inherit;">However, for a better collection of colonies, I repeated the experiment without X-gal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only with white colonies, the robot assembler successfully collected ten colonies from each of the first five plates. </font><font style="vertical-align: inherit;">It can be assumed that in most of the collected colonies there are successful insertions. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cb/6f1/835/2cb6f183502e484f66e1f95ba1b44ed7.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colonies growing on plates with ampicillin (1-4) and without antibiotic (5-6)</font></font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results: transformation with the collected product </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After growing 50 selected colonies on a 96-well plate for 20 hours, I measure the fluorescence to check for sfGFP expression. Transcriptic uses a </font></font><a href="http://lifesciences.tecan.com/products/reader_and_washer/microplate_readers/infinite_200_pro"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tecan Infinite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reader to measure fluorescence and absorption (and luminescence, if you want) </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In theory, an assembled plasmid should be collected in any colony with growth, since it needs antibiotic resistance for growth, and each assembled plasmid expresses sfGFP. In fact, there are many reasons why this may not be the case, not least because you can lose the sfGFP gene from a plasmid without losing resistance to ampicillin. A bacterium that loses the sfGFP gene has an advantage in selection over its competitors, because it does not waste excess energy, and with a sufficient number of generations of growth, this will definitely happen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I collect absorption (OD600) and fluorescence data every four hours for 20 hours (about 60 generations).</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>]: abs_data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">"glow/sfgfp_puc19_gibson_pick_v3_abs_{}.csv"</span></span>.format(t), index_col=<span class="hljs-string"><span class="hljs-string">"Well"</span></span>) flr_data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">"glow/sfgfp_puc19_gibson_pick_v3_fl2_{}.csv"</span></span>.format(t), index_col=<span class="hljs-string"><span class="hljs-string">"Well"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t == <span class="hljs-number"><span class="hljs-number">0</span></span>: new_data = abs_data.join(flr_data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new_data = new_data.join(abs_data, rsuffix=<span class="hljs-string"><span class="hljs-string">'_{}'</span></span>.format(t)) new_data = new_data.join(flr_data, rsuffix=<span class="hljs-string"><span class="hljs-string">'_{}'</span></span>.format(t)) new_data.columns = [<span class="hljs-string"><span class="hljs-string">"OD 600:nanometer_0"</span></span>, <span class="hljs-string"><span class="hljs-string">"Fluorescence_0"</span></span>] + list(new_data.columns[<span class="hljs-number"><span class="hljs-number">2</span></span>:])</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We place on the chart the data of the 20th hour and the traces of previous measurements. Actually, I am only interested in the latest data, since that is when the peak of fluorescence should be observed.</font></font><br><br><pre> <code class="python hljs">svg = [] W, H = <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> min_x, max_x = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span> min_y, max_y = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_toxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> W*(x-min_x)/(max_x-min_x), HH*(y-min_y)/(max_y-min_y) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_topt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span>.join(map(str,_toxy(x,y))) ab_fls = [[row[<span class="hljs-number"><span class="hljs-number">0</span></span>]] + [list(row[<span class="hljs-number"><span class="hljs-number">1</span></span>])] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data.iterrows()] <span class="hljs-comment"><span class="hljs-comment"># axes svg.append('&lt;g fill="#888" font-size="18" transform="translate(20,0),scale(.95)"&gt;') svg.append('&lt;text x="0" y="{}"&gt;OD600 ‚Üí&lt;/text&gt;'.format(H+20)) svg.append('&lt;text x="0" y="0" transform="rotate(-90),translate(-{},-8)"&gt;Fluorescence ‚Üí&lt;/text&gt;'.format(H)) svg.append('&lt;line x1="0" y1="{}" x2="{}" y2="{}" style="stroke:#888;stroke-width:2" /&gt;'.format(H,W,H)) svg.append('&lt;line x1="0" y1="0" x2="0" y2="{}" style="stroke:#888;stroke-width:2" /&gt;'.format(H)) # glow filter svg.append("""&lt;filter id="glow" x="-200%" y="-200%" height="400%" width="400%"&gt; &lt;feColorMatrix type="matrix" values="0 0 0 0 0 255 0 0 0 0 0 0 0 0 0 0 0 0 1 0"/&gt; &lt;feGaussianBlur stdDeviation="10" result="coloredBlur"/&gt; &lt;feMerge&gt;&lt;feMergeNode in="coloredBlur"/&gt;&lt;feMergeNode in="SourceGraphic"/&gt;&lt;/feMerge&gt; &lt;/filter&gt;""") for n, (well, vals) in enumerate(ab_fls): fill = "#444" if not well.startswith("D") else "#aaa" gfilter = 'filter="url(#glow)"' if well in ["C3", "D1", "D3"] else "" cx, cy = _toxy(*vals[-2:]) svg.append('''&lt;g id="point{n:d}"&gt;&lt;circle {gfilter:s} r="12" cx="{cx:f}" cy="{cy:f}" fill="{fill:s}" /&gt; &lt;text x="{cx:f}" y="{cy:f}" font-size="10" text-anchor="middle" fill="#fff" alignment-baseline="middle"&gt;{txt:s}&lt;/text&gt;&lt;/g&gt; '''.format(n=n, cx=cx, cy=cy, fill=fill, txt=well, gfilter=gfilter)) pathd = 'M{} '.format(_topt(*vals[:2])) pathd += ' '.join("L{}".format(_topt(*vals[i:i+2])) for i in range(2,len(vals),2)) svg.append('''&lt;path d="{pathd:}" stroke="#ccc" stroke-width=".2" fill="none" id="path{n:d}"/&gt;'''.format(pathd=pathd, n=n)) svg.append("&lt;/g&gt;") # entire chart group show_svg(''.join(svg), w=W, h=H)</span></span></code> </pre> <br><br><img src="https://habrastorage.org/webt/03/z3/kk/03z3kkczqokp7nhgplib_q1bhia.png"><br> <i><font color="gray">  OD600:    ,     .   ,       sfGFP</font></i> <br><br>  <a href="https://developers.transcriptic.com/docs/plasmid-mini-prep">miniprep</a> ,    ,       13.  ,  -  miniprep       - Transcriptic,    .          (C1, D1, D3)    (B1, B3, E1),    sfGFP   <a href="http://www.drive5.com/muscle/">muscle</a> . <br><br>   C1, D3  D3      sfGFP,      B1, B3  E1       . <br><br><h4>    </h4><br>  ,    . ,           0     (40 000 ).  20-            OD600   (, -    ),      . ,     ,  , , 11-15 . <br><br>            (. .  ,  ),  ,       ,     ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on fluorescence data and sequencing results, it appears that only three of the 50 colonies produce sfGFP and fluoresce. </font><font style="vertical-align: inherit;">This is not as much as I expected. </font><font style="vertical-align: inherit;">However, since three separate growth stages have passed (on a plate, in a test tube, for miniprep), about 200 generations of growth have undergone to this stage, so there were quite a few possibilities for mutations to occur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There must be ways to make the process more efficient, especially since I am far from being an expert on these protocols. </font><font style="vertical-align: inherit;">However, we successfully produced transformed cells with the expression of engineered GFP using only Python code!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part Three: Conclusions </font></font></h1><br><h4>  Price </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depending on how to measure, the cost of this experiment was about $ 360, not counting money for debugging: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 70</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for DNA synthesis</font></font><br></li><li> <b>$32</b>  PCR       <br></li><li> <b>$31</b>    <br></li><li> <b>$32</b>    <br></li><li> <b>$53</b>   <br></li><li> <b>$67</b>    <br></li><li> <b>$75</b>  3 miniprep'   </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think that the cost can be reduced to $ 250-300 with some modifications. For example, a robotic collection of 50 colonies is suspiciously expensive and can probably be abandoned. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my experience, this price seems high for some (molecular biologists) and low for others (people from IT). Since Transcriptic basically simply charges for reagents on the price list, the main cost difference is labor. The robot already costs quite cheaply per hour, and he is not averse to getting up in the middle of the night to photograph the plate. Once the protocols have been approved, it‚Äôs hard to imagine that even a graduate student will be cheaper, especially considering the opportunity costs.</font></font><br><br>  ,       . ,    -     ,         .         ,       :      ,  ,  IDT       . <br><br><h4>  :    </h4><br> ,       .            ,                  : <br><br><ul><li> <b>!</b> ,   .              autoprotocol,     . <br></li><li> <b></b> .      100    ,    . <br></li><li> <b>  </b> , ,  PCR.       ,          ,      ?    /       ?    ,   ,      ,      ¬´  2-3 ¬ª.  ? <br></li><li> <b> </b> .          .     ,   . <br></li><li> <b></b> .       . <br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expressiveness</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can use the programming syntax to encode repeating steps or branching logic. </font><font style="vertical-align: inherit;">For example, if you want to dose from 1 to 96 Œºl of reagent and (96-x) Œºl of water into a 96-tube plate, this can be summarized.</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machine readable data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Data with the results is almost always returned in csv or other format suitable for machine processing.</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraction</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ideally, you can run the entire protocol regardless of the reagents used or the cloning style and replace something if necessary, if it works better.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, there are some drawbacks, especially since the tools have just begun to develop. </font><font style="vertical-align: inherit;">If we compare with the Internet, then we are in the area of ‚Äã‚Äã1994:</font></font><br><br><ul><li>    Transcriptic   ‚Äî  .   ,    ,         ,    .         , ,     . <br></li><li>         ‚Äî        Transcriptic. <br></li><li>   ,      .     Transcriptic     ( ,   ,     ). <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For many laboratories, it may be more expensive to use a cloud lab than just taking a graduate student to do work (marginal cost per hour: ~ $ 0). </font><font style="vertical-align: inherit;">It depends on whether the lab needs a graduate student's hands or his intellect.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transcriptic is not experimenting at the weekend yet. </font><font style="vertical-align: inherit;">They can be understood, but this is inconvenient, even if you have a small project.</font></font></li></ul><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protein Making Software </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although there is quite a lot of code and quite a lot of debugging, I think it is possible to create some kind of software that accepts a sequence of proteins at the input, and creates bacteria at the output with the expression of this protein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this to work, several things must happen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> True Twist / IDT / Gen9 integration with Transcriptic (probably, it will be slow due to low demand at present). </font></font><br></li><li>    ,    ,       , ,    . . <br></li><li>     (    NEB,    IDT)       (, <a href="http://bioinfo.ut.ee/primer3/">primer3</a> ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In many applications, you also want to purify your protein (through a </font></font><a href="https://en.wikipedia.org/wiki/Polyhistidine-tag"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">column</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) or, perhaps, simply force bacteria to </font></font><a href="http://2014.igem.org/Team:Michigan"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secrete</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it. </font><font style="vertical-align: inherit;">Suppose that soon we can do this in a cloud lab, or that we can conduct in vivo experiments (i.e., inside a bacterial cell). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many possibilities for the protocol to actually work better than a human, for example: the design of promoters and RBS to optimize the expression specific to your sequence; </font><font style="vertical-align: inherit;">experiment success probability statistics based on comparable experiments; </font><font style="vertical-align: inherit;">automated gel analysis.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why all this? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all this, it may not be entirely clear why create such a protein. </font><font style="vertical-align: inherit;">Here are some ideas:</font></font><br><br><ul><li>  <a href="https://nimasensor.com/"></a>   - //,  . <br></li><li>  <a href="http://www.the-scientist.com/%3Farticles.view/articleNo/26908/title/Synthetic-vaccine-nabs-iGEM-prize/"></a>   ,   ,  <a href="http://prosperosworld.com/problem-solving-technique2012/2012/"> </a> . <br></li><li>    <i>in vivo</i>   <a href="http://www.nature.com/articles/srep02854">split-GFP</a>  <a href="https://en.wikipedia.org/wiki/Two-hybrid_screening"> </a> . <br></li><li>  <a href="http://2014.igem.org/Team:Michigan">scFv</a>     .  scFvs   -  <a href="http://www.ncbi.nlm.nih.gov/pubmed/22230329">  </a> . <br></li><li>  <a href="https://en.wikipedia.org/wiki/Bi-specific_T-cell_engager">BiTE</a>     ,      (   ,  ). <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make a local vaccine that enters the body </font></font><a href="http://blog.booleanbiotech.com/naked%2520DNA.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">through hair follicles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (I do not recommend trying this at home).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutagenicize your protein in hundreds of different ways and see what happens. </font><font style="vertical-align: inherit;">Then scale up to 1000 or 10,000 mutations? </font><font style="vertical-align: inherit;">Can characterize GFP mutations?</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For new ideas on what's possible when designing proteins, look at hundreds </font></font><a href="http://blog.booleanbiotech.com/static/igem.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of iGEM projects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, I would like to thank </font></font><a href="https://twitter.com/BenNMiles"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ben Miles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of Transcriptic for helping to complete this project.</font></font></div><p>Source: <a href="https://habr.com/ru/post/451124/">https://habr.com/ru/post/451124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451112/index.html">Jetpack compose</a></li>
<li><a href="../451114/index.html">Indigenous microbes and research products in stores</a></li>
<li><a href="../451116/index.html">How I struggled with the Shared Element Transition and wrote my first opensource library</a></li>
<li><a href="../451118/index.html">Testing is not for beginners</a></li>
<li><a href="../451120/index.html">About the difficulties when porting Dead Cells to mobile platforms</a></li>
<li><a href="../451126/index.html">Toolbox for researchers - release one: self-organization and data visualization</a></li>
<li><a href="../451132/index.html">Consumer Driven Contracts or Gitlab CI through the eyes of QA test automation</a></li>
<li><a href="../451136/index.html">Presented by .NET 5</a></li>
<li><a href="../451144/index.html">Antiquities: technology in TV advertising</a></li>
<li><a href="../451146/index.html">Accelerate webpack build with webpack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>