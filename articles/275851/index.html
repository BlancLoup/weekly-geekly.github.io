<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explaining the inexplicable</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Friends, we are happy to continue to publish interesting materials on the most diverse aspects of working with PostgreSQL. Today's translation opens a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explaining the inexplicable</h1><div class="post__text post__text-html js-mediator-article">  <i>Friends, we are happy to continue to publish interesting materials on the most diverse aspects of working with PostgreSQL.</i>  <i>Today's translation opens a whole series of articles by <a href="http://www.depesz.com/">Hubert Lubaczewski</a> , which will certainly interest a wide circle of readers.</i> <br><br><img src="https://habrastorage.org/files/76f/c0f/0ab/76fc0f0ab4f84f7b828593a11c8d456b.jpg"><br><br>  One of the first things that the new database administrator hears is ‚Äúuse EXPLAIN‚Äù.  And at the first attempt he encounters the incomprehensible: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="sql hljs">QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------------- Sort (cost=146.63..148.65 rows=808 width=138) (actual time=55.009..55.012 rows=71 loops=1) Sort Key: n.nspname, p.proname, (pg_get_function_arguments(p.oid)) Sort Method: quicksort Memory: 43kB -&gt; Hash Join (cost=1.14..107.61 rows=808 width=138) (actual time=42.495..54.854 rows=71 loops=1) Hash Cond: (p.pronamespace = n.oid) -&gt; Seq Scan on pg_proc p (cost=0.00..89.30 rows=808 width=78) (actual time=0.052..53.465 rows=2402 loops=1) Filter: pg_function_is_visible(oid) -&gt; Hash (cost=1.09..1.09 rows=4 width=68) (actual time=0.011..0.011 rows=4 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 1kB -&gt; Seq Scan on pg_namespace n (cost=0.00..1.09 rows=4 width=68) (actual time=0.005..0.007 rows=4 loops=1) Filter: ((nspname &lt;&gt; 'pg_catalog'::name) AND (nspname &lt;&gt; 'information_schema'::name))</span></span></code> </pre> <br>  What does it mean? <br><a name="habracut"></a><br>  It is useless to try to immediately understand the above presented explain.  Let's start with something simpler.  But before that, I would like you to understand one important thing: <br><br>  <i>PostgreSQL remembers</i> <br><br>  This means that PostgreSQL stores some meta-information (information about the information).  The number of lines, the number of different values, the most common values, and so on.  For large tables, this information is based on a random sample, but in general, Postgres really knows a lot about our data. <br><br>  So let's consider a simple query and explain it: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ Seq Scan on test (cost=0.00..40.00 rows=12 width=4) Filter: (i = 1) (2 rows)</span></span></code> </pre><br>  The request is quite simple and, it seems to me, does not require any additional comments. <br><br>  In explain, the first line and all lines beginning with ‚Äú-&gt;" are operations. The remaining lines are additional information to the operation above. <br><br>  In our case, there is only one operation ‚Äî sequential scanning of the test table. <br><br>  There is also additional information about the filter. <br><br>  Sequential scanning means that PostgreSQL will ‚Äúopen‚Äù data from a table and read it.  Theoretically, he can filter (delete) rows, but, in general, he is ready to read and return the entire table as a whole. <br><br>  Why ready?  I'll explain in a minute. <br><br>  So, the Seqscan line informs us that we are scanning the table in sequential mode.  And that the table is called ‚Äútest" (although this is where one of the biggest problems of explain is hidden - it does not show a diagram, and this was shouted to me more than once). <br><br>  And what are these numbers in brackets after the operation? <br><br>  I want to ask you a question.  You have this table: <br><br><pre> <code class="sql hljs"> Table "public.t" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">-------------+---------+------------------------------------------------ id | integer | not null default nextval('t_id_seq'::regclass) some_column | integer | something | text | Indexes: "t_pkey" PRIMARY KEY, btree (id) "q" btree (some_column)</span></span></code> </pre><br>  Having the definition of this table and query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> some_column = <span class="hljs-number"><span class="hljs-number">123</span></span>;</code> </pre><br>  What do you think is the best way to fulfill this request?  Sequentially scan the table or use an index? <br><br>  If your answer is: of course, use an index, there is an index on this column, so this method will be faster - then I will ask: what about the situation when there is only one row in the table and it contains some_column value equal to 123? <br><br>  To perform a sequential scan, I need to read just one page of the table (8192 bytes), and I‚Äôll get a row.  In order to use an index, I need to read a page from the index, check whether there are rows in the table that match the condition, and then read the page from the table. <br><br>  In the end - twice as much work! <br><br>  You could say: ‚ÄúOf course, but we are talking about very small tables, so the speed does not matter.‚Äù  Good.  Then let's imagine a table in which there are 10 billion lines, and each of them has some_column = 123. The index here does not exactly help, but in reality it will seriously worsen the situation. <br><br>  Of course, if you have a million rows and only one of them has some_column = 123, scanning the indices will be the most correct solution. <br><br>  Thus, it is impossible to say whether a given query will use an index, and whether it is necessary for it to use an index at all (we are talking about general cases).  To understand this, you need more information.  And this fact leads us to a simple conclusion: depending on the situation, one method of obtaining data will be better or worse than the other. <br><br>  PostgreSQL (up to a certain point) checks all possible scenarios.  He knows how many lines you have and how many lines (most likely) will fall under the specified criteria, so he can make very smart decisions. <br><br>  But how are these decisions made?  This is what the first set of numbers in explain shows.  This is a cost. <br><br>  Some think that costs are estimated in seconds.  This is not true.  Their unit of measurement is ‚Äúretrieving one page in a sequential order‚Äù.  That is, both time and resource utilization is estimated. <br><br>  In <i>postgresql.conf,</i> you might notice the following parameters: <br><br><pre> <code class="sql hljs">seq_page_cost = 1.0 <span class="hljs-comment"><span class="hljs-comment"># measured on an arbitrary scale random_page_cost = 4.0 # same scale as above cpu_tuple_cost = 0.01 # same scale as above cpu_index_tuple_cost = 0.005 # same scale as above cpu_operator_cost = 0.0025 # same scale as above</span></span></code> </pre><br>  That is, we can even change the cost of reading a sequential page.  These parameters set the costs that PostgreSQL assumes will be required in order to implement different methods of executing the same query. <br><br>  For example, let's create a simple table of 1000 lines with some texts and an index: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, some_text <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (some_text) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'whatever'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  We see that the launch of explain with the condition on id produces the following: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------- Index Scan using test_pkey on test (cost=0.28..8.29 rows=1 width=36) Index Cond: (id = 50) (2 rows)</span></span></code> </pre><br>  But what if we told the postgres that the index scan cannot be used under any circumstances? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Bitmap Heap Scan on test (cost=4.28..8.30 rows=1 width=13) Recheck Cond: (id = 50) -&gt; Bitmap Index Scan on test_pkey (cost=0.00..4.28 rows=1 width=0) Index Cond: (id = 50) (4 rows)</span></span></code> </pre><br>  And this, too, let's disable: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ Seq Scan on test (cost=0.00..18.50 rows=1 width=13) Filter: (id = 50) (2 rows)</span></span></code> </pre><br>  OK, and now let's display them next to each other: <br><br><pre> <code class="sql hljs">Index Scan using test_pkey on test (cost=0.28..8.29 rows=1 width=36) Bitmap Heap Scan on test (cost=4.28..8.30 rows=1 width=13) Seq Scan on test (cost=0.00..18.50 rows=1 width=13)</code> </pre><br>  By default postgres uses IndexScan.  Why?  Everything is simple - in this case it is the least expensive way.  Costs will be 8.29, while bitmap heap scan (whatever it is) will require 8.30, and for seq scan - 18.5. <br><br>  OK, but the costs are indicated by two numbers: number..number.  What is it and why am I talking only about the second number?  If we took the first number into account, then the winner would be seq scan, since this value is zero for it, and 0.28 for indexscan, and even 4.28 for bitmap heap scan. <br><br>  The cost value is displayed in the range (number ..number), because it shows the cost per line of the beginning of the operation and the cost of getting all the lines (by all we mean the results returned by this operation, not all that are in the table). <br><br>  What are the initial costs?  For seqscan there are none - you just read the page and return the lines.  And that's all.  But, for example, to sort a dataset, you need to read all the data and really sort it before you consider returning even the first row.  This is clearly seen in the following explain: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- Sort (cost=22.88..23.61 rows=292 width=202) Sort Key: relfilenode -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=202) (3 rows)</span></span></code> </pre><br>  Note that the initial costs for Sort are 22.88, while the total costs will be only 23.61.  So, the return of rows from Sort is insignificant in terms of costs, but their sorting is yes. <br><br>  The following information in explain is ‚Äúrows". This is an approximate number of rows, which, according to PostgreSQL, this operation can return (it can return less, for example, if there is a LIMIT). This is also very important for some operations - for example, joins (join). Combining two tables with a total of 20 rows can be done in a variety of ways, and, by and large, no matter which one. But when you combine a table of a million rows with a table of a billion rows, the way you doing is very important (i'm talking  not about inner join / left join, but rather about hash join, nested loop, merge join - if you don‚Äôt understand what this is about, don‚Äôt worry, I‚Äôll explain everything a little later). <br><br>  Of course, this number can be estimated incorrectly - for many reasons.  Sometimes it does not matter, and sometimes it does.  But we‚Äôll talk about wrong estimates later. <br><br>  The last piece of information is width.  This is a PostgreSQL estimate of how many, on average, a byte is contained in the single line returned by this operation.  For example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------- Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=202) (1 row) explain select relname, relkind from pg_class; QUERY PLAN ------------------------------------------------------------ Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=65) (1 row)</span></span></code> </pre><br>  As you can see, the limit on the number of fields has modified the width, and, therefore, the amount of data that must pass through the execution of the request. <br><br>  And now attention, the most important information: explain'y are trees.  The top node requires data from the nodes below it. <br><br>  Let's look at <a href="http://explain.depesz.com/s/84Q">this plan</a> . <br><br>  It has 5 operations: sort, hash join, seq scan, hash and again seq scan.  PostgreSQL performs the top operation ‚Äî a sort, which in turn performs the next one that is right below it (hash join) and receives data from it.  Hash join, in order to return data to the sorting, must run seq scan (by pg_proc) and hash (# 4).  And finally, hash, in order to return the data, should run a seq scan by pg_namespace. <br><br>  It is very important to understand that some operations can return data instantly or, more importantly, gradually.  For example, Seq Scan.  And some can not.  For example, here we see that Hash (# 4) has the same initial costs as its ‚Äúsub-operation‚Äù seq scan for ‚Äúall lines‚Äù.  This means that to start a hash operation (in order for it to return at least one line), you need to read all the lines from its suboperations. <br><br>  The part about gradual return of strings becomes especially important when you start writing functions.  Let's look at this function: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.test() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> SETOF <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> i int4; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> i; perform pg_sleep(1); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; return; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $function$;</code> </pre><br>  If you do not understand, do not worry.  The function returns 3 lines, each of which contains one integer - 1, 2 and 3. It is important that it falls asleep for 1 second after returning each line. <br><br>  This means that if I do this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>();</code> </pre><br>  I have to wait for the results for 3 seconds. <br><br>  But how long will have to wait for the return in this situation: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Let's get a look: <br><br><pre> <code class="sql hljs">\timing Timing is on. <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; test <span class="hljs-comment"><span class="hljs-comment">------ 1 (1 row) Time: 3005.334 ms</span></span></code> </pre><br>  Same 3 seconds.  Why?  Because PL / pgSQL (and most, if not all, PL / * languages) cannot return partial results.  It seems that they can - with the help of ‚Äúreturn next" - but in fact all the results are stored in a buffer and returned together when the execution of the function ends. <br><br>  On the other hand, ‚Äúnormal‚Äù operations can usually return partial data.  This can be seen if you carry out some kind of banal operation, like a sequential scan, on a difficult table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span>(<span class="hljs-string"><span class="hljs-string">'depesz'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> payload <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>) i;</code> </pre><br>  This table shows that: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------- Seq Scan on t (cost=0.00..185834.82 rows=10250082 width=36) (actual time=0.015..232.380 rows=1000000 loops=1) Total runtime: 269.666 ms (2 rows) explain analyze select * from t limit 1; QUERY PLAN -------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..0.02 rows=1 width=36) (actual time=0.003..0.003 rows=1 loops=1) -&gt; Seq Scan on t (cost=0.00..185834.82 rows=10250082 width=36) (actual time=0.003..0.003 rows=1 loops=1) Total runtime: 0.016 ms (3 rows)</span></span></code> </pre><br>  (please, look only at ‚ÄúTotal runtime: ..") <br><br>  As you can see, the sequential scan ended very quickly - as soon as the LIMIT appetite was satisfied by exactly 1 line. <br><br>  Please note that even costs (which are not the best criteria for comparing queries) show that the top node (seq scan in the first request and limit in the second) has very different values ‚Äã‚Äãfor returning all the rows - 185834.82 against 0.02. <br><br>  So the first 4 numbers for any operation (two cost estimates, number of lines and width) are approximate.  They may or may not be right. <br><br>  The other 4 numbers that you get when you run the ‚ÄúEXPLAIN ANALYZE query" or "EXPLAIN (ANALYZE on) query" show real results. <br><br>  The time is still indicated by the range, but this time is real time.  This is exactly the time PostgreSQL spent working on this operation (on average, because it could chase the same operation many times).  And just like costs, time is represented by a range: the time at which the operation begins and the time to return all data.  Let's check this plan: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..9.33 rows=100 width=608) (actual time=0.008..0.152 rows=100 loops=1) -&gt; Seq Scan on t (cost=0.00..93333.86 rows=999986 width=608) (actual time=0.007..0.133 rows=100 loops=1) Total runtime: 0.181 ms (3 rows)</span></span></code> </pre><br>  As you can see, the start time of the operation for Limit is 0.008 (the unit of measure here is milliseconds).  This happens because Seq Scan (which Limit called for data acquisition) took 0.007ms to return the first row, and then another 0.001ms was spent processing inside the limit itself. <br><br>  Then (after returning the first row), limit continued to receive data from Seq Scan until it received 100 rows.  Then he stopped the sequential scan (this happened in 0.133 ms after the beginning of the request) and ended up after another 0.019 ms. <br><br>  The actual number of rows, as the name implies, shows how many rows (on average) this operation returned.  And the loop shows how many times this operation has been performed. <br><br>  In which case the operation will be called more than once?  For example, in some cases with join or subqueries.  It will be like <a href="http://explain.depesz.com/s/7Z2">this plan</a> . <br><br>  Note that in the third operation there are only two cycles.  This means that this seq scan was run twice, returned, on average, 1 line and, on average, it took 0.160ms to complete.  So the total time spent on this particular operation: 2 * 0.160ms = 0.32ms (as indicated in the columns exclusive / inclusive on explain.depesz.com). <br><br>  Very often, poor query performance is due to the fact that it had to execute a loop on some subquery many times.  For example, like <a href="http://explain.depesz.com/s/gsg">here</a> . <br><br>  (Of course, this does not mean that the postgres was to blame for everything, he chose such a plan. Perhaps there were simply no other options or they turned out to be even more costly). <br><br>  In the example above, it is worth paying attention to the fact that, although the actual time of operation 3 is only 0.003ms, this operation was performed more than 26,000 times, which resulted in almost 79ms of elapsed time. <br><br>  I think this is where the theoretical information needed to read the explain has been exhausted.  Most likely, you still do not understand what operations and other information mean, but at least now you know what numbers mean and what is the difference between explain (which shows costs in abstract units of measurement based on an approximate estimate of random examples) and explain analyze (which shows the actual time, the number of lines and the execution time in units of measure that allow you to compare different queries). <br><br>  As always, I‚Äôm afraid I missed a lot of things that might be important, but didn‚Äôt catch my eye, or (worse,) I thought they were ‚Äúobvious.‚Äù  If it seems to you that something is missing, please let me know and I will try to fill in the blanks as soon as possible. <br><br>  But I also want to add that I plan to develop this text in 2-3 more publications, in which I will tell more about: <br><ul><li>  what are the operations, how they work and what to expect when you see them in the explain output; </li><li>  What is statistics, how does Pg get it, how to view it and how to get the most out of it. </li></ul><br>  <i>I hope this article has been helpful to you.</i>  <i>Subscribe and follow publications.</i>  <i>Translations of the following episodes will soon appear on the blog!</i>  <i>As usual, do not hesitate to leave feedback and suggestions.</i>  <i>We will include the most interesting ones in the program of the upcoming PG Day'16 Russia!</i>  <i>:)</i> </div><p>Source: <a href="https://habr.com/ru/post/275851/">https://habr.com/ru/post/275851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275841/index.html">50 quotes about programming all time</a></li>
<li><a href="../275843/index.html">Unifi unfolding network. Personal experience from and to</a></li>
<li><a href="../275845/index.html">How to make AJAX indexed</a></li>
<li><a href="../275847/index.html">Do not go to the dark side</a></li>
<li><a href="../275849/index.html">We write the correct manifesto for the site</a></li>
<li><a href="../275853/index.html">What is wrong with the security of the Internet of Things: How Shodan became a ‚Äúsearch engine for sleeping children‚Äù</a></li>
<li><a href="../275855/index.html">Introducing the free Wolfram Programming Lab for learning the Wolfram Language</a></li>
<li><a href="../275859/index.html">First steps in Xenko</a></li>
<li><a href="../275861/index.html">"Hello World!" In C array int main []</a></li>
<li><a href="../275863/index.html">Clock on FPGA Lattice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>