<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nothing is easier than calling a function; I myself have done this repeatedly.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous article about exceptions in C ++ left a bunch of dark places, 
 the main thing that remained incomprehensible is how is it done 
 transfe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">ğŸ”</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">ğŸ“œ</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">â¬†ï¸</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">â¬‡ï¸</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nothing is easier than calling a function; I myself have done this repeatedly.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/69b/c6b/9b1/69bc6b9b15c64d63ba7fa1c046ca15d0.png"><br>  The previous <a href="http://habrahabr.ru/post/208006/">article</a> about exceptions in C ++ left a bunch of dark places, <br>  the main thing that remained incomprehensible is how is it done <br>  transfer of control when an exception is raised? <br>  With <a href="http://www.cplusplus.com/reference/csetjmp/setjmp/">SJLJ,</a> everything is clear, but it is argued that this technology is practically <br>  pushed out by some no-cost (with no exceptions) tabular mechanism. <br>  But what kind of mechanism it is and how it works, we will understand under the cut. <br><a name="habracut"></a><br>  This article appeared in the process of preparing to speak in <a href="http://habrahabr.ru/company/cpp_russia/blog/263017/">C ++ Siberia,</a> when it turned out some details that may well be useful to someone else, except the author, known for his tediousness. <br><br><h3>  Introduction </h3><br>  It all began with a simple desire to find out the size of the buffer that the setjmp / longjmp functions use: <br><ul><li>  sizeof (jmp_buf) == <b>64</b> bytes (MSVC 2013, win32) </li><li>  sizeof (jmp_buf) == <b>256</b> bytes (MSVC 2013, x64) </li><li>  sizeof (jmp_buf) == <b>200</b> bytes (GCC-4.8.4, Ubuntu 14.04 x64) </li></ul>  It is believed that the state of the processor is preserved in this structure. <br>  And how does this fit in with the number of <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> ( <a href="http://support.amd.com/TechDocs/24592.pdf">AMD x86-64</a> )? <br><img src="https://habrastorage.org/files/4a5/5a0/b1d/4a55a0b1dc0e401dacf11e667d0b8363.png" width="500"><br>  MMX and FP87 registers are combined. <br>  In 32 - bit mode - 32 + 128 + 80 + 12 (eip, flags) = 252 bytes <br>  In 64-bit - 128 + 256 + 80 + 24 (...) = 480 bytes <br>  Something does not converge. <br>  We read <a href="https://msdn.microsoft.com/en-us/library/36d3b75w.aspx">documentation</a> : <br><blockquote>  When you call setjmp, the current stack position, non-volatile registers, and flags are saved. </blockquote>  What other non-volatile registers?  Again, read the <a href="https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx">documentation</a> : <br><blockquote>  When calling a function, the responsibility for saving the contents of a part of the registers lies with the caller, and these are the so-called volatile registers.  The callee takes care of the contents of the other registers and these are non-volatile registers. </blockquote>  So what is it and why is it needed? <br><br><h3>  Register division by volatile and non-volatile </h3><br>  It is about optimizing call functions.  Such a division has existed for a long time. <br>  In any case, in the architecture of <a href="https://ru.wikipedia.org/wiki/Motorola_680x0">68K</a> (1979), two out of 8 general-purpose registers and seven address registers <a href="https://en.wikipedia.org/wiki/Calling_convention">were considered</a> volatile, the rest were protected by the called party. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the <a href="http://people.cs.clemson.edu/~mark/subroutines/m88k.html">88K</a> architecture (1988), 12 of 32 general-purpose registers were protected by the called party + (pointers to the stack and frame). <br><br>  In the <a href="http://everything2.com/title/System%25252F370%2BS-type%2Blinkage%2Bconvention">IBM S / 360</a> (1964), there are 16 integer registers (32-bit) for general purpose and 4 floating point, but no hardware stack.  Before calling a function, all registers are stored in a special area.  For a recursive call, you need to dynamically request memory from the OS.  Parameters are passed as a pointer to a list of pointers to parameter values.  In fact, 11 registers are non-volatile. <br><br>  For architectures with fewer registers, there is no problem with their preservation.  In <a href="https://ru.wikipedia.org/wiki/PDP-11">PDP-11</a> (1970), there are a total of 6 general-purpose registers.  And the parameters are passed through the stack.  Actually, this is how â€œC calling conventionâ€ ( <a href="https://en.wikipedia.org/wiki/Calling_convention">cdecl</a> ) appeared and it was here that the C language <a href="https://en.wikipedia.org/wiki/C_(programming_language)">crystallized</a> . <br><br>  8086. Where do without him.  The processor has 8 general-purpose registers, but only BX has no architectural burdens.  There were several <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">agreements</a> on calling functions, they concerned the transfer of parameters, and all registers were considered volatile. <br><br>  We will not dwell on <a href="https://en.wikipedia.org/wiki/IA-32">IA-32</a> , we will return again to <a href="https://en.wikipedia.org/wiki/X86-64">x86-64</a> . In this case, there are too many registers to save their values â€‹â€‹before each call.  In the case of a full-fledged function, this will somehow have to be done, but for small â€œfunctionletsâ€ it is wasteful.  Need a compromise. <br>  Who can determine which class belongs to a particular register?  The compiler itself, to the architecture is indirectly related.  Here is what <a href="https://plus.google.com/%2BJanHubi%25C4%258Dka/posts">one</a> of the GCC developers <a href="http://www.ucw.cz/~hubicka/papers/amd64/node2.html">wrote</a> in 2003 about this: <br><blockquote>  The decision to which category to assign a specific register was not easy.  AMD64 has 15 general-purpose registers (av. Ln .:% rsp does not count, save it anyway), and using 8 of them (the so-called extended registers) in the instruction requires the REX prefix, which increases its size.  In addition, the% rax,% rdx,% rcx,% rsi, and% rdi registers are implicitly used in some IA-32 instructions.  We decided to make these volatile registers to avoid restrictions on the use of instructions. <br>  Thus, we can make non-volatile only% rbx,% rbp and extended registers.  A series of tests showed that the smallest code is obtained when non-volatile registers are assigned (% rbx,% rbp,% r12-% r15). <br><br>  Initially, we wanted to make volatile 6 SSE registers.  However, difficulties arose - these registers are 128-bit and only 64 bits are usually used to store data, so saving them for the caller is more expensive than for the party being called. <br>  Various experiments were carried out and we came to the conclusion that the most compact and fast code is obtained in the case when all SSE registers are declared as volatile. </blockquote><br>  This is exactly how things are still, see <a href="http://x86-64.org/documentation/abi.pdf">AMD64 ABI spec</a> , page 21. <br>  The same ABI is <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/140-x86-64_Function_Calling_Conventions/x86_64.html">supported</a> in B OS X. <br><br>  Microsoft considered it different and their division <a href="https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx">is as follows</a> : <br><ul><li>  volatile: RAX, RCX, RDX, R8: R11, XMM0: XMM5, YMM0: YMM5 </li><li>  non-volatile: RSI, RDI, RBX, RBP, RSP, R12: R15, XMM6: XMM15, YMM6: YMM15 </li></ul>  Well, at least all this can fit into the size of <i>jmp_buf</i> . <br><br>  What about more case-rich architectures? <br>  This is how <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/110-64-bit_PowerPC_Function_Calling_Conventions/64bitPowerPC.html">things</a> work with the OS X 64-bit compiler for PowerPC, where there are 32 integer registers and floating point ones: <br><ul><li>  volatile: GPR0, GPR2: GPR10, GPR12, FPR0: FPR13, a <b>total of 11 + 14</b> </li><li>  non-volatile: GPR1, GPR11 (*), GPR13: GPR31, FPR14: FPR31, <b>total 21 + 18</b> </li></ul>  GPR11 (*) - non-volatile for leaf functions (of which there are no other calls) <br><br>  Total: division of registers into two classes implements a universal optimization of function calls: <br><ul><li>  some registers are used to pass arguments, this is faster than working through the stack (plus some registers are used for official needs) </li><li>  the number of these registers is determined by compiler developers on the basis of statistics and their own ideas about typical code. </li><li>  the contents of the other registers are saved only by necessity, so in the case of small and non-greedy functions, it can save nothing </li><li>  and when calling a full function, the contents of all registers will be saved, but this is nothing compared to the time the body of this function </li></ul><br><h3>  Register <a href="https://en.wikipedia.org/wiki/Register_window">windows</a> </h3><br>  An alternative approach, processors using this <a href="http://people.cs.clemson.edu/~mark/subroutines.html">technique</a> , grow from the project <a href="https://en.wikipedia.org/wiki/Berkeley_RISC">Berkeley RISC</a> (1980..1984). <br><br>  Intel <a href="https://ru.wikipedia.org/wiki/I960">i960</a> (1989) is a 32-bit processor with 16 local and 16 global general-purpose registers.  Parameters are passed through global registers; when a function is called, all local registers are saved with a special instruction.  In fact, all local registers are non-volatile, but they are saved forcibly in the hope that hardware support will give this some kind of acceleration.  However, in modern times this is just one <a href="http://habrahabr.ru/company/intel/blog/143446/">line of cache</a> . <br><br>  AMD <a href="https://en.wikipedia.org/wiki/AMD_Am29000">29K</a> (1988) - 32-bit processor with 192 (sic!) Registers <br><ul><li>  64 global and 128 local integer registers </li><li>  local registers form the top of the stack, continued in memory, access to the stack goes in offsets from the top of the stack (one of the global registers) </li><li>  input parameters of the function are transmitted through local registers, return - through global </li><li>  there is also a real stack in memory for data that did not fit in 16 words, as well as those that may require an address from someone, for example, for local arrays or anything that has this. </li></ul><br>  <a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a> (1987) may have a different number of registers (S in the name means Scalable) <br><ul><li>  typical processor has 128 general purpose registers </li><li>  of which only 32 - 8 global and 24 local, which form a window, are visible at a time </li><li>  the window consists of 8 input (arguments), 8 local and 8 output (for the next call) </li><li>  local registers form a ring buffer; when the function is called, the window is shifted by 16 registers.  In this case, 8 output registers for the called function become input. </li><li>  when preempted, registers are pushed onto the stack </li></ul><br>  <a href="https://ru.wikipedia.org/wiki/Itanium">Itanium</a> (2001) SPARC follower. <br><ul><li>  only 128 general-purpose general-purpose general-purpose registers (64-bit) and as many floating </li><li>  32 of them are considered global. </li><li>  96 - local and they form the top of the register stack </li><li>  the processor itself takes care of loading and unloading them, creating the illusion of an infinite register stack (RSE, Register Stack Engine) </li><li>  when calling a function, a register window is created for it with a special instruction <a href="http://people.cs.clemson.edu/~mark/subroutines/itanium.html">alloc</a> , and the compiler must explicitly set its dimensions </li><li>  the window is similar to SPARC, but the dimensions of its parts are flexible and are also set by the compiler, the total size is not more than 96 registers <br><ul><li>  in part is intended for function input parameters, not more than 8 </li><li>  local part for local data </li><li> out - intended for parameters of functions that will be called and this one, not more than 8 </li></ul></li><li>  when a function is called from a function, the register window shifts and with a light movement out the part turns into in </li><li>  the usual stack is also present, the compiler puts everything that could not be placed on the stack of local registers. </li></ul><br>  Definitely, Itanium gets the audience award, itâ€™s a pity that this processor didnâ€™t take off. <br><br><h3>  Function call </h3><br>  So, having considered all this architectural splendor, we can draw the following conclusions about the function call. <br><br>  Yes, after the optimizer, the contents of the function body sometimes remind of the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B1%25D1%2583%25D0%25BB%25D1%258C%25D0%25BE%25D0%25BD">primary broth</a> , where it is not always clear why this or that instruction is needed and how to find the value of a variable. <br><br>  However, at the time of the child function call, all this hectic activity freezes. <br><br>  Regardless of the processor architecture, the actual data from the registers is somehow prevented from being lost.  For architects with register windows, this happens naturally.  For other volatile registers are saved in memory, if this is a temporary value and it has no place in memory, it will have to be re-evaluated.  Non-volatile registers either remain unchanged or their values â€‹â€‹are restored. <br><br>  Suppose an exception occurred in the underlying function and we want to transfer control to one of the catch blocks of a certain function.  All the information we need to restore the execution context is already in the stack or in registers, <br>  The try block may take no effort, it does not need to allocate space on the stack and save there anything.  All information is already saved.  But now the problem arises how to save information about where we placed that information. <br><br>  Fortunately, this information is static and is determined at compile time.  The compiler collects all of this into tables, and thatâ€™s how it turned out to be a no-cost tabular mechanism. <br><br>  Let's see how this is implemented in the MSVC (x64) and GCC (x64) compilers. <br><br><h3>  MSVC (x64) </h3><br>  MSVC creates a prolog and an epilog for each function, while the RSP value between them remains unchanged.  RBP is considered a regular register until someone uses <a href="https://msdn.microsoft.com/ru-ru/library/wb1s57t5(v%3Dvs.120).aspx">alloca</a> .  Take for experiments some nontrivial function and look in the debugger at the significant part of its prologue for us: <br><blockquote>  000000013F440850 mov rax, rsp <br>  000000013F440853 push rbp <br>  000000013F440854 push rdi <br>  000000013F440855 push r12 <br>  000000013F440857 push r14 <br>  000000013F440859 push r15 <br>  000000013F44085B lea rbp, [rax-0B8h] # initialization <br>  000000013F440862 sub rsp, 190h <br>  000000013F440869 mov qword ptr [rbp + 20h], 0FFFFFFFFFFFFFFFEh # initialization <br>  000000013F440871 mov qword ptr [rax + 10h], rbx <br>  000000013F440875 mov qword ptr [rax + 18h], rsi <br>  000000013F440879 mov rax, qword ptr [__security_cookie (013F4C5020h)] #from hereafter - the function body <br></blockquote>  the optimizer dilutes the prolog code with initialization instructions whenever <u>possible</u> . <br><br>  And an epilogue in which non-volatile registers are brought to their original state. <br><blockquote>  000000013F4410C2 lea r11, [rsp + 190h] <br>  000000013F4410CA mov rbx, qword ptr [r11 + 38h] <br>  000000013F4410CE mov rsi, qword ptr [r11 + 40h] <br>  000000013F4410D2 mov rsp, r11 <br>  000000013F4410D5 pop r15 <br>  000000013F4410D7 pop r14 <br>  000000013F4410D9 pop r12 <br>  000000013F4410DB pop rdi <br>  000000013F4410DC pop rbp <br>  000000013F4410DD ret <br></blockquote>  The compiler collects information for the promotion of the stack in the .pdata section.  A <a href="https://msdn.microsoft.com/en-us/library/ft9x1kdx.aspx">RUNTIME_FUNCTION</a> structure is <a href="https://msdn.microsoft.com/en-us/library/ft9x1kdx.aspx">created for</a> each function, from which there is a link to the <a href="https://msdn.microsoft.com/en-us/library/ft9x1kdx.aspx">unwind table</a> .  Its contents can be pulled out using the link utility with the parameters -dump -unwindinfo.  For the same function we find: <br><blockquote>  00001D70 00020880 0002110E 000946C0? Write_table_header ... <br>  Unwind version: 1 <br>  Unwind flags: EHANDLER UHANDLER <br>  Size of prologue: 0x3A <br>  Count of codes: 11 <br>  Unwind codes: <br>  29: SAVE_NONVOL, register = rsi offset = 0x1D0 <br>  25: SAVE_NONVOL, register = rbx offset = 0x1C8 <br>  19: ALLOC_LARGE, size = 0x190 <br>  0B: PUSH_NONVOL, register = r15 <br>  09: PUSH_NONVOL, register = r14 <br>  07: PUSH_NONVOL, register = r12 <br>  05: PUSH_NONVOL, register = rdi <br>  04: PUSH_NONVOL, register = rbp <br>  Handler: 0006BFD0 __GSHandlerCheck_EH <br>  EH Handler Data: 00087578 <br>  GS Unwind flags: UHandler <br>  Cookie Offset: 00000188 <br></blockquote>  We are interested in <a href="https://msdn.microsoft.com/en-us/library/ck9asaa9.aspx">Unwind codes</a> - they contain actions that must be performed when an exception is raised. <br><ul><li>  the number at the beginning of the line means a shift from the beginning of the function of the instruction address following the described one.  If an exception occurs in the middle of the prologue (which is very strange), only the changes made can be rolled back. </li><li>  Then comes the type of instruction, for example, ALLOC_LARGE means allocating a certain amount of memory on the stack, SAVE_NONVOL - saving the register to already allocated memory, PUSH_NONVOL - saving the register on the stack with decreasing RSP </li><li>  instructions go in reverse order, repeating the actions of the epilogue </li></ul><br><br><h3>  GCC (x64) </h3><br>  Similarly, we analyze the prologue and epilogue of the same function created by GCC. <br>  Prologue <br><blockquote>  .cfi_startproc <br>  .cfi_personality 0x9b, DW.ref .__ gxx_personality_v0 <br>  .cfi_lsda 0x1b, .LLSDA11339 <br>  pushq% r15 <br>  .cfi_def_cfa_offset 16 <br>  .cfi_offset 15, -16 <br>  pushq% r14 <br>  .cfi_def_cfa_offset 24 <br>  .cfi_offset 14, -24 <br>  pushq% r13 <br>  .cfi_def_cfa_offset 32 <br>  .cfi_offset 13, -32 <br>  movq% rdi,% r13 <br>  pushq% r12 <br>  .cfi_def_cfa_offset 40 <br>  .cfi_offset 12, -40 <br>  pushq% rbp <br>  .cfi_def_cfa_offset 48 <br>  .cfi_offset 6, -48 <br>  pushq% rbx <br>  .cfi_def_cfa_offset 56 <br>  .cfi_offset 3, -56 <br>  subq $ 456,% rsp <br>  .cfi_def_cfa_offset 512 <br></blockquote>  Epilogue: <br><blockquote>  addq $ 456,% rsp <br>  .cfi_remember_state <br>  .cfi_def_cfa_offset 56 <br>  popq% rbx <br>  .cfi_def_cfa_offset 48 <br>  popq% rbp <br>  .cfi_def_cfa_offset 40 <br>  popq% r12 <br>  .cfi_def_cfa_offset 32 <br>  popq% r13 <br>  .cfi_def_cfa_offset 24 <br>  popq% r14 <br>  .cfi_def_cfa_offset 16 <br>  popq% r15 <br>  .cfi_def_cfa_offset 8 <br>  ret <br></blockquote>  CFI prefix means Call Frame Information; these are <a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">directives to the</a> assembler how to write additional information for stack promotion.  This information is collected in the .eh_frame section, you can see it in a readable form using the dwarfdump utility with the -F key <br><blockquote>  #prologue <br>  ã€ˆ0ã€‰ ã€ˆ0x00000e08: 0x00000f4a ã€ˆã€‰ ã€ˆfde offset 0x00000e00 length: 0x00000060 eh aug data len 0x0 <br>  0x00000e08: ã€ˆoff cfa = 08 (r7) ã€ˆoff r16 = -8 (cfa) <br>  0x00000e0a: ã€ˆoff cfa = 16 (r7) ã€ˆoff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e0c: ã€ˆoff cfa = 24 (r7) ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e0e: ã€ˆoff cfa = 32 (r7) ã€ˆoff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e10: ã€ˆoff cfa = 40 (r7) off r12 = -40 (cfa) ã€ˆoff r13 = -32 (cfa) <br>  ã€ˆOff r14 = -24 (cfa)ã€‰ ã€ˆoff r15 = -16 (cfa) ã€ˆoff r16 = -8 (cfa) <br>  0x00000e11: ã€ˆoff cfa = 48 (r7) ã€ˆoff r6 = -48 (cfa) <br>  ã€ˆOff r12 = -40 (cfa)ã€‰ ã€ˆoff r13 = -32 (cfa) <br>  ã€ˆOff r14 = -24 (cfa)ã€‰ ã€ˆoff r15 = -16 (cfa) <br>  ã€ˆOff r16 = -8 (cfa) <br>  0x00000e12: ã€ˆoff cfa = 56 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  #body <br>  0x00000e19: ã€ˆoff cfa = 64 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e51: ã€ˆoff cfa = 56 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e52: ã€ˆoff cfa = 48 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e53: ã€ˆoff cfa = 40 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e55: ã€ˆoff cfa = 32 (r7) ã€ˆoff r3 = -56 (cfa) ã€ˆoff r6 = -48 (cfa) <br>  ã€ˆã€ˆOff r12 = -40 (cfa)ã€‰ ã€ˆoff r13 = -32 (cfa) <br>  ã€ˆOff r14 = -24 (cfa)ã€‰ ã€ˆoff r15 = -16 (cfa) <br>  ã€ˆOff r16 = -8 (cfa) <br>  0x00000e57: ã€ˆoff cfa = 24 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e59: ã€ˆoff cfa = 16 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e5b: ã€ˆoff cfa = 08 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000e60: ã€ˆoff cfa = 64 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa) ã€ˆoff r14 = -24 (cfa) ã€ˆoff r15 = -16 (cfa) <br>  ã€ˆOff r16 = -8 (cfa) <br>  0x00000f08: ã€ˆoff cfa = 56 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000f09: ã€ˆoff cfa = 48 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000f0a: ã€ˆoff cfa = 40 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000f0c: ã€ˆoff cfa = 32 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa) ã€ˆoff r14 = -24 (cfa) ã€ˆoff r15 = -16 (cfa) <br>  ã€ˆOff r16 = -8 (cfa) <br>  0x00000f0e: ã€ˆoff cfa = 24 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000f10: ã€ˆoff cfa = 16 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000f12: ã€ˆoff cfa = 08 (r7) ã€ˆoff r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br>  0x00000f18: ã€ˆoff cfa = 64 (r7) off r3 = -56 (cfa) <br>  ã€ˆOff r6 = -48 (cfa)ã€‰ ã€ˆoff r12 = -40 (cfa) <br>  ã€ˆOff r13 = -32 (cfa)ã€‰ ã€ˆoff r14 = -24 (cfa) <br>  ã€ˆOff r15 = -16 (cfa)ã€‰ ã€ˆoff r16 = -8 (cfa) <br></blockquote>  What we see here: <br><ul><li>  the first number is the instruction address </li><li>  for each address you can find the interval to which the entry corresponds </li><li>  the record consists of a descriptor which register is a frame-pointer ã€ˆoff cfa = 48 (r7) (r7 is% rsp, see <i>dwarfdump.conf</i> ), </li><li>  and a list of register descriptors, for example, r off r3 = -56 (cfa) means that the register% rbx is stored at -56 offset from frame-pointer </li><li>  The prologue is similar to assembly language, the% r16 register has been added, which the compiler uses for some of its own purposes. </li><li>  There is no description of the epilogue, apparently, the compiler believes that when executing the epilogue there can be no exceptions </li><li>  we see several code branches in which the value of cfa monotonously decreases.  It is not clear why this happens, perhaps the compiler inline functions and places their temporary data on the stack, saves the stack rollback until everything fits in the <a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">red zone</a> . </li></ul><br><br><h3>  Total </h3><br>  So we got to the end.  In the process, it turned out that there was no magic.  In order to be able to recover from the exception after catching the exception, no action is needed, everything is saved by itself during the natural execution of the code. <br>  But in order to restore the state, a little help from the compiler is required, but everything is rather modest, without frills. <br><br>  In general, exception handling by modern compilers is an excellent example of how the most difficult problem can be solved calmly, without any fuss, using completely â€œworker-peasantâ€ methods.  Developers respect. </div><p>Source: <a href="https://habr.com/ru/post/267771/">https://habr.com/ru/post/267771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267761/index.html">Victory Roll Girl tutorial</a></li>
<li><a href="../267763/index.html">Using GATT in Bluetooth LE on Intel Edison</a></li>
<li><a href="../267765/index.html">Vim FileStyle Update</a></li>
<li><a href="../267767/index.html">DropBox distributes place to students / teachers 2</a></li>
<li><a href="../267769/index.html">Attach files to comments</a></li>
<li><a href="../267773/index.html">Modification of the system call. Part 2</a></li>
<li><a href="../267775/index.html">"Front-end Bookshelf" - like google, only better</a></li>
<li><a href="../267777/index.html">Candy Challenge</a></li>
<li><a href="../267779/index.html">Create a REST service on Rust. Part 3: update the database from the console</a></li>
<li><a href="../267781/index.html">C ++ module support in Visual Studio 2015 Update 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>