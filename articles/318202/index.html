<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modification of stock firmware for Android. Part 5. Revolution c Xposed Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In 2012, a user with the nickname rovo89 on the XDA community published source codes and a ready-to-use framework that simplifies customization of fir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modification of stock firmware for Android. Part 5. Revolution c Xposed Framework</h1><div class="post__text post__text-html js-mediator-article">  In 2012, a user with the nickname rovo89 on the XDA community published <a href="https://github.com/rovo89/Xposed">source codes</a> and a ready-to-use <a href="http://repo.xposed.info/">framework</a> that simplifies customization of firmware, with detailed instructions and examples, offering an alternative to the traditional, at that time, method (deodexing ‚Üí disassembling ‚Üí decompiling ‚Üí recompiling ‚Üí testing ‚Üí download patches into the phone): <a href="https://habrahabr.ru/post/181826/">Part 1</a> , <a href="https://habrahabr.ru/post/182640/">Part 2</a> , <a href="https://habrahabr.ru/post/185940/">Part 3</a> , <a href="https://habrahabr.ru/post/190428/">Part 4</a> <br><br>  He proposed the use of separate modules that can be changed on the fly, without interfering with the source code of the firmware or its individual components.  But reputable developers choir replied: " <b>No ... nobody needs it</b> " <br><br>  Rovo did not abandon his brainchild, but continued to develop.  When the KitKat version came out in 2013, the same community of eminent developers replied: " <b>Nope, this is too dangerous ... although ...</b> " 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Meanwhile, Google decided to release a new version of the operating system annually.  Of course, it became expensive to customize the firmware: you do not have time to make one, as a new OS version appears.  So in 2014, the Lollipop version comes out and the developers finally pay attention to the framework with the thoughts: ‚Äú <b>Maybe it‚Äôs still worth seeing what it is? It looks promising</b> .‚Äù <br><br>  In 2015, the next version (Marshmallow) was released, and most of the community, as a result, recognized the development as very worthwhile, shortening the development time for customizing stock firmware as an installation of separate modules that extend functionality.  ‚Äú <b>Wow, this is absolutely safe and there is a library of ready-made useful modules!</b> ‚Äù They exclaimed. <br><br>  Now the end of February 2017.  Xposed under Nougat is still not available, and crowds of afflicted developers and users continually open topics like " <b>Xposed does not work! I need it! Rovo, please!</b> " <br><br>  Today I will talk about the Xposed Framework. <br><a name="habracut"></a><br><h2>  <b>Denial of responsibility</b> </h2><br>  Any product names and trademarks mentioned in the text are the property of their respective owners.  Texts of the article published for educational purposes.  The authors (@Falseclock and <a href="https://habrahabr.ru/users/xronofag/" class="user_link">xronofag</a> ) are not responsible for possible losses, damage to equipment, lost profits due to attempts to play or use the information in this article.  By continuing to read, the reader thereby confirms that any use of the source code may entail risks for it. <br><br><h2>  <b>Retreat</b> </h2><br>  More than three years ago, I began to write a series of articles about the modification of firmware for Android.  At the moment, the relevance of these articles is very doubtful: the process is very time consuming, requires a lot of time and tools, and the slightest mistake can turn into significant problems until the phone is completely flashing. <br><br>  I waited about two years in the hope that someone will still describe on Habr√© what the Xposed Framework is and how it can simplify the application customization process, but I suspect that few people are familiar with this wonderful creation.  For my needs, I wrote dozens of modules, some even <a href="http://repo.xposed.info/users/falseclock">published</a> in the general repository, which currently contains more than 1000 ready-for-use developments.  Each module - this may not be a single customization, but a whole set of functions with a settings interface or additional functionality.  A striking example of this is <a href="https://forum.xda-developers.com/xposed/modules/app-gravitybox-v3-1-5-tweak-box-android-t2554049">GravityBox</a> or <a href="http://sensetoolbox.com/">Sense ToolBox</a> . <br><br>  I will not describe the installation process and get root rights, but I want to describe what a framework is and how to write the simplest module. <br><br><h2>  <b>Installation</b> </h2><br>  If earlier to install third-party firmware, it was required to unlock the phone loader, then to use Xposed, the user only needs to have root rights on the phone.  Even now, obtaining these rights on most devices is not a big deal: you download the application, but it itself does all the necessary manipulations and in a few minutes you become the owner of the phone with the ‚ÄúGOD‚Äù level. <br><br><h3>  The principle of work "on the fingers" </h3><br>  In the Android system there is a process called ‚ÄúZygote‚Äù.  This is the main executive system.  Any process runs as its copy.  Zygote is launched via /init.rc as soon as the main system kernel is loaded.  Applications are launched via the / system / bin / app_process script, which loads the necessary classes and starts the application initialization through the declared methods. <br><br>  This is where Xposed comes on the scene.  When installing the framework, the modified app_process is copied to / system / bin.  The essence of the modification is that an additional jar library is added to the variable environment, which can execute special methods under certain conditions and cases.  For example, we can intervene as soon as the <a href="https://ru.wikipedia.org/wiki/Dalvik">Dalvik</a> virtual machine is created or even before the main Zygote method is called.  As part of the Zygote process, we can interfere with the work of any methods, even synthetic ones, and perform any actions in their context. <br><br><h3>  Practical value Xposed </h3><br>  Suppose you need to change some method, and, for example, instead of the Boolean value TRUE, return FALSE.  Instead of a time-consuming and costly traditional method (parsing, assembling, testing an application), you can ‚Äúintercept‚Äù this class method and ‚Äúimplant‚Äù your Java code that will perform the necessary operation (change the value in this example) and return the desired result.  At the same time, with Xposed, you can: modify or just see what data is transferred to the method, or after executing the method, find out the result of data processing and, depending on the requirements, change them or use them. <br><br>  There are cases when you do not want this or that method to work at all, or you want to completely change the logic and algorithm.  Xposed allows you to completely replace the method, or not to let it work at all. <br><br>  In the case of resources, everything became simple.  You load your resources into your module, even graphic elements, even solid xml files and when loading the module into memory you can replace them during initialization. <br><br>  And now the main thing is that it is often not even necessary to change the operation of the module (or make minimal improvements) with the release of a new version of the firmware / application!  This is logical, because the names of methods, classes and variables, as a rule, remain the same. <br><br>  Isn't it convenient? <br><br><h2>  <b>Module creation</b> </h2><br>  The module itself is a regular apk file created in the development environment.  It does not have to contain any Activity or graphic resources.  In fact, there can only be one file with instructions, of course, besides the required files, and the module can work.  To configure, we need to do three things: <br><br><h3>  Manifest.xml </h3><br>  When installing any application, Xposed checks for the presence of certain headers in Manifest.xml.  If there are three necessary lines, the framework stores information about the application in its settings and then you can activate the installed module (hereinafter, examples of the code of different modules will be used, including those from known applications). <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xposedmodule"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xposedminversion"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2.6*"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xposeddescription"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Uber-Driver application patch tool"</span></span></span><span class="hljs-tag"> /</span></span></code> </pre> <br>  The first line is clear. <br><br>  In the second line specify the minimum version of the framework for working with the module.  Each version is sharpened for a specific release of Android and that the module is not accidentally running on a platform for which it is not intended, the version is indicated. <br><br>  The third line defines how your application will be identified in the list of available or installed modules on your phone. <br><br><h3>  / assets / xposed_init </h3><br>  At the root of your application, you need to create an assets folder and put a file called xposed_init into it.  Inside this file you simply write in which Java class the operation of your module is described.  I used to call a class like XMain.  In my case there is a line in the file <br><br> <code>uber.hack.XMain</code> <br> <br><h3>  Java class </h3><br>  The class itself must contain one of the three methods for working with the framework.  It is not necessary to specify everything, you can only indicate those with which you plan to modify the application or applications.  Out of habit, I specify everything as a template. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMain</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IXposedHookInitPackageResources</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IXposedHookLoadPackage</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IXposedHookZygoteInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initZygote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StartupParam startupParam)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleInitPackageResources</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitPackageResourcesParam resparam)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleLoadPackage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( LoadPackageParam paramLoadPackageParam)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ } }</code> </pre> <br>  The <b>initZygote</b> method <b>runs</b> when <u>your module is</u> loaded into memory. <br>  Very useful if your application has an Activity with the settings of your module.  As a rule, your application data is saved to a file. <br>  <code>/data/data/YOUR_PACKAGE_NAME/shared_prefs/YOUR_PACKAGE_NAME_preferences.xml</code> .  At boot time, you can get a handle once and, while running, just read your settings from it.  You can also predetermine any variables, make checks.  In fact, this is an analogue of the constructor method. <br><br>  The <b>handleLoadPackage</b> method <b>runs</b> when Dalvik loads the source code of <u>anyone</u> !  applications at startup.  This is a very important point.  If you have 10 different modules on your phone, then through this method, the sources of the launched application will be ‚Äúrun‚Äù in all 10 cases.  For filtering, the usual check by package name is used.  Of course, if you want to change the work of several applications, then put as many checks as you need. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleLoadPackage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( LoadPackageParam paramLoadPackageParam)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LoadPackageParam llpm = paramLoadPackageParam; String packageName = llpm.packageName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (packageName.contains(<span class="hljs-string"><span class="hljs-string">"ubercab.driver"</span></span>)) { } }</code> </pre> <br>  You need the handleInitPackageResources method when you want to replace application resources while they are loaded into memory.  This is the same as with handleLoadPackage - you filter by application name. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleInitPackageResources</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InitPackageResourcesParam resparam)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ String pkg = resparam.packageName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pkg.equals(<span class="hljs-string"><span class="hljs-string">"com.ubercab.driver"</span></span>)) { } }</code> </pre> <br>  It is important to specify the name of the application as it is specified in the manifest.  This completes the configuration of the module in the development environment and we can proceed directly to programming. <br><br><h2>  <b>Code examples</b> </h2><br>  The main code, unless you decide to just change the colors or fonts of some application, occurs in handleLoadPackage.  To do this, we first study the source code of the application of interest, figure out how to modify the code, and describe our logic. <br>  The main logic works through the findAndHookMethod method, less often through the findAndHookConstructor and findClass.  All basic methods can be peeped in the <a href="">XposedHelpers</a> class. <br><br>  It looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (packageName.contains(<span class="hljs-string"><span class="hljs-string">"ubercab.driver"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { XposedHelpers.findAndHookMethod( <span class="hljs-string"><span class="hljs-string">"com.ubercab.driver.feature.online.DispatchedFragment"</span></span>, llpm.classLoader, <span class="hljs-string"><span class="hljs-string">"onCreateView"</span></span>, <span class="hljs-string"><span class="hljs-string">"android.view.LayoutInflater"</span></span>, <span class="hljs-string"><span class="hljs-string">"android.view.ViewGroup"</span></span>, <span class="hljs-string"><span class="hljs-string">"android.os.Bundle"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XC_MethodHook() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeHookedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHookParam param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterHookedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHookParam param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ } } ); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { XposedBridge.log(t); } }</code> </pre> <br>  First of all, we need to wrap our ‚Äúhooks‚Äù in try / catch, because if there is an error in your code, without the wrapper, the main application can complete the work with an error, and the full trace can get to the developer who becomes aware that his application imposed a module.  When wrapping the whole trace, you can put Xposed into the log and understand where we have an error and why. <br><br>  In findAndHookMethod, the first parameter is the name of the class, the second is the link to the class loader, the third is the name of the method we need, then the enumeration is followed by strings which variables are passed to the method and at the end our callback method. <br><br>  Here is an example of how to get the class context and use it. <br><br><div class="spoiler">  <b class="spoiler_title">Context catching</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ XposedHelpers.findAndHookMethod(<span class="hljs-string"><span class="hljs-string">"com.ubercab.driver.core.app.DriverApplication"</span></span>, llpm.classLoader, <span class="hljs-string"><span class="hljs-string">"init"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XC_MethodHook() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterHookedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHookParam param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ Application application = (Application) param.thisObject; Context context = application.getApplicationContext(); Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-string"><span class="hljs-string">"uber.hack.ACTION_BACKGROUND"</span></span>); context.sendBroadcast(intent); } }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { XposedBridge.log(t); }</code> </pre><br>  We catch the loading of the init method in the DriverApplication class and use <code>param.thisObject</code> use the context to send a broadcast message to our receiver or service. <br></div></div><br>  or if it is necessary to change the variables transferred to the method, then this can be done through <br><div class="spoiler">  <b class="spoiler_title">beforeHookedMethod</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ XposedHelpers.findAndHookMethod(<span class="hljs-string"><span class="hljs-string">"com.htc.htcdialer.widget.DividerDrawable"</span></span>, paramLoadPackageParam.classLoader, <span class="hljs-string"><span class="hljs-string">"setDividerColor"</span></span>, <span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-string"><span class="hljs-string">"int"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XC_MethodHook() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeHookedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHookParam param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> paramInt1 = (Integer) param.args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> paramInt2 = (Integer) param.args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramInt1 == <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramInt2 == -<span class="hljs-number"><span class="hljs-number">13388315</span></span>) param.args[<span class="hljs-number"><span class="hljs-number">1</span></span>] = Color.RED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramInt2 == -<span class="hljs-number"><span class="hljs-number">13128336</span></span>) param.args[<span class="hljs-number"><span class="hljs-number">1</span></span>] = Color.BLUE; } } }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { XposedBridge.log(t); }</code> </pre><br></div></div><br>  In addition to XC_MethodHook, you can use XC_MethodReplacement.  The name speaks for itself.  We completely replace some method with our own.  Here is a typical example of when I wanted to get rid of a pop-up notification when I connect my phone via USB to a laptop. <br><div class="spoiler">  <b class="spoiler_title">SetUSBNotification</b> <div class="spoiler_text"><pre> <code class="java hljs">findAndHookMethod(<span class="hljs-string"><span class="hljs-string">"com.android.settings.PSService"</span></span>, paramLoadPackageParam.classLoader, <span class="hljs-string"><span class="hljs-string">"SetUSBNotification"</span></span>, <span class="hljs-string"><span class="hljs-string">"android.content.Context"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>.class, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XC_MethodReplacement() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceHookedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHookParam param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } });</code> </pre> <br></div></div><br>  In this void method, a notification was invoked.  I simply replaced it and forgot that it once hurt me. <br><br>  There were cases and more complicated.  I used my modules to fix errors in system applications.  It‚Äôs not particularly tempting to wait for the manufacturer to fix the bug in the new OTA application, so I fixed it myself. <br><br><div class="spoiler">  <b class="spoiler_title">Fixed bugs</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tweak_fix98918</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -------------------------------------------------- // https://android-review.googlesource.com/#/c/98918/ // -------------------------------------------------- try { final Class&lt;?&gt; TaskRecord = XposedHelpers.findClass("com.android.server.am.TaskRecord", null); XposedHelpers.findAndHookMethod(TaskRecord, "setFrontOfTask", new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable { Object mActivities = XposedHelpers.getObjectField(param.thisObject, "mActivities"); boolean foundFront = false; final int numActivities = (Integer) XposedHelpers.callMethod(mActivities, "size"); for (int activityNdx = 0; activityNdx &lt; numActivities; activityNdx++) { final Object r = XposedHelpers.callMethod(mActivities, "get", activityNdx); if (foundFront || XposedHelpers.getBooleanField(r, "finishing")) { XposedHelpers.setBooleanField(r, "frontOfTask", false); } else { XposedHelpers.setBooleanField(r, "frontOfTask", true); foundFront = true; } } if (!foundFront &amp;&amp; numActivities &gt; 0) { Object get = XposedHelpers.callMethod(mActivities, "get", 0); XposedHelpers.setBooleanField(get, "frontOfTask", true); } return null; } }); } catch (Throwable t) { XposedBridge.log(t); } } // -------------------------------------------------- // https://android-review.googlesource.com/#/c/81970/ // -------------------------------------------------- public static void tweak_fix81970() { try { final Class&lt;?&gt; ActiveServices = XposedHelpers.findClass("com.android.server.am.ActiveServices", null); XposedHelpers.findAndHookMethod(ActiveServices, "killServicesLocked", "com.android.server.am.ProcessRecord", "boolean", new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable { // XposedBridge.log("killServicesLocked happen"); Boolean DEBUG_SERVICE = (Boolean) XposedHelpers.getStaticBooleanField(ActiveServices, "DEBUG_SERVICE"); String TAG = (String) XposedHelpers.getStaticObjectField(ActiveServices, "TAG"); Object app = param.args[0]; boolean allowRestart = (Boolean) param.args[1]; Object services = XposedHelpers.getObjectField(app, "services"); int size = (Integer) XposedHelpers.callMethod(services, "size"); // First clear app state from services. for (int i = size - 1; i &gt;= 0; i--) { Object sr = XposedHelpers.callMethod(services, "valueAt", i); Object stats = XposedHelpers.getObjectField(sr, "stats"); synchronized (XposedHelpers.callMethod(stats, "getBatteryStats")) { XposedHelpers.callMethod(stats, "stopLaunchedLocked"); } Object sr_app = XposedHelpers.getObjectField(sr, "app"); Boolean persistent = XposedHelpers.getBooleanField(sr_app, "persistent"); Boolean stopIfKilled = XposedHelpers.getBooleanField(sr, "stopIfKilled"); if (sr_app != null &amp;&amp; !persistent &amp;&amp; stopIfKilled) { Object sr_app_services = XposedHelpers.getObjectField(sr_app, "services"); XposedHelpers.callMethod(sr_app_services, "remove", sr); } XposedHelpers.setObjectField(sr, "app", null); XposedHelpers.setObjectField(sr, "isolatedProc", null); XposedHelpers.setObjectField(sr, "executeNesting", 0); XposedHelpers.callMethod(sr, "forceClearTracker"); Object mDestroyingServices = XposedHelpers.getObjectField(param.thisObject, "mDestroyingServices"); Boolean check = (Boolean) XposedHelpers.callMethod(mDestroyingServices, "remove", sr); if (check) { if (DEBUG_SERVICE) Slog.v(TAG, "killServices remove destroying " + sr); } Object bindings = XposedHelpers.getObjectField(sr, "bindings"); final int numClients = (Integer) XposedHelpers.callMethod(bindings, "size"); for (int bindingi = numClients - 1; bindingi &gt;= 0; bindingi--) { Object IntentBindRecord = XposedHelpers.callMethod(bindings, "valueAt", bindingi); if (DEBUG_SERVICE) Slog.v(TAG, "Killing binding " + IntentBindRecord + ": shouldUnbind=" + XposedHelpers.getObjectField(IntentBindRecord, "hasBound")); XposedHelpers.setObjectField(IntentBindRecord, "binder", null); XposedHelpers.setObjectField(IntentBindRecord, "requested", false); XposedHelpers.setObjectField(IntentBindRecord, "received", false); XposedHelpers.setObjectField(IntentBindRecord, "hasBound", false); } } // Clean up any connections this application has to // other // services. Object connections = XposedHelpers.getObjectField(app, "connections"); size = (Integer) XposedHelpers.callMethod(connections, "size"); for (int i = size - 1; i &gt;= 0; i--) { Object ConnectionRecord = XposedHelpers.callMethod(connections, "valueAt", i); XposedHelpers.callMethod(param.thisObject, "removeConnectionLocked", ConnectionRecord, app, null); } XposedHelpers.callMethod(connections, "clear"); Object smap = XposedHelpers.callMethod(param.thisObject, "getServiceMap", XposedHelpers.getObjectField(app, "userId")); // Now do remaining service cleanup. services = XposedHelpers.getObjectField(app, "services"); size = (Integer) XposedHelpers.callMethod(services, "size"); for (int i = size - 1; i &gt;= 0; i--) { Object sr = XposedHelpers.callMethod(services, "valueAt", i); Object mServicesByName = XposedHelpers.getObjectField(smap, "mServicesByName"); if (XposedHelpers.callMethod(mServicesByName, "get", XposedHelpers.getObjectField(sr, "name")) != sr) { Object cur = XposedHelpers.callMethod(mServicesByName, "get", XposedHelpers.getObjectField(sr, "name")); Slog.wtf(TAG, "Service " + sr + " in process " + app + " not same as in map: " + cur); Object app_services = XposedHelpers.getObjectField(app, "services"); XposedHelpers.callMethod(app_services, "removeAt", i); continue; } // Any services running in the application may // need to be // placed back in the pending list. Object serviceInfo = XposedHelpers.getObjectField(sr, "serviceInfo"); Object applicationInfo = XposedHelpers.getObjectField(serviceInfo, "applicationInfo"); if (allowRestart &amp;&amp; XposedHelpers.getIntField(sr, "crashCount") &gt;= 2 &amp;&amp; (XposedHelpers.getIntField(applicationInfo, "flags") &amp; ApplicationInfo.FLAG_PERSISTENT) == 0) { Slog.w(TAG, "Service crashed " + XposedHelpers.getIntField(sr, "crashCount") + " times, stopping: " + sr); EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH, XposedHelpers.getObjectField(sr, "userId"), XposedHelpers.getObjectField(sr, "crashCount"), XposedHelpers.getObjectField(sr, "shortName"), XposedHelpers.getObjectField(app, "pid")); XposedHelpers.callMethod(param.thisObject, "bringDownServiceLocked", sr); } else if (!allowRestart) { XposedHelpers.callMethod(param.thisObject, "bringDownServiceLocked", sr); } else { boolean canceled = (Boolean) XposedHelpers.callMethod(param.thisObject, "scheduleServiceRestartLocked", sr, true); // Should the service remain running? Note // that in the // extreme case of so many attempts to // deliver a command // that it failed we also will stop it here. if (XposedHelpers.getBooleanField(sr, "startRequested") &amp;&amp; (XposedHelpers.getBooleanField(sr, "stopIfKilled") || canceled)) { Object pendingStarts = XposedHelpers.getObjectField(sr, "pendingStarts"); if ((Integer) XposedHelpers.callMethod(pendingStarts, "size") == 0) { XposedHelpers.setBooleanField(sr, "startRequested", false); if (XposedHelpers.getObjectField(sr, "tracker") != null) { Object tracker = XposedHelpers.getObjectField(sr, "tracker"); Object mAm = XposedHelpers.getObjectField(param.thisObject, "mAm"); Object mProcessStats = XposedHelpers.getObjectField(mAm, "mProcessStats"); XposedHelpers.callMethod(tracker, "setStarted", false, XposedHelpers.callMethod(mProcessStats, "getMemFactorLocked"), SystemClock.uptimeMillis()); } if (!XposedHelpers.getBooleanField(sr, "hasAutoCreateConnections")) { // Whoops, no reason to restart! XposedHelpers.callMethod(param.thisObject, "bringDownServiceLocked", sr); } } } } } if (!allowRestart) { Object app_services = XposedHelpers.getObjectField(app, "services"); XposedHelpers.callMethod(app_services, "clear"); // Make sure there are no more restarting // services for this // process. Object mRestartingServices = XposedHelpers.getObjectField(param.thisObject, "mRestartingServices"); for (int i = (Integer) XposedHelpers.callMethod(mRestartingServices, "size") - 1; i &gt;= 0; i--) { Object r = XposedHelpers.callMethod(mRestartingServices, "get", i); String processName = (String) XposedHelpers.getObjectField(r, "processName"); Object serviceInfo = XposedHelpers.getObjectField(r, "serviceInfo"); Object applicationInfo = XposedHelpers.getObjectField(serviceInfo, "applicationInfo"); Object info = XposedHelpers.getObjectField(app, "info"); if (processName.equals((String) XposedHelpers.getObjectField(app, "processName")) &amp;&amp; XposedHelpers.getIntField(applicationInfo, "uid") == XposedHelpers.getIntField(info, "uid")) { XposedHelpers.callMethod(mRestartingServices, "remove", i); XposedHelpers.callMethod(param.thisObject, "clearRestartingIfNeededLocked", r); } } Object mPendingServices = XposedHelpers.getObjectField(param.thisObject, "mPendingServices"); for (int i = (Integer) XposedHelpers.callMethod(mPendingServices, "size") - 1; i &gt;= 0; i--) { Object r = XposedHelpers.callMethod(mPendingServices, "get", i); String processName = (String) XposedHelpers.getObjectField(r, "processName"); Object serviceInfo = XposedHelpers.getObjectField(r, "serviceInfo"); Object applicationInfo = XposedHelpers.getObjectField(serviceInfo, "applicationInfo"); Object info = XposedHelpers.getObjectField(app, "info"); if (processName.equals((String) XposedHelpers.getObjectField(app, "processName")) &amp;&amp; XposedHelpers.getIntField(applicationInfo, "uid") == XposedHelpers.getIntField(info, "uid")) { XposedHelpers.callMethod(mPendingServices, "remove", i); } } } // Make sure we have no more records on the stopping // list. Object mDestroyingServices = XposedHelpers.getObjectField(param.thisObject, "mDestroyingServices"); int i = (Integer) XposedHelpers.callMethod(mDestroyingServices, "size"); while (i &gt; 0) { i--; Object sr = XposedHelpers.callMethod(mDestroyingServices, "get", i); if (XposedHelpers.getObjectField(sr, "app") == app) { XposedHelpers.callMethod(sr, "forceClearTracker"); XposedHelpers.callMethod(mDestroyingServices, "remove", i); if (DEBUG_SERVICE) Slog.v(TAG, "killServices remove destroying " + sr); } } Object executingServices = XposedHelpers.getObjectField(app, "executingServices"); XposedHelpers.callMethod(executingServices, "clear"); return null; } }); } catch (Throwable t) { XposedBridge.log(t); } }</span></span></code> </pre><br></div></div><br>  This is how I allowed all applications to write information on an SD card, when this functionality was cut down for security purposes on KitKat. <br><br><div class="spoiler">  <b class="spoiler_title">hookSDcardPermission</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { XposedHelpers.findAndHookMethod(<span class="hljs-string"><span class="hljs-string">"com.android.server.SystemConfig"</span></span>, paramLoadPackageParam.classLoader, <span class="hljs-string"><span class="hljs-string">"readPermission"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.xmlpull.v1.XmlPullParser"</span></span>, <span class="hljs-string"><span class="hljs-string">"java.lang.String"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XC_MethodHook() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterHookedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHookParam param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ String permission = (String) param.args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (permission.equals(<span class="hljs-string"><span class="hljs-string">"android.permission.WRITE_EXTERNAL_STORAGE"</span></span>)) { Class&lt;?&gt; process = XposedHelpers.findClass(<span class="hljs-string"><span class="hljs-string">"android.os.Process"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gid = (Integer) XposedHelpers.callStaticMethod(process, <span class="hljs-string"><span class="hljs-string">"getGidForName"</span></span>, <span class="hljs-string"><span class="hljs-string">"media_rw"</span></span>); Object mPermissions = XposedHelpers.getObjectField(param.thisObject, <span class="hljs-string"><span class="hljs-string">"mPermissions"</span></span>); Object localPermissionEntry = XposedHelpers.callMethod(mPermissions, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, permission.intern()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] gids = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]) XposedHelpers.getObjectField(localPermissionEntry, <span class="hljs-string"><span class="hljs-string">"gids"</span></span>); XposedHelpers.setObjectField(localPermissionEntry, <span class="hljs-string"><span class="hljs-string">"gids"</span></span>, ArrayUtils.appendInt(gids, gid)); } } }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { XposedBridge.log(t); }</code> </pre><br></div></div><br>  Access to variables and class methods is done through the XposedHelpers class.  For example: <br><br><pre> <code class="java hljs">Object mActivity = XposedHelpers.getObjectField(param.thisObject, <span class="hljs-string"><span class="hljs-string">"mActivity"</span></span>);</code> </pre> <br>  If the object is an accessible imported class, then the resulting object can be immediately cast to the desired type. <br><br><pre> <code class="java hljs">(Activity) mActivity = (Activity) XposedHelpers.getObjectField(param.thisObject, <span class="hljs-string"><span class="hljs-string">"mActivity"</span></span>);</code> </pre> <br>  and facilitate further code.  If the object is some type of internal class that is not available to us for import, further use of its methods and properties is also available through XposedHelpers. <br><br>  In summary, we can change the static and final variables of any class, anytime, anywhere.  Check variables passed to methods, change them before execution, change the result of individual methods, or completely replace them with your own code. <br><br>  In most cases, it is enough to catch the desired method and modify or change its logic as soon as the application is launched.  But there is a known problem with the limit of the number of methods in one DEX file, therefore many bulky applications have 3-5 additional DEX files.  Here is hidden underwater rock.  It's pretty easy to get around it: <br><br><div class="spoiler">  <b class="spoiler_title">multi dex</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleLoadPackage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( LoadPackageParam paramLoadPackageParam)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LoadPackageParam llpm = paramLoadPackageParam; String packageName = paramLoadPackageParam.packageName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (packageName.contains(<span class="hljs-string"><span class="hljs-string">"ubercab.driver"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    DEX  try{ XposedHelpers.findAndHookMethod("com.ubercab.driver.feature.main.MainActivity", llpm.classLoader, "onNewIntent", "android.content.Intent", new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { //    } }); } catch (Throwable t) { XposedBridge.log(t); } //    DEX . XposedHelpers.findAndHookMethod(Application.class, "attach", Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { //     ,     DEX . try { XposedHelpers.findAndHookMethod( "com.ubercab.driver.feature.online.DispatchedFragment", llpm.classLoader, "onCreateView", "android.view.LayoutInflater", "android.view.ViewGroup", "android.os.Bundle", new XC_MethodHook() { //    } ); } catch (Throwable t) { XposedBridge.log(t); } } }); } }</span></span></code> </pre> <br></div></div><br>  As for obfuscated applications, at first glance you need to rewrite the module with each new application release.  There is always a way out of this situation, but this is a separate topic.  The basic principle is to find a class that is not obfuscated and backtracking to determine the names of classes and methods. <br><br><h2>  <b>Conclusion</b> </h2><br>  I gave the basic tricks and solutions to the problems of programming that I encountered in the course of the development of various modules.  I see no reason to analyze each case in detail, since experienced programmers just need to use the guides from the author <a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial">here</a> and <a href="https://github.com/rovo89/XposedBridge/wiki/Replacing-resources">here</a> . <br><br>  With this I plan to finish the cycle of articles about the modification of firmware, but the theme of the practical application of Xposed, I hope, is not closed.  There are plans for a large article about how I worked as a Uber driver and developed the Xposed module, which gave me extensive information about both the upcoming trip and during the order, which, to my surprise, is not provided in the standard application.  He got a very, very interesting experience and made conclusions: both about the quality of the Uber architecture itself, and about what information is transmitted through the application about users and how, perhaps, the company plans to monetize its service and the data obtained in the future. </div><p>Source: <a href="https://habr.com/ru/post/318202/">https://habr.com/ru/post/318202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318188/index.html">Backing up with Commvault: some statistics and cases</a></li>
<li><a href="../318190/index.html">Being present and writing VS code to sort out and seem</a></li>
<li><a href="../318194/index.html">Free Seminar "Oracle Cloud Security Day: Technologies for Business Security", February 2</a></li>
<li><a href="../318198/index.html">Excel Almighty and Redmine: how to generate tasks right in Excel</a></li>
<li><a href="../318200/index.html">Mobile bank for iOS: add block architecture to Cocoa MVC</a></li>
<li><a href="../318204/index.html">How I translated the BEM project ... and translated</a></li>
<li><a href="../318208/index.html">12 more big data cases</a></li>
<li><a href="../318210/index.html">Attempts to open a new checkers tactic or what to do with a pipe dream</a></li>
<li><a href="../318212/index.html">Secrets of a successful update: interface, backend, application structure</a></li>
<li><a href="../318214/index.html">5 really free non-linear video editors for Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>