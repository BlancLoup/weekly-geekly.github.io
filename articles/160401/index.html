<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Precision bitmap rotation at an arbitrary angle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rotation of a raster image at angles that are multiples of 90 ¬∞ relative to the geometric center of the image is a trivial task and is solved without ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Precision bitmap rotation at an arbitrary angle</h1><div class="post__text post__text-html js-mediator-article">  Rotation of a raster image at angles that are multiples of 90 ¬∞ relative to the geometric center of the image is a trivial task and is solved without loss of quality by simply transforming the coordinates of each pixel. <br><br>  To rotate the bitmap at an arbitrary angle, fast but not optimal algorithms have been developed that provide an approximation that is acceptable for practical purposes with a loss of quality (for example, <a href="http://zhukovsd.blogspot.com/2010/04/blog-post.html">this one</a> ). <br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/5b5/7db/cb65b57dbeee53418c96abe9a361e854.png" align="left">  For quite a long time, out of purely sports interest, I was interested in the task of maximally accurate bitmap rotation at an arbitrary angle.  Unfortunately, I could not find a ready-made algorithm anywhere, so I had to do it myself.  Even if in the end I ‚Äúinvented the bicycle‚Äù, the result, I think, was interesting enough to be shared. <br><br>  Below we consider the algorithm of precision rotation of a raster image at an arbitrary angle relative to an arbitrary center with minimal losses. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I express my gratitude to Kharchenko Vladislav Vladimirovich for the assistance provided. <br><a name="habracut"></a><br><h2>  Algorithm </h2><br>  It can be seen from the above picture that after rotating a raster image, the color of each pixel of the final image is determined by adding the colors of several ‚Äúfragments‚Äù of several pixels of the original image, proportional to the areas of the corresponding ‚Äúfragments‚Äù.  Therefore, in general, the solution to our problem will be to <b>find the areas of all the "fragments" for each pixel of the original image and collect the color of each pixel of the final image from the colors of the corresponding "fragments"</b> . <br><br>  As the pixel model of the original image, we will use a square with a side = 1, with the following angle designations: <br><img src="https://habrastorage.org/getpro/habr/post_images/851/3b3/ffa/8513b3ffa0d1f4823b2229e0272f04f2.gif" align="left">  i1 is the rightmost corner; <br>  i2 is the lowest corner; <br>  i3 is the leftmost corner; <br>  i4 is the topmost corner. <br><br>  The model of the final image will be a grid of parallel horizontal and vertical lines with the distance between the lines = 1. <br><br>  The coordinates of the center of rotation of the raster image, in this representation, can be expressed by a pair of arbitrary real numbers.  That is, the center of rotation in our problem may lie not at the geometric center of the pixel and not at the point of intersection of the grid lines, but at an arbitrary point of Cartesian coordinates. <br><br>  Since, when rotating a raster image, the square of each pixel is rotated by the same angle (relative to the center of this pixel) we will solve the problem for one pixel, and then apply the solution obtained for each pixel of the original image. <br><br>  The bitmap rotation can be divided into two parts: <br>  1. Rotate the square of each pixel of the original image relative to the center of this square at a given angle. <br>  2. The offset of the center of the square of the pixel in accordance with the angle of rotation of the image relative to the center of rotation of the image so that the square takes up its final position on the grid of the final image. <br>  At the same time, the grid of the final image cuts the square of each pixel of the original image into ‚Äúfragments‚Äù in the amount of 4, 5 or 6 pieces. <br><br>  To systematize the variety of the resulting options, I had to compile a taxonomy of all possible intersections of the square of a pixel of the original image with the grid of the final image.  There were only 23 essentially different options: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fa/978/a2e/0fa978a2e125e3030f0e66ae8ca7d3dc.png"><br>  The conventions here are as follows: <br>  - the numbers in the cells indicate the number of corners of the square of a pixel that fell into the given grid cell of the final image after the image was rotated; <br>  - the green color indicates the cells into which the pixel sections fell and are guaranteed to be left there by a ‚Äúfragment‚Äù; <br>  - yellow color indicates cells, which, depending on the conditions, <b>may</b> fall (or may not fall) "fragments" of a square of a pixel, formed not by the corners of a square, but by the sides of a square. <br><br>  For clarity, I will give one of the possible variations of option number 3: <br><img src="https://habrastorage.org/getpro/habr/post_images/822/ed9/1e4/822ed91e4253dc31bcb92c9126a43547.png" align="left"><br>  As you can see, the upper right cell does not contain a ‚Äúfragment‚Äù of a pixel, although under other conditions it could contain a turn. <br clear="all">  In order not to load the reader with detailed geometric calculations, I will say at once that in all these 23 variants, the pixel of the original image is dissected into ‚Äúfragments‚Äù, the area of ‚Äã‚Äãwhich is easily calculated by combining 4 formulas.  Below are these formulas with illustrations.  Red color indicates grid lines of the final image, which cut through the square of a pixel.  The yellow area is shaded area, the area of ‚Äã‚Äãwhich is calculated by the formula. <br><br><h5>  Formula 1 </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/bf9/f83/81b/bf9f8381b3dceaad3c88469c141e9d48.png" align="left">  This formula is not used to calculate the final area of ‚Äã‚Äãthe ‚Äúfragment‚Äù, but it is convenient to use it to quickly calculate auxiliary intermediate areas, since we know that the area of ‚Äã‚Äãthe entire pixel is 1. <br>  The input variables in all formulas use heights dropped from the corners of a square onto the grid of the final image, for the simple reason that calculating these heights is reduced to instantaneous selection of the fractional part of the numerical value of the coordinate of the corresponding angle of a square pixel. <br><br clear="all"><h5>  Formula 2 </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/b25/41e/6a2/b2541e6a248a2978351ad235d78545d5.png" align="left"><br>  This formula is used only in options 1 and 2. <br><br clear="all"><h5>  Formula 3 </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/2aa/1c4/c0f/2aa1c4c0f6f5bab1182d6ba4e9cff09e.png" align="left">  A frequently used formula is very good that it is quickly calculated.  Since the rotation angle is the same for each pixel - all trigonometric functions can be calculated once, before processing all pixels, and then use these values ‚Äã‚Äãin the loop as constants. <br><br clear="all"><h5>  Formula 4 </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/322/c66/bce/322c66bce154cd7befa76ea53dbfc18f.png" align="left">  This formula is calculated in two steps.  First, the expression in brackets is evaluated.  If it takes a positive value, then the area is calculated.  If the value is negative, then the ‚Äúfragment‚Äù formed by the corner of the grid and the side of the square is not cut off from the pixel, and it makes no sense to perform further calculations. <br><br clear="all">  In view of the foregoing, in general, the algorithm will look like this: <br>  1. Load the original image into the computer memory. <br>  2. Calculate the size of the final image in pixels. <br>  3. Create an intermediate two-dimensional array, each element of which contains 3 components of the RGB color in the format of a floating-point number.  The size of the array is equal to the size of the final image. <br>  4. Sequentially iterate through all the pixels of the original image;  rotate each of them at a given angle and place it on the grid of the final image, calculating 4 coordinates of the corners of a square pixel;  we classify a pixel according to 23 variants and count the areas of "fragments";  we add to the corresponding elements of the intermediate array the colors of the obtained ‚Äúfragments‚Äù in proportion to the area of ‚Äã‚Äãthese ‚Äúfragments‚Äù. <br>  5. After processing all the pixels of the original image, we round off the RGB values ‚Äã‚Äãin the intermediate array to an integer value for each element and create a final image in BMP format based on these integer values. <br><br><h2>  Program </h2><br>  Based on the above algorithm, a program for Windows was written.  Source codes on Object Pascal and the compiled executable file can be downloaded <a href="">here</a> . <br><br>  Program interface <br>  By clicking on the "Open ..." button, a dialog box for selecting a BMP file opens.  Only bitmaps with 24-bit palette are supported.  The open image is displayed in the window.  The window header displays the full file path and image size. <br><br>  In the "Angle" field, you can set the rotation angle in degrees - any positive number. <br>  As a decimal separator when entering fractional numbers, both a period and a comma can be used. <br><br>  Radio buttons "CW" and "CCW" set the direction of rotation: "clockwise" and "counterclockwise", respectively. <br><br>  In the ‚ÄúBackground color‚Äù block you can set the background color with which the boundary pixels of the image will be mixed.  The default background color is black. <br><br>  In the "Center X" and "Center Y" fields, the coordinates of the center of rotation are specified.  It should be borne in mind that the origin is in the upper left corner of the image and Y increases down.  By default, the center of rotation is set to the geometric center of the loaded image. <br><br>  By clicking on the ‚ÄúRotate‚Äù button or by pressing the Enter key, the image is rotated at a given angle relative to the specified center of rotation and displayed in a window.  Rotation of the image at angles that are multiples of 90 ¬∞ is implemented in a simplified scheme, by simply converting the coordinates of the pixels in the original image, while the values ‚Äã‚Äãof ‚ÄúCenter X‚Äù and ‚ÄúCenter Y‚Äù are ignored. <br>  The running time of the algorithm in seconds is displayed under the ‚ÄúRotate‚Äù button. <br><br>  Via the ‚ÄúSave ...‚Äù button, the rotated image can be saved to a BMP file. <br><br>  If the final image does not fit in the window - it fits to the window borders with the StretchBlt API function - therefore, you can only assess the real quality of large images from a saved BMP file. <br>  To rotate the image to a different angle, you do not need to load it again - the image from the selected file is rotated, but not the one currently displayed in the window. <br><br>  An image with dimensions of 1024 x 768 on a machine with a quad core processor of 2.67 GHz is rotated by this program at an arbitrary angle, on average, approximately in 0.5 seconds.  An image with dimensions of 4000 x 4000 - in about 10 seconds.  The running time of the algorithm for different angles may differ due to the fact that the image at different angles is split into different numbers of ‚Äúfragments‚Äù, the total time spent on calculating the areas of which is total, respectively, different times. <br><br>  The intermediate array containing the pixel color information of the final image in the floating point number format is implemented on the extended type (10 bytes), therefore processing of large images (approximately more than 5000 x 5000 pixels) can cause a memory overflow error.  It is possible to improve the situation by applying a less accurate data type and saving the integer part of the number immediately to the final bitmap, leaving only the fractional part in the auxiliary array. <br><br><h2>  results </h2><br>  We will conduct a comparative analysis of the work of the precision algorithm and the image rotation algorithm implemented in Photoshop. <br><br><h5>  Test 1 </h5><br>  For the first test, I took a very simple image ‚Äî a horizontal black line with a thickness of 1 pixel and a length of 10 pixels, offset from the center of the white square with dimensions of 100 x 100 pixels: <br><img src="http://prosolver.kiev.ua/rotate_test.bmp"><br><br>  After that, I rotated this image relative to the point with coordinates (0, 0) 3 ¬∞ clockwise.  The point (0, 0) was chosen because, judging by my experiments, Photoshop rotates the image relative to this particular point.  Here is the comparative result (increased 24 times): <br><img src="http://prosolver.kiev.ua/rotate_result1.BMP" align="left"><br><br>  Precision algorithm <br><br><br><br><br><br>  Photoshop 7.0.1 <br><br><br><br><br><br>  Photoshop CS6 (64 Bit) <br clear="all">  The Photoshop algorithm gives a more contrast image, the precision algorithm somewhat "blurs" the image.  But in general, with a visual assessment, the result is almost the same.  Along the way, we note that the rotation algorithm implemented in Photoshop has not undergone significant changes over 10 years. <br><br><h5>  Test 2 </h5><br>  For the second test, I chose a tulip from the standard Win7 distribution: <br><br><img src="http://prosolver.kiev.ua/rotate_Tulip.BMP"><br><br>  After turning this image 5 ¬∞ clockwise relative to the geometric center, I summarized the color of all the pixels in the context of the RGB channels.  Here is the result for the precision algorithm and the Photoshop algorithm: <br><table><tbody><tr><td><h5>  Original </h5></td><td><h5>  Precision turn <br>  (before rounding) </h5></td><td><h5>  Precision turn <br>  (after rounding) </h5></td><td><h5>  Photoshop CS6 </h5></td></tr><tr><td>  R = 33381406 <br>  G = 27933900 <br>  B = 11239213 <br></td><td>  R = 33381406,0000004 <b>(~ 0)</b> <br>  G = 27933899.9999997 <b>(~ 0)</b> <br>  B = 11239212.9999999 <b>(~ 0)</b> <br></td><td>  R = 33382786 <b>(1380)</b> <br>  G = 27933920 <b>(20)</b> <br>  B = 11238086 <b>(-1127)</b> <br></td><td>  R = 33387726 <b>(6320)</b> <br>  G = 27950823 <b>(16923)</b> <br>  B = 11245937 <b>(6724)</b> <br></td></tr></tbody></table>  The numbers in parentheses indicate the absolute deviation of this indicator from the original. <br>  The color of the image after the precision rotation and before rounding almost did not change - which was to be expected. <br>  The largest deviation, in this particular case, we find on channel G for the Photoshop algorithm.  In percentage terms, this deviation is only 0.06%, so "by eye" it is not noticeable, but for reasons of perfectionism, the result of Photoshop is worse than that of a precision algorithm. <br>  It is important to note that rounding off the color of each pixel in the precision algorithm to the integer value required for the BMP format irreversibly destroys some of the color information. <br><br>  For a visual comparison of two algorithms, I will give an enlarged fragment of the image, <br><img src="http://prosolver.kiev.ua/rotate_Tulip_orig.BMP"><br><br>  rotated 5 ¬∞ clockwise, respectively, with Photoshop: <br><img src="http://prosolver.kiev.ua/rotate_ps_tulip_5.bmp"><br><br>  and precision algorithm: <br><img src="http://prosolver.kiev.ua/rotate_my_tulip_5.bmp"><br><br>  Comparative analysis shows that Photoshop better preserves the contrasting elements of the image, but it also creates ‚Äúhalos‚Äù of distorted color.  The precision algorithm does not distort the color but at the same time ‚Äúblurs‚Äù the image somewhat. <br><br><h2>  findings </h2><br>  1. Precision and at the same time relatively quick rotation of the bitmap at an arbitrary angle is possible.  It remains a mystery to me why the professional graphic editors do not have an option that allows the user to rotate the image extremely precisely in a little more time. <br><br>  2. Despite the extreme accuracy of the considered algorithm, the inverse image transformation, i.e.  rotation to the opposite angle without loss of quality is impossible, because rounding off the exact color value (in the format of a floating point number) irreversibly destroys some of the color information. <br><br>  3. From the point of view of visual perception of contrasting details, the best result is given by the suboptimal Photoshop algorithm.  Precision same algorithm makes sense to apply in cases where it is important to keep the maximum information about the color of the image. <br><br>  <b>UPD:</b> For practical use, I wrote a program that implements a simplified algorithm, in which for each pixel of the final image all the necessary pieces of pixels of the original image are calculated sequentially and the color rounds off immediately.  Only after that the next pixel of the final image is calculated.  In this case, the program accesses several pixels of the original image.  Calculation time, therefore, has increased, on average, by 1.7 times, but the memory in this version of the algorithm is spent only on the storage of bitmaps, which allows you to work with images of large sizes.  Download the program and source code <a href="">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/160401/">https://habr.com/ru/post/160401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../160389/index.html">Why Joomla Fails in Russia</a></li>
<li><a href="../160391/index.html">Designer "Video Control"</a></li>
<li><a href="../160395/index.html">Automatic optimization of MySQL, PostgreSQL settings</a></li>
<li><a href="../160397/index.html">Service goal setting. How the idea gained incarnation</a></li>
<li><a href="../160399/index.html">The practice of developing mobile sites</a></li>
<li><a href="../160405/index.html">ID Software continues to publish Doom III source</a></li>
<li><a href="../160409/index.html">Brainwashing ‚ÄúInterfaces for iPhone‚Äù on December 1, 2 and 4</a></li>
<li><a href="../160411/index.html">Telltale Games Success Secret</a></li>
<li><a href="../160413/index.html">SSD is not for everyone, or how I talked to Fusion-io ioDrive Duo</a></li>
<li><a href="../160417/index.html">‚ÄúPlanet 0‚Äù from Beeline will drag MTS roaming subscribers and Megafon in distant countries? (updated)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>