<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Secure crypto programming. Part 2, final</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are continuing to translate the set of secure crypto-programming rules from Jean-Phillip Omasson ... 

 Prevent compiler tampering with parts of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Secure crypto programming. Part 2, final</h1><div class="post__text post__text-html js-mediator-article">  We are continuing to translate the set of secure crypto-programming rules from Jean-Phillip Omasson ... <br><br><h1>  Prevent compiler tampering with parts of the code that critically affect security. </h1><br><h3>  Problem </h3><br>  Some compilers optimize operations that they deem useless. <br><br>  For example, the MS Visual C ++ compiler considered the | memset |  in the following snippet of the Tor anonymous network implementation: <br><a name="habracut"></a><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_pk_private_sign_digest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> digest[DIGEST_LEN]; (...) <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(digest, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(digest)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  However, the role of this operator | memset |  is to clear the buffer | digest |  from confidential data so that any subsequent readings of data from the uninitialized stack will not allow you to receive confidential information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Some compilers believe that they can remove conditional checks, considering the code to be erroneous anywhere in the program.  For example, finding the following code snippet <br><br><pre> <code class="hljs pgsql"> call_fn(ptr); //   ptr. //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { error("ptr must not be NULL"); }</code> </pre><br>  some compilers will decide that the condition | ptr == NULL |  should always be FALSE, because otherwise it would be incorrect to dereference it in the function | call_fn () |. <br><br><h3>  Decision </h3><br>  Analyze the compiled code and make sure that all instructions are present in it.  (This is not possible for standard-sized applications, but this should be done for a security-critical code snippet). <br><br>  Understand what optimizations your compiler can do and carefully evaluate the effect of each of them in terms of the principles of safe programming.  In particular, be careful with optimizations that remove code snippets or branching, as well as code snippets that prevent errors that ‚Äúcannot occur‚Äù if the rest of the program is correct. <br><br>  Whenever possible, consider disabling that optimization during compilation, which removes or weakens the verification of conditions affecting security. <br><br>  To prevent deletion of instructions through optimization, the function can be redefined using the volatile keyword.  This is for example used in libottery when overriding | memset |: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * (*<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> memset_volatile)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>;</code> </pre><br>  In C11, a call to memset_s is introduced, for which deletion during optimization is prohibited. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __STDC_WANT_LIB_EXT1__ 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; ... memset_s(secret, sizeof(secret), 0, sizeof(secret));</span></span></span></span></code> </pre><br><br><h1>  Do not mix safe and insecure software interfaces. </h1><br><h3>  Problem </h3><br>  Many programming environments provide different implementations of the same software interfaces ‚Äî their functionality is outwardly the same, but the security properties are radically different. <br><br>  This problem is typical of random number sensors: OpenSSL has | RAND_bytes () |  and | RAND_pseudo_bytes () |, the BSD C-libraries have | RAND_bytes () |  and | RAND_pseudo_bytes () |, in Java - | SecureRandom |  and | Random | <br><br>  Another example would be the fact that in systems that provide time-independent byte word comparison functions, at the same time, there are variations that can leak over time. <br><br><h3>  Bad decisions </h3><br>  Sometimes the function is safe on some platforms and dangerous on others.  In these cases, programmers use this function, considering that their code will be executed on platforms where it is safe.  This is a bad approach, because the code can be ported to other platforms and become insecure - no one will notice. <br><br>  In systems that allow redefinition of platform-specific functions, some programmers override insecure functions with safe functions and write programs using a software interface, which is normally unsafe.  This is a rather controversial approach, since it causes the programmer to write code that looks unsafe.  Moreover, if the overridden method does not work ever, the program will become unsafe and this cannot be determined.  And finally, this will lead to the fact that the code fragments of such programs will be unsafe, if they are copied to other projects. <br><br><h3>  Decision </h3><br>  If possible, do not use unsafe security options.  For example, a PDCH based on a strong stream cipher with a random initial fill is fast enough for most applications.  Independent of the data type, a memcmp replacement is also fast enough to be used for all the memory comparison operations. <br><br>  If you cannot remove unsafe functions, redefine them so that an error is generated at the compilation stage, or use static code analysis tools to detect and warn about the use of unsafe functions.  If you can redefine an insecure function with its safe option, then for greater security, never call the insecure API and make sure that you can detect the fact of its use. <br><br>  If you need to leave both options (safe and unsafe) make sure that the names of the functions are so different that it will be difficult to accidentally use the unsafe option.  For example, if you have a secure and insecure PDCP, do not call the unsafe variant ‚ÄúRandom‚Äù, ‚ÄúFastRandom‚Äù, ‚ÄúMersenneTwister‚Äù or ‚ÄúLCGRand‚Äù - instead name it, for example, ‚ÄúInsecureRandom‚Äù.  Design your programming interfaces so that using insecure functions is always a little scary. <br><br>  If your platform provides an unsafe version of a function without a name that says it is insecure and you cannot remove this function, use a system call wrapper with a safe name, then by static code analysis, identify all uses of the unsafe name. <br><br>  If the function is safe on some platforms and unsafe on others, do not use the function directly: define and use a secure wrapper instead. <br><br><h1>  Avoid confusing security levels and cryptographic primitive abstractions at the same API level. </h1><br><h3>  Problem </h3><br>  When it is not clear what analysis different parts of the program interface require, the programmer can easily make a mistake in what functionality they can safely use. <br><br>  Consider the following example (invented, but similar to those found in real life) of the RSA software interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rsa_padding_t</span></span> { no_padding, pkcs1v15_padding, oaep_sha1_padding, pss_padding }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_rsa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct rsa_key *key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> encrypt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">public</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rsa_padding_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padding_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *output)</span></span></span></span>;</code> </pre><br>  Suppose that the ‚Äúkey‚Äù parameter contains the components of the details, then the function can be called in 16 ways, many of which are meaningless and some are unsafe. <br><table><tbody><tr><th>  encryption / decryption </th><th>  symmetrical / asymmetrical <br></th><th>  padding type <br></th><th>  remarks </th></tr><tr><td>  0 </td><td>  0 </td><td>  none </td><td>  Decryption without padding.  The possibility of forgery. </td></tr><tr><td>  0 </td><td>  0 </td><td>  pkcs1v15 </td><td>  Decryption PKCS1 v1.5.  Possibly subject to Blainebacher's attack. </td></tr><tr><td>  0 </td><td>  0 </td><td>  oaep </td><td>  OAEP decryption.  A good option. </td></tr><tr><td>  0 </td><td>  0 </td><td>  pss </td><td>  PSS decryption.  A rather strange variant, possibly leading to unintended errors. </td></tr><tr><td>  0 </td><td>  one </td><td>  none </td><td>  Signed without padding.  The possibility of forgery. </td></tr><tr><td>  0 </td><td>  one </td><td>  pkcs1v15 </td><td>  Signature PKCS1 v1.5.  Suitable for some applications, but it is better to use the PSS signature. </td></tr><tr><td>  0 </td><td>  one </td><td>  oaep </td><td>  OAEP Signature.  Suitable for some applications, but it is better to use the PSS signature. </td></tr><tr><td>  0 </td><td>  one </td><td>  pss </td><td>  Signed PSS.  Very good option. </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  the remaining options (encryption and signature verification). </td></tr></tbody></table><br><br>  Note that only 4 of the 16 possible ways to call this function are safe, 6 more are unsafe, and the remaining 6 in some cases can cause problems with the application.  This API is only suitable for developers who understand the implications of using various add-ons in the RSA system. <br><br>  Now imagine that we add software interfaces for block encryption in various modes, key generation, various message authentication codes and signatures.  Any programmer who tries to develop the correct function that implements data authentication and encryption using such software interfaces will have a huge number of choices, while the number of secure options will obviously decrease. <br><br><h3>  Decision </h3><br><ul><li>  Provide high-level software interfaces.  For example, provide functions that implement data encryption and authentication, which use only strong algorithms and in a safe manner.  When you write a function that provides various combinations of symmetric and asymmetric algorithms and their modes of operation, make sure that this function does not allow the use of unsafe algorithms and their unsafe combinations. <br></li><li>  When possible, avoid low-level APIs.  Most users do not need to use RSA without add-ons, use a block cipher in ECB mode, or use a DSA signature with a random value selected by the user.  These functions can be used as building blocks in order to implement something strong ‚Äî for example, do OAEP padding before an RSA call without an add-on, use ECB encryption for blocks 1,2,3, ... to implement counter mode or use a random or unpredictable byte sequence for a random DSA value, but practice shows that they will often be used incorrectly rather than correctly. <br><br>  Some other primitives are necessary for the implementation of certain protocols, but most likely will not be suitable for the implementation of new protocols.  For example, you cannot implement a TLS browser without CBC, PKCS1 v1.5 and RC4, but any of these primitives is not a good option. <br><br>  If you provide a cryptographic module for use by inexperienced programmers, it is better to avoid such functions completely and select (for the API) only functions that implement well-described high-level secure operations. <br></li><li>  If you still have to provide the interface to both experienced and inexperienced users, clearly separate the high-level and low-level software interfaces.  The ‚Äúsecure encryption‚Äù function should not be the same function as ‚Äúincorrect encryption‚Äù with slightly modified arguments.  In languages ‚Äã‚Äãthat separate functions and types into packages and headers, safe and insecure crypto functions should not be contained in the same packages and headers.  In languages ‚Äã‚Äãwith subtypes, there must be separate types for secure crypto implementations. <br></li></ul><br><br><h1>  Use unsigned types to represent binary data. </h1><br><h3>  Problem </h3><br>  In some C-like languages, signed and unsigned integer types are different.  In particular, in C the question is whether the type | char |  landmark depends on implementation.  This can lead to a problem code, such as, for example, the following: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrypt_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... char *name; char buf[257]; decrypt_data(key, buf, 257); int name_len = buf[0]; name = malloc(name_len + 1); memcpy(name, buf+1, name_len); name[name_len] = 0; //... }</span></span></code> </pre><br>  If | char |  unsigned, this code behaves as we expect it to.  But if | char |  signed | buf [0] |  can take negative values, resulting in very large values ‚Äã‚Äãof the arguments of the | malloc | functions  and | memcpy |  and heap damage potential if we try to set the value of the last character to 0. The situation can be even worse if | buf [0] |  equal to 255, then name_len will be equal to -1.  Thus, we allocate a buffer of size 0 bytes in memory, and then we copy | | (size_t) -1 memcpy |  into this buffer, causing the heap to clog up. <br><br><h3>  Decision </h3><br>  In languages ‚Äã‚Äãthat distinguish between signed and unsigned byte types, implementations must use unsigned types to represent byte strings in their APIs. <br><br><h1>  Clear the memory of secret data </h1><br><h3>  Problem </h3><br>  In most operating systems, the memory used by one process can be used by another process without prior cleaning, because the first process is stopped or the memory is returned to the system.  If the memory contains secret keys, they will be available to another process, which increases the chance of their compromise.  In multi-user systems, this makes it possible to determine the keys of other users of the system.  Even within the same system, this situation may lead to the fact that previously relatively ‚Äúsafe‚Äù vulnerabilities could lead to leakage of secret data. <br><br><h3>  Decision </h3><br>  Clear all variables that contain sensitive data until you forget about them and use them.  Using the function | mmap () |  remember that running | munmap () |  instantly frees up memory and you lose control of it. <br><br>  To clear memory or destroy objects that go out of your sight, use platform-specific memory cleaning functions, where possible - such as | SecureZeroMemory () |  for win32 or | OPENSSL_cleanse () |  for openssl. <br><br>  A more or less universal solution for C could be: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">burn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = ( <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * )v; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( n-- ) *p++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br><h1>  Use "strong" randomness </h1><br><br><h3>  Problem </h3><br>  Many cryptographic systems require sources of randomness, and such systems may become insecure even in the case of small deviations from randomness in such sources.  For example, the leakage of even one random number in a DSA will lead to an extremely fast identification of the secret key.  Inadequate randomness is quite difficult to determine: the <a href="http://www.debian.org/security/2008/dsa-1571">error of the</a> Debian random number generator in OpenSSL went unnoticed for two years, leading to the compromise of a large number of keys.  The requirements for random numbers for cryptographic applications are very strict: many pseudo-random number generators do not satisfy them. <br><br><h3>  Bad decisions </h3><br>  For cryptographic applications <br><br><ul><li>  Do not rely on predictable sources of randomness, such as time stamps, identifiers, temperature sensors, etc. </li><li>  do not rely on pseudo-random common function functions such as | rand () |, | srand () |, | random () |  libraries | stdlib |  or | random |  python language </li><li>  <a href="http://crypto.di.uoa.gr/CRYPTO.SEC/Randomness_Attacks.html">Do not use the</a> Mersenne Twister Generator (Mersenne Twister) </li><li>  Do not use resources like <a href="http://www.random.org/">www.random.org</a> (random data may be known to third parties or may also be used by them). <br></li><li>  Do not use your own random number generator, even if it is based on strong crypto-primitive (unless you know exactly what you are doing). <br></li><li>  Do not use the same random bits in different places of the application, for their "economical" spending. </li><li>  Do not conclude that the generator is only resistant because it passes <a href="http://www.stat.fsu.edu/pub/diehard/">Diehard</a> or <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/stats_tests.html">NIST</a> tests <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/stats_tests.html">.</a> <br></li><li>  Do not conclude that a cryptographically stable generator necessarily protects you from reading ahead and reading backwards. </li><li>  Never use ‚Äúrandomness‚Äù in its pure form as random data (analog random sources often have deviations, so the N bits received from such a source have less than N random bits). </li></ul><br><br><h3>  Decision </h3><br>  Minimize the use of randomness by selecting primitives and their design (for example, <a href="http://ed25519.cr.yp.to/">Ed25519</a> allows <a href="http://ed25519.cr.yp.to/">you</a> to get curves for electronic signatures in a deterministic way).  For generating random numbers, use sources provided by the operating systems and guaranteed to meet cryptographic requirements, such as | / dev / random |.  On platforms with limited resources, consider using analog sources of random noise and a good mixing procedure. <br><br>  Be sure to <a href="http://jbp.io/2014/01/16/openssl-rand-api/">check the</a> values ‚Äã‚Äãproduced by your sensor to make sure that the bytes received are as they should be and that they were recorded properly. <br><br>  Follow the recommendations of Nadi Heninger et al. In section 7 of their <a href="https://factorable.net/weakkeys12.extended.pdf">article</a> . <br><br>  On Intel processors with the Ivy Bridge architecture (and later generations), the built-in <a href="http://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide">generator</a> guarantees high entropy and speed. <br><br>  On Unix systems, | / dev / random |  or | / dev / urandom |.  However, the first one has the blocking property, i.e.  it does not return values ‚Äã‚Äãif it believes that not enough randomness has been accumulated.  This property limits convenience. <br>  its use, and therefore | / dev / urandom |  used more often.  Use | / dev / urandom |  simple enough: <br><br><pre> <code class="hljs go">#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> randint; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes_read; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/urandom"</span></span>, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { bytes_read = read(fd, &amp;randint, sizeof(randint)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytes_read != sizeof(randint)) { fprintf(stderr, <span class="hljs-string"><span class="hljs-string">"read() failed (%d bytes read)\n"</span></span>, bytes_read); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fprintf(stderr, <span class="hljs-string"><span class="hljs-string">"open() failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-2</span></span>; } printf(<span class="hljs-string"><span class="hljs-string">"%08x\n"</span></span>, randint); <span class="hljs-comment"><span class="hljs-comment">/* assumes sizeof(int) &lt;= 4 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  However, this simple program may not be sufficient for the safe generation of randomness: it is safer to perform additional error checks as in the function | getentropy_urandom |  <a href="http://libressl.org/">LibreSSL</a> <br><br><pre> <code class="hljs go">static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> getentropy_urandom(void *buf, size_t <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> stat st; size_t i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, cnt, flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> save_errno = errno; start: flags = O_RDONLY; #ifdef O_NOFOLLOW flags |= O_NOFOLLOW; #endif #ifdef O_CLOEXEC flags |= O_CLOEXEC; #endif fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/urandom"</span></span>, flags, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EINTR) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> nodevrandom; } #ifndef O_CLOEXEC fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC); #endif <span class="hljs-comment"><span class="hljs-comment">/* Lightly verify that the device node looks sane */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fstat(fd, &amp;st) == <span class="hljs-number"><span class="hljs-number">-1</span></span> || !S_ISCHR(st.st_mode)) { <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> nodevrandom; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ioctl(fd, RNDGETENTCNT, &amp;cnt) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> nodevrandom; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>; ) { size_t wanted = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> - i; ssize_t ret = read(fd, (char *)buf + i, wanted); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EAGAIN || errno == EINTR) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> nodevrandom; } i += ret; } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gotdata(buf, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { errno = save_errno; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* satisfied */</span></span> } nodevrandom: errno = EIO; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  On Windows systems <a href="http://msdn.microsoft.com/en-us/library/aa379942.aspx">| CryptGenRandom |</a>  from the Win32 API produces pseudo-random bits suitable for use in cryptography.  Microsoft offers the following use case: <br><br><pre> <code class="hljs kotlin">#include &lt;stddef.h&gt; #include &lt;stdint.h&gt; #include &lt;windows.h&gt; #pragma comment(lib, <span class="hljs-string"><span class="hljs-string">"advapi32.lib"</span></span>) int randombytes(unsigned char *<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>, size_t outlen) { static HCRYPTPROV handle = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* only freed when program ends */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!handle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!CryptAcquireContext(&amp;handle, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(outlen &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DWORD len = outlen &gt; <span class="hljs-number"><span class="hljs-number">1048576</span></span>UL ? <span class="hljs-number"><span class="hljs-number">1048576</span></span>UL : outlen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!CryptGenRandom(handle, len, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> += len; outlen -= len; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  If you focus on use in Windows XP or later versions, the above code on CryptoAPI can be replaced by <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694%2528v%3Dvs.85%2529.aspx">| RtlGenRandom |</a> <br><br><pre> <code class="hljs rust">#include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #define RtlGenRandom SystemFunction036 #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(__cplusplus) <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> #endif BOOLEAN NTAPI RtlGenRandom(PVOID RandomBuffer, ULONG RandomBufferLength); #pragma comment(lib, <span class="hljs-string"><span class="hljs-string">"advapi32.lib"</span></span>) int main() { uint8_t buffer[<span class="hljs-number"><span class="hljs-number">32</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FALSE == RtlGenRandom(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> buffer)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> buffer; ++i) printf(<span class="hljs-string"><span class="hljs-string">"%02X "</span></span>, buffer[i]); printf(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/269737/">https://habr.com/ru/post/269737/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269727/index.html">Multi-tier, extensible business information repository architecture. LSA and SAP BW. Traditional approach</a></li>
<li><a href="../269729/index.html">Certificate Transparency Overview</a></li>
<li><a href="../269731/index.html">Why Go is a badly designed programming language.</a></li>
<li><a href="../269733/index.html">Concepts of natural language versus formal classifications in OpenStreetMap</a></li>
<li><a href="../269735/index.html">How lighthouses work: iBeacon Physics Technology</a></li>
<li><a href="../269739/index.html">Conference on web analytics and internet marketing CONVERT.2015 will be held in Yekaterinburg on December 7</a></li>
<li><a href="../269741/index.html">Swift + VK.API, or the story of SwiftyVK</a></li>
<li><a href="../269743/index.html">We continue to fight the frontend-routine</a></li>
<li><a href="../269745/index.html">Learning machine learning</a></li>
<li><a href="../269747/index.html">Why google voice neural nets search?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>