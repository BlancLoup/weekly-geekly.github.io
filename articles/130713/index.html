<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Series 2. How to perform ancestor methods in prototype inheritance modification</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's design it in habrahabr.ru/blogs/javascript/130495, which is convenient for using the .inherit4 method of the Constr designer, to actually build ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Series 2. How to perform ancestor methods in prototype inheritance modification</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/252/c46/fda/252c46fda2af26bc27692ada652a5bed.png" alt="image">  Let's design it in <a href="http://habrahabr.ru/blogs/javascript/130495/">habrahabr.ru/blogs/javascript/130495, which</a> is convenient for using the <i>.inherit4</i> method of the <i>Constr</i> designer, to actually build a model of classes and inheritance (it will be more powerful than the classical one, but this is a side effect).  If you do not want to connect Mootools with a similar model, this method of 2 KB of uncompressed code will be enough to work normally with prototype inheritance and have a couple of additional methods: access to ancestor methods.  Using all 3 methods allows you to exclude the words <i>prototype</i> and <i>constructor</i> from the lexicon, while continuing to work with both, and makes the code easy to read. <br><a name="habracut"></a><br>  In the 1st part on 2 functions, we built an implementation of an idea that can be used, but I would like to improve the quality of the future code.  Wishlist for improvement: <br><br>  1) to improve the writing and readability of the code when writing the inheritance tree - in particular, to write inheritance through the method of an object acting as a class (now it is a function); <br>  2) use the execution of constructors to enable <i>this.some_method = ...</i> ;  (now they are not executed, only prototypes work, therefore the traditional creation of methods is not available); <br>  3) add a parameter for the expansion of the prototype of the constructor - we regularly, after each inheritance, expand the prototype of the descendant with new methods;  it is necessary to put the operation on a regular basis;  The previous article contains the <i>extend ()</i> function; <br>  4) embed <i>.ancestor</i> in the inheritance constructor (now we also have this function). <br><br>  In fact, we want to get the <i>Class</i> object in terms of Mootools, but having access to the ancestors and performing regular actions to load the child prototype.  And in general, the inheritance code is improving; this is one of the goals of building a method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About access to the ancestors in the 1st part sounded rich in content critic, thanks to everyone, especially, <a href="http://habrahabr.ru/users/lalaki/" class="user_link">lalaki</a> , <a href="http://habrahabr.ru/users/andrewsumin/" class="user_link">AndrewSumin</a> .  Its general direction is 1) access to the ancestors is not needed, except to the immediate ancestor, according to the basic principles of the PLO, otherwise it indicates poor-quality design of the model and the model must be changed.  Also, 2) it is easy to access via <i>(constructor-name prefix) .prototype.pred_ method.apply (this, parameters)</i> , but also comments on OOP should not be ignored. <br><br>  Answers: <br>  1. Exactly, access to the distant ancestor speaks about the incorrect design (Liskov principle), except for the case when we want to insert a multiple inheritance node into the Procrustean inheritance bed JS - where 2 or more classes (constructors) are connected.  And about access to the nearest parent, the principle says that it is permissible (how else can it be used).  Our function makes it in the most abbreviated form, with the 2nd parameter by default (1) - .ancestor ('method'). <br><br>  2. Yes, access through 4 words " <i>class.prototype.metho.apply</i> " is, only 3 extra words are added instead of one: class name and 2 service words, and ' <i>ancestor</i> ' and the relative node number are sufficient.  On the other hand, when rearranging the structure of inheritance, the verbose expression does not change, and the node number may change. <br><br>  Thus, the criticism does not force us to turn <i>away</i> from the intended path - the purpose of introducing the <i>.ancestor</i> method was reasonable, we must complete the statement and present a fairly perfect way of inheritance containing our <i>.ancestor</i> .  Nevertheless, criticism is important - it forces you not to forget that you need to avoid unnecessary parameter calls for executing methods, and ideally only referring to your immediate ancestor (for this, the second parameter in <i>.ancestor</i> defaults to 1) or not referring to ancestors at all. <br><br><h3>  Making the function method for Function </h3><br>  You can write the <i>inherit ()</i> method (inheritance) through the base class prototype.  We'll have to overload the base <i>Function</i> class, and this method will appear in every function.  This is bad - each function is clogged, a source of conflicts with other software arises, but a very compact format for recording inheritance is created (this indicates a lack of constructor language for inheritance).  Therefore, to illustrate and better understand the structure, we give an example of inheritance with this compact code. <br><br>  <a href="http://spmbt.kodingen.com/inherit/inheritFun.htm">Link to an example</a> (Firebug is convenient to view the work and methods). <br><br>  In fact, this is a test case with testing capabilities, like other links to examples in articles.  Analysis and its construction will be lower, but no longer on the basis of <i>Function</i> , therefore, consideration of this code should be addressed if something is not clear further - or simply for aesthetic reasons.  Moreover, this code and example do exactly the same as the following, more perfect. <br><br><h3>  Solution without overloading the base Function object </h3><br>  To avoid the appearance of methods in <i>Function</i> , create a class <i>Constr</i> (constructor) - an analogue of the <i>Class</i> constructor in Mootools.  Immediately there is a need for additional movements - we can no longer write <i>(constructor) .inherit</i> , because the function does not have it.  It is necessary to use either the prototype of the constructor (but this is long), or the <i>Constr</i> object <i>to</i> be considered a constructor, but in fact the constructor is a function in this object, or every time the constructor function is <i>loaded with the</i> definition of <i>inherit ()</i> . <br><br>  The latter, although somewhat costly (copying the link to each constructor), but more consistent with the concept of the constructor - it remains a function.  Therefore, we‚Äôll dwell on this approach: every time we will load (add) the definition of <i>inherit ()</i> . <br><br><h3>  Inheritance in pictures </h3><br>  Here it is obvious that the multifunctional code is difficult to understand, therefore the scheme of how one step of inheritance works (using the <i>.inherit4 ()</i> method) is given.  Basically, it makes a new constructor an operation <i>new</i> and ensures that the new constructor has: 1) a prototype ( <i>prototype</i> ), 2) a function <i>inherit4 ()</i> , and in a prototype that there are at least 4 properties: <i>ancestor</i> (function), <i>extend</i> (function ), <i>constructor</i> (a function is a link to itself), <i>_anc</i> (a function is a link to a parent constructor) and 3) to them are all the properties of the constructor and its prototype, and the properties of the prototype are more priority and do not require action.  The first 2 properties of the prototype ( <i>ancestor, extend</i> ) are also copied automatically and do not require actions - there is no copying in the code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/879/c98/df5/879c98df51e5cf3d2bddc6db40752f4b.png"><br><br><h4>  Bottom line: recording inheritance functions </h4><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *        . spmbt, 2011 * @param {Constructor} Inherited - - ( extProto,   ) * @param {Object} extProto -     * @param contextArg0 - 1-     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Constr = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; Constr.inherit4 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Inherited, extProto, contextArg0</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f2 ={<span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, extObj</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    if(obj ==null) obj = this; if(arguments.length &gt;2) for(var a =1, aL = arguments.length; a &lt; aL; a++) arguments.callee(obj, arguments[a]) else{ if(arguments.length ==1){ extObj = obj; obj = this; } for(var i in extObj) obj[i] = extObj[i]; } return obj; }, ancestor: function(name, level, constr){ //    level = level || (level ==0 ? 0 : 1); var t =this; return level &lt;= 1 ? (level ? constr &amp;&amp; constr.prototype[name] || t.constructor.prototype[name] : t[name]) : arguments.callee.call(this, name, level -1 , constr &amp;&amp; (constr.prototype._anc != Function &amp;&amp; constr.prototype._anc || constr.prototype.constructor) || t._anc ); }}; if(!this.prototype || !this.prototype.ancestor){ if(!this.prototype) this.prototype ={}; for(var i in f2) //       this.prototype[i] = f2[i]; } if(this === Constr &amp;&amp; Inherited != Constr){ //   if(Inherited ===null) Inherited = Constr; return arguments.callee.call(Inherited, Inherited, extProto, contextArg0); }else{ if(Inherited || (Inherited &amp;&amp; typeof Inherited !='function' &amp;&amp; !extProto)){ //   ,   extend + ancestor     if(!extProto){ //  1 -       - extProto = typeof Inherited !='function' ? Inherited :{}; Inherited = typeof Inherited !='function' ? function(){} : Inherited; } Inherited.prototype = new this(contextArg0); Inherited.inherit4 = arguments.callee; f2.extend(Inherited.prototype, {_anc: this, constructor: Inherited}, extProto); return Inherited; }else{ if(this === window) return Constr; else{ this.prototype.constructor = this; return this; //  ,   - } } } }; //: A = Constr.inherit4(function(){this.prop ='A';}, {protoProp:'protoA'}); B = A.inherit4(function(){this.prop ='B';}, {protoProp:'protoB'}); C = B.inherit4(function(arg){this.prop ='C';this.propArg = arg ||'XX';}, {protoProp:'protoC'}); D = C.inherit4(function(arg){this.propArgD = arg ||'XX';}, {protoProp:'protoD'}, '3thArgInCInh'); var c01 = new D('ArgInD'); //B.prototype._anc = B; Alert(c01['protoProp'], c01.ancestor('protoProp', 0), c01.ancestor('prop', 0), c01.prop) //'protoD protoD DD' Alert(c01.constructor.prototype.protoProp, c01.ancestor('protoProp'), c01.ancestor('prop', 1)) //'protoD protoD C' Alert(c01.ancestor('protoProp', 2), c01.ancestor('prop', 2) ); //'protoC B' Alert(c01.ancestor('protoProp', 3), c01.ancestor('prop', 3) ); //'protoB A' Alert(c01.ancestor('protoProp', 4), c01.ancestor('prop', 4) ,'-- prop    ,    '); //'protoA C' Alert(c01.ancestor('protoProp', 5), c01.ancestor('prop', 5) ,'-- protoProp    '); //'protoA C' Alert(c01.ancestor('protoProp', 6), c01.ancestor('prop', 6) ); //'protoA C' Alert(c01.ancestor('protoProp2', 4), c01 instanceof A, c01 instanceof D, '--   - undedfined; instanceof - '); //'undefined D true true' Alert(c01.propArg, '--     C; ', c01.propArgD, '--    D');</span></span></code> </pre> <br>  (For a <a href="http://spmbt.kodingen.com/inherit/inheritConstr.htm">working example</a> with a number of additional tests described below, see the console (output is in console.log ()).) <br><br><h3>  Terms of use (instead of documentation) </h3><br><table><tbody><tr><td>  Creating root class: <br><pre> <code class="javascript hljs">_ = Constr.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{_;}, __, <span class="hljs-number"><span class="hljs-number">1</span></span>___); <span class="hljs-comment"><span class="hljs-comment">//  ,    //  ,     - {}   _</span></span></code> </pre> <br>  Class inheritance: <br><pre> <code class="javascript hljs">_ = _.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{_;}, ___, <span class="hljs-number"><span class="hljs-number">1</span></span>___);</code> </pre> <br>  Creating an instance is, as usual, <i>instance = new class ()</i> ; <br>  The inheritance indicator is, as usual, an <i>instance of the || class instanceof ancestor_class</i> ; <br>  // when <i>instanceof</i> multiple inheritance does not work, if you do not line up the inheritance tree <br><br>  Appeal to ancestor method: <br><pre> <code class="javascript hljs">.ancestor(<span class="hljs-string"><span class="hljs-string">''</span></span>, _); <span class="hljs-comment"><span class="hljs-comment">//   =1</span></span></code> </pre> <br>  Possible reference to ancestor method by class name (not implemented in code, link <a href="http://habrahabr.ru/blogs/javascript/130713/">#</a> ): <br><pre> <code class="javascript hljs">.ancestor(, <span class="hljs-string"><span class="hljs-string">''</span></span>, [__]);</code> </pre> <br>  <b>Overloaded operations:</b> <b><br></b>  <b>-----------------------</b> <br>  Adding one hash to yourself: <br><pre> <code class="javascript hljs">__Constr.extend(xe);</code> </pre> <br>  Adding a few hashes to yourself: <br><pre> <code class="javascript hljs">.extend(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, xe, xe, ...);</code> </pre> <br>  Expansion of any hash: <br><pre> <code class="javascript hljs">_  = __Constr.extend(xe, xe, ...); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></td></tr></tbody></table><br><h4>  Intended Criticism and Responses </h4><br>  Analysis of testing will be a little further, and here - the answers for those who have already figured out. <br><br>  <b>1)</b> here the class constructor is executed instead of <i>new F ()</i> in the previous function;  The environment will be loaded a little more if the application constructor is empty and is no different from <i>F ()</i> .  But it is possible to construct properties.  Will the environment be loaded more when a property appears in the constructor?  No, because otherwise they would be declared in the prototype, and their preparation would not be carried out in a constructor, but somewhere close by, which threatens with unstructured code.  Therefore, it is better to do in the designer the formation of those properties of the prototype of the heir that we need and which depend on the designer. <br><br>  <b>2)</b> Is the inheritance method becoming a bit heavier with a couple of additional functions and some checks?  This is a prototype, so the declaration is weighted down once in the root constructor itself, but execution is not, if it is not used.  If used, it should still be defined somewhere. <br>  Checks, of course, slightly slow down the work, but we get a number of amenities.  Do they need - to decide the developer.  In my opinion, something that facilitates development is justified at least during the development phase. <br><br>  <b>3)</b> Why is there only one <i>contextArg0</i> argument for the ancestor?  Because an attempt to write the construction of an object as <i>Inherited.prototype = new (this.apply (this, contextArgs));</i>  - does not work.  But one argument will be enough to specify a hash with all the parameters in it - almost the same and more convenient description of the arguments. <br><br>  4) Why an extra <i>if</i> entity <i>(this === window) ...</i> ?  For an overloaded hash expansion method (with empty 1st argument or with 1 argument).  Inheritance is not used. <br><br><h3>  Using Constructor Arguments </h3><br>  Constructor arguments are a very important and useful mechanism for specifying heirs or generated objects, which can determine the properties of a constructor and, thus, they are included in a full circle, becoming dynamic.  But in the implementation it was not possible to pass many arguments in the array in order to scatter them through <i>apply</i> in the function <i>new this ()</i> - this is not implemented in javascript.  But the argument of the constructor is so important that we enter at least one - in place of the third argument in <i>inherti4</i> .  (It would be better if it were the first one, but then writing is complicated when the method is overloaded.) <br><br>  There is a demonstration of use in the example.  In class <i>C,</i> we determined the function that takes the first argument ‚Äî we write the first argument for it in place of the third argument in <i>C.inherit4 ()</i> .  In class <i>D,</i> we identified a similar function ‚Äî in the generation of the instance, the argument is used in its first place. <br><br>  Of course, it is inconvenient that the argument jumps from place to place.  But how to make the overload differently, given that the argument for the constructor is most often not?  You can use that the current first argument is always a function, but then the argument for the constructor can also be a function.  Therefore, let everything stay in place for the time being, but with real use of the mechanism, maybe we will invent something better.  The main thing is that this mechanism now exists and works. <br><br>  By the argument of the constructor, the function of automatically spreading the hash on the properties of <i>this</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   if( typeof arg =='object') //    for(var i in arg) this[i] = arg[i]; }</span></span></code> </pre> <br>  How to make this scattering automatic?  To insert even a single call of something into the constructor function every time is not very interesting.  Let's invent instead of simple construction of the successor <br><br><pre> <code class="javascript hljs">Inherited.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(contextArg0);</code> </pre> <br>  extended: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> contextArg0 ==<span class="hljs-string"><span class="hljs-string">'object'</span></span>){ Inherited.prototype = contextArg0; f2.extend(Inherited.prototype, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(contextArg0)); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Inherited.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(contextArg0);</code> </pre> <br>  As you can see, it works, but introduces an unobvious feature for constructing an object and adds another check.  We will not include it in the final code, but we should try to apply it in order to display a convenient format. <br><br>  If you swap the order of assignment, <br><br><pre> <code class="javascript hljs"> Inherited.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(contextArg0); f2.extend(Inherited.prototype, contextArg0);</code> </pre> <br>  we will get an atypical priority of assigning constructor properties (more priority than a prototype), which may come in handy sometime (but this is even more dangerous experiment on habits, therefore we also only mention it). <br><br><h3>  Analysis of tests and mechanism of action </h3><br>  You can compare the type of tests with <a href="http://spmbt.kodingen.com/inherit/inherit3.htm">an example from the first article</a> .  Almost the same thing is done (plus the execution of constructors), but the code is no longer so loose, the arguments fell into place.  This is a consequence of the fouling of the function code with new checks and movement towards some goal. <br><br>  The example began to involve the properties of constructors - those that arise from " <i>this.xxx</i> ".  In the test example, we carefully arranged the letters <i>A, B, C, D</i> each in its own level.  In the results we see the shift of letters.  This is quite logical, because <i>.ancestor</i> extracts prototypes (except <i>c01.ancestor ('prop', 0)</i> ), and the prototype arises from the heir: the ancestor's property is written into the prototype.  It turns out that we see next: the property - from the previous class, the prototype - from the current one.  Only the instance of <i>c01</i> in the sample prototype is not (not written), so it is taken from the previous class, so the first line - ‚ÄúprotoD D‚Äù - is the same for the output letters, and in the following there is a shift. <br><br>  In order for the properties from prototypes and constructors to behave in exactly the same way, it was necessary to catch the <i>if</i> condition <i>(this === Constr) ...</i> in order to detect the first ancestor and "loop" inheritance.  Works, as in the first part of the story, the ‚Äúbomb of kindness‚Äù, which does not give an error when addressing the missing property.  However, it was ensured that the behavior when accessing the ‚Äútoo early‚Äù ancestor is the same for all properties: the first existing property of the parent is returned or <i>undefined</i> . <br><br>  Tests that work in the example by reference show how multiple inheritance works (defective), how overloaded methods work in objects that have an ancestor <i>Constr</i> .  About this - just below. <br><br><h3>  Inheritance model and its variations </h3><br>  Such a somewhat bizarre model of inheritance turned out, if both the properties of the constructors and the prototypes are involved.  The model is more powerful than the classical inheritance, and if you look closely, then within it (this algorithm of 30 lines) you can implement an analog of the classical inheritance in more than two ways - only through prototypes or only through properties.  Or inheritance "with a doubled frequency of steps" in this order: <ol><li>  The base class is the prototype of constructor A (its properties are stored in the same place in the prototype); </li><li>  1st heir - properties of constructor A (stored in the prototype of the 2nd heir); </li><li>  The 2nd heir is the prototype of constructor B (the properties are here, in the prototype of the 2nd heir); </li><li>  3rd heir - properties of constructor B (stored in the prototype of the 4th heir); </li><li>  ... </li></ol>  Of course, this is not pure classical inheritance, because you can change the prototypes of any constructor, therefore, instantly change the properties of all heirs.  On the other hand, the properties of ancestors are not stored in each class (unless there is optimization in the script engine), and if you avoid the ‚Äúerrors‚Äù of changing prototypes after creating successors, you will get classical inheritance, even in the ‚Äúdouble frequency steps‚Äù mode. <br><br><h3>  Multiple inheritance </h3><br>  Compatibility, we must also say that multiple inheritance is not supported by the <i>instanceof</i> operation.  Making it react to the tree of ancestors can only be a way to line up the tree in the line of ancestors.  At the same time, due to a special feint in inherit4 () with the addition of the properties of the prototype, if it already exists, the merging of the branches from the ancestors is done normally.  The code with mixing is not included in the example, so inheritance will not work - the prototype will receive the value only from the last ancestor. <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> = Constr.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop =<span class="hljs-string"><span class="hljs-string">'prop1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propA =<span class="hljs-string"><span class="hljs-string">'propA'</span></span>;}, {<span class="hljs-attr"><span class="hljs-attr">protoProp</span></span>:<span class="hljs-string"><span class="hljs-string">'prot1'</span></span>}); <span class="hljs-number"><span class="hljs-number">2</span></span> = Constr.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop =<span class="hljs-string"><span class="hljs-string">'prop2'</span></span>;});  = <span class="hljs-number"><span class="hljs-number">1.</span></span>inherit4({<span class="hljs-attr"><span class="hljs-attr">protoProp</span></span>:<span class="hljs-string"><span class="hljs-string">'prot11'</span></span>, <span class="hljs-attr"><span class="hljs-attr">protoPropA</span></span>:<span class="hljs-string"><span class="hljs-string">'protA'</span></span>});  = <span class="hljs-number"><span class="hljs-number">2.</span></span>inherit4(, {<span class="hljs-attr"><span class="hljs-attr">protoProp</span></span>:<span class="hljs-string"><span class="hljs-string">'prot2'</span></span>});</code> </pre> <br>  The correct result is the alignment of the merge tree into the " <i>Ancestor1-Ancestor2-Heir</i> " chain of inheritance - a case when the method of addressing ancestral methods with a generation greater than 1 comes in handy. <br><br><h3>  Where can I apply a double inheritance rate? </h3><br>  Where the structure of inheritance is determined and for each level we know what to write.  For example, there is the task of using the default program settings (base class), which are overlapped by the ‚Äúrecommended settings‚Äù, which are overlapped by the ‚Äúrecommended priority‚Äù, which finally are overlapped by the user settings.  Total - 4 levels of settings, everywhere - inheritance relations.  Obviously, in JS they can be implemented by 2 constructors and inheritance of the described type. <br><br>  In this example, even the class procedures will be the same.  In cases more complicated - it is possible to write your own procedures for each ‚Äúhalf-step‚Äù of inheritance. <br><br>  All this is not a virtue, but simply an additional opportunity that you can not use, but write one step of inheritance per operation. <i>Inherit4 ()</i> .  And, of course, you need to understand the model of inheritance in JS for this use; knowledge of classical inheritance will not be enough. <br><br><h3>  Expansion of properties - we will extend the description of extend into ‚Äúpublic‚Äù, and a number of other </h3><br>  Properties that are not necessary, because they solve side problems, but the code for them is written and used.  This is an <i>extend</i> method for expanding hashes and the associated overloading of arguments ‚Äî for use in different modes for different purposes.  (These properties are already implemented in the function above and in the example.) Why?  Yes, at least for faster merging hashes than in jQuery, where more type checks are done. <br>  <b>1)</b> In fact, why should the good (in a few lines of the <i>extend</i> function) disappear, since it is written and ready to infiltrate wherever the <i>Constr is</i> defined?  (You may not like the fact that it inserts <i>extend</i> into all inherited objects, but there are no problems to disable it.) <br><br>  <b>2)</b> ... And, oh, walk - so walk, add to <i>extend the</i> possibility of expanding yourself, if you write one argument or in place of the first argument is <i>null</i> . <br><br>  <b>3)</b> Additional convenience - we can write <i>(constructor). Inherit4 ()</i> , without arguments, to include in the prototype both functions - <i>extend</i> and <i>ancestor</i> , if we are not going to inherit this class (constructor).  <i>(object) .ancestor ('method_name')</i> will also make sense if the generated object ( <i>object = new constructor ();</i> ) was later attributed to a direct wiping method ‚Äî the constructor‚Äôs prototype method (not the constructor itself) will have ‚Äúhuman-readable‚Äù access (along with <i>object.constructor.prototype [name]</i> ). <br><br>  Example (so it will be clearer than the same words): <br>  Note that a similar example for <i>Function.prototype.inherit3</i> also knows how, but is written differently. <br><br><pre> <code class="javascript hljs"> = Constr.inherit4(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">333</span></span>}); <span class="hljs-comment"><span class="hljs-comment">//   = new (); //   - .a = 555; //  Alert(.a, .ancestor('a'), "--     "); //    : 333      : Alert(.extend({a:3}, {b:4}, {c:5}), "--      " ); //Object {a=3, b=4, c=5}</span></span></code> </pre><br>  <b>4)</b> Given that we are returning the first argument, it is possible to create a nameless heir, in order to assign it a name later (more correctly, assign it a name :)). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     (  - null) obj = new (Constr.inherit4()); Alert( obj.extend(null, {a:1}, {b:2}) ); //Object { a=1, b=2, _anc=function(), ...</span></span></code> </pre><br>  <b>5)</b> In the examples we have already forgotten that in the first part of the article we had to write explicitly the prototype of the object - now this is done by the 2nd parameter, it is visual and convenient: <br><br><pre> <code class="javascript hljs">A = Constr.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{_ }, {_});</code> </pre> <br>  In this format: <br><pre> <code class="javascript hljs">A = <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop =<span class="hljs-string"><span class="hljs-string">'A'</span></span>;}, {<span class="hljs-attr"><span class="hljs-attr">protoProp</span></span>:<span class="hljs-string"><span class="hljs-string">'protoA'</span></span>});</code> </pre>  the code looks much better than with the scattered definition of properties. <br>  As a result, we see that the code has grown "meat", but each section operates very effectively. <br><br>  We should not forget that the <i>.extend</i> method <i>was</i> not attributed to the base Object class, so this is <i>{x: 2} .extend ({a: 1});</i>  - will not work (the cost of abstaining from expanding the base class).  But <br><br><pre> <code class="javascript hljs">Alert( (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (Constr.inherit4(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">2</span></span>;}) ) ).extend({<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>});</code> </pre> <br>  - will be (gives the object <i>{a: 1, x: 2, and a pair of functions}</i> ).  (A nightmare, of course, no one will do, but the idea is shown ( <i>extend</i> itself) and will work in the case of more stretched codes.) The main thing is that we do not lose anything (only the namespace is <i>clogged</i> ), the <i>extend</i> function has already been, just assigned to the prototype of the root object <i>Constr</i> , like <i>ancestor</i> . <br><br>  PS If someone gives a link to the description of at least a very similar approach to inheritance or the same, we will all be very grateful - it‚Äôs interesting to know where this approach leads. <br><br>  PS2 Do I need to get rid of the bomb of kindness and how? </div><p>Source: <a href="https://habr.com/ru/post/130713/">https://habr.com/ru/post/130713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130704/index.html">Watchdog for replication in PostgreSQL 9</a></li>
<li><a href="../130707/index.html">Nesztapap - old-school non-commercial site</a></li>
<li><a href="../13071/index.html">Closed the exit / entrance to the garage, what to do?</a></li>
<li><a href="../130710/index.html">Interception PPPoE session</a></li>
<li><a href="../130712/index.html">Broadcast from a Google and Samsung event in Hong Kong - Galaxy Nexus features, new Android 4.0 Ice Cream Sandwich [updated]</a></li>
<li><a href="../130714/index.html">Acer Iconia Tab - how to disassemble the tablet and what it consists of</a></li>
<li><a href="../130716/index.html">October 19 - It-english speaking club: Silicon Valley from Russia</a></li>
<li><a href="../130717/index.html">USSD in Android</a></li>
<li><a href="../130718/index.html">Android 4.0 Ice Cream Sandwich SDK will be available via ... Already available!</a></li>
<li><a href="../130720/index.html">How to save and how to use the money?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>