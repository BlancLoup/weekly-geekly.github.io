<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generic and metaprogramming models: Go, Rust, Swift, D and others</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In some areas of programming, it‚Äôs normal to want to write a data structure or algorithm that can work with elements of different types. For example, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generic and metaprogramming models: Go, Rust, Swift, D and others</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  In some areas of programming, it‚Äôs normal to want to write a data structure or algorithm that can work with elements of different types.  For example, a list of generics or a sorting algorithm that only needs a comparison function.  In various languages, various ways of solving this problem are offered: from simply pointing out the appropriate common functions (C, Go) to programmers to such powerful generic systems that they become Turing complete ( <a href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">Rust</a> , <a href="http://matt.might.net/articles/c%2B%2B-template-meta-programming-with-lambda-calculus/">C ++</a> ).  In this article I will talk about generic systems from different languages ‚Äã‚Äãand their implementation.  I'll start by solving the problem in languages ‚Äã‚Äãwithout a similar system (like C), and then I will show how the gradual addition of extensions leads to systems from other languages. <br><a name="habracut"></a><br>  I find generics to be an interesting option because they are a simple special case of the general metaprogramming task: writing programs that can generate classes of other programs.  As a proof, I will show how three different and completely general metaprogramming methods can be considered multidirectional extensions in the space of generic systems: dynamic languages ‚Äã‚Äãlike Python, procedural macro systems like <a href="https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial">Template Haskel,</a> and phased compilation like <a href="https://ziglang.org/">Zig</a> and <a href="http://terralang.org/">Terra</a> . <br><br><h2>  Overview </h2><br>  I drew a block diagram of all the systems described in the article so that you can present its contents and how these systems are interconnected: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Main ideas </h2><br>  Suppose we are writing in a language without generic systems, and we want to make a generic stack data structure data structure that works with data of any type.  The problem is that each function and type definition will only work with data of the same size and copied in one way, and generally work similarly. <br><br>  There are two ways to get around this: either make sure that all data types act in the same way in our structure, or make many copies of the data structure with minor changes to work correctly with each data type.  These ideas formed the basis of two large groups of solutions with generics: boxing and monomorphization. <br><br>  Packaging means putting everything in a row into unified ‚Äúboxes‚Äù that work the same way.  This is usually done like this: the data is put in a heap, and the pointers to it are placed in the data structure.  You can make pointers to all types that will work the same way, so the same code will work with data of any type!  However, this leads to increased memory consumption, dynamic search, and cache misses.  In C, this means that your data structure stores <code>void*</code> pointers and simply caches data to and from <code>void*</code> (if the data is not on the heap, it places them there). <br><br>  Monomorphization means copying code repeatedly for the different types of data that we want to store.  Then each code instance can directly use the size and data methods that it works with without dynamic search.  With this approach, the code runs the fastest, but its size and compilation time increase, because we repeatedly compile the same code with minor changes.  In C, this corresponds to the <a href="https://www.cs.grinnell.edu/~rebelsky/musings/cnix-macros-generics">definition of the entire data structure as a macro</a> , followed by its invocation for each data type. <br><br>  In general, when compiling, the code compiles faster, but its performance may deteriorate during execution, while during monomorphization we generate fast code, but it takes more time to compile and optimize all instances of the code.  Another difference is that when packaging extensions allow you to make more dynamic behavior of the executable code, and monomorphization allows you to more flexibly separate different instances of the generic code.  It is also worth noting that in some large programs, the benefits of monomorphization can be offset by misses in the cache of additional instructions from the generated code. <br><br>  Each of the described schemes for working with generics can be expanded in different directions, if you need more features or security, and the authors of various languages ‚Äã‚Äãhave come up with very interesting solutions.  For example, both approaches can be used in Rust and C #! <br><br><h2>  Packaging </h2><br>  Let's start with an example of basic packaging in Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  Also, packaging is used in C ( <code>void*</code> ), Go ( <code>interface{}</code> ), pre-generic Java ( <code>Object</code> ) and pre-generic Objective-C ( <code>id</code> ). <br><br><h2>  Packed Generics with Mashing Types </h2><br>  The main packaging method has disadvantages: <br><br><ul><li>  Depending on the language, we often have to cast values ‚Äã‚Äãto or from the correct type each time we read or write to the data structure. <br></li><li>  Nothing prevents us from putting elements of different types into the structure, which can provoke bugs that look like crashes during code execution. <br></li></ul><br>  Both problems can be solved by adding generic types of functionality to the system, while using the main packaging method in the same way as before during code execution.  This approach is often called type erasure, because types in the generic system are ‚Äúoverwritten‚Äù and become one type under the hood (like <code>Object</code> ). <br><br>  Java and Objective-C started with the usual packaging, and later acquired language tools for generics with type mashing, for the sake of compatibility, using the same collection types as before, but with the optional parameters of generic types.  Consider a Wikipedia example about <a href="https://en.wikipedia.org/wiki/Generics_in_Java">generics in Java</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  Derived Packaged Generics with Unified Performance </h3><br>  OCaml further develops the idea of ‚Äã‚Äãa unified view.  There are no primitive types that need additional packaging placement (like an <code>int</code> must turn into <code>Integer</code> to get into an <code>ArrayList</code> in Java), because everything is already packed or represented by an integer value the size of a pointer, that is, everything fits into one machine word.  But when the garbage collector looks at the data stored in generic structures, it needs to distinguish pointers from numbers, so numbers are marked with a single bit, placed where correctly aligned pointers do not have one bit, leaving ranges of only 31 or 63 bits. <br><br>  OCaml also has a type inference system, so you can write a function and the compiler will output the most suitable generic type if you do not annotate it, and so the functions will look like it's a dynamically typed language: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  The given type can be called ‚Äúa function from the list of elements of type <code>'a</code> into something with type <code>'a</code> ‚Äù.  This means that the return type will be the same as the list type, and it can be any type. <br><br><h2>  Interfaces </h2><br>  Another limitation of conventional packaging is that packaged types are <i>completely</i> opaque.  This is not a problem for data structures like a stack, but tools like sorting generic functions need additional features, such as type-specific comparison functions.  There are many ways to implement this in runtime and reflect in the language, technically these are different directions, and you can <a href="http://okmij.org/ftp/Computation/typeclass.html">implement the same language with several similar approaches</a> .  However, the features of different languages ‚Äã‚Äãaffect their implementation, and only then extensions enhance the strengths of the selected implementations.  This means that there are two families of languages ‚Äã‚Äãbased on different approaches to runtime: virtual method tables (vtables) and dictionary transfer. <br><br><h3>  Interface Method Tables </h3><br>  If we want to provide type-specific functions, adhering to the packaging strategy for the sake of unified work with everything, then it is enough to have a unified way to find similar functions that we need to get from the object.  This approach is called ‚Äúvirtual method tables‚Äù (vtables, virtual method tables), although no one uses the full name.  It is implemented as follows: at a zero offset in each generic structure object, there is a pointer to a table of function pointers with a consistent circuit.  In these tables, the generic code looks for pointers to type-specific functions by indexing specific pointers at fixed offsets. <br><br>  This is how <code>interface</code> types are implemented in Go and <code>dyn trait</code> objects in Rust.  When you cast a type to an interface type of what it implements, a wrapper is created for the interface that contains a pointer to the source object and a pointer to vtable of type-specific functions.  But this requires an additional level of indirect addressing of pointers and another scheme.  Therefore, sorting in Go uses the <a href="https://golang.org/pkg/sort/">interface for the container with the Swap method</a> , and does not take the slice of the Comparable interface, because this would require placing in memory a completely new slice of interface types that would be sorted instead of the original slice! <br><br><h3>  Object oriented programming </h3><br>  OOP is a language property that makes good use of the capabilities of virtual type tables.  Instead of separate interface objects with vtables, OOP languages ‚Äã‚Äãlike Java simply insert a pointer to a table of virtual types at the beginning of each object.  Java-like languages ‚Äã‚Äãhave an inheritance system and interfaces that can be fully implemented using these virtual type object tables. <br><br>  In addition to providing additional features, embedding vtable in each object solves the problem of the need to construct new interface types with indirect addressing (indirection).  Unlike Go, in Java <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html">, the sort function</a> can apply the <code>Comparable</code> interface to the types that it implements. <br><br><h3>  Reflection </h3><br>  If you have tables of virtual types, then it will not be difficult for you to force the compiler to generate tables of other types of information, for example, names of fields, types and locations.  This will allow access to all data of this type with the help of a code that can view all data of any other types.  This behavior can be used to add ‚Äúreflection‚Äù to the language, which allows serialization and beautiful display of arbitrary types.  Reflection, as an extension of the packaging paradigm, has a drawback: for it, only one copy of the code is enough, but you need to perform many dynamic searches, which reduces the speed of serialization. <br><br>  Languages ‚Äã‚Äãthat use reflection for serialization and other functions: Java, C # and Go. <br><br><h3>  Dynamically typed languages </h3><br>  Reflection is a very powerful tool that allows you to solve a bunch of different metaprogramming tasks.  But it does not allow you to create new types or edit information about the types of existing values.  If we add this feature and make the data access and modification syntaxes use reflection by default, we get dynamically typed languages!  The incredible flexibility of metaprogramming in languages ‚Äã‚Äãlike Python and Ruby has arisen thanks to the effective, powerful reflection systems that are used to solve any problems. <br><br>  You can say: ‚ÄúBut dynamic languages ‚Äã‚Äãdo not work like that, they just implement everything using hash tables!‚Äù  Hash tables are just a good data structure for creating editable tables with type information.  In addition, some interpreters, such as CPython, work this way.  In a high-performance JIT, say V8, <a href="https://v8.dev/blog/fast-properties">there are a lot of virtual type tables and</a> reflection information.  In V8, hidden classes (vtables and reflection information) and the structure of objects are similar to what you can see in the Java VM, with the ability to replace objects with new virtual type tables at runtime.  This is not a coincidence, because there are no coincidences: the <a href="https://ru.wikipedia.org/wiki/V8_(%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25BE%25D0%25BA_JavaScript)">creator of V8</a> used to <a href="https://en.wikipedia.org/wiki/Lars_Bak_(computer_programmer)">work on high-performance Java VM</a> . <br><br><h3>  Dictionary Transfer </h3><br>  Another way to implement dynamic interfaces is to transfer a table with the required function pointers to the generic function that needs them.  This is somewhat similar to constructing Go-shaped interface objects at the place of call, only in our case the table is passed as a hidden argument, and not packed into a bundle as one of the existing arguments. <br><br>  This approach is used in <a href="http://okmij.org/ftp/Computation/typeclass.html">type classes in Haskell</a> , although GHC allows you to perform some kind of monomorphization using inlining and specialization.  OCaml uses dictionary transfer with an explicit argument in the form <a href="https://v1.realworldocaml.org/v1/en/html/first-class-modules.html">of first-class modules</a> , but it has already been proposed to <a href="https://tycon.github.io/modular-implicits.html">add the ability to make the parameter implicit</a> . <br><br><h3>  Witness tables in Swift </h3><br>  The Swift authors applied an interesting solution: transferring the dictionary, as well as putting data on the type sizes and how to move, copy and release them into the table, allows you to provide all the necessary information for unified work with any types without packing them.  Thus, Swift can implement generics <a href="https://www.reddit.com/r/rust/comments/7gkiie/implementing_swift_generics_video/">without monomorphization and placement in memory in a unified representation of</a> all entities!  Yes, you have to pay for dynamic searches, as is characteristic of the entire family that uses packaging, but resources for memory, memory consumption and cache inconsistency are saved.  Using the functions <a href="">annotated as @inlinable</a> , the Swift compiler is also able to specialize (monomorphize) and inline generics inside a module or between modules to avoid the mentioned expenses.  Probably a heuristic evaluation of the effect on the code size is used. <br><br>  It also explains how Swift can <a href="">implement ABI stability</a> , while still allowing you to add and redistribute fields in the structure, although the authors provide the <code>@frozen</code> attribute to refuse dynamic searches for better performance. <br><br><h3>  Intensional Type Analysis </h3><br>  There is another way to implement interfaces for packaged types.  We add a type identifier to a certain part of the object, following the example of a pointer to vtable, and then generate functions for each interface method that has a large <code>switch</code> expression for all types that implement this method, and pass it to the correct type-specific method. <br><br>  I don‚Äôt warn against using languages ‚Äã‚Äãthat use this approach, but C ++ compilers and Java virtual machines act in a similar way, when they use profile-based optimization to find out that a certain place of calling generics mostly works with objects of certain types.  Compilers and VMs replace call locations with checks for each ordinary type, and then statically dispatch these types, as a fallback, using regular dynamic dispatch.  Therefore, the branch prediction algorithm can predict which branch the code will go on and continue to dispatch instructions using static calls. <br><br><h2>  Monomorphization </h2><br>  This is an alternative to packaging.  With monomorphization, we need to find a way to generate multiple versions of the code for each type that we want to use.  Compilers have several presentation phases through which code passes, and, theoretically, can be copied to any of these stages. <br><br><h3>  Source code generation </h3><br>  The easiest way to monomorphize is to copy at the first presentation stage: copy the source code!  Then the compiler does not even have to support generics, and this is sometimes done by users of the C and Go languages, in whose compilers there is no such support. <br><br>  In C, you can use a preprocessor and define the data structure in a macro or header by repeatedly inserting it with different <code>#define</code> .  Go has scripts like <a href="https://github.com/cheekybits/genny">genny</a> that make code generation easier. <br><br>  The disadvantage of duplicating the source code is that, depending on the language, it may be necessary to deal with numerous problems and edge cases, moreover, the compiler parses and checks types for many times for virtually the same code.  Again, depending on the language and tools, these generics of methods can be difficult to write and use, as if inside a C-macro each line ends with a backslash and all types and names of functions must be manually glued into their identifiers to avoid collisions. <br><br><h3>  String mixins in D </h3><br>  However, code generation has its advantages, such as the fact that you can generate code using a full-fledged programming language, as well as use a view familiar to users. <br><br>  Some languages ‚Äã‚Äãin which generics are implemented differently also allow code to be generated for more general metaprogramming cases not considered in their generic systems, for example, for serialization.  The most understandable example is <a href="https://dlang.org/articles/mixin.html">string mixins in D</a> , which allow compiling D-code in the form of string values ‚Äã‚Äãin the middle of compilation, using all the features of the language. <br><br><h3>  Rust procedural macros </h3><br>  A similar example, only with representation in the compiler at only one stage.  <a href="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html">Rust procedural macros</a> use token streams as input and output, providing utilities for converting these streams to string and vice versa.  The advantage of this approach is that token streams can store location information from source code.  The code written by the user, the macro can be inserted as tokens directly from the input to the weekend.  And if this code leads to a compilation error in the output of the macos, the compiler will display a message and accurately point to the file, line and column of the broken part of the code.  But if the macro generates the broken code, then the error message will indicate a macro call.  For example, if you use a <a href="https://docs.rs/log-derive/">macro that wraps a function in logging calls</a> and makes a mistake in implementing a wrapped function, then the error message will point directly to the error in the file, and not to the code generated by the macro. <br><br><h3>  Syntax Tree Macros </h3><br>  Some languages ‚Äã‚Äãgo even further and offer tools for using and creating different types of abstract syntax trees in macros (Abstract Syntax Tree, AST).  Examples include <a href="https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial">Template Haskell</a> , <a href="https://nim-lang.org/docs/tut3.html">Nim macros</a> , <a href="http://ocamllabs.io/doc/ppx.html">OCaml PPX,</a> and almost all <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> . <br><br>  The disadvantage of AST macros is that you don‚Äôt want to force users to learn a bunch of functions to build AST types, as well as basic languages.  In the Lisp family of languages, this is solved with the help of a strong simplification and maximum correspondence between the syntax and structure of AST, however, creating structures is not always easy. <br><br>  Thus, in all the languages ‚Äã‚ÄãI mentioned, there is one way or another primitive "quote" to which you give a piece of code in the language, and that returns a syntax tree.  These primitives can merge the values ‚Äã‚Äãof the syntax tree using the similarity of string interpolation.  Here is an example on Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://github.com/ocaml-ppx/ocaml-migrate-parsetree">     </a> /  ,  .  Rust  ,   <a href="https://github.com/dtolnay/syn">parsing</a>  <a href="https://github.com/dtolnay/quote">quotation</a> ,          ,       .    Rust  <a href="https://github.com/dtolnay/reflect"> ,    ,  </a> ! <br><br><h3>  Patterns </h3><br>    ‚Äî        .   ++  D    ,         ¬´ ¬ª.        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="http://dlang.org/">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://en.cppreference.com/w/cpp/language/constraints">C++20  ¬´¬ª</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      ¬´    ¬ª. , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="http://terralang.org/">Terra</a>    ,   . Terra ‚Äî   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="http://terralang.org/">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     ‚Äî  Swift  Haskell. <br><br>  Rust      ¬´ ¬ª (trait bounds). <code>Trait</code> ‚Äî      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        ‚Äî          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div><p>Source: <a href="https://habr.com/ru/post/461321/">https://habr.com/ru/post/461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46131/index.html">Gay Test v.3</a></li>
<li><a href="../461313/index.html">Zimbra 8.8.15 LTS Released</a></li>
<li><a href="../461317/index.html">9 Principles for Creating Quality iOS Applications</a></li>
<li><a href="../461319/index.html">What does a game designer do?</a></li>
<li><a href="../46132/index.html">Firefox 3 bug: phantom borders and how to deal with them</a></li>
<li><a href="../461323/index.html">An affordable explanation of the wave function collapse algorithm</a></li>
<li><a href="../461325/index.html">Victory at PHDays 9. We share life hacks in three parts. Part 3</a></li>
<li><a href="../461327/index.html">Front-end crisis?</a></li>
<li><a href="../461333/index.html">ITX5 mitap: live JAVA, Kotlin magic and tomato tinder</a></li>
<li><a href="../461339/index.html">How to be data driven. From the very beginning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>