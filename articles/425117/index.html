<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Two bits per transistor: Intel 8087 floating point high density ROM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intel developed the 8087 chip in 1980 in order to improve PC performance with 8086/8088 processor lines (such as the IBM PC) when performing floating ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Two bits per transistor: Intel 8087 floating point high density ROM</h1><div class="post__text post__text-html js-mediator-article">  Intel developed the 8087 chip in 1980 in order to improve PC performance with 8086/8088 processor lines (such as the IBM PC) when performing floating point operations.  Since the first microprocessors were designed to perform operations with integers, the execution of operations with floating-point numbers was slow, which already speak of performing transcendental operations, such as trigonometric functions or logarithms.  The 8087 coprocessor significantly increased the speed of performing tasks with a floating point, everything was performed almost 100 times faster.  The 8087 architecture was also implemented in later Intel processors, and the 8087 instructions are still used in modern x86 PCs.  Intel introduced the 8087 chip in 1980, designed to improve the performance of floating-point computing on the 8086 and 8088 processors. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/uw/rf/zauwrfyx0v8mkj7aqjq7bx0kmhw.jpeg"></div><a name="habracut"></a><br>  Because early microprocessors only worked with integers, floating-point arithmetic was slow, and transcendental operations, such as triggers or logarithms, looked even worse.  Adding the math coprocessor 8087 to the system made it possible to speed up operations with a floating point 100 times.  The 8087 architecture has become part of the later Intel processors, and the 8087 instructions (although outdated) are still part of modern x86 desktops. <br><br>  The 8087 chip provided fast floating point arithmetic for the original IBM PC and became part of the x86 architecture used today.  One of the unusual features of the 8087 is a multi-level ROM (read only memory) capable of storing two bits per transistor, which is twice the density of a conventional ROM.  Instead of storing binary data, each cell in the 8087 ROM stored one of four different values, which were then decoded into two bits.  Since 8087 needed a large amount of ROM for microcode (1), and the number of transistors on a chip was very limited, Intel used unusual technology to solve the problem.  In this article, I will explain how Intel implemented this multi-level ROM. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I opened the 8087 chip and photographed it with a microscope, taking a photo below.  In the photo I indicated the main functional blocks, based on my own reverse engineering (Click to enlarge image).  The processor matrix 8087 is quite complex, with 40,000 transistors (2).  8087 uses 80-bit floating-point numbers: 64 bits are reserved for the mantissa, 15 bits for the exponent, and another sign bit.  (An example of a number with base 10: in the number 6.02 √ó 1023 6.02 is the mantissa, and 23 is the exponent).  At the bottom of the photo, the word ‚Äúfraction processing‚Äù marks a part of the mantissa scheme.  From left to right, this includes: a constant store, a 64-bit offset, a 64-bit adder / subtractor, and a stack of registers.  Slightly above is the circuit for handling exponents. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/gx/q8/hjgxq8dq_dzulzxp79by-ue27jm.jpeg"></div><br>  <i>Chip math coprocessor for floating point operations Intel 8087, with the designation of the main functional units</i> <br><br>  Execution of the instruction on 8087 required several steps, and in some cases more than 1000. The firmware 8087 used microcode to determine low-level operations at each step: shifts, increment, memory samples, reading constants, etc. You can perceive the microcode as a simple program, written in the form of microinstructions, in which each microinstruction generates control signals for various components of the chip.  In the photo above, you can see the ROM with the microcode program 8087. The ROM occupies most of the chip, clearly showing why the compact multi-level ROM was necessary.  To the left of the ROM is the ‚Äúengine‚Äù on which the microcode program was run, in fact, a simple processor. <br><br>  8087 worked as a coprocessor with an 8086 processor. When the 8086 detected a special floating point instruction, the processor ignored it and allowed the 8087 to execute the instruction in parallel.  I will not explain in detail the internal work of 8087, but, briefly, floating point operations were implemented using integer addition / subtraction and shift operations.  To add or subtract two floating point numbers, 8087 performed a bitwise offset of the number until the binary delimiters (that is, the decimal separator is a comma, but in the binary system) become equal, and then add or subtract the mantissa.  Multiplication, division and square root were performed by multiple shifts, additions or subtractions.  Transcendental operations (tan, arctan, log, power) used CORDIC algorithms that use shifts and add special constants, processing one bit at a time.  8087 also encountered many particular cases: infinity, overflow, NaN (not a number), denormalized numbers and several rounding modes.  The microcode stored in the ROM controlled all these operations. <br><br><h3>  ROM implementation </h3><br>  Chip 8087 consists of a tiny silicon matrix, on which silicon is doped with impurities in places in order to obtain the desired semiconductor properties.  Polysilicon (a special type of silicon) that forms wires and transistors is deposited on a silicon surface.  And finally, the metal layer on top of the silicone completes the working electrical circuit.  In the photo below, on the left side, a small part of the chip is shown, as it is visible under the microscope, showing yellowish metallic wiring.  On the right side of the photo, the metal was removed with acid, exposing polysilicon and silicon.  When polysilicon crosses silicon, a transistor is formed.  The pink areas are doped silicon, and the thin vertical lines are polysilicon.  Small circles are the contacts between the silicon and metal layers connecting them together. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/us/9j/cgus9jmdjvhec5j30deqymfz8r4.png"></div><br>  <i>ROM structure in an Intel 8087 FPU.</i>  <i>The metal layer is shown on the left and polysilicon and silicon on the right.</i> <br><br>  Although there are many ways to build ROMs, the standard way is to create a grid of "cells", where each cell stores one bit.  Each cell can have a transistor (which means 0 bits) or not have a transistor, which means 1 bit.  In the image above, you can see a grid of cells with transistors (where polysilicon is deposited on silicon) and missing transistors (where there are gaps in silicon).  To read information from the ROM, one column selection line is activated (based on the address) to select the bits stored in this column and to get one bit from each row at the output.  You can see the vertical lines of column selection (column select lines) from polysilicon, and the horizontal metal rows in the photo above.  Vertical doped silicon lines are grounded. <br><br>  The diagram below (corresponding to the 4 √ó 4 ROM segment) explains how the ROM functions.  Each cell either has a transistor (black) or does not have a transistor (grayed out).  When voltage is applied to the column selection line of the polysilicon, the transistors in this column turn on and ground the corresponding metal rows.  (in this case, the NMOS transistor is similar to a gate that is open if the input is 0, and is closed if the input is 1.) The metal "rows" of the circuit output the data stored in the selected "column". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/sl/q_/oislq_mbf-lyx6kbddwl4wxbgya.png"></div><br>  <i>4x4 ROM Segment</i> <br><br>  The column selection signals are generated by the decoder circuit.  Since this circuit is built from NOR valves, I will first explain the design of the valves.  The diagram below shows a four-input NOR gate built from four transistors and a pull-up resistor (although in fact, a special transistor performs the function of a resistor).  In the left part of the circuit, all inputs are equal to 0, therefore all transistors are disconnected, and the pull-up resistor keeps the output signal at a high level.  In the right side, one of the inputs was fed 1, turning on the transistor.  The transistor is grounded, so the output signal is now "low" level.  Thus, if any inputs are high (1), the output is low (0).  So this circuit implements the NOR valve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_n/if/hi/_nifhiurrurn523sddqmq8w3eq8.png"></div><br>  <i>4-input NOR gate built from NMOS transistors</i> <br><br>  The column selection decoder circuit accepts incoming address bits and activates the corresponding selection string.  The decoder contains an 8-input NOR gate for each column, that is, one NOR gate for each address.  The photo shows two NOR elements that generate column selection signals (for simplicity, I will show only four of the 8 inputs).  Each column uses a different combination of address lines and augmented address lines as input, choosing a different address.  Address lines are in the metal layer, which is removed in the photo below;  address lines are highlighted in green.  To determine the address associated with a column, look at the square contacts associated with each transistor and note which address lines are connected.  If all address lines connected to the transistors of the column are at the low (0) level, the NOR gate will select this column. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/va/bt/hdvabtftpvkypgl28rpwa2ev2vy.png"></div><br>  <i>Part of the address decoder.</i>  <i>Address decoder selects odd columns in ROM, counting from right to left.</i>  <i>The numbers at the top show the address associated with each exit.</i> <br><br>  The photo below shows a small part of the ROM decoder with all 8 inputs for NOR gates.  You can read binary addresses by carefully examining the connections in the address bar.  Note the binary pattern: connections a1 change values ‚Äã‚Äãin each column, connections a2 alternate every two columns, connections a3 every four columns, and so on. D. Connection a0 is fixed because this decoder scheme selects odd columns;  A similar ROM scheme selects even-numbered addresses (such a separation was necessary for the decoder to fit on the chip, since each column of the decoder is twice as wide as the ROM cell). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l-/el/lv/l-ellviplb3kupadfsrcgwqp_ui.png"></div><br>  <i>Part of the address decoder for ROM 8087 microcode. The decoder converts an 8-bit address into column selection signals</i> <br><br>  The last component of the ROM is a set of multiplexers, which reduces the 64 output lines to 8 lines.  Each 8-to-1 multiplexer selects one of its 8 inputs based on the address.  The diagram below shows one of the 8087 processor row multiplexers, built with eight large pass-through transistors, each of which is connected to one of the ‚Äúrow‚Äù lines.  All transistors are connected to the output so when the selected transistor is turned on, it transmits its input to the output.  Multiplexer transistors are much, much larger than transistors in ROM to reduce ROM signal distortion.  A decoder (similar to the one discussed earlier, but smaller) generates eight multiplexer control lines from three address lines. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/kx/_o/m2kx_ochmi4nes3z-bjryrrsmbq.png"></div><br>  <i>One of 8-row multiplexers in ROM.</i>  <i>Here you can see layers of (poly) silicon, with metallic compounds painted in orange</i> <br><br>  To summarize, ROM stores bits in a grid.  It uses eight address bits to select a column in the grid.  Then the three bits of the address select the desired eight outputs from the ‚Äústrings‚Äù. <br><br><h3>  Multi-level ROM </h3><br>  So far I have explained the typical ROM device that stores one bit per cell.  So how could the 8087 store two bits per cell?  If you look carefully, the microcode ROM 8087 contains four different sizes of transistors - if we assume the absence of the transistor as one of the sizes (6).  With four options for each transistor, one cell can encode two bits, roughly doubling the density (7).  The current section explains how the four sizes of transistors generate four different currents, and how analog and digital IC circuits convert these currents to two bits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/fb/g2/ykfbg2a-lsfxfa2c7ijsmcjxlzk.png"></div><br>  <i>A micrograph of the microcode ROM 8087 shows four different transistor sizes.</i>  <i>This allows the ROM to store two bits per cell.</i> <br><br>  The size of the transistor regulates the current through the transistor (8).  An important geometric factor is the different width of silicon (pink), where it intersects with polysilicon (vertical lines), creating transistors with different gate widths.  Since the gate width controls the current through the transistor, four transistor sizes generate four different currents: the largest transistor passes most of the current, and the current does not flow at all if there is no transistor. <br><br>  The ROM current is converted to bits in several steps.  First, the pull-up resistor converts the current to voltage.  The three comparators then compare the voltage with the reference voltage to generate digital signals, determining which voltage is higher / lower.  Finally, the logic gates convert the comparator output signals to two output bits.  This scheme is repeated eight times, generating a total of 16 bits on the output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/a6/go/ada6goh-_wnbiaam90ai_nxgfdk.png"></div><br>  <i>Scheme for reading two bits from the ROM cell</i> <br><br>  The diagram above performs these conversion steps.  As a result, one of the ROM transistors is selected by the ‚Äúcolumn‚Äù selection line and the multiplexer (discussed earlier), which generates one of the four currents.  Then, the pull-up resistor (12) converts the current of the transistor to voltage, with the result that the voltage depends on the size of the selected transistor.  Comparators compare this voltage with three reference voltages, and output 1 if the ROM voltage is higher than the reference voltage.  Comparators and reference voltages require careful design, since ROM voltages can differ by as little as 200 mV. <br><br>  The reference voltages are midway between the expected values ‚Äã‚Äãof the voltage of the ROM, which allows for some voltage fluctuations.  The ‚Äúlow‚Äù voltage of the ROM is lower than all the reference voltages, so all the comparators will output 0. The second voltage of the ROM is higher than Ref 0, so the lower comparator outputs 1. With the third voltage ROM, the lower two comparators output 1, and at the maximum the voltage of the ROM at the output of all three comparators 1. Thus, the three comparators give four different output patterns, depending on the transistor ROM.  The logic elements then convert the comparator output into two output bits (10). <br><br>  The design of the comparator is interesting because it is a bridge between the analog and digital worlds, producing 1 or 0 if the voltage of the ROM is higher or lower than the reference voltage.  Each comparator contains a differential amplifier that amplifies the difference between the voltage of the ROM and the reference voltage.  The output of the differential amplifier drives a gate, which stabilizes the output and converts it into a logic level signal.  The differential amplifier (below) is a standard analog circuit.  The current source (symbol below) provides a constant current.  If one of the transistors has a higher input voltage than the other, most of the current passes through that transistor.  The voltage drop across the resistors will cause the corresponding output to be lower, and the other output to be higher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d6/fn/ns/d6fnnswmm1veissvrruouwjrrmi.png"></div><br>  <i>Diagram showing the operation of the differential pair.</i>  <i>Most of the current will pass through a transistor with a higher input voltage, with the result that the corresponding output signal will be lower.</i>  <i>Double circle symbol at the bottom - DC source I</i> <br><br>  The photo below shows one of the comparators on the chip;  metal layer on top, transistors under it.  I will consider only the highlights of this complex scheme;  See note 12 for details.  The signal from the ROM and multiplexer arrives on the left.  Pull-up circuit 12 converts current to voltage.  Two large differential amplifier transistors compare the voltage of the ROM with the reference voltage (input from the top).  The outputs from the differential amplifier go to the gate circuit (scattered around the photo);  shutter output is in the lower right corner.  The current source of the differential amplifier and pull-up resistors are made of depletion-mode transistors.  Each output circuit uses three comparators, which gives a total of 24 comparators. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/ec/jr/pmecjrsutl-vzf3k0qvzgw5t1cw.png"></div><br>  <i>One of the comparators in 8087. The chip contains 24 comparators for converting voltage levels from a multi-level ROM to binary data</i> <br><br>  Each reference voltage is generated by a carefully sized transistor and a pull-up circuit.  The reference voltage circuit is designed to be as similar as possible to the ROM signal circuit, so that any changes in chip production will affect both elements in the same way.  The reference voltage and the ROM signal use the same load circuit.  In addition, each reference voltage circuit includes a very large transistor, identical to the multiplexer transistor, although there is no multiplexing in the reference signal circuit ‚Äî just to ensure ‚Äúmatching‚Äù of the circuits.  Three reference voltage circuits are identical, except for the size of the reference transistor (9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/11/je/wn/11jewn6dap_lxtfqtvrh7vdzcfw.png"></div><br>  <i>A circuit that generates three reference voltages.</i>  <i>The size of the reference transistors - between the size of the transistors ROM.</i>  <i>The oxide layer was not completely removed from this part of the matrix, which caused color twists in the photo.</i> <br><br>  To assemble the entire puzzle, the photo below shows the location of the components of the microcode ROM on the chip (12).  The main part of the circuit ROM is transistors that store data.  The column decoder circuit is located above and below the ROM data.  Half of the column selection decoders are at the top, and half at the bottom, for better layout.  The output circuit is on the right.  Eight multiplexers reduce 64 lines to eight lines.  Then eight lines enter the comparators, generating 16 bits at the output from the ROM on the right.  The reference circuit over the comparators generates three reference voltages.  At the bottom right, a small string decoder controls the multiplexers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-q/df/9s/-qdf9s_vh19u5bxltwg59ye7_2o.png"></div><br>  <i>Microcode ROM from Intel 8087 FPU with the marking of the main components</i> <br><br>  Although initially it may seem that the multi-level ROM will be two times smaller than the usual ROM, the effect is not so noticeable due to the additional comparators scheme, and because the transistors themselves are slightly larger, due to the need to use several sizes.  Despite this, a multi-level ROM saved about 40% of the space that would have occupied the usual ROM. <br><br>  Now that I understand the structure of the ROM, I can simply (but tiresomely) read the contents of the ROM, just by looking at the size of each transistor under a microscope.  But, without knowing the set of microcode instructions, the contents of the ROM is useless. <br><br><h3>  findings </h3><br>  The 8087 floating-point math coprocessor used an unusual ‚Äútwo bits per cell‚Äù structure to place microcode on the chip.  Intel reused the multi-level ROM structure in 1981 in the doomed iAPX system. 432.11 As far as I can tell, interest in multi-level cell ROMs reached its peak in the 1980s and then waned.  Probably due to the fact that, according to Moore's law, it is much easier to increase the capacity of the ROM by reducing the standard cell than by designing non-standard ROMs that require special analog circuits built with high tolerances (14). <br><br>  Surprisingly, the multi-level concept has recently returned, but already on flash memory.  Many flash devices store two or more bits per cell (13).  Flash memory has even reached a remarkable 4 bits per cell (requiring 16 different voltage levels) in consumer products recently announced (QLC, quad-level cell).  Thus, the little-known technologies of the 1980s can come back again decades later. <br><br>  I report my latest blog posts on Twitter, so subscribe to @kenshirriff to read future articles on 8087. I also have an RSS feed.  Thanks to Jeff Epler for offering to explore the 8087 ROM. <br><br><h3>  Notes and links </h3><br><ol><li>  The 8087 processor contains 1648 microcode words (if I correctly counted), with 16 bits in each word, a total of 26,368 bits.  The size of the ROM does not have to be a power of two, and Intel can build it with any desired size. </li><li>  Sources provide conflicting values ‚Äã‚Äãfor the number of transistors in 8087: Intel states that 40,000 transistors and Wikipedia claims that 45,000. The discrepancy may be due to different ways of counting transistors.  In particular, since the number of transistors in ROM, PLA, or a similar structure depends on the data stored in it, sources often consider ‚Äúpotential‚Äù transistors, rather than the number of physical transistors.  Other discrepancies may be related to whether pull-up transistors are taken into account and whether high-current drivers are considered to be several parallel or one large transistor. </li><li>  The interaction between the 8086 processor and the 8087 floating-point coprocessor is quite complex;  I will explain some of the highlights.  A simplified view is that 8087 watches the stream of 8086 commands and executes any instructions that are 8087 instructions. The difficulty is that 8086 has a command prefetch buffer, so the selected command does not mean executable.  Thus, 8087 duplicates the 8086 prefetch buffer (or smaller 8088 prefetch buffer), so it knows what 8086 is doing. Another obstacle is the complex addressing modes used by the 8086, which use the registers inside the processor.  8087 cannot perform these addressing modes, since it does not have access to the 8086 registers. Instead, when the 8086 sees the 8087 instruction, it samples the memory at the specified address, and ignores the result.  Meanwhile, 8087 captures the address from the bus so that it can use it if it needs an address.  If 8087 is missing, you can expect a malfunction, but this does not happen.  Instead, for a system without 8087, the linker rewrites 8087 instructions, replacing them with subprogram calls into the emulation library. </li><li>  The reason why ROMs typically use multiplexers at the outputs of rows is that it is inefficient to create ROMs with a large number of columns and several output bits, since the decoder circuit will be larger than the ROM data.  The solution is to change the shape of the ROM to keep the same bits, but with more rows and fewer columns.  For example, a ROM can have 8 times more rows and 1/8 columns, which allows using a 1/8 size decoder.  In addition, a long, narrow ROM (for example, 1 K √ó 16) is inconvenient to place on the chip, since it is not suitable as a simple unit.  However, the "snake" design can also be used.  For example, Intel's earliest memory samples were shift registers;  1405 contained 512 bits in one long shift register.  To install it on the chip, the shift register was put back and forth about 20 times by the ‚Äúsnake‚Äù. </li><li>  Some IBM computers used an unusual storage technique for storing microcode: holes were punched in Mylar cards (just like in ordinary punched cards), and a computer detected capacitively (link) holes.  Some computers, such as Xerox Alto, had some microcode in the RAM.  This allowed programs to modify the microcode, creating new instructions for their specific purposes.  Many modern processors have a writeable microcode, so patches can fix bugs in the microcode. </li><li>  I did not notice the four transistor sizes in the microcode ROM until I saw a mention in the comments on Hacker News that 8087 used two-bit per cell technology.  I was skeptical, but after a closer examination of the chip, I realized that the comment was correct. </li><li>  Several other approaches were used in the 1980s to store several bits per cell.  Mostek and other companies used one of the most common: alloy transistors in ROM had different threshold voltages.  Using four different threshold voltages, you can store two bits per cell.  Compared to Intel's geometric approach, the threshold approach provided greater density (since all transistors could be of minimal size), but required more layers and processing steps to create a multi-level implantation.  This approach used a new (at that time) ion implantation technology to carefully adjust the doping levels of each transistor.  The biggest effect of ion implantation on integrated circuits was its use to create depleting transistors (negative threshold voltage transistors), which worked much better than pull-up resistors in logic elements.  Ion implantation was also used in the Z-80 microprocessor to create some transistor ‚Äútraps,‚Äù circuits that looked like ordinary transistors under a microscope, but received implants that made them non-functional.  This served as copy protection, since the manufacturer who tried to produce clones of the Z-80 processor by copying the chip with a microscope eventually received a chip that did not work correctly in different ways, some of which were difficult to detect. </li><li>  The current through the transistor is proportional to the ratio between the width and the length of the gate.  (The length is the distance between the source and the drain.) ROM transistors (and all but the smallest reference transistor) maintain a constant length and change the width, so reducing the width reduces the current.  For MOSFET equations, see Wikipedia </li><li>  The gate of the smallest reference transistor is rather longer than narrow, due to the properties of MOS transistors.  The problem is that the reference transistors must be sized between the sizes of the ROMs of the transistors.  In particular, for Reference 0, a transistor smaller than the smallest transistor ROM is required.  But the smallest ROM transistor is already as small as possible, following the manufacturing technology.  Note: to solve this problem, polysilicon, crossing the middle reference transistor, is much thicker horizontally.  Since the properties of a MOSFET are determined by the ratio of the width to the height of its gate, the expansion of polysilicon works as well as the compression of silicon in order to make the transistor work with a lower current. </li><li>  The ROM logic decodes the size of the transistor in bits as follows: No transistor = 00, small transistor = 01, middle transistor = 11, large transistor = 10. This bit ordering saves several elements in the decoding logic;  Since the mapping from transistor to bits is arbitrary, it does not matter that the sequence is not in order.  (See "Two Bits Per Cell ROM", Stark). </li><li>  The Intel iAPX 43203 (1981) interface processor used a multi-level ROM, very similar to the 8087 chip. For details, see ‚ÄúThe interface processor for the Intel VLSI 432 32 bit computer,‚Äù J. Bayliss et al., IEEE J. Solid-State Circuits vol.  SC-16, pp. 522-530, October 1981 The 43203 interface processor provided I / O support for the iAPX 432 processor. Intel launched the iAPX 432 project in 1975 to create a ‚Äúmicro-mainframe‚Äù that will be the revolutionary Intel processor for 1980- s.  When delays occurred in the iAPX 432 project, Intel released the 8086 processor as a temporary solution in 1978.  Although the Intel 8086 was a huge success, leading to desktop PCs and modern x86 architecture, the iAPX 432 project failed in 1986. </li><li>  The diagram below (from the ‚ÄúMultiple-Valued ROM Output Circuits‚Äù) contains detailed information on the ROM read scheme.  Conceptually, the ROM uses a pull-up resistor to convert the transistor current into voltage.  The circuit actually uses a three-transistor circuit (T3, T4, T5) as a pull-up.  T4 and T5 are essentially an inverter providing negative feedback through T3, which makes the circuit less sensitive to disturbances (such as production deviations).  The comparator consists of a simple differential amplifier (yellow) with T6 acting as a current source.  The output of the differential amplifier is converted to a stable logic level signal using a gate (green). </li><li>  Flash memory is divided into SLC (one single level cell - one bit per cell), MLC (multi level cell - two bits per cell), TLC (triple level cell - three bits per cell) and QLC (quad level cell - four bits per cell).  Often, flash memory with a higher number of bits per cell is cheaper, but less reliable, and wears out more slowly and more quickly due to smaller signal differences. </li><li>  The magazine ‚ÄúElectronics‚Äù published a short article ‚ÄúFour-State Cell Doubles ROM Bit Capacity‚Äù (pp. 39, October 9, 1980), describing the Intel methodology, but this article is unclear and misleading.  Intel published a detailed article ‚ÄúTwo bits per cell ROM‚Äù in COMPCON (pp. 209-212, February 1981).  The external team attempted to reverse engineer more detailed specifications of Intel's circuits in Multiple-valued ROM output circuits (Proc. 14th Int. Symp. Multivalue Logic, 1984).  Two articles describing memory using this technology are ‚Äú <a href="https://www.computer.org/csdl/trans/tc/1986/02/01676727.pdf">A Survey of Multivalued Memories</a> ‚Äù (‚ÄúIEEE Transactions on Computers‚Äù, February 1986, p. 99‚Äì106) and ‚Äú <a href="https://www.semanticscholar.org/paper/A-Review-of-Multiple-Valued-Memory-Technology-(-)-Gulak/a3c1cbc425c7987fe2307b48e0ff96f2c2c1b038">A review of multiple-valued memory technology</a> ‚Äù (IEEE Symposium on Multivalued Logic, 1998). </li></ol><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until January 1 for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/425117/">https://habr.com/ru/post/425117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425107/index.html">Fintech Digest: problems of biometrics on mobiles, leasing phones from Samsung, securities on the blockchain</a></li>
<li><a href="../425109/index.html">The book "Java in the cloud. Spring Boot, Spring Cloud, Cloud Foundry ¬ª</a></li>
<li><a href="../425111/index.html">Promotional tricks that can cost you money and reputation</a></li>
<li><a href="../425113/index.html">‚ÄúDigital typography‚Äù or my experience in mobile book digitization</a></li>
<li><a href="../425115/index.html">Full-blown DevOps: Greek tragedy in three acts</a></li>
<li><a href="../425123/index.html">Mysterious heart of the drum machine Roland TR-808</a></li>
<li><a href="../425125/index.html">Selection @pythonetc, September 2018</a></li>
<li><a href="../425129/index.html">How to automate the creation of virtual machines? We tell in detail</a></li>
<li><a href="../425131/index.html">What to read about blockchain technologies: manuals, books and articles</a></li>
<li><a href="../425133/index.html">Problems of cross-border payments - why and how blockchains are used here</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>