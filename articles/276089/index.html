<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compression of textures in Android: format comparison and code samples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the best format for compressing textures? Maybe it's PNG, ETC, PVRTC, S3TC, or some other? The question is not simple, but very important. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compression of textures in Android: format comparison and code samples</h1><div class="post__text post__text-html js-mediator-article">  What is the best format for compressing textures?  Maybe it's PNG, ETC, PVRTC, S3TC, or some other?  The question is not simple, but very important.  The answer depends on the quality of visual design, speed and size of Android applications.  The matter is complicated by the fact that a universal ‚Äúbest format‚Äù simply does not exist.  It all depends on the needs of the developer. <br><br> <a href="https://habrahabr.ru/company/intel/blog/276089/"><img src="https://habrastorage.org/files/d4c/c34/e05/d4cc34e055d04cc998b466609c4aae19.jpg"></a> <br><br>  The technology of applying textures to two-dimensional or three-dimensional models is widely used in computer graphics.  This is done in order to improve the detail of objects that are represented by models.  Android supports many texture compression formats, each with its own advantages and disadvantages. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">Preliminary information about working with textures and their storage formats</font> </h2><br>  Texture mapping is a method of ‚Äústicking‚Äù an image onto the surface of shapes or polygons.  In order to make it clearer, the figure can be compared with a box, and the texture with a patterned wrapping paper in which this box is wrapped in order to put something good in it and give it to someone.  Therefore, in the English-language literature, texture mapping is also called ‚Äútexture wrapping,‚Äù which can be translated as ‚Äúwrapping textures.‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/5de/20c/b4a/5de20cb4ad686aa488c8274fcaec0992.png"><br>  <i><font color="#999999">The first tank is a polygonal model, and the second is the same model on which the textures are applied.</font></i> <br><br>  MIP maps (Mipmaps) are optimized groups of images that are generated for the main texture.  Usually they are created in order to increase the speed of image rendering and to smooth images (anti-aliasing), that is, to get rid of the effect of ‚Äústepped‚Äù lines.  Each level of the map (it is called ‚Äúmip‚Äù, in fact, this is one of the bitmap images, of which the set of textures included in the MIP map consists of) is a version of the original texture with a lower resolution. <br><br>  Such an image is used in cases where a textured object is visible from a distance, or when its size is reduced.  The idea of ‚Äã‚Äãusing MIP cards is based on the fact that we simply cannot distinguish between small details of an object that is far from us or has small dimensions.  Based on this idea, different parts of the map can be used to represent different parts of the texture, based on the size of the object.  This increases the rendering speed due to the fact that reduced versions of the main texture have much less texels (texture pixels), that is, the GPU has to process less data to display a textured model.  In addition, since MIP cards are usually smoothed, the number of noticeable artifacts is seriously reduced.  Here we look at MIP cards in PNG, ETC (KTX), ETC2 (KTX), PVRTC, and S3TC formats. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/a98/034/f89a9803407b96a436e33cef5a0cd947.jpg"></div><br>  <i><font color="#999999">MIP card</font></i> <br><br><h2>  <font color="#0071c5">Portable Network Graphics (PNG)</font> </h2><br>  PNG is a raster image storage format, especially noticeable in that it uses an algorithm for compressing image data without loss of information.  It supports color indexed images (24 bits RGB or 32 bits RGBA), full-color and halftone images, as well as an alpha channel. <br><br><h3>  Benefits </h3><br><ul><li>  The format uses lossless image compression, as a result, PNG images are very high quality. </li><li>  Supports both 8-bit and 16-bit transparency. </li></ul><br><h3>  disadvantages </h3><br><ul><li>  Files are large.  This increases application size and memory consumption. </li><li>  The relatively high need for computing resources (which leads to poor performance). </li></ul><br><h2>  <font color="#0071c5">Ericsson Texture Compression (ETC)</font> </h2><br>  Ericsson Texture Compression is a texture compression format that operates on blocks of 4x4 pixels.  Initially, Khronos used ETC as the standard format for Open GL ES 2.0.  (this version is also called ETC1).  As a result, this format is available on almost all Android devices.  With the release of OpenGL ES 3.0.  As a standard, the ETC2 format is used - a revised version of ETC1.  The main difference between these two standards lies in the algorithm that operates on pixel groups.  Improvements in the algorithm led to a higher accuracy of displaying fine detail images.  As a result, image quality has improved, but file size does not. <br><br>  ETC1 and ETC2 support compression of 24-bit RGB data, but they do not support compression of images with the alpha channel.  In addition, there are two different file formats related to the ETC algorithm: these are KTX and PKM. <br><br>  KTX is the standard file format of the Khronos Group, it provides a container in which you can store many images.  When a MIP card is created using KTX, a single KTX file is generated.  The PKM file format is much simpler, such files are mainly used to store individual images.  As a result, using PKM to create a MIP card will result in several PKM files instead of a single KTX.  Therefore, it is not recommended to use the PKM format for storing MIP cards. <br><br><h3>  Benefits </h3><br><ul><li>  ETC files are noticeably smaller than PNG files. </li><li>  The format supports hardware acceleration on almost all Android devices. </li></ul><br><h3>  disadvantages </h3><br><ul><li>  The quality is not as high as that of PNG (ETC is a lossy image compression format). </li><li>  There is no transparency support. </li></ul><br>  You can use the <a href="http://malideveloper.arm.com/resources/tools/mali-gpu-texture-compression-tool/">Mali GPU Texture Compression Tool</a> and the <a href="https://bitbucket.org/wolfpld/etcpak/wiki/Home">ETC-Pack Tool</a> to compress images in ETC. <br><br><h2>  <font color="#0071c5">PowerVR Texture Compression (PVRTC)</font> </h2><br>  PowerVR Texture Compression is a lossy image compression format with a fixed compression level, which is used mainly in devices of Imagination Technology PowerVR MBX, SGX and Rogue.  It is used as a standard method of compressing images on the iPhone, iPod, iPad. <br><br>  Unlike ETC and S3TC, the PVRTC algorithm does not work with fixed blocks of pixels.  It uses bilinear zooming and low-resolution mixing of two low-resolution images.  In addition to the unique compression process, PVRTC supports the RGBA format (with transparency) for both the 2-bpp option (2 bits per pixel) and the 4-bpp option (4 bits per pixel). <br><br><h3>  Benefits </h3><br><ul><li>  Support alpha channels. </li><li>  RGBA support for option 2-bpp (2 bits per pixel) and for option 4-bpp (4 bits per pixel). </li><li>  File size is much smaller than PNG. </li><li>  Support for hardware acceleration on the GPU PoverVR. </li></ul><br><h3>  disadvantages </h3><br><ul><li>  The quality is not as high as with PNG (PVRTC is a lossy image compression format). </li><li>  PVRTC is supported only on PoverVR hardware. </li><li>  Support is provided for square POT textures, i.e. textures whose width and height are a power of 2, although in some cases rectangular textures are supported. </li></ul><br><ul><li>  Compressing textures in this format can be slow. </li></ul><br>  <a href="https://community.imgtec.com/developers/powervr/tools/pvrtextool/">PVRTexTool</a> can be used for <a href="https://community.imgtec.com/developers/powervr/tools/pvrtextool/">compression</a> . <br><br><h2>  <font color="#0071c5">S3 Texture Compression (S3TC) or DirectX Texture Compression (DXTC)</font> </h2><br>  S3 Texture Compression is a lossy image compression format with a fixed compression level.  Its features make this format ideal for compressing textures used in 3D applications designed for the use of a graphics accelerator.  The integration of S3TC with Microsoft DirectX 6.0 and OpenGL 1.3 contributed to its widespread adoption.  There are at least 5 different S3TC format options (from DXT1 to DXT5).  The sample application supports the most commonly used variants (DXT1, DXT3 and DXT5). <br><br>  DXT1 provides the strongest compression.  Each 16-pixel input block is converted into a 64-bit block consisting of two 16-bit RGB 5: 6: 5 color values ‚Äã‚Äãand a 2-bit lookup table of 4x4 size.  Transparency support is limited to one color (1-bit transparency). <br><br>  DXT3 converts each block of 16 pixels into 128 bits, 64 bits fall into alpha channel data, 64 - into color information.  DXT3 is very well suited for images or textures with sharp transitions between transparent and opaque areas.  However, if there are no gradations of transparency, and there are transparent areas in the image, it is worth considering using DXT1. <br><br>  DXT5, like DXT3, converts each block of 16 pixels into 128 bits, 64 bits fall into alpha channel data, 64 into color information.  However, unlike DXT3, DXT5 is suitable for images or textures with smooth transitions between transparent and opaque areas. <br><br><h3>  Benefits </h3><br><ul><li>  The file size is much smaller than a similar PNG file. </li><li>  Decent quality, low percentage of artifacts in the form of strips associated with the imposition of flowers. </li><li>  Good encoding and decoding speed. </li><li>  Hardware acceleration on multiple GPUs.  On desktop systems it is supported by almost all solutions, it is gradually spreading on the Android platform. </li></ul><br><h3>  disadvantages </h3><br><ul><li>  The quality is lower than that of PNG (S3TC is an image compression format with loss of information). </li><li>  Not supported on all Android devices. </li></ul><br>  You can use <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D6812">DirectX Texture Tool</a> from DirectX (included in the DX SDK) to work with this format. <br><br><h2>  <font color="#0071c5">Access to texture data</font> </h2><br>  Most file formats for storing compressed textures include a header located in front of the image data.  Usually the header contains information about the name of the format of the compression of textures, the width and height of the texture, its color depth, the size of the data, the internal format and other information about the file. <br><br>  Our goal is to load texture data from different files and superimpose them on a two-dimensional model to compare image quality and data size.  The header, which is located in front of the graphic data, should not be processed as part of the texture, if we consider it a fragment of the image and superimpose it on the model, this will lead to distortions.  File headers for different texture compression formats are different, so each format needs individual support, otherwise it will not work to load and apply texture correctly. <br><br><h3>  note </h3><br>  The PVRTC header is packed taking into account the presence of a data member of a 64-bit pixel format (mPixelFormat in the example).  In the code compiled for ARM, the header is aligned with the addition of 4 additional bytes to it, with the result that, from the original 52-byte one, it becomes 56-byte.  This leads to the fact that when outputting to ARM devices, the image is distorted.  In the code compiled for Intel processors, this does not happen.  Packing the header solves the alignment problem on ARM devices, as a result, the texture is displayed correctly on both ARM devices and Intel devices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa7/33a/dde/fa733adde9419c1b77f24263a185a731.png"><br>  <i><font color="#999999">Here's what the image distortion on the ARM device looks like caused by alignment of the header.</font></i> <br><br><h3>  About example application </h3><br>  An example of Android Texture Compression, fragments of which will be given below, allows everyone to quickly compare the quality of textures in five formats.  Namely, it is Portable Network Graphics (PNG), Ericsson Texture Compression (ETC), Ericsson Texture Compression 2 (ETC2), PowerVR Texture Compression (PVRTC), and S3 Texture Compression (S3TC), which is sometimes called DirectX Texture Compression (DXTC) . <br><br>  The example shows how to load and use textures of these formats using OpenGL ES in Android.  Images stored in different formats are located next to each other, which allows you to compare their size and quality.  Choosing the most suitable format for storing textures for a specific project allows the developer to find the right balance between application size, visual picture quality and performance. <br><br>  In the example, the image stored in the file of each of the formats is loaded, the coordinates are determined to overlay it on the model, and a fragment of each texture is displayed.  The result is a single image, divided into four textures of the appropriate format.  The formats are shown at the top of the screen, the file size is shown below. <br><br>  The example considered here is based on the code that William Guo created.  Christiano Ferreira, an expert on graphics applications from Intel, has added an example using ETC2 texture compression.  Download the code <a href="https://github.com/Cristianohh/ETC2TextureLoader">here</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce0/827/7b2/ce08277b2c6bc0766b9f4ddb3f1c0f1c.png"><br>  <i><font color="#999999">Texture compression formats: size and quality</font></i> <br><br><h3>  PNG download </h3><br>  You can work with PNG MIP maps using the simple glGenerateMipmap function from Khronos OpenGL, which was created specifically for this purpose.  We, in order to read and download PNG files, used the code prepared by Sean Barret, stb_image.c, which is publicly available.  Also, this code is used to find and select the area of ‚Äã‚Äãtexture that needs to be processed. <br><br><pre><code class="hljs pgsql">//      glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>, width, height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>, GL_UNSIGNED_BYTE, pData );    //  MIP-    glGenerateMipmap( GL_TEXTURE_2D );</code> </pre> <br><h3>  ETC / ETC2 Download </h3><br>  As mentioned above, ETC textures can be stored in KTX and PKM files.  KTX is a standard compression format used as a container for multiple images, it is ideal for creating MIP cards.  In turn, PKM was created to store separate compressed images, so creating MIP cards based on it results in the need to generate multiple files, and this is inefficient.  MTC card support for ETC in the example is limited to the KTX format. <br><br>  Khronos provides an open source library written in C (libktx), which supports downloading MIP cards from KTX files.  We used this library and implemented the code in the LoadTextureETC_KTX function responsible for loading textures.  The function that directly loads KTX files is called ktxLoadTextureM.  It allows you to load the desired texture from the data in memory.  This function is part of the libktx library; documentation on it can be found <a href="https://www.khronos.org/opengles/sdk/tools/KTX/doc/libktx/">on the Khronos website</a> . <br><br>  Here is a snippet of code that initializes the texture and provides MIP card support for the ETC (KTX) format. <br><br><pre> <code class="hljs pgsql">//   (handle)      GLuint handle = <span class="hljs-number"><span class="hljs-number">0</span></span>;   GLenum target;   GLboolean mipmapped;       KTX_error_code result = ktxLoadTextureM( pData, fileSize, &amp;handle, &amp;target, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, &amp;mipmapped, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> );   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( result != KTX_SUCCESS )   {       LOGI( "KTXLib couldn't load texture %s. Error: %d", TextureFileName, result );       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;   }   //     glBindTexture( target, handle );</code> </pre> <br><h3>  PVRTC loading </h3><br>  MIP card support for PVRTC textures is a bit more complicated.  After reading the header, an offset is determined that equals the sum of the sizes of the header and the metadata.  Metadata follows the heading; they are not part of the image.  For each generated map level, pixels are grouped into blocks (the differences depend on whether the encoding is 4 bits per pixel or 2 bits - both options are suitable for PVRTC).  Further, there is a search for boundaries, fixed width and height of the blocks.  Then the function glCompressedTexImage () is called, it identifies a two-dimensional image in the compressed format PVRTC.  Further, the size of the pixel data is calculated and what is obtained is added to the previously found offset in order to group the set of pixels for the next map fragment.  This process is repeated until all the textures that make up the map are processed. <br><br><pre> <code class="hljs pgsql">//     unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = sizeof(PVRHeaderV3) + pHeader-&gt;mMetaDataSize;   unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> mipWidth = pHeader-&gt;mWidth;   unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> mipHeight = pHeader-&gt;mHeight;   unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> mip = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   {       //   ( *  * bbp/<span class="hljs-number"><span class="hljs-number">8</span></span>),    <span class="hljs-number"><span class="hljs-number">32</span></span>       unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> pixelDataSize = ( mipWidth * mipHeight * bitsPerPixel ) &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>;       pixelDataSize = (pixelDataSize &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) ? <span class="hljs-number"><span class="hljs-number">32</span></span> : pixelDataSize;       //             glCompressedTexImage2D(GL_TEXTURE_2D, mip, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>, mipWidth, mipHeight, <span class="hljs-number"><span class="hljs-number">0</span></span>, pixelDataSize, pData + <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>);       checkGlError("glCompressedTexImage2D");       //        ,  ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>       mipWidth  = ( mipWidth &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : mipWidth &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;       mipHeight = ( mipHeight &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : mipHeight &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;       //           <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> += pixelDataSize;       mip++;   } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(mip &lt; pHeader-&gt;mMipmapCount);</code> </pre> <br><h3>  S3TC download </h3><br>  After downloading the file that stores the S3TC texture, its format is determined and the MIP card located behind the header is read.  A fragment of the map is traversed, the pixels are grouped into blocks.  Then, to identify the two-dimensional image in the compressed data, the function glCompressedTexImage () is called.  The total block size is then added to the offset in order to be able to find the beginning of the next map fragment and perform the same actions.  This is repeated until all levels of the map have been processed.  Here is a code snippet that initializes the texture and provides MIP card support for the S3TC format. <br><br><pre> <code class="hljs pgsql">//     //      unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;   unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> width = pHeader-&gt;mWidth;   unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> height = pHeader-&gt;mHeight;   unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> mip = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   {       //         //   : size = ceil(&lt;w&gt;/<span class="hljs-number"><span class="hljs-number">4</span></span>) * ceil(&lt;h&gt;/<span class="hljs-number"><span class="hljs-number">4</span></span>) * blockSize       unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> Size = ((width + <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) * ((height + <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) * blockSize;        glCompressedTexImage2D( GL_TEXTURE_2D, mip, <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>, width, height, <span class="hljs-number"><span class="hljs-number">0</span></span>, Size, (pData + sizeof(DDSHeader)) + <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> );       checkGlError( "glCompressedTexImage2D" );       <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> += Size;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( width &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) == <span class="hljs-number"><span class="hljs-number">0</span></span>) width = <span class="hljs-number"><span class="hljs-number">1</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( height &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) == <span class="hljs-number"><span class="hljs-number">0</span></span>) height = <span class="hljs-number"><span class="hljs-number">1</span></span>;       mip++;   } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( mip &lt; pHeader-&gt;mMipMapCount );</code> </pre> <br><h2>  <font color="#0071c5">findings</font> </h2><br>  Depending on the specific situation, choosing the most appropriate format for storing compressed textures can improve the appearance of images, seriously reduce the size of the application and significantly improve performance.  Careful selection of the optimal texture compression method can give developers and their applications a serious competitive advantage.  The example application Android Texture Compression shows how to work with textures of the most popular formats in Android.  <a href="https://github.com/Cristianohh/ETC2TextureLoader">Download the code</a> and add support for the most appropriate texture compression formats to your projects. </div><p>Source: <a href="https://habr.com/ru/post/276089/">https://habr.com/ru/post/276089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276071/index.html">Oracle Stops Java Browser Plugin</a></li>
<li><a href="../276077/index.html">XAML Developer Chips: Dynamic Grid</a></li>
<li><a href="../276079/index.html">Hakaton on the analysis of open data of users of the social network VKontakte. For schoolchildren and freshmen</a></li>
<li><a href="../276083/index.html">How does the virtual mobile operator (MVNO) work with the greatest benefit for subscribers and for themselves?</a></li>
<li><a href="../276087/index.html">Oracle stops Java plugin support for web browsers</a></li>
<li><a href="../276091/index.html">A game for those learning to program: Colobot</a></li>
<li><a href="../276093/index.html">TensorFlow and Logistic Regression</a></li>
<li><a href="../276095/index.html">Prediction, cloud computing in 2016</a></li>
<li><a href="../276097/index.html">Game design: on the other side of the game</a></li>
<li><a href="../276099/index.html">Add local search system to Android application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>