<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What I learned about optimization in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Today we want to share one more translation prepared on the eve of the launch of the Python Developer course. Go! 



 I used Python more often...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What I learned about optimization in Python</h1><div class="post__text post__text-html js-mediator-article">  Hello.  Today we want to share one more translation prepared on the eve of the launch of <a href="https://otus.pw/5ywK/">the Python Developer</a> course.  Go! <br><br><img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br><br>  I used Python more often than any other programming language in the last 4-5 years.  Python is the predominant language for Firefox builds, testing, and the CI tool.  Mercurial is also mostly written in Python.  I also wrote a lot of my third-party projects on it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During my work, I gained a little knowledge of Python's performance and optimization tools.  In this article I would like to share this knowledge. <br><br>  My experience with Python is mainly related to the CPython interpreter, especially CPython 2.7.  Not all of my observations are universal for all Python distributions, or for those that have the same characteristics in similar versions of Python.  I will try to mention this during the narration.  Remember that this article is not a detailed review of Python performance.  I will only talk about what I came across on my own. <a name="habracut"></a><br><br><h2>  Load due to the features of the launch and import of modules </h2><br>  Running the Python interpreter and importing modules is a long process if it‚Äôs about milliseconds. <br><br>  If you need to run hundreds or thousands of Python processes in one of your projects, this delay will turn into a delay of a few seconds in milliseconds. <br><br>  If you use Python to provide CLI tools, the overhead can cause a noticeable hang to the user.  If you need CLI tools instantly, then starting the Python interpreter with each call will make it harder to get this complex tool. <br><br>  I already wrote about this issue.  A few of my last notes talk about this, for example, <a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">in 2014</a> , <a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">in May 2018</a> and <a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">October 2018</a> . <br><br>  There are not so many things you can do to reduce the launch delay: fixing this case refers to manipulating the Python interpreter, since it is he who controls the execution of code that takes too much time.  The best thing you can do is turn off the import of the <a href="https://docs.python.org/3/using/cmdline.html">site</a> module in calls to avoid executing unnecessary Python code during startup.  On the other hand, many applications use the site.py module functionality, so you can use it at your own risk. <br><br>  We should also consider the problem of importing modules.  What good is a Python interpreter if it does not process any code?  The point is that the code becomes available for understanding the interpreter most often through the use of modules. <br><br>  To import modules you need to take a few steps.  And in each of them there is a potential source of loads and delays. <br><br>  A certain delay occurs due to the search for modules and the reading of their data.  As I demonstrated using <a href="https://gregoryszorc.com/blog/2019/01/06/pyoxidizer-support-for-windows/">PyOxidizer</a> , replacing the search and loading of a module from the file system with an architecturally simpler solution, which consists in reading module data from a data structure in memory, you can import the standard Python library for 70-80% of the initial time to solve this problem.  Having one module per file system file increases the load on the file system and can slow down the Python application in the critical first milliseconds of execution.  Solutions like PyOxidizer can help avoid this.  I hope that the Python community sees these costs of the current approach and is considering the possibility of moving to the mechanisms for distributing modules that are not so dependent on individual files in the module. <br><br>  Another source of additional costs for importing a module is the execution of code in this module during import.  Some modules contain parts of the code in the area outside the functions and classes of the module, which is executed when the module is imported.  Execution of such a code increases the cost of import.  Workaround: do not execute all the code during the import, but execute it only when needed.  Python 3.7 supports the <code>__getattr__</code> module, which will be called if the attribute of any module was not found.  This can be used to lazily populate the attributes of a module upon first access. <br><br>  Another way to get rid of the slowdown during import is to import the module lazily.  Instead of directly loading the module when importing, you register a custom import module, which returns a stub instead.  When you first access this stub, it will load the actual module and ‚Äúmutate‚Äù to become this module. <br><br>  You can save tens of milliseconds at the expense of applications that import several dozen modules if you bypass the file system and avoid launching unnecessary parts of the module (modules are usually imported globally, but only certain module functions are used). <br><br>  Lazy import of modules is a fragile thing.  Many modules have templates in which there are the following things: <code>try: import foo</code> ;  <code>except ImportError:</code>  A lazy module importer may never issue an ImportError, because if it does, it will have to look in the file system for the module to find out if it exists in principle.  This will add additional workload and increase time costs, so lazy importers do not do this in principle!  This problem is rather unpleasant.  Importer of lazy modules Mercurial processes a list of modules that cannot be lazily imported, and it should bypass them.  Another problem is the syntax <code>from foo import x, y</code> , which also interrupts the import of a lazy module, in cases where foo is a module (as opposed to a package), because to return a reference to x and y, the module still needs to be imported. <br><br>  PyOxidizer has a fixed set of modules embedded in a binary, so it can be effective in issuing an ImportError.  The __getattr__ module from Python 3.7 provides additional flexibility for lazy module importers.  I hope to integrate a reliable lazy importer into PyOxidizer to automate some processes. <br><br>  The best solution to avoid running the interpreter and the appearance of time delays is to start the background process in Python.  If you run the Python process as a daemon (daemon process), say for a web server, then you can do it.  The solution that Mercurial proposes is running a background process that provides a <a href="https://www.mercurial-scm.org/wiki/CommandServer">command server protocol</a> .  hg is an executable file C (or now Rust), which connects to this background process and sends a command.  To find an approach to the command server, you need to do a lot of work, it is extremely unstable and has security problems.  I am considering the idea of ‚Äã‚Äãdelivering a command server using PyOxidizer so that the executable file has its advantages, and the problem of the cost of a software solution is solved by creating a PyOxidizer project. <br><br><h2>  Delay due to function call </h2><br>  Calling functions in Python is a relatively slow process.  (This observation is less applicable to PyPy, which can execute JIT code.) <br><br>  I saw dozens of patches for Mercurial, which made it possible to align and combine the code in such a way as to avoid unnecessary load when calling functions.  In the current development cycle, some efforts were made to reduce the number of called functions when updating the progress bar.  (We use progress bars for any operations that may take some time so that the user understands what is happening).  Getting the results of calling <a href="https://www.mercurial-scm.org/repo/hg/rev/6603de284b0a">functions</a> and avoiding simple searches among <a href="https://www.mercurial-scm.org/repo/hg/rev/963462786f6e">functions</a> saves tens of hundreds of milliseconds when executed, when we talk about one million executions, for example. <br><br>  If you have hard loops or recursive functions in Python, where hundreds of thousands or more function calls can happen, you should be aware of the overhead of calling a single function, as this is important.  Keep in mind the presence of built-in simple functions and the possibility of combining functions to avoid overhead. <br><br><h2>  Additional attribute search load </h2><br>  This problem is similar to the overhead due to a function call, since the meaning is almost the same! <br><br>  Finding (resolving) attributes in Python can be slow.  (Again, this is faster in PyPy).  However, handling this problem is something we do often in Mercurial. <br><br>  Suppose you have the following code: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(obj.member): total += obj.member[i]</code> </pre> <br>  We omit that there are more efficient ways of writing this example (for example, <code>total = sum(obj.member)</code> ), and note that the loop needs to define obj.member at each iteration.  Python has a relatively complex mechanism for defining <a href="https://docs.python.org/3/reference/datamodel.html">attributes</a> .  For simple types, it can be quite fast.  But for complex types, this attribute access can automatically call <code>__getattr__</code> , <code>__getattribute__</code> , various <code>dunder</code> methods <code>dunder</code> and even user-defined <code>@property</code> functions.  This is similar to a quick search for an attribute that can make several function calls, which will lead to an extra load.  And this load can be exacerbated if you use things like <code>obj.member1.member2.member3</code> , etc. <br><br>  Each attribute definition causes an extra load.  And since almost everything in Python is a dictionary, we can say that every attribute search is a dictionary search.  From the general concepts of basic data structures, we know that a dictionary search is not as fast as, say, a pointer search.  Yes, of course there are a few tricks in CPython that allow you to get rid of overhead due to a dictionary search.  But the main topic I want to touch on is that any attribute search is a potential performance leak. <br><br>  For hard loops, especially those that potentially exceed hundreds of thousands of iterations, you can avoid these measurable attribute search costs by assigning a value to a local variable.  Let's look at the following example: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> member = obj.member <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(member): total += member[i]</code> </pre> <br>  Of course, this can be done safely only if it is not replaced in a cycle.  If this happens, the iterator will save the link to the old element and everything can explode. <br>  The same trick can be performed when calling an object method.  Instead <br><br><pre> <code class="python hljs">obj = MyObject() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): obj.process(i)</code> </pre><br>  You can do the following: <br><br><pre> <code class="python hljs">obj = MyObject() fn = obj.process <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>:) fn(i)</code> </pre> <br>  It is also worth noting that in the case when the attribute search needs to call a method (as in the previous example), then Python 3.7 is relatively <a href="https://bugs.python.org/issue26110">faster</a> than previous releases.  But I am sure that here the excessive load is connected, first of all, with the function call, and not with the load on the attribute search.  Therefore, everything will work faster if you give up the unnecessary attribute search. <br><br>  Finally, since the search for attributes causes this function, we can say that the search for attributes is generally less of a problem than the load due to a function call.  As a rule, to notice significant changes in the speed of work, you will need to eliminate a multitude of attribute searches.  In this case, as soon as you give access to all the attributes inside the loop, you can talk about 10 or 20 attributes only in the loop before the function is called.  And cycles with a total of thousands or less than tens of thousands of iterations can quickly provide hundreds of thousands or millions of attribute searches.  So be careful! <br><br><h2>  Object load </h2><br>  From the point of view of the Python interpreter, all values ‚Äã‚Äãare objects.  In CPython, each element is a PyObject structure.  Each object managed by the interpreter is in the heap and has its own memory containing a reference counter, the type of the object and other parameters.  Each object is disposed of by the garbage collector.  This means that each new object adds overhead due to reference counting, garbage collection, etc.  (And again, PyPy can avoid this extra load, since it "more attentively refers" to the lifetime of short-term values.) <br><br>  As a rule, the more unique values ‚Äã‚Äãand Python objects you create, the slower everything works. <br><br>  Let's say you iterate through a collection of one million objects.  You call a function to collect this object in a tuple: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> my_collection: a, b, c, d, e, f, g, h = process(x)</code> </pre> <br>  In this example, <code>process()</code> will return an 8-tuple tuple.  It does not matter whether we destroy the return value or not: this tuple requires at least 9 values ‚Äã‚Äãto be created in Python: 1 for the tuple itself and 8 for its internal members.  Well, in real life there may be less values ‚Äã‚Äãif <code>process()</code> returns a reference to an existing object.  Or, on the contrary, there may be more if their types are not simple and require a set of PyObjects to be represented.  I just want to say that under the hood of the interpreter there is a real juggling of objects for the full representation of certain structures. <br><br>  From my own experience, I can say that these overheads are relevant only for operations that give a speed gain when implemented in a native language such as C or Rust.  The problem is that the CPython interpreter is simply unable to perform bytecode so quickly that the additional load is important due to the number of objects.  Instead, you will most likely reduce performance by calling a function, or by cumbersome calculations, etc.  before you can notice the extra load due to objects.  There are, of course, several exceptions, namely the construction of tuples or dictionaries of several values. <br><br>  As a concrete example of overhead, we can give Mercurial having a C code that parses low-level data structures.  For faster parsing, the C code is executed an order of magnitude faster than CPython does.  But as soon as the C code creates PyObject to represent the result, the speed drops several times.  In other words, the load is related to the creation and management of Python elements so that they can be used in the code. <br><br>  The way to get around this problem is to produce fewer elements in Python.  If you need to refer to a single element, then let the function return it, not a tuple or a dictionary of N elements.  However, do not stop to monitor the possible load due to the call functions! <br><br>  If you have a lot of code that runs fast enough using the CPython C API, and the elements that need to be distributed between different modules, do not have Python types that present the various data as C structures and have already compiled code to access these structures. instead of going through the CPython C API.  By avoiding CPython C API for data access, you will get rid of a large amount of unnecessary load. <br><br>  Considering elements as data (instead of having functions to access everything in a row) would be the best approach for a pythonist.  Another workaround for already compiled code is the lazy creation of PyObject instances.  If you create a custom type in Python (PyTypeObject) to represent complex elements, you need to define the <i><a href="https://docs.python.org/3/c-api/typeobj.html">tp_members</a></i> fields or <i><a href="https://docs.python.org/3/c-api/typeobj.html">tp_getset</a></i> to create custom C functions to find the value for the attribute.  If you, say, write a parser and know that customers will only have access to a subset of the analyzed fields, you can quickly create a type containing raw data, return this type and call a C function to search for Python attributes that processes PyObject.  You can even postpone parsing until the function is called to save resources in case parsing is never needed!  This technique is quite rare because it requires writing non-trivial code, but it gives a positive result. <br><br><h2>  Predetermining the size of the collection </h2><br>  This refers to the CPython C API. <br><br>  When creating collections, such as lists or dictionaries, use <code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> to populate a new collection if its size has already been determined at the time of creation.  This will pre-determine the size of the collection in order to be able to hold a finite number of elements in it.  This helps to skip checking for sufficient collection size when inserting items.  When creating a collection of thousands of items this will help save some resources! <br><br><h2>  Using Zero-copy in C API </h2><br>  In the Python C API, it‚Äôs really more like making copies of objects than returning links to them.  For example, <i><a href="https://docs.python.org/3.7/c-api/bytes.html">PyBytes_FromStringAndSize ()</a></i> copies <code>char*</code> into memory reserved Python.  If you do this for a large number of values ‚Äã‚Äãor big data, then we could talk about gigabytes of I / O from memory and the associated allocator load. <br><br>  If you need to write high-performance code without the C API, then you should familiarize yourself with the <i><a href="https://docs.python.org/3.7/c-api/buffer.html">buffer protocol</a></i> and the corresponding types, such as <i><a href="https://docs.python.org/3.7/c-api/memoryview.html">memoryview</a> .</i> <br><br>  <code>Buffer protocol</code> is built into Python types and allows interpreters to cast from / to byte types.  It also allows the C interpreter to get a <code>void*</code> handle of a certain size.  This allows you to associate any address in memory with PyObject.  Many functions that work with binary data transparently accept any object that implements the <code>buffer protocol</code> .  And if you want to accept any object that can be considered as bytes, then you need to use <a href="https://docs.python.org/3/c-api/arg.html">the</a> <code>s*</code> , <code>y*</code> or <code>w*</code> <a href="https://docs.python.org/3/c-api/arg.html">format units</a> when receiving function arguments. <br><br>  Using the <code>buffer protocol</code> , you give the interpreter the best opportunity to use <code>zero-copy</code> operations and refuse to copy extra bytes into memory. <br><br>  By using Python types of <code>memoryview</code> , you can also allow Python to access memory levels by reference, instead of creating copies. <br><br>  If you have gigabytes of code that runs through your Python program, then an insightful use of Python types that support zero-copy will save you the difference in performance.  Once I noticed that <a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> was faster than any Python LZ4 bindings (although it should be the other way around), because I used the <code>buffer protocol</code> too extensively and avoided excessive memory I / O in <code>python-zstandard</code> ! <br><br><h2>  Conclusion </h2><br>  In this article, I tried to talk about some things that I learned while optimizing my Python programs for several years.  I repeat and say that it is not in any way a comprehensive review of Python performance improvement methods.  I admit that I may use Python more demandingly than others, and my recommendations cannot be applied to all programs.  <b>You should in no case massively correct your Python code and remove, for example, the search for attributes after reading this article</b> .  As always, when it comes to optimizing performance, first correct where the code is especially slow.  I highly recommend <i><a href="https://github.com/benfred/py-spy">py-spy</a></i> for profiling Python applications.   ,     ,      Python,       .  ,        ,         ,     ! <br><br> ,          Python    . ,       ,  Python           -  .     Python   ‚Äì     PyPy,        .  Python      .    ,     Python  ,     .      ,          ¬´  ¬ª.   ,   ,     ,    Python,   ,    ,      . <br><br>       ;-) </div><p>Source: <a href="https://habr.com/ru/post/457942/">https://habr.com/ru/post/457942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457930/index.html">Statically safe dynamic typing √† la Python</a></li>
<li><a href="../457932/index.html">Reviewing the IDS Bypass Competition at Positive Hack Days 9</a></li>
<li><a href="../457936/index.html">We invite you to the first Zabbix conference in Russia</a></li>
<li><a href="../45794/index.html">ExtJS extensions for the Adobe AIR platform</a></li>
<li><a href="../457940/index.html">How to peek into the counterparty</a></li>
<li><a href="../457946/index.html">Top 10 JavaScript libraries for visualizing data in graphs and charts</a></li>
<li><a href="../457948/index.html">Board games, which will have to break his head</a></li>
<li><a href="../45795/index.html">Cleaning Ubuntu from unnecessary applications</a></li>
<li><a href="../457952/index.html">How processors are developed and manufactured: chip manufacturing</a></li>
<li><a href="../457954/index.html">Why Swift can be a great event in depth learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>