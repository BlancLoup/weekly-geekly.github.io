<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Categories</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Logging composition 
 You have seen how to make categories of types and pure functions. I also mentioned that there is a way to model side effects, or...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Categories</h1><div class="post__text post__text-html js-mediator-article"><h4>  Logging composition </h4><br>  You have seen how to make categories of types and pure functions.  I also mentioned that there is a way to model side effects, or impure functions, within the framework of category theory.  Let's look at an example: functions that log or record their progress. <br><a name="habracut"></a><br>  Something that in an imperative language is likely to be realized through the mutation of some global state, for example: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> logger; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">negate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ logger += <span class="hljs-string"><span class="hljs-string">"Not so! "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !b; }</code> </pre> <br>  You know that this is not a pure function, because its version with caching the results will not be able to write to the log.  This feature has side effects. <br><br>  In modern programming, we try to stay away from the global changeable state, while it is possible - at least, because of the difficulties with parallelism.  And you never write similar code to libraries. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Fortunately for us, you can make this feature clean.  You just need to pass the log explicitly to and from the function.  Let's do this by adding a string argument, and returning the pair from the main result and the line containing the updated log: <br><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; negate(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> logger) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(!b, logger + <span class="hljs-string"><span class="hljs-string">"Not so! "</span></span>); }</code> </pre><br>  This function is clean, it has no side effects, it returns the same pair every time it is called with the same arguments, and its results can be cached if necessary.  However, given the cumulative nature of the log, you will have to cache all possible stories that may lead to this challenge.  There will be a separate cached entry for: <br><br><pre> <code class="cpp hljs">negate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"It was the best of times. "</span></span>);</code> </pre><br>  and <br><pre> <code class="cpp hljs">negate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"It was the worst of times. "</span></span>);</code> </pre><br>  and so on. <br><br>  This is not a very good interface to the library function.  Users can freely ignore the string in the return value, so there is a small additional complexity, but they have to pass the string as input, which can be inconvenient. <br><br>  Is there a way to do the same thing less intrusive?  Is there a way to share the problems?  In this simple example, the main purpose of the negate function is to turn one Boolean into another.  Logging is secondary.  Of course, a message that is logged is function-specific, but aggregating messages into one continuous log is a separate task.  We still want the function to return a string, but we would like to free it from the task of creating a log.  Here is a compromise solution: <br><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; negate(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(!b, <span class="hljs-string"><span class="hljs-string">"Not so! "</span></span>); }</code> </pre><br>  The idea is that the log will be aggregated between function calls. <br><br>  To see how this can be done, let's move on to a slightly more realistic example.  We have one function from string to string that turns lower case letters into upper case: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toUpper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*toupperp)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) = &amp;<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>; <span class="hljs-comment"><span class="hljs-comment">// toupper is overloaded transform(begin(s), end(s), back_inserter(result), toupperp); return result; }</span></span></code> </pre><br>  and another one, which breaks a line into a vector of lines, breaking it up by spaces: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; toWords(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> words(s); }</code> </pre><br>  The main work is done in the auxiliary function words: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; words(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; result{<span class="hljs-string"><span class="hljs-string">""</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = begin(s); i != end(s); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>(*i)) result.push_back(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result.back() += *i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  We want to change the toUpper and toWords functions so that they cling the message string on top of their normal return values. <br><br><img align="right" width="176" height="188" src="https://habrastorage.org/getpro/habr/post_images/888/076/da0/888076da08e0cda49b50423ee271f395.jpg" alt="image"><br><br>  We will "enrich" the return values ‚Äã‚Äãof these functions.  Let's do it in a general way by defining a Writer template that encapsulates a pair, the first component of which is a value of an arbitrary type A, and the second component is a string: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">&lt;A, string&gt;;</span></span></code> </pre><br>  Here are the enriched functions: <br><br><pre> <code class="cpp hljs">Writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; toUpper(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*toupperp)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) = &amp;<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>; transform(begin(s), end(s), back_inserter(result), toupperp); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(result, <span class="hljs-string"><span class="hljs-string">"toUpper "</span></span>); } Writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt; toWords(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(words(s), <span class="hljs-string"><span class="hljs-string">"toWords "</span></span>); }</code> </pre><br>  We want to group these functions into another rich function that raises the string to upper case and breaks it into words, while logging these actions.  Here's how we can do it: <br><br><pre> <code class="cpp hljs">Writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt; process(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = toUpper(s); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = toWords(p1.first); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(p2.first, p1.second + p2.second); }</code> </pre><br>  We have achieved our goal: merging a journal is no longer a concern for individual functions.  They produce their own messages, which are then, outside, collected into a whole log. <br><br>  Now imagine the whole program written in this style.  This is a nightmare of repetitive and error-prone code.  But we are programmers.  We know how to deal with duplicate code: we abstract it!  These, however, are not your usual abstractions: we must abstract the very composition of functions.  But composition is the essence of category theory, so before writing code further, let's analyze this problem from a categorical point of view. <br><br><h4>  Category Writer </h4><br>  The idea of ‚Äã‚Äãenriching return types of functions in order to attach some additional functionality turns out to be very useful.  We will see many more such examples.  The starting point is our usual category of types and functions.  We leave the types as objects, but redefine morphisms as enriched functions. <br><br>  For example, suppose we want to enrich the isEven function, which converts an int into a bool.  We turn it into a morphism, which is represented by an enriched function.  It is important that this morphism is still considered an arrow between int and bool objects, although the decorated function returns a pair: <br><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; isEven(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(n % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"isEven "</span></span>); }</code> </pre><br>  According to the laws of the category, we must be able to combine this morphism with another morphism, which goes from bool to anything.  In particular, we should be able to combine it with our previous negate function: <br><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; negate(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(!b, <span class="hljs-string"><span class="hljs-string">"Not so! "</span></span>); }</code> </pre><br>  Obviously, we cannot compose these two morphisms in the same way as we compose the usual functions, due to the mismatch of input / output.  Their composition should look like this: <br><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; isOdd(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; p1 = isEven(n); pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; p2 = negate(p1.first); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(p2.first, p1.second + p2.second); }</code> </pre><br>  So, here is the recipe for the composition of two morphisms in this new category that we are building: <br><ol><li>  Perform enriched function corresponding to the first morphism. </li><li>  Extract the first component of the result pair and pass it to an enriched function corresponding to the second morphism. </li><li>  Connect the second component (line) of the first result and the second component (also line) of the second result </li><li>  Return the new pair that combines the first component of the final result with the concatenated string. </li></ol><br>  If we want to abstract this composition as a higher order function in C ++, we must use a template parameterized by three types, corresponding to the three objects in our category.  You should take two enriched functions that are compiled according to our rules, and return the third enriched function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">&lt;Writer&lt;C&gt;(A)&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compose</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">&lt;Writer&lt;B&gt;(A)&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">&lt;Writer&lt;C&gt;(B)&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [m1, m2](A x) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = m1(x); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = m2(p1.first); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(p2.first, p1.second + p2.second); }; }</code> </pre><br>  Now we can return to our example and implement the composition toUpper and toWords using this template: <br><br><pre> <code class="cpp hljs">Writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt; process(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compose&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;(toUpper, toWords)(s); }</code> </pre><br>  There is still a lot of noise with the transfer of types to the compose template.  This can be avoided if as long as you have a C ++ 14-compatible compiler that supports generic lambda functions with return type deduction (thanks to Eric Niebler for the code): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m1, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [m1, m2](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = m1(x); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = m2(p1.first); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(p2.first, p1.second + p2.second); }; };</code> </pre><br>  In this new definition, the implementation process is simplified: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Writer</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">vector</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span>&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">process</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>){ return compose(toUpper, toWords)(s); }</code> </pre><br>  But we are not done yet.  We defined the composition in our new category, but what are the single morphisms?  These are not our regular identity functions!  They must be morphisms from type A back to type A, which means they are enriched functions of the form: <br><br><pre> <code class="cpp hljs">Writer&lt;A&gt; identity(A);</code> </pre><br>  They should behave as units in relation to the composition.  If you look at our definition of composition, you will see that the identical morphism, must pass its argument without change, but only add an empty line to the log: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span><span class="hljs-class">&lt;A&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(x, <span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre><br>  You can easily make sure that the category we have just defined is a truly legitimate category.  In particular, our composition is trivially associative.  If you trace what happens to the first component of each pair, you will see that it is just a simple composition of functions that is associative.  The second components are connected, and concatenation is also associative. <br><br>  An astute reader may notice that one can easily generalize this construction to any monoid, and not just strings.  We would like to use mappend inside compose and mempty inside identity (in place of + and "").  Indeed, there is no reason to limit yourself to logging only strings.  A good library writer should be able to determine the necessary minimum of restrictions that are necessary for a library to work - here the only requirement of a logging library is that the log has monoidal properties. <br><br><h4>  Haskell Writer </h4><br>  The same construction on Haskell will be much more concise, and the compiler will help us a lot more.  Let's start by defining the type of Writer: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Writer</span></span></span><span class="hljs-class"> a = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Here I simply define a type alias, the equivalent of typedef (or using) in C ++.  The Writer type is parameterized by a type variable and is equivalent to a pair of a and String.  The syntax for pairs is minimal: there are only two names in brackets, separated by commas. <br><br>  Our morphisms are functions from an arbitrary type to a specific type of Writer: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> b</code> </pre><br>  We will declare the composition as a funny infix operator, sometimes called ‚Äúfish‚Äù: <br><pre> <code class="haskell hljs">(&gt;=&gt;) :: (a -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> b) -&gt; (b -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> c) -&gt; (a -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> c)</code> </pre><br>  This is a function of two arguments, each of which is itself a function, and it returns a function.  The first argument is of type (a -&gt; Writer b), the second (b -&gt; Writer c) and result (a -&gt; Writer c). <br><br>  Here is the definition of this infix operator - two arguments m1 and m2, appear on both sides of the fish symbol: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">m1</span></span> &gt;=&gt; m2 = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (y, s1) = m1 x (z, s2) = m2 y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (z, s1 ++ s2)</code> </pre><br>  The result is a lambda function of one argument x.  Lambda is written as a backslash - you can think of it as the Greek letter Œª with an amputated leg. <br><br>  The word let allows you to declare auxiliary variables.  Here the result of calling m1 is matched with a pair of variables (y, s1), and the result of calling m2 with the argument y from the first pattern will be matched with (z, s2). <br><br>  In Haskell, matching pairs is a common substitute for using getters, as we did in C ++.  In addition, there is a fairly simple correspondence between the two implementations. <br><br>  The value of the let expression is contained after in: here is a pair, whose first component is z, and the second component is the union of two strings, s1 ++ s2. <br><br>  I will also define a unit morphism for our category, but for reasons that will become clear much later, I will call it return. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">return</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> a return x = (x, <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre><br>  For completeness, let's write the Haskell version, enriched with upCase functions (approx. Translator: meant toUpper from C ++ example, but a function with this name already exists in the standard Prelude module) and toWords: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">upCase</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> upCase s = (map toUpper s, <span class="hljs-string"><span class="hljs-string">"upCase "</span></span>) toWords :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> [<span class="hljs-type"><span class="hljs-type">String</span></span>] toWords s = (words s, <span class="hljs-string"><span class="hljs-string">"toWords "</span></span>)</code> </pre><br>  The map function corresponds to the transform function in C ++.  It applies the function on the toUpper characters to the string s.  The helper function words is defined in the standard Prelude library. <br><br>  Finally, the composition of these two functions is built using the fish operator: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">process</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Writer</span></span> [<span class="hljs-type"><span class="hljs-type">String</span></span>] process = upCase &gt;=&gt; toWords</code> </pre><br><h4>  Categories </h4><br>  You probably guessed that I did not invent this category on the fly.  This is an example of the so-called Cleisley category, a monad-based category.  We are not yet ready to discuss monads, but I wanted to show what they can do.  For our limited purposes, the Claisley category has types as objects.  The morphisms from type A to type B are functions that go from A to the type derived from B using special enrichment.  Each Kleisley category defines its own way of composition of such morphisms, as well as identical morphisms with respect to this composition.  (Later we will see that the inaccurate term ‚Äúenrichment‚Äù corresponds to the concept of an endofunctor in a category.) <br><br>  The specific monad that I used as the basis of the category in this post is called a writer and is used to log or track the execution of functions.  It is also an example of a more general mechanism for embedding effects in pure computation.  You saw earlier that we could model programming language types and functions in the category of sets (excluding bottom, as usual).  Here we expanded this model to a slightly different category, categories where morphisms are represented by enriched functions, and their composition does more than simply transfer the result of one function to the input of another.  We have one degree of freedom more: you can change the composition itself.  It turns out that it is this degree of freedom that makes it possible to give simple denotational semantics to programs that are traditionally implemented in imperative languages ‚Äã‚Äãusing side effects. <br><br>  <a href="http://habrahabr.ru/post/245797/">Category Theory for Programmers: Preface</a> <br>  <a href="http://habrahabr.ru/post/246009/">Category: essence of composition</a> <br>  <a href="http://habrahabr.ru/post/247765/">Types and functions</a> <br>  <a href="http://habrahabr.ru/post/248257/">Categories big and small</a> <br>  Categories </div><p>Source: <a href="https://habr.com/ru/post/249113/">https://habr.com/ru/post/249113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249099/index.html">Warming data centers</a></li>
<li><a href="../249101/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.14 of 6</a></li>
<li><a href="../249103/index.html">Curves Beziers de Castelgio. HTML5 Canvas</a></li>
<li><a href="../249105/index.html">How to get convenient access to XAML-resources from Code-Behind</a></li>
<li><a href="../249107/index.html">ReactJS for stupid people</a></li>
<li><a href="../249115/index.html">How we made a mod under the Oculus Rift for World of Tanks</a></li>
<li><a href="../249117/index.html">Proxy server for free internet</a></li>
<li><a href="../249119/index.html">Xclaim - ‚Äúnoisy‚Äù * Wi-Fi invasion of small business</a></li>
<li><a href="../249123/index.html">Upgrade from Windows 7 / 8.1 to Windows 10 TP via Windows Update</a></li>
<li><a href="../249127/index.html">Practice "Intel IoT". Galileo Gen2 - Eclipse & libmraa + UPM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>