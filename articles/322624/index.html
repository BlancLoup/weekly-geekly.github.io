<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Uber - the reasons for the transition from Postgres to MySQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the end of July 2016, a truly historical article appeared on the Uber corporate blog about the reasons for the company's transition from PostgreSQL...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Uber - the reasons for the transition from Postgres to MySQL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/af4/865/0dc/af48650dc1ab446d8989ba1bb6a0afef.png"><br><br><p>  At the end of July 2016, a truly historical article appeared on the Uber corporate blog about the reasons for the company's transition from PostgreSQL to MySQL.  Since then, a lot of copies have been broken in hot discussions of this material, Uber‚Äôs arguments were carefully prepared, the company was accused of bias, technical illiteracy, inability to effectively interact with the community and other deadly sins, while several changes were made to Postgres, designed to solve some of the problems described.  The list of consequences does not end there, and it can be continued for a very long time. </p><br><p>  Probably it would not be an exaggeration to say that over the past few years this has become one of the most notorious and resonant events connected with the PostgreSQL DBMS, which, by the way, we love and use extensively.  This situation certainly benefited not only the systems mentioned, but also the movement of Free and Open Source as a whole.  At the same time, unfortunately, the Russian translation of the article did not appear.  Due to the significance of the event, as well as a detailed and interesting from a technical point of view material presentation, in which in the style of ‚ÄúPostgres vs MySQL‚Äù there is a comparison of the physical data structure on the disk, organization of primary and secondary indexes, replication, MVCC, updates and support of a large number of connections, we decided to fill this gap and translate the original article.  Result you can find under the cut. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  At an early stage of development, the Uber architecture consisted of a monolithic server application in Python that used <a href="http://www.postgresql.org/">Postgres</a> to store data.  Since then, much has changed: the model of <a href="https://eng.uber.com/soa/">microservices</a> was applied, as well as new data processing and storage platforms.  In particular, we used to use Postgres in many cases, but now we‚Äôve switched to <a href="https://eng.uber.com/schemaless-part-one/">Schemaless</a> , a new distributed storage system running on top of MySQL.  In this article we will talk about some of the shortcomings of Postgres and explain why we decided to build Schemaless and other services based on MySQL. </p><br><h2 id="arhitektura-postgres">  Postgres architecture </h2><br><p>  We encountered several Postgres flaws, including: </p><br><ul><li>  architecture inefficiency in terms of writing, </li><li>  poor data replication </li><li>  table damage cases </li><li>  MVCC issues on replicas </li><li>  difficulty updating. </li></ul><br><p>  We will look at these limitations by analyzing how Postgres places table and index data on disk, especially when compared to the MySQL approach implemented with the <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">InnoDB storage subsystem</a> .  Please note: the analysis presented here is for the most part based on our experience with the rather old version of Postgres 9.2.  But as far as we know, the internal architecture that we are discussing in this article has not seriously changed in new releases of Postgres.  Moreover, the basic principles of presenting data on disk, which are used in version 9.2, have not changed significantly since at least Postgres 8.3 (that is, it is almost 10 years old). </p><br><h3 id="format-predstavleniya-dannyh-na-diske">  Disk format </h3><br><p>  A relational DBMS must provide several key tasks: </p><br><ul><li>  performing insert / update / delete operations; </li><li>  making changes to the data schema; </li><li>  implementation of the mechanism for <a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">controlling parallel access using multiversion</a> (multiversion concurrency control, MVCC), which allows different connections to the database to use transactions when working with data. </li></ul><br><p>  The interaction of the above mechanisms largely determines how the DBMS will store data on disk. </p><br><p>  One of the key aspects of Postgres design is immutable strings.  They are called tuples in Postgres.  <a href="http://www.postgresql.org/docs/9.5/static/ddl-system-columns.html">Tuples</a> have unique identifiers ‚Äî <a href="http://www.postgresql.org/docs/9.5/static/ddl-system-columns.html">ctid</a> , which essentially represent a specific disk space (i.e., offset on physical media).  Several ctid could potentially describe a single line (for example, if there are multiple versions of the line within the MVCC or when the space occupied by the old versions of the line has not yet been freed by <a href="http://www.postgresql.org/docs/9.2/static/routine-vacuuming.html">autovacuum</a> ).  An organized collection of tuples forms a table.  Tables have indexes that have a specific data structure (usually B-trees), by means of which index fields are matched with data identified by ctid. </p><br><p>  The user is usually not confronted with ctid, but understanding these identifiers will help to better understand how Postgres stores data on disk.  To get ctid rows, add the ‚Äúctid‚Äù column to the query: </p><br><pre><code class="bash hljs">uber@[<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>] uber=&gt; SELECT ctid, * FROM my_table LIMIT 1; -[ RECORD 1 ]--------+------------------------------ ctid | (0,1) ...   ...</code> </pre> <br><p>  Let's take a simple user table as an example.  Each row has an automatically increasing primary key id, first name, last name and year of birth.  We will also create a secondary composite index for the full name (first name and surname) and another secondary index for the year of birth.  <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDL</a> instructions for creating such a table might look like this: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SERIAL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">first</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, birth_year <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_users_first_last <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">first</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ix_users_birth_year <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (birth_year);</code> </pre> <br><p>  Note: these instructions create three indexes: an index for the primary key and two secondary indexes. </p><br><p>  Fill the table with the data of famous mathematicians: </p><br><table><tbody><tr><td>  <b>id</b> </td><td>  <b>first</b> </td><td>  <b>last</b> </td><td>  <b>birth_year</b> </td></tr><tr><td>  one </td><td>  Blaise </td><td>  Pascal </td><td>  1623 </td></tr><tr><td>  2 </td><td>  Gottfried </td><td>  Leibniz </td><td>  1646 </td></tr><tr><td>  3 </td><td>  Emmy </td><td>  Noether </td><td>  1882 </td></tr><tr><td>  four </td><td>  Muhammad </td><td>  al-KhwƒÅrizmƒ´ </td><td>  780 </td></tr><tr><td>  five </td><td>  Alan </td><td>  Turing </td><td>  1912 </td></tr><tr><td>  6 </td><td>  Srinivasa </td><td>  Ramanujan </td><td>  1887 </td></tr><tr><td>  7 </td><td>  Ada </td><td>  Lovelace </td><td>  1815 </td></tr><tr><td>  eight </td><td>  Henri </td><td>  Poincar√© </td><td>  1854 </td></tr></tbody></table><br><p>  As mentioned earlier, each line contains a unique, non-default ctid.  The internal representation of the table may look as follows: </p><br><table><tbody><tr><td>  <b>ctid</b> </td><td>  <b>id</b> </td><td>  <b>first</b> </td><td>  <b>last</b> </td><td>  <b>birth_year</b> </td></tr><tr><td>  A </td><td>  one </td><td>  Blaise </td><td>  Pascal </td><td>  1623 </td></tr><tr><td>  B </td><td>  2 </td><td>  Gottfried </td><td>  Leibniz </td><td>  1646 </td></tr><tr><td>  C </td><td>  3 </td><td>  Emmy </td><td>  Noether </td><td>  1882 </td></tr><tr><td>  D </td><td>  four </td><td>  Muhammad </td><td>  al-KhwƒÅrizmƒ´ </td><td>  780 </td></tr><tr><td>  E </td><td>  five </td><td>  Alan </td><td>  Turing </td><td>  1912 </td></tr><tr><td>  F </td><td>  6 </td><td>  Srinivasa </td><td>  Ramanujan </td><td>  1887 </td></tr><tr><td>  G </td><td>  7 </td><td>  Ada </td><td>  Lovelace </td><td>  1815 </td></tr><tr><td>  H </td><td>  eight </td><td>  Henri </td><td>  Poincar√© </td><td>  1854 </td></tr></tbody></table><br><p>  The primary key index, which is used to match id and ctid identifiers, is defined as follows: </p><br><table><tbody><tr><td>  <b>id</b> </td><td>  <b>ctid</b> </td></tr><tr><td>  one </td><td>  A </td></tr><tr><td>  2 </td><td>  B </td></tr><tr><td>  3 </td><td>  C </td></tr><tr><td>  four </td><td>  D </td></tr><tr><td>  five </td><td>  E </td></tr><tr><td>  6 </td><td>  F </td></tr><tr><td>  7 </td><td>  G </td></tr><tr><td>  eight </td><td>  H </td></tr></tbody></table><br><p>  A B-tree (B-tree) is built on the basis of the id field, and each node contains a ctid value.  Note: in this case, the order of index entries coincides with the order of entries in the table.  This is due to the autoincrement of the id field, but this is not always the case. </p><br><p>  Secondary indexes look similar.  The main difference is that the records are stored in a different order, since the B-tree must be organized lexicographically.  The index <em>(first, last)</em> begins with the names arranged in alphabetical order: </p><br><table><tbody><tr><td>  <b>first</b> </td><td>  <b>last</b> </td><td>  <b>ctid</b> </td></tr><tr><td>  Ada </td><td>  Lovelace </td><td>  G </td></tr><tr><td>  Alan </td><td>  Turing </td><td>  E </td></tr><tr><td>  Blaise </td><td>  Pascal </td><td>  A </td></tr><tr><td>  Emmy </td><td>  Noether </td><td>  C </td></tr><tr><td>  Gottfried </td><td>  Leibniz </td><td>  B </td></tr><tr><td>  Henri </td><td>  Poincar√© </td><td>  H </td></tr><tr><td>  Muhammad </td><td>  al-KhwƒÅrizmƒ´ </td><td>  D </td></tr><tr><td>  Srinivasa </td><td>  Ramanujan </td><td>  F </td></tr></tbody></table><br><p>  The <em>birth_year</em> index <em>is</em> clustered in ascending order: </p><br><table><tbody><tr><td>  <b>birth_year</b> </td><td>  <b>ctid</b> </td></tr><tr><td>  780 </td><td>  D </td></tr><tr><td>  1623 </td><td>  A </td></tr><tr><td>  1646 </td><td>  B </td></tr><tr><td>  1815 </td><td>  G </td></tr><tr><td>  1854 </td><td>  H </td></tr><tr><td>  1887 </td><td>  F </td></tr><tr><td>  1882 </td><td>  C </td></tr><tr><td>  1912 </td><td>  E </td></tr></tbody></table><br><p>  Unlike the primary index by id, in both secondary indexes the values ‚Äã‚Äãof the ctid field do not lexicographically increase. </p><br><p>  Suppose that you need to update one of the records in the table.  Change al-KhwƒÅrizmƒ´'s year of birth to 770. As we mentioned earlier, string tuples are immutable.  Thus, to update the record, you need to add a new tuple to the table.  It will have a new ctid, let's call it I. Postgres should be able to distinguish the new active tuple I from the old version D. For this, each tuple has a field with the version number and a pointer to the previous tuple (if there is one).  Accordingly, the updated table is as follows: </p><br><img src="https://habrastorage.org/files/b6a/dbf/52b/b6adbf52b080449fad2874f76ad6c37f.png"><br><br><p>  Since we now have two rows with al-KhwƒÅrizmƒ´, the indexes should contain entries for each of them.  For brevity, we omit the index on the primary key and show only the secondary indexes: </p><br><img src="https://habrastorage.org/files/e8c/8e0/d5e/e8c8e0d5ee5b4585858806427a561b6e.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr><br><img src="https://habrastorage.org/files/5ac/559/829/5ac559829abc426e96fcb00291b1b2fa.png"><br><br><p>  The old version is highlighted in red, and the new one - in green.  Under the hood of Postgres, there is another field in which the version of the tuple is stored.  This field allows the DBMS to show transactions only those rows that they should see. </p><br><img src="https://habrastorage.org/files/c75/632/369/c7563236904b4bccbc24c50c21454777.png"><br><p>  <em>In Postgres, the primary and secondary indexes directly indicate the physical displacements of the tuples on the disk.</em>  <em>If you change the location of the line indexes need to be updated.</em> </p><br><h2 id="replikaciya">  Replication </h2><br><p>  If stream replication is configured in Postgres, for example, when inserting a new row into the table, such a change needs to be replicated.  For recovery purposes after failures <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">, a forward-looking write log (WAL)</a> is built into the DBMS, which is used to perform <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit</a> .  The DBMS must maintain WAL even when streaming replication is disabled, since WAL is also needed to comply with the principles of atomicity and durability of the <a href="https://en.wikipedia.org/wiki/ACID">ACID</a> requirements. </p><br><p>  To better understand WAL, consider the case of an unplanned DBMS shutdown, which can occur, for example, during a power outage.  WAL makes all the changes that the DBMS plans to make in the contents of the tables and indexes on the disk.  Postgres daemon compares WAL to disk data after launch.  In the event that there is something in WAL that has not yet been written to disk, the DBMS makes changes, matching the data on the disk and the contents of the proactive write log.  Then the DBMS rolls back those instructions in WAL that refer to uncommitted transactions. </p><br><p>  Postgres streaming replication is implemented by forwarding WAL from the master to replicas that actually work in disaster recovery mode, constantly applying WAL updates just as it would have done if the system was started after an abnormal shutdown.  The only difference in streaming replication from disaster recovery is that replicas work in hot standby mode, handling read requests in parallel with streaming changes, while the Postgres database in recovery mode usually refuses to maintain any requests until the recovery process is complete. </p><br><p>  Since WAL was designed for recovery purposes, low-level information about updating data on disk is written to it.  WAL content is at the level of the actual presentation of tuple data on a disk, including their physical offsets (i.e. ctid values).  If you suspend the master and the replica that is completely synchronized with it, the actual location of the data on the disks of both systems will be identical literal bytes to bytes.  Thus, tools like <a href="https://en.wikipedia.org/wiki/Rsync">rsync</a> can be used to restore replica data if it is far behind the master. </p><br><h2 id="k-chemu-privodyat-osobennosti-dizayna-postgres">  What are the features of Postgres design? </h2><br><p>  Features Postgres led to difficulties and reduced efficiency of working with <a href="https://eng.uber.com/category/uberdata/">data in Uber</a> . </p><br><h3 id="usilenie-zapisi">  Record Gain </h3><br><p>  The first issue with Postgres design is with <a href="https://en.wikipedia.org/wiki/Write_amplification">write enhancement</a> .  Usually, this term is mentioned in connection with the peculiarities of the operation of SSD disks: a logically small update (say, writing a few bytes) becomes a much more serious and resource-intensive operation at the physical level.  A similar problem exists in Postgres.  In our previous example, when we made a logical small update, changing the year of birth of al-KhwƒÅrizmƒ´, physically the system had to perform at least four operations: </p><br><p>  1) write the new tuple into the <a href="https://en.wikipedia.org/wiki/Tablespace">tablespace</a> , <br>  2) update the index on the primary key, adding an entry for the new tuple, <br>  3) update the index (first, last), adding an entry for the new tuple, <br>  4) update the birth_year index, adding an entry for the new tuple </p><br><p>  In fact, these four items reflect only the changes made in the main tablespace (main tablespace), but they also need to be taken into account in WAL, so the total number of write operations is even greater. </p><br><p>  It is worth mentioning points 2 and 3 separately. After we updated the year of birth of al-KhwƒÅrizmƒ´, neither the primary key of the record, nor the meaning of the name and surname changed.  And yet the indices have to be updated, since a new tuple has appeared in the database.  For tables with a large number of secondary indexes, these additional steps can lead to significant write overhead.  For example, for a table with a dozen indexes, updating the field covered by only one index should be extended to the other nine, since it is necessary to write in them the ctid of the new row. </p><br><h3 id="replikaciya-1">  Replication </h3><br><p>  The problem with recording enhancement also affects replication, which is performed at the disk data presentation level.  Instead of transferring a small logical record, such as, for example, ‚ÄúChange the year of birth for ctid D, setting it to 770‚Äù, the DBMS must send all WAL elements relating to the four above-mentioned operations accompanying the record.  Thus, the problem of recording gain goes into the problem of replication gain, and the Postgres replication data stream very quickly becomes so significant that it can take up much of the available network bandwidth. </p><br><p>  In cases where replication is performed within the same datacenter, there will most likely not be a problem with bandwidth.  Modern network equipment can handle large amounts of data, and many hosting providers charge a small fee for transferring data within the data center or provide this service for free.  However, when it is necessary to set up replication between machines in different data centers, problems can begin to grow like a snowball.  For example, Uber first used physical servers in a colocation center on the West Coast.  In case of disaster recovery, we placed several replicas on additional servers on the East Coast. </p><br><p>  Through the use of <a href="http://www.postgresql.org/docs/9.2/static/warm-standby.html">cascade replication,</a> we were able to reduce the amount of data sent between data centers to the values ‚Äã‚Äãnecessary for replication between one master and one replica.  However, postgres replication ‚Äúverbosity‚Äù can still lead to the need to transfer too large volumes if many indices are used.  Buying high-speed data channels connecting different parts of the country is expensive.  But even when money is not a problem, it is simply impossible to get speeds comparable to the local network connections of the datacenters.  This bandwidth problem also makes it difficult to archive WAL.  In addition to sending WAL updates from the West Coast to the East Coast, we archived it in a web-based file storage.  These archives could be used both in case of need for disaster recovery and for the deployment of new replicas.  During peak loads, the bandwidth of the network connection to the file storage was simply not enough to keep up with the WAL updates created during the work with the database. </p><br><h3 id="povrezhdenie-dannyh">  Data corruption </h3><br><p>  During the standard operation to increase database capacity, which used the replica enhancement mechanism, we encountered an error in Postgres 9.2.  Replicas incorrectly handled the timeline switch, with the result that some of them incorrectly applied WAL updates.  Due to this error, some of the entries that should have been deactivated by the versioning mechanism did not receive a corresponding note, that is, they remained active. </p><br><p>  Using the following query, we can illustrate how this error will be reflected in our example with a user table: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><p>  The query will return two entries: the initial string for al-KhwƒÅrizmƒ´ with a birth year equal to 780, as well as a new entry with birth_year = 770. If we add a ctid column to the query, we will get different values ‚Äã‚Äãof these identifiers, as in two different strings. </p><br><p>  This problem turned out to be extremely unpleasant for us for several reasons.  First: it was impossible to say exactly how many lines were affected.  In some cases, duplicates caused the application to malfunction.  As a result, we had to add instructions to the application code to detect such situations.  Secondly, since the error appeared on all servers, each of them spoiled different strings, that is, on one replica, line X could be damaged, and Y was untouched, but on another replica, line X could be in order, and Y - damaged.  In fact, we did not know exactly how many replicas had corrupted data, and whether this problem was manifested on the wizard. </p><br><p>  As far as we understood, only a few lines were usually damaged on the entire base, but still we were extremely concerned, since the indices could be completely corrupted due to the fact that replication is performed on a physical level.  An essential feature of B-trees is the need for their periodic <a href="https://en.wikipedia.org/wiki/B-tree">rebalancing</a> , and this operation can completely change the tree structure, since the subtrees are moved to other places on the disk.  When moving damaged data, significant parts of the tree may be incorrect. </p><br><p>  As a result, we were able to find the error and, having analyzed it, find out that the lines were not damaged on the cue, which was becoming the new master.  By resynchronizing with a fresh snapshot of the wizard, we corrected the data on all replicas.  It was a very laborious process, because at that time we could afford to simultaneously remove only a few replicas from the workload load balancing pool. </p><br><p>  The bug found appeared in some releases of Postgres 9.2 and has been fixed a long time ago.  However, we are very concerned about the fact that such a thing turned out to be possible.  At any time, we can expect the release of a new version of Postgres with a similar error, and due to the nature of the replication mechanism, the problem may spread to all databases in the replication hierarchy. </p><br><h3 id="mvcc-na-replikah">  MVCC on replicas </h3><br><p>  Postgres does not actually support MVCC replicas.  Since WAL updates are applied on replicas, <a href="http://blog.2ndquadrant.com/tradeoffs_in_hot_standby_deplo/">there is a copy of the database</a> on them at any time <a href="http://blog.2ndquadrant.com/tradeoffs_in_hot_standby_deplo/">with the same data on the disk as on the wizard</a> .  For Uber, this is a serious problem. </p><br><p>  To ensure the operation of the MVCC mechanism, the DBMS needs to store old versions of strings.   ,   ,  ,       .    Postgres    WAL   ,     .     ,   ,       .     Postgres   :     WAL   <a href="https://www.postgresql.org/docs/9.2/static/hot-standby.html"> </a> , Postgres  . </p><br><p>   Postgres   ,          .      ,       .        ,  ,           . ,   ,      .             ,     . ,    ,          -,   ,               ,    ORM,    ,       . </p><br><h3 id="obnovlenie-postgres">  Postgres </h3><br><p>      ,      ,    Postgres.   Postgres 9.3         Postgres 9.2;          9.2-  9.3-. </p><br><p>       ,   <a href="https://www.postgresql.org/docs/current/static/pgupgrade.html"> </a> : </p><br><ul><li>  . </li><li>       pg_upgrade.         ,        . </li><li>  . </li><li>   .       ,         . </li><li>         . </li><li>      . ,    ,   ,        . </li></ul><br><p>    Postgres 9.1         9.2.     ,           .   ,   Postgres 9.3,     ,        .      Postgres      9.2,   ,     9.5. </p><br><p>   Postgres  9.4         <a href="http://2ndquadrant.com/en/resources/pglogical/">pglogical</a> ,      Postgres.   pglogical       Postgres,    , ,  9.4  9.5    .        Postgres,      .   ,          Postgres, pglogical   . </p><br><h2 id="arhitektura-mysql">  MySQL </h2><br><p>      Postgres    ,  MySQL    Uber Engineering    , , , Schemaless.    ,  MySQL    .       MySQL     Postgres.      <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">InnoDB</a> , , ,        MySQL. </p><br><h3 id="innodb--predstavlenie-dannyh-na-diske"> InnoDB ‚Äî     </h3><br><p>   Postgres, InnoDB  MVCC    .       ,  InnoDB,     .        Postgres. </p><br><p>       ,  Postgres        ,   InnoDB   ,             ( ctid  Postgres),      .  ,     MySQL     : </p><br><table><tbody><tr><td> <b>first</b> </td><td> <b>last</b> </td><td> <b>id (primary key)</b> </td></tr><tr><td> Ada </td><td> Lovelace </td><td>  7 </td></tr><tr><td>  Alan </td><td> Turing </td><td>  five </td></tr><tr><td> Blaise </td><td> Pascal </td><td>  one </td></tr><tr><td> Emmy </td><td> Noether </td><td>  3 </td></tr><tr><td> Gottfried </td><td> Leibniz </td><td>  2 </td></tr><tr><td> Henri </td><td> Poincar√© </td><td>  eight </td></tr><tr><td> Muhammad </td><td> al-KhwƒÅrizmƒ´ </td><td>  four </td></tr><tr><td> Srinivasa </td><td> Ramanujan </td><td>  6 </td></tr></tbody></table><br><p>      (first, last),    :      ,            . </p><br><p>     InnoDB        Postgres,        . ,    ,       ,     .  InnoDB       .  -     MVCC    , MySQL        <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html">  (rollback segment)</a> . </p><br><p>  ,       al-KhwƒÅrizmƒ´.              id=4 (         ¬´ ¬ª,      birth year ‚Äî   ,      ).    birth year   ¬´ ¬ª,        .        (   (first, last)).      ,       ,     birth_year. , , ,        signup_date, last_login_time  . .,    ,    Postgres    . </p><br><p>         (vacuum)   (compaction). ,  ,   ,     .  :  Postgres     autovacuum     . </p><br><img src="https://habrastorage.org/files/5c7/4e6/840/5c74e68404d94650923c58441274c846.png"><br><p> <em> MySQL    :       , ,   ,       .        .</em> </p><br><h3 id="replikaciya-2">  </h3><br><p> MySQL   <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-formats.html">  </a> : </p><br><ul><li>  statement-based-   SQL- (         : <br> <code>sql UPDATE users SET birth_year=770 WHERE id = 4</code> ). </li><li>  row-based-   . </li><li>   (mixed)     . </li></ul><br><p>          . Statement-based-   ,             .   , row-based-,       WAL  Postgres, ¬´¬ª,           . </p><br><p>  MySQL         ,      .              .     ¬´ timestamp  X  T_1  T_2¬ª.        . </p><br><p>  Postgres   , ,   ,   ¬´  XYZ   8,382,491¬ª.          WAL.    ( , ,  timestamp)      :       .  ,   WAL      .        ,       MySQL    WAL PostgreSQL. </p><br><p>          MVCC  .  MySQL   ,     MVCC-,           . ,  Postgres        ,      ,      ,        MVCC. </p><br><p>    MySQL      ,    .      ,  ,   <a href="https://en.wikipedia.org/wiki/B-tree">B-</a> ,      .  MySQL   ,   SQL-    (   ).        ,      . </p><br><p> ,  MySQL      ,       . MySQL         ,    ,           .      ,            .       MySQL ‚Äî   ,  ,     ,      .          MySQL   . </p><br><h2 id="drugie-preimuschestva-arhitektury-mysql">    MySQL </h2><br><p>         Postgres  MySQL,      .        MySQL       ,  Postgres. </p><br><h3 id="pul-buferov">   </h3><br><p>       -. Postgres       ,           .    Postgres         <a href="https://en.wikipedia.org/wiki/Page_cache">  (page cache)</a> . ,     Postgres  768  ,   <a href="https://en.wikipedia.org/wiki/Resident_set_size">RSS-</a> ,   Postgres,   25 .  ,  700      Linux. </p><br><p>    ,               RSS.      Postgres    <a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek(2)</a>  <a href="http://man7.org/linux/man-pages/man2/read.2.html">read(2)</a> .      ,           .    Postgres        :     <a href="http://man7.org/linux/man-pages/man2/pwrite.2.html">pread(2)</a> ,       (seek + read)    . </p><br><p>     InnoDB   <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BA%25D1%258D%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">LRU</a>   <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html">  (buffer pool)</a> InnoDB.       Linux,      .          Postgres,   InnoDB   : </p><br><ol><li>     LRU. ,        ,     ,        . </li><li>    .        InnoDB     ‚Äî.       <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2583%25D1%2584%25D0%25B5%25D1%2580_%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D1%2586%25D0%25B8%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D0%25B8"> TLB</a> , , ,         <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages</a> . </li></ol><br><h3 id="upravlenie-soedineniyami">   </h3><br><p>  MySQL       (thread).       :        ,       .   ,   MySQL   10 000  .     MySQL       . </p><br><p>  Postgres      .         .       ,     .  , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B2%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D0%25B8%25D0%25B5">IPC</a>      ,   . Postgres 9.2   <a href="http://man7.org/linux/man-pages/man7/svipc.7.html">System V IPC</a>   <a href="http://man7.org/linux/man-pages/man2/futex.2.html"> (futexes)</a> ,     ,    ,     ,     . </p><br><p>   , ,  Postgres        .    ,      ,       Postgres       . <a href="https://wiki.postgresql.org/wiki/Number_Of_Database_Connections">  (       )</a>      (connection pooler)     .        <a href="https://pgbouncer.github.io/">pgbouncer</a> .    ,         (   ‚Äúidle in transaction‚Äù),   .        . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> Postgres        Uber,            ,    .           Postgres,         MySQL (     <a href="https://eng.uber.com/schemaless-part-one/">Schemaless</a> ),       NoSQL-,   Cassandra.      MySQL                  Uber. </p><br><hr><br><p> <em>Evan Klitzke   <a href="https://www.uber.com/careers/list/%3Fcity%3Dall%26country%3Dall%26keywords%3Dsoftware%2Bengineer%26subteam%3Dall%26team%3Dengineering"> ()   </a>     <a href="https://people.uber.com/eng/">Uber Engineering</a> .      <a href="https://eng.uber.com/tag/database/"> </a> ,   Uber    2012.</em> </p></div><p>Source: <a href="https://habr.com/ru/post/322624/">https://habr.com/ru/post/322624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322614/index.html">Overview of automated paid parking systems</a></li>
<li><a href="../322616/index.html">Setting up DKIM / SPF / DMARC records or defending against spoofing</a></li>
<li><a href="../322618/index.html">Visualization of JavaScript exchange sorting algorithms</a></li>
<li><a href="../322620/index.html">Moving to Yandex ClickHouse</a></li>
<li><a href="../322622/index.html">Linus Torvals spoke about the SHA-1 collisions in the Git repositories: there is nothing to fear</a></li>
<li><a href="../322626/index.html">Open machine learning course. Topic 1. Primary data analysis with Pandas</a></li>
<li><a href="../322634/index.html">Free IP Camera Software</a></li>
<li><a href="../322636/index.html">Experiment: looking for int i = 0xDEADBEEF in a physical memory dump</a></li>
<li><a href="../322642/index.html">Pygest # 4. Releases, articles, interesting projects from the world of Python [February 14, 2017 - February 27, 2017]</a></li>
<li><a href="../322646/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ251 (February 20 - 26, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>