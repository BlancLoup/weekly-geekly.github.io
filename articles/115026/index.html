<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RMQ Task - 2. Segment Tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of our topic, we looked at the solution of the static RMQ problem for (O (nlogn), O (1)). Now we will deal with a data structure cal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RMQ Task - 2. Segment Tree</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/algorithm/114980/">first part of</a> our topic, we looked at the solution of the static RMQ problem for (O (nlogn), O (1)).  Now we will deal with a data structure called a segment tree, or intervals (in English literature, a segment tree or interval tree).  With it, you can solve dynamic RMQ for (O (n), O (logn)). <br><br><h4>  Definition </h4><br><br>  We introduce the concept of a tree of segments.  For convenience, we add the length of the array to the power of two.  We add infinities to the added array elements (beyond infinity we should understand, for example, a number, more than which nothing will appear in the data).  So, the segment tree is a binary tree, at each vertex of which the value of a given function is written on a certain segment.  The function in our case is the minimum. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each sheet will correspond to an array element with a number equal to the ordinal number of the sheet in the tree.  And to each vertex that is not a leaf, there will be a segment of the array elements corresponding to the descendants of this vertex. <br><br><a name="habracut"></a><br><br>  Behind the seemingly monstrous definition is a quite simple concept - we look at the drawing. <br><br><img src="https://habrastorage.org/storage/272835a6/daa8fe10/a235dee8/5048437e.png"><br><br>  Explain the definition.  The marked vertex will correspond to the marked segment, because it is the union of all the descendant sheets of the vertex (from this moment we identify the leaf and the array element that it represents). <br><br>  Keep the tree will be like a binary heap.  Let's get an array of T [2n - 1].  The root will lie in the first element of the array, and the sons of the i-th vertex will lie in the elements with numbers 2i and 2i + 1 - left and right, respectively.  Immediately you can notice the obvious property: T [i] = min (T [2i], T [2i + 1]) for the i-th vertex, which is not a leaf.  Sheets, by the way, will lie with this numbering in the elements with numbers from n to 2n - 1. <br><br><h4>  Building </h4><br><br>  We construct a tree, running along the elements from (n - 1) through the first, counting the minimum values ‚Äã‚Äãin the sons for each vertex. <br>  Beginning with this article I will give the code for greater clarity. <br><br><pre><code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">int</span></span> INF = INT_MAX; <span class="hljs-type"><span class="hljs-type">void</span></span> build_tree(const vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;&amp; V) { // ,     <span class="hljs-type"><span class="hljs-type">int</span></span> n = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (log(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)); V.resize(<span class="hljs-number"><span class="hljs-number">2</span></span> * n, INF); //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = n; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n; i++) V[i] = V[i - n]; //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; i<span class="hljs-comment"><span class="hljs-comment">--) V[i] = min(V[2 * i], V[2 * i + 1]); }</span></span></code> </pre> <br><br>  The build_tree (V) function turns an array V into a segment tree for this array.  So, now how to find a minimum on it on a segment?  To do this, we introduce the concept of a fundamental segment. <br><br><h4>  Minimum request </h4><br><br>  A fundamental segment in an array is such a segment that there exists a vertex in the tree to which it corresponds.  We divide our segment into a minimal number of non-intersecting fundamental ones.  We show that at each level their number does not exceed 2. <br><br><img src="https://habrastorage.org/storage/48a3cfe9/b8b9862d/8362bfeb/c72f89ec.png"><br><br>  Take the largest fundamental segment in the partition.  Let its length be 2t.  Note that the fundamental segments of length 2t are no more than two (1).  Take the leftmost of the maximum available fundamental.  We will move from it to the left.  Note, again, that the lengths of the segments will decrease (2).  Also with the right of the maximum.  Thus, we obtain that the fundamental segments are at most 2t, which does not exceed 2logn.  Clauses (1) and (2) in the proof I leave for self-reflection. <br><br>  How does this help us?  Now we can implement the minimum request ‚Äúfrom below‚Äù.  We will rise from below, adding to the answer at each level, if necessary, a fundamental segment. <br><br>  Let's get two pointers - l and r, with which we will find the next fundamental segments of the partition.  Initially, we set l and r pointing to the sheets corresponding to the ends of the query segment.  Note that if l points to a vertex that is the right son of its parent, then this vertex belongs to the division into fundamental segments, otherwise it does not belong.  Similarly, with the pointer r - if it points to the vertex, which is the left son of its parent, then we add it to the partition.  After that, move both pointers to a higher level and repeat the operation.  We continue operations until the pointers enter one by one. <br><br>  Finding another fundamental segment, we compare the minimum on it with the current minimum found and reduce it if necessary.  The asymptotic behavior of the algorithm is O (logn), since at each level we perform a constant number of operations, and the entire levels we perform logn. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> rmq_up(vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;&amp; T, <span class="hljs-type"><span class="hljs-type">int</span></span> l, <span class="hljs-type"><span class="hljs-type">int</span></span> r) { <span class="hljs-type"><span class="hljs-type">int</span></span> ans = INF; <span class="hljs-type"><span class="hljs-type">int</span></span> n = T.size() / <span class="hljs-number"><span class="hljs-number">2</span></span>; l += n - <span class="hljs-number"><span class="hljs-number">1</span></span>, r += n - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt;= r) { //  l -    , //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) ans = min(ans, T[l]); //  r -    , //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(r &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) ans = min(ans, T[r]); //      l = (l + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>, r = (r - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans; }</code> </pre><br><br><h4>  Modification </h4><br><br>  Now let's learn how to change the value of a tree item.  Note that for each leaf there is exactly logn of fundamental segments that contain it ‚Äî they all correspond to vertices lying on the path from our leaf to the root. <br><br><img src="http://habrastorage.org/storage/747ec67b/293eb7cb/5b3c12ac/71e659ec.png"><br><br>  Therefore, when changing an element, it is enough just to run from its sheet to the root and update the value at all vertices on the path by the formula T [i] = min (T [2i], T [2i + 1]). <br><br><pre> <code class="hljs matlab">void update(vector&lt;int&gt;&amp; T, int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, int x) { int n = T.<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>() / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> += n ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; T[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = x; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> /= <span class="hljs-number"><span class="hljs-number">2</span></span>) T[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(T[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], T[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre><br><br>  Hooray!  We obtain the solution of the Dynamic RMQ problem for (O (n), O (logn)). <br><br>  In the next article we will learn how to make a request from above.  Despite the fact that the asymptotics of the query from above will be the same, it has one big bun - the ability to easily and naturally tighten the modification on the segment.  See you again! <br><br></div><p>Source: <a href="https://habr.com/ru/post/115026/">https://habr.com/ru/post/115026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115020/index.html">VLC as a Windows service</a></li>
<li><a href="../115021/index.html">Running javascript in a C # program</a></li>
<li><a href="../115022/index.html">Android Development Tutorial. Part 1/?</a></li>
<li><a href="../115023/index.html">Google, unite!</a></li>
<li><a href="../115024/index.html">Patch intrusive warning "Press Esc for ..." in Flash Player version 10.2.152.32</a></li>
<li><a href="../115027/index.html">Mobile Firefox 4 beta 5</a></li>
<li><a href="../115029/index.html">We translate mobile Firefox in fullscreen mode for Android</a></li>
<li><a href="../115030/index.html">Making a greeting card on March 8 in HTML5 and EaselJS</a></li>
<li><a href="../115031/index.html">Realization of this 3D effect in your projects</a></li>
<li><a href="../115034/index.html">Adult game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>