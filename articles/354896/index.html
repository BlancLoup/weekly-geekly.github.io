<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 1: "Introduction: threat models", part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 1: "Introduction: threat models", part 3</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <a name="habracut"></a><br><br>  Run this program with a debugger.  You will get acquainted with this in detail in the first laboratory work.  And now we will try to set a breakpoint in this redirection function, run the program and see what we have done. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/wd/dx/e5/wddxe5te_krxjx77czqayp2psqq.jpeg"><br><br>  So, I started the program, it began to perform the main function, and the redirection happens rather quickly.  Now the debugger is stopped at the beginning of the redirect.  We can see what is happening here, for example, we can ask to show us the current CPU registers.  Here we are going to look at the lower level, not the source code level C. We are going to look at these instructions executed by my machine to see what is really going on.  The C language can really hide something from us, so we ask you to show us all the registers. <br><br>  In 32-bit systems (x86), as you remember, there is a pointer to the stack frame - the EBP register (stack-frame Base Pointer, pointer to the stack frame).  And my program, not surprisingly, also has a stack. <br><br><img src="https://habrastorage.org/webt/kg/n6/qw/kgn6qwkqbmiahzlbomgehiyxf_m.jpeg"><br><br>  On x86, the stack grows down, this is such a stack, as shown on the slide, and we can continue to stuff our data into it.  Currently, the stack pointer points to the specific memory location ffffd010 (the ESP register, the address of the top of the stack).  There is some value here.  How did it get there?  One way to understand this is to parse the code for the redirection function. <br><br><img src="https://habrastorage.org/webt/7p/qo/oj/7pqoojxuvxrzl2u-8zfzwvexfhy.jpeg"><br><br>  The variable Convenience must have an integer value.  So we can sort the function by name.  Here you can see what this function does.  First of all, it starts to perform some actions with the EBP register, this is not very interesting.  But then it subtracts a certain value from the stack pointer.  This essentially creates space for all variable parameters, such as a buffer and an integer, we saw this in the source code C. <br>  Now we want to understand the work of this function.  The value of the stack pointer, which we saw earlier, is already in the middle of the stack, and above it is information about what is being done in the buffer, what is the integer value and also the return address to the main function, which is implemented in the stack.  So somewhere here we must have a return address.  Now we are just trying to figure out where different things are on the stack. <br><br>  We can give the command to print the address of this buffer variable. <br><br><img src="https://habrastorage.org/webt/d9/jr/ki/d9jrkihfsbmcru9xuc-ebcvm7kq.jpeg"><br><br>  Her address is ffffd02c.  Now let's display the address of the integer value i - it looks like this: ffffd0ac.  Thus, the integer is located above the stack, and the buffer below. <br><br>  That is, we see that our buffer is located on the stack at this place, there is an integer on top, and possibly some other things, and at the very end is the return address to the main function, which is called ‚Äúredirection‚Äù. <br><br><img src="https://habrastorage.org/webt/_9/ix/bk/_9ixbkpqxslplyi6otyfppktxba.jpeg"><br><br>  We see that the stack grows down because there are things with higher ‚Äúhigh‚Äù addresses above it.  Inside our buffer, the elements will be as follows: [0] below, and further upwards, ascending to element [128], as I drew on the board. <br><br>  Let's see what happens if we enter the same data that led to the crash of the system.  But before that, we need to determine exactly where our return address is, how it relates to the ebp pointer. <br><br>  In x86, there is a handy thing, called Convention, which makes the EBP pointer, or register, indicating something happening in the running stack be flagged as "saved EBP register" (saved EBP).  This is a separate register, located after all variables, but before the return address, as shown in this figure. <br><br><img src="https://habrastorage.org/webt/49/j_/9k/49j_9kn5nbgqzcr6rkru_3pgjqq.jpeg"><br><br>  It is stored according to several instructions above.  Examine what is saved EBP. <br><br>  In the GDB (GNU Debugger) debugger, you can explore some variable X, for example, the EBP pointer variable. <br><br><img src="https://habrastorage.org/webt/fg/gs/h4/fggsh4gn6xs1jm6nkuwtwhurbxg.jpeg"><br><br>  Here is his stack position - ffffd0b8.  Indeed, it is located higher than our variable i (register edi).  It is perfectly. <br><br>  And it has some other value that EBP takes before the function is called, and above is another memory location, which will be the return address.  If we print ebp + 4, it will show us the contents of the stack 0x08048E5F.  Let's see what this indicates. <br><br>  This is what you have to do in the laboratory.  So you can take this address and try to parse it.  What is it like and where does it end?  Thus, GDB really helps to figure out which function contains this address. <br><br><img src="https://habrastorage.org/webt/dq/y0/zj/dqy0zjjjimh9ns1bsgws_hswe_0.jpeg"><br><br>  What is 5f?  This is what the return address indicates.  As you can see, this instruction follows immediately after calling the &lt;read_req&gt; redirect.  Therefore, when we return from the redirection, this is the place where we go and from where we continue to perform the function. <br><br>  So where are we now?  To summarize, we can try to disassemble our instruction pointer.  Enter ‚Äúdisass $ eip‚Äù. <br><br><img src="https://habrastorage.org/webt/ia/kr/0e/iakr0eudy9k624ctvxagz_ezpt0.jpeg"><br><br>  Now we are at the very beginning of the redirection.  Let's try to run the get () function and enter the ‚Äúnext‚Äù command.  And then we print our unimaginable amount, which caused the program to stop - AAA ... And, to see what happens. <br><br><img src="https://habrastorage.org/webt/rs/ly/fg/rslyfg_vdmjgb72l98wp3mjpakq.jpeg"><br><br>  So we did get (), but the program still works.  Now we will find out what is happening in the memory at the moment and why everything will become bad afterwards <br><br>  What do you guys think is happening now?  I typed a sequence of characters A. What did the get () command do to the memory?  She placed this sequence on a stack of memory, which, if you remember, contains elements from [0] to [128].  And this sequence A began to fill it from the bottom up, this is how I drew, in the direction of the arrow. <br><br><img src="https://habrastorage.org/webt/iw/x9/yy/iwx9yyvvrqfo_gdclqc5dij3psa.jpeg"><br><br>  But we had only one pointer ‚Äî the beginning of the address, that is, we indicated where to start in the buffer from A. But get () does not know the length of the stack, so it just continues to fill the memory with our data, redistributing them up the stack, possibly bypassing the return address and everything above our stack.  So I type a command to count repeats A and get the value "180", which exceeds our value "128". <br><br><img src="https://habrastorage.org/webt/_w/3w/kt/_w3wktgzlmxpeg3hb2sv_rictci.jpeg"><br><br>  This is not so good.  We can again check what is happening with our EBP index, for this I am typing $ ebp.  We get the address 41414141. <br><br><img src="https://habrastorage.org/webt/yo/jf/sz/yojfszs2pm2qk1_ugwblpng1org.jpeg"><br><br>  Great, then I type "show the location of the return address $ ebp + 4" and get the same address 41414141. <br><br><img src="https://habrastorage.org/webt/at/j8/ld/atj8ldluyp0uwek6ck6tfh2omcq.jpeg"><br><br>  This is not good at all.  This shows what will happen if the program returns here after the redirection, that is, it jumps to the register with the address 41414141. And there is nothing there!  And she will stop.  That is, we got a segmentation error. <br><br>  So let's just come here and see what happens.  Type ‚Äúnext‚Äù and run the program further. <br><br><img src="https://habrastorage.org/webt/ou/we/ua/ouweuamn4ogrh8nbhtjxjnyaxmo.jpeg"><br><br>  Now we are approaching the end of the function and can step over another 2 instructions.  Recruit nexti again. <br><br><img src="https://habrastorage.org/webt/0a/yz/wj/0ayzwjibo3ddnqgmaomktoilbja.jpeg"><br><br>  You can see that at the end of the function there is an ‚Äúleave‚Äù instruction that restores the stack to where it was.  She seems to be ‚Äúpushing‚Äù the stack pointer all the time back to the return address using the same EBP, which is what she basically needs.  And now the stack points to the return address we are going to use.  In fact, these are all our A characters. And if we run another instruction, the processor will go to this particular address 41414141, start executing the code there and ‚Äúcrash‚Äù because it is an invalid address in the page table. <br><br><img src="https://habrastorage.org/webt/h7/qk/nr/h7qknr0cgftsbowwzzpcauwwu08.jpeg"><br><br>  Let's check what happens there.  Once again, we print the contents of our buffer and make sure that it is completely filled with 128 A characters. <br><br><img src="https://habrastorage.org/webt/1b/i0/jb/1bi0jb5sbs2mznkodpihdvw0nkq.jpeg"><br><br>  If you remember, we have entered 180 ‚ÄúA‚Äù elements into the buffer.  So something else happens after the buffer overflow has occurred.  If you remember, we have converted A to integer i in the integer register.  And if we have only alphabetic characters A, without any numbers, then 0 is written into the memory location, since the letter cannot be represented as an integer.  And 0, as is known, in C language means the end of a line.  Thus, GDB thinks that we have a beautiful, complete string of 128 characters A. <br><br><img src="https://habrastorage.org/webt/kt/h_/-t/kth_-tuzrywq6zr3sbho-h_5ego.jpeg"><br><br>  But it doesn‚Äôt really matter, because we still have all these A's at the top, which have already damaged the stack. <br><br>  Well, that was a really important lesson.  It is necessary to take into account that there is another code that will be executed after you managed to overflow the buffer and cause memory corruption.  You must make sure that this code does not do anything stupid, for example, does not try to convert the letter A characters into integer values ‚Äã‚Äãi.  So, it should provide that if a non-numerical value is detected, in our case it is A, we will not be able to skip to the address 41414141. Thus, in some cases you must limit the input data.  Perhaps this is not very important in this case, but in other situations you need to be careful with the type of input data, that is, specify what kind of data ‚Äî numeric or alphabetic ‚Äî the program should handle. <br><br>  Now we will see what happens next and jump again.  Look at our register.  Right now, EIP, a kind of instruction pointer, points to the last redirect address &lt;read_req + 44&gt;.  If we take another step, we will finally move on to our unfortunate 41414141. <br><br><img src="https://habrastorage.org/webt/cg/pj/2c/cgpj2cwilnme5grdxr_vawt-6fw.jpeg"><br><br>  Indeed, the program follows our instructions, and if we ask GDB to print the current set of registers, then the current position indicator will be a strange value.  Let's try to execute one more instruction and finally, we get a program crash. <br><br><img src="https://habrastorage.org/webt/9y/7l/si/9y7lsixxcvmyvlbmw3xp6asdmps.jpeg"><br><br>  This happened because the program attempted to follow an instruction pointer that does not correspond to a valid page for this process in the operating system's page table.  It's clear? <br><br>  Great, I have a question for you.  So what is our problem after all? <br><br>  Audience: you can do whatever you want with this program! <br><br>  That's right!  Although, in fact, it was rather stupid to enter such a huge number of these A. But if you knew well where to put these values, you could put other values ‚Äã‚Äãthere and go to some other address.  Let's see if we can do this. <br><br>  Stop our program, restart it and re-enter many A characters to overflow the buffer.  But I'm not going to figure out which one is on the stack.  But suppose I fill the stack at this point and then try to manually change things in the stack so that the function jumps to the place I need.  Therefore, I introduce again NEXTI. <br><br><img src="https://habrastorage.org/webt/js/kh/w1/jskhw1cs98slsrq3niwjm7bx3wm.jpeg"><br><br>  Where are we?  We are again at the very end of the redirection.  Let's take a look at our stack. <br><br><img src="https://habrastorage.org/webt/mn/g1/qh/mng1qhqy_osbtcc49sij244ndie.jpeg"><br><br>  If we examine ESP, we will see our broken pointer.  Good.  Where could we jump from here?  What could we do interesting?  Unfortunately, this program is very limited.  There is nothing in her code that would help us jump and do something interesting, but we will still try.  Perhaps we will be able to find the PRINTF function, jump over there and make it print some value, or an equivalent value X. We can disassemble the main function - disass main. <br><br><img src="https://habrastorage.org/webt/wa/pw/cj/wapwcjpnvtbpmncr3v6_eu5feki.jpeg"><br><br>  And the main function does a whole bunch of things ‚Äî initiation, call forwarding, a lot more, and then calling PRINTF.  So how about jumping to this point - &lt;+26&gt;, which sets the argument for PRINTF equal to% eax in register &lt;+22&gt;?  Thus, we will be able to take the value in the register &lt;+26&gt; and ‚Äúpaste‚Äù it to this stack.  This should be fairly easy to do with the debugger; you can make this set {int} esp equal to this value. <br><br>  You can check ESP again, and indeed, it has that value. <br><br><img src="https://habrastorage.org/webt/fs/9z/b7/fs9zb7hm1jofwnjtf-dyxha2f6o.jpeg"><br><br>  We will continue with the help of the ‚ÄúC‚Äù command, and we will see that the function has printed out X equal to some kind of nonsense, and I think it happened because of the contents of this stack, which we tried to print.  We incorrectly set up all the arguments because we jumped into the middle of this calling sequence (the sequence of commands and data needed to call this procedure). <br><br><img src="https://habrastorage.org/webt/u0/oa/ix/u0oaixv2awhcn3sylfxgd-h0bqm.jpeg"><br><br>  Yes, we typed this value, and after that the system failed.  Why did this happen?  We jumped to the PRINTF function, and then something went wrong.  We changed the return address, so when we returned from the redirection, we move to this new address, at the same point immediately after PRINTF.  So where did this crash come from? <br><br>  Audience: due to the return of the main function! <br><br>  That's right!  This is what happens - this is the point where we jumped in the register &lt;+26&gt;.  It sets some parameters and calls PRINTF.  PRINTF is operational and ready to return.  So far, so good, because this call instruction "puts" the return address on the stack so that this address is used by the PRINTF function. <br><br><img src="https://habrastorage.org/webt/3l/lb/nj/3llbnjodzcn_ijeyki1hotfhxtm.jpeg"><br><br>  The main function continues to work, it is ready to run the LEAVE instruction, which is not anything interesting, and then make another ‚Äúreturn‚Äù in the &lt;+39&gt; register.  But the fact is that in this stack there is no correct return address.  Therefore, presumably, we return to someone else who knows the location of the memory above the stack, and jump somewhere else.  So, unfortunately, our pseudo-attacks do not work here.  Some other code is running here.  But then he "crashes."  This is probably not what we wanted to do. <br><br>  So if you really want to be careful, you must not only carefully place the return address on the stack, but also find out from whom the second RET will receive its return address.  Then you need to try to carefully push something else onto the stack to be sure that your program ‚Äúcleanly‚Äù continues to run after it has been hacked, and so that no one will notice this interference. <br><br>  This is all you try to do in laboratory work number 1, only in more detail. <br><br>  There is one more thing that we should think about now - about the stack architecture in case of buffer overflow.  In this case, our problem is that the return address is located at the top, right?  The buffer continues to grow and, eventually, overlaps the return address.  But what if we turn the stack ‚Äúdown finished‚Äù?  You know, some machines have stacks that grow upwards.  So we could imagine an alternative design where the stack starts from the bottom and continues to grow up, not down.  So if you overflow such a buffer, you just keep going up the stack, and in this case nothing bad happens. <br><br>  Now I will draw you to explain how it looks.  Let the return address is here at the bottom of the stack.  Above are our variables, or saved EBP, then integer variables, and at the very top is a buffer from [0] to [128].  If we make an overflow, it goes up this arrow. <br><br><img src="https://habrastorage.org/webt/af/qs/6t/afqs6tjgyq14xzze19ngdl_h7z0.jpeg"><br><br>  Thus, a buffer overflow will not affect the return address.  What do we need to do in our program to implement this version of work?  Right, make the redirect!  Place a stack frame on the left that performs this redirection and redirect the function call to the top.  As a result, our scheme will look like this: at the top on the stack is the return address, then the saved EBP, and all the other variables will be located on top of it.  And then we start overflowing the buffer with the get (S) command. <br><br><img src="https://habrastorage.org/webt/zz/vd/fj/zzvdfj56aecvd_hbqgt4-ab44de.jpeg"><br><br>  So, the work function is still problematic.  Basically, because the buffer is surrounded by return functions from all sides, and in any case you can overflow something.  Suppose our machine has a stack growing upwards.  Then at what point can you take control of the program? <br><br>  In fact, in some cases it is even easier.  You do not need to wait for the redirect to return.  Perhaps there were even things like turning A into i.  In fact, this is easier because the get (S) command overflows the buffer.  This will change the return address, and then immediately come back and jump to where you tried to create a certain structure. <br><br>  What happens if we have such a rather boring program for all sorts of experiments?  It does not seem to contain an interesting code for the jump.  All you can do is type here, in PRINTF, another value of X. <br><br><img src="https://habrastorage.org/webt/zq/yf/go/zqyfgodyx-c12fnqop5yeiafpfy.jpeg"><br><br>  Let's try! <br><br>  Audience: if you have an extra stack, can you put an arbitrary code that, for example, executes a program shell? <br><br>  Yes, yes, yes, it is really reasonable, because then you can support other ‚Äúinput‚Äù values.  But here there is some protection against this, you will learn about it in the next lectures.  But in principle, you could have a return address here that overlaps on both types of machines ‚Äî with stacks up and with stacks down.  And instead of specifying it in the existing code, for example PRINTF in the main function, we could have a return address in the buffer, since this is just some location in the buffer.  But you can "jump" there and consider it an executable parameter. <br><br><img src="https://habrastorage.org/webt/l5/fm/tf/l5fmtfstffu00mmqshlfbvpva-i.jpeg"><br><br>  As part of your request, you send a few bytes of data to the server, and then get the return address or thing that you placed in this buffer location, and you will continue the execution of the program from this point. <br><br>      ,   ,        .  ,   Unix     ‚Äì        BIN SH,       ,   .    ,   ,     ,       ¬´ ¬ª, shell code.          . <br><br><img src="https://habrastorage.org/webt/jk/oy/5x/jkoy5xgdrjgtuyrrx18fczvhopc.jpeg"><br><br> :        ? <br><br>   ,          ,       :    ,   ‚Äì ,     ,    .          ,     ,     ,      .  ,   32-  64-  ,  ,     .       ,        .               . <br><br>      -       ,   ,   ,     .           ,       . <br><br>       ,       ?        ,    ¬´¬ª    .  ,            . ,       ,          .       ,     PRINT X,   . <br><br>              ,    ,     .    ¬´return to lib c¬ª ‚Äî    ,    .           ,          .     .  ,        ,       ,  ,   ,        .     , ,      ,       getS(),       . <br><br>     ,      ,       .         ,         . ,    ,             -  ,    .   2-      .   ,       . <br> :         ? <br><br> ,     ,    2 . <br><br> ,  .        ?      ‚Äì     .   ,           ,     .       ,      -. <br><br>          ,        ,       .        . <br><br>    ,    ,     ,        .            ,      ,     - . <br><br>   ,             . <br><br>  To be continued‚Ä¶ <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GqmQg-cszw4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/"></a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/354896/">https://habr.com/ru/post/354896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354886/index.html">ReactiveValidation: data validation in WPF</a></li>
<li><a href="../354888/index.html">Practice implementing Cisco ISE. Engineer's look</a></li>
<li><a href="../354890/index.html">We optimize the web with Vitaly Friedman, - compression, images, fonts, HTTP / 2 features and Resource Hints</a></li>
<li><a href="../354892/index.html">Commenting code: good, bad, evil</a></li>
<li><a href="../354894/index.html">MIT course "Computer Systems Security". Lecture 1: "Introduction: threat models", part 2</a></li>
<li><a href="../354898/index.html">Fractal manifold method in Data Science problems</a></li>
<li><a href="../354902/index.html">As I wrote a graphic bot and what it turned into</a></li>
<li><a href="../354906/index.html">Distribution of programs on Go. Part 1</a></li>
<li><a href="../354910/index.html">By the Day of Radio. Oh connection, you are the world</a></li>
<li><a href="../354912/index.html">PyTorch Tour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>