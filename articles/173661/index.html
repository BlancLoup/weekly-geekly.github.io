<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows Azure Storage - Architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear colleagues! 

 WAS is a cloud storage system that provides customers with the ability to store virtually unlimited amounts of dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows Azure Storage - Architecture</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear colleagues! <br><br>  WAS is a cloud storage system that provides customers with the ability to store virtually unlimited amounts of data for any period of time.  WAS was introduced in the production version in November 2008. Previously, it was used for internal Microsoft purposes for applications such as storing video, music and games, storing medical records, etc. The article is based on the principles of working with storage services and is devoted to the principles work of these services. <br><br><a name="habracut"></a><br>  WAS customers have access to their data from anywhere at any time and only pay for what they use and store.  Data stored in WAS uses both local and geographic replication to realize recovery from serious failures.  At the moment, the WAS repository consists of three abstractions - blobs (files), tables (structured storage) and queues (message delivery).  These three data abstractions cover the need for different types of stored data for most applications.  The usual use case is to save data in blobs, while using queues, data is transferred to these blobs, while intermediate data, status, and similar temporary data are stored in tables or blobs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During the development of WAS, the wishes of customers were taken into account, and the most significant characteristics of the architecture were: <br><ul><li>  <b>Strong consistency</b> - a lot of customers want to have strict consistency, especially for corporate customers, transferring infrastructure to the cloud.  They also want to be able to perform read, write, and delete operations according to certain conditions for optimistic control over strictly consistent data ‚Äî for this, Windows Azure Storage provides what the CAP theorem (Consistency, Availability, Partition-tolerance) describes as difficult to achieve in one moment Time: strict consistency, high availability and Partition Tolerance. </li><li>  <b>Global and highly scalable namespaces</b> - to simplify the use of storage in WAS, a global namespace has been implemented, which allows you to store and access data from anywhere in the world.  Since one of the main goals of WAS is to provide the ability to store large amounts of data, this global namespace must be able to address exabytes of data. </li><li>  <b>Disaster recovery</b> - WAS stores customer data in several data centers that are located several hundred kilometers apart, and this redundancy provides effective protection against data loss due to various situations, such as earthquakes, fires, tornadoes, and so on. </li><li>  <b>Multi-tenancy and storage costs</b> ‚Äî to reduce storage costs, many clients are served from the same shared storage infrastructure, and WAS using this model, when the storages of many different customers with different storage volumes they need are grouped in one place, significantly reducing the total required storage capacity than if WAS allocated separate equipment to each client. </li></ul><br>  Let's take a closer look at the global partitions namespace.  The key goal of the Windows Azure storage system is to provide one global namespace that would allow customers to place and scale any amount of data in the cloud.  To provide a global namespace, WAS uses DNS as part of the namespace, and the namespace consists of three parts: the name of the storage account, the name of the partition, and the name of the object. <br><br>  Example: <br>  http (s): //AccountName..core.windows.net/PartitionName/ObjectName <br><br>  <b>AccountName</b> ‚Äî The storage account name selected by the client is part of the DNS name.  This part is used to find the main storage cluster and, in fact, the data center where the necessary data is stored and where all requests for data for this account should be sent.  A client in one application can use several account names and store data in completely different places. <br>  <b>PartitionName</b> - the name of the partition, which determines the location of the data when a storage cluster receives a request.  PartitionName is used to vertically scale data access across multiple storage nodes depending on traffic. <br>  <b>ObjectName</b> - if there is a set of objects in the partition, ObjectName is used to uniquely identify an object.  The system supports atomic transactions for objects within the same PartitionName.  The ObjectName value is optional; for some data types, PartitionName can uniquely identify an object within an account. <br>  In WAS, you can use the blob's full blob name as PartitionName for blobs.  In the case of tables, it is necessary to take into account that each entity in the table has a primary key consisting of PartitionName and ObjectName, which allows grouping entities into one partition to perform an atomic transaction.  For queues, PartitionName is the value of the name of the queue, but each message placed in the queue has its own ObjectName, which uniquely identifies the message within the queue. <br><br><h5>  WAS architecture </h5><br><br>  <b>The fabric controller</b> manages, monitors, provides fault tolerance and many other tasks in the data center.  This is a mechanism that knows about everything that happens in the system, starting from the network connection and ending with the state of the operating systems on the virtual machines.  The controller constantly communicates with its own agents installed on operating systems and sending full information about what is happening with this operating system, including OS version, service configuration, configuration packages, and so on.  For storage, the Fabric Controller allocates resources and manages the replication and distribution of data across disks, as well as load and traffic balancing.  The architecture of Windows Azure Storage is presented in Figure 1. <br><br><img src="https://habrastorage.org/storage2/a6f/b05/8ce/a6fb058ce42eb53d06c36d7200acdd60.png"><br>  Fig.  1. Windows Azure Storage Architecture <br><br>  <b>Storage Stamp (SS).</b>  This term refers to a cluster consisting of N rivers (rack) of storage nodes, where each river is in its own error domain with excess network and power supply.  Clusters typically have from 10 to 20 rivers with 18 nodes on the rivers, with the first generation of Storage Stamps containing about 2 petabytes.  The following is up to 30 petabytes.  Storage Stamp also try to make the most used, that is, the percentage of each SS should be equal to about 70 in terms of capacity use, number of transactions and bandwidth, but not more than 80, as there should be a reserve for more efficient disk operations.  As soon as the use of SS reaches 70%, the Location Service migrates accounts to other SSs using inter-SS replication. <br>  <b>Location Service (LS).</b>  This service manages all SS and namespaces for accounts for all SS.  LS distributes accounts by SS and implements load balancing and other management tasks.  The very same service is distributed in two geographically separated locations for their own security. <br>  <b>Stream Layer (SL).</b>  This layer stores data on disk and is responsible for distributing and replicating data across servers to store data within the SS.  SL can be viewed as a distributed file system layer within each SS that understands files (‚Äústreams‚Äù), how to store these files, replicate, and so on.  Data is stored on SL, but available with Partition Layer.  SL provides, in essence, some interface used only by PL, and a file system with an API that allows you to perform only Append-Only write operations, which allows PL to open, close, delete, rename, read, add parts and merge large files. ‚Äù streams ‚Äù, ordered lists of large pieces of data, called‚Äú extents ‚Äù(Fig. 2). <br><br><img src="https://habrastorage.org/storage2/b25/454/a08/b25454a0898bebd7cd7725cfa543361f.png"><br>  Fig.  2. Visual image of extents Stream <br><br>  A stream can contain multiple pointers to extents, and each extent contains a set of blocks.  In this case, the extents can be sealed (sealed), that is, you cannot add new data pieces to them.  If attempts are made to read data from the Stream, then the data will be received sequentially from the E1 extent to the E4 extent.  Each stream is viewed by Partition Layer as one large file, and the content of the Stream can be modified or read in random mode. <br>  <b>Block</b>  The minimum unit of data available for writing and reading, which can be up to a certain N bytes.  All recorded data is written to the extent in the form of one or more combined blocks, and the blocks do not have to be the same size. <br>  <b>Extent.</b>  The extents are replication units on the Stream Layer, and by default the Storage Stamp stores three replicas for each extent stored in the NTFS file and consisting of blocks.  The extent size used by Partition Layer is 1 GB, while smaller objects are complemented by Partition Layer to one extent, and sometimes to one block.  To store very large objects (for example, blobs), the object is partitioned by Partition Layer into several extents.  In this case, of course, Partition Layer keeps track of which extents and blocks which objects belong to. <br><br><img src="https://habrastorage.org/storage2/ce6/940/d36/ce6940d36475293fd8b7bc38ca9ae9ce.png"><br><br>  <b>Stream Manager (SM).</b>  The Stream Manager tracks the namespace of the streams, manages the state of all active stream and extents and their location between the Extend Node, monitors the health of all the Extend Node, creates and distributes extents (but not blocks - the Stream Manager knows nothing about them), and performs lazy re-replication of extents whose replicas were lost due to hardware errors or simply inaccessible and collects "garbage extents".  The Stream Manager periodically polls and synchronizes the status of all Extend Node and the extents that they store.  If the SM detects that the extent has been loosened to less than the expected number of ENs, the SM performs a replication.  At the same time, the volume of the state, if you can call it that, can be small enough to fit in the memory of one Stream Manager.  The only consumer and customer of the Stream Layer is the Partition Layer, and they are so designed that they cannot use more than 50 million extents and no more than 100,000 Stream for a single Storage Stamp (the blocks are not taken into account, since there may be an innumerable number) that Fits perfectly in 32 gigabytes of memory Stream Manager. <br>  <b>Extent Nodes (EN).</b>  Each EN manages the repository for the set of extents replicas assigned to them by the SM.  EN has N mapped drives, which are under its full control to save extents replicas and their blocks.  At the same time, EN does not know anything about the Stream (unlike the Stream Manager, which knows nothing about blocks) and manages only extents and blocks that (extents) are, in fact, files on disks containing data blocks and their checksums + the map of associations of extents to the corresponding blocks and their physical location.  Each EN contains some idea of ‚Äã‚Äãits extents and where the replicas for particular extents are located.  When any of the Streams no longer refers to specific extents, the Stream Manager collects these junk extents and notifies EN of the need to free up space.  In this case, the data in the Stream can only be added, the existing data cannot be modified.  Atomic add operations ‚Äî either the entire data block is added, or nothing is added.  At the same time, several blocks can be added within one atomic operation ‚Äúadding several blocks‚Äù.  The minimum size that can be read from Stream is one block.  The operation of adding several blocks allows the client to record large amounts of sequential data in a single operation. <br><br>  Each extent, as already mentioned, has a certain ceiling for the size, and when it is filled, the extent is sealed (sealed) and further write operations operate on new extents.  Data cannot be added to a sealed extent, and it is immutable. <br><br>  There are a few rules regarding extents: <br><br>  1. After adding a record and confirming the operation to the client, all further read operations of this record from any replica should return the same data (the data is immutable). <br>  2. After sealing the extent, all read operations from any sealed replica must return the same extent content. <br><br>  For example, when a Stream is created, SM assigns to the first extent three replicas (one primary and two secondary) for three Extent Nodes, which, in turn, are chosen by the SM for random distribution between different update and error domains and taking into account the possibility of load balancing.  In addition, the SM decides which replica will be Primary for the extent and all write operations to the extent are performed first on the primary EN, and only after that from the primary EN the record is made on two secondary EN.  Primary EN and the location of the three replicas does not change to extent.  When the SM allocates an extent, the extent information is sent back to the client, who then knows which EN contain three replicas and which of them is primary.  This information becomes part of the Stream metadata and is cached on the client.  When the last extent in the Stream is sealed, the process repeats.  SM allocates one more extent, which now becomes the last extent in Stream, and all new recording operations are performed on the new last extent.  For an extent, each add operation is replicated three times across all replicas of the extent, and the client sends all write requests to the primary EN, but read operations can be performed from any replica, even for unsealed extents.  The add operation is sent to the primary EN, and the primary EN is responsible for determining the shift in the extent, as well as organizing all write operations in the event that concurrent recording occurs in one extent, sending the add operation with the necessary shift by two secondary EN and sending confirmation of the operation to the client that is sent only when the add operation was confirmed on all three replicas.  If one of the replicas does not respond or a hardware error occurs (or has occurred), a write error is returned to the client.  In this case, the client is associated with the SM and the extent in which the write operation occurred is sealed by the SM. <br><br>  SM then places a new extent with replicas on other available ENs and marks this extent as the last one in stream, and this information is returned to the client, who continues to perform operations to add to the new extent.  It should be mentioned that the entire sequence of actions for sealing and placing a new extent is performed on average of only 20 milliseconds. <br>  As for the sealing process itself.  In order to seal the extent, the SM polls all three ENs about their current length.  In the process of sealing two scenarios - either all replicas of the same size, or one of the replicas longer or shorter than the others.  The second situation occurs only when an add operation fails, when some of the EN (but not all) were not available.  When sealing the extent, the SM selects the shortest length based on the available ENs.  This allows you to seal the extents so that all changes confirmed for the client will be sealed.  After sealing, the confirmed extent length no longer changes and, if the SM cannot reach EN during sealing, but then EN becomes available, the SM forces this EN to synchronize to the confirmed length, which results in an identical set of bits. <br><br>  However, a different situation may arise here - SM cannot communicate with EN, however Partition Server, which is a client, can.  Partition Layer, about which a little later, has two read modes - reading records in known positions and using iteration over all records in stream.  As for the first - Partition layer uses two types of Stream - recording and blob.  For these Stream, read operations always occur for certain positions (extent + shift, length).  Partition Layer performs read operations for these two types using the position information returned after a previous successful add operation on the Stream Layer, which only happens when all three replicas have reported that the add operation was successful.  In the second case, when all the records in the Stream are iterated sequentially, each partition has two separate Stream (metadata and confirmation log), which the Partition Layer will read sequentially from beginning to end. <br><br>  In Windows Azure Storage, a mechanism has been introduced that allows saving on disk space and traffic, while not reducing the level of data availability, and is called erasure codes.  The essence of this mechanism is that the extent is divided into N fragments of approximately equal size (in practice, these are files again), after which, according to the Reed-Solomon algorithm, M code fragments are added to correct the error.  What does it mean?  Any X of N fragments are equal in size to the original file, to restore the original file, it is enough to collect X any fragments and decode, the other NX fragments can be deleted, broken, and so on.  As long as there are more than M error-correcting code fragments in the system, the system can fully restore the original extent. <br><br>  This optimization of sealed extents is very important with huge amounts of data stored in the cloud storage, as it reduces the cost of storing data from three full replicas of the source data to 1.3-1.5 of the source data depending on the number of fragments used, and also increases the "stability" of the data compared to storing three replicas inside the Storage Stamp. <br><br>  When performing write operations for an extent that has three replicas, all operations are put to execution with a specific time value and, if the operation was not completed during this time, this operation should not be performed.  If the EN determines that the read operation cannot be completely completed within a certain time, he immediately informs the client.  This mechanism allows the client to access a different EN with a read operation. <br>  Similarly with data for which erasure coding is applied - when a read operation does not have time to execute over a time period due to heavy load, this operation may not be used to read the full data fragment, but it can use the opportunity of data reconstruction and in this case the read operation refers to all extent fragments with an erasure code, and the first N responses will be used to reconstruct the required fragment. <br>  Paying attention to the fact that the WAS system can serve very large Streams, the following situation may occur: some physical disks are servicing and become locked into servicing large read or write operations, starting to cut throughput for other operations.  To prevent such a situation, WAS does not assign new I / O operations to the disk when it has already been assigned operations that can be performed for more than 100 milliseconds or when already assigned operations have been assigned but not performed in 200 milliseconds. <br><br>  When data is determined by the Stream Layer as writeable, an additional whole disk or SSD is used as storage for the log of all write operations to EN.  The journaling disk is fully allocated for one journal, in which all write operations are sequentially logged.  When each EN performs an add operation, it writes all the data to the journaling disk and starts writing the data to the disk.  If the log disk returns a successful operation code earlier, data will be buffered in memory, and until all data is written to the data disk, all read operations will be serviced from memory.  Using a journaling disk provides important advantages, since, for example, adding operations should not ‚Äúcompete‚Äù with data disk read operations in order to confirm the operation for a client.  The log allows adding operations with Partition Layer to be more consistent and have lower delays. <br><br>  <b>Partition Layer (PL).</b>  This layer contains special Partition Servers (daemon processes) and is designed to manage the storage abstractions themselves (blobs, tables, queues), namespace, transaction order, strict object consistency, data storage on SL and data caching to reduce the number of I / O operations to disk.  PL is also engaged in partitioning data objects within SS according to PartitionName and further load balancing between partition servers.  Partition Layer provides an internal data structure called the Object Table (OT), which is a large table capable of growing to a few petabytes.  OT, depending on the load, is dynamically split into RangePartitions and distributed across all Partition Servers inside the Storage Stamp.  A RangePartition is a range of OT entries starting from the smallest key provided to the largest key. <br><br>  There are several different types of OT: <br>  ‚Ä¢ The Account Table stores the metadata and configuration for each storage account associated with the Storage Stamp. <br>  ‚Ä¢ Blob Table stores all blob objects for all accounts associated with the Storage Stamp. <br>  ‚Ä¢ The Entity Table stores all the entity records for all storage accounts associated with the Storage Stamp and is used for the Windows Azure table storage service. <br>  ‚Ä¢ The Message Table stores all messages for all queues for all storage accounts associated with the Storage Stamp. <br>  ‚Ä¢ Schema Table keeps track of schemas for all OT. <br>  ‚Ä¢ Partition Map Table keeps track of all current RangePartitions for all Object Tables and which Partition Server services which RangePartition services.  This table is used by FE servers to redirect requests to the required Partition Server. <br><br>  All table types have fixed schemas that are stored in the Schema Table. <br>  For all OT schemes, there is a standard set of property types - bool, binary, string, DateTime, double, GUID, int32 and int64; in addition, the system supports two special DictionaryType and BlobType properties, the first of which allows you to add properties without a specific scheme as a record .  These properties are stored inside the dictionary type as <br>  (name, type, value).  The second special property is used to store large amounts of data and is currently used only for the Blob Table, while blob data is not stored in the general stream of records, but in a separate stream for blob data, in essence, only the link to blob data is stored (list links "extent + shift length").  OT supports standard operations ‚Äî insert, update, delete, and read, as well as batch transactions for records with a single PartitionName value.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactions in one batch are confirmed as one transaction. </font><font style="vertical-align: inherit;">OT also supports snapshot isolation mode to allow read operations to be performed in parallel with write operations.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partition Layer Architecture </font></font></h5><br><br><img src="https://habrastorage.org/storage2/2dd/250/052/2dd250052a7fbee6b646f075479ade71.png"><br>  Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Architecture and Workflow Partition The Layer </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partition Manager (PM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tracks and splits large OTs onto an N RangePartition within the Storage Stamp and assigns the RangePartition to a specific Partition Server. </font><font style="vertical-align: inherit;">Information about where it is stored is stored in the Partition Map Table. </font><font style="vertical-align: inherit;">One RangePartition is assigned to one active Partition Server, which guarantees that two RangePartition will not overlap. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each Storage Stamp has several PM instances and they all "compete" for one Leader Lock stored in the Lock Service. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partition Server (PS)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serves requests for RangePartitions assigned to this PM server and stores all partition state in Streams and manages the cache in memory. PS is able to serve several RangePartitions from several OTs, possibly up to a dozen on average. The PS maintains the following components, keeping them in memory: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a version of the confirmation log for the RangePartition, containing all recent changes that have not yet been confirmed by the test point. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Index Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a cache containing positions by the checkpoint of the data flow of records. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Row Data Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in-memory cache for checkpoint data entry pages. This cache is read only. When the cache is accessed, the Row Data Cache and Memory Table are checked with a preference for the second. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom Filters</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - if the data is not found in the Row Data Cache and Memory Table, then the positions and control points in the data stream are inspected, and their rough search will be ineffective, therefore special bloom filters are used for each control point, which indicate whether access to the record in the checkpoint. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock service</font></font></b>     PM.  PS     Lock Service   .   PS  N RangePartitions,   PS,   PS. PM  N PS,    ,  PM  RangePartitions PS   Partition Map Table  ,   Front-End Layer   RangePartitions,   Partition Map Table. RangePartition     Log-Structured Merge-Tree,   RangePartition     Streams  Stream Layer  Stream     RangePartition. <br><br>  RangePartition       Streams: <br> ‚Ä¢ <b>Metadata Stream</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This Stream is central to the RangePartition. PM assigns a PS partition, providing the Metadata Stream name of this PS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commit Log Stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äî This Stream is intended to store logs of confirmed insert, update, and delete operations applied to a RangePartitions from the last point generated for a RangePartition. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Row Data Stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saves record data and position for RangePartitions </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blob Data Stream is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used only for Blob Table to save blob data.</font></font><br>   Stream   Stream  Stream Layer,  OT RangePartition.  RangePartition  OT     ,  Blob Table ‚Äì RangePartition  Blob Table             ( )             BlobType. <br><br><h5>   RangePartitions </h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To perform load balancing between Partition Servers and determine the total number of partitions in the Storage Stamp, PM performs three operations: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load balancing.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With this operation, it is determined when a particular PS is experiencing an excessive load, and then one or more RangePartitions are reassigned to less loaded PS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Split.</font></font></b>     ,   RangePartition    ,   RangePartition        ,    RangePartitions      PS. PM   Split,  ,    , PS,   AccountName  PartitionName.  , ,   RangePartition B   RangePartitions C  D   : <br> o PM   PS   B  C  D. <br> o PS     B    . <br> o PS    MultiModify,  Streams  B (,    )     Streams  C  D    ,    B (  ,   ,  ,    ).  PS    Partition Key  C  D  . <br> o PS       C  D. <br> o PS  PM   ,  Partition Map Table  ,       PS. <br> ‚Ä¢ <b>Merge.</b>      ¬´¬ª   RangePartitions  ,       OT.   PM   RangePartitions    PartitionName,   ,     : <br> o PM  C  D  ,     PS,   PS    C  D  E. <br> o PS     C  D       C  D. <br> o PS   MultiModify         .             C  D. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o PS creates an E metadata stream containing the confirmation log and data stream names, a combined range of keys for E, and pointers (extent + offset) for the confirmation log (from C and D). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o The traffic for RangePartition E starts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o PM updates the Partition Map Table and the metadata. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following metrics are monitored for load balancing: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ The number of transactions per second. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ The average number of pending transactions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ CPU load. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Network load. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Delayed requests. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Size of the RangePartition data.</font></font><br> PM    heartbeat-   PS,        PM    heartbeat.  PM ,  RangePartition     (  ),        PS    Split.    PS   ,   RangePartition,  PM     PS RangePartitions    PS.     RangePartition PM   PS,  RangePartition,     ,    PS   PM  PM  RangePartition   PS   Partition Map Table. <br><br>         (   RangePartition)      (        )   ,         Performance Isolation,           RangePartitions,           ,             .              ,           .             ‚Äì ,            ,          RangePartition  .            .          PartitionNames,        RangePartitions      ,     . <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Front-End (FE).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The frontend layer consists of a set of stateless servers that accept incoming requests. Upon receiving the request, the FE reads the AccountName, authenticates and authorizes the request, and then transfers it to the partition server on PL (based on the received PartitionName). The servers belonging to the FE cache the so-called Partition Map, in which the system manages some tracking of the PartitionName ranges and which partition server which PartitionNames serves. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intra-Stamp Replication (stream layer).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This mechanism controls synchronous replication and data integrity. It stores enough replicas for different nodes in different error domains in order to save this data in case of any error, and it runs completely on the SL. In the case of a write operation received from a client, it is confirmed only after full successful replication. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inter-Stamp Replication (partition layer).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This replication mechanism produces asynchronous replication between SSs, and it performs this replication in the background. Replication occurs at the object level, that is, either the whole object is replicated, or its change is replicated (delta).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These mechanisms differ in that intra-stamp provides resistance against "iron" errors that periodically occur in large-scale systems, whereas inter-stamp provides geographical redundancy against various catastrophes that occur rarely. One of the main scenarios for this type of replication is the geographical replication of storage account data between two data centers in order to recover from natural disasters.</font></font><br>           (  ‚Äì ).          ,    .     LS  Storage Stamp         AccountName   Storage Stamp,        ¬´¬ª ,   , secondary,    inter-stamp replication (     ). LS   DNS    AccountName.service.core.windows.net,   VIP  .  ,    - ,      .          ,      intra-stamp replication  Stream Layer,         .                   Partition Layer. <br>      ,       .        ,        . ,       ,         ‚Äì        ,    DNS-       (account.service.core.windows.net). ,    DNS-   -  ,             URL.             (  ,        ).                       .    ,    ,      ,   ,        ,        ( ,     ). <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process of geographic replication is much more interesting if only because it affects our actions more and more often than the ephemeral dinosaur that ate the data center, which led to geo-failover.</font></font><br> , ,        (   ), foo  bar.        PartitionKey.     A  B   foo,      X  Y   bar.  ,         B, , ,  X      Y.      ‚Äì  ,           foo    bar. ,       -  ,        ,   ,    A  X,    B  Y  .      ,  X  Y .          ( ,        PartitionKey ,    ). <br><br><h5>  Summary </h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Windows Azure storage services are an essential part of the platform, providing services for storing data in the cloud and implementing a combination of characteristics such as strict consistency, global namespace, and high data fault tolerance in a multi-tenancy environment. </font></font><br><br></div><p>Source: <a href="https://habr.com/ru/post/173661/">https://habr.com/ru/post/173661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173649/index.html">WorldHostingDays - the largest hosters conference (report)</a></li>
<li><a href="../173651/index.html">Zip codes - to freedom! (Reversing in pictures)</a></li>
<li><a href="../173653/index.html">Watching the collection. Tailable cursors</a></li>
<li><a href="../173655/index.html">Amazon Expanded Instance Types with EBS-Optimized Disks</a></li>
<li><a href="../173657/index.html">Voyager 1 almost left the solar system</a></li>
<li><a href="../173663/index.html">The war is over, everyone has won</a></li>
<li><a href="../173665/index.html">Google Keep is available. Again</a></li>
<li><a href="../173667/index.html">MODX Evolution return! (version 1.0.9 from 03/19/2013)</a></li>
<li><a href="../173669/index.html">Who can be called a cloud provider or how not to fall for hoster tricks?</a></li>
<li><a href="../173675/index.html">Course lectures "Startup". Peter Thiel. Stanford 2012. Session 12</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>