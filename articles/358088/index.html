<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go assembler guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before you start implementing the runtime and studying the standard library, you need to master the abstract assembler Go. I hope this guide will help...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go assembler guide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/sq/d4/pz/sqd4pzzyimnn4hapk2_utwr949s.jpeg"><br><br>  Before you start implementing the runtime and studying the standard library, you need to master the abstract assembler Go.  I hope this guide will help you quickly master the necessary knowledge. <br><a name="habracut"></a><br>  <b>Content</b> <br><br><ul><li>  <a href="https://habr.com/company/mailru/blog/358088/">"Pseudoassembler"</a> </li><li>  <a href="https://habr.com/company/mailru/blog/358088/">Simple program decomposition</a> <br><ul><li>  <a href="https://habr.com/company/mailru/blog/358088/">Analyzing add</a> </li><li>  <a href="https://habr.com/company/mailru/blog/358088/">Analyzing main</a> </li></ul></li><li>  <a href="https://habr.com/company/mailru/blog/358088/">A couple of words about gorutinah, stacks and splits</a> <br><ul><li>  <a href="https://habr.com/company/mailru/blog/358088/">Stacks</a> </li><li>  <a href="https://habr.com/company/mailru/blog/358088/">Divisions</a> </li><li>  <a href="https://habr.com/company/mailru/blog/358088/">Minus some subtleties</a> </li></ul></li><li>  <a href="https://habr.com/company/mailru/blog/358088/">Conclusion</a> </li><li>  <a href="https://habr.com/company/mailru/blog/358088/">Links</a> </li></ul><br>  <i>This article assumes that readers have a basic knowledge of any kind of assembler.</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i>When it comes to architecture-related issues, linux / amd64 is always implied.</i> <i><br><br></i>  <i>We will always work with compiler optimizations <b>enabled</b> .</i> <i><br><br></i>  <i>All quotes are taken from official documentation and / or code base, unless otherwise noted.</i> <br><br><a name="1"></a><h2>  "Pseudoassembler" </h2><br>  The Go compiler generates an abstract, portable assembler that is not tied to any hardware.  The assembler Go then uses this pseudo-assembler to generate machine-specific instructions for the target hardware. <br><br>  This additional "level" gives a lot of advantages.  The main one is the easy porting of Go to the new architecture.  For details, I send you to Rob Pike‚Äôs ‚Äú <a href="https://www.youtube.com/watch%3Fv%3DKINIAgRpkDA">The Design of the Go Assembler</a> ‚Äù. <br><br><blockquote>  The most important thing to know about the Go assembler: it is not a direct representation of the machine underlying the language.  Something is compared directly with the machine, but something is not.  The fact is that the compiler does not need to transfer the assembler to a regular pipeline.  Instead, the compiler operates on a semi-abstract set of instructions, which are partially selected after generating the code.  The assembler works in a semi-abstract form, so if you see the MOV instruction, this does not mean that the toolkit will generate a move instruction for this operation.  Perhaps this will be a cleaning or loading instruction.  Or maybe the generated instruction will exactly match the machine instruction with the same name.  In general, machine-specific operations look like they are, and more general concepts, like moving memory or call and return routines, are more abstract.  The details depend on the architecture, and we apologize for the inaccuracies, the situation is uncertain. </blockquote><br>  An assembler program is a way to parse the description of this set of semi-abstract instructions and turn them into instructions for transfer to a linker. <br><br><a name="2"></a><h2>  Simple program decomposition </h2><br>  Consider this code on Go ( <a href="">direct_topfunc_call.go</a> ): <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:noinline func add(a, b int32) (int32, bool) { return a + b, true } func main() { add(10, 32) }</span></span></code> </pre> <br>  (Pay attention to the <code>//go:noinline</code> compiler directive <code>//go:noinline</code> ... Be careful.) <br><br>  Let's compile the code into an assembler: <br><br><pre> <code class="go hljs">$ GOOS=linux GOARCH=amd64 <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool compile -S direct_topfunc_call.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-number"><span class="hljs-number">0x0000</span></span> TEXT <span class="hljs-string"><span class="hljs-string">""</span></span>.add(SB), NOSPLIT, $<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-16</span></span> <span class="hljs-number"><span class="hljs-number">0x0000</span></span> FUNCDATA $<span class="hljs-number"><span class="hljs-number">0</span></span>, gclocals¬∑f207267fbf96a0178e8758c6e3e0ce28(SB) <span class="hljs-number"><span class="hljs-number">0x0000</span></span> FUNCDATA $<span class="hljs-number"><span class="hljs-number">1</span></span>, gclocals¬∑<span class="hljs-number"><span class="hljs-number">33</span></span>cdeccccebe80329f1fdbee7f5874cb(SB) <span class="hljs-number"><span class="hljs-number">0x0000</span></span> MOVL <span class="hljs-string"><span class="hljs-string">""</span></span>.b+<span class="hljs-number"><span class="hljs-number">12</span></span>(SP), AX <span class="hljs-number"><span class="hljs-number">0x0004</span></span> MOVL <span class="hljs-string"><span class="hljs-string">""</span></span>.a+<span class="hljs-number"><span class="hljs-number">8</span></span>(SP), CX <span class="hljs-number"><span class="hljs-number">0x0008</span></span> ADDL CX, AX <span class="hljs-number"><span class="hljs-number">0x000a</span></span> MOVL AX, <span class="hljs-string"><span class="hljs-string">""</span></span>.~r2+<span class="hljs-number"><span class="hljs-number">16</span></span>(SP) <span class="hljs-number"><span class="hljs-number">0x000e</span></span> MOVB $<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>.~r3+<span class="hljs-number"><span class="hljs-number">20</span></span>(SP) <span class="hljs-number"><span class="hljs-number">0x0013</span></span> RET <span class="hljs-number"><span class="hljs-number">0x0000</span></span> TEXT <span class="hljs-string"><span class="hljs-string">""</span></span>.main(SB), $<span class="hljs-number"><span class="hljs-number">24</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> ;; ...omitted stack-split prologue... <span class="hljs-number"><span class="hljs-number">0x000f</span></span> SUBQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0013</span></span> MOVQ BP, <span class="hljs-number"><span class="hljs-number">16</span></span>(SP) <span class="hljs-number"><span class="hljs-number">0x0018</span></span> LEAQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP <span class="hljs-number"><span class="hljs-number">0x001d</span></span> FUNCDATA $<span class="hljs-number"><span class="hljs-number">0</span></span>, gclocals¬∑<span class="hljs-number"><span class="hljs-number">33</span></span>cdeccccebe80329f1fdbee7f5874cb(SB) <span class="hljs-number"><span class="hljs-number">0x001d</span></span> FUNCDATA $<span class="hljs-number"><span class="hljs-number">1</span></span>, gclocals¬∑<span class="hljs-number"><span class="hljs-number">33</span></span>cdeccccebe80329f1fdbee7f5874cb(SB) <span class="hljs-number"><span class="hljs-number">0x001d</span></span> MOVQ $<span class="hljs-number"><span class="hljs-number">137438953482</span></span>, AX <span class="hljs-number"><span class="hljs-number">0x0027</span></span> MOVQ AX, (SP) <span class="hljs-number"><span class="hljs-number">0x002b</span></span> PCDATA $<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0x002b</span></span> CALL <span class="hljs-string"><span class="hljs-string">""</span></span>.add(SB) <span class="hljs-number"><span class="hljs-number">0x0030</span></span> MOVQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP <span class="hljs-number"><span class="hljs-number">0x0035</span></span> ADDQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0039</span></span> RET ;; ...omitted stack-split epilogue...</code> </pre> <br>  We decomposed two functions line by line to understand how the compiler works. <br><br><a name="3"></a><h4>  Analyzing <code>add</code> </h4><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0000</span></span> TEXT <span class="hljs-string"><span class="hljs-string">""</span></span>.add(SB), NOSPLIT, $<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-16</span></span></code> </pre> <br><ul><li>  <code>0x0000</code> : Offset (offset) of the current instruction relative to the start of the function. </li><li>  <code>TEXT "".add</code> : The <code>TEXT</code> directive declares the character <code>"".add</code> part of the <code>.text</code> section (that is, executable code) and means that the instructions following the directive are the body of the function. <br><br>  The empty string <code>""</code> during the build will be replaced with the name of the current package: for example, <code>"".add</code> after linking to the final binary will become <code>main.add</code> . </li><li>  <code>(SB)</code> : <code>SB</code> is a virtual register containing a "static-base" pointer, that is, the address of the beginning of the program's address space. <br><br>  <code>"".add(SB)</code> declares that our character is located at an address with a constant offset from the beginning of the address space.  In other words, it is the absolute direct address where the symbol of the global function is written.  This confirms <code>objdump</code> : <br><br> <code>$ objdump -j .text -t direct_topfunc_call | grep 'main.add' <br> 000000000044d980 g F .text 000000000000000f main.add</code> <br> <blockquote>  All user characters are written as offsets for pseudo-registers FP (arguments and local variables) and SB (global variables).  The pseudo-register SB can be considered as a source of memory, so the symbol <code>foo(SB)</code> is the name foo as an address in memory. </blockquote></li><li>  <code>NOSPLIT</code> tells the compiler that it should NOT insert the stack split preamble (stack-split), which checks whether the current stack should be enlarged. <br><br>  In the case of our <code>add</code> function, the compiler set this flag itself: it is smart enough and realized that since <code>add</code> does not have local variables and its own stack frame, then it simply cannot outgrow the current stack.  This means that checks are performed on every call - processor cycles thrown to the wind. <br><br><blockquote>  <code>"NOSPLIT"</code> : do not insert the initial check if the stack should be split.  The frame for the subroutine (routine), as well as what it calls, must be placed in the spare space at the beginning of the stack segment.  Used to protect subroutines, such as the stack partitioning code itself.  At the end of the article we will talk a little about gorutin and stack splits. </blockquote></li><li>  <code>$0-16: $0</code> - the size (in bytes) of the stack frame allocated in memory.  <code>$16</code> - the size of the arguments passed to the caller. <br><br><blockquote>  In general, after the frame size comes the size of the argument, separated by a minus sign (this is not a subtraction, but a stupid syntax).  The frame size of <code>$24-8</code> means that the function has a frame size of 24 bytes, and it is called with an 8-byte argument that is in the frame of the caller.  If <code>NOSPLIT</code> is not specified for <code>TEXT</code> , then the size of the argument must be provided.  For assembly functions with go-prototypes, <code>go vet</code> will check if the size of the argument is correct. </blockquote></li></ul><br> <code>0x0000 FUNCDATA $0, gclocals¬∑f207267fbf96a0178e8758c6e3e0ce28(SB) <br> 0x0000 FUNCDATA $1, gclocals¬∑33cdeccccebe80329f1fdbee7f5874cb(SB)</code> <br> <br>  The <code>FUNCDATA</code> and <code>PCDATA</code> provided by the compiler and contain information for the garbage collector. <br><br>  Do not go deep yet, we will return to this in the article where garbage collection will be dealt with. <br><br> <code>0x0000 MOVL "".b+12(SP), AX <br> 0x0004 MOVL "".a+8(SP), CX</code> <br> <br>  The calling convention in Go instructs all arguments to be pushed to the stack using the space already reserved in the stack frame of the caller.  The caller‚Äôs duty is to shrink and grow the stack so that the caller can pass arguments and the caller can return values. <br><br>  The Go compiler never generates instructions for the PUSH / POP family: the stack size is changed by decrementing or incrementing the virtual pointer of the SP equipment stack (see discussion <a href="https://github.com/teh-cmc/go-internals/issues/21">issue # 21: about SP register</a> ). <br><br><blockquote>  The pseudo-register SP is a virtual stack pointer used to refer to local frame variables and arguments prepared for function calls.  It indicates the beginning of the local stack frame, so links should use a negative offset in the range [‚àíframesize, 0]: <code>x-8(SP)</code> , <code>y-4(SP)</code> , and so on. </blockquote><br>  Although the official documentation states that ‚ÄúAll user characters are written as offsets relative to the FP pseudo-register (arguments and local variables),‚Äù this is only true for the code you write yourself. <br><br>  Like most newer compilers, the Go toolkit directly in the generated code always refers to arguments and local variables using offsets from the stack pointer.  This allows the stack frame to be used as a general-purpose register on platforms with a smaller number of registers (for example, x86). <br><br>  Check out the ‚Äú <a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64">x86-64 stack frame layout</a> ‚Äù if you like these boring details (see also issue # 2: Frame pointer). <br><br>  <code>"".b+12(SP)</code> and <code>"".a+8(SP)</code> refer to addresses located 12 and 8 bytes from the top of the stack (remember: the stack grows down!). <br><br>  <code>.a</code> and <code>.b</code> are arbitrary aliases for the places to which we refer.  Although <b>they have absolutely no semantic meaning</b> , they are prescribed to be used when relative addressing is used for virtual registers.  This is what the documentation says about the virtual frame pointer: <br><br><blockquote>  The FP pseudo-register is a virtual frame pointer used to refer to function arguments.  Compilers support a virtual frame pointer and refer to arguments in the stack as offsets from the pseudo-register.  Thus, 0 (FP) is the first argument of the function, 8 (FP) is the second (on a 64-bit machine), and so on.  However, if you refer to the function arguments in this way, you must first put the name, for example: first_arg + 0 (FP) and second_arg + 8 (FP) (here the offset - from the frame pointer - differs from SB, which means offset from characters).  The assembler uses this convention forcibly, rejecting simple 0 (FP) and 8 (FP).  The real name does not correspond semantically, but should be used to document the name of the argument. </blockquote><br>  Finally, two more important points should be noted: <br><br><ol><li>  The first argument <code>a</code> is not at <code>0(SP)</code> , but at <code>8(SP)</code> , because the caller retains its return address at <code>0(SP)</code> by means of a pseudo-function <code>CALL</code> . </li><li>  Arguments are passed in reverse order.  That is, the first argument will be closest to the top of the stack. </li></ol><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0008</span></span> ADDL CX, AX <span class="hljs-number"><span class="hljs-number">0x000a</span></span> MOVL AX, <span class="hljs-string"><span class="hljs-string">""</span></span>.~r2+<span class="hljs-number"><span class="hljs-number">16</span></span>(SP) <span class="hljs-number"><span class="hljs-number">0x000e</span></span> MOVB $<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>.~r3+<span class="hljs-number"><span class="hljs-number">20</span></span>(SP)</code> </pre> <br>  <code>ADDL</code> adds two Long-words (for example, 4-byte values), lying in <code>AX</code> and <code>CX</code> , and the result is written in <code>AX</code> .  Then this result is moved to <code>"".~r2+16(SP)</code> , on the stack of which the caller has previously reserved a place and will look for returned values ‚Äã‚Äãthere.  I repeat: in this case, <code>"".~r2</code> has no semantic meaning. <br><br>  To demonstrate how Go handles multiple return values, we will return the constant boolean value <code>true</code> .  The mechanics are exactly the same as in the case of the first return value, only the offset will correspond to changes in <code>SP</code> . <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0013</span></span> RET</code> </pre> <br>  The <code>RET</code> pseudoinstructor tells the Go assembler to insert any instructions required by the calling convention used on the target platform in order to correctly return the result from the subroutine of the call.  This will certainly force the code to extract (pop off) the return address located at <code>0(SP)</code> , and then return to it. <br><br><blockquote>  The last instruction in the TEXT block should be some kind of transition, it is usually a (pseudo) RET instruction.  If this is not the case, the linker will add a jump-to-itself instruction.  There is no ‚Äúfall through‚Äù in the TEXT blocks. </blockquote><br>  We'll have to learn at once a large amount of syntax and semantics.  Here is an inline summary of the above: <br><br><pre> <code class="go hljs">;; Declare global function symbol <span class="hljs-string"><span class="hljs-string">""</span></span>.add (actually main.add once linked) ;; Do not insert stack-split preamble ;; <span class="hljs-number"><span class="hljs-number">0</span></span> bytes of stack-frame, <span class="hljs-number"><span class="hljs-number">16</span></span> bytes of arguments passed in ;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0000</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEXT</span></span></span><span class="hljs-function"> "".</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SB)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NOSPLIT</span></span></span><span class="hljs-function">, $0-16 ;; ...</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">omitted</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNCDATA</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stuff</span></span></span><span class="hljs-function">... 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0000</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MOVL</span></span></span><span class="hljs-function"> "".</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">+12</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AX</span></span></span><span class="hljs-function"> ;; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Long</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">word</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(4B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">argument</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AX</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0004</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MOVL</span></span></span><span class="hljs-function"> "".</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">+8</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CX</span></span></span><span class="hljs-function"> ;; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Long</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">word</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(4B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">argument</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CX</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0008</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADDL</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CX</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AX</span></span></span><span class="hljs-function"> ;; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AX</span></span></span><span class="hljs-function">=</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CX</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AX</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x000a</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MOVL</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AX</span></span></span><span class="hljs-function">, "".~</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r2</span></span></span><span class="hljs-function">+16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function"> ;; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addition</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AX)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x000e</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MOVB</span></span></span><span class="hljs-function"> $1, "".~</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r3</span></span></span><span class="hljs-function">+20</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span><span class="hljs-function"> ;; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-function"> `</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">true</span></span></span><span class="hljs-function">` </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(constant)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0013</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RET</span></span></span><span class="hljs-function"> ;; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jump</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stored</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span><span class="hljs-function"> 0</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SP)</span></span></span></span></code> </pre> <br>  But a visual representation of the contents of the stack after the execution of <code>main.add</code> : <br><br><pre> <code class="go hljs"> | +-------------------------+ &lt;-- <span class="hljs-number"><span class="hljs-number">32</span></span>(SP) | | | G | | | R | | | O | | main.main<span class="hljs-string"><span class="hljs-string">'s saved | W | | frame-pointer (BP) | S | |-------------------------| &lt;-- 24(SP) | | [alignment] | D | | "".~r3 (bool) = 1/true | &lt;-- 21(SP) O | |-------------------------| &lt;-- 20(SP) W | | | N | | "".~r2 (int32) = 42 | W | |-------------------------| &lt;-- 16(SP) A | | | R | | "".b (int32) = 32 | D | |-------------------------| &lt;-- 12(SP) S | | | | | "".a (int32) = 10 | | |-------------------------| &lt;-- 8(SP) | | | | | | | | | \ | / | return address to | \|/ | main.main + 0x30 | - +-------------------------+ &lt;-- 0(SP) (TOP OF STACK) (diagram made with https://textik.com)</span></span></code> </pre> <br><a name="4"></a><h4>  Analyzing <code>main</code> </h4><br>  In order not to have to flip through the article, let me remind you what our <code>main</code> function looks like: <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0000</span></span> TEXT <span class="hljs-string"><span class="hljs-string">""</span></span>.main(SB), $<span class="hljs-number"><span class="hljs-number">24</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> ;; ...omitted stack-split prologue... <span class="hljs-number"><span class="hljs-number">0x000f</span></span> SUBQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0013</span></span> MOVQ BP, <span class="hljs-number"><span class="hljs-number">16</span></span>(SP) <span class="hljs-number"><span class="hljs-number">0x0018</span></span> LEAQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP ;; ...omitted FUNCDATA stuff... <span class="hljs-number"><span class="hljs-number">0x001d</span></span> MOVQ $<span class="hljs-number"><span class="hljs-number">137438953482</span></span>, AX <span class="hljs-number"><span class="hljs-number">0x0027</span></span> MOVQ AX, (SP) ;; ...omitted PCDATA stuff... <span class="hljs-number"><span class="hljs-number">0x002b</span></span> CALL <span class="hljs-string"><span class="hljs-string">""</span></span>.add(SB) <span class="hljs-number"><span class="hljs-number">0x0030</span></span> MOVQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP <span class="hljs-number"><span class="hljs-number">0x0035</span></span> ADDQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0039</span></span> RET ;; ...omitted stack-split epilogue... <span class="hljs-number"><span class="hljs-number">0x0000</span></span> TEXT <span class="hljs-string"><span class="hljs-string">""</span></span>.main(SB), $<span class="hljs-number"><span class="hljs-number">24</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span></code> </pre> <br>  Nothing new: <br><br><ul><li>  <code>"".main</code> (once linked <code>main.main</code> ) is the symbol of a global function in the <code>.text</code> section, whose address is a constant offset from the beginning of our address space. </li><li>  This code places a 24-byte stack frame in memory, takes no arguments, and does not return values. </li></ul><br> <code>0x000f SUBQ $24, SP <br> 0x0013 MOVQ BP, 16(SP) <br> 0x0018 LEAQ 16(SP), BP</code> <br> <br>  As mentioned above, the calling convention in Go dictates that all arguments be passed to the stack. <br><br>  The caller - <code>main</code> - increases its stack frame by 24 bytes ( <i>do not forget that the stack grows down, so in this case <code>SUBQ</code> increases the stack frame</i> ) by decrementing the virtual stack pointer.  What do these 24 bytes consist of: <br><br><ul><li>  8 bytes ( <code>16(SP)-24(SP)</code> ) are used to store the current value of the BP frame pointer ( <i>real!</i> ) To unwind the stack (stack-unwinding) and simplify debugging. </li><li>  1 + 3 bytes ( <code>12(SP)-16(SP)</code> ) is reserved for the second return value ( <code>bool</code> ) plus 3 bytes of the necessary equalization on amd64. </li><li>  4 bytes ( <code>8(SP)-12(SP)</code> ) are reserved for the first return value ( <code>int32</code> ). </li><li>  4 bytes ( <code>4(SP)-8(SP)</code> ) are reserved for the value of the argument b ( <code>int32</code> ). </li><li>  4 bytes ( <code>0(SP)-4(SP)</code> ) are reserved for the value of the argument a ( <code>int32</code> ). </li></ul><br>  Finally, after increasing the stack, <code>LEAQ</code> calculates the new frame pointer address and saves it to <code>BP</code> . <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x001d</span></span> MOVQ $<span class="hljs-number"><span class="hljs-number">137438953482</span></span>, AX <span class="hljs-number"><span class="hljs-number">0x0027</span></span> MOVQ AX, (SP)</code> </pre> <br>  The caller takes an argument for the Quad word being called (8-byte value) and places it on top of the stack that has just increased. <br><br>  Although at first glance it may seem like random garbage, in fact, <code>137438953482</code> corresponds to 4-byte values ‚Äã‚Äãof <code>10</code> and <code>32</code> , which are combined into one 8-byte value: <br><br><pre> <code class="go hljs">$ echo <span class="hljs-string"><span class="hljs-string">'obase=2;137438953482'</span></span> | bc <span class="hljs-number"><span class="hljs-number">10000000000000000000000000000000001010</span></span> \____/\______________________________/ <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0x002b</span></span> CALL <span class="hljs-string"><span class="hljs-string">""</span></span>.add(SB)</code> </pre> <br>  We apply <code>CALL</code> to the <code>add</code> function as an offset from the static-base pointer.  That is, it is a direct transition to a direct address. <br><br>  Note that <code>CALL</code> also places the return address (8-byte value) on top of the stack.  Therefore, each link to <code>SP</code> from within the <code>add</code> function will be offset by 8 bytes!  For example, <code>"".a</code> is now not at <code>0(SP)</code> , but at <code>8(SP)</code> . <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0030</span></span> MOVQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP <span class="hljs-number"><span class="hljs-number">0x0035</span></span> ADDQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0039</span></span> RET</code> </pre> <br>  Finally we: <br><br><ol><li>  We unwind the frame pointer by one stack pointer (that is, we ‚Äúgo down‚Äù one level). </li><li>  Reduce the stack by 24 bytes to return the space we previously occupied. </li><li>  Ask the assembler Go to insert a return routine. </li></ol><br><a name="5"></a><h2>  A couple of words about gorutinah, stacks and splits </h2><br>  This is not the time or place to deal with the gorutin's giblets, but if you begin to sink into the assembler, you will very quickly have to become familiar with the instructions related to managing the stack. <br><br>  You need to be able to quickly recognize these patterns and generally understand what they are doing and how. <br><br><a name="6"></a><h4>  Stacks </h4><br>  Since the number of gorutin in the Go-program is not defined and in practice can reach several million, in order to avoid devouring all the available memory, you need to follow the conservative method of allocating the stack for gorutin during runtime. <br><br>  Thus, each new gorutina initially receives a small 2 KB stack during runtime (in fact, it is in a heap). <br><br>  During its execution, the gorutin can outgrow the initial stack space (i.e. there will be a stack overflow).  To prevent this from happening, the runtime environment, when the stack is filled, allocates a new stack, twice the old one, whose contents are copied to the new stack. <br><br>  This process is known as stack split (split-split) and provides a dynamic stack mechanism for gorutin. <br><br><a name="7"></a><h4>  Divisions </h4><br>  In order for the stack sharing mechanism to work, the compiler inserts new instructions at the beginning and end of each function that may overflow its stack. <br><br>  To avoid unnecessary costs, functions that are unlikely to outgrow the stack are labeled <code>NOSPLIT</code> , which tells the compiler not to insert checks. <br><br>  Let's take a look at our main function, but this time without omitting the preamble with the split stack: <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0000</span></span> TEXT <span class="hljs-string"><span class="hljs-string">""</span></span>.main(SB), $<span class="hljs-number"><span class="hljs-number">24</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> ;; stack-split prologue <span class="hljs-number"><span class="hljs-number">0x0000</span></span> MOVQ (TLS), CX <span class="hljs-number"><span class="hljs-number">0x0009</span></span> CMPQ SP, <span class="hljs-number"><span class="hljs-number">16</span></span>(CX) <span class="hljs-number"><span class="hljs-number">0x000d</span></span> JLS <span class="hljs-number"><span class="hljs-number">58</span></span> <span class="hljs-number"><span class="hljs-number">0x000f</span></span> SUBQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0013</span></span> MOVQ BP, <span class="hljs-number"><span class="hljs-number">16</span></span>(SP) <span class="hljs-number"><span class="hljs-number">0x0018</span></span> LEAQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP ;; ...omitted FUNCDATA stuff... <span class="hljs-number"><span class="hljs-number">0x001d</span></span> MOVQ $<span class="hljs-number"><span class="hljs-number">137438953482</span></span>, AX <span class="hljs-number"><span class="hljs-number">0x0027</span></span> MOVQ AX, (SP) ;; ...omitted PCDATA stuff... <span class="hljs-number"><span class="hljs-number">0x002b</span></span> CALL <span class="hljs-string"><span class="hljs-string">""</span></span>.add(SB) <span class="hljs-number"><span class="hljs-number">0x0030</span></span> MOVQ <span class="hljs-number"><span class="hljs-number">16</span></span>(SP), BP <span class="hljs-number"><span class="hljs-number">0x0035</span></span> ADDQ $<span class="hljs-number"><span class="hljs-number">24</span></span>, SP <span class="hljs-number"><span class="hljs-number">0x0039</span></span> RET ;; stack-split epilogue <span class="hljs-number"><span class="hljs-number">0x003a</span></span> NOP ;; ...omitted PCDATA stuff... <span class="hljs-number"><span class="hljs-number">0x003a</span></span> CALL runtime.morestack_noctxt(SB) <span class="hljs-number"><span class="hljs-number">0x003f</span></span> JMP <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  As you can see, the preamble is divided into prologue and epilogue: <br><br><ul><li>  In the prologue, it is checked whether the space allocated for the gorutine has overflowed, and if so, the execution goes to the epilogue. </li><li>  Epilogue starts the mechanism for increasing the stack, and then returns to the prologue. </li></ul><br>  There is a feedback loop, which works until a sufficiently large stack is allocated for the ‚Äústarving‚Äù mountain. <br><br>  <b>Prologue</b> <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x0000</span></span> MOVQ (TLS), CX ;; store current *g in CX <span class="hljs-number"><span class="hljs-number">0x0009</span></span> CMPQ SP, <span class="hljs-number"><span class="hljs-number">16</span></span>(CX) ;; compare SP and g.stackguard0 <span class="hljs-number"><span class="hljs-number">0x000d</span></span> JLS <span class="hljs-number"><span class="hljs-number">58</span></span> ;; jumps to <span class="hljs-number"><span class="hljs-number">0x3a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SP &lt;= g.stackguard0</code> </pre> <br>  <code>TLS</code> is a virtual register supported by the runtime environment containing a pointer to the current <code>g</code> , that is, to a data structure that monitors the entire state of the gorutine. <br><br>  Let's look at the definition of <code>g</code> in the runtime source code: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stack stack <span class="hljs-comment"><span class="hljs-comment">// 16 bytes // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. stackguard0 uintptr stackguard1 uintptr // ...omitted dozens of fields... }</span></span></code> </pre> <br>  <code>16(CX)</code> corresponds to <code>g.stackguard0</code> , the threshold value supported by the runtime environment.  It compares this value with the stack pointer and finds out if the goretin is close to stack exhaustion.  That is, the prolog checks if the current <code>SP</code> value is less than or equal to <code>stackguard0</code> (correctly, it is greater), and if necessary, it goes to the epilog. <br><br>  <b>Epilogue</b> <br><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0x003a</span></span> NOP <span class="hljs-number"><span class="hljs-number">0x003a</span></span> CALL runtime.morestack_noctxt(SB) <span class="hljs-number"><span class="hljs-number">0x003f</span></span> JMP <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  The epilogue body is simple: it is called during runtime, which does all the work of increasing the stack, and then goes back to the first instruction of the function (that is, the prologue). <br><br>  The <code>NOP</code> instruction stands in front of <code>CALL</code> so that the prologue does not go directly to <code>CALL</code> .  On some platforms, this can lead to bad consequences.  Therefore, right before the call itself, they usually insert an empty instruction (noop instruction) and land on the <code>NOP</code> (also see discussion <a href="https://github.com/teh-cmc/go-internals/issues/4">issue # 4: Clarify "nop before call" paragraph</a> ). <br><br><a name="8"></a><h4>  Minus some subtleties </h4><br>  We considered only the tip of the iceberg.  The internal mechanics of increasing the stack have much more nuances: the process is rather complicated and requires a separate article for detailed consideration. <br><br><a name="9"></a><h2>  Conclusion </h2><br>  As you dive into the Go device in the following articles, the Go assembler will be one of the most important tools for understanding internal mechanics and connections with things that are not so obvious at first glance. <br><br><a name="10"></a><h2>  Links </h2><br><ul><li>  <a href="https://golang.org/doc/asm">[Official Documentation] Quick Guide to Assembler Go</a> </li><li>  <a href="https://golang.org/cmd/compile/">[Official Documentation] Go Compiler Directives</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DKINIAgRpkDA">[Official Documentation] Go Assembly Language</a> </li><li>  <a href="https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub">[Official Records] Continuous Stack Architecture</a> </li><li>  <a href="">[Official Documentation] Constant _StackMin</a> </li><li>  <a href="https://github.com/teh-cmc/go-internals/issues/2">[Discussion] Issue # 2: Frame pointer</a> </li><li>  <a href="https://github.com/teh-cmc/go-internals/issues/4">[Discussion] Issue # 4: Clarify "nop before call" paragraph</a> </li><li>  <a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/">Excursus to programming in assembler Go</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D9jpnFmJr2PE">Converting Go to Assembly Functions</a> </li><li>  <a href="https://stackoverflow.com/questions/579262/what-is-the-purpose-of-the-ebp-frame-pointer-register">What is the EBP frame pointer register for?</a> </li><li>  <a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64">X86-64 stack frame layout</a> </li><li>  <a href="https://blog.cloudflare.com/how-stacks-are-handled-in-go/">How Go Works with Stacks</a> </li><li>  <a href="https://gist.github.com/cpq/8598782">Why stack grows down</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/358088/">https://habr.com/ru/post/358088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358078/index.html">How to automate the development of a team of various sizes</a></li>
<li><a href="../358080/index.html">11 backlog optimization tips</a></li>
<li><a href="../358082/index.html">The influence of a small window on the user's memory, and what to do about it</a></li>
<li><a href="../358084/index.html">Three main principles for rapid product growth from Head of Growth Recruitee</a></li>
<li><a href="../358086/index.html">Not a single code: what affects the operation of blockchain systems</a></li>
<li><a href="../358090/index.html">Understanding the life cycle of the React component</a></li>
<li><a href="../358092/index.html">Why think about web security when it's too late?</a></li>
<li><a href="../358094/index.html">Friday JS: random mixing</a></li>
<li><a href="../358096/index.html">Dive into pyTorch</a></li>
<li><a href="../358100/index.html">How to write on Habrahabr and Geektimes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>