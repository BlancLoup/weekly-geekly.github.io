<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the A * algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing games, we often need to find ways from one point to another. We do not just strive to find the shortest distance, we also need to take...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the A * algorithm</h1><div class="post__text post__text-html js-mediator-article">  When developing games, we often need to find ways from one point to another.  We do not just strive to find the shortest distance, we also need to take into account the duration of the movement.  Move the asterisk (starting point) and the cross (end point) to see the shortest path.  <i>[Approx.</i>  <i>Per .: In the articles of this author there are always many interactive inserts, I recommend to go to the original article.]</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/810/086/1da/8100861dab5d4495872820e074376ae7.png"></div><br>  To search for this path, you can use the graph search algorithm, which is applicable if the map is a graph.  <b>A * is</b> often used as a graph search algorithm.  <b>Search in width</b> is the simplest of the search algorithms for a graph, so let's start with it and gradually move on to A *. <br><a name="habracut"></a><br><h3>  Map presentation </h3><br>  The first thing you need when studying an algorithm is to understand the <b>data</b> .  What is served at the entrance?  What do we get at the output? <br><br>  <b>Input</b> : search algorithms for a graph, including A *, receive a graph as input.  A graph is a set of points (‚Äúnodes‚Äù) and connections (‚Äúedges‚Äù) between them.  Here is the graph I gave to A *: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/114/50d/b10/11450db1045e4a18870fd4d6f4ed411b.png"><br><br>  A * sees nothing else.  He sees only the graph.  He does not know whether something is inside or outside, whether it is a door or a room, how large the area is.  He sees only the graph!  He does not understand any difference between the map above and this one: <br><br><img src="https://habrastorage.org/web/7a3/f91/7e2/7a3f917e25b6466b9c228ef3ec8078de.png"><br><br>  <b>Output</b> : A * defined path consists of nodes and edges.  Ribs is an abstract mathematical concept.  A * tells us to move from one point to another, but does not tell us how to do it.  Remember that he does not know anything about rooms or doors, he sees only the graph.  You yourself have to decide what the edge of the graph, returned by A *, will be - moving from tile to tile, moving in a straight line, opening the door, running along a curved path. <br><br><img src="https://habrastorage.org/web/b6a/074/803/b6a074803fe9450f939244c37f80b624.png"><br><br>  Compromises: for each game card there are many different ways to transfer the path search graph to the A * algorithm.  The card in the figure above turns the doors into knots. <br><br>  And what if we turn doors into ribs? <br><br><img src="https://habrastorage.org/web/223/5a7/6b6/2235a76b6c944a11b9eaed273da74860.png"><br><br>  And if we use the grid to find the way? <br><br><img src="https://habrastorage.org/web/c2e/14a/a40/c2e14aa4059841a08f659ef728a96a50.png"><br><br>  The path search graph does not have to be the same as used in your game map.  In the grid-based map, you can use the pathfinding graph without grids, and vice versa.  A * runs faster with the least number of nodes in the graph.  It is often easier to work with grids, but they make a lot of nodes.  This article discusses the A * algorithm itself, and not the design of graphs.  More information about the graphs can be found on my <a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html">other page</a> .  For explanations, I <em>will use grids</em> in the future <em>, because it's easier to visualize concepts like this</em> . <br><br><h3>  Algorithms </h3><br>  There are many algorithms that work with graphs.  I will review the following: <br><br><img src="https://habrastorage.org/web/d1f/b57/883/d1fb578833c14824be4175ffbf6cf158.png"><br><br>  <b>A wide search</b> does research evenly in all directions.  This is an incredibly useful algorithm, not only for the usual search of a path, but also for procedural map generation, search for paths of flow, distance maps and other types of analysis of maps. <br><br><img src="https://habrastorage.org/web/c72/250/4fb/c722504fba634cf18ba094fb9ba90e0a.png"><br><br>  <b>Dijkstra's algorithm</b> (also called equal cost search) allows us to set the priorities for path research.  Instead of a uniform study of all possible paths, he prefers low cost paths.  We can set reduced costs so that the algorithm moves along the roads, increased cost, to avoid forests and enemies, and much more.  When the cost of movement may be different, we use it instead of searching in width. <br><br><img src="https://habrastorage.org/web/293/cb8/f8c/293cb8f8c7df47f4b47977f5462d116b.png"><br><br>  <b>A *</b> is a modification of the Dijkstra algorithm, optimized for a single end point.  Dijkstra's algorithm can find paths to all points, A * finds a path to one point.  He gives priority to paths that lead closer to the goal. <br><br>  I will start with the simplest - search in width, and will add functions, gradually turning it into A *. <br><br><h3>  Search wide </h3><br>  The key idea of ‚Äã‚Äãall these algorithms is that we track the state of the expanding ring, which is called the <b>boundary</b> .  In the grid, this process is sometimes called flood fill, but the same technique applies to maps without grids.  View the border expansion animation: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YM6Swr6kcBw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  How to implement it?  Repeat these steps until the border is empty: <br><br><ol><li>  Select and delete a <i>point</i> from the <i>border</i> . </li><li>  Mark the point as <i>visited</i> to know that you do not need to process it again. </li><li>  <em>Expanding the</em> border, looking at its <i>neighbors</i> .  All the neighbors, which we have not yet seen, add to the <i>border</i> . </li></ol><br>  Let's take a look at this in more detail.  Tiles are numbered in the order of their visit: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_Ny7WAjzMYE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The algorithm is described in just ten lines of Python code: <br><br><pre><code class="python hljs">frontier = Queue() frontier.put(start ) visited = {} visited[start] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: frontier.put(next) visited[next] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  In this cycle is the whole essence of the search algorithms for the graph of this article, including A *.  But how do we find the shortest path?  The cycle doesn‚Äôt really create paths, it just tells us how to visit all the points on the map.  It happened because the search in width can be used for much more than just finding paths.  In <a href="http://www.redblobgames.com/pathfinding/tower-defense/">this article,</a> I show how it is used in tower defense games, but it can also be used in distance maps, in procedural map generation and much more.  However, here we want to use it to search for paths, so let's change the loop so that we track <em>where we came from</em> for each point visited and rename the <code>visited</code> to <code>came_from</code> : <br><br><pre> <code class="python hljs">frontier = Queue() frontier.put(start ) came_from = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> came_from: frontier.put(next) came_from[next] = current</code> </pre> <br>  Now came_from for each point indicates the place from which we came.  This is similar to the "bread crumbs" from a fairy tale.  This is enough for us to recreate the whole path.  See how the arrows show the way back to the starting position. <br><br><img src="https://habrastorage.org/web/8ce/3a5/3a0/8ce3a53a093c42d5ba7403a54346e08d.png"><br><br>  The code for recreating paths is simple: <em>follow the arrows back <b>from the</b> goal <b>to the</b> beginning</em> .  A path is a <em>sequence of edges</em> , but sometimes it is easier to store only nodes: <br><br><pre> <code class="python hljs">current = goal path = [current] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> current != start: current = came_from[current] path.append(current) path.append(start) <span class="hljs-comment"><span class="hljs-comment"># optional path.reverse() # optional</span></span></code> </pre> <br>  This is the simplest path finding algorithm.  It works not only in grids, as shown above, but also in any structure of graphs.  In a dungeon, points of a graph can be rooms, and edges - doors between them.  In the platformer, the nodes of the graph can be locations, and the edges - possible actions: move left, right, jump, jump down.  In general, you can perceive the graph as a state and action, changing the state.  Read more about the presentation of the maps I wrote <a href="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html">here</a> .  In the remainder of this article, I will continue to use the examples with grids, and tell you why you can use search variations in width. <br><br><h3>  Early exit </h3><br>  We found paths from one point to all other points.  Often we do not need all the paths, we just need a path between two points.  We can stop expanding the border as soon as we find our goal.  See how the border stops expanding after finding the target. <br><br><img src="https://habrastorage.org/web/f04/d11/7dc/f04d117dc83f46579229df66adb70c3a.png"><br><br>  The code is quite straightforward: <br><br><pre> <code class="python hljs">frontier = Queue() frontier.put(start ) came_from = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> came_from: frontier.put(next) came_from[next] = current</code> </pre> <br><h3>  Relocation cost </h3><br>  So far we have taken steps with equal value.  In some cases, the search for ways in different types of movement has a different cost.  For example, in Civilization, movement through plains or desert can cost 1 point of movement, and movement through a forest - 5 movement points.  On the map at the very beginning of the article, passing through the water is 10 times more expensive than moving through the grass.  Another example is the diagonal movement in a grid, which costs more than movement along the axes.  We need to find the way to take this cost into account.  Let's compare the <em>number of steps</em> from the beginning with the <em>distance</em> from the beginning: <br><br><img src="https://habrastorage.org/web/4be/c35/64b/4bec3564bba44c6f8f57985398a55f23.png"><br><br>  For this, we need <strong>a Dijkstra algorithm</strong> (also called a uniform cost search).  How does it differ from search in width?  We need to track the cost of movement, so we add a new variable, <code>cost_so_far</code> , to keep track of the total cost of movement from the starting point.  In assessing points, we need to consider the cost of movement.  Let's turn our queue into a priority queue.  It is less obvious that it may happen that one point is visited several times with different costs, so you need to change the logic a bit.  Instead of adding a point to the border in the case where the point has never been visited, we add it if the new path to the point is better than the best previous path. <br><br><pre> <code class="python hljs">frontier = PriorityQueue() frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>) came_from = {} cost_so_far = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> cost_so_far[start] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): new_cost = cost_so_far[current] + graph.cost(current, next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cost_so_far <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> new_cost &lt; cost_so_far[next]: cost_so_far[next] = new_cost priority = new_cost frontier.put(next, priority) came_from[next] = current</code> </pre> <br>  Using a priority queue instead of a normal queue <em>changes the way the boundary is expanded</em> .  Contour lines allow you to see it.  <strong>Watch the video</strong> to see how the border widens more slowly through forests, and the search for the shortest path is performed around the central forest rather than through it: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6WzhjIohHPg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The cost of movement, which differs from 1, allows us to explore more interesting graphs, not just grids.  On the map at the beginning of the article, the cost of movement is based on the distance between the rooms.  Movement costs can also be used to avoid or prefer areas based on the proximity of enemies or allies.  An interesting implementation detail: the usual priority queue supports inserts and deletes, but in some versions of the Dijkstra algorithm, the third operation also uses the priority of an element that is already in the priority queue.  I do not use this operation, and explain it on <a href="https://habrahabr.ru/post/331220/">the implementation page of the algorithm</a> . <br><br><h3>  Heuristic search </h3><br>  In the search in width and Dijkstra algorithm, the border expands in all directions.  This is a logical choice if you are looking for a path to all points or to a set of points.  However, usually a search is performed for only one point.  Let's make it so that the border expands toward the goal more than in other directions.  First, we define a heuristic function that tells us how close we are to the goal: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">heuristic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Manhattan distance on a square grid return abs(ax - bx) + abs(ay - by)</span></span></code> </pre> <br>  In the Dijkstra algorithm, for ordering the priority queue, we used the distance from the <em>start</em> .  In the <strong>greedy search for the first best match</strong> for the order of the queue with priorities, we instead use the estimated distance to the <em>target</em> .  The point closest to the target will be examined first.  The code uses a queue with priorities from search to width, but no <code>cost_so_far</code> from Dijkstra‚Äôs algorithm is applied: <br><br><pre> <code class="python hljs">frontier = PriorityQueue() frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>) came_from = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> came_from: priority = heuristic(goal, next) frontier.put(next, priority) came_from[next] = current</code> </pre> <br>  Let's see how it works: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pWaFhNeaUJw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wow!  Awesome, right?  But what happens on a more complex map? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8ALNM6bYyGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  These paths are not the shortest.  So, this algorithm works faster when there are not very many obstacles, but the paths are not very optimal.  Can this be fixed?  Of course. <br><br><h3>  Algorithm A * </h3><br>  Dijkstra's algorithm is good at finding the shortest path, but it spends time researching all directions, even unpromising ones.  The eager search explores promising avenues, but may not find the shortest path.  Algorithm A * uses both the true distance from the beginning and the estimated distance to the target. <br><br>  The code is very similar to Dijkstra's algorithm: <br><br><pre> <code class="python hljs">frontier = PriorityQueue() frontier.put(start, <span class="hljs-number"><span class="hljs-number">0</span></span>) came_from = {} cost_so_far = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> cost_so_far[start] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == goal: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): new_cost = cost_so_far[current] + graph.cost(current, next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cost_so_far <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> new_cost &lt; cost_so_far[next]: cost_so_far[next] = new_cost priority = new_cost + heuristic(goal, next) frontier.put(next, priority) came_from[next] = current</code> </pre> <br>  <b>Compare</b> algorithms: Dijkstra's algorithm calculates the distance from the starting point.  A greedy search for the first best match estimates the distance to the target point.  A * uses the sum of these two distances. <br><br><img src="https://habrastorage.org/web/aa5/983/6fd/aa59836fd1494dfba73157ae9e0d3acc.png"><br><br>  <strong>Try</strong> to make holes in different places of the wall in the original article.  You will find that the greedy search finds the right answer, A * finds it too, exploring the same area.  When the greedy first-best search finds the wrong answer (the longer path), A * finds the right one, like Dijkstra's algorithm, but still explores less than Dijkstra's algorithm. <br><br>  A * takes the best from two algorithms.  Since heuristics do not re-estimate distances, A * <em>does not</em> use heuristics to find a suitable answer.  It finds the optimal path, like Dijkstra‚Äôs algorithm.  A * uses heuristics to change the order of nodes to <em>increase the likelihood of</em> an earlier finding a target node. <br><br>  And that is all!  This is the algorithm A *. <br><br><h3>  Additional reading </h3><br>  <strong>Are you ready to implement it?</strong>  Try using a ready-made library.  If you want to implement it yourself, then I have <a href="https://habrahabr.ru/post/331220/">instructions</a> for step-by-step implementation of graphs, queues and path finding algorithms in Python, C ++ and C #. <br><br>  What algorithm should be used to find the paths on the game map? <br><br><ul><li>  If you need to find ways from or to <em>all</em> points, use the search in width or Dijkstra's algorithm.  Use wide search if the cost of movement is the same.  Use the Dijkstra algorithm if the cost of movement changes. </li><li>  If you need to find the way to <em>one</em> point, use the greedy search for the best first or A *.  In most cases, A * should be preferred.  When there is a temptation to use a greedy search, then consider using A * with an <a href="https://en.wikipedia.org/wiki/Admissible_heuristic">‚Äúinvalid‚Äù heuristic</a> . </li></ul><br>  What about the best ways?  Search in width and Dijkstra's algorithm is guaranteed to find the shortest path in the graph.  Greedy search does not necessarily find it.  A * is guaranteed to find the shortest path if the heuristics is never greater than the true distance.  When heuristics become smaller, A * turns into Dijkstra's algorithm.  When heuristics get larger, A * turns into a greedy search for the best first match. <br><br>  What about performance?  It is best to eliminate unnecessary points of the graph.  If you are using a mesh, then <a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html">read this</a> .  Reducing the size of the graph helps all graph search algorithms.  After that, use the simplest possible algorithm.  Simple queues are faster.  A greedy search is usually faster than the Dijkstra algorithm, but does not provide optimal paths.  For most pathfinding tasks, the best choice is A *. <br><br>  What about using not on cards?  I used maps in the article because I think it is easier to explain the operation of the algorithm.  However, these graph search algorithms can be used on any graphs, not only on game maps, and I tried to present the code of the algorithm in a form that does not depend on two-dimensional grids.  The cost of movement on the maps turns into arbitrary weights of the edges of the graph.  Heuristics are not so easy to transfer to arbitrary maps, it is necessary to create heuristics for each type of graph.  For flat maps, distances are a good choice, so we used them here. <br><br>  I wrote a lot more about finding ways <a href="http://theory.stanford.edu/~amitp/GameProgramming/">here</a> .  Do not forget that searching by graphs is only one part of what you need.  By itself, A * does not handle such aspects as joint movement, moving obstacles, changing the map, estimating dangerous areas, formations, turning radii, object sizes, animation, smoothing of paths, and much more. </div><p>Source: <a href="https://habr.com/ru/post/331192/">https://habr.com/ru/post/331192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331180/index.html">Cloud security: reality or myth?</a></li>
<li><a href="../331182/index.html">The first selection of materials on the digitalization of insurance</a></li>
<li><a href="../331184/index.html">Entertaining layout with viewing area units</a></li>
<li><a href="../331186/index.html">Artem Gavrichenkov's report on TLS scaling</a></li>
<li><a href="../331188/index.html">Our experience with Kubernetes in small projects (review and video report)</a></li>
<li><a href="../331194/index.html">Competence does not have gender: on gender balance and the trend of development of female coding</a></li>
<li><a href="../331196/index.html">Self-sufficient controllers on Xamarin.Forms: "Re-use the code to the maximum!". Part 2</a></li>
<li><a href="../331200/index.html">Augmented Reality for state leaders</a></li>
<li><a href="../331202/index.html">Build a Linux kernel module without accurate header files</a></li>
<li><a href="../331204/index.html">Hackers steal money from banks more often than from their clients</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>