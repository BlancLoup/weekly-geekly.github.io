<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PC Development and Performance - Memory Latency</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Herb Sutter (by Exceptional C ++, former head of the ISO C ++ standards committee, Mr. Free Lunch Is Over and so on and so forth) works at Microsoft a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PC Development and Performance - Memory Latency</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://www.gotw.ca/">Herb Sutter</a> (by Exceptional C ++, former head of the ISO C ++ standards committee, Mr. <a href="http://www.gotw.ca/publications/concurrency-ddj.htm">Free Lunch Is Over</a> and so on and so forth) works at Microsoft and sometimes reads atomic lectures on Wednesdays. <br><br>  I finally got one of these, and was very happy.  Smart men are always happy to look and listen. <br>  For the report - apart from Herb, I saw Oleksandrescu live and Walter Bright live (which is " <a href="http://www.digitalmars.com/d/">D</a> "). <br><br>  The lecture was called ‚ÄúMachine Architecture: Things Your Programming Language Never Told You‚Äù ( <a href="http://www.nwcpp.org/Meetings/2007/09.html">here</a> you can download the presentation and video) and was about a specific part of the abstraction penalty - Memory Latency. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will try to briefly talk about the key idea of ‚Äã‚Äãthe lecture.  It is simple, obvious and said a thousand times.  I think once again repeat the alphabet - it never hurts. <br><a name="habracut"></a><br><br><h4>  For the smallest, what is Latency and Bandwidth </h4><br>  Bandwidth is the width of the channel.  How much data can be pumped per second, how many instructions can be used to fully load the ALU, and so on. <br>  Latency is the length of the channel, that is, after what time the data you asked for will come to you.  After how many clock cycles the requested bit from memory will come to you, after how many clock cycles the result of the instruction will be ready, when the command passes to the end of the pipeline and so on. <br>  And they, of course, affect each other.  As soon as a result is needed, and there is nothing more to be done - the whole bandwidth is idle because of latency.  They requested a memory that is not in the cache - we are sitting, waiting for the memory.  We wanted to follow the instruction that requires the result of the previous one - we are waiting for its implementation.  This creates ‚Äúbubbles‚Äù in the channel and accordingly reduces the load. <br><br>  Herb in the presentation uses the example of the pipeline, it is quite obvious.  You can pump a wild amount of barrels per minute, but each barrel goes to the destination a few days.  In pure bandwidth and latency. <br><br>  A practically important point is that bandwidth is always easy to buy.  Put two processors, take twice as much data from memory, put two computers in the end.  Latency is much more expensive - two women will not give birth to a child in 4.5 months, and it moves only with progress - to increase the frequency, reduce the size of the elements, change the technology, and so on. <br><br><h4>  And now the last 20 plus years show that latency is growing much slower.  Especially - the latency of memory. </h4><br>  Scha, Herb had a sign there ... <br><br><pre>                                 
                     1980 VAX-11/750 Modern Desktop Improvement since 1980 <font></font>
<font></font>
 Clockspeed (MHz) 6 3000 + 500x <font></font>
<font></font>
 Memory size (RAM, MB) 2 2000 + 1000x <font></font>
<font></font>
 Memory bandwidth (MB / s) 13 7000 (read) + 540x <font></font>
<font></font>
                                         2000 (write) + 150x <font></font>
<font></font>
 Memory latency (ns) 225 ~ 70 + 3x <font></font>
<font></font>
 Memory latency (cycles) 1.4 210 -150x (!!!!!!)
</pre><br><br>  From the plate it is clearly seen that the processor grows well, the size of the memory grows well, the bandwidth of the memory is again zashibato, but the latency since the times of VAX has become only three times better.  Per clock cycle (last line) - it has deteriorated 150 times. <br>  Which means that a cache miss is worth orders of magnitude more than even the heaviest processor instructions. <br><br>  In the 80s it was simple and great - the cost of access to memory was quite comparable, if not less, of computational instructions (and in general at the floating point), <br>  There is a processor, a disk and memory, the programmer directly operates on them.  The code runs transparently and predictably to the clock. <br><br>  Now in the gland, in fact, everything is different.  Memory access - hundreds of cycles.  Yes, at a time you can take the whole cache line (32 or 64 bytes), but still wait for hundreds of cycles.  In millisecond, for example, it turns out to go to different places of memory about 10,000 times.  100 objects of different classes, calling 10 virtual functions in each - already 20 +% of a millisecond.  In game devs - very real numbers.  And the memory traffic, generally speaking, is the most important thing that we have. <br><br>  And this is all about memory.  If you climbed to the disk - it is already quite beyond good and evil, there is a latency of tens of millions of cycles. <br><br>  How to treat it is of course a cache and a hierarchy.  L1 - 2 clocks, L2 - 14 clocks, L3 - lets say about 40. Separately for data, separately for instructions. <br>  The complex logic of the cache, the know-how of various manufacturers of processors and so on. <br>  In addition - be sure to out of order, to try to do something that does not depend on waiting. <br>  Out of order execution, register renaming, necessarily powerful branch prediction, be sure to start access and write to memory as early as possible.  If the brunch goes the wrong way, it immediately pulls down out of order and is a disaster. <br>  Again, there is a long conveyor inside.  On P4, it was even pathologically long - up to 25 instructions at a time and out of order looking ahead a hundred.  On the latest processors, the pipeline is smaller, but still opaque. <br><br>  Sutter writes that on Itanium2 the cache occupies 85% of the processor area. <br>  On the Core Duo - I could not google, I think about the same. <br>  Another 10 percent or more is the logic of out of order, branch prediction and other good. <br>  There are only a few percents left on the ALU proper, which actually count something. <br><br>  <strong>A modern processor is not a calculator, but a giant hardware emulator of x86 instructions.</strong> <br>  All this is necessary in order to hide latency from the programmer.  So that you can continue to program in the 80s - when there is only process and memory, and memory can be accessed as often as you like.  To continue to run the old code all the better, so that you can write new as well. <br><br>  And yet - we are trying to hide the speed drop 150 times!  Unnoticed by the programmer!  Without changing its data structures!  So that he did not notice a change in the order of execution of instructions! <br><br>  Of course, this exercise will never be optimal. <br><br>  From the fact that the programmer in a sense lives in the land of elves, Sutter makes two practical consequences. <br><br><h4>  The first is that it affects the correctness of the programs. </h4><br>  Everywhere, where assumptions are made about the sequence of readings-records in memory, in the multithreading favorite by Satter. <br>  If, assuming that the int record in memory is atomic, start making lock free interaction between threads, you will get hurt. <br><br>  For example: <br><br> <code>Thread1: <br> flag1 = 1; <br> if (flag2 != 0) { ‚Ä¶} <br> // enter critical section <br> <br> Thread2: <br> flag2 = 1; <br> if (flag1 != 0) { ‚Ä¶} <br> // enter critical section <br> <br></code> <br><br>  Thread1 first sets flag1 - the flag of what it wants a shared resource, and checks if the second resource is busy with another thread.  It is assumed that flag2 will be checked only after installing flag1 (so as not to enter the critical section if it is occupied by another thread). <br>  And there will be a total translation - memory read on flag1 will happen very early due to out of order (formally, this read does not depend on anything, so it can be done early), and there will be no synchronization. <br>  Therefore, you need to honestly lock.  It is impossible to rely on memory as something that reflects the values ‚Äã‚Äãof variables. <br><br><h4>  The second and most fun - of course, performance. </h4><br>  For a long time, it basically slows down memory.  Mainly due to latency, not bandwidth.  Random reading of memory is much more expensive than a whole cloud of calculations.  Locality matters, on all scales. <br><br>  By the way, what is ‚Äúaccidental‚Äù in a real program is terribly blurred because of the opaque hierarchy of caches. <br>  It seems that if you use a lot, then it will be in the cache.  On the other hand, how much is a real working set at different times - not to estimate it properly. <br>  And it is different on each processor.  And it is extremely dependent on the data.  And the great thing - he still has to die! <br>  I reduced the example to synthetic - it began to fit into the cache.  Hello <br><br>  Fortunately (unfortunately?), The price of a cache-mission is so high that serious problems can be measured through a thick layer. <br>  The speed of random access (measure latency) versus sequential access (measure bandwith) differs by an order of magnitude.  This is the difference between std :: vector vs std :: list. <br>  Worse, it can be the difference between std :: vector &lt;T&gt; vs std :: vector &lt;T *&gt; (this, as everyone knows, and an array of objects in Java or .net). <br><br>  In the end, you should always think about memory.  Both about locality and about costs. <br>  To measure, whether in memory rested.  When in random access - you can productively think and solve.  And when in the footprint - it happens too. <br><br>  At the gamedeff <a href="http://blog.gamedeff.com/%3Fp%3D54">, a</a> good example of such a struggle for locality was described <a href="http://blog.gamedeff.com/%3Fp%3D54">here</a> . <br><br>  But it is still impossible to accurately measure and predict.  Everything is very thick, non-linear and opaque.  Under you works a large machine with incomprehensible logic and, worse, incomprehensible loading.  The network will come to life in the background and will confuse everything.  Or an indexer, God forbid. <br><br><h4>  And I do not know what to do with it in the PC world </h4><br>  Forgive me, I wrote only games from applications and I will reason and compare platforms only using the example of my favorite game dev. <br><br>  On the one hand, I want more control.  Have a clear place in the cache where I can have guaranteed access time.  To have certain guarantees that I will not be spoiled by the cache at the first context switch. <br>  For example, it is easy to talk about how well everything is in the console world, where a completely different iron.  SPU, 256 kb fully managed very fast local memory, clear requests to main memory with wide (to hide latency) DMA packages.  Or Xbox360, where you can lock part of the cache for a while, and even ask the GPU to render from it. <br>  None of these models will heal on a PC in its pure form. <br>  On one processor, there is a multitude of threads simultaneously, if everyone manages 256 kilobytes of memory, then with a context switch, it must be completely unloaded and loaded.  There will be a heavy and long context switch, and typically in the OS, well, just dofig even semi-active threads. <br>  Lock cache cannot be allowed for the same reasons - it means either to buffer it into memory during a context switch, or to take it away from other applications forever.  If they take even active ones, the rest will slow down. <br><br>  Worse, the basic applications are without any upper bounds.  Can download the document and 10 kilobytes, and 100 megabytes.  The size of an Excel spreadsheet can differ thousands of times, no upper bounds on memory, as on the console - you can‚Äôt put it. <br><br>  And the iron set, and the amount of memory is always different, the target is viscous - ‚Äúeat less memory and work faster‚Äù.  And iron emulates more than it works. <br><br>  The life of one application in a system on a fixed iron without backward compatibility is fundamentally different from the life of a cloud of heterogeneous on an unspecified gland, with the old code and other requirements.  The further I look, the more I think that different worlds. <br><br>  And this is a small part of the problems.  I would say, the fundamental is backward compatibility and a completely different balance on performance than development costs on consoles.  But you can write about this infinitely a lot later. <br><br>  Finally, a brief meditative tifirki (I took from my home machine): <br><br>  floating point mul: 0.5-4 cycles (on one core) <br>  L1 access (~ 16-32 kb): ~ 2-3 cycles <br>  L2 access (~ 2-4 mb): ~ 15 cycles <br>  Random Memory Access: ~ 200 cycles <br>  Sequential Access with Prefetch: ~ 2 bytes / cycle <br><br>  It remains to fight, men.  Understand the price of abstraction and at this level, do not allow the brain to relax and live in the eighties. <br></div><p>Source: <a href="https://habr.com/ru/post/43905/">https://habr.com/ru/post/43905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../43896/index.html">Original gameplay ideas</a></li>
<li><a href="../43897/index.html">How to make the computer obey the person, and not vice versa</a></li>
<li><a href="../43898/index.html">Template + jQuery + MVC = jsMVC</a></li>
<li><a href="../43899/index.html">SMS service for Gmail</a></li>
<li><a href="../43901/index.html">About Leadership and Management</a></li>
<li><a href="../43912/index.html">Glavpoker - social network of poker players</a></li>
<li><a href="../43913/index.html">KNetworkManager 0.7 and Kubuntu 8.04</a></li>
<li><a href="../43915/index.html">Manage achievements</a></li>
<li><a href="../43916/index.html">Check your nickname in popular services</a></li>
<li><a href="../43919/index.html">Touch candy bar Eee Top</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>