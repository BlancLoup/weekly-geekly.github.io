<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a function on Rust that returns a String or & str</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
  This is the last article from the series on working with strings and memory in Rust by Herman Radtke, which I translate. It seemed ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a function on Rust that returns a String or & str</h1><div class="post__text post__text-html js-mediator-article"><h3>  From translator </h3><br> <a href="http://habrahabr.ru/post/274565/"><img src="https://habrastorage.org/files/6b8/cb6/a67/6b8cb6a67c1a45e7b803703a89846a2f.png" alt="" title="KDPV" align="right"></a>  This is the last article from the series on working with strings and memory in Rust by Herman Radtke, which I translate.  It seemed to me the most useful, and initially I wanted to start translating from it, but then it seemed to me that the rest of the articles in the series are also needed to create a context and an introduction to simpler, but very important, moments of the language, without which this article loses its utility. <br><hr><br>  We learned how <a href="http://habrahabr.ru/post/274455/">to create a function that takes a String or &amp; str</a> ( <a href="http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html">English</a> ) as an argument.  Now I want to show you how to create a function that returns a <code>String</code> or <code>&amp;str</code> .  I also want to discuss why we may need it. <br><a name="habracut"></a><br>  To begin, let's write a function that removes all spaces from a given string.  Our function might look something like this: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_spaces</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::with_capacity(input.len()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input.chars() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c != <span class="hljs-string"><span class="hljs-string">' '</span></span> { buf.push(c); } } buf }</code> </pre><br><br>  This function allocates memory for the string buffer, traverses all the characters in the <code>input</code> string, and adds all non-whitespace characters to the <code>buf</code> buffer.  Now the question is: what if there is not a single space at the input?  Then the <code>input</code> value will be exactly the same as <code>buf</code> .  In this case, it would be more efficient not to create <code>buf</code> at all.  Instead, we would simply like to return the given <code>input</code> back to the user of the function.  The <code>input</code> type is <code>&amp;str</code> , but our function returns a <code>String</code> .  We could change the <code>input</code> type to <code>String</code> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_spaces</span></span></span></span>(input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { ... }</code> </pre><br>  But there are two problems.  First, if the <code>input</code> becomes <code>String</code> , the user of the function will have to <i>transfer the</i> ownership of the <code>input</code> to our function, so that he will not be able to work with the same data in the future.  We should take possession of <code>input</code> only if we really need it.  Secondly, the input may already be <code>&amp;str</code> , and then we force the user to convert the string to a <code>String</code> , nullifying our attempt to avoid allocating memory for <code>buf</code> . <br><br><h3>  Write cloning </h3><br>  In fact, we want to be able to return our input string ( <code>&amp;str</code> ) if there are no spaces in it, and a new string ( <code>String</code> ) if there are spaces and we need to remove them.  This is where the type of copy-on-write ( <i>c</i> lone- <i>o</i> n- <i>w</i> rite) <a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html">Cow</a> comes to the rescue.  The <code>Cow</code> type allows us to abstract away from whether we own the variable ( <code>Owned</code> ) or we just borrow it ( <code>Borrowed</code> ).  In our example, <code>&amp;str</code> is a link to an existing string, so this will be <i>borrowed</i> data.  If the string has spaces, we need to allocate memory for the new <code>String</code> .  The variable <code>buf</code> <i>owns</i> this string.  In the usual case, we would <i>move the</i> ownership of <code>buf</code> , returning it to the user.  When using <code>Cow</code> we want to <i>move</i> the <code>buf</code> ownership to the <code>Cow</code> type and then return it. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::borrow::Cow; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_spaces</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; Cow&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.contains(<span class="hljs-string"><span class="hljs-string">' '</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::with_capacity(input.len()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input.chars() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c != <span class="hljs-string"><span class="hljs-string">' '</span></span> { buf.push(c); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cow::Owned(buf); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cow::Borrowed(input); }</code> </pre><br>  Our function checks whether the original <code>input</code> argument contains at least one space, and only then allocates memory for the new buffer.  If there are no spaces in <code>input</code> , then it is simply returned as is.  We add a bit of <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D0%25BE%25D0%25B2">complexity at runtime</a> to optimize memory handling.  Please note that our type of <code>Cow</code> the same lifetime as that of <code>&amp;str</code> .  As we said earlier, the compiler needs to track the use of the <code>&amp;str</code> reference in order to know when it is safe to free up memory (or call the destructor method if the type implements <code>Drop</code> ). <br><br>  The beauty of the <code>Cow</code> is that it implements the <code>Deref</code> type, so you can call on the methods that do not change these methods without even knowing if a new buffer is allocated for the result.  For example: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = remove_spaces(<span class="hljs-string"><span class="hljs-string">"Herman Radtke"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">" : {}"</span></span>, s.len());</code> </pre><br>  If I need to change <code>s</code> , then I can convert it to the <i>owning</i> variable using the <code>into_owned()</code> method.  If the <code>Cow</code> contains borrowed data (the <code>Borrowed</code> option is selected), memory allocation will occur.  This approach allows us to clone (that is, allocate memory) lazily only when we really need to write (or change) into a variable. <br><br>  Example with editable <code>Cow::Borrowed</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = remove_spaces(<span class="hljs-string"><span class="hljs-string">"Herman"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// s   Cow::Borrowed let len = s.len(); //         Deref let owned: String = s.into_owned(); //      String</span></span></code> </pre><br>  Example with editable <code>Cow::Owned</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = remove_spaces(<span class="hljs-string"><span class="hljs-string">"Herman Radtke"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// s   Cow::Owned let len = s.len(); //         Deref let owned: String = s.into_owned(); //    ,      String</span></span></code> </pre><br>  The idea behind <code>Cow</code> as follows: <br><br><ul><li>  Postpone memory allocation for as long as possible.  At best, we will never allocate a new memory. </li><li>  To enable the user of our function <code>remove_spaces</code> not to worry about memory allocation.  Using <code>Cow</code> will be the same anyway (whether new memory will be allocated or not). </li></ul><br><h3>  Using Into Type </h3><br>  We used to talk about using the <a href="http://habrahabr.ru/post/274455/">type of Into</a> ( <a href="http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html">English</a> ) to convert <code>&amp;str</code> to <code>String</code> .  Similarly, we can use it to convert a <code>&amp;str</code> or <code>String</code> into the desired <code>Cow</code> variant.  Calling <code>.into()</code> will cause the compiler to choose the correct conversion option automatically.  Using <code>.into()</code> doesn't slow down our code at all; it's just a way to get rid of the explicit indication of the <code>Cow::Owned</code> or <code>Cow::Borrowed</code> option. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_spaces</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; Cow&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.contains(<span class="hljs-string"><span class="hljs-string">' '</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::with_capacity(input.len()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; = input.chars().collect(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c != <span class="hljs-string"><span class="hljs-string">' '</span></span> { buf.push(c); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf.into(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.into(); }</code> </pre><br>  And finally, we can slightly simplify our example using iterators: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_spaces</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; Cow&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.contains(<span class="hljs-string"><span class="hljs-string">' '</span></span>) { input .chars() .filter(|&amp;x| x != <span class="hljs-string"><span class="hljs-string">' '</span></span>) .collect::&lt;std::string::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;() .into() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { input.into() } }</code> </pre><br><h3>  Real use of Cow </h3><br>  My example of removing spaces seems a bit far-fetched, but in real code this strategy also finds use.  In the Rust core there is a function that <a href="">converts bytes to a UTF-8 string with the loss of invalid combinations of bytes</a> , and a function that <a href="">translates the end of the lines from CRLF to LF</a> .  For both of these functions, there is a case in which you can return <code>&amp;str</code> in the optimal case, and a less optimal case that requires memory allocation under <code>String</code> .  Other examples that come to my mind: encoding a string into valid XML / HTML or correctly escaping special characters in a SQL query.  In many cases, the input data is already correctly encoded or shielded, and then it is better to simply return the input string back as is.  If the data needs to be changed, then we will have to allocate memory for the string buffer and return it already. <br><br><h3>  Why use String :: with_capacity ()? </h3><br>  While we are talking about efficient memory management, note that I used <code>String::with_capacity()</code> instead of <code>String::new()</code> when creating the string buffer.  You can use <code>String::new()</code> instead of <code>String::with_capacity()</code> , but it is much more efficient to allocate all the required memory for the buffer at once, rather than re-allocating it as we add new characters to the buffer. <br><br>  <code>String</code> is actually a <code>Vec</code> vector from UTF-8 code points.  When calling <code>String::new()</code> Rust creates a zero-length vector.  When we put the character <code>a</code> in the string buffer, for example using <code>input.push('a')</code> , Rust should increase the capacity of the vector.  To do this, it will allocate 2 bytes of memory.  When we further put characters into the buffer, when we exceed the allocated amount of memory, Rust doubles the size of the line, re-allocating the memory.  He will continue to increase the capacity of the vector each time it is exceeded.  The sequence of allocated capacity is: <code>0, 2, 4, 8, 16, 32, ‚Ä¶, 2^n</code> , where n is the number of times Rust has detected that the allocated memory has been exceeded.  Re-allocating memory is very slow (correction: kmc_v3 <a href="http://www.reddit.com/r/rust/comments/37q8sr/creating_a_rust_function_that_returns_a_str_or/croylbu">explained</a> that it may not be as slow as I thought).  Rust not only has to ask the kernel to allocate new memory, it also has to copy the contents of the vector from the old memory to the new one.  Take a look at the source code of <a href="">Vec :: push</a> to see for yourself the logic of vector resizing. <br><br><div class="spoiler">  <b class="spoiler_title">Clarification on re-allocating memory from kmc_v3</b> <div class="spoiler_text">  It may not be so bad because: <br><br><ul><li>  Any decent allocator requests memory from the OS in large chunks, and then gives it to users. </li><li>  Any decent multi-threaded memory allocator also supports caches for each thread, so you don‚Äôt need to synchronize access to it all the time. </li><li>  Very often, you can increase the allocated memory in place, and in such cases there will be no data copying.  Maybe you allocated only 100 bytes, but if the next thousand bytes are free, the allocator will simply give them to you. </li><li>  Even in the case of copying, <a href="https://www.opennet.ru/man.shtml%3Ftopic%3Dmemcpy%26category%3D3%26russian%3D0"><code>memcpy</code></a> byte copying is used, with a completely predictable way of accessing memory.  So this is probably the most efficient way to move data from memory to memory.  The libc system library typically includes <code>memcpy</code> optimizations for your particular micro-architecture. </li><li>  You can also ‚Äúmove‚Äù large allocated chunks of memory using the <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BB%25D0%25BE%25D0%25BA_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C%25D1%258E">MMU</a> reconfiguration, which means you need to copy only one page of data.  However, typically changing page tables has a large fixed cost, so the method is only suitable for very large vectors.  I'm not sure that <code>jemalloc</code> in Rust makes such optimizations. </li></ul><br>  Changing the size of <code>std::vector</code> in C ++ can be very slow due to the fact that you need to call the displacement constructors individually for each element, and they can throw an exception. </div></div><br>  In general, we want to allocate a new memory only when it is needed, and exactly as much as necessary.  For short strings, such as <code>remove_spaces("Herman Radtke")</code> , the overhead of re-allocating memory does not play a big role.  But what if I want to remove all spaces in all JavaScript files on my site?  Overhead for re-allocating buffer memory will be much more.  When placing data into a vector ( <code>String</code> or whatever), it is very useful to specify the size of memory that will be required when creating the vector.  At best, you know the desired length in advance, so that the capacity of the vector can be set exactly.  <a href="">Comments to the code</a> <code>Vec</code> warn about the same. <br><br><h3>  What else to read? </h3><br><ul><li>  <a href="http://habrahabr.ru/post/274485/"><code>String</code> or <code>&amp;str</code> in Rust functions</a> ( <a href="http://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html">original</a> ) </li><li>  <a href="http://habrahabr.ru/post/274455/">Creating a function on Rust that accepts a <code>String</code> or <code>&amp;str</code></a> ( <a href="http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html">original</a> ) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/274565/">https://habr.com/ru/post/274565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274555/index.html">PayPal API Go Client</a></li>
<li><a href="../274557/index.html">Sitemap.xml or ‚ÄúThere was nothing to do ...‚Äù</a></li>
<li><a href="../274559/index.html">Google fixed Android vulnerabilities</a></li>
<li><a href="../274561/index.html">New from Google. Is authentication safe without entering a password?</a></li>
<li><a href="../274563/index.html">Firefox will support non-standard CSS for compatibility with WebKit</a></li>
<li><a href="../274567/index.html">Why is functional programming mainstream?</a></li>
<li><a href="../274569/index.html">Parallelism vs Concurrency: choosing the right tools</a></li>
<li><a href="../274571/index.html">We write in Java in Arduino</a></li>
<li><a href="../274573/index.html">Sunrise developeromics (ending)</a></li>
<li><a href="../274575/index.html">IBM continues to work with Apache Spark: corporation launches Spark-as-a-service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>