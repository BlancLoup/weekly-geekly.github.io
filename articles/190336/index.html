<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python inside. Objects Tail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 
 2. Objects. Head 
 3. Objects. Tail 
 4. Process structures 

 In the previous part, we began to study the object system of Python: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python inside. Objects Tail</h1><div class="post__text post__text-html js-mediator-article"><a href="http://www.flickr.com/photos/pnut83/5667632257/"><img src="https://habrastorage.org/getpro/habr/post_images/b74/1eb/407/b741eb4072b270b1af70d2299db81a21.jpg" align="left"></a>  1. <a href="http://habrahabr.ru/post/189972/">Introduction</a> <br>  2. <a href="http://habrahabr.ru/post/189986/">Objects.</a>  <a href="http://habrahabr.ru/post/189986/">Head</a> <br>  3. <b>Objects.</b>  <b>Tail</b> <br>  4. <a href="http://habrahabr.ru/post/191032/">Process structures</a> <br><br>  <i>In the <a href="http://habrahabr.ru/post/189986/">previous part,</a> we began to study the object system of Python: we understood what exactly can be considered an object and how objects perform their work.</i>  <i>We continue consideration of the issue.</i> <br><br>  Greetings to you in the third part of our series of articles on the internals of Python (I strongly recommend reading the second part, if you have not done this yet, otherwise you will not understand anything).  In this episode, we will talk about an important concept, which we still cannot find, about attributes.  If you ever wrote anything on the Python, then you had to use them.  Object attributes are other objects associated with it that are accessible through an operator <code>.</code>  (dot), for example: <code>&gt;&gt;&gt; my_object.attribute_name</code> .  We briefly describe the behavior of Python when referring to attributes.  This behavior depends on the type of object that is accessible by attribute (have you already understood that this applies to all operations related to objects?). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the type, you can describe special methods that modify access to the attributes of its instances.  These methods are described <a href="http://docs.python.org/3/reference/datamodel.html">here</a> (as we already know, they will be associated with the necessary slots of the type by the <code>fixup_slot_dispatchers</code> function, where the type is created ... you <i>read the</i> <a href="http://habrahabr.ru/post/189986/">previous post</a> , right?).  These methods can do anything;  Whether you describe your type in C or in Python, you can write methods that save and return attributes from some incredible storage, if you like, you can send and receive attributes on the radio from the ISS or even store them in relational database.  But in more or less ordinary conditions, these methods simply write an attribute as a key-value pair (attribute name / attribute value) in an object's dictionary when the attribute is set, and return an attribute from this dictionary when it is requested (or an exception is thrown <code>AttributeError</code> , if the dictionary does not have a key corresponding to the name of the requested attribute).  It's all so simple and beautiful, thank you for your attention, perhaps we‚Äôll end it. <br><br>  <i>Stand</i> !  My friends, the fecal masses have just begun their rapid approach to the rotating wind generator.  To disappear, so to all to disappear.  I propose to jointly study what is happening in the interpreter and ask, as we usually do, some annoying questions. <br><a name="habracut"></a><br>  We read carefully the code or go directly to the text description: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>print(object.__dict__) {<span class="hljs-string"><span class="hljs-string">'__ne__'</span></span>: &lt;slot wrapper <span class="hljs-string"><span class="hljs-string">'__ne__'</span></span> of <span class="hljs-string"><span class="hljs-string">'object'</span></span> objects&gt;, ... , <span class="hljs-string"><span class="hljs-string">'__ge__'</span></span>: &lt;slot wrapper <span class="hljs-string"><span class="hljs-string">'__ge__'</span></span> of <span class="hljs-string"><span class="hljs-string">'object'</span></span> objects&gt;} &gt;&gt;&gt; object.__ne__ <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> object.__dict__[<span class="hljs-string"><span class="hljs-string">'__ne__'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; o = object() &gt;&gt;&gt; o.__class__ &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">'&gt; &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oa</span></span></span><span class="hljs-class"> = 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traceback</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(most recent call last)</span></span></span><span class="hljs-class">:</span></span> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AttributeError: <span class="hljs-string"><span class="hljs-string">'object'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'a'</span></span> &gt;&gt;&gt; o.__dict__ Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AttributeError: <span class="hljs-string"><span class="hljs-string">'object'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'__dict__'</span></span> &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> ... A = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; C.__dict__[<span class="hljs-string"><span class="hljs-string">'A'</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; CA <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; o2 = C() &gt;&gt;&gt; o2.a = <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; o2.__dict__ {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} &gt;&gt;&gt; o2.__dict__[<span class="hljs-string"><span class="hljs-string">'a2'</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; o2.a2 <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; C.__dict__[<span class="hljs-string"><span class="hljs-string">'A2'</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'dict_proxy'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment &gt;&gt;&gt; C.A2 = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; C.__dict__[<span class="hljs-string"><span class="hljs-string">'A2'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> C.A2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; type(C.__dict__) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> type(o2.__dict__) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; type(C.__dict__) &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dict_proxy</span></span></span><span class="hljs-class">'&gt; &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(o2.__dict__)</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dict</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre><br>  Let's translate this into a human language: <code>object</code> (this is the simplest built-in type, if you forget), as we can see, has a dictionary, and everything we can access through attributes is identical to what we see in <code>object.__dict__</code> .  It should surprise us that <i>instances of type <code>object</code> (for example, object <code>o</code> ) do not support the definition of additional attributes and do not have <code>__dict__</code> at all, but do support access to the existing attributes</i> (try <code>o.__class__</code> , <code>o.__hash__</code> , etc.; these commands allow then <i>return</i> ).  After that we created a new <code>C</code> class, inherited it from <code>object</code> , added attribute <code>A</code> and saw that it is accessible through <code>CA</code> and <code>C.__dict__['A']</code> , as expected.  Then we created an instance of class <code>o2</code> <code>C</code> and saw that the attribute definition changes <code>__dict__</code> , and vice versa, the change in <code>__dict__</code> affects the attributes.  Afterwards, we were surprised to find out that the <i><code>__dict__</code> class is read-only, although the definition of attributes ( <code>C.A2</code> ) works great</i> .  Finally, we saw that <i>the <code>__dict__</code> objects of the instance and class are of different types</i> - the usual <code>dict</code> and the mysterious <code>dict_proxy</code> respectively.  And if all this is not enough, remember the puzzle from the previous part: if the heirs of a pure <code>object</code> (for example, <code>o</code> ) do not have <code>__dict__</code> , and <code>C</code> expands the <code>object</code> without adding anything significant, then <i>suddenly instances of class <code>C</code> ( <code>o2</code> ) have <code>__dict__</code></i> ? <br><br>  Yeah, everything is strange and strange!  But do not worry, everything has its time.  First, consider the implementation of <code>__dict__</code> type.  If you look at the definition of <a href=""><code>PyTypeObject</code></a> (I strongly recommend reading!), You can see the slot <code>tp_dict</code> , ready to accept a pointer to a dictionary.  This slot should be in all types.  The dictionary is placed there when calling <a href=""><code>./Objects/typeobject.c</code></a> : <code>PyType_Ready</code> , which occurs when the interpreter is initialized (remember <code>Py_Initialize</code> ? This function calls <code>_Py_ReadyTypes</code> , which calls <code>PyType_Ready</code> for all known types), or when the user dynamically creates a new type ( <code>type_new</code> calls <code>PyType_Ready</code> for each newborn type before returning).  In fact, each name that you specify in the <code>class</code> statement appears in <code>__dict__</code> new type (line <a href=""><code>./Objects/typeobject.c</code></a> : <code>type_new</code> : <code>type-&gt;tp_dict = dict = PyDict_Copy(dict);</code> ).  Do not forget that types are also objects, i.e.  they also have a type - <code>type</code> , which has slots with functions that provide access to attributes as needed.  These functions use a dictionary that each type has and that <code>tp_dict</code> points to for storing / accessing attributes.  Thus, a call to type attributes is, in fact, a call to the private dictionary of an instance of <code>type</code> , which is indicated by the type structure. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">:</span></span> bar = <span class="hljs-string"><span class="hljs-string">"baz"</span></span> print(Foo.bar)</code> </pre><br>  In this example, the last line demonstrates a call to a type attribute.  In this case, to find the <code>bar</code> attribute, the function of accessing the attributes of the class <code>Foo</code> (pointed to by <a href="http://docs.python.org/3/c-api/typeobj.html"><code>tp_getattro</code></a> ) will be called.  Approximately the same thing happens when defining and deleting attributes (for the interpreter, by the way, ‚Äúdeletion‚Äù is just setting the value to <code>NULL</code> ).  I hope, until now everything was clear, and in the meantime we discussed the appeal to the attributes. <br><br>  Before we consider accessing the attributes of instances, let me say a little-known (but very important!) Concept: a <b>descriptor</b> .  Descriptors play a special role in accessing instance attributes, and I need to clarify what it is.  An object is considered to be a descriptor if one or two slots of its type ( <code>tp_descr_get</code> and / or <code>tp_descr_set</code> ) are filled with non-zero values.  These slots are associated with the special methods <code>__get__</code> , <code>__set__</code> and <code>__delete__</code> (for example, if you define a class with the <code>__get__</code> method that <code>__get__</code> slot and create an object of this class, then this object will be a descriptor).  Finally, an object is considered a <b>data descriptor</b> if the <code>tp_descr_set</code> slot is filled with a nonzero value.  As we will see, descriptors play an important role in accessing attributes, and I will give some explanations and links to the necessary documentation. <br><br>  So, we figured out what descriptors are, and understood how type attributes are accessed.  But most objects are not types, i.e.  their type is not <code>type</code> , but something more prosaic, for example, <code>int</code> , <code>dict</code> or a custom class.  All of them rely on universal attribute access functions that are either defined in the type or inherited from the type parent when it was created (this topic, slot inheritance, we discussed in the ‚Äú <a href="http://habrahabr.ru/post/189986/">Head</a> ‚Äù).  The algorithm of the universal function of accessing attributes ( <a href="http://docs.python.org/3/c-api/object.html">PyObject_GenericGetAttr</a> ) looks like this: <br><br><ol><li>  Search in the instance type dictionary and in dictionaries of all parents of the type.  If a <i>data descriptor is</i> found, call its <code>tp_descr_get</code> function and return the result.  If something else is found, remember this just in case (for example, under the name <i>X</i> ). </li><li>  Search the object's dictionary and return the result if it is found. </li><li>  If nothing was found in the object dictionary, check <i>X</i> if it was installed;  if <i>X</i> is a descriptor, call its <code>tp_descr_get</code> function and return the result.  If <i>X</i> is a regular object, return it. </li><li>  Finally, if nothing was found, throw an <code>AttributeError</code> exception. </li></ol><br>  Now we understand that descriptors can execute code when accessed as attributes (that is, when you write <code>foo = oa</code> or <code>oa = foo</code> , <b><code>a</code></b> executes the code).  Powerful functionality that is used to implement some of the "magic" features of Python.  Data descriptors are even more powerful because they take precedence over instance attributes (if you have an object <code>o</code> class <code>C</code> , class <code>C</code> has a data descriptor <code>foo</code> , and <code>o</code> has an attribute <code>foo</code> , then when executing <code>o.foo</code> result will return a descriptor).  Read what descriptors are and <a href="http://docs.python.org/3/reference/datamodel.html">how</a> .  I especially recommend the first link (‚Äúwhat‚Äù) - despite the fact that at first it was discouraging, after attentive and thoughtful reading you will understand that it is much simpler and shorter than my talk.  It is also worth reading <a href="https://www.google.ru/search%3Fq%3DRaymond%2BHettinger">Raymond Hettinger's</a> amazing article that <a href="http://users.rcn.com/python/download/Descriptor.htm">describes</a> descriptors in Python 2.x;  With the exception of <a href="http://docs.python.org/3/whatsnew/3.0.html">removing</a> unrelated methods, the article is still relevant for version 3.x and is recommended to be read.  Descriptors are a very important concept, and I advise you to devote some time to studying the listed resources in order to understand them and get into the idea.  Here, for the sake of brevity, I will no longer go into details, but I will give an example ( <i>very</i> simple) of their behavior in the interpreter: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoutingInteger</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(int)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-comment"><span class="hljs-comment"># __get__   tp_descr_get ... def __get__(self, instance, owner): ... print('I was gotten from %s (instance of %s)' ... % (instance, owner)) ... return self ... &gt;&gt;&gt; class Foo: ... Shouting42 = ShoutingInteger(42) ... &gt;&gt;&gt; foo = Foo() &gt;&gt;&gt; 100 - foo.Shouting42 I was gotten from &lt;__main__.Foo object at 0xb7583c8c&gt; (instance of &lt;class __main__.'foo'&gt;) 58 # :     ! &gt;&gt;&gt; foo.Silent666 = ShoutingInteger(666) &gt;&gt;&gt; 100 - foo.Silent666 -566 &gt;&gt;&gt;</span></span></code> </pre><br>  Note that we have just gained a complete understanding of object-oriented inheritance in Python:  the attribute search starts with the object type, and then in all parents, we understand that accessing the attribute <code>A</code> object <code>O</code> class <code>C1</code> , which is inherited from <code>C2</code> , which in turn inherits from <code>C3</code> , can return <code>A</code> from <code>O</code> , <code>C1</code> , and <code>C2</code> and <code>C3</code> , which is determined by a certain order of resolution methods, which is described well <a href="http://www.python.org/download/releases/2.3/mro">here</a> .  This way of attribute resolution together with inheritance of slots is enough to explain most of the inheritance functionality in Python (although the devil, as usual, is in the details). <br><br>  We have learned a lot today, but it is still unclear where references to object dictionaries are stored.  We have already seen the definition of <a href="http://docs.python.org/3/c-api/structures.html">PyObject</a> , and there definitely is no pointer to a similar dictionary.  If not there, then where?  The answer is rather unexpected.  If you look closely at <code>PyTypeObject</code> (this is a useful pastime! Read daily!), You can see a field called <a href="http://docs.python.org/3/c-api/typeobj.html">tp_dictoffset</a> .  This field specifies the byte offset in C-structures allocated for type instances;  At this offset is a pointer to a regular Python dictionary.  Under normal conditions, when creating a new type, the size of the type of memory plots required for instances will be calculated, and this size will be larger than that of the pure <code>PyObject</code> .  Additional space is usually used (among other things) to store the pointer to the dictionary (all this happens in <a href=""><code>./Objects/typeobject.c</code></a> : <code>type_new</code> , read from the line <code>may_add_dict = base-&gt;tp_dictoffset == 0;</code> ).  <a href="http://tech.blog.aknin.name/metablogging/tools/">Using <code>gdb</code></a> , we can easily break into this space and look at the object's private dictionary: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; o = C() &gt;&gt;&gt; o.foo = <span class="hljs-string"><span class="hljs-string">'bar'</span></span> &gt;&gt;&gt; o &lt;__main__.C object at <span class="hljs-number"><span class="hljs-number">0x846b06c</span></span>&gt; &gt;&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">#   GDB Program received signal SIGTRAP, Trace/breakpoint trap. 0x0012d422 in __kernel_vsyscall () (gdb) p ((PyObject *)(0x846b06c))-&gt;ob_type-&gt;tp_dictoffset $1 = 16 (gdb) p *((PyObject **)(((char *)0x846b06c)+16)) $3 = {u'foo': u'bar'} (gdb)</span></span></code> </pre><br>  We created a new class, an object and defined an attribute for it ( <code>o.foo = 'bar'</code> ), entered <code>gdb</code> , <code>tp_dictoffset</code> object type ( <code>C</code> ) and found it <code>tp_dictoffset</code> (16), and then checked what is located on this offset in C-structure of the object.  Not surprisingly, we found an object dictionary with a single key, <code>foo</code> , indicating the value of <code>bar</code> .  Naturally, if you check the <code>tp_dictoffset</code> type that does not have <code>__dict__</code> , for example, an <code>object</code> , then we find zero there.  Goosebumps, huh? <br><br>  The fact that type dictionaries and instance dictionaries are similar, but their implementations differ a lot, can be confusing.  There are still a few mysteries.  Let's summarize and determine what we missed: define an empty class <code>C</code> inherited from <code>object</code> , create an object <code>o</code> this class, allocate additional memory for the pointer to the dictionary by offset <code>tp_dictoffset</code> (the space is allocated from the very beginning, but the dictionary is allocated only at the first (any) appeal; here is a trap ...).  Then we execute in the interpreter <code>o.__dict__</code> , compiles the byte code with the <code>LOAD_ATTR</code> command, which calls the <code>PyObject_GetAttr</code> function, which dereferences the object type <code>o</code> and finds the <code>tp_getattro</code> slot, which starts the standard attribute search process described above and implemented in <code>PyObject_GenericGetAttr</code> .  In the end, after all this happens, <i>what</i> does the dictionary of our object return?  We know <i>where</i> the dictionary is stored, but you can see that <code>__dict__</code> doesn‚Äôt have him, so there is a chicken and egg problem: what does the dictionary give us when we turn to <code>__dict__</code> if it‚Äôs not in the dictionary itself? <br><br>  Something that has priority over an object's dictionary is a handle.  See: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; o = C() &gt;&gt;&gt; o.__dict__ {} &gt;&gt;&gt; C.__dict__[<span class="hljs-string"><span class="hljs-string">'__dict__'</span></span>] &lt;attribute <span class="hljs-string"><span class="hljs-string">'__dict__'</span></span> of <span class="hljs-string"><span class="hljs-string">'C'</span></span> objects&gt; &gt;&gt;&gt; type(C.__dict__[<span class="hljs-string"><span class="hljs-string">'__dict__'</span></span>]) &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getset_descriptor</span></span></span><span class="hljs-class">'&gt; &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">['</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">'].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(o, C)</span></span></span><span class="hljs-class"> {} &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">['</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">'].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(o, C)</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">True</span></span></span><span class="hljs-class"> &gt;&gt;&gt;</span></span></code> </pre><br>  Wow!  You can see that there is something called <code>getset_descriptor</code> (a <a href=""><code>./Objects/typeobject.c</code></a> file), a certain group of functions that implements the descriptor protocol, and which must be in a <code>__dict__</code> type object.  This descriptor will intercept all attempts to access <code>o.__dict__</code> objects of this type and return everything that it wants, in our case, it will be a pointer to the dictionary by offset <code>tp_dictoffset</code> to <code>o</code> .  This also explains why we saw <code>dict_proxy</code> bit earlier.  If <code>tp_dict</code> is a pointer to a simple dictionary in <code>tp_dict</code> , why do we see it wrapped in an object to which it is impossible to write something?  This makes the <code>__dict__</code> type descriptor <code>type</code> . <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>type(C) &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">'&gt; &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(C)</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">['</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">'] &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">' </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">' </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">objects</span></span></span><span class="hljs-class">&gt; &gt;&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(C)</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">['</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__dict__</span></span></span><span class="hljs-class">'].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(C, type)</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dict_proxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xb767e494</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br>  This handle is a function that wraps the dictionary with a simple object that simulates the behavior of a regular dictionary, except that it is read-only.  Why is it so important to prevent user intervention in the <code>__dict__</code> type?  Because the namespace can contain special methods, for example <code>__sub__</code> .  When we create a type with special methods, or when we define them for a type through attributes, the <code>update_one_slot</code> function is <code>update_one_slot</code> , which connects these methods with slots of the type, for example, as it happened with the subtraction operation in a previous post.  If we could add these methods directly to the <code>__dict__</code> type, they would not be associated with slots, and we would get a type similar to what we need (for example, it has <code>__sub__</code> in the dictionary), but which behaves differently . <br><br>  We have long crossed the line in 2000 words, for which the reader's attention is rapidly fading away, but I still have not told about <code>__slots__</code> .  How about <a href="http://docs.python.org/3/reference/datamodel.html">self-</a> reading, daredevils?  You have everything in place to deal with them alone!  Read the document at the specified link, play a little with <code>__slots__</code> in the interpreter, look at the sources and search them through <code>gdb</code> .  Enjoy.  In the next series, I think we will leave objects for some time and talk about the <b>state of the interpreter</b> and the <b>state of the stream</b> .  I hope it will be interesting.  But even if it does not, it is still necessary to know.  What I can say for sure is that girls terribly like guys who are knowledgeable in such matters. <br><br>  <i>And you know what?</i>  <i>Not just girls.</i>  <i><a href="http://buruki.ru/">We</a> also like these guys.</i>  <i><a href="http://hantim.ru/jobs/21698-python-django-razrabotchik">Come</a> - together more fun.</i> </div><p>Source: <a href="https://habr.com/ru/post/190336/">https://habr.com/ru/post/190336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190324/index.html">Good localization: mission impossible</a></li>
<li><a href="../190326/index.html">Is it a quine?</a></li>
<li><a href="../190328/index.html">SPO as a means of cooperation between the authors of ideas of the subject area and software manufacturers</a></li>
<li><a href="../190330/index.html">The digest of news from the world of mobile payments # 3</a></li>
<li><a href="../190332/index.html">Convenient interface Habra? # 2</a></li>
<li><a href="../190338/index.html">Superfast copying / pasting code snippets</a></li>
<li><a href="../190340/index.html">Mail.Ru for business, part 2: how it works</a></li>
<li><a href="../190342/index.html">Understanding the types of services in AngularJS (constant, value, factory, service, provider)</a></li>
<li><a href="../190346/index.html">Lemming sculpture from DMA Design opened in Dundee (Scotland)</a></li>
<li><a href="../190348/index.html">Arkanoid with a joystick on the phone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>