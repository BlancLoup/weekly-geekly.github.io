<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C / C ++: how to measure CPU time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="KDPV 


 From the translator: 
 Most of my friends use chrono or, in particularly advanced cases, ctime to measure time in different types of benchmar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C / C ++: how to measure CPU time</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/e1e/3f2/6aa/e1e3f26aaea64501ac8d44dc4d1ab87d.jpg" alt="image"><br>  <em>KDPV</em> </p><br><p> <em><strong>From the translator:</strong></em> <em><br></em>  <em>Most of my friends use <code>chrono</code> or, in particularly advanced cases, <code>ctime</code> to measure time in different types of benchmarks in C ++.</em>  <em>But benchmarking is much more useful to measure the CPU time.</em>  <em>Recently, I came across an article about cross-platform measurement of CPU time and decided to share it here, perhaps somewhat increasing the quality of local benchmarks.</em> </p><br><p>  <em>PS When the article says "today" or "now", it means "at the time of publication of the article", that is, if I am not mistaken, March 2012. Neither I nor the author can guarantee that this is still the case.</em> <em><br></em>  <em>PPS At the time of publication, the original is unavailable, but is stored in the <a href="http%253A%252F%252Fnadeausoftware.com%252Farticles%252F2012%252F03%252Fc_c_tip_how_measure_cpu_time_benchmarking%2523clockgettme%26amp%3Bl10n%3Dru%26amp%3Bmime%3Dhtml%26amp%3Bsign%3Dacfadd1eee05fdfb3a0c525c0ae469db%26amp%3Bkeyno%3D0">Yandex cache</a></em> </p><br><p>  API functions that allow you to get the processor time used by the process differ in different operating systems: Windows, Linux, OSX, BSD, Solaris, as well as other UNIX-like operating systems.  <strong>This article provides a cross-platform function that takes the process CPU time and explains what features each OS supports.</strong> </p><a name="habracut"></a><br><h1>  How to get CPU time </h1><br><p>  CPU time increases when the process runs and consumes CPU cycles.  During I / O operations, thread locks, and other operations that pause the processor, the processor time does not increase until the process starts using the CPU again. </p><br><p>  Different tools, such as <code>ps</code> on POSIX, Activity Monitor on OSX and Task Manager on Windows, show the processor time used by processes, but it is often useful to monitor it directly from the process itself.  This is especially useful during benchmarking algorithms or a small part of a complex program.  Despite the fact that all operating systems provide an API for getting CPU time, each of them has its own subtleties. </p><br><h2>  Code </h2><br><p>  The <strong><code>getCPUTime( )</code></strong> function shown below works on most operating systems (just copy the code or download the <a href="https://gist.github.com/Randl/45bcca59720f661fa033a67d5f44bff0">getCPUTime.c</a> file).  Where necessary, link up with <strong>librt</strong> to get POSIX timers (for example, AIX, BSD, Cygwin, HP-UX, Linux and Solaris, but not OSX).  Otherwise, standard libraries are sufficient. </p><br><p>  Next, we will discuss in detail all the functions, subtleties and reasons why there are so many <code>#ifdef</code> in the code. </p><br><div class="spoiler">  <b class="spoiler_title">getCPUTime.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Author: David Robert Nadeau * Site: http://NadeauSoftware.com/ * License: Creative Commons Attribution 3.0 Unported License * http://creativecommons.org/licenses/by/3.0/deed.en_US */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_WIN32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) #include &lt;unistd.h&gt; #include &lt;sys/resource.h&gt; #include &lt;sys/times.h&gt; #include &lt;time.h&gt; #else #error "Unable to define getCPUTime( ) for an unknown OS." #endif /** * Returns the amount of CPU time used by the current process, * in seconds, or -1.0 if an error occurred. */ double getCPUTime( ) { #if defined(_WIN32) /* Windows -------------------------------------------------- */ FILETIME createTime; FILETIME exitTime; FILETIME kernelTime; FILETIME userTime; if ( GetProcessTimes( GetCurrentProcess( ), &amp;createTime, &amp;exitTime, &amp;kernelTime, &amp;userTime ) != -1 ) { SYSTEMTIME userSystemTime; if ( FileTimeToSystemTime( &amp;userTime, &amp;userSystemTime ) != -1 ) return (double)userSystemTime.wHour * 3600.0 + (double)userSystemTime.wMinute * 60.0 + (double)userSystemTime.wSecond + (double)userSystemTime.wMilliseconds / 1000.0; } #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) &amp;&amp; defined(__MACH__)) /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, and Solaris --------- */ #if defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS &gt; 0) /* Prefer high-res POSIX timers, when available. */ { clockid_t id; struct timespec ts; #if _POSIX_CPUTIME &gt; 0 /* Clock ids vary by OS. Query the id, if possible. */ if ( clock_getcpuclockid( 0, &amp;id ) == -1 ) #endif #if defined(CLOCK_PROCESS_CPUTIME_ID) /* Use known clock id for AIX, Linux, or Solaris. */ id = CLOCK_PROCESS_CPUTIME_ID; #elif defined(CLOCK_VIRTUAL) /* Use known clock id for BSD or HP-UX. */ id = CLOCK_VIRTUAL; #else id = (clockid_t)-1; #endif if ( id != (clockid_t)-1 &amp;&amp; clock_gettime( id, &amp;ts ) != -1 ) return (double)ts.tv_sec + (double)ts.tv_nsec / 1000000000.0; } #endif #if defined(RUSAGE_SELF) { struct rusage rusage; if ( getrusage( RUSAGE_SELF, &amp;rusage ) != -1 ) return (double)rusage.ru_utime.tv_sec + (double)rusage.ru_utime.tv_usec / 1000000.0; } #endif #if defined(_SC_CLK_TCK) { const double ticks = (double)sysconf( _SC_CLK_TCK ); struct tms tms; if ( times( &amp;tms ) != (clock_t)-1 ) return (double)tms.tms_utime / ticks; } #endif #if defined(CLOCKS_PER_SEC) { clock_t cl = clock( ); if ( cl != (clock_t)-1 ) return (double)cl / (double)CLOCKS_PER_SEC; } #endif #endif return -1; /* Failed. */ }</span></span></span></span></code> </pre> </div></div><br><h2>  Using </h2><br><p>  To measure the processor time of the algorithm, call <code>getCPUTime( )</code> before and after running the algorithm, and output the difference.  You should not assume that the value returned by a single function call carries some meaning. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> startTime, endTime; startTime = getCPUTime( ); ... endTime = getCPUTime( ); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"CPU time used = %lf\n"</span></span>, (endTime - startTime) );</code> </pre> <br><h1>  Discussion </h1><br><p>  Each OS provides one or more ways to get CPU time.  However, some methods are more accurate than others. </p><br><table><thead><tr><th>  OS </th><th>  clock </th><th>  clock_gettime </th><th>  GetProcessTimes </th><th>  getrusage </th><th>  times </th></tr></thead><tbody><tr><td>  Aix </td><td>  yes </td><td>  yes </td><td></td><td>  yes </td><td>  yes </td></tr><tr><td>  BSD </td><td>  yes </td><td>  yes </td><td></td><td>  yes </td><td>  yes </td></tr><tr><td>  HP-UX </td><td>  yes </td><td>  yes </td><td></td><td>  yes </td><td>  yes </td></tr><tr><td>  Linux </td><td>  yes </td><td>  yes </td><td></td><td>  yes </td><td>  yes </td></tr><tr><td>  Osx </td><td>  yes </td><td></td><td></td><td>  yes </td><td>  yes </td></tr><tr><td>  Solaris </td><td>  yes </td><td>  yes </td><td></td><td>  yes </td><td>  yes </td></tr><tr><td>  Windows </td><td></td><td></td><td>  yes </td><td></td><td></td></tr></tbody></table><br><p>  Each of these methods is detailed below. </p><br><h2>  GetProcessTimes () </h2><br><p>  On Windows and <a href="http://cygwin.com/index.html">Cygwin</a> (a UNIX-like environment and command line interface for Windows), the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683223(v%3Dvs.150).aspx">GetProcessTimes ()</a> function fills the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284(v%3Dvs.150).aspx">FILETIME</a> structure <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284(v%3Dvs.150).aspx">with the</a> processor time used by the process, and the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724280(v%3Dvs.150).aspx">FileTimeToSystemTime ()</a> function converts the FILETIME structure into a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950(v%3Dvs.150).aspx">SYSTEMTIME</a> structure containing the usable time value. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSTEMTIME</span></span></span><span class="hljs-class"> {</span></span> WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds; } SYSTEMTIME, *PSYSTEMTIME;</code> </pre> <br><p>  <strong>Accessibility GetProcessTimes ():</strong> Cygwin, Windows XP and later. </p><br><p>  Getting CPU time: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; ... FILETIME createTime; FILETIME exitTime; FILETIME kernelTime; FILETIME userTime; if ( GetProcessTimes( GetCurrentProcess( ), &amp;createTime, &amp;exitTime, &amp;kernelTime, &amp;userTime ) != -1 ) { SYSTEMTIME userSystemTime; if ( FileTimeToSystemTime( &amp;userTime, &amp;userSystemTime ) != -1 ) return (double)userSystemTime.wHour * 3600.0 + (double)userSystemTime.wMinute * 60.0 + (double)userSystemTime.wSecond + (double)userSystemTime.wMilliseconds / 1000.0; }</span></span></span></span></code> </pre> <br><h2>  clock_gettme () </h2><br><p>  On most POSIX-compatible OSs, <code>clock_gettime( )</code> (see <a href="https://www.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.basetrf1/clock_getres.htm">AIX</a> , <a href="https://www.freebsd.org/cgi/man.cgi%3Fquery%3Dclock_gettime">BSD</a> , <a href="http://nixdoc.net/man-pages/HP-UX/man2/clock_getres.2.html">HP-UX</a> , <a href="http://man7.org/linux/man-pages/man2/clock_gettime.2.html">Linux,</a> and <a href="https://docs.oracle.com/cd/E23824_01/html/821-1465/clock-gettime-3c.html">Solaris</a> manuals) provides the most accurate CPU time.  The first argument of the function selects "clock id", and the second is the structure of the <code>timespec</code> , filled with used processor time in seconds and nanoseconds.  For most OSs, the program must be linked to <strong>librt</strong> . </p><br><p>  However, there are several subtleties that make it difficult to use this function in cross-platform code: </p><br><ul><li>  The function is an optional part of the POSIX standard and is only available if <code>_POSIX_TIMERS</code> defined in <code>&lt;unistd.h&gt;</code> value greater than 0. Currently, AIX, BSD, HP-UX, Linux and Solaris support this function, but OSX does not support it. </li><li>  The <code>timespec</code> structure filled in by the <code>clock_gettime( )</code> function can store time in nanoseconds, but the clock accuracy differs across OSs and systems.  The <a href="http://man7.org/linux/man-pages/man2/clock_gettime.2.html">clock_getres ()</a> function returns the accuracy of the clock if you need one.  This function, again, is an optional part of the POSIX standard, available only if <code>_POSIX_TIMERS</code> greater than zero.  Currently, AIX, BSD, HP-UX, Linux, and Solaris provide this feature, but it does not work on Solaris. </li><li>  <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_gettime.html">The POSIX standard</a> defines the names of several standard "clock id" values, including the <code>CLOCK_PROCESS_CPUTIME_ID</code> , to obtain the process time of the process.  However, today BSD and HP-UX do not have this id, and define their own id <code>CLOCK_VIRTUAL</code> for processor time instead.  To confuse everything even more, Solaris defines <em>both of</em> these, but uses <code>CLOCK_VIRTUAL</code> for the <code>CLOCK_VIRTUAL</code> 's processor time, not the <em>process</em> . </li></ul><br><table><thead><tr><th>  OS </th><th>  What id to use </th></tr></thead><tbody><tr><td>  Aix </td><td> <code>CLOCK_PROCESS_CPUTIME_ID</code> </td> </tr><tr><td>  BSD </td><td> <code>CLOCK_VIRTUAL</code> </td> </tr><tr><td>  HP-UX </td><td> <code>CLOCK_VIRTUAL</code> </td> </tr><tr><td>  Linux </td><td> <code>CLOCK_PROCESS_CPUTIME_ID</code> </td> </tr><tr><td>  Solaris </td><td> <code>CLOCK_PROCESS_CPUTIME_ID</code> </td> </tr></tbody></table><br><ul><li>  Instead of using one of the constants declared above, the <a href="http://man7.org/linux/man-pages/man3/clock_getcpuclockid.3.html">clock_getcpuclockid ()</a> function returns a timer for the selected process.  Using process 0 allows you to get the processor time of the current process.  However, this is another <em>optional</em> part of the POSIX standard and is available only if <code>_POSIX_CPUTIME</code> greater than 0. Today, only AIX and Linux provide this function, but Linux include files do not define <code>_POSIX_CPUTIME</code> and the function returns unreliable and incompatible with POSIX results. </li><li>  The <code>clock_gettime( )</code> function can be implemented using the processor's time register.  On multiprocessor systems, individual processors may have slightly different perceptions of time, due to which the function may return incorrect values ‚Äã‚Äãif the process was transferred from the processor to the processor.  On Linux, and only on Linux, this can be detected if <code>clock_getcpuclockid( )</code> returns a non-POSIX error and sets <code>errno</code> to <code>ENOENT</code> .  However, as noted above, Linux <code>clock_getcpuclockid( )</code> unreliable on Linux. </li></ul><br><p>  In practice, due to all these subtleties, the use of <code>clock_gettime( )</code> requires a lot of checks with <code>#ifdef</code> and the ability to switch to another function if it does not work. </p><br><p>  <strong>Availability clock_gettime ():</strong> AIX, BSD, Cygwin, HP-UX, Linux, and Solaris.  But the clock id on BSD and HP-UX is non-standard. </p><br><p>  <strong>Availability clock_getres ():</strong> AIX, BSD, Cygwin, HP-UX, and Linux, but Solaris does not work. </p><br><p>  <strong>Availability clock_getcpuclockid ():</strong> AIX and Cygwin, not unreliable on Linux. </p><br><p>  Getting CPU time: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; #include &lt;time.h&gt; ... #if defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS &gt; 0) clockid_t id; struct timespec ts; #if _POSIX_CPUTIME &gt; 0 /* Clock ids vary by OS. Query the id, if possible. */ if ( clock_getcpuclockid( 0, &amp;id ) == -1 ) #endif #if defined(CLOCK_PROCESS_CPUTIME_ID) /* Use known clock id for AIX, Linux, or Solaris. */ id = CLOCK_PROCESS_CPUTIME_ID; #elif defined(CLOCK_VIRTUAL) /* Use known clock id for BSD or HP-UX. */ id = CLOCK_VIRTUAL; #else id = (clockid_t)-1; #endif if ( id != (clockid_t)-1 &amp;&amp; clock_gettime( id, &amp;ts ) != -1 ) return (double)ts.tv_sec + (double)ts.tv_nsec / 1000000000.0; #endif</span></span></span></span></code> </pre> <br><h2>  getrusage () </h2><br><p>  On all UNIX-like operating systems, the <a href="http://man7.org/linux/man-pages/man2/getrusage.2.html">getrusage ()</a> function is the most reliable way to get the processor time used by the current process.  The function fills the <strong>rusage</strong> structure <strong>with</strong> time in seconds and microseconds.  The <code>ru_utime</code> field contains time spent in user mode, and the <code>ru_stime</code> field <code>ru_stime</code> system mode on behalf of the process. </p><br><p>  <em>Note:</em> Some operating systems, before widespread 64-bit support, defined the <code>getrusage( )</code> function, which returns a 32-bit value, and the <code>getrusage64( )</code> function, which returns a 64-bit value.  Today, <code>getrusage( )</code> returns a 64-bit value, and <code>getrusage64( )</code> is out of date. </p><br><p>  <strong>Accessibility getrusage ():</strong> AIX, BSD, Cygwin, HP-UX, Linux, OSX, and Solaris. </p><br><p>  Getting CPU time: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/resource.h&gt; #include &lt;sys/times.h&gt; ... struct rusage rusage; if ( getrusage( RUSAGE_SELF, &amp;rusage ) != -1 ) return (double)rusage.ru_utime.tv_sec + (double)rusage.ru_utime.tv_usec / 1000000.0;</span></span></span></span></code> </pre> <br><h2>  times () </h2><br><p>  On all UNIX-like operating systems, the outdated <a href="http://man7.org/linux/man-pages/man2/times.2.html">times ()</a> function fills the <code>tms</code> structure with processor time in ticks, and the <a href="http://linux.die.net/man/3/sysconf">sysconf ()</a> function returns the number of ticks per second.  The <code>tms_utime</code> field contains the time spent in user mode, and the <code>tms_stime</code> field <code>tms_stime</code> system time on behalf of the process. </p><br><p>  <em>Warning: The</em> older argument of the <code>sysconf( )</code> <code>CLK_TCK</code> obsolete and may not be supported in some operating systems.  If it is available, the <code>sysconf( )</code> function usually does not work when using it.  Use <code>_SC_CLK_TCK</code> instead. </p><br><p>  <strong>Times () availability:</strong> AIX, BSD, Cygwin, HP-UX, Linux, OSX, and Solaris. </p><br><p>  Getting CPU time: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; #include &lt;sys/times.h&gt; ... const double ticks = (double)sysconf( _SC_CLK_TCK ); struct tms tms; if ( times( &amp;tms ) != (clock_t)-1 ) return (double)tms.tms_utime / ticks;</span></span></span></span></code> </pre> <br><h2>  clock () </h2><br><p>  On all UNIX-like operating systems, the very old <a href="http://man7.org/linux/man-pages/man3/clock.3.html">clock ()</a> function returns the processor time of the process in ticks, and the <code>CLOCKS_PER_SEC</code> macro <code>CLOCKS_PER_SEC</code> number of ticks per second. </p><br><p>  <em>Note: The</em> returned processor time includes the time spent in user mode <em>and</em> in system mode on behalf of the process. </p><br><p>  <em>Note:</em> Although <code>CLOCKS_PER_SEC</code> was originally supposed to return a processor-dependent value, the C ISO C89 and C99 standards, the Single UNIX Specification and the POSIX standard require <code>CLOCKS_PER_SEC</code> have a fixed value of 1,000,000, which limits the accuracy of the function to microseconds.  Most operating systems comply with these standards, but FreeBSD, Cygwin, and older OSX versions use non-standard values. </p><br><p>  <em>Caution:</em> On AIX and Solaris, the <code>clock( )</code> function includes the CPU time of the current <em>AND</em> process and any completed child process for which the parent executed one of the <code>wait( )</code> , <code>system( )</code> or <code>pclose( )</code> functions. </p><br><p>  <em>Attention:</em> In Windows, the <a href="">clock ()</a> function is supported, but returns not processor, but real time. </p><br><p>  <strong>Availability clock ():</strong> AIX, BSD, Cygwin, HP-UX, Linux, OSX, and Solaris. </p><br><p>  Getting CPU time: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; ... clock_t cl = clock( ); if ( cl != (clock_t)-1 ) return (double)cl / (double)CLOCKS_PER_SEC;</span></span></span></span></code> </pre> <br><h2>  Other approaches </h2><br><p>  There are other OS-specific ways to get CPU time.  On Linux, Solaris and some BSD, you can parse <a href="http://man7.org/linux/man-pages/man5/proc.5.html">/ proc / [pid] / stat</a> to get process statistics.  On OSX, the <code>proc_pidtaskinfo( )</code> private API function in <code>libproc</code> returns information about the process.  There are also open libraries, such as libproc, <a href="http://procps.sourceforge.net/">procps</a> and <a href="https://support.hyperic.com/display/SIGAR/Home">Sigar</a> . </p><br><p>  On UNIX, there are several utilities for displaying the processor time of the process, including <a href="http://linux.die.net/man/1/ps">ps</a> , <a href="http://linux.die.net/man/1/top">top</a> , <a href="https://en.wikipedia.org/wiki/Mpstat">mpstat,</a> and others.  You can also use the <a href="http://man7.org/linux/man-pages/man1/time.1.html">time</a> utility to display the time spent on a command. </p><br><p>  On Windows, you can use <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BF%25D0%25B5%25D1%2582%25D1%2587%25D0%25B5%25D1%2580_%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587_Windows">Task Manager</a> to monitor CPU usage. </p><br><p>  On OSX, you can use <a href="https://en.wikipedia.org/wiki/List_of_OS_X_components">Activity Monitor</a> to monitor CPU usage.  The <a href="https://developer.apple.com/library/tvos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/">Instruments</a> Profiling Utility bundled with Xcode can monitor CPU usage as well as many other things. </p><br><h1>  Downloads </h1><br><ul><li>  <a href="https://gist.github.com/Randl/45bcca59720f661fa033a67d5f44bff0">getCPUTime.c</a> implements the above described function on C. Compile it with any C compiler and link with <strong>librt</strong> , on systems where it is available.  The code is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a> . </li></ul><br><h1>  See also </h1><br><h2>  Related articles at NadeauSoftware.com </h2><br><ul><li>  <a href="http://nadeausoftware.com/articles/2012/04/c_c_tip_how_measure_elapsed_real_time_benchmarking">Elapsed real time for benchmarking</a> explains how to get real time to measure elapsed time for a piece of code, including the time spent on I / O or user input. </li><li>  <a href="http://nadeausoftware.com/articles/2012/01/c_c_tip_how_use_compiler_predefined_macros_detect_operating_system">The operating system</a> explains how to use <code>#ifdef</code> macros for OS-specific code.  Some of these methods are used in this article to determine Windows, OSX and UNIX variants. </li></ul><br><h2>  Articles on the Internet </h2><br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D1%258F">CPU time</a> on wikipedia explains what processor time is. </li><li>  <a href="https://www.gnu.org/software/libc/manual/html_node/CPU-Time.html">CPU Time Inquiry</a> at GNU.org explains how to use the ancient clock () function. </li><li>  <a href="http://www.philosophicalgeek.com/2009/01/03/determine-cpu-usage-of-current-process-c-and-c/">Determine CPU usage of current process (C ++ and C #)</a> provides code and explanations for obtaining CPU time and other statistics on Windows. </li><li>  <a href="http://man7.org/linux/man-pages/man7/posixoptions.7.html">Posix Options</a> on Kernel.org explains optional POSIX features and constants, including _POSIX_TIMERS and _POSIX_CPUTIME. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/282301/">https://habr.com/ru/post/282301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282283/index.html">Student projects within the Google Summer of Code</a></li>
<li><a href="../282287/index.html">Separate host and user configurations in 3CX Phone System v14</a></li>
<li><a href="../282293/index.html">Use CommonJS modules in Rails with Browserify</a></li>
<li><a href="../282297/index.html">AdminVK - monitoring your own Vkontakte groups for new events using push notifications</a></li>
<li><a href="../282299/index.html">Especially unscientific: Tarantool 1.6 vs Golang (by speed)</a></li>
<li><a href="../282305/index.html">Optimizing the Nested Set model in PHPixie</a></li>
<li><a href="../282311/index.html">Organization of functional requirements for a large project</a></li>
<li><a href="../282313/index.html">Magic, broken calculator or just a "divorce"?</a></li>
<li><a href="../282317/index.html">Review of the review of the minuses of Bitrix, or the dude reads only the first 5 pages</a></li>
<li><a href="../282319/index.html">Mozilla Thunderbird OAuth authorization: from inception to release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>