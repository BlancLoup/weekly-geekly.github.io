<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to optimize Unicorn processes in a Ruby on Rails application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are a rails developer, then you have probably heard about Unicorn , an http server that can simultaneously handle many requests. 

 To ensure c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to optimize Unicorn processes in a Ruby on Rails application</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/38b/476/782/38b4767825cf51dce7993b24974010bf.png"><br>  If you are a rails developer, then you have probably heard about <a href="http://unicorn.bogomips.org/">Unicorn</a> , an http server that can simultaneously handle many requests. <br><br>  To ensure concurrency, Unicorn uses multiple process creation.  Since  The created (forked) processes are copies of each other, which means that a rails application must be thread-safe. <br><br>  It's great because  it's hard for us to be sure that our code is thread-safe.  If we cannot be sure of this, then neither parallel web servers, such as <a href="http://www.puma.io/">Puma</a> , nor even alternative implementations of Ruby implementing parallelism, such as <a href="http://jruby.org/">JRuby</a> and <a href="http://rubini.us/">Rubinius</a> , are out of the question. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, Unicorn provides concurrency to our rails applications even if they are not thread-safe.  However, this requires a certain fee.  Rails applications running on Unicorn require much more memory.  Without paying any attention to the memory consumption of your application, you may eventually find out that your cloud server is overloaded. <br><br>  In this article, we will look at several ways to use Unicorn parallelism, while controlling the amount of memory consumed. <br><a name="habracut"></a><br><h4>  Use Ruby 2.0! </h4><br>  If you are using Ruby 1.9, you should seriously consider switching to 2.0.  To understand why, we need a little bit to figure out how to create processes. <br><br><h5>  Creating Processes and Copy-on-Write </h5><br>  When a child process is created, it is exactly a copy of its parent process.  However, it is not necessary to immediately copy the physical memory.  Being exact copies of each other, both child and parent processes can use the same physical memory.  When the write process occurs, only then do we copy the child process to physical memory. <br><br><h5>  How does all this relate to Ruby 1.9 / 2.0 and Unicorn? </h5><br>  I remind you that Unicorn uses forks.  In theory, the operating system can use Copy-on-Write.  Unfortunately Ruby 1.9 makes this impossible.  To be more precise, the implementation of garbage collection in Ruby 1.9 makes this impossible.  In a simplified version, it looks like this - when the garbage collector in 1.9 is triggered, it is written, which makes Copy-on-Write useless. <br><br>  Without going into details, suffice it to say that Ruby 2.0's garbage collector eliminates this, and we can use Copy-on-Write. <br><br><h4>  Unicorn configuration setup </h4><br>  Here are a few settings that we can set in config / unicorn.rb to squeeze the maximum performance out of Unicorn. <br>  <b>worker_processes</b> <br>  Sets the number of executables.  It is important to know how much memory one process takes.  This is necessary so that you can run the required number of workers without fear of overloading the RAM of your VPS. <br>  <b>timeout</b> <br>  Must be given a small number: usually between 15 and 30 seconds is appropriate.  A relatively small value is set so that time-consuming requests do not delay the processing of other requests. <br>  <b>preload_app</b> <br>  Must be set to true - this reduces the startup time of the worker.  Thanks to the Cope-on-Write application is loaded before the rest of the vorkers.  However, there is an important nuance.  We need to make sure that all sockets (including database connections) are properly closed and reopened.  We do this using before_fork and after_fork. <br>  Example: <br><pre><code class="ruby hljs">before_fork <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|server, worker|</span></span> <span class="hljs-comment"><span class="hljs-comment"># Disconnect since the database connection will not carry over if defined? ActiveRecord::Base ActiveRecord::Base.connection.disconnect! end if defined?(Resque) Resque.redis.quit Rails.logger.info('Disconnected from Redis') end end after_fork do |server, worker| # Start up the database connection again in the worker if defined?(ActiveRecord::Base) ActiveRecord::Base.establish_connection end if defined?(Resque) Resque.redis = ENV['REDIS_URI'] Rails.logger.info('Connected to Redis') end end</span></span></code> </pre> <br>  In this example, we make sure that the connections are closed and reopened when creating workers.  In addition to database connections, we need to make sure that other connections requiring socket handling are handled the same way.  The above is the configuration for <a href="https://github.com/resque/resque">Resque</a> . <br><br><h4>  Limit memory consumption by Unicorn workers </h4><br>  Obviously, around not only rainbows but unicorns.  (here was the author's pun 'rainbows and unicorns' - approx. translator).  If there are memory leaks in your Rails application, Unicorn will make it all the worse. <br><br>  Each of the created processes takes up memory, since  is a copy of the rails application.  Therefore, although having more workers means that our application can handle more incoming requests, we are limited by the physical amount of RAM in our system. <br><br>  Memory leaks in a rails application are very simple.  But even if we succeed in ‚Äúplugging‚Äù all memory leaks, we still have to deal with a slightly imperfect garbage collector (I mean the implementation in MRI). <br><img src="https://habrastorage.org/getpro/habr/post_images/8d4/8b6/59a/8d48b659a7ce3310283bdabf0f27ff1f.png"><br>  The image above shows a rails application with memory leaks launched by Unicorn. <br><br>  Over time, memory consumption will continue to grow.  The use of many workers will only accelerate the speed of memory consumption, until the moment when there is no free memory left.  The application will crash, resulting in many unhappy users and customers. <br><br>  It is important to note that this is not Unicorn‚Äôs fault.  However, this is a problem that you will encounter sooner or later. <br><br><h4>  Meet the Unicorn Worker Killer </h4><br>  One of the easiest solutions I've come across is the <a href="https://github.com/kzk/unicorn-worker-killer">unicorn-worker-killer</a> gem. <br>  Quote from <a href="">README</a> : <br><blockquote>  The unicorn-worker-killer gem allows you to automatically restart Unicorn workers based on: <br>  1) the maximum number of requests and <br>  2) the size of the memory occupied by the process (RSS), not processing the request. <br>  This will greatly increase the stability of the site, allowing you to avoid unexpected memory shortages in the application nodes. <br></blockquote><br>  Please note that I assume that you already have Unicorn installed and running. <br>  Step 1: <br>  Add a unicorn-worker-killer to your gemfile lower than unicorn. <br><pre> <code class="ruby hljs">group <span class="hljs-symbol"><span class="hljs-symbol">:production</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> gem <span class="hljs-string"><span class="hljs-string">'unicorn'</span></span> gem <span class="hljs-string"><span class="hljs-string">'unicorn-worker-killer'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Step 2: <br>  Run bundle install. <br>  Step 3: <br>  Next comes the fun part.  Open the file config.ru. <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># --- Start of unicorn worker killer code --- if ENV['RAILS_ENV'] == 'production' require 'unicorn/worker_killer' max_request_min = 500 max_request_max = 600 # Max requests per worker use Unicorn::WorkerKiller::MaxRequests, max_request_min, max_request_max oom_min = (240) * (1024**2) oom_max = (260) * (1024**2) # Max memory size (RSS) per worker use Unicorn::WorkerKiller::Oom, oom_min, oom_max end # --- End of unicorn worker killer code --- require ::File.expand_path('../config/environment', __FILE__) run YourApp::Application</span></span></code> </pre><br>  At the beginning we check that we are in a production environment.  If so, we execute the rest of the code. <br>  unicorn-worker-killer kills workers based on two conditions: the maximum number of requests and the maximum memory consumed. <br><ul><li>  maximum number of requests. In this example, the worker is killed if he processed from 500 to 600 requests.  Note that spacing is used.  This minimizes situations where more than one worker stops simultaneously. </li><li>  maximum consumed memory.  Here the worker is killed if he takes from 240 to 260 MB of memory.  The interval is needed here for the same reason as above. </li></ul><br>  Each application has its own memory requirements.  You should have an overall assessment of the memory consumption of your application during normal operation.  This way you can better estimate the minimum and maximum amount of memory that your workers should occupy. <br><br>  If you have configured everything correctly during the deployment of your application, you will notice much less volatile memory behavior: <br><img src="https://habrastorage.org/getpro/habr/post_images/a6c/e5b/b19/a6ce5bb19b98125c427acd6078688ed6.png"><br>  Pay attention to the excesses in the schedule - this heme does its job! <br><br><h4>  Conclusion </h4><br>  Unicorn provides your rails application with a painless way to achieve concurrency, regardless of whether it is thread safe or not.  However, this is achieved along with an increase in memory consumption.  Memory balancing is very important for the stability and performance of your application. <br>  We looked at 3 ways to tune your Unicorn workers for maximum performance: <br><ol><li>  Using Ruby 2.0 gives us an improved garbage collector that allows us to take advantage of copy-on-write. </li><li>  Configure various configuration options in config / unicorn.rb. </li><li>  Using unicorn-worker-killer to solve the problem of stopping workers when they get too bloated. </li></ol><br><br><h4>  Resources </h4><br><ul><li>  A great <a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0">explanation</a> of how the garbage collector and copy-on-write work in Ruby 2.0 work. </li><li>  <a href="http://unicorn.bogomips.org/Unicorn/Configurator.html">Complete list of</a> Unicorn configuration options. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/206840/">https://habr.com/ru/post/206840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206826/index.html">Java-programmer in St. Petersburg. Overview of the labor market in terms of the applicant. Part 3/3. What are the employers</a></li>
<li><a href="../206828/index.html">Test-driven development - cart or horse?</a></li>
<li><a href="../206830/index.html">Encryption virus. BIG article</a></li>
<li><a href="../206832/index.html">MOGA ACE ‚Ñ¢ POWER Game Controller for the New Generation iPhone 5</a></li>
<li><a href="../206834/index.html">In retro style: J2ME on TCL</a></li>
<li><a href="../206846/index.html">Nokia Sensing XCHALLENGE Grand Prix: Nanotechnology against epidemics</a></li>
<li><a href="../206848/index.html">Inexpensive 3D printer for metal based on welding machine</a></li>
<li><a href="../206850/index.html">Soon a new slavery: now with vitamins and minerals</a></li>
<li><a href="../206852/index.html">Porting and localizing the application on Windows Phone 8</a></li>
<li><a href="../206854/index.html">Increase smartphone performance. All the pros and cons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>