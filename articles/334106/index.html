<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ronimo Code Style Methodology and Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have a large third-party structural approach to work. Game programmers have to create complex systems and therefore it is not enough just to go with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ronimo Code Style Methodology and Guide</h1><div class="post__text post__text-html js-mediator-article">  I have a large third-party structural approach to work.  Game programmers have to create complex systems and therefore it is not enough just to go with the flow.  I wrote two documents about how we write code in <a href="http://www.ronimo-games.com/">Ronimo</a> , which every programmer and trainee should learn on the first day of work.  Our <i>methodology</i> paper explains the workflow, and <i>the style guide</i> talks about our code system.  First, I want to reveal the methodology and talk about the reasons behind the rules presented in the document. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/2cb/7ba/115/2cb7ba11591c835e86863de041f55e85.jpg"><br>  <i>In our two-dimensional MOBA Awesomenauts, there are currently two thousand classes and more than 400 thousand lines of code.</i>  <i>To prevent such a voluminous code base from becoming chaos, a structural approach is needed.</i> <br><br>  It should be noted that the content of this document is not very original: for the most part it is a combination of Agile practices I liked. <br><br>  Let's start by examining the methodology paper itself: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Ronimo code methodology </h2><br><h4>  The standard way to implement a new feature: </h4><br><ol><li>  Analyze what needs to be done.  Discuss the approach with end users (usually artists and / or designers) and with the lead developer. </li><li>  Divide the work into <i>small tasks</i> that can be solved a maximum of a day. </li><li>  Create a simple plan for small tasks.  Implementation of the core of the functional and the most difficult parts put in the beginning of the plan </li><li>  Implement each of the smaller tasks. </li><li>  Rate results with end users and lead developer. </li><li>  Explain to the end user what the new function is doing to actually use it. </li></ol><br><h4>  Implementation of the <i>petty task</i> : </h4><br><ol><li>  Analyze what needs to be done. </li><li>  Make sure that there is no error in the existing code (run the tests!). </li><li>  Explore and experiment with all the new technologies needed for this feature. </li><li>  Create a new feature code design.  Do not overly emphasize theoretical use in the future, but keep it in mind. </li><li>  Refactor existing code to create space for a new function. </li><li>  Run tests to verify that the old functions still work. </li><li>  Implement a new feature. </li><li>  Test the work of the new function. </li><li>  Finish the code: add comments, clean the code and check the destructors. </li><li>  Check with the tests that the new feature is still working. </li><li>  Test the work of the old functions. </li><li>  Analyze the result.  If possible, show the intermediate result to the end user. </li></ol><br><h4>  Other rules: </h4><br><ul><li>  Keep a personal list of all the small tasks that need to be done.  If a problem arises that cannot be solved immediately, or when you are asked to add a function that you promise to add later, write it in the list.  Do not think that you can remember everything. </li><li>  Do not continue to work on the task if there is a failure or a serious error.  Always correct the failure first. </li><li>  <i>‚ÄúPremature optimization is the root of all evil‚Äù</i> (Donald Knut).  First, implement a new function in the simplest or cleanest possible way, analyze whether it works, then analyze the execution speed, and only make optimization if necessary. </li><li>  Don't worry about adding unknown future extensions to your code.  If necessary, the code can be refactored.  Of course, if you do not need a lot of work for this, then do everything as general as possible. </li></ul><br>  Most of the principles are clear enough, but it is interesting to discuss the reasons behind these rules.  Quite often I saw intern coders with a bunch of unfinished parts in the code, because they worked on five tasks at the same time and forgot to test, clean and complete some of them.  Therefore, our code methodology requires programmers to complete tasks, and only then move on to the following.  That is why I demand that large tasks be divided into several smaller ones: a person‚Äôs memory is limited, and the more tasks you perform at the same time, the more likely you are to miss something important. <br><br>  At the same time, I prefer the agile approach: do only what you really need and expand the code base in the process.  At the beginning of development, you do not know all the functions that you will need, nor do you know how to solve all the problems.  However, the gradual addition of functionality often inflates the code and blurs its meaning, creates vague responsibilities of classes.  Therefore, the code needs to be refactored frequently.  Refactoring requires discipline.  Often, you can write a hack of a new function in just a few hours, or first spend half a day on refactoring so that this function can be successfully integrated into the code.  It is very easy to skip or postpone refactoring until later, but in this case, very often in the long run, such code becomes inoperative.  This is why refactoring is clearly mentioned in our methodology. <br><br>  But do not take the call to work only on one small task too literally.  Although I think that it is important not to do anything else until you finish and make the code clean, this does not mean that you should not look ahead.  When creating something complex, it is important to think about how you make the entire system work.  Once I had a trainee who had to redo a large part of the tool, because he took the code methodology too literally and did not think at all beforehand.  The most complex functions of the tool were completely impossible to implement with what he created.  The most important thing here is the right balance between thinking about the future and focusing on one task. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/507/1cd/231/5071cd2310c56e8ef4434eaff2cfe279.gif"><br>  <i>When creating a tool that should quickly process a tree of 100 thousand settings, you need to think about the execution speed from the very beginning, although our methodology says the opposite.</i>  <i>Rules should not be taken too literally.</i> <br><br>  Another important aspect for me is the direct communication of programmers with designers and artists.  We believe that detailed design documents rarely come in handy, so the only way to know for sure is to speak with a designer or artist who needs a new function.  Often this person can not decide on the exact requirements for the function, so the coder needs to communicate with him, find out all the features from a design and artistic point of view.  If a programmer has some kind of design and artistic experience, it helps a lot in communication, but even if there is no such experience, I think that the programmer‚Äôs task is to speak the language of the artist or designer, but not vice versa.  It is very difficult for a designer to talk about code, and a programmer can tell about his work in accessible English (or Dutch, in our case). <br><br>  Our code methodology has surprisingly no unit testing.  We very strictly adhere to thorough testing of our own code, but the document says nothing about writing unit tests.  The reason is that I consider the gameplay too chaotic and unpredictable, so that it can be sufficiently well captured by unit tests.  Some functions can be checked by unit tests, but errors we encounter are often not detected by them.  Often these are fragments that work fine, but lead to the wrong gameplay. <br><br>  I realize that the lack of unit tests makes us more vulnerable to errors than developers who write unit tests.  That is why we emphasize that when a failure or a serious bug is detected, it must be corrected immediately.  We may have more bugs than software developers writing detailed unit tests, but at least we fix them quickly.  I think we should use unit tests more for such aspects.  as server architecture.  Unit testing is not inherent in our company, but perhaps it should be used at least a little. <br><br>  Regardless of whether or not you agree with the rules of our methodology, I believe that it is important for all programmers to think about their workflow.  It is not enough just to do what seems right to you.  Discipline and structure are important for all who work on large and complex systems.  What is your code methodology?  If you work for a company, does it have a similar official document? <br><br>  So here it is - the Ronimo code methodology!  Below I will talk about the code style guide, which is a little stricter than usual for most programmers. <br><br><h2>  Code Style Guide </h2><br>  Now we look at how our code looks, as described in <i>the code style guide</i> .  The main idea of ‚Äã‚Äãthe style guide is that if all the code is formatted in a general style, then the code of your colleagues is easier to read and change.  For example, getting used to another way of placing curly brackets or naming takes time.  Thanks to the strict style guide that all Ronimo programmers must follow, this can be avoided. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c3/75c/ed2/5c375ced2b30630b56abbe3e09359cac.jpg"><br>  <i>In a few years, 18 programmers (including interns) contributed to the Awesomenauts code base.</i>  <i>Due to strict rules of design, all code is read in the same way</i> <br><br>  I have not seen so many manuals on the style of other companies, but from what I heard, I realized that our management is much stricter than usual.  I'm not sure if this is true, but I can believe it, because I am known for my meticulousness (sometimes too strong).  However, our leadership is not "immortalized in stone": every rule has exceptions.  If, in some situation, the style guide does not make sense, the coder may well ignore it sometimes.  But only if this is a good reason. <br><br>  Some selected solutions in this document are rather arbitrary.  Sometimes the alternatives are just as good, but without a clearly selected option, it is impossible to achieve the same formatting for all programmers.  This is especially true for braces.  I know that this is a hot topic, and although I have clear preferences, I know that good arguments can be made in favor of alternative styles of arrangement.  (And it would be nice if the defenders of any other popular style did not call him the Only True ...;)) <br><br>  The most important element of our style guide is that I want to read the code as much as possible in English.  The names of variables and functions must be descriptive, only the most common abbreviations are allowed.  I am concerned not with brevity, but readability. <br><br>  However, not all points of our style guide relate to formatting.  Part describes language constructs.  C ++ is a rich language with enormous possibilities, but some of them are too confusing or represent the danger of errors.  For example, in C ++ it is quite possible to use nested ternary operators, but the result is rarely convenient to read, so we completely abandoned them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a7/1c7/d8b/5a71c7d8be7f6452309b17fafc584a43.gif"><br>  <i>This relatively simple example of a nested ternary operator is already too difficult to read.</i>  <i>Our style guide prefers readability.</i> <br><br>  In addition, our guide contains rules for simplifying cross-platform development.  On consoles, it is usually impossible to choose a compiler, so you have to work with the fact that you chose Nintendo, Sony or Microsoft, taking into account the limitations of their compilers.  We studied what features of C ++ are supported by all these compilers and have banned the use of some new C ++ constructs that, in our opinion, may not work on one of the consoles.  Since we are not currently engaged in development for some consoles, we draw conclusions only on the documentation, but it is better to be too strict than too lenient. <br><br>  In the style guide, you can also notice my dislike for complex language constructs.  C ++ allows you to perform quite impressive tricks, especially with the use of templates and macros.  Of course, I agree that sometimes such tricks are very useful, but in general I reject them when it becomes too difficult to read them.  In rare cases, when they are really necessary, they are allowed, but usually I prefer to avoid complex structures. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/172/593/215/1725932153d40e481c2e6938d61e09c8.gif"><br>  <i>An example of what a C ++ header looks like, written according to the rules of our style guide.</i> <br><br>  One of the most hotly discussed items in the style of writing code is whether to mark variables of class elements.  If the Car class has <code>float speed</code> , do we need to call it <code>speed</code> , <code>mSpeed</code> , <code>_speed</code> or something else?  I decided to call it just <code>speed</code> .  Here again I adhere to the fact that the code should resemble the English text as much as possible.  The more prefixes and underscores, the farther we go from natural language and the harder it is to just read the code and understand it. <br><br>  However, there is a logical reason why many programmers mark variables of class elements: in code, it is very important to know whether a variable is an element of a class, a parameter of a function, or a local variable.  This point of view is also valid, but I think we solved this problem differently: in our style guide there are restrictions on the length of classes and functions.  If the function is short and fits on one screen, then it‚Äôs very easy to immediately see where the variables come from.  I believe that if classes and functions are short enough, then labels of variable elements are not really needed. <br><br>  By the way, notice that the rule about the length of functions and classes in a company is violated most often.  Sometimes it is very difficult to separate a class or function beautifully.  In the end, the goal of our style guide is to write clean code, rather than complicating it with awkward separations.  For the beautiful division of classes into smaller, more convenient, accompanied modules, real art is required.  So if you are not too experienced, then most often you will not see possible beautiful splitting options.  In my opinion, the ideal class size is somewhere between 200 and 400 lines, but such a strict rule cannot be fulfilled, therefore it is formulated more softly in the style manual. <br><br>  We discussed the reasons for the decisions chosen in the code style guide, let's finally see what it looks like by itself! <br><br><table><tbody><tr><td><h2>  Ronimo Code Style Guide </h2><br>  Every rule has exceptions.  However, whenever possible it is worth adhering to these rules in order to maintain a permanent system and style throughout the entire code base.  In many ways, they depend on taste, therefore, maintaining a constant code structure requires you to find your own taste and adhere to these rules.  If you follow the rules, it becomes easier to read the code. <br><br>  When working with other languages ‚Äã‚Äã(not C ++), try to adhere as closely as possible to the C ++ code standard, but, of course, within logical limits.  At the end of the guide are special notes on C #. <br><br><h2>  C ++ </h2><br><ul><li>  All code and comments are written in British English.  (Not in American English.) Correct: <i>color, center, initialiser</i> .  Wrong: <i>color, center, initializer</i> . </li><li>  Each comma is followed by a space, for example: <code>doStuff(5, 7, 8)</code> </li><li>  Operators are separated by spaces, for example: <code>5 + 7</code> instead of <code>5+7</code> </li><li>  Tabs are four spaces long.  Tabs are stored as tabs, not as spaces. </li><li>  Functions and static variables are specified in the same order in the .h and .cpp files. </li><li>  Use <code>#pragma once</code> instead of <code>#include guard</code> (we switched to this recently, so you will see many old <code>#include guard</code> in our code). </li><li>  Try to write short functions, preferably no longer than 50 lines. </li><li>  Avoid creating too large classes.  If you expect the class to grow large and it can be logically divided, then divide it.  Strive to ensure that the standard class size does not exceed 750 lines.  However, you should not divide the class if the code becomes less readable.  Here are examples of unreadable partitions: too closely related classes, <code>friend</code> classes, and complex class hierarchies. </li><li>  Do not write long lines that do not fit on a standard 1920 * 1080 screen (do not forget that there is a Solution Explorer window on this screen). </li><li>  When splitting a long line into several lines, make sure the indents correspond to the brackets.  For example, like this: <br><br><pre> <code class="cpp hljs">myReallyLongFunctionName(Vector2(bananaXPos + xOffset, bananaYPos * multiplier), explodingKiwi);</code> </pre> </li><li>  If possible, use a preliminary announcement: the header files should be as small as possible include.  For example, use <code>class Bert;</code>  and move <code>#include "Bert.h"</code> to the .cpp file. </li><li>  Include and preliminary declarations must have the following order: <br><ul><li>  Start with all preliminary announcements from your own code (in alphabetical order) </li><li>  Then all include from your own code (in alphabetical order) </li><li>  Empty line </li><li>  Then for each library: <br><ul><li>  Preliminary announcements from this library (in alphabetical order) </li><li>  All include from this library (in alphabetical order) </li></ul></li></ul></li><li>  The include of the .h file belonging to the .cpp file is always at the top. </li><li>  Do not define <code>static</code> variables in a function.  Use class element variables (possibly static). </li><li>  Everything must be correct in terms of <code>const</code> . </li><li>  The names of variables and functions should be descriptive.  You can easily use long names, you can not use vague names.  Use abbreviations only if they are very clear and standard. </li><li>  The first letter of the class names, the struct and enum types is the capital letter.  Variables and functions begin with an uppercase.  Each next word in the title begins with a capital letter.  Do not use underscores (_) in variable names.  Here is an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> someVariable; };</code> </pre> </li><li>  Element variables are not flagged in any way, neither the letter m before the name, nor _ after.  Functions must be short enough so that you can keep track of what is declared in the function and what is in the class.  Do not mark the variables of the elements <code>this-&gt;</code> . </li><li>  Implementations of functions should never be in .h files. </li><li>  Template functions that cannot be implemented in a .cpp file are implemented in an additional header file, which is included from the main header file.  Such a class can have three files: MyClass.h, MyClassImplementation.h and MyClass.cpp.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T thingy)</span></span></span></span>; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MyClassImplementation.h"</span></span></span></span></code> </pre> </li><li>  Start the template type names with the letter T. If you need more information, then you can add words after it, for example <code>TString</code> . </li><li>  You cannot declare multiple classes in a single header file.  Exception: the file is part of another class (for example, declared inside another class). </li><li>  There must be two blank lines between the functions (in the .cpp file). </li><li>  Use blank lines to structure and group code for readability. </li><li>  Accompany the code with detailed comments. </li><li>  Above each class give a short description of the class.  In particular, it is worth describing relationships (for example, ‚ÄúThis class helps class X by doing Y for it‚Äù). </li><li>  The curly brackets <code>{</code> and <code>}</code> always occupy a separate line, that is, they cannot be placed on a single line with <code>if</code> or <code>for</code> .  Also, they can never miss them.  The only exception: several similar single-line <code>if</code> constructions, going one under the other.  In this case, it is allowed to put them in one line.  As in this example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( banana &amp;&amp; kiwi &amp;&amp; length &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cow; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( banana &amp;&amp; !kiwi &amp;&amp; length &gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pig; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!banana &amp;&amp; !kiwi &amp;&amp; length &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> duck; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dragon;</code> </pre> </li><li>  When writing the <code>do-while</code> while function, it should be in the same line with a closing bracket: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { blabla; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bleble);</code> </pre> </li><li>  Indents in <code>switch</code> constructions should be arranged as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (giraffeCount) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: text = <span class="hljs-string"><span class="hljs-string">"one giraffe"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: text = <span class="hljs-string"><span class="hljs-string">"two giraffes"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">//     doStuffOnSeveralLines; text = "three giraffes"; break; case 4: { //       int x = getComplexThing(); text = "quadruple giraffe"; break; } }</span></span></code> </pre> </li><li>  Function parameters must have the same name in the .h and .cpp files. </li><li>  If the function parameter and the variable of the class element have the same name, then you need to either come up with another name, or add <code>_</code> at the end of the function parameter.  For example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHealth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health_)</span></span></span><span class="hljs-function"> </span></span>{ health = health_; }</code> </pre> </li><li>  The number of preprocessor instructions (everything starting with #) should be minimal, of course, except for <code>#include</code> and <code>#pragma once</code> . </li><li>  Do not write macros. </li><li>  Variables within functions are declared where they are needed, not all of them need to be declared at the beginning of a function. </li><li>  In the body of constructors, it is better to use initialization lists (initialiser list), rather than setting variables.  Each initialization in the initialization list should occupy a separate line.  Make sure the variables in the initialization list are in the same order as in the class definition in the .h file. </li><li>  Do not use exceptions (unless you use a library that requires them). </li><li>  Do not use dynamic data type identification (RTTI) (that is, do not use <code>dynamic_cast</code> ).  RTTI slows down a bit, but more importantly, RTTI is almost always a sign of poor object-oriented design. </li><li>  Use <code>reinterpret_cast</code> and <code>const_cast</code> only when absolutely necessary. </li><li>  Do not commit code that does not compile without errors or warnings (and do not turn off warning / error messages). </li><li>  Do not commit commits breaking existing functionality. </li><li>  No global variables.  Use variable elements of the <code>static</code> type instead. </li><li>  Instead of <code>std::abs</code> use our own function <code>MathTools::abs</code> .  Reason: implementation of <code>std::abs</code> is different on different platforms, which leads to hard-to-find errors. </li><li>  Always use namespaces explicitly.  Do not insert into the code anything like <code>using namespace std</code> . </li><li>  Don't even think about using <code>go-to</code> designs.  We have a thought recognizer and in such cases it beats the programmer with current. </li><li>  Do not use commas as delimiters.  Example: <code>if (i += 7, i &lt; 10)</code> </li><li>  Do not use union unions. </li><li>  Do not use function pointers unless required by other libraries (for example, <code>sort</code> from STL). </li><li>  Use ternary operators only in the simplest cases.  Never use nested ternary operators.  Example of permitted simple use: <br><br><pre> <code class="cpp hljs">print(i &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-string"><span class="hljs-string">"big"</span></span> : <span class="hljs-string"><span class="hljs-string">"small"</span></span>);</code> </pre> </li><li>  The counters used by the artist or designer must begin with 0, as in ordinary arrays in code.  Some old tools may still start at 1, but all new tools developed for artists start at 0. </li><li>  When checking for the existence of a pointer, perform this operation explicitly.  Therefore, use <code>if (myPointer != nullptr)</code> , and not <code>if (myPointer)</code> . </li><li>  If possible, use RAII (Resource Acquisition Is Initialization).  That is, instead of creating a separate <code>initialise()</code> function, completely initialize the class in its constructor so that it is never in an incomplete state. </li><li>  Write the constructor and destructor at the same time: write each corresponding <code>delete</code> for each <code>new</code> , so as not to forget about them later. </li><li>  If you are writing a temporary debugging code, then add a comment with <code>QQQ</code> to it.  Never commit with <code>QQQ</code> : delete all debugging code before committing. </li><li>  If you want to leave a note on what needs to be done later, use <code>QQToDo</code> .  If you need to do this, add your letter to the comment, for example, <code>QQToDoJ</code> .  Make commits with <code>QQToDo</code> only if it is impractical to shut down now. </li><li>  Class definitions begin with all functions, then all variables follow.  The order should be as follows: <code>public/protected/private</code> .  This can sometimes mean that you need to use the same <code>public/protected/private</code> keywords in the same header file several times (first for functions, then for variables). </li><li>  The class begins with its constructors, followed by the destructor.  If they are <code>private</code> or <code>protected</code> , they should still be at the top. </li><li>  If something has two options, but not exactly <code>true/false</code> , then it is better to use the class <code>enum</code> , rather than <code>boolean</code> .  For example, to indicate the direction, do not use <code>bool isRight</code> .  Instead, use <code>enum Direction</code> with the values <code>Left</code> and <code>Right</code> . </li><li>  Instead of <code>std::string</code> and <code>std::stringstream</code> use our own <code>RString</code> , <code>RStringstream</code> , <code>WString</code> and <code>WStringstream</code> (they are tied to our own memory management system). </li><li>  The variable <code>float time</code> always means the time after the last frame in seconds.  If time means something else, then express it explicitly, for example, by giving the name <code>timeExisting</code> . </li><li>  Make sure that all code is independent of the frame rate, so actively use the <code>float time</code> variable for this. </li><li>  Make the structures explicit and understandable.  For example, avoid this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (yellow) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> banana; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kiwi;</code> </pre> <br>  This means that, depending on the yellow, banana or kiwi is returned.  More readable code will be, if you express it explicitly: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (yellow) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> banana; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kiwi; }</code> </pre> </li><li>  Use <code>nullptr</code> , not <code>NULL</code> . </li><li>  We use <code>auto</code> only for cases such as complex iterator types.  For everything else, we specify the type explicitly. </li><li>  Use where applicable, range-based for, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Banana&amp; ultimateFruit : myList)</code> </pre> <br>  (Note that when you do not work with pointers, it is important to type this link, because otherwise <code>Banana</code> will be copied in this case.) </li><li>  As applicable, use <code>override</code> and <code>final</code> . </li><li>  If the function is virtual, then the <code>virtual</code> keyword should always be added to it, not only in the parent class, but also in each of the versions of the functions in the descendant classes. </li><li>  Use <code>enum</code> with strong typing, the same with the word <code>class</code> .  The register in the names is the same as in the classes.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fruit</span></span></span><span class="hljs-class"> {</span></span> Banana, Kiwi, ApplePie };</code> </pre> </li><li>  Use rvalue references ( <code>&amp;&amp;</code> ), if absolutely necessary. </li><li>  If possible, use <code>unique_ptr</code> .  If the object does not have an owner, then it is stored as a regular pointer. </li><li>  Avoid instantiating complex types in the initialization list.  In the initialization list, simple copying and assignment is used, and more complex code, for example, the call <code>new</code> , should be in the body of the constructor.  Here is an example of how this works: <br><br><pre> <code class="cpp hljs">FruitManager::FruitManager(Kiwi* notMyFruit): notMyFruit(notMyFruit) { bestFruitOwnedHere.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Banana()); }</code> </pre> </li><li>  Use <code>shared_ptr</code> only in cases where common ownership is really necessary.  In general, try to avoid common ownership and use <pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span></code> </pre>  . </li><li>  Lambda functions that are too long to be written in one line should have the following indents: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if(myVec.begin(), myVec.end(), [id = <span class="hljs-number"><span class="hljs-number">42</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Element&amp; e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.id() == id; });</code> </pre> </li><li>  Do not use <code>MyConstructor = delete</code> (this does not seem to be supported in some of the compilers we use). </li><li>  Do not use the C ++ 11 features to initialize lists (it seems that this is not supported in some of the compilers we use).  Therefore, we do not use this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; thingy = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> </li><li>  Do not use features added in C ++ 14. </li></ul><h2>  C # </h2><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variables should be at the beginning of the file, not at the bottom. </font><font style="vertical-align: inherit;">We strictly separate functions and variables (as in C ++), so all variables are listed first, then all functions.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Names </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-functions must always end with </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for example </font></font><code>eatBananaAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all, this is our code style guide! </font><font style="vertical-align: inherit;">I think you may disagree with some of the rules, but it‚Äôs still useful for any company to create their own style guide. </font><font style="vertical-align: inherit;">Our leadership can be a good basis for creating your own leadership. </font><font style="vertical-align: inherit;">I'm curious: what code style guide is used in your company and do you like it?</font></font> And is it at all? </div><p>Source: <a href="https://habr.com/ru/post/334106/">https://habr.com/ru/post/334106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334088/index.html">Student website without cost</a></li>
<li><a href="../334090/index.html">Document generation - a view from the inside</a></li>
<li><a href="../334100/index.html">Add GPRS to your home GSM network</a></li>
<li><a href="../334102/index.html">Enter a member rating of GitHub and StackOverflow on My Circle</a></li>
<li><a href="../334104/index.html">Details about the new version of Veeam Backup for Microsoft Office 365 and briefly about the ticket draw for VMworld 2017</a></li>
<li><a href="../334108/index.html">JetBrains MPS - IDE for developing problem-oriented programming languages</a></li>
<li><a href="../334112/index.html">Nike Brand Story</a></li>
<li><a href="../334114/index.html">Pricing in the ERP-system SAP Business One</a></li>
<li><a href="../334116/index.html">We send routine and bureaucracy into the past or how large and medium-sized enterprises stay on top of the iceberg</a></li>
<li><a href="../334118/index.html">Why i hate spring</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>