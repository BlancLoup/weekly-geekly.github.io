<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prism Developer Guide - Part 7, creating a user interface</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


1. Introduction 
2. Initializing Prism Applications 
3. Manage dependencies between components 
4. Modular Application Developmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prism Developer Guide - Part 7, creating a user interface</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <b>Table of contents</b> <br><ol><li>  <a href="http://habrahabr.ru/post/176851/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/176853/">Initializing Prism Applications</a> </li><li>  <a href="http://habrahabr.ru/post/176861/">Manage dependencies between components</a> </li><li>  <a href="http://habrahabr.ru/post/176863/">Modular Application Development</a> </li><li>  <a href="http://habrahabr.ru/post/176867/">Implementation of the MVVM pattern</a> </li><li>  <a href="http://habrahabr.ru/post/176869/">Advanced MVVM scripts</a> </li><li>  <a href="http://habrahabr.ru/post/176895/">Creating user interface</a> <br><ol><li>  <a href="http://habrahabr.ru/post/177925/">User Interface Design Recommendations</a> </li></ol></li><li>  <a href="http://habrahabr.ru/post/178009/">Navigation</a> <ol><li>  <a href="http://habrahabr.ru/post/182052/">View-Based Navigation (View-Based Navigation)</a> </li></ol></li><li>  <a href="http://habrahabr.ru/post/182580/">The interaction between loosely coupled components</a> </li></ol></blockquote><br>  There are several paradigms for creating a user interface: <br><br><ul><li>  All controls are contained in a single XAML file and are merged during form design. </li><li>  The form is divided into logical parts, usually user controls.  The form is created at design time, referring to these parts. </li><li>  The form, as in the previous version, is divided into logical parts, but does not refer to them directly.  Parts are added to the form at run time.  Such applications are known as composite. </li></ul><br><br>  The interface of a composite application usually consists of disparate components, called views.  Views are usually found in application modules, although this is not a requirement.  If you break an application into modules, then you need a way to combine weakly related views into a user interface.  However, this approach can be used even if the views are not in different modules. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To build a user interface, you need an architecture that allows you to create markup consisting of loosely coupled visual elements generated at runtime.  In addition, this architecture should allow views to exchange messages with each other, while remaining loosely coupled. <br><br>  The <i>Stock Trader Reference Implementation (Stock Trader RI)</i> application performs user interface composition at runtime by loading views from various modules into regions declared in the shell ( <code>Shell</code> ), as shown in the illustration below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db3/03f/098/db303f098d3c85bf6382667339928ea9.png" alt="Stock Trader RI Regions and Views"><br><br><a name="habracut"></a><br><h3>  User Interface Layout Principles </h3><br>  The root element of a composite application is called a shell.  The shell works as a master page for the application and consists of several regions ( <code>Region</code> ).  Regions are placeholder elements into which content is loaded at run time.  Regions can be associated with different UI elements, such as <code>ContentControl</code> , <code>ItemsControl</code> , <code>TabControl</code> , or a user control, and can manage their content.  Regions can download content either automatically or on demand, depending on the requirements of the application. <br><br>  Usually, the content of the region is the presentation.  It encapsulates part of the user interface of the application and keeps it separate from the rest of the application.  A view can be either a user control or a data template. <br><br>  Regions control the layout and display of views.  Regions can be accessed by name.  They also support the dynamic addition and removal of views.  You can think of regions as containers that dynamically load views. <br><br>  The following sections provide insights into high-level concepts for creating composite applications. <br><br><h4>  <i>Shell</i> </h4><br>  The shell is the root object of the application and contains the main parts of the user interface.  In a WPF application, the <code>Windows</code> object acts as a shell.  In the Silverlight application - <code>RootVisualUserControl</code> . <br><br>  The shell plays the role of a master page, providing the basic interface markup structure.  It contains one or more named regions in which modules can substitute the necessary representations.  It may also contain certain high-level user interface components, such as the background, main menu, or toolbar. <br><br>  The shell defines the overall look of the application.  It can define styles and borders visible in the shell itself, as well as styles, patterns and themes that can be applied to the loaded views. <br><br>  Typically, the shell is part of a primary WPF or Silverlight project.  An assembly that contains a shell may refer to assemblies with loaded views, or it may not be referenced if assemblies are searched for and loaded at run time. <br><br><h4>  <i>Views</i> </h4><br>  Views are key elements in building the user interface of an application.  You can use a user control, a page ( <code>Page</code> ), or a data template as a view.  The view encapsulates those parts of the user interface that you want to keep away from the rest of the application.  You can choose what will be contained in the view based on the separation of functionality, as well as on the basis of the reuse of parts of the interface within the application. <br><br>  Thanks to the content model used in WPF and Silverlight, nothing related to Prism, is required to create a view.  The easiest way to create a view is to create a user control ( <code>User Control</code> ).  To add a view to the UI, you only need a way to create this view and add it to the container.  WPF and Silverlight provide mechanisms for doing this.  Prism adds the ability to specify regions in which a view can be dynamically added at runtime. <br><br><h5>  Composite views </h5><br>  A view, when adding some functionality to it, can become quite complex.  In this case, you can split it into several child views and use the parent view to create and host child views.  This can occur both statically, at design time, and dynamically, allowing modules to substitute views into regions at run time.  If the representation is not fully defined in one class, then it can be referred to as a composite representation.  In many cases, the parent view is responsible for both the creation of child views and the coordination of their interaction.  You can design child views that are less connected with each other using Prism features such as event aggregator and command objects. <br><br><h5>  Views and Design Patterns </h5><br>  Although Prism does not insist on this, you should consider using some design patterns when creating views.  <i>Stock Trader RI</i> and <i>QuickStarts</i> demonstrate the use of the MVVM pattern to divide the responsibility between the interface and logic. <br><br>  The MVVM design pattern is recommended mostly due to the fact that it naturally combines with Microsoft XAML platforms such as WPF, Silverlight, Windows Phone, and Windows RT.  The mechanism of dependent properties and rich data binding support enable the presentation model and presentation to interact in a loosely coupled manner. <br><br>  Separating presentation logic from presentation itself is an important step that will facilitate testing and maintainability, as well as improve the process of interaction between designers and programmers. <br><br>  If you create a view as a user control and place the logic in a separate code file, it will be difficult for you to test it, since for this you will need to create an instance of the view and test the logic through it.  This presents some complexity for the reason that it will be necessary to create stubs for a huge amount of infrastructure.  Accordingly, to remove infrastructure dependencies, it is necessary to separate the presentation logic from the presentation itself. <br><br>  If you create a view as a data template.  That code associated with this view is missing.  For this reason, you must place the accompanying logic somewhere else.  The same approach that ensured testability can now help with the deployment of a view. <br><br><blockquote>  <b>The note.</b> <br>  Unit testing and automation testing UI are two completely different approaches to testing with completely different coverage.  Best unit testing practices recommend that an object be tested in complete isolation.  To achieve this, it is necessary to create fakes and stubs for all dependencies.  After that, the unit test works with only one object.  Automation UI tests run the application, then apply gestures to the UI and check the result.  Tests of this type are necessary to verify the correctness of the connection of controls to the logic of the application. </blockquote><br>  The separation of logic from representation contributes to the division of responsibility.  As a complement to increasing the ability to test, it allows the UI designer to work independently of the developer.  For more information about the MVVM pattern, see part 5: Implementing the MVVM Pattern. <br><br><h5>  Commands ( <i>Commands</i> ), UI Triggers ( <i>UI Triggers</i> ), Actions ( <i>Actions</i> ) and Behaviors ( <i>Behaviors</i> ) </h5><br>  If the presentation logic is located in a separate code, then event handlers are used to interact with the UI.  However, when using MVVM, the view model cannot directly handle the events generated in the UI.  To redirect events from a UI to a view model, you can use commands, UI triggers, actions, or behaviors. <br><br>  Commands separate the semantics and the object on which this command is called from the logic of the command itself.  Also, the command object makes it possible to determine whether this command can be executed at the moment.  Commands in the UI are tied to the properties of the ICommand type of the view model.  For more information, see the ‚ÄúCommands‚Äù section in Part 5. <br><br>  UI triggers, actions, and behaviors are part of the <code>Microsoft.Expression.Interactivity</code> namespace and come with Expression Blend.  They are also part of the Expression SDK.  These components provide an extensive API for intercepting UI events or commands and their subsequent routing in the <code>ICommand</code> object properties of the current data context.  For more information about them, see the relevant sections in part 5. <br><br><h5>  <i>Data Binding</i> </h5><br>  Data binding is the most important feature of XAML platforms.  To successfully create applications that use XAML, you need to be well-versed in data binding. <br><br>  Data binding uses a built-in change notification system provided by a system of dependent properties.  When combined with the <code>INotifyPropertyChanged</code> CLR interface, these notifications allow you to organize the interaction between the receiver and the data binding source, without using any additional code. <br><br>  Data binding allows you to connect sources and receiver that are incompatible by data type using value converters.  It also provides several mechanisms for validating data. <br><br><h4>  Regions </h4><br>  Regions are available in Prism through the region manager, regions and region adapters.  The following section describes how they work and interact. <br><br><h5>  <i>Region</i> Manager ( <i>Region Managers</i> ) </h5><br>  The <code>RegionManager</code> class <code>RegionManager</code> responsible for creating and deploying a collection of regions into controls.  <code>RegionManager</code> uses adapters that are specific to each type of control to associate a new region with the corresponding control.  The following illustration shows the relationship between a region, a control, and an adapter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/940/6d6/8d2/9406d68d2c5372ba2eb7976690bd5d98.png" alt="Relationship between region, control, and adapter"><br><br>  RegionManager can create regions in code, or in XAML.  The RegionManager.RegionName attached property is used to create a region in XAML by applying it to a control that will act as a host for that region. <br><br>  An application can contain one or more <code>RegionManager</code> instances.  It is possible to choose in which instance of the regional manager it is necessary to register the region.  This can be useful if you want to move the control in the visual tree, but do not want the region to be cleared after clearing the attached property. <br><br>  RegionManager provides the RegionContext attached property, with which you can exchange data between regions. <br><br><h5>  Creating a region </h5><br>  A region is a class that implements the <code>IRegion</code> interface.  The term "region" refers to a container that can hold the dynamic contents of the user interface.  Regions allow Prism to place dynamic content contained in modules in predefined placeholders in the user interface. <br><br>  Regions can hold any type of UI content.  A module may contain UI content represented as user controls, data with associated data templates, specialized controls, or a combination of these.  This allows you to specify the location of the areas in the UI, and then allow the modules to load the content into these areas. <br><br>  A region may contain zero or more items.  Depending on which control is used as a host for a given region, one or more elements may be visible.  For example, ContentControl can only display a single object, whereas <code>ItemsControl</code> can display several items at once. <br><br>  In the following illustration, the <i>Stock Trader RI</i> shell consists of four regions: <code>MainRegion</code> , <code>MainToolbarRegion</code> , <code>ResearchRegion</code> , and <code>ActionRegion</code> .  These regions are filled with various modules of the application - the content can change at any time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27b/eae/a7f/27beaea7f179258891b3a7e8a65f2db3.png" alt="Regions Stock Trader RI"><br><br><h5>  Displaying a user control from a module in a region </h5><br>  For a demonstration of how modules and content are linked to regions, see the following illustration.  It shows the <code>WatchModule</code> and <code>NewsModule</code> with the corresponding region in the shell. <br><br>  The <code>MainRegion</code> region contains the <code>WatchListView</code> control, which is contained in the <code>WatchModule</code> module.  The <code>ResearchRegion</code> region also contains the <code>ArticleView</code> user control, which is located in the <code>NewsModule</code> module. <br><br>  In an application created with Prism, displays like this will be a natural part of the development process, as the designer and developer use them to determine what content will be contained in a particular region.  This allows the designer to determine what space is needed and what needs to be added so that the content can be seen in the space provided. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab6/cd6/b28/ab6cd6b28f38d05eb1d5f19826159038.png" alt="Displaying a user control from a module in a region"><br><br><h4>  Standard region functionality </h4><br>  Although it is not necessary to know the details of their implementation to use the regions, it will be useful to understand how controls and regions are associated with each other.  And also about their standard functionality: for example, how regions find and create views, how views can be notified when they become active, or how the life cycle of views can be associated with their activation. <br><br>  The following sections describe region adapters and region behavior. <br><br><h5>  <i>Region Adapters</i> </h5><br>  To substitute a control into a region, it must have the necessary adapter.  Region adapters are responsible for creating a region and associating it with a control element.  This allows you to use the <code>IRegion</code> interface to manage the content of the control in a consistent manner.  Each region adapter adapts a particular type of control.  Prism provides the following adapters: <br><br><ul><li>  <b>ContentControlRegionAdapter</b> .  It adapts <code>System.Windows.Controls.ContentControl</code> and its successors. </li><li>  <b>SelectorRegionAdapter</b> adapts <code>System.Windows.Controls.Primitives.Selector</code> and its descendants, such as <code>System.Windows.Controls.TabControl</code> . </li><li>  <b>ItemsControlRegionAdapter</b> adapts <code>System.Windows.Controls.ItemsControl</code> and its heirs. </li></ul><br><br><blockquote>  <b>The note.</b> <br>  The Silverlight version of the Prism library contains another adapter named <code>TabControlRegionAdapter</code> .  This is because Silverlight's <code>TabControl</code> is not a descendant of the <code>Selector</code> class and has a different behavior from WPF. <br></blockquote><br><h5>  <i>Region Behavior</i> ( <i>Region Behaviors</i> ) </h5><br>  Prism introduces the concept of regional behavior.  These are plug-in components that are responsible for most of the functionality of the regions.  Behaviors were introduced to support the discovery of views and the context of a region, as well as to create a uniform API for both WPF and Silverlight.  Additionally, due to the behaviors, an effective way to expand the functionality of the regions appears. <br><br>  Behavior is a class that is attached to a region and gives it additional functionality.  The behavior joins the region and remains active throughout its existence.  For example, <code>AutoPopulateRegionBehavior</code> joining a region automatically creates and adds view types registered to a region with the given name.  Throughout the life of the region, it continues to monitor <code>RegionViewRegistry</code> for new registrations.  It is easy to add a new behavior, or replace the existing one, both for the entire application and for a particular region. <br><br>  The next few sections will talk about standard behaviors that are automatically added to regions.  An exception is the behavior of <code>SelectorItemsSourceSyncBehavior</code> , which is attached only to controls that are descendants of the <code>Selector</code> class. <br><br><h5>  <i>Registration Behavior</i> </h5><br>  <code>RegionManagerRegistrationBehavior</code> responsible for ensuring that the region is registered with the correct regional manager.  When a view or control is added to a visual tree, as a descendant of another control, or region, any region associated with the control must be registered in the RegionManager of the parent control.  When you delete a control, the registration of the region should be removed. <br><br><h5>  <i>Auto-Population Behavior</i> </h5><br>  Two classes are responsible for discovering views.  One of them is <code>AutoPopulateRegionBehavior</code> .  When joining a region, it receives all types of views that are registered under the name of this region.  After that, he creates instances of these views and adds them to the region.  After creating a region, <code>AutoPopulateRegionBehavior</code> oversees the registration of new views in <code>RegionViewRegistry</code> for a given region name. <br><br>  If you need more control over the process of discovering views, you can create your own implementation of <code>IRegionViewRegistry</code> and <code>AutoPopulateRegionBehavior</code> . <br><br><h5>  <i>Region Context Behaviors</i> </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The regional context functionality is enclosed in </font></font><code>SyncRegionContextWithHostBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>BindRegionContextToDependencyObjectBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These behaviors are responsible for observing changes in the context created for the region, and synchronizing this context with the corresponding dependency property attached to the view.</font></font><br><br><h5> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activation Behavior</font></font></i> </h5><br> <code>RegionActiveAwareBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">responsible for notifying whether it is active or not. </font><font style="vertical-align: inherit;">To receive these notifications, the view must implement an interface </font></font><code>IActiveAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These notifications are unidirectional and are passed from behavior to presentation. </font><font style="vertical-align: inherit;">A view cannot make itself active by affecting the corresponding property of the interface </font></font><code>IActiveAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Region lifetime behavior</font></font></i> </h5><br> <code>RegionMemberLifetimeBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determines whether the item should be removed from the region when it is deactivated. </font></font><code>RegionMemberLifetimeBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monitors the </font></font><code>ActiveViews</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">region's </font><font style="vertical-align: inherit;">collection </font><font style="vertical-align: inherit;">to determine which items have been rendered inactive. </font><font style="vertical-align: inherit;">The behavior checks whether the item has been deleted </font></font><code>IRegionMemberLifetime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or </font></font><code>RegionMemberLifetimeAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in that order) to determine if it should be saved during deletion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the item is </font></font><code>System.Windows.FrameworkElement</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then it is </font></font><code>DataContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also checked for availability </font></font><code>IRegionMemberLifetime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or </font></font><code>RegionMemberLifetimeAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Region elements are checked in the following order:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Value </font></font><code>IRegionMemberLifetime.KeepAlive</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Value </font></font><code>IRegionMemberLifetime.KeepAlive  DataContext</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Value </font></font><code>RegionMemberLifetimeAttribute.KeepAlive</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Value </font></font><code>RegionMemberLifetimeAttribute.KeepAlive  DataContext</code> </li></ol><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control Specific Behavior </font></font></h5><br> <code>SelectorItemsSourceSyncBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used only if the control is inherited from </font></font><code>Selector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for example, </font></font><code>TabControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF. </font><font style="vertical-align: inherit;">It is responsible for matching the selected elements in the selector with active views in the region. </font></font><br><br> <code>TabControlRegionSyncBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar </font></font><code>SelectorItemsSourceSyncBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and used instead in Silverlight.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Expansion of regional functionality </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prism has extension points that allow you to extend or override the standard behavior of the provided APIs. </font><font style="vertical-align: inherit;">For example, you can write your own regional adapter, regional behavior, change the way the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parses the URI, or extend the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to work with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight Frame Navigation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For more information, see the </font></font><a href="http://msdn.microsoft.com/en-us/library/gg430866(v%3Dpandp.40).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extending Prism</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section </font><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> View composition </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The composition of views is how views are created. </font><font style="vertical-align: inherit;">In composite applications, views from multiple modules must be displayed at runtime at a specific point in the user interface. </font><font style="vertical-align: inherit;">To achieve this, you need to specify the regions in which the views will be located, and how the views will be created and displayed in these regions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Views can be created and displayed both automatically, through the detection of views, and programmatically, through the introduction of views. </font><font style="vertical-align: inherit;">These two techniques determine how views will be mapped to named regions in the application's user interface.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection representations ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Discovery</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this approach, it is necessary to create a relationship between the name of a region and the type of view in </font></font><code>RegionViewRegistry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When a region is created, it searches for everything </font></font><code>ViewTypes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">associated with that region and automatically creates and loads the appropriate views. </font><font style="vertical-align: inherit;">Accordingly, in this approach, you have no direct control over how the representations corresponding to the given region are created and displayed.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The introduction of representations ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Take Injection</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, your code gets a link to the region, and then programmatically adds the view to it. This is usually done at the time the module is loaded, or in response to a user action. Your code should request </font></font><code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the required region by its name, and then embed the view into it. So you have much more control over how views are created and substituted into regions. It is also possible to remove views from regions. However, you cannot add views to regions that have not yet been created.</font></font><br><br><h5>  Navigation </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prism Library 4.0 contains the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> facilitates the process of introducing views through the ability to navigate by URI </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> creates a view, adds it to the region, and activates it. </font><font style="vertical-align: inherit;">Additionally, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allows you to navigate to previously created views contained in a region. </font><font style="vertical-align: inherit;">See Part 8 </font></font><a href="http://msdn.microsoft.com/en-us/library/gg430861(v%3Dpandp.40).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Navigation,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for more information </font><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When to use the detection of views, and when the introduction of views </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The choice of region loading strategy depends on the requirements of the application and the function of the region. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View detection can be used in the following situations:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Automatic loading of views is desired, or required. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A single view instance is loaded into the region. </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Introduction of the submission: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The application uses the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You need explicit control over how the view is created and displayed, or you must delete views from regions, for example, in response to a user action or as a result of navigation. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You must display multiple instances of a single view in a region, linking each view to your data. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You must control which instance of the region the view is added to. </font><font style="vertical-align: inherit;">For example, you want to add a presentation with information about the buyer to the relevant information region. </font><font style="vertical-align: inherit;">This approach requires the creation of a region with a limited scope, which will be shown later.</font></font></li></ul><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI build scripts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In composite applications, views from multiple modules are displayed at runtime in certain places in the user interface. </font><font style="vertical-align: inherit;">For this, you need to specify the regions where these views will be displayed, as well as how these views will be created and associated with these regions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separation of representations and places of their display in the interface allows the appearance and layout of the application to develop independently of the representations loaded into the regions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following sections describe the main scenarios that you will encounter when developing composite applications. </font><font style="vertical-align: inherit;">If needed, examples from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will demonstrate solutions for these scenarios.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shell creation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shell is the root object of the application, which contains the primary UI content. In a WPF application, the shell is an instance </font></font><code>Windows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In Silverlight - </font></font><code>RootVisualUserControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shell can contain named regions in which modules can substitute the necessary representations. It can also set certain high-level UI elements, such as the main menu and toolbar. The shell defines the basic structure and presentation of the application, similar to ASP.NET master pages. It can set styles, borders that are visible in the shell itself, it can also set styles, patterns and themes applied to views loaded into the shell.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shell is optional when creating applications using Prism. If you create a new composite application, creating a shell will give you a well-defined application root, as well as make initialization templates available to the main interface of the application. However, if you add Prism support to an existing application, you are not required to change its core architecture to add a shell. Instead, you can modify existing window or control definitions to add regions to display views. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can have more than one shell in an application. If an application is designed in such a way that allows users to open more than one top-level window, each such window may behave like a shell for its content.</font></font><br><br><h5>  <i>Stock Trader RI</i> </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> application </font><font style="vertical-align: inherit;">as a shell has a main window. The following illustration highlights the shell and views. The shell is the main window that is created when the application starts and contains all views. It specifies the regions in which the modules substitute the necessary views, and several high-level user interface elements, such as the header and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Watch List</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> banner. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/58c/e40/ec258ce4071121e2ba8b35f88b2b6b64.png" alt="Shell, regions and views in Stock Trader RI"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shell </font><font style="vertical-align: inherit;">is presented in the file </font></font><code>Shell.xaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, its separated code file </font></font><code>Shell.xaml.cs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and also in the view model </font></font><code>ShellViewModel.cs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Shell.xaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains markup and UI elements that are part of the shell, including definitions of regions to which modules add views.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following XAML shows the structure and main elements defined in the shell. </font><font style="vertical-align: inherit;">The attached property </font></font><code>RegionName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is used to define regions, and the background image of the window is the background image of the shell. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XAML Shell.xaml (WPF)</font></font></b> <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"StockTraderRI.Shell"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">!‚Äîshell</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">background</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">--</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window.Background</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ImageBrush</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ImageSource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Resources/background.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Stretch</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UniformToFill"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window.Background</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Logo"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"CFI"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STOCKTRADER"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--    --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemsControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MainToolbar"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Static inf:RegionNames.MainToolBarRegion}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemsControl</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Controls:AnimatedTabControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PositionBuySellTab"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Static inf:RegionNames.MainRegion}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ContentControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ActionContent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Static inf:RegionNames.ActionRegion}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ContentControl</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"SideGrid"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Controls:ResearchControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Static inf:RegionNames.ResearchRegion}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Controls:ResearchControl</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation is </font></font><code>Shell.xaml.cs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very simple. </font></font><code>Shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is exportable, which allows it to be created by the loader. </font><font style="vertical-align: inherit;">Its dependencies are resolved by MEF. </font><font style="vertical-align: inherit;">The shell has a single dependency on </font></font><code>ShellViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is implemented during creation using MEF. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C # Shell.xaml.cs</font></font></b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Shell</span></span> : <span class="hljs-title"><span class="hljs-title">Window</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); } [Import] ShellViewModel ViewModel { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DataContext = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C # ShellViewModel.cs</font></font></b> <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ShellViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">NotificationObject</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        . }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By the amount of code in the code-behind file, you can appreciate the power and simplicity of the architecture of composite applications, and the weakness of the connection between the shell and views. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task regions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regions play the role of zones in which one or more views are displayed at run time. Modules can detect regions and load views into them without knowing how and where they are located. This allows you to change change regions without affecting the modules that provide content for them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regions can be specified by associating a region name with a control in XAML, or in code. Access to the region can be obtained by name. At run time, views are added to the regions and displayed according to the characteristics of the control associated with the region. For example, a region associated with</font></font><code>TabControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, will display tabs. Regions support adding and deleting views. Views can be created and displayed both programmatically and automatically. In Prism, this is achieved through the use of embedding views and detecting views. These two techniques determine how individual views will be mapped to named regions in the user interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The application shell specifies the highest level markup. For example, specifying the location of the main content and navigation content, as shown in the illustration below. The markup inside these high-level views can be set similarly, allowing the user interface to be composed recursively.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/d0e/a8a/efdd0ea8aabe419572cdc79428643f97.png" alt="Shell preparation"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regions are sometimes used to specify the location of several logically related views. </font><font style="vertical-align: inherit;">In this case, the region is usually ItemsControl or its successor, which displays views in accordance with its markup strategy, such as the arrangement of elements in the form of a stack, or tabs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regions may also be used for specifying the location of a single representation using, for example </font></font><code>ContenControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, the control associated with the region displays only one view at a time, even if several views have been added to this region.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regions in the shell </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i> </h5><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides examples of approaches using both a single view and several views added to a region. You can see both approaches in the application shell. The following illustration shows the regions defined in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shell </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/24c/ab8/53a/24cab853a2698a94da3e062bfe1b9a9b.png" alt="Regions in the shell Stock Trader RI"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An approach using multiple representations can be seen in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when buying, or selling stocks. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Buy / Sell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> area is a list-like region, which is shown </font></font><code>OrderCompositeView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as list items, as shown below. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec3/24d/5fd/ec324d5fdb7d6535844593cc99e15752.png" alt="ItemsControl Region"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shell region </font></font><code>ActionRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains </font></font><code>OrdersView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>OrdersView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Submit All</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel All buttons</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as the region </font></font><code>OrdersRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><code>OrdersRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attached to a control </font></font><code>ListBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that displays multiple views </font></font><code>OrderCompositeViews</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">IRegion</font></i><font style="vertical-align: inherit;"> interface</font></font><i><font style="vertical-align: inherit;"></font></i> </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The region is the class that implements the interface </font></font><code>IRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A region is a container containing content to display in a control. </font><font style="vertical-align: inherit;">The following code shows what is contained in this interface.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRegion</span></span> : <span class="hljs-title"><span class="hljs-title">INavigateAsync</span></span>, <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { IViewsCollection Views { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IViewsCollection ActiveViews { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Context { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } Comparison&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; SortComparison { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-function">IRegionManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> view</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IRegionManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> viewName</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IRegionManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> view, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> viewName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> createRegionManagerScope</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> view</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deactivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> view</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> viewName</span></span></span><span class="hljs-function">)</span></span>; IRegionManager RegionManager { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IRegionBehaviorCollection Behaviors { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IRegionNavigationService NavigationService { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding Regions to XAML </font></font></h5><br> <code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides an attached property that can be used to easily create a region in XAML. To use this approach, you must add the Prism namespace in the XAML and use the attached property </font></font><code>RegionName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The following example shows how to associate a region with an item </font></font><code>AnimatedTabControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get a string with the name of a region </font></font><code>MainRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the markup extension is used </font></font><code>x:Static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This avoids the use of magic strings in XAML.</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Controls:AnimatedTabControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PositionBuySellTab"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Static inf:RegionNames.MainRegion}"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silverlight 4 does not allow to use </font></font><code>x:Static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Consequently, you will have to use string values ‚Äã‚Äãto specify regions, or, if desired, define string resources available to the entire application that will contain these names. </font><font style="vertical-align: inherit;">An attached property </font></font><code>RegionName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, using this approach, can be associated with such a resource to get the name of a region.</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Controls:AnimatedTabControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Regions:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MainRegion"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding regions in the code </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using </font></font><code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it </font><font style="vertical-align: inherit;">is </font><font style="vertical-align: inherit;">possible to register regions directly in the code, without using XAML. </font><font style="vertical-align: inherit;">The following code example shows how to associate a region with a control in a file of separated code. </font><font style="vertical-align: inherit;">To get started, you need to get a link to the regional manager. </font><font style="vertical-align: inherit;">Then, using the static method </font></font><code>RegionManager.SetRegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>RegionManager.SetRegionName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the region is associated with the control </font></font><code>ActionContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, after which its name is set in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúActionRegion‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs">IRegionManager regionManager = ServiceLocator.Current.GetInstance&lt;IRegionManager&gt;(); RegionManager.SetRegionManager(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ActionContent, regionManager); RegionManager.SetRegionName(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ActionContent, <span class="hljs-string"><span class="hljs-string">"ActionRegion"</span></span>);</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display views in the region when it loads </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When approaching the detection of views, modules can register views (view models, presenter models) in certain named regions. After the region is displayed at run time, any view that has been registered in the region will be created and displayed automatically. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modules register views using a register. The parent representation may request from the register the representations that were registered in the region with the given name. After detection, the parent view places these views on the screen, adding them to the control associated with the region.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the application is loaded, the composite view receives notifications that it needs to place in the user interface new views added to the register. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following illustration shows the approach of finding views. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ee/1e4/1ed/6ee1e41edfe93259944631ac6d5e0d4e.png" alt="View Detection"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prims provides a standard register class </font></font><code>RegionViewRegistry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that serves to register submissions in named regions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to display a view in a region, you need to register it with the manager of the regions. </font><font style="vertical-align: inherit;">As shown in the example below. </font><font style="vertical-align: inherit;">You can directly specify the type of the presentation, after which it will be resolved through the dependency injection container when loading the region.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.regionManager.RegisterViewWithRegion(<span class="hljs-string"><span class="hljs-string">"MainRegion"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(EmployeeView));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also provide a delegate that returns the required view, as shown below. </font><font style="vertical-align: inherit;">The regional manager will display a view when creating a region.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.regionManager.RegisterViewWithRegion(<span class="hljs-string"><span class="hljs-string">"MainRegion"</span></span>, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.Resolve&lt;EmployeeView&gt;());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composition QuickStar UI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a step-by-step guide in a </font></font><code>EmployeeModule ModuleInit.cs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file that demonstrates how to use the method </font></font><code>RegisterViewWithRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display representation in the region program </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the approach with the introduction of views, they are programmatically added, or removed from the regions, the modules responsible for them. To make this possible, the application supports the register of named regions declared in the user interface. A module can use this register in order to obtain a region from it, and programmatically introduce a representation into it. In order to make access to regions uniform throughout the application, each named region implements an interface </font></font><code>IRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The following illustration shows the implementation approach. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/20e/6f6/f7b/20e6f6f7b2e5ee88f5cdf27b7b16a5e4.png" alt="Introduction of ideas"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To introduce a view into a region, you need to get this region through the regional manager and call the method</font></font><code>Add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as shown below. </font><font style="vertical-align: inherit;">With this approach, the view becomes visible only after adding it to the region, which can happen after the module is loaded, or in response to a user action.</font></font><br><br><pre> <code class="cs hljs">IRegion region = regionManager.Regions[<span class="hljs-string"><span class="hljs-string">"MainRegion"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ordersView = container.Resolve&lt;OrdersView&gt;(); region.Add(ordersView, <span class="hljs-string"><span class="hljs-string">"OrdersView"</span></span>); region.Activate(ordersView);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stock Trader RI and UI Composition QuickStart provide step-by-step tutorials for applying this approach. </font></font><br><br><h5>  Navigation </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prism Library 4.0 includes the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation API</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , gives a rich and uniform approach to the implementation of navigation in WPF, or Silverlight applications. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation regions is a case of introducing views. During the processing of a navigation request, an attempt is made to find a representation in the region that can fulfill the request. If it is impossible to find a suitable representation, the necessary representation is created through the DI container, after which it is embedded in the target region and activated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code shows how to </font><font style="vertical-align: inherit;">initiate a navigation query </font><font style="vertical-align: inherit;">using the example of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i> <code>ArticleViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.regionManager.RequestNavigate(RegionNames.SecondaryRegion, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"/NewsReaderView"</span></span>, UriKind.Relative));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information, see part 8, section ‚ÄúNavigation‚Äù. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View-Switching Navigation QuickStart</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State-Based Navigation QuickStart</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are also examples of this approach.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streamlining views in the region </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardless of which approach is used, it is often necessary for an application to locate views in a region in a specific contract, in case the region is associated with a control that supports the display of several views. By default, views are located in the region in the order in which they were registered and added to the region. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating a composite application, views are often registered with different modules. Creating dependencies between modules can solve this problem, but this is not the best approach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To control how views will be located in a region, Prism provides an attribute </font></font><code>ViewSortHint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It contains a string property.</font></font><code>Hint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which allows the submission to give a hint about how it wants to be located in the region. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When displaying views, the class </font></font><code>Region</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses a standard sorting procedure, taking into account this hint, which is a simple, case-sensitive, sorting of rows. Views that have this attribute are sorted and placed in front of those that do not have it. Views without an attribute are arranged in the order in which they were added to the region. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to change the way that the views are sorted by region, the class </font></font><code>Region</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has a property </font></font><code>SortComparison</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">through which you can specify your own delegate </font></font><code>Comparison&lt;object&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is important to note that sorting the properties of a region </font></font><code>Views</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>ActiveViews</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflected on the UI due to the fact that adapters such as </font></font><code>ItemsControlRegionAdapter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binding directly to these properties. </font><font style="vertical-align: inherit;">A nonstandard adapter can implement its own sorting method, which will override the sorting of the views produced in the region. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Switching QuickStart</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demonstrates a simple numbering scheme for streamlining views in the navigation region. </font><font style="vertical-align: inherit;">The following example </font></font><code>ViewSortHint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">applies to each view responsible for navigation.</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export</span></span>] [ViewSortHint(<span class="hljs-string"><span class="hljs-string">"01"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EmailNavigationItemView</span></span> { ‚Ä¶ } [Export] [ViewSortHint(<span class="hljs-string"><span class="hljs-string">"02"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalendarNavigationItemView</span></span> { ‚Ä¶ } [Export] [ViewSortHint(<span class="hljs-string"><span class="hljs-string">"03"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ContactsDetailNavigationItemView</span></span> { ‚Ä¶ } [Export] [ViewSortHint(<span class="hljs-string"><span class="hljs-string">"04"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ContactsAvatarNavigationItemView</span></span> { ‚Ä¶ }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data exchange between multiple regions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prims provides several approaches for interacting between views, depending on your scenario. The regional manager provides the property </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as one such approach. </font></font><br><br> <code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useful when you want the parent view and child views to share a common data context. </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is an attached property. You set the required context through this property, and it becomes available to the child views added to the corresponding region. It can be both simple and complex object to which data can be bound. </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be used both in the detection and in the implementation of views.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The note. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The property </font></font><code>DataContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Silverlight and in WPF is used to set the local data context for the view. </font><font style="vertical-align: inherit;">This allows the view to use data binding to interact with the view model, local presenter, or model. </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Used to share context across multiple views and is not local to a single view. </font><font style="vertical-align: inherit;">This provides a simple mechanism for sharing context across multiple views.</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code shows how the attached property is </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used in XAML.</font></font><br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TabControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">AutomationProperties.AutomationId</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DetailsTabControl"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Static local:RegionNames.TabRegion}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cal:RegionManager.RegionContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Path=SelectedEmployee.EmployeeId}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> &gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also install </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the code as shown below.</font></font><br><br><pre> <code class="cs hljs">RegionManager.Regions[<span class="hljs-string"><span class="hljs-string">"Region1"</span></span>].Context = employeeId;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get the context in the view, you can use a static method </font></font><code>RegionContext.GetObservableContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It takes a view as a parameter, after which the context can be accessed through a property </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as shown below.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRegionContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model.EmployeeId = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)RegionContext.GetObservableContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).Value; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value </font></font><code>RegionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be changed by simply setting a new property value </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Views can subscribe to notifications of context changes by using an event of an </font></font><code>PropertyChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object of type </font></font><code>ObservableObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that can be obtained by calling a method </font></font><code>GetObservableContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This allows multiple views to be synchronized when the context changes. </font><font style="vertical-align: inherit;">The following example shows how to subscribe to context changes.</font></font><br><br><pre> <code class="cs hljs">ObservableObject&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; viewRegionContext = RegionContext.GetObservableContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); viewRegionContext.PropertyChanged += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ViewRegionContext_OnPropertyChangedEvent; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewRegionContext_OnPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.PropertyName == <span class="hljs-string"><span class="hljs-string">"Value"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = (ObservableObject&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;) sender; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newValue = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)context.Value; } }</code> </pre><br><blockquote> <b>.</b> <br> <code>RegionContext</code>      ,   ,   ,       <code>DependencyObject</code> .   ,    ,      <code>DependencyObject</code> .        ,      ,  ,    .  ,   <code>RegionContext</code> ,        <code>DependencyObject</code> . <br></blockquote><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regions with a limited scope are only available when using the introduction of views. You may need them if you need a view with your own copy of the region. Views that define regions using the attached property automatically inherit the parent property </font></font><code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Usually, this is </font></font><code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">common to the entire application, registered in the shell. If the application creates more than one view of this type, each of them will use the same one </font></font><code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to register their regions. Since the regional manager only allows unique regional names, the second registration of the region in the view will throw an exception.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To prevent this, you can use regions with limited scope. </font><font style="vertical-align: inherit;">In this case, each submission will have its own regional manager, and its regions will be registered with the help of this particular manager, and not the parent one. </font><font style="vertical-align: inherit;">This approach is shown in the illustration below. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/1a7/0e2/1d31a70e2cf9da1577df65da0c9466ed.png" alt="      "><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a local for the submission manager of regions, you must specify that a new one </font></font><code>RegionManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be created when adding a submission to a region, as shown below.</font></font><br><br><pre> <code class="cs hljs">IRegion detailsRegion = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.regionManager.Regions[<span class="hljs-string"><span class="hljs-string">"DetailsRegion"</span></span>]; View view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> createRegionManagerScope = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; IRegionManager detailsRegionManager = detailsRegion.Add(view, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, createRegionManagerScope);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The Add method returns a new manager of regions, which the view can save for later reference to regions from a local scope. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating views </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The appearance of your application can be created from a variety of elements, such as custom controls, special controls and data templates. In the case of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , user controls are typically used to represent scattered areas in the main window, but this is not standard. In your application, you must take the approach that you are most familiar with and which is best suited for the designer. Regardless of the appearance of your application, you will most likely use a mixture of user controls, special controls and data templates. The following figure shows where the </font><i><font style="vertical-align: inherit;">Stock Trader RI</font></i><font style="vertical-align: inherit;"> uses which approaches.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will also be referenced by subsequent sections describing each of the approaches.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bda/b14/ff5/bdab14ff57bd67ff2a186b49a4a2c71b.png" alt="   ,        Stock Trader RI"><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> User Controls (User Controls) </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both Expression Blend and Visual Studio 2010-2012 provide rich support for creating these controls. </font><font style="vertical-align: inherit;">User controls created using these tools are recommended for creating user interfaces when using Prism. </font><font style="vertical-align: inherit;">As mentioned earlier, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> makes extensive use of them to create regional content. </font><font style="vertical-align: inherit;">The WatchListView.xaml user control is a good example of how a small part of the user interface can be placed inside the WatchModule module. </font><font style="vertical-align: inherit;">Such controls are very simple and straightforward to create and use.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Special Controls ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Custom Controls</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some situations, user controls may be too limited. </font><font style="vertical-align: inherit;">In these cases, special markup or extensibility may be more important than ease of creation. </font><font style="vertical-align: inherit;">In such cases, special controls may be useful. </font><font style="vertical-align: inherit;">In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a pie chart control is a good example of this. </font><font style="vertical-align: inherit;">This type of control is more difficult to create than custom, and has more limited support for creating in Expression Blend and Visual Studio 2010-2012, compared to user controls.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Templates data ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Templates</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data templates are an important part of most types of applications that operate on data. Using data patterns in list-based controls is especially common in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In many cases, using data templates, you can do without creating user controls at all. The region </font></font><code>ResearchRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses data templates to display articles, and, along with styles for </font></font><code>Items</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, shows which element has been selected. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expression Blend has full support for visually creating data templates. Visual Studio 2010 provides data template editing only through XAML. In Visual Studio 2012, the visual editor is taken from Expression Blend, so almost similar support for data templates is provided, as in Expression Blend itself.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resources ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Resources</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resources, such as styles, resource dictionaries and templates, can be scattered throughout the application. </font><font style="vertical-align: inherit;">This is especially true for composite applications. </font><font style="vertical-align: inherit;">When you think about where to put a resource, pay special attention to the dependencies between the UI elements and the resources they need. </font><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stock Trader RI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">, shown in the figure below, contains tags that show where resources can live.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/07c/a4f/56f/07ca4f56f3db38edad0c2fdf26399ffe.png" alt="   "><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application Tier Resources </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typically, application-level resources are used throughout the application. </font><font style="vertical-align: inherit;">These resources are usually focused on the application root directory, but they can also provide default styles based on types for modules and controls. </font><font style="vertical-align: inherit;">An example is the style for a text field, applicable to the type </font></font><code>TextBox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the root of the application. </font><font style="vertical-align: inherit;">This style will be applied to all text fields in the application, unless it is overridden in the module, or in the control itself.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module Level Resources </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The role of module-level resources is similar to the application-level resources in that they apply to all elements in a module. </font><font style="vertical-align: inherit;">The use of resources at this level can provide a consistent view of the individual module, as well as ensure the reuse of individual elements within the module. </font><font style="vertical-align: inherit;">The use of module-level resources should be limited within this module. </font><font style="vertical-align: inherit;">Creating dependencies between modules can lead to hard-to-find errors in the display of custom elements.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control Level Resources </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This type of resource is usually found in user element libraries, in which resources are used by all the elements contained in it. </font><font style="vertical-align: inherit;">These resources usually have the smallest scope, due to the fact that libraries of user elements contain only certain elements and do not contain user controls. </font><font style="vertical-align: inherit;">(In Prism applications, user controls are usually placed in the modules in which they are used.)</font></font></div><p>Source: <a href="https://habr.com/ru/post/176895/">https://habr.com/ru/post/176895/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176883/index.html">Metric # 4 - Podcast on technologies and design of interfaces and services</a></li>
<li><a href="../176885/index.html">Electronic universe (a look at computer science from the 80s)</a></li>
<li><a href="../176887/index.html">We send a thick client through an SSL tunnel with encryption according to GOST</a></li>
<li><a href="../176891/index.html">RubyMine 5.4 is ready for Rails 4</a></li>
<li><a href="../176893/index.html">CDN for statics and measurement: how Yandex.Mail has become faster in the regions</a></li>
<li><a href="../176897/index.html">Bootstrap-wysiwyg: a tiny text editor</a></li>
<li><a href="../176901/index.html">Trainings Nokia Developers Workshop in Russia</a></li>
<li><a href="../176909/index.html">Autoprefixer - the ultimate solution to the prefix problem in CSS</a></li>
<li><a href="../176911/index.html">We return privacy or big brother watching me on the standard settings. Part 3. We set up Facebook and VKontakte</a></li>
<li><a href="../176913/index.html">Highlights for upcoming US immigration reform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>