<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to calculate the time for testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... Or, in other words, how to calculate the time for testing so that everyone believes? After all, in fact, we usually have two goals. The first is t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to calculate the time for testing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/335/c3b/068/335c3b0680254198b99432263d29b8be.png"><br><br>  ... Or, in other words, how to calculate the time for testing so that everyone believes?  After all, in fact, we usually have two goals.  The first is to count the time in such a way as not to make a mistake and correctly allocate resources - most likely, at first it won't be possible to do it well anyway.  The second goal is more realistic: calculate the time for testing so as to prove to someone that you need more people in the team, explain why you don‚Äôt have time, etc. Strangely enough, after just 50 you do the second, then and the first will work! <br><br>  Let's now look at how to count the time for testing, with specific examples. <br><a name="habracut"></a><br><h2>  Case 1: ‚ÄúHere's the TZ, how much time will it take to write test cases?‚Äù </h2><br>  Suppose a volume folder with a well-written technical task (TZ) comes to us.  We are asked how long it will take to write test scenarios (TS) for the whole case. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before we can answer this question, we would like to know: <br><br><ul><li>  <strong>Who will write the vehicle?</strong> <br><br><ul><li>  <strong>What is the level of the</strong> <strong>person</strong> who will write the vehicle: does he have less or more experience than you?  If he has less experience, of course, he will need more time.  If he has as much experience as you have, then your estimates converge.  If a person is better than you, then it is not at all clear why you were asked to count time. </li><li>  <strong>What is the level of knowledge of technology</strong> ?  Will a person be able to conduct low-level testing, it‚Äôs good to understand everything, will he understand what is happening with the base, for example? </li><li>  <strong>What is the level of knowledge of the subject area</strong> ?  This is even more important than the level of knowledge of technology, because if we, for example, need to test some sophisticated financial application, and we do not understand what bonds and options are, it will take a lot of time to understand the subject area.  Without this, it is difficult to understand how difficult TZ is, how complex the product is and, ultimately, how voluminous and what a vehicle should be. </li></ul><br><br></li><li>  <strong>Why and for whom are the vehicles written?</strong> <br><br><ul><li>  <strong>For ourselves</strong> - if we test our internal development.  We have our own product, our own team, and we write the vehicle for our product. </li><li>  <strong>For the client</strong> .  Sometimes the customer orders only testing, and sometimes only the vehicle.  Sometimes he asks to test once, and then leave him an artifact, according to which he can test it himself.  TCs for a client may be less detailed and detailed, but differently than if we wrote a vehicle for ourselves.  So, we ourselves are well aware of all the terms of testing, but we may need to write in detail in the TC all sorts of complex things from the subject area.  The client may understand the subject matter perfectly, but he may not know what form validation is and he will need to explain it. </li><li>  <strong>For acceptance testing</strong> - in this case, the TS is even more difficult to write than for the client, because it is testing, the results of which the client may not accept if he does not want.  Therefore, we write a much more formal TS for acceptance testing - there should not be any statements like ‚Äúeverything works fine,‚Äù because for such a TS the client may not accept anything from you and never. </li><li>  <strong>For automation.</strong>  Here we have to think about data-driven testing, how to automate it, and so on. </li><li>  <strong>For the soul</strong> .  In this case, we just want to understand and there is no request from the team for testing. </li></ul><br><br></li><li>  <strong>Where are written, in which test management system?</strong> <br><br><ul><li>  <strong>Familiar environment.</strong> </li><li>  <strong>Unfamiliar environment.</strong>  In an unfamiliar environment, of course, we will need more time. </li></ul><br><br></li></ul>  From the answers to all these questions depends on how long it takes to write one positive test case - T1.  It is also worth considering the time to write one negative TS (it will be denoted as T-1).  My experience says that negative TSs are usually written longer - they also usually need more.  Of course, it happens differently here, but it seems to me that the better we know the subject area, the better we understand the application, the better we understand where and how it can fall, the more negative we will have the TS.  If you have, for example, three negative TSs have one negative, you probably misunderstand the application.  If for one positive you can come up with 500 negative TS, this is a good job.  My ratio of positive and negative TS is usually from ¬Ω to 1/5. <br><br>  T. h. We need to calculate the time to write a positive TS, estimate the ratio of positive and negative, and count the time entirely. <br><br><h3>  Evaluation options: </h3><br><ul><li>  <strong>Rough expert</strong> .  For example, we know that usually we write 5 TS on one page of the TZ.  Usually one vehicle we write 20 min.  The specification of 300 pages.  5 x 20 x 300 = 30000 - this is how many minutes offhand we will write the TS. <br><br><ul><li><img src="https://habrastorage.org/files/f28/8a4/091/f288a409186043bead7228a3be8fbcf2.jpg"><br><br>  X test cases per page, T1 minutes per vehicle, Y pages (T-1 - negative vehicle) </li></ul><br><br></li><li>  <strong>Rough deductive</strong> .  Suppose we have a project plan, there are deadlines, there is a team.  And we present what the ratio of developers to testers should be in the project.  For example, the project for six months.  There are five developers (which means we need two testers for these six months).  We see that the TS will be writing about a quarter of the time of all the time allotted for testing.  This is a rough but quick way to count. <br><br><ul><li>  Testing takes X time from project time. </li><li><img src="https://habrastorage.org/files/38c/827/841/38c827841d1f4f02a79b3c01a8f51035.jpg"><br><br>  Writing test cases Y from time to time for testing </li></ul><br><br></li><li>  <strong>Inductively experienced</strong> .  This is a slow way to evaluate, but it works well.  Here we are trying to write a vehicle for each part of the TZ.  It is better to do this with the degree of detail with which we will write them further.  However, you can make at least a high-level vehicle.  It may take a day, two, a week, but it will help to understand how much time it will take at all. <br><br><ul><li>  We break the TZ into homogeneous parts (for example, by functional) and try to write the TS for each part </li><li>  We look at how much time it took to write a vehicle for a certain number of pages of each part, based on this, we calculate how much time it would take to write a vehicle for each part. </li><li>  We add the time counted for each part. <br><br><img src="https://habrastorage.org/files/d20/925/b4a/d20925b4a3e24670a19bf7337a9070d1.jpg"><br><br></li></ul><br></li></ul><br><br><h3>  Example </h3><br>  Let's now see how these techniques work, with a specific example.  For example, we are writing a social network for pets.  We have a TK for this social network, only 47 pages.  Suppose we broke it into homogeneous parts.  Here is what we end up with: <br><br><ul><li>  <strong>TK</strong> : <br><br><ul><li>  Host account (5 pages). </li><li>  Animal profile (15 pages). </li><li>  Fotochki, video (12 pages). </li><li>  Friends (8 pages). </li><li>  Messages (5 pages). </li><li>  Non-functional requirements (2 pages, 12 pieces). </li></ul></li><li>  <strong>Programmers</strong> : four people. </li><li>  <strong>Deadline</strong> : six months. </li><li>  <strong>A rough expert assessment</strong> (adopted in our company): two positive vehicles per page, 0.5 hours for a positive vehicle, 45 minutes.  - negative </li></ul><br>  Now we will try to calculate how many hours it will take for us to write the vehicle (but, pay attention, not for testing at all): <br><br><ul><li>  <strong>A rough expert assessment</strong> : (0.5 + 3 x 0.75) x 2 x 47 = 258 hours. <br><br>  <em>Comment: negative TS here 3 to one positive.</em>  <em>Two positive TS on one page, only 47 pages.</em>  <em>0.75 is 45 minutes.</em> </li><li>  <strong>A rough deductive estimate</strong> : (176 x 4 x 6) / 3/4 = 352 hours. <br><br>  <em>Comment: 176 hours per month, four programmers for six months, divided into three (the ratio of programmers to testers is approximately 1.5 testers on a project (4 / 1.5 ‚âà 3)) and divided into four (a quarter of the time from all testing will be go to the writing of the vehicle).</em> </li><li>  <strong>Inductively experienced rating</strong> : (1 x 10) + (3 x 15) + (6 x 12) + (2 x 16) + (1 x 10) + (3 x 12) = 205 <br><br>  <em>Comment: we spent an hour on the host account, managed to cover half of the page, and we have 10 of these halves (1x10).</em>  <em>We spent 3 hours on the profile of the animal, for three hours covered one page (3x15).</em>  <em>We spent 6 hours covering one page of photos / videos (so much because, let's say, everything is very difficult).</em>  <em>2 hours spent on friends and made half a page during this time (2x16).</em>  <em>1 hour spent on the message, made an hour half a page (1x10).</em>  <em>Non-functional requirements, we decided to look here not by the pages, but by the requirements themselves: we spent 3 hours on one requirement (3x12).</em>  <em>All this took us 16 hours - it means that in 2 days we estimated the time at 205 hours.</em> </li></ul><br><br>  Our estimates do not agree, but this is normal - at least we were able to calculate approximately.  And if we have enough time for evaluation, we can make an assessment in several ways. <br><br><h3>  We count time when using Agile </h3><br>  Now let's talk about flexible development methodologies, when there is no technical task.  It is not very clear how to evaluate, but still some approaches can be distinguished.  For example, you can: <br><br><ul><li>  just walk through the backlog; </li><li>  write high-level TS; </li><li>  write down all the actions inside the sprint and try to estimate how much time they will take - this approach will be discussed below. </li></ul><br><br>  <em><strong>Retreat for QA-managers</strong></em> <br><br>  Now a slight digression for QA-managers, project managers.  We can divide all actions for creating and launching test cases into the following components: <br><br><table border="1" cellpadding="10"><tbody><tr><td>  <strong>CREATION OF THE CU</strong> <br><br></td><td>  <strong>STARTING TS</strong> <br><br></td></tr><tr><td>  Environment Preparation (TCenv) <br><br></td><td>  Fulfillment of preconditions (TRprec) <br><br></td></tr><tr><td>  TC structure preparation (TCstr) <br><br></td><td>  Run Regression Tests (TRreg) <br><br></td></tr><tr><td>  Creating a vehicle for the finished functionality (TCbase) <br><br></td><td>  Running tests for new functionality (TRnew) <br><br></td></tr><tr><td>  Creating a vehicle for new functionality (TCnew) <br><br></td><td>  Build new configurations (Cnew) <br><br></td></tr><tr><td>  Automated Test Creations (TCa) <br><br></td><td>  Number of configurations (Qconf) <br><br></td></tr><tr><td>  Change created TC (TCchng) <br><br></td><td>  Retest after fixing bugs (TRrtst) <br><br></td></tr><tr><td>  Outcome: Œ£TC = TCenv + TCstr + TCbase + TCnew <br><br>  + (TCbase + TCnew) x TCa + TCchng <br><br></td><td>  Total: Œ£TR = (TRprec + TRreg + TRnew) x Qconf + TRrtst x Qconf + Cnew <br><br></td></tr></tbody></table><br><br>  How much time does the testing take, we see the table in the formulas below - everything is clear and without comments. <br><br><h3>  Case 2: "Here is a piece of functionality, how much time will it take for testing?" </h3><br>  How much time will it take to test one or another part of the functional?  To estimate this, there are different ways: <br><br><ul><li><img src="https://habrastorage.org/files/118/606/5fd/1186065fdeda476097907f63123e3dcb.jpg"><br>  You can see how much time it usually takes us to test <strong>similar functionality.</strong> </li><li>  You can look at <strong>the same functionality</strong> , if we have previously tested this.  It is very convenient!  If you, of course, recorded the last time, how much time it took. <br><img src="https://habrastorage.org/files/fa9/20e/06e/fa920e06edbe4359bc615f133a5f0604.jpg"><br><br></li><li>  <strong>Deductive evaluation</strong> - if we know how much this functionality takes place in the general functionality (if we, for example, already know how long a complete regression takes), we simply see that testing this functionality will take, for example, one fifth of the total time. <br><br><img src="https://habrastorage.org/files/49c/28c/60e/49c28c60efd8492aba27a2e74ab8ee28.jpg"><br><br></li><li>  <strong>Inductive assessment</strong> - we remember how much time we spend on each vehicle.  We look at this functionality and we understand that we need 10 - 15 vehicles to test it. <br><br><img src="https://habrastorage.org/files/a73/b2e/e4f/a73b2ee4fbeb4719801aaac921814772.jpg"><br><br></li></ul><br>  What is important to remember in this case?  That the new functionality can again require time to prepare the environment.  It is important to remember about the existence of a coefficient on familiarity with the system: more time is spent on tests if you run them away the first time than if you run them second or third time.  But if the second time comes in a month, then you still chase him away, as if for the first time - however, this is different for everyone. <br><br><h3>  Case 3: "Why do you not have time?!" </h3><br>  The next, very common question asked by testers: ‚Äúwhat do you do, why do you not have time, why do you need help with automation, why do not you want us to release new versions every day - there are no new bugs ? .. " <br><br>  To show what we do, we can write out for each project all the tasks that are performed in one sprint, and paint them by day: calculate how much time each task takes on a particular day.  So you can see the average, maximum and minimum load. <br><br>  An example of such a table: <br><br><img src="https://habrastorage.org/files/dca/9dd/e52/dca9dde5293a4c76989d318bb055896d.jpg"><br><br>  When I did it, I saw that the load could not always be optimally distributed - sometimes the load is large, and sometimes half a day there is nothing at all to do.  This allows you to make certain conclusions and somehow optimize the process, to distribute the load - for example, to do some things in advance, even if it is not completely consistent with the logic of the process.  For example, if we have a lot of free time at the beginning of a sprint, we can already start writing user stories for the next sprint.  Although we don‚Äôt know the structure of the next sprint, we can most likely predict that these two or three stories will definitely fit into it - they are usually the most critical, usually they have to be rewritten anyway, so this is a good exercise. <br><br>  So: <br><br><ol><li>  <strong>Defined a task list.</strong> </li><li>  <strong>Defined "input parameters".</strong> </li><li>  <strong>Determined time for each task.</strong> </li><li>  <strong>Smeared the tasks of the sprint.</strong> </li></ol><br><br>  Received download in hours by day.  And if it turns out that every day you need 24 hours of testing, and we have only two people ... So, we definitely need a third tester! <br><br><h3>  Case 4.1: "We are releasing the assembly on Friday, or even earlier - so how much time do you need for testing?" <br><br>  In this case, the testing process is as follows: <br></h3><br><ol><li>  <em>Smoke test + test for complete regression x on the number of major platforms + test for basic functionality for all platforms + tests for complete regression on platforms (see the matrix).</em> </li><li>  <em>Retesting</em> : <em>smoke test + validation of the whole platform.</em> </li></ol><br><br>  Tests for a complete regression on the platforms are carried out in this case as follows (Cr, FF, etc., here are different platforms, in this case browsers): <br><br><table border="1" cellpadding="10"><tbody><tr><td><br><br></td><td>  <strong>Cr</strong> <br><br></td><td>  <strong>FF</strong> <br><br></td><td>  <strong>IE9</strong> <br><br></td><td>  <strong>IE8</strong> <br><br></td><td>  <strong>Cr '</strong> <br><br></td><td>  <strong>FF '</strong> <br><br></td><td>  <strong>Œ£</strong> <br><br></td></tr><tr><td>  <strong>Smoke test</strong> <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  6 <br><br></td></tr><tr><td>  <strong>Basic functionality</strong> <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  one <br><br></td><td>  6 <br><br></td></tr><tr><td>  <strong>Administration</strong> <br><br></td><td>  one <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>Statistics for admins</strong> <br><br></td><td><br><br></td><td>  one <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>User account</strong> <br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>User Posts</strong> <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>User friends</strong> <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td><td><br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>User photos</strong> <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>User Files</strong> <br><br></td><td>  one <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td></tr><tr><td>  <strong>User Settings</strong> <br><br></td><td><br><br></td><td>  one <br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td><br><br></td><td>  one <br><br></td></tr></tbody></table><br><br>  According to this matrix, we see that for each platform we are testing any part of the functional: as a result, it turns out that we have checked all the functionality and tried the work on each platform.  We can also shift this matrix - in the end it turns out that for a certain number of runs we will check every function on each platform anyway.  This is still a simple scheme - and in fact there may be 20 configurations without the ability to automate their testing - of course, in this case, we will not have time to test everything, and we will test on such a matrix. <br><br>  As a result, we obtain the following formula: <br><br>  Œ£T = (Tprec + Treg) x (Qmain + 1) + (Tprec + Tbase + Tsmoke) x Qconf + (Tsmoke + Tvalidation) x Qconf x Qreturns <br><br>  Qmain - the number of main configurations on which we test everything. <br><br>  Qreturns - the number of returns. <br><br>  By this formula, it is clear how much time it will take.  On it, you can try to keep track of time, look at which testing takes the most time.  It will also be clear where it is better to automate where - we will understand where automation will save us the most time. <br><br><h3>  Case 4.2: ‚ÄúToo many tests!  Hurry up". </h3><br>  If we are required to perform testing faster, we can cut the number of tests according to the following principles: <br><ul><li>  <strong>We look at the priorities:</strong> <br><ul><li>  <strong>test cases</strong> - if we describe the priorities of the vehicle.  Then we will work only with the highest priority vehicles; </li><li>  <strong>user stories or bugs</strong> , if our vehicles are attached to them. </li></ul></li><li>  <strong>We look at the</strong> release notes, which include <strong>:</strong> <br><ul><li>  <strong>critical functionality</strong> , without which the application will not work and no one needs it; </li><li>  <strong>declared new functionality -</strong> since it is publicly announced, users will definitely check it; </li><li>  <strong>Correction of critical errors</strong> (most likely, errors will already be checked); </li><li>  <strong>declared bug fixes</strong> - we stated that we fixed something, and we check it; </li><li>  <strong>Known issues</strong> (known issues) - paradoxically, but we definitely have to retest those errors that we have stated as errors with which we have released a product.  Why do this?  First, you need to check that their impact is exactly the same as we described.  Secondly, we check if that workaround of this error that we offer works. </li></ul></li><li>  Instead of reducing the amount of testing, you can <strong>increase the command</strong> : <br><ul><li>  <strong>To add programmers</strong> is best from your own project.  For example, they can write data generators, etc., all for automation or semi-automation.  They do it well, and the responsibility for testing is still not on them - so they do not suffer from the fact that their code does not work well.  For the same reason, some programmers can be asked to check the code of other programmers. </li><li>  <strong>Call testers</strong> from other projects, or from this project, but doing something else. </li></ul></li></ul><br><br>  In general, the actual testing process can be represented as a triangle.  The angles of this triangle are: <br><br><ol><li>  <strong>Scope of</strong> testing. </li><li>  <strong>The number of people</strong> in the team. </li><li>  <strong>The period</strong> for which you want to perform testing. </li></ol><br><br>  The speed and quality of testing depends on these three aspects - it is on them that you need to think in order to successfully plan your work.  So, for example, if we are offered to test a product for an unrealistically short period, and we definitely don‚Äôt meet or refuse such work (if we don‚Äôt want to release a low-quality product, of course), or work with the above aspects.  Then we can: <br><br><ol><li>  <strong>Reduce</strong> testing. </li><li>  <strong>Increase the number of people</strong> in the team. </li><li>  Ask to <strong>extend the period</strong> for testing. </li></ol><br><br>  The latter method is perhaps the most reliable: after all, people in a team can give inept ones, and a reduction in the amount of testing can lead to the release of a raw product. <br><br>  A method also works here - to ask why such terms are.  Maybe you need only one function for one client - then we will make him a private release, and later we will test everything else. <br><br><h3>  And finally, the case: the revision of the already released project </h3><br>  If the project has already been released, but there is a demand to finalize it, how then to calculate the time for testing, for development, etc.?  In this case, we count time as usual, but at the same time we multiply it by two, because all people have already forgotten everything, already in other projects - it takes time to get acquainted with the system.  In addition, the addition may be outside the standard cycle, therefore, in addition to testing this addition, complete regression may be needed - then we add time to the complete regression. <br><br>  Posted by:  , QA Lead </div><p>Source: <a href="https://habr.com/ru/post/272193/">https://habr.com/ru/post/272193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272183/index.html">Cisco IOS shellcode: All-in-one</a></li>
<li><a href="../272185/index.html">Announcement of laboratory works with Windows Camp // Labs and useful links for developers</a></li>
<li><a href="../272187/index.html">Not all cookies are equally useful.</a></li>
<li><a href="../272189/index.html">Feature javascript protocol or generation of random password in the browser tab</a></li>
<li><a href="../272191/index.html">Welcome to TechDay in Moscow on December 10</a></li>
<li><a href="../272195/index.html">A couple of words about the "death" of Flash, Animate CC and Web standards</a></li>
<li><a href="../272197/index.html">Release close ...</a></li>
<li><a href="../272199/index.html">Installing and configuring Puppet version 3.8 using the example of Centos 6.5</a></li>
<li><a href="../272201/index.html">The steady beauty of indecent models</a></li>
<li><a href="../272203/index.html">Where does IaaS work?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>