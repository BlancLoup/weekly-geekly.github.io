<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript Guide, Part 9: ES7, ES8, and ES9 Features Overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, in the ninth part of the translation of the JavaScript manual, we will review the features that have emerged in the language thanks to the stan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript Guide, Part 9: ES7, ES8, and ES9 Features Overview</h1><div class="post__text post__text-html js-mediator-article">  Today, in the ninth part of the translation of the JavaScript manual, we will review the features that have emerged in the language thanks to the standards ES7, ES8 and ES9. <br><br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/429552/">Part 1: first program, language features, standards</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/429556/">Part 2: code style and program structure</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/429838/">Part 3: Variables, Data Types, Expressions, Objects</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/430382/">Part 4: Functions</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/430380/">Part 5: Arrays and Loops</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/430376/">Part 6: Exceptions, Semicolon, Pattern Literals</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/431072/">Part 7: strict mode, this keyword, events, modules, mathematical calculations</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/431074/">Part 8: ES6 feature overview</a> <br>  ‚Üí <a href="https://habr.com/company/ruvds/blog/431872/">Part 9: Overview of ES7, ES8, and ES9 Capabilities</a> <br><br> <a href="https://habr.com/company/ruvds/blog/431872/"><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">ES7 standard</font> </h2><br>  The ES7 standard, which, in accordance with the official terminology, is called ES2016, was released in the summer of 2016.  In comparison with ES6, it brought not so much new to the language.  In particular, we are talking about the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> The <code>Array.prototype.includes()</code> method. </li><li>  Exponentiation operator. </li></ul><br><h3>  <font color="#3AC1EF">ArArray.prototype.includes () method</font> </h3><br>  The <code>Array.prototype.includes()</code> method is designed to check for the presence of an element in an array.  Finding the required in the array, it returns <code>true</code> , not finding - <code>false</code> .  Prior to ES7, the <code>indexOf()</code> method served to perform the same operation, which returns, if an element is found, the first index by which it can be found in the array.  If <code>indexOf()</code> does not find the element, it returns the number <code>-1</code> . <br><br>  According to the JavaScript type conversion rules, the number <code>-1</code> converted to <code>true</code> .  As a result, to check the results of the work of <code>indexOf()</code> it was necessary to use a not very convenient construction of the following form. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  If in a situation like this, assuming that <code>indexOf()</code> does not find an element, returns <code>false</code> , use something like the one shown below, the code will not work correctly. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// console.log('Not found') }</span></span></code> </pre> <br>  In this case, it turns out that the construction <code>![1,2].indexOf(3)</code> gives <code>false</code> . <br><br>  Using the <code>includes()</code> method, such comparisons look much more logical. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].includes(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  In this case, the construction <code>[1,2].includes(3)</code> returns <code>false</code> , this value is an operator <code>!</code>  turns into <code>true</code> and a message is received in the console stating that the required element in the array was not found. <br><br><h3>  <font color="#3AC1EF">‚ñçExponentiation operator</font> </h3><br>  The exponentiation operator performs the same function as the <code>Math.pow()</code> method, but it is more convenient to use it than the library function, since it is part of the language. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span> ** <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  This operator can be considered a nice addition JS, which is useful in applications that perform certain calculations.  A similar operator exists in other programming languages. <br><br><h2>  <font color="#3AC1EF">ES8 standard</font> </h2><br>  Standard ES8 (ES2017) was released in 2017.  He, like ES7, introduced not so much new to the language.  Namely, we are talking about the following possibilities: <br><br><ul><li>  Supplement lines to a given length. </li><li>  <code>Object.values()</code> method. </li><li>  <code>Object.entries()</code> method. </li><li>  The <code>Object.getOwnPropertyDescriptors()</code> method. </li><li>  Trailing commas in function parameters. </li><li>  Asynchronous functions. </li><li>  Shared memory and atomic operations. </li></ul><br><h3>  <font color="#3AC1EF">‚ñçAdd lines up to specified length</font> </h3><br>  In ES8, there are two new methods for the <code>String</code> object ‚Äî <code>padStart()</code> and <code>padEnd()</code> . <br><br>  The <code>padStart()</code> method fills the current line with another line until the final line reaches the desired length.  Filling occurs at the beginning of the line (left).  Here is how to use this method. <br><br><pre> <code class="javascript hljs">str.padStart(targetLength [, padString])</code> </pre> <br>  Here <code>str</code> is the current string, <code>targetLength</code> is the length of the resulting string (if it is less than the length of the current string ‚Äî this string will be returned unchanged), <code>padString</code> ‚Äî optional ‚Äî the string used to populate the current string.  If the <code>padString</code> parameter <code>padString</code> not specified, a space character is used to <code>padString</code> current line to the specified length. <br><br>  The <code>padEnd()</code> method is similar to <code>padStart()</code> , but the line is filled to the right. <br><br>  Consider examples of the use of these methods. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">'`</span></span>) <span class="hljs-comment"><span class="hljs-comment">//'      test' console.log(`'${str1}'`) //'test******'</span></span></code> </pre> <br>  Here, when using <code>padStart()</code> indicating only the desired length of the result line, spaces were added to the beginning of the source line.  When using <code>padEnd()</code> <code>*</code> characters were added to the end of the source line with the indication of the length of the final line and the line. <br><br><h3>  <font color="#3AC1EF">Object Method Object.values ‚Äã‚Äã()</font> </h3><br>  This method returns an array containing the values ‚Äã‚Äãof the object's own properties, that is, properties that the object itself contains, and not those that are accessible to it through a chain of prototypes. <br><br>  Here's how to use it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// ['Fred', 87]</span></span></code> </pre> <br>  This method also applies to arrays. <br><br><h3>  <font color="#3AC1EF">Object Method Object.entries ()</font> </h3><br>  This method returns an array, each element of which is also an array containing, in the format of <code>[key, value]</code> , the keys and values ‚Äã‚Äãof the object's own properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// [['name', 'Fred'], ['age', 87]]</span></span></code> </pre> <br>  When applying this method to arrays, indexes of elements are displayed as keys, and what is stored in the array at the corresponding indices is displayed as values. <br><br><h3>  <font color="#3AC1EF">Get Method getOwnPropertyDescriptors ()</font> </h3><br>  This method returns information about all the object's own properties.  Associated attribute sets (descriptors) are associated with properties of objects.  In particular, we are talking about the following attributes: <br><br><ul><li>  <code>value</code> is the property value of the object. </li><li>  <code>writable</code> - <code>true</code> if the property can be changed. </li><li>  <code>get</code> - contains the getter function associated with the property, or if there is no such function, <code>undefined</code> . </li><li>  <code>set</code> - contains the setter function for the property or <code>undefined</code> . </li><li>  <code>configurable</code> - if there is <code>false</code> - the property cannot be deleted, its attributes cannot be changed except for the value. </li><li>  <code>enumerable</code> ‚Äî if this property contains true ‚Äî the <code></code> is enumerable. </li></ul><br>  Here is how to use this method. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj)</code> </pre> <br>  It takes an object whose property information you want to know, and returns an object containing this information. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> propDescr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(propDescr) <span class="hljs-comment"><span class="hljs-comment">/* { name:  { value: 'Fred',    writable: true,    enumerable: true,    configurable: true }, age:  { value: 87,    writable: true,    enumerable: true,    configurable: true } } */</span></span></code> </pre> <br>  Why do you need this method?  The fact is that it allows you to create small copies of objects, copying, among other properties, getters and setters.  This could not be done using the <code>Object.assign()</code> method for copying objects, which appeared in the ES6 standard. <br><br>  In the following example, there is an object with a setter that outputs, using <code>console.log()</code> , what it is trying to write to its corresponding property. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person1 = { set name(newName) {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(newName) } } person1.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">// x</span></span></code> </pre> <br>  Let's try to copy this object using the <code>assign()</code> method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person2 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(person2, person1) person2.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ,   </span></span></code> </pre> <br>  As you can see, this approach does not work.  The <code>name</code> property, which in the original object was a setter, is now represented as a regular property. <br><br>  Now we will copy the object using the <code>Object.defineProperties()</code> methods (it appeared in ES5.1) and <code>Object.getOwnPropertyDescriptors()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person3 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(person3, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person1)) person3.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//x</span></span></code> </pre> <br>  Here in the copy of the object the setter remained. <br><br>  It should be noted that the limitations specific to <code>Object.assign()</code> are also characteristic of the <code>Object.create()</code> method when it is used to clone objects. <br><br><h3>  <font color="#3AC1EF">‚ñçCompleted commas in function parameters</font> </h3><br>  This feature allows you to leave a comma at the end of the list of parameters or arguments, respectively, when you declare and when you call functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> var1, var2, </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } doSomething( 'test1', 'test2', )</span></span></code> </pre> <br>  This improves the usability of version control systems.  Namely, we are talking about the fact that, when adding new parameters to a function, it is not necessary to change the existing code just to insert a comma. <br><br><h3>  <font color="#3AC1EF">‚ñç Asynchronous functions</font> </h3><br>  The ES2017 standard introduced the <code>async/await</code> construction, which can be considered the most important innovation of this version of the language. <br><br>  Asynchronous functions are a combination of promises and generators; they simplify constructions, which were previously described with a large amount of template code and inconvenient promis chains.  In fact, this is a high-level abstraction over promises. <br><br>  When promises appeared in the ES2015 standard, they were designed to solve existing problems with asynchronous code, which they did.  But in the two years that have shared the ES2015 and ES2017 standards, it has become clear that promises cannot be considered the final solution to these problems. <br><br>  In particular, promises were aimed at solving the problem of ‚Äúhell callbacks‚Äù, but, having solved this problem, they themselves showed themselves not with the best hand due to the complexity of the code in which they are used.  As a matter of fact, the <code>async/await</code> construction solves the problem of promises and improves usability with asynchronous code. <br><br>  Consider an example. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  This code will display the following in the console. <br><br><pre> <code class="javascript hljs">Before After I did something</code> </pre> <br>  As you can see, after the call to <code>doSomething()</code> program continues to run, after <code>Before</code> , After is immediately output to the console, and after three seconds has passed, <code>I did something</code> is displayed. <br><br><h4>  Asynchronous function sequential call </h4><br>  If necessary, asynchronous functions can form something like call chains.  Such constructions have better readability than something similar, based solely on promises.  This can be seen in the following example. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promiseToDoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)=&gt;</span></span>{     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneWatchingSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">// I did something and I watched and I watched as well })</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçShared memory and atomic operations</font> </h3><br>  Here we are talking about the <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a> object, which allows us to describe shared memory areas, and the <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Atomics">Atomics</a> object, which contains a set of atomic operations in the form of static methods.  Details about the possibilities that these objects give to the programmer can be found <a href="https://habr.com/company/ruvds/blog/332194/">here</a> . <br><br><h2>  <font color="#3AC1EF">ES9 standard</font> </h2><br>  ES9 (ES2018) is the latest version of the standard at the time of publication of this material.  Here are its main features: <br><br><ul><li>  Application of spread and rest operators to objects. </li><li>  Asynchronous iterators. </li><li>  Method <code>Promise.prototype.finally()</code> . </li><li>  Regular Expression Improvements </li></ul><br><h3>  <font color="#3AC1EF">‚ñçApplication of spread and rest operators to objects</font> </h3><br>  We have already spoken about the rest and spread operators, which appeared in ES6 and can be used to work with arrays.  Both of them look like three points.  The rest operator, in the following example of destructuring an array, allows you to place its first and second elements in the <code>first</code> and <code>second</code> constants, and all the others in the <code>others</code> constant. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, ...others] = numbers <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //[ 3, 4, 5 ]</span></span></code> </pre> <br>  The <code>spread</code> operator allows you to pass arrays to functions that are waiting for normal parameter lists. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c, d, e</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b + c + d + e <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = sum(...numbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">//15</span></span></code> </pre> <br>  Now, using the same approach, you can work with objects.  Here is an example of using the rest operator in a destructive assignment operation. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { first, second, ...others } = { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">fourth</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">fifth</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //{ third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br>  Here is the spread operator used when creating a new object based on an existing one.  This example continues the previous one. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = { first, second, ...others } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(items) <span class="hljs-comment"><span class="hljs-comment">//{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Asynchronous iterators</font> </h3><br>  The new <code>for-await-of</code> design allows you to call asynchronous functions that return promises in cycles.  Such cycles are waiting for promise resolution before proceeding to the next step.  Here's what it looks like. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> readLines(filePath)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(line) }</code> </pre> <br>  It should be noted that such cycles should be used in asynchronous functions - just as is done when working with the <code>async/await</code> construction. <br><br><h3>  <font color="#3AC1EF">Prom Method Promise.prototype.finally ()</font> </h3><br>  If the promise is successfully resolved, the next <code>then()</code> method is called.  If something goes wrong, the <code>catch()</code> method is called.  The <code>finally()</code> method allows you to execute some code, regardless of what happened before. <br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'file.json'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error)) .finally(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'finished'</span></span>))</code> </pre> <br><h3>  <font color="#3AC1EF"> Improved regular expressions</font> </h3><br>  In regular expressions, it was possible to retrospectively check strings ( <code>?&lt;=</code> ).  This allows you to search in the lines for some constructions, in front of which there are some other constructions. <br><br>  The possibility of forward checks using the <code>?=</code> Construct was in regular expressions implemented in JavaScript and up to the ES2018 standard.  Such checks let you know if another fragment follows a fragment of a string. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?= Waters)/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  The design <code>?!</code>  performs the inverse operation ‚Äî a match will be found only if there is no other line following the specified string. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?! Waters)/g</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br>  For retrospective verification, as already mentioned, the <code>?&lt;=</code> Construct is used. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  The inverse operation can be performed using the <code>?&lt;!</code>  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br><h4>  Regular Expression Unicode Control Sequences </h4><br>  In regular expressions, you can use the class <code>\d</code> , the corresponding any digit, the class <code>\s</code> , the corresponding any space character, the class <code>\w</code> , which matches any alphanumeric character, and so on.  The feature in question extends the set of classes that can be used in regular expressions, allowing you to work with Unicode sequences.  We are talking about the class <code>\p{}</code> and the opposite class <code>\P{}</code> . <br><br>  In Unicode, each character has a set of properties.  These properties are specified in curly brackets of the group <code>\p{}</code> .  So, for example, the <code>Script</code> property determines the family of languages ‚Äã‚Äãto which a character belongs, the <code>ASCII</code> property, logical, is <code>true</code> for ASCII characters, and so on.  For example, find out if certain strings contain exclusively ASCII characters. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('ABC@')) //true console.log(r.test('ABC')) //false</span></span></code> </pre> <br>  The <code>ASCII_Hex_Digit</code> property is <code>true</code> only for characters that can be used to write hexadecimal numbers. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{ASCII_Hex_Digit}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'0123456789ABCDEF'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('H')) //false</span></span></code> </pre> <br>  There are many other similar properties that are used the same way as described above.  Among them - <code>Uppercase</code> , <code>Lowercase</code> , <code>White_Space</code> , <code>Alphabetic</code> , <code>Emoji</code> . <br><br>  Here, for example, using the <code>Script</code> property to determine which alphabet is used in a string.  Here we check the string for use of the Greek alphabet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{Script=Greek}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('hey')) //false</span></span></code> </pre> <br>  Details on these properties can be read <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">here</a> . <br><br><h4>  Named groups </h4><br>  Captured character groups in ES2018 can be given names.  Here's what it looks like. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: { year: '2015', month: '01', day: '02' } ] */</span></span></code> </pre> <br>  Without the use of named groups, the same data would be available only as elements of an array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: undefined ] */</span></span></code> </pre> <br><h4>  Regular Expression Flag s </h4><br>  Using the <code>s</code> flag causes the symbol to be <code>.</code>  (dot) will, among other things, match the newline character.  Without the use of this flag, a dot matches any character except a newline character. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/hi.welcome/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'hi\nwelcome'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// false console.log(/hi.welcome/s.test('hi\nwelcome')) // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  With this material we complete the publication of translations of <a href="https://medium.freecodecamp.org/the-complete-javascript-handbook-f26b2c71719c">this</a> JavaScript manual.  We hope these publications have helped those who have not worked with JavaScript before, to take their first steps in programming in this language. <br><br>  <b>Dear readers!</b>  If you have not written in JS before and mastered this language according to this manual, please share your impressions. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/431872/">https://habr.com/ru/post/431872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431858/index.html">Mitap Sberteha in Rostov-on-Don</a></li>
<li><a href="../431862/index.html">Mitap Sberteha in Yekaterinburg</a></li>
<li><a href="../431864/index.html">PVS-Studio ROI: how not to lose millions (draft article)</a></li>
<li><a href="../431866/index.html">Programmers misconceptions about names - with examples</a></li>
<li><a href="../431870/index.html">Developer of interactive books with LEDs complained about the theft of ideas by Google employees</a></li>
<li><a href="../431874/index.html">Imba: JavaScript-compatible language for quick work with DOM</a></li>
<li><a href="../431876/index.html">Angular Application Optimization</a></li>
<li><a href="../431878/index.html">Unknown javascript features</a></li>
<li><a href="../431880/index.html">Doom of SceneKit. Yandex experience with 3D graphics in iOS</a></li>
<li><a href="../431884/index.html">Microsoft has overtaken Apple by market capitalization: how did this happen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>