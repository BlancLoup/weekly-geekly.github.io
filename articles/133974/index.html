<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Application Development for Meego Harmattan</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post participates in the competition "Smart phones for smart posts". 


 In this article I would like to share my experience in software developm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Application Development for Meego Harmattan</h1><div class="post__text post__text-html js-mediator-article">  This post participates in the competition <a href="http://habrahabr.ru/company/Nokia/blog/132522/">"Smart phones for smart posts".</a> <br><br><img src="http://www.gaadget.ru/f/items/2/2586.jpg" alt="image" align="right"><br>  In this article I would like to share my experience in software development using QtComponents with the example of Meego Harmattan.  We will write the editor of notes with synchronization by means of Ubuntu One. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All development will be carried out using scratchbox, it has some advantages in comparison with madde, but it works exclusively on linux systems. <br>  Among the key advantages, I would like to note that the build is done in chroot, and in the case of armel, qemu is used for emulation.  Conditions as close as possible to the fighting.  This allows you to avoid additional fuss with the cross-configuration setting.  An additional advantage is the presence of apt-get, which is able to install all the dependencies necessary for the assembly, which undoubtedly will be needed when writing an application is more complicated than helloworld. <br><h4>  Install and configure scratchbox'a </h4><br><br>  In order to install scratchbox you need to download and run this <a href="http://harmattan-dev.nokia.com/unstable/beta3/harmattan-sdk-setup.py">script</a> from root and then follow its instructions. <br><pre><code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># ./harmattan-sdk-setup.py</span></span></code> </pre> <br>  After installation, you need to re-login so that the user is successfully added to the sbox group. <br>  We will run the scratchbox with the command: <br><pre> <code class="hljs pgsql">$ /scratchbox/<span class="hljs-keyword"><span class="hljs-keyword">login</span></span></code> </pre> <br>  If the installer worked correctly, you should see an invitation similar to the following: <br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">sbox-HARMATTAN_ARMEL: ~</span></span>] &gt;</code> </pre> <br>  If login swears, then try running the run_me_first.sh script, which lies at the root of the scratchbox.  The desired target can be selected using sb_menu.  The rest of the scratchbox manual can be found <a href="http://harmattan-dev.nokia.com/docs/library/html/guide/html/Developer_Library_Alternative_development_environments_Platform_SDK_user_guide_Installing_Harmattan_Platform_SDK.html">here.</a> <br><br><h4>  Creating a cmake project </h4><br><br>  As a collector, I use not the usual qmake, but the more powerful cmake, which can search for dependencies, has a lot of configuration options and is much better suited for cross-platform development.  In this article I will not go deep into the analysis of the assembly system, so for a better understanding I recommend reading this <a href="http://www.devexp.ru/2010/01/cmake-i-qt/">article</a> . <br>  The only disadvantage is that cmake does not know how to Symbian, so you can forget about this platform for now or manually write a special project to build it for this platform.  With all other cmake copes with ease, so in the future I plan to port this application to the desktop systems and, possibly, to Android or even on iOS. <br>  The project consists of a number of dependent libraries, which are connected via git submodule to the main repository, each of them has its own cmake project.  All of them are in the 3rdparty directory and are connected to the main project, so the build goes right away with the main dependencies that are not in the harmattan repositories. <br><br>  List of 3rdparty libraries: <br><ul><li>  QOauth - Qt Oauth protocol implementation </li><li>  k8json is a very fast JSON parser </li><li>  QmlObjectModel - The class that implements the model - a list of objects </li></ul><br>  In addition, there are still external libraries needed for building, but present in the main Harmattan turnips, qca applies to them, let's install it right away, and install cmake: <br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">sbox-HARMATTAN_ARMEL: ~</span></span>] &gt; apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install libqca2-dev cmake</code> </pre> <br>  In order to be able to use it, you need to write a special cmake file that would be able to find the directory with the library header files and the library file itself in order to link with it. <br><pre> <code class="hljs lisp">include(<span class="hljs-name"><span class="hljs-name">FindLibraryWithDebug</span></span>) if(<span class="hljs-name"><span class="hljs-name">QCA2_INCLUDE_DIR</span></span> AND QCA2_LIBRARIES) # in cache already set(<span class="hljs-name"><span class="hljs-name">QCA2_FOUND</span></span> TRUE) else(<span class="hljs-name"><span class="hljs-name">QCA2_INCLUDE_DIR</span></span> AND QCA2_LIBRARIES) if(<span class="hljs-name"><span class="hljs-name">NOT</span></span> WIN32) find_package(<span class="hljs-name"><span class="hljs-name">PkgConfig</span></span>) pkg_check_modules(<span class="hljs-name"><span class="hljs-name">PC_QCA2</span></span> QUIET qca2) set(<span class="hljs-name"><span class="hljs-name">QCA2_DEFINITIONS</span></span> ${PC_QCA2_CFLAGS_OTHER}) endif(<span class="hljs-name"><span class="hljs-name">NOT</span></span> WIN32) find_library_with_debug(<span class="hljs-name"><span class="hljs-name">QCA2_LIBRARIES</span></span> WIN32_DEBUG_POSTFIX d NAMES qca HINTS ${PC_QCA2_LIBDIR} ${PC_QCA2_LIBRARY_DIRS} ${QT_LIBRARY_DIR}) find_path(<span class="hljs-name"><span class="hljs-name">QCA2_INCLUDE_DIR</span></span> QtCrypto HINTS ${PC_QCA2_INCLUDEDIR} ${PC_QCA2_INCLUDE_DIRS} ${QT_INCLUDE_DIR}} PATH_SUFFIXES QtCrypto) include(<span class="hljs-name"><span class="hljs-name">FindPackageHandleStandardArgs</span></span>) find_package_handle_standard_args(<span class="hljs-name"><span class="hljs-name">QCA2</span></span> DEFAULT_MSG QCA2_LIBRARIES QCA2_INCLUDE_DIR) mark_as_advanced(<span class="hljs-name"><span class="hljs-name">QCA2_INCLUDE_DIR</span></span> QCA2_LIBRARIES) endif(<span class="hljs-name"><span class="hljs-name">QCA2_INCLUDE_DIR</span></span> AND QCA2_LIBRARIES)</code> </pre><br>  The search for most dependencies is written in the same style.  For systems with pgkconfig, to which Harmattan belongs everything is simple and clear, for systems where there is none, we will search in the $ QTDIR directory.  In case cmake did not automatically find the library, it will offer to manually set the variables QCA2_INCLUDE_DIR QCA2_LIBRARIES.  This approach makes life easier on systems that do not have a package manager. <br>  In cmake, there are variables that allow you to determine the platform on which this or that program is built, for example: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(WIN32) .... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span>(APPLE) ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span>(LINUX) ... <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>()</code> </pre><br>  Unfortunately, cmake knows nothing about Harmattan, the easiest solution is to run cmake with the -DHARMATTAN = ON switch.  Now we have the HARMATTAN variable defined, and you can write these things: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HARMATTAN) add_definitions(-DMEEGO_EDITION_HARMATTAN) <span class="hljs-meta"><span class="hljs-meta">#  ,         . </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta">()</span></span></code> </pre><br>  Using the same variables, you can determine which GUI implementation will be installed. <br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HARMATTAN) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(CLIENT_TYPE meego) <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>(STATUS <span class="hljs-string"><span class="hljs-string">"Using meego harmattan client"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(CLIENT_TYPE desktop) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND QML_MODULES QtDesktop) <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>(STATUS <span class="hljs-string"><span class="hljs-string">"Using desktop client"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(QML_DIR <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/qml/${CLIENT_TYPE}"</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>(DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${QML_DIR}</span></span> DESTINATION <span class="hljs-variable"><span class="hljs-variable">${SHAREDIR}</span></span>/qml)</code> </pre><br>  For development, QtSDK with harmattan quick components and the -DHARMATTAN switch will be sufficient for development.  In scratchbox, it makes sense to build more or less final versions. <br><br><h4>  C ++ plugin that implements the Tomboy notes API </h4><br><br>  I myself decided to bring the API into a separate qml module, which will be accessible through the import directive.  This is done for the convenience of creating many different implementations of the GUI interface. <br>  The most difficult thing in the development process was to implement authorization using OAuth, during which several different library implementations were enumerated and at the moment I settled on QOauth, which is certainly not perfect, but is quite working.  On <a href="http://habrahabr.ru/blogs/development/86846/">Habr√©</a> there is an article with a description of this library, so we will immediately move on to solving urgent problems.  First of all, we need to get the most desired token. <br>  The point is not tricky, just send a request to the address and wait for us to receive a request for basic authorization via https: <br><pre> <code class="hljs php">UbuntuOneApi::UbuntuOneApi(QObject *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QObject(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), m_manager(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QNetworkAccessManager(this)), m_oauth(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QOAuth::Interface(this)) { ... connect(m_manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)), SLOT(onAuthenticationRequired(QNetworkReply*,QAuthenticator*))); } ... void UbuntuOneApi::requestToken(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;email, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;password) { m_email = email; m_password = password; QUrl url(<span class="hljs-string"><span class="hljs-string">"https://login.ubuntu.com/api/1.0/authentications"</span></span>); url.addQueryItem(QLatin1String(<span class="hljs-string"><span class="hljs-string">"ws.op"</span></span>), QLatin1String(<span class="hljs-string"><span class="hljs-string">"authenticate"</span></span>)); url.addQueryItem(QLatin1String(<span class="hljs-string"><span class="hljs-string">"token_name"</span></span>), QLatin1Literal(<span class="hljs-string"><span class="hljs-string">"Ubuntu One @ "</span></span>) % m_machineName); qDebug() &lt;&lt; url.toEncoded(); QNetworkRequest request(url); QNetworkReply *reply = m_manager-&gt;get(request); reply-&gt;setProperty(<span class="hljs-string"><span class="hljs-string">"email"</span></span>, email); reply-&gt;setProperty(<span class="hljs-string"><span class="hljs-string">"password"</span></span>, password); connect(reply, SIGNAL(finished()), SLOT(onAuthReplyFinished())); } ... void UbuntuOneApi::onAuthenticationRequired(QNetworkReply *reply, QAuthenticator *auth) { auth-&gt;setUser(reply-&gt;property(<span class="hljs-string"><span class="hljs-string">"email"</span></span>).toString()); auth-&gt;setPassword(reply-&gt;property(<span class="hljs-string"><span class="hljs-string">"password"</span></span>).toString()); }</code> </pre><br>  As you can see, for authentication, the QNetworkAccessManager‚Äôs standard authenticationRequired signal is used, and I just remember the login and password as usual.  Convenient and does not clog the interface with unnecessary details. <br>  Upon completion, the reply should receive a reply in json format that contains the desired token and other important information.  This is where we need the k8json library. <br><pre> <code class="hljs cpp"> QNetworkReply *reply = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;QNetworkReply*&gt;(sender()); QVariantMap response = Json::parse(reply-&gt;readAll()).toMap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.isEmpty()) { <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorizationFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tr(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Unable to recieve token"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; } m_token = response.value(<span class="hljs-string"><span class="hljs-string">"token"</span></span>).toByteArray(); m_tokenSecret = response.value(<span class="hljs-string"><span class="hljs-string">"token_secret"</span></span>).toByteArray(); m_oauth-&gt;setConsumerKey(response.value(<span class="hljs-string"><span class="hljs-string">"consumer_key"</span></span>).toByteArray()); m_oauth-&gt;setConsumerSecret(response.value(<span class="hljs-string"><span class="hljs-string">"consumer_secret"</span></span>).toByteArray()); <span class="hljs-function"><span class="hljs-function">QUrl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">url</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"https://one.ubuntu.com/oauth/sso-finished-so-get-tokens/"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> + reply-&gt;property(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"email"</span></span></span></span><span class="hljs-function"><span class="hljs-params">).toString())</span></span></span></span>; connect(get(url), SIGNAL(finished()), SLOT(onConfirmReplyFinished()));</code> </pre><br>  The next step is to send confirmation of the fact that we received the token (note the last line).  As a result, we should receive an answer ok. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UbuntuOneApi::onConfirmReplyFinished() { QNetworkReply *reply = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;QNetworkReply*&gt;(sender()); QByteArray data = reply-&gt;readAll(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.contains(<span class="hljs-string"><span class="hljs-string">"ok"</span></span>)) { <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasTokenChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  If such a word is in the answer, then everything, you can happily jump and send a signal that the token has finally been received and you can start working with notes, but it was not there!  For compatibility with tomboy api, the notes server requires authorization via a web browser.  Until I managed to get around this problem and, gritting my teeth, I had to add a window to the webkit application, which contains a button ‚Äúallow this user access to notes‚Äù.  We give a pointer to our QNetworkAccessManager to this webkit window and upon successful completion of authorization he will become the owner of the cherished cookies with the data necessary for authorization. <br>  And so that the user doesn‚Äôt have to enter a username and password with a new one, we will fill in these fields through the DOM tree. <br><pre> <code class="hljs erlang-repl"> QWebFrame *frame = page()-&gt;mainFrame(); QWebElement email = frame-&gt;findFirstElement(<span class="hljs-string"><span class="hljs-string">"#id_email"</span></span>); email.setAttribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, m_email); QWebElement pass = frame-&gt;findFirstElement(<span class="hljs-string"><span class="hljs-string">"#id_password"</span></span>); pass.setAttribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, m_password); QWebElement submit = frame-&gt;findFirstElement(<span class="hljs-string"><span class="hljs-string">"#continue"</span></span>); submit.setFocus();</code> </pre><br>  Do not forget to save the received cookies, we want to be too intrusive. <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Notes::onWebAuthFinished(<span class="hljs-type"><span class="hljs-type">bool</span></span> success) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (success) { QNetworkCookieJar *jar = m_api-&gt;manager()-&gt;cookieJar(); QList&lt;QNetworkCookie&gt; cookies = jar-&gt;cookiesForUrl(m_apiRef); QSettings settings; settings.beginWriteArray("cookies", cookies.count()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != cookies.count(); i++) { settings.setArrayIndex(i); settings.setValue("cookie", cookies.at(i).toRawForm()); } settings.endArray(); sync(); } }</code> </pre><br>  In order for the server to successfully process our requests it is necessary that they contain the token received by us earlier in the header.  This is where QOauth comes in handy. <br><pre> <code class="hljs php">QNetworkReply *UbuntuOneApi::get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QUrl &amp;url) { QByteArray header = m_oauth-&gt;createParametersString(url.toEncoded(), QOAuth::GET, m_token, m_tokenSecret, QOAuth::HMAC_SHA1, QOAuth::ParamMap(), QOAuth::ParseForHeaderArguments); QNetworkRequest request(url); request.setRawHeader(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>, header); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_manager-&gt;get(request); }</code> </pre><br>  Now with a light heart you can begin to implement <a href="">tomboy api.</a> <br>  For ease of operation from qml, I decided to submit each note with a separate QObject, and implemented the list of notes through QObjectListModel, the implementation of which I found in qt labs open spaces.  Each note has its own guid, knowing that you can work with it.  Guid is generated on the client side, for this Qt has corresponding methods that are in the QUuid class, so when constructing a new note, you need to generate for it a unique identifier, by which we will refer to it later. <br><pre> <code class="hljs ruby">Note::Note(Notes *notes) : QObject(notes), m_notes(notes), m_status(StatusNew), m_isMarkedForRemoral(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { QUuid uid = QUuid::createUuid(); m_guid = uid.toString(); m_createDate = QDateTime::currentDateTime(); }</code> </pre><br>  Main actions with notes: <br><ul><li>  Sync notes with server </li><li>  Add new note </li><li>  Update note </li><li>  Delete note </li></ul><br>  Based on these actions, we will design the API, in the note model we will make the sync method, and in the note itself, save, remove.  And of course we implement the properties title and content: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Note</span></span></span><span class="hljs-class"> : public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_OBJECT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_PROPERTY</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QString</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">READ</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WRITE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setTitle</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOTIFY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">titleChanged</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_PROPERTY</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QString</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">content</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">READ</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">content</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WRITE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setContent</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOTIFY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textChanged</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_PROPERTY</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">revision</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">READ</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">revision</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOTIFY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">revisionChanged</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_PROPERTY</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Status</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">READ</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOTIFY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">statusChanged</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_PROPERTY</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QDateTime</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createDate</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">READ</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createDate</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOTIFY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createDateChanged</span></span></span><span class="hljs-class">) ...</span></span></code> </pre><br>  A good idea would also be to add the status property of a note that could be used in states in qml. <br><pre> <code class="hljs swift"> <span class="hljs-type"><span class="hljs-type">Q_ENUMS</span></span>(<span class="hljs-type"><span class="hljs-type">Status</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">StatusNew</span></span>, <span class="hljs-type"><span class="hljs-type">StatusActual</span></span>, <span class="hljs-type"><span class="hljs-type">StatusOutdated</span></span>, <span class="hljs-type"><span class="hljs-type">StatusSyncing</span></span>, <span class="hljs-type"><span class="hljs-type">StatusRemoral</span></span> };</code> </pre><br>  To do this, we use the magic Q_ENUMS macro, which generates meta information for enums.  Now in the qml code, you can get their numerical value and compare with each other. <br><pre> <code class="hljs pgsql"> State { <span class="hljs-type"><span class="hljs-type">name</span></span>: "syncing" <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>: note.status === Note.StatusSyncing</code> </pre><br>  Convenient, readable and fast.  Still, numbers are compared, not strings! <br>  By default, in the QObjectListModel, the model element from the delegate can be accessed by the object name, but this does not suit me very much, so I just inherited from the model and changed the name for the ObjectRole role to note. <br><pre> <code class="hljs mel">NotesModel::NotesModel(QObject *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QObjectListModel(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) { QHash&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, QByteArray&gt; roles; roles[ObjectRole] = <span class="hljs-string"><span class="hljs-string">"note"</span></span>; setRoleNames(roles); }</code> </pre><br><br>  And now I will consider the creation of the qml module itself.  In order for our api implementation to be able to be used through import in qml, we need to create in our module a class inherited from QDeclarativeExtensionPlugin and implement the registerTypes method in it, which would register all of our methods and classes. <br><pre> <code class="hljs perl">void QmlBinding::registerTypes(const char *uri) { Q_ASSERT(uri == QLatin1String(<span class="hljs-string"><span class="hljs-string">"com.ubuntu.one"</span></span>)); qmlRegisterType&lt;UbuntuOneApi&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Api"</span></span>); qmlRegisterType&lt;ProgressIndicatorBase&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"ProgressIndicatorBase"</span></span>); qmlRegisterUncreatableType&lt;Notes&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Notes"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">tr</span></span>(<span class="hljs-string"><span class="hljs-string">"Use Api.notes property"</span></span>)); qmlRegisterUncreatableType&lt;Account&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Account"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">tr</span></span>(<span class="hljs-string"><span class="hljs-string">"Use Api.account property"</span></span>)); qmlRegisterUncreatableType&lt;Note&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Note"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">tr</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)); qmlRegisterUncreatableType&lt;NotesModel&gt;(uri, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"NotesModel"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">tr</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } Q_EXPORT_PLUGIN2(qmlbinding, QmlBinding)</code> </pre><br>  You probably noticed assert and want to ask.  And where does this uri come from?  And it is taken from the name of the directory in which our module lies.  That is, Qt will look for our module in: <br><pre> <code class="hljs perl">$QML_IMPORTS_DIR/com/ubuntu/one/</code> </pre><br>  But that's not all.  In order for Qt to find and import our module, it is necessary for the directory to contain a correctly composed qmldir file, which lists binary plugins, qml and js files. <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">plugin</span></span> qmlbinding</code> </pre><br><br><h4>  Developing a qml interface for Meego Harmattan </h4><br><br>  The core of most applications on Meego is the PageStackWindow element, which, oddly enough, is a stack of pages.  Pages are added to the stack using the push method, and retrieved using pop.  One of the pages should be designated as the original.  Each page can have its own toolbar.  You can assign several pages to the same one. <br><pre> <code class="hljs lua">import QtQuick <span class="hljs-number"><span class="hljs-number">1.1</span></span> import com.nokia.meego <span class="hljs-number"><span class="hljs-number">1.0</span></span> import com.ubuntu.one <span class="hljs-number"><span class="hljs-number">1.0</span></span> //    notes API PageStackWindow { id: appWindow initialPage: noteListPage Api { //,  API id: api Component.onCompleted: checkToken() onHasTokenChanged: checkToken() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasToken) loginPage.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> api.notes.sync(); } } ...</code> </pre><br>  Now let's create all the pages we need as well as a standard toolbar, in which there will be a button to add a note and a menu with actions: <br><pre> <code class="hljs mel">... LoginPage { id: loginPage onAccepted: api.requestToken(email, password); } NoteListPage { id: noteListPage notes: api.notes } NoteEditPage { id: noteEditPage } AboutPage { id: aboutPage } ToolBarLayout { id: commonTools visible: true ToolIcon { iconId: <span class="hljs-string"><span class="hljs-string">"toolbar-add"</span></span> onClicked: { noteEditPage.note = api.notes.create(); pageStack.push(noteEditPage); } } ToolIcon { platformIconId: <span class="hljs-string"><span class="hljs-string">"toolbar-view-menu"</span></span> anchors.right: (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> === undefined)? undefined: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.right onClicked: (<span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.status === DialogStatus.Closed)? <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.open(): <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.close() } } Menu { id: <span class="hljs-keyword"><span class="hljs-keyword">menu</span></span> visualParent: pageStack MenuLayout { MenuItem { <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: qsTr(<span class="hljs-string"><span class="hljs-string">"About"</span></span>) onClicked: {<span class="hljs-keyword"><span class="hljs-keyword">menu</span></span>.close(); pageStack.push(aboutPage)} } MenuItem { <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: qsTr(<span class="hljs-string"><span class="hljs-string">"Sync"</span></span>) onClicked: api.notes.sync(); } MenuItem { <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: api.hasToken ? qsTr(<span class="hljs-string"><span class="hljs-string">"Logout"</span></span>) : qsTr(<span class="hljs-string"><span class="hljs-string">"Login"</span></span>) onClicked: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (api.hasToken) api.purge(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> loginPage.open(); } } } }</code> </pre><br><br>  Now let's look at what a separate page is like on the example of NoteListPage, the implementation of which lies in NoteListPage.qml: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.nokia.meego <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.ubuntu.one <span class="hljs-number"><span class="hljs-number">1.0</span></span> Page { id: noteListPage property QtObject notes: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> tools: commonTools //  ,   main.qml PageHeader { //  .           id: <span class="hljs-keyword"><span class="hljs-keyword">header</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>: qsTr("Notes:") } ListView { id: listView anchors.top: <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.bottom anchors.left: parent.left anchors.right: parent.right anchors.bottom: parent.bottom anchors.margins: <span class="hljs-number"><span class="hljs-number">11</span></span> clip: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> focus: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> model: notes.model delegate: ItemDelegate { title: note.title //      subtitle: <span class="hljs-keyword"><span class="hljs-keyword">truncate</span></span>(note.content, <span class="hljs-number"><span class="hljs-number">32</span></span>) onClicked: { noteEditPage.note = note; pageStack.push(noteEditPage); //    } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">truncate</span></span>(str, n, suffix) { str = str.replace(/\r\n/g, ""); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suffix === undefined) suffix = "..."; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length &gt; n) str = str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, n) + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } } } ScrollDecorator { flickableItem: listView } }</code> </pre><br>  The result is such a cute page: <br> <a href="http://itmages.ru/image/view/350837/0fe18429"><img src="https://habrastorage.org/getpro/habr/post_images/cc4/f5a/65b/cc4f5a65bbc83d14096c6f3048719494.png"></a> <br><br>  For the login window, I used the Sheet object, which is a page that leaves at the top.  Usually, using it, the user is asked for some information. <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.nokia.meego <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "constants.js" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UI //     - js   .      namespac<span class="hljs-string"><span class="hljs-string">e'  qml'</span></span>. Sheet { id: loginPage property <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> email: loginInput.text //.   ,           loginInput.text property <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: passwordInput.text content: <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> { // sheet<span class="hljs-string"><span class="hljs-string">' anchors.topMargin: UI.MARGIN_DEFAULT anchors.horizontalCenter: parent.horizontalCenter Image { id: logo source: "images/UbuntuOneLogo.svg" } Text { id: loginTitle width: parent.width text: qsTr("Email:") font.pixelSize: UI.FONT_DEFAULT_SIZE color: UI.LIST_TITLE_COLOR } TextField { id: loginInput width: parent.width } Text { id: passwordTitle width: parent.width text: qsTr("Password:") font.pixelSize: UI.FONT_DEFAULT_SIZE color: UI.LIST_TITLE_COLOR } TextField { id: passwordInput width: parent.width echoMode: TextInput.Password } } acceptButtonText: qsTr("Login") rejectButtonText: qsTr("Cancel") }</span></span></code> </pre><br>  All this magnificence will look like this: <br> <a href="http://itmages.ru/image/view/350838/8bd27712"><img src="https://habrastorage.org/getpro/habr/post_images/19e/b1a/f01/19eb1af018b8a049062faddad7908fc1.png"></a> <br>  On the edit and about pages you need to implement a back button that would return us to the list of notes.  For this, commonTools is no longer very suitable, we need our own toolbars: <br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ToolBarLayout</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: aboutTools visible: true ToolIcon { iconId: <span class="hljs-string"><span class="hljs-string">"toolbar-back"</span></span> onClicked: { pageStack.<span class="hljs-built_in"><span class="hljs-built_in">pop</span></span>() } } }</code> </pre><br><br><h4>  Launch icon </h4><br><br>  In order for the application to have a launch icon, create a .desktop file, which is familiar to all Linux users: <br><pre> <code class="hljs sql">[Desktop Entry] Name=ubuntuNotes Name[ru]=ubuntuNotes GenericName=ubuntuNotes GenericName[ru]=ubuntuNotes <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>=Notes editor <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>[ru]=    Exec=/usr/<span class="hljs-keyword"><span class="hljs-keyword">bin</span></span>/single-<span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> /opt/ubuntunotes/<span class="hljs-keyword"><span class="hljs-keyword">bin</span></span>/ubuntuNotes %U Icon=/usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/icons/hicolor/<span class="hljs-number"><span class="hljs-number">80</span></span>x80/apps/ubuntuNotes.png StartupNotify=<span class="hljs-literal"><span class="hljs-literal">true</span></span> Terminal=<span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>=Application Categories=Network;Qt;</code> </pre><br>  Notice the Exec section: this way we say that the application cannot be started several times.  If we want the application to have a beautiful splash, then we can use the invoker utility. <br><pre> <code class="hljs ruby">Exec=<span class="hljs-regexp"><span class="hljs-regexp">/usr/bin</span></span><span class="hljs-regexp"><span class="hljs-regexp">/invoker --splash=/usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/share/apps</span></span><span class="hljs-regexp"><span class="hljs-regexp">/qutim/declarative</span></span><span class="hljs-regexp"><span class="hljs-regexp">/meego/qutim</span></span>-portrait.png --splash-landscape=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/apps/qutim</span></span><span class="hljs-regexp"><span class="hljs-regexp">/declarative/meego</span></span><span class="hljs-regexp"><span class="hljs-regexp">/qutim-landscape.png --type=e /usr</span></span><span class="hljs-regexp"><span class="hljs-regexp">/bin/qutim</span></span></code> </pre><br>  Of course, all the pictures also need not forget to install otherwise, instead of a beautiful icon, we get a red square. <br><br><h4>  Build deb package </h4><br><br>  The standard dpkg-buildpackage and the usual debian, which is called debian_harmattan for convenience, are used for the build, and the simlink debian_harmattan&gt; debian is set before the build itself.  The control section is standard for debian packages and its creation has already been described in detail in many articles on Habr√©.  I recommend reading <a href="http://habrahabr.ru/blogs/ubuntu/50540/">this</a> series of articles. <br><br>  Contents of the control file: <br><pre> <code class="hljs pgsql">Source: ubuntunotes Section: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/network Priority: extra Maintainer: Aleksey Sidorov &lt;gorthauer87@ya.ru&gt; Build-<span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: debhelper (&gt;= <span class="hljs-number"><span class="hljs-number">5</span></span>),locales,cmake, libgconf2<span class="hljs-number"><span class="hljs-number">-6</span></span>,libssl-dev,libxext-dev,libqt4-dev,libqca2-dev,libqca2-plugin-ossl, libqtm-dev Standards-<span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">3.7</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> Package: ubuntunotes Section: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/network Architecture: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: ${shlibs:<span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>}, ${misc:<span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>},libqca2-plugin-ossl Description: TODO XSBC-Maemo-Display-<span class="hljs-type"><span class="hljs-type">Name</span></span>: ubuntuNotes XSBC-Bugtracker: https://github.com/gorthauer/ubuntu-one-qml Package: ubuntunotes-dbg Section: <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> Priority: extra Architecture: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: ${misc:<span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>}, qutim (= ${binary:<span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>}) Description: <span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span> symbols <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ubuntuNotes <span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span> symbols <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> provide extra <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> crash.</code> </pre><br>  To keep a changelog, it would not be superfluous to install the dch program from the devscripts package.  Using it is very simple: <br><pre> <code class="hljs matlab">$ dch - <span class="hljs-built_in"><span class="hljs-built_in">i</span></span></code> </pre> <br>  The rules file, due to the use of debhelper, turned out to be very simple: <br><pre> <code class="hljs mel">#!/usr/bin/make -f %: dh $@ override_dh_auto_configure: dh_auto_configure -- -DCMAKE_INSTALL_PREFIX=/opt/ubuntunotes -DHARMATTAN=ON override_dh_auto_install: dh_auto_install --destdir=$(CURDIR)/debian/ubuntunotes</code> </pre><br>  The same file is suitable for almost any project with minimal changes. <br>  Build a package is also trivial: <br><pre> <code class="hljs ruby">$ ln -s ./debian_harmattan ./debian $ dpkg-buildpackage -b</code> </pre><br><br><h4>  Conclusion </h4><br><br>  Now you can safely install and run the resulting package and enjoy a fast and responsive interface.  Source codes for self-assembly can be downloaded on <a href="https://github.com/gorthauer/ubuntu-one-qml">github</a> .  In the same place the collected <a href="">deb packet</a> lies.  I hope this article will help novice developers under Harmattan and not only start writing their first applications faster.  In the future, I may try to better clarify to the Habrasoobschestvu the subtleties of working with cmake, many have already complained about the lack of articles about him. </div><p>Source: <a href="https://habr.com/ru/post/133974/">https://habr.com/ru/post/133974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133967/index.html">My look at ŒºHabr</a></li>
<li><a href="../133968/index.html">Flashlight for Windows Phone 7</a></li>
<li><a href="../133969/index.html">iCamp Kazan 2011 - final report</a></li>
<li><a href="../133972/index.html">The release of version 0.6.4 led to the blocking of the nodejs.org domain in China</a></li>
<li><a href="../133973/index.html">Impressions of the Nokia Lumia 800</a></li>
<li><a href="../133976/index.html">What engine do you use to create HTML5 games?</a></li>
<li><a href="../133977/index.html">Mandate Tag Management in MAFM 3.0</a></li>
<li><a href="../133978/index.html">FTBB programmer for minimalist Arduino</a></li>
<li><a href="../133979/index.html">How do you pronounce python (in Russian)?</a></li>
<li><a href="../133980/index.html">JSF GUI Development Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>