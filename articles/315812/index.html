<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebRTC: Making a peer to peer javascript game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I happened to work on a prototype video chat. It was an excellent opportunity to get acquainted with the concepts of WebRTC and try them out...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebRTC: Making a peer to peer javascript game</h1><div class="post__text post__text-html js-mediator-article">  Recently, I happened to work on a prototype video chat.  It was an excellent opportunity to get acquainted with the concepts of WebRTC and try them out in practice.  As a rule, when talking about WebRTC, they imply the organization of audio and video communications, but this technology can also be used for other interesting things.  I decided to try to make a peer-to-peer game and share the experience of its creation.  Video of what happened and implementation details under the cat. <br><br><img src="https://habrastorage.org/files/8f4/a22/330/8f4a223309db459695247a0d44ddb051.png"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-kKUFLyCyJw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h4>  Game engine </h4><br>  Once upon a time a demo of the game with pretty pixelart graphics caught my eye.  The game was made on the JavaScript engine <a href="http://impactjs.com/">Impact</a> .  About him even once mentioned on <a href="https://habrahabr.ru/post/106241/">Habr√©</a> . <br><br><img src="https://habrastorage.org/files/c1d/710/f16/c1d710f16f3c45a6b7ced0a517f3fb34.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The engine is paid, I bought it a couple of years ago, but I didn‚Äôt do anything practical on it, and finally it came in handy to me.  I must say that the process of creating a game on it is in itself a very exciting experience, and for people like me who want to quickly and inexpensively feel like cool igrodels, this is what you need.  Having decided on the technology of communication and the game engine, you can proceed to the implementation.  Personally, I started with game rooms. <br><br><h4>  Game rooms </h4><br>  How can a player get into the game and how to invite his friends to it?  Many online games use so-called rooms or channels so that players can play with each other.  To do this, you need a server that allows you to create these same rooms and add / delete users.  The scheme of his work is quite simple: when the user starts the game, and in our case opens the browser window with the address of the game, the following happens: <br><br><ol><li>  a new player tells the server the name of the room in which he would like to play; </li><li>  the server sends back a list of players in this room; </li><li>  the rest of the players receive a notification about the appearance of a new member. </li></ol><br><img src="https://habrastorage.org/files/7e1/1d0/550/7e11d05507f14aaab4d367c6bfb91e6a.png"><br>  All this is quite simple to implement, for example, on node.js + socket.io.  What happened, you can see <a href="">here</a> .  After the player has entered the game room, he must establish a peer-to-peer connection with each of the players in this room.  But, before turning to the implementation of peer-to-peer data, I suggest thinking about what kind of data it will be in principle. <br><br><h4>  Interaction protocol </h4><br>  The format and meaning of the messages transmitted between players, strongly depends on what will happen in the game.  In our case, this is a simple 2D shooter where players run and shoot each other.  Therefore, the first thing you need to know about the location of other players on the map: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PlayerPosition { <span class="hljs-attribute"><span class="hljs-attribute">int16</span></span> x; <span class="hljs-attribute"><span class="hljs-attribute">int16</span></span> y; }</code> </pre> <br>  Receiving such a message you can understand where the player is, but you can not understand how he looks at the moment.  Therefore, to complete the picture, here you can add information about what kind of animation the player has at the moment, what frame it is in and in which direction it looks: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PlayerPositionAndAnimation { <span class="hljs-attribute"><span class="hljs-attribute">int16</span></span> x; <span class="hljs-attribute"><span class="hljs-attribute">int16</span></span> y; <span class="hljs-attribute"><span class="hljs-attribute">int8</span></span> anim; <span class="hljs-attribute"><span class="hljs-attribute">int8</span></span> animFrame; <span class="hljs-attribute"><span class="hljs-attribute">bool</span></span> flipped; }</code> </pre><br>  Fine!  What other messages will be needed?  Depending on what you plan to do in the game, you will have your own set, and I got something like this: <br><br><ul><li>  player dies (); </li><li>  the player is born (int16 x, int16 y); </li><li>  player shoots (int16 x, int16 y, boolean flipped); </li><li>  the player picks up the weapon (int8 weapon_id). </li></ul><br><h4>  Typed fields in messages </h4><br>  As you can see, each of the fields in the messages has its own data type, for example, <i>int16</i> - for the fields that represent the coordinates.  Let's understand this right away, at the same time I will tell you a little about the WebRTC API.  The fact is that for data transfer between peers, an object of the type <i>RTCDataChannel is used</i> , which, in turn, can work with data of the type <i>USVString</i> , <i>BLOB</i> , <i>ArrayBuffer</i> or <i>ArrayBufferView</i> .  Just in order to use <i>ArrayBufferView</i> , and you need to clearly understand what format the data will be. <br><br>  So, having described all the messages, we are ready to continue and go directly to the organization of interaction between the feasts.  Here I will try to describe the hardware as briefly as I can.  In general, trying to tell about WebRTC in all its details is a long and difficult task, all the more so since in public access there is a <a href="https://hpbn.co/">book by Ilya Grigorik</a> , which is simply a wealth of information on this and other topics related to networking.  My goal, as I said, is to give a brief description of the basic mechanisms of WebRTC, with the study of which everyone will have to start. <br><br><h4>  Connection setup </h4><br>  What is needed for A and B users to establish a peer-to-peer connection between themselves?  Well, at least each of the users must know the address and port where his opponent listens and can receive incoming data.  But how will A and B communicate this information to each other if the connection has not yet been established?  To transfer this information you need a server.  In WebRTC terminology, it is called a signalling server.  And since its own server for game rooms has already been implemented, it can also be used as a signalling server. <br><br>  Also, in addition to addresses and ports, A and B must agree on the parameters of the session to be established. For example, the use of certain codecs and their parameters in the case of audio and video communications.  The format of the data describing various properties of the connection is called SDP - Session Description Protocol.  More information on him can be found at <a href="https://webrtchacks.com/sdp-anatomy/">webrtchacks.com</a> .  So, based on the above, the order of data exchange through signaling is as follows: <br><br><ol><li>  User A sends a connection request to User B; </li><li>  User B confirms the request from A; </li><li>  having received confirmation, user A determines his IP, port, possible session parameters and sends them to user B; </li><li>  User B responds by sending his address, port and session parameters to User A. </li></ol><br>  Upon completion of these actions, both users know each other‚Äôs addresses and parameters and can begin to exchange data.  But before moving on to implementation, there is one more thing to learn about the definition of a pair of IP address + port. <br><br><h4>  Address determination and availability check </h4><br>  When each user is available at a public IP address or both are on the same subnet, everything is simple.  Then each of them can request his IP from the operating system and send it through signaling to his opponent.  But what to do if the user is not directly accessible, but is behind NAT, and he has two addresses: one is local, inside the subnet ( <b>192.168.1.1</b> ), the second is the address of the NAT itself ( <b>50.76.44.114</b> )?  In this case, he somehow needs to determine his public address and port. <br><br>  The idea of ‚Äã‚Äãthe solution is quite simple: we need a publicly available server, which, upon receiving a request from us, will send back our public address and port. <br><img src="https://habrastorage.org/files/9bb/6c6/2e7/9bb6c62e7f4b4d048d8ceb4f61ab84bd.png"><br>  Such servers are called STUN ( <a href="https://en.wikipedia.org/wiki/STUN">Session Traversal Utilities for NAT</a> ).  There are ready-made solutions, for example, coturn, which can be deployed as your STUN server.  But you can do even easier and use the already deployed and accessible servers, for example from Google. <br><br>  Thus, everyone can get their address and send it to their opponent.  But this is not enough, because after receiving the address from your opponent you need to check whether we can reach him at this address? <br><br>  Fortunately, the ICE ( <a href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">Interactive Connectivity Establishment</a> ) framework embedded in the browser takes on the task of interacting with STUN and the availability test.  All we need is to handle the events of this framework.  So let's get down to implementing ... <br><br><h4>  Making a connection </h4><br>  At first it may seem that the process of setting up a connection is rather complicated.  But, fortunately, all the complexity is hidden with just one interface RTCPeerConnection, and in practice everything is simpler than it might seem at first glance.  The full code for the class that implements the peer-to-peer connection can be found <a href="">here</a> , <a href="">then</a> I will explain it. <br><br>  As I have already said, setting up, monitoring and closing a connection, as well as working with SDP and ICE candidates - all this is done via RTCPeerConnection.  More detailed information about the configuration can be found, for example, <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection">here</a> .  As a configuration, we will only need the address of the STUN server from Google, which I mentioned above. <br><br><pre> <code class="javascript hljs">iceServers: [{ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'stun:stun.l.google.com:19302'</span></span> }], <span class="hljs-attr"><span class="hljs-attr">connect</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.peerConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCPeerConnection({ <span class="hljs-attr"><span class="hljs-attr">iceServers</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iceServers }); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  RTCPeerConnection provides a set of callbacks for various connection lifecycle events, from which we will need: <br><br><ol><li>  icecandidate - to process the found candidate; </li><li>  iceconnectionstatechange - to track the status of the connection; </li><li>  datachannel - for processing an open data channel. </li></ol><br><pre> <code class="javascript hljs">init: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, peerUser, isInitiator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... this.peerHandlers = { 'icecandidate': this.onLocalIceCandidate, 'iceconnectionstatechange': this.onIceConnectionStateChanged, 'datachannel': this.onDataChannel }; this.connect(); }, connect: function() { // ... Events.listen(this.peerConnection, this.peerHandlers, this); // .... }</span></span></code> </pre><br><h4>  Send connection request </h4><br>  In the list of actions for a connection, the first two points were the request to establish a connection and the confirmation of this request.  We will simplify the process a bit and assume that if the user knows the address of the game room, then someone gave him a link, so the request to establish a connection is not required, you can immediately proceed to the exchange of session data and addresses. <br><br><h4>  Defining session parameters </h4><br>  To get session parameters in <i>RTCPeerConnection,</i> there are <i>createOffer</i> methods ‚Äî for calling on the originating side, and <i>createAnswer</i> ‚Äî on the answering side.  The result of the work of these methods are the data in SDP format, which must be sent through signaling to the opponent.  <i>RTCPeerConnection</i> stores both a local session description and a remote session, obtained through signaling from an opponent.  To set these fields there are <i>setLocalDescription</i> and <i>setRemoteDescription methods</i> .  So, let's say client A initiates a connection, then the procedure is as follows: <br><br>  1. Client A creates an SDP-offer, sets a local session description in his <i>RTCPeerConnection</i> , and then sends it to client B: <br><br><pre> <code class="javascript hljs">connect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... if (this.isInitiator) { this.setLocalDescriptionAndSend(); } }, setLocalDescriptionAndSend: function() { var self = this; self.getDescription() .then(function(localDescription) { self.peerConnection.setLocalDescription(localDescription) .then(function() { self.log('Sending SDP', 'green'); self.sendSdp(self.peerUser.userId, localDescription); }); }) .catch(function(error) { self.log('onSdpError: ' + error.message, 'red'); }); }, getDescription: function() { return this.isInitiator ? this.peerConnection.createOffer() : this.peerConnection.createAnswer(); }</span></span></code> </pre><br>  2. Client B receives an offer from client A and establishes a remote session description.  Then it creates an SDP-answer, sets it as a local session description and sends it to client A: <br><br><pre> <code class="javascript hljs">setSdp: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sdp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create session description from sdp data var rsd = new RTCSessionDescription(sdp); // And set it as remote description for peer connection self.peerConnection.setRemoteDescription(rsd) .then(function() { self.remoteDescriptionReady = true; self.log('Got SDP from remote peer', 'green'); // Add all received remote candidates while (self.pendingCandidates.length) { self.addRemoteCandidate(self.pendingCandidates.pop()); } // Got offer? send answer if (!self.isInitiator) { self.setLocalDescriptionAndSend(); } }); }</span></span></code> </pre><br>  4. After client A receives the SDP-answer from client B, it also sets it as a remote session description.  As a result, each client has established a local session description and a remote one received from his opponent: <br><br><img src="https://habrastorage.org/files/178/990/959/1789909590094f9498e5e3b2851b7caf.png"><br><br><h4>  ICE candidate gathering </h4><br>  Each time the client's ICE agent A finds a new IP + port pair that can be used for communication, the icecandidate event is <i>fired for RTCPeerConnection</i> .  Candidate data is as follows: <br><br><pre> <code class="hljs xml">candidate:842163049 1 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>udp<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> 1677729535 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>94.221.38.159 60478 typ srflx raddr 192.168.1.157 rport 60478<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> generation 0 ufrag KadE network-cost 50</code> </pre> <br>  Here's what you can understand by looking at this data: <br><br><ol><li>  <b>udp</b> : If the ICE agent decides to use this candidate for communication, then udp transport will be used for it; </li><li>  <b>typ srflx</b> is a candidate obtained by accessing a STUN server to determine the NAT address; </li><li>  <b>94.221.38.159 60478</b> ‚Äî NAT address and port to be used for communication; </li><li>  <b>raddr 192.168.1.157 rport 60478</b> - the address and port inside NAT. </li></ol><br>  You can read more about the protocol for describing ICE candidates <a href="https://tools.ietf.org/html/rfc5245">here</a> . <br><br>  This data needs to be transmitted through signaling to client B so that he adds them to his RTCPeerConnection.  Client B does the same when it detects its IP + port pairs: <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// When ice framework discoveres new ice candidate, we should send it // to opponent, so he knows how to reach us onLocalIceCandidate: function(event) { if (event.candidate) { this.log('Send my ICE-candidate: ' + event.candidate.candidate, 'gray'); this.sendIceCandidate(this.peerUser.userId, event.candidate); } else { this.log('No more candidates', 'gray'); } }</span></span></code> </pre><br><pre> <code class="javascript hljs"> addRemoteCandidate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">candidate</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.peerConnection.addIceCandidate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RTCIceCandidate(candidate)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Added his ICE-candidate:'</span></span> + candidate.candidate, <span class="hljs-string"><span class="hljs-string">'gray'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error adding remote ice candidate'</span></span> + err.message, <span class="hljs-string"><span class="hljs-string">'red'</span></span>); } }</code> </pre><br><h4>  Creating a data feed </h4><br>  Well, and perhaps the last thing worth staying at is <i>RTCDataChannel</i> .  This interface provides us with an API with which you can transfer arbitrary data, as well as customize the properties of data delivery: <br><br><ul><li>  full or partial guarantee of message delivery; </li><li>  ordered or unordered message delivery. </li></ul><br>  More details about the configuration of <i>RTCDataChannel</i> can be found, for example, <a href="https://developer.mozilla.org/ru/docs/Web/API/RTCDataChannel">here</a> .  At the moment, the ordered = false property will be enough to preserve the UDP semantics when transferring our data.  Like <i>RTCPeerConnection</i> , <i>RTCDataChannel</i> provides a set of events describing the life cycle of a data channel.  From it, you will need <i>open</i> , <i>close</i> and <i>message</i> to open, close a channel and receive a message, respectively: <br><br><pre> <code class="javascript hljs">init: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, peerUser, isInitiator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... this.dataChannelHandlers = { 'open': this.onDataChannelOpen, 'close': this.onDataChannelClose, 'message': this.onDataChannelMessage }; this.connect(); }, connect: function() { // ... if (this.isInitiator) { this.openDataChannel( this.peerConnection.createDataChannel(this.CHANNEL_NAME, { ordered: false })); } }, openDataChannel: function(channel) { this.dataChannel = channel; Events.listen(this.dataChannel, this.dataChannelHandlers, this); }</span></span></code> </pre><br>  Finally, after successfully opening a data channel between players, you can begin to transfer game messages between them. <br><br><h4>  More players </h4><br>  We considered how to establish a connection between two players, and this, in principle, is enough to play one on one.  And if we want to have several players in the same room?  What will change then?  In fact - nothing, just for each pair of players must have its own connection.  Those.  if you are playing in a room with 3 more players, you must have 3 peer-to-peer connections with each of them.  The full code of the class responsible for interacting with all opponents in the room can be found <a href="">here</a> . <br><img src="https://habrastorage.org/files/58b/73e/f9e/58b73ef9e1274e6083b455e2ce8b98a8.png"><br>  So, the signaling server with rooms is ready, the format of messages and the method of their delivery have been discussed, so how can we make players see each other based on this? <br><br><h4>  Location sync </h4><br>  The idea of ‚Äã‚Äãsynchronization is quite simple: you need to send your coordinates to your opponents once at some time, then they can reliably reflect your location based on this data. <br><br>  How often do I need to send sync messages?  Ideally, the opponent should see updates as often as the player, i.e.  if the game works with a frame rate of 30-60 frames per second, then the messages should also be sent with the same frequency.  But this is a rather naive decision, and much ultimately depends on the dynamism of the game itself.  For example, is it worth sending coordinates so often if they change every ten to twenty seconds?  Perhaps in this case it is unnecessary.  In my case, the animation and position of the players changes quite often, so I decided to go the simple way and send messages with coordinates to each frame. <br><br>  Sending synchronization message: <br><br><pre> <code class="javascript hljs">update: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... // Broadcast state this.connection.broadcastMessage(MessageBuilder.createMessage(MESSAGE_STATE) .setX(this.player.pos.x * 10) .setY(this.player.pos.y * 10) .setVelX((this.player.pos.x - this.player.last.x) * 10) .setVelY((this.player.pos.y - this.player.last.y) * 10) .setFrame(this.player.getAnimFrame()) .setAnim(this.player.getAnimId()) .setFlip(this.player.currentAnim.flip.x ? 1 : 0)); // ... }</span></span></code> </pre><br>  Receive sync message: <br><br><pre> <code class="javascript hljs">onPeerMessage: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, user, peer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... switch (message.getType()) { case MESSAGE_STATE: this.onPlayerState(remotePlayer, message); break; // ... } }, onPlayerState: function(remotePlayer, message) { remotePlayer.setState(message); }, // in RemotePlayer class: setState: function(state) { var x = state.getX() / 10; var y = state.getY() / 10; this.dx = state.getVelX() / 10; this.dy = state.getVelY() / 10; this.pos = { x: x, y: y }; this.currentAnim = this.getAnimById(state.getAnim()); this.currentAnim.frame = state.getFrame(); this.currentAnim.flip.x = !!state.getFlip(); this.stateUpdated = true; }</span></span></code> </pre><br>  Unfortunately, what turned out works without any delays only until you start playing with someone real, who is sitting at another computer and not on the same network with you.  Because then it starts working like this: <br><br><img src="https://habrastorage.org/files/af3/6af/41f/af36af41f2a548ba9ad601ca0e13b789.gif"><br><br>  The fact is that for a smooth image it is necessary to deliver messages with a constant frequency - the same with which they were sent.  To achieve this in real conditions is almost impossible, because of this, the intervals between incoming messages are constantly changing, creating an effect that is unpleasant to the eye.  You can defeat him using extrapolation of coordinates. <br><br><h4>  Extrapolation of coordinates </h4><br>  First you need to understand in more detail how message delays affect the quality of a picture that a player sees.  For a smooth movement, it is necessary that messages arrive at an equal interval close to the frame refresh rate in the game: <br><br><img src="https://habrastorage.org/files/168/624/109/1686241090e646d090782ae48e585a14.png"><br><br>  In practice, it turns out something else.  The intervals between messages are unevenly distributed, which leads to hopping animation and changing coordinates: <br><br><img src="https://habrastorage.org/files/253/157/fba/253157fba877447f9e2842cc7949bc62.png"><br><br>  When looking at the second scheme, it becomes clear what happens at the moment of an increased message delay: the player first sees a fade, and then a sharp jump.  This produces an unpleasant effect. <br><br>  The movement would be much smoother if, at the moments of delay, the coordinates of the player changed proportionally, though not always reliably: <br><br><img src="https://habrastorage.org/files/ca7/24a/997/ca724a997ff74408883288b6dcacdcdb.png"><br><br>  And indeed, if we analyze the movement of players, it can be understood that there is usually no abrupt change in the direction of movement, which means that without receiving the next message with coordinates at some point, we can assume them based on, for example, its speed in the previous frame.  To do this, you must either calculate this speed on the receiving side, or simply send it along with the coordinates.  I, as usual, chose the easiest way and send it along with the coordinates.  And now, if there was no message with coordinates updating in a certain frame, they are calculated from the player‚Äôs speed in the previous frame: <br><br><pre> <code class="javascript hljs">setState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = state.getX() / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = state.getY() / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dx = state.getVelX() / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dy = state.getVelY() / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: y }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentAnim = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAnimById(state.getAnim()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentAnim.frame = state.getFrame(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentAnim.flip.x = !!state.getFlip(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stateUpdated = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, <span class="hljs-attr"><span class="hljs-attr">update</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stateUpdated) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stateUpdated = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos.x += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dx; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pos.y += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dy; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentAnim ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentAnim.update(); } }</code> </pre><br>  And this is how it looks after applying extrapolation: <br><br><img src="https://habrastorage.org/files/cc6/2bb/c4a/cc62bbc4afab4e1092ca71b5b6417abb.gif"><br><br>  Of course, this method has a lot of flaws, and on very slow connections it can happen, for example, like this: <br><br><img src="https://habrastorage.org/files/15a/afc/039/15aafc03940543089da7b17aab8b95b2.gif"><br><br>  But the implementation of extrapolation goes far beyond the scope of this article, so I propose to dwell on what is. <br><br><h4>  Other game actions </h4><br>  In addition to moving around the map, it would be nice to collect cartridges and shoot someone.  What I mean is that there are a number of actions that the player performs in the game, and they too are subject to synchronization.  Fortunately, there are much fewer problems there than in the synchronization of movement: it is enough to simply reproduce the event received through the message.  Therefore, I probably will not dwell on this in detail, but simply refer to the project code. <br><br><h4>  What happened in the end </h4><br>  The code (with the exception of the source code of ImpactJS itself) and the instructions for launching can be viewed on the <a href="https://github.com/gutnikov/webrtc-shooter">github</a> . <br><br>  I would venture to leave this link here, where you can try to <a href="http://138.68.96.105/">play</a> .  I don‚Äôt know what will happen to my single-core droplet, but come what may =) <br><br><h4>  At last </h4><br>  If you have read to the end - thanks!  So, my work was not in vain and you found something interesting for yourself.  Questions, comments and suggestions, please leave in the comments. <br><br>  Alexander Gutnikov, frontend developer, Badoo. </div><p>Source: <a href="https://habr.com/ru/post/315812/">https://habr.com/ru/post/315812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315802/index.html">How to use HTTP headers to prevent vulnerabilities</a></li>
<li><a href="../315804/index.html">Jenkins for Android on a clean system and without UI</a></li>
<li><a href="../315806/index.html">True lies optimistic interfaces</a></li>
<li><a href="../315808/index.html">The book "Design. Modern Creatif</a></li>
<li><a href="../315810/index.html">The best IT vacancies on My Circle in a week, October 31 - November 6</a></li>
<li><a href="../315816/index.html">Why ready-made methods do not work and what is needed instead</a></li>
<li><a href="../315818/index.html">Learning to work with asyncio + aiohttp: Moscow will host a course from Core Python developer</a></li>
<li><a href="../315820/index.html">Results and forecasts: the main thing about the digital advertising market in 2016-2017</a></li>
<li><a href="../315822/index.html">Interview with Tanya Evdokimenko (Playrix) o mobile games</a></li>
<li><a href="../315824/index.html">Linux version of PVS-Studio gave itself a tour of Disney</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>