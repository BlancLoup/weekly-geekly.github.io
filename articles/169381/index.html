<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit testing for dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Even if you never thought you were testing, you do. You compile your application, press a button and check if the result is in line with your expectat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit testing for dummies</h1><div class="post__text post__text-html js-mediator-article">  Even if you never thought you were testing, you do.  You compile your application, press a button and check if the result is in line with your expectations.  Quite often, in the application, you can find tweezers with the ‚ÄúTest it‚Äù button or classes called <i>TestController</i> or <i>MyServiceTestClient</i> . <br><br><img src="https://habrastorage.org/storage2/6da/5c9/f6d/6da5c9f6d05c82a919b8cdcfa00e0b9b.png"><br><br>  What you do is called <i>integration testing</i> .  Modern applications are quite complex and contain many dependencies.  Integration testing verifies that several system components work together correctly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It performs its task, but it is difficult to automate.  As a rule, tests require that all or almost all of the system be deployed and configured on the machine on which they are run.  Suppose you are developing a web application with UI and web services.  The minimum equipment you need is a browser, a web server, properly configured web services, and a database.  In practice, it is still more difficult.  To deploy all this on the build server and all the developers' machines? <br><br><a name="habracut"></a><h2>  We need to go deeper </h2><br><img src="https://habrastorage.org/storage2/5c0/1c5/99f/5c01c599f95b6ee0edf77494908860a9.jpg"><br>  Let's first go down to the previous level and make sure that our components work correctly separately. <br><br>  Turn to Wikipedia: <br><blockquote>  <b>Unit testing</b> , or <b>unit testing</b> (unit testing) is a programming process that allows you to check for the correctness of individual modules of the program source code. <br><br>  The idea is to write tests for each non-trivial function or method.  This allows you to quickly check whether the next code change did not lead to regression, that is, to the appearance of errors in the already tested program areas, and also facilitates the detection and elimination of such errors. <br></blockquote><br><br><img src="https://habrastorage.org/storage2/ec3/825/c7f/ec3825c7f0710f9fed6814c89b794ded.jpg"><br><br>  Thus, unit testing is the first bastion against bugs.  Behind it is still integration, acceptance and, finally, manual testing, including ‚Äúfree search‚Äù. <br><br>  Do you need all this?  From my point of view, the answer is: ‚Äúnot always.‚Äù <br><br><h2>  No need to write tests if </h2><br><ul><li>  You make a simple online business card of 5 static html-pages and with one form of sending a letter.  On this, the customer is likely to calm down, he does not need anything more.  There is no special logic here, it‚Äôs faster just to check everything with ‚Äúhands‚Äù </li><li>  You are engaged in an advertising site / simple flash games or banners - complex layout / animation or a large amount of static.  There is no logic, only the presentation </li><li>  You are doing a project for the exhibition.  Term - from two weeks to a month, your system - a combination of hardware and software, at the beginning of the project it is not fully known what exactly should happen at the end.  The software will work for 1-2 days at the exhibition </li><li>  You always write code without errors, have an ideal memory and foresight.  Your code is so cool that it changes itself, following the requirements of the client.  Sometimes the code explains to the client that his requirements do not need to be implemented. </li></ul><br><br>  In the first three cases, for objective reasons (tight deadlines, budgets, vague goals, or very simple requirements), you will not gain from writing tests. <br><br>  We consider the last case separately.  I know only one such person, and if you do not recognize yourself in the photo below, then I have bad news for you. <br><br><img src="https://habrastorage.org/storage2/635/68c/356/63568c35676c4d929422ec8e42dd3563.jpg"><br><br><h2>  Any long-term project without proper test coverage is doomed sooner or later to be rewritten from scratch. </h2><img src="https://habrastorage.org/storage2/ee9/ab0/40f/ee9ab040f988cde943d001c819e8c08c.png"><br><br>  In my practice, I have met with projects over a year many times.  They fall into three categories: <br><ul><li>  <b>Uncovered tests.</b>  Usually such systems are accompanied by spaghetti code and resigned leading developers.  No one in the company knows exactly how it all works.  Yes, and what it ultimately needs to do, employees represent very remotely. </li><li>  <b>With tests that no one runs and does not support.</b>  There are tests in the system, but what they are testing, and what result is expected of them, is unknown.  The situation is already better.  There is some kind of architecture, there is an understanding of what weakness is.  You can find some documents.  Most likely, the company still employs the main system developer, who keeps in his head the features and the intricacies of the code. </li><li>  <b>With serious coverage.</b>  <b>All tests pass.</b>  If the tests in the project really run, there are a lot of them.  Much more than in systems from the previous group.  And now each of them is atomic: one test checks only one thing.  A test is a specification of a class method, a contract: what input parameters does this method expect and what other components of the system expect from it at the output.  Such systems are much smaller.  They contain current specification.  There is little text: usually a couple of pages, with a description of the main features, server layouts and <i>getting started guide</i> .  In this case, the project does not depend on people.  Developers can come and go.  The system is reliably tested and tells about itself through tests. </li></ul><br><br>  Projects of the first type are a tough nut to work with them the hardest.  Typically, their cost refactoring is equal to or greater than rewriting from scratch. <br><br><h2>  Why are there projects of the second type? </h2>  Colleagues from <i>ScrumTrek</i> assure that the dark side of the code and Lord <a href="http://habrahabr.ru/company/scrumtrek/blog/168485/">Dart</a> <i>Avtotestius are to</i> blame.  I am convinced that this is very close to the truth.  Thoughtless writing of tests <b>not only does not help, but harms the project</b> .  If earlier you had one poor-quality product, then having written tests, without understanding this subject, you receive two.  And double the time for support and support. <br><br>  In order for the dark side of the code not to take over, you need to adhere to the <b>following basic rules</b> . <br>  Your tests should: <br><br><ul><li>  To be authentic </li><li>  Do not depend on the environment on which they are executed. </li><li>  Easy to maintain </li><li>  Easy to read and easy to understand (even a new developer must understand <b>what is</b> being tested) </li><li>  Comply with the uniform naming convention. </li><li>  Run regularly in automatic mode </li></ul><br>  To achieve the fulfillment of these points, we need patience and will.  But let's order. <br><br><h3>  Select the logical location of the tests in your VCS </h3>  The only way.  Your tests should be part of version control.  Depending on the type of your decision, they can be organized differently.  General recommendation: if the application is monolithic, put all the tests in the Tests folder;  If you have many different components, store the tests in the folder of each component. <br><br><h3>  Choose a method for naming projects with tests. </h3>  One of the best practices: add to each project its own test project. <br>  Do you have parts of &lt;PROJECT_NAME&gt; .Core, &lt;PROJECT_NAME&gt; .Bl and &lt;PROJECT_NAME&gt; .Web?  Add more &lt;PROJECT_NAME&gt; .Core.Tests, &lt;PROJECT_NAME&gt; .Bl.Tests and &lt;PROJECT_NAME&gt; .Web.Tests. <br><br>  This naming convention has an additional side effect.  You can use the pattern * .Tests.dll to run tests on the build server. <br><br><h3>  Use the same naming method for test classes. </h3>  Do you have a class ProblemResolver?  Add ProblemResolverTests to the test project.  Each testing class must test only one entity.  Otherwise, you will very quickly fall <s>into a sad</s> second type of project (with tests that no one runs). <br><br><h3>  Choose the ‚Äútalking‚Äù method of naming the testing class methods. </h3>  <i>TestLogin</i> is not the best name for a method.  What exactly is being tested?  What are the input parameters?  Can errors and exceptions occur? <br><br>  In my opinion, the best way to name methods is: <i>[Test method] _ [Scenario] _ [Expected behavior]</i> . <br>  Suppose we have a class Calculator, and it has a method Sum, which (hello, Cap!) Has to add two numbers. <br>  In this case, our testing class will look like this: <br><br><pre><code class="hljs cs">lass CalculatorTests { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum_2Plus5_7Returned</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } }</span></span></code> </pre> <br>  This record is clear without explanation.  This is a specification for your code. <br><br><h3>  Choose a test framework that suits you </h3>  Regardless of the platform, do not write bicycles.  I have seen many projects in which automated tests (mostly not units, but acceptance ones) were launched from a console application.  Do not do this, everything has been done for you. <br><br>  Pay a little more attention to the framework overview.  For example, many .NET developers use MsTest only because it is included in the studio's distribution.  I prefer NUnit.  It does not create extra folders with test results and has support for parameterized testing.  I can just as easily run my NUnit tests with Resharper.  Someone will love xUnit's elegance: a constructor instead of initialization attributes, an implementation of IDisposable as TearDown. <br><br><h3>  What to test and what not? </h3>  Some talk about the need to cover the code by 100%, others consider it a waste of resources. <br>  I like this approach: draw a piece of paper along the X and Y axis, where X is the algorithmic complexity and Y is the number of dependencies.  Your code can be divided into 4 groups. <br><img src="https://habrastorage.org/storage2/177/ea7/e55/177ea7e5529adfb647db334db0e83cb0.png"><br><br>  We first consider extreme cases: simple code without dependencies and complex code with a large number of dependencies. <br><br><ol><li>  <b>Simple code without dependencies.</b>  Most likely here and so everything is clear.  It can not be tested. </li><li>  <b>Complex code with a lot of dependencies.</b>  Hmm, if you have this code, it smells like a God Object and a strong connectivity.  Most likely, it will be nice to refactor.  We will not cover this code with unit tests, because we will rewrite it, which means that we will change the method signatures and create new classes.  So why write tests that have to be thrown away?  I want to make a reservation that for this kind of refactoring we still need testing, but it is better to use higher-level <i>acceptance tests</i> .  We will consider this case separately. </li></ol><br>  What we have left: <br><ol><li>  <b>Complex code without dependencies.</b>  These are certain algorithms or business logic.  Well, these are important parts of the system, test them. </li><li>  <b>Not very complicated code with dependencies.</b>  This code links together different components.  Tests are important to clarify exactly how the interaction should occur.  The reason for the loss of the Mars Climate Orbiter on September 23, 1999 was a software-human error: one unit of the project counted "in inches" and the other - "in meters", and clarified this after the loss of the device.  The result could be different if the teams tested the ‚Äústitches‚Äù of the application. </li></ol><br><br><h3>  Adhere to the same style of writing the test body </h3>  The AAA approach <i>(arrange, act, assert) has</i> proven itself well.  Let's go back to the calculator example: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CalculatorTests { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Sum_2Plus5_7Returned() { // arrange var calc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Calculator(); // act var res = calc.Sum(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.AreEqual(<span class="hljs-number"><span class="hljs-number">7</span></span>, res); } }</code> </pre><br><br>  This form is much easier to read than <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalculatorTests</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum_2Plus5_7Returned</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Calculator().sum(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>)); } }</code> </pre><br><br>  So, this code is easier to maintain. <br><br><h3>  Test one thing at a time </h3>  <b>Each test should check only one thing.</b>  If the process is too complicated (for example, buying from an online store), divide it into several parts and test them separately. <br>  If you do not adhere to this rule, your tests will become unreadable, and soon it will be very difficult for you to support them. <br><br><h3>  Dealing with addictions </h3>  So far we have tested the calculator.  He has no dependencies at all.  In modern business applications, the number of such classes, unfortunately, is small. <br>  Consider this example. <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AccountManagementController : BaseAdministrationController { #region Vars <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly IOrderManager _orderManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly IAccountData _accountData; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly IUserManager _userManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly FilterParam _disabledAccountsFilter; #endregion <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AccountManagementController() { _oms = OrderManagerFactory.GetOrderManager(); _accountData = _ orderManager.GetComponent&lt;IAccountData&gt;(); _userManager = UserManagerFactory.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>(); _disabledAccountsFilter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FilterParam(<span class="hljs-string"><span class="hljs-string">"Enabled"</span></span>, Expression.Eq, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br>  The factory in this example takes data about a specific implementation of <i>AccountData</i> from the configuration file, which we are absolutely not satisfied with.  We do not want to support the zoo * .config files.  Moreover, these implementations may be database dependent.  If we continue in the same vein, then we will stop testing only the methods of the controller and begin to test with them the other components of the system.  As we remember, this is called <i>integration testing</i> . <br>  In order not to test everything together, we will slip a fake implementation. <br>  Rewrite our class like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AccountManagementController : BaseAdministrationController { #region Vars private readonly IOrderManager _oms; private readonly IAccountData _accountData; private readonly IUserManager _userManager; private readonly FilterParam _disabledAccountsFilter; #endregion <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AccountManagementController() { _oms = OrderManagerFactory.GetOrderManager(); _accountData = _oms.GetComponent&lt;IAccountData&gt;(); _userManager = UserManagerFactory.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>(); _disabledAccountsFilter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FilterParam("Enabled", Expression.Eq, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> testability /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="accountData"&gt;&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="userManager"&gt;&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> AccountManagementController( IAccountData accountData, IUserManager userManager) { _accountData = accountData; _userManager = userManager; _disabledAccountsFilter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FilterParam("Enabled", Expression.Eq, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } }</code> </pre><br><br>  Now the controller has a new entry point, and we can transfer other interface implementations there. <br><br><h3>  Fakes: stubs &amp; mocks </h3>  We rewrote the class and now we can slip the controller other dependency implementations that will not crawl into the database, look at configs, etc.  In a word, they will only do what is required of them.  Separate and conquer.  We must test real implementations separately in our own test classes.  Now we are testing only the controller. <br><br>  <b>There are two types of fakes: stubs (stubs) and moki (mock).</b> <br>  Often these concepts are confused.  The difference is that stub does not check anything, but only imitates a given state.  Mock is an object that has expectations.  For example, that a given class method must be called a certain number of times.  In other words, your test will never break because of the ‚Äústub‚Äù, but because of the mock it can. <br>  From a technical point of view, this means that using stubs in Assert, we check the status of the class being tested or the result of the method performed.  When using mock, we check whether the expectation of mock is consistent with the behavior of the class under test. <br><br><h4>  Stub </h4><h4><img src="https://habrastorage.org/storage2/95a/409/842/95a40984251f9529238b2e48c61e79f2.png"><br><br><pre> <code class="hljs pgsql">[Test] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> LogIn_ExisingUser_HashReturned() { // Arrange OrderProcessor = Mock.<span class="hljs-keyword"><span class="hljs-keyword">Of</span></span>&lt;IOrderProcessor&gt;(); OrderData = Mock.<span class="hljs-keyword"><span class="hljs-keyword">Of</span></span>&lt;IOrderData&gt;(); LayoutManager = Mock.<span class="hljs-keyword"><span class="hljs-keyword">Of</span></span>&lt;ILayoutManager&gt;(); NewsProvider = Mock.<span class="hljs-keyword"><span class="hljs-keyword">Of</span></span>&lt;INewsProvider&gt;(); Service = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IosService( UserManager, AccountData, OrderProcessor, OrderData, LayoutManager, NewsProvider); // Act var hash = Service.<span class="hljs-keyword"><span class="hljs-keyword">LogIn</span></span>("ValidUser", "Password"); // <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.That(!string.IsNullOrEmpty(hash)); }</code> </pre><br><br></h4><h4>  Mock </h4><h4><img src="https://habrastorage.org/storage2/92d/add/11c/92dadd11ca7c689b6cc19e1f040c1888.png"><br><br><pre> <code class="hljs pgsql">[Test] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Create_AddAccountToSpecificUser_AccountCreatedAndAddedToUser() { // Arrange var account = Mock.<span class="hljs-keyword"><span class="hljs-keyword">Of</span></span>&lt;AccountViewModel&gt;(); // Act _controller.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, account); // <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span> _accountData.Verify(m =&gt; m.CreateAccount(It.IsAny&lt;IAccount&gt;()), Times.Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)); _accountData.Verify(m =&gt; m.AddAccountToUser(It.IsAny&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(), It.IsAny&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;()), Times.Once()); }</code> </pre><br><br></h4><h3>  Condition testing and behavior testing </h3>  Why is it important to understand the seemingly insignificant difference between moka and stubs?  Let's imagine that we need to test the automatic irrigation system.  You can approach this task in two ways: <br><br><h4>  State testing </h4>  Run the cycle (12 hours).  And after 12 hours we check whether the plants are well watered, whether there is enough water, what is the condition of the soil, etc. <br><br><h4>  Interaction testing </h4>  Install sensors that will detect when watering has begun and ended, and how much water came from the system. <br>  Stubs are used in state testing, and mocks are interactions.  <b>It is better to use no more than one moka per test</b> .  Otherwise, with a high probability, you violate the principle of "testing only one thing."  In this case, in one test there can be as many stubs as you like or as a mock and stubs. <br><br><h3>  Insulation Frameworks </h3>  We could implement moki and stubs on our own, but there are several reasons why I do not advise doing this: <br><ul><li>  Bicycles are already written to us </li><li>  Many interfaces are not so easy to implement with a half-kick </li><li>  Our handwritten fakes may contain errors </li><li>  This is additional code that will have to be supported. </li></ul><br><br>  In the example above, I used the <a href="http://code.google.com/p/moq/">Moq</a> framework to create mocks and stubs.  The <a href="http://www.hibernatingrhinos.com/oss/rhino-mocks">Rhino Mocks</a> framework is quite common.  Both frameworks are free.  In my opinion, they are almost equivalent, but Moq is subjectively more convenient. <br><br>  There are also two commercial frameworks on the market: <i>TypeMock Isolator</i> and <i>Microsoft Moles</i> .  In my opinion, they have excessive capabilities to replace non-virtual and static methods.  Although this may be useful when working with legacy code, I‚Äôll describe below why I don‚Äôt advise doing such things. <br><br>  Showcases of the listed insulation frameworks can be found <a href="http://code.google.com/p/mocking-frameworks-compare/">here</a> .  And information on the technical aspects of working with them is easy to find in Habr√©. <br><br><h3>  Tested architecture </h3>  Let's go back to the example with the controller. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">public</span></span> AccountManagementController( IAccountData accountData, IUserManager userManager) { <span class="hljs-attribute"><span class="hljs-attribute">_accountData</span></span> = accountData; <span class="hljs-attribute"><span class="hljs-attribute">_userManager</span></span> = userManager; <span class="hljs-attribute"><span class="hljs-attribute">_disabledAccountsFilter</span></span> = new FilterParam(<span class="hljs-string"><span class="hljs-string">"Enabled"</span></span>, Expression.Eq, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  Here we got off with a little blood.  Unfortunately, not always everything is so simple.  Let's look at the main cases of how we can inject dependencies: <br><br><h4>  Injection into the constructor </h4>  Add an additional constructor or replace the current constructor (depending on how you create objects in your application, whether you use an IOC container).  We used this approach in the example above. <br><br><h4>  Injection into the factory </h4>  Setter can additionally be ‚Äúhidden‚Äù from the main application, if you select the IUserManagerFactory interface and work in the production code via the interface link. <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserManagerFactory { private IUserManager _instance; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> UserManager instance /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;IUserManager <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> file&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IUserManager <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _instance ?? <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>(UserConfigurationSection.GetSection()); } private IUserManager <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>(UserConfigurationSection config) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _instance ?? (_instance = <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(config)); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> testing purposes <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>! /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="userManager"&gt;&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(IUserManager userManager) { _instance = userManager; } }</code> </pre><br><h4>  Factory substitution </h4>  You can replace the entire factory entirely.  This will require the allocation of the interface or the creation of a virtual function, the creation of objects.  After this, you can redefine the factory methods so that they return your fakes. <br><br><h4>  Override local factory method </h4>  If dependencies are instantiated directly in the code explicitly, then the easiest way is to select the factory-protected CreateObjectName () method and override it in the inheriting class.  After that, test the heir class, not your original class being tested. <br>  For example, we decided to write an extensible calculator (with complex actions) and began to select a new layer of abstraction. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Calculator</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Multipy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiplier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Multiplier(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multiplier.Execute(a, b); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IArithmetic</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Multiplier</span></span> : <span class="hljs-title"><span class="hljs-title">IArithmetic</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * b; } }</code> </pre><br>  We do not want to test the <i>Multiplier</i> class, there will be a separate test for it.  Rewrite the code like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Calculator</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Multipy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiplier = CreateMultiplier(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multiplier.Execute(a, b); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IArithmetic </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMultiplier</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiplier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Multiplier(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multiplier; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CalculatorUnderTest</span></span> : <span class="hljs-title"><span class="hljs-title">Calculator</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IArithmetic </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMultiplier</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FakeMultiplier(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FakeMultiplier</span></span> : <span class="hljs-title"><span class="hljs-title">IArithmetic</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; } }</code> </pre><br>  The code is intentionally simplified in order to focus attention on the illustration of the method.  In real life, instead of a calculator, most likely there will be DataProviders, UserManagers and other entities with much more complex logic. <br><br><h4>  Test architecture VS OOP </h4>  Many developers are starting to complain, they say "this is your test design," breaks the encapsulation, opens too much.  I think that there are only two reasons for this: <br><br><h5>  Strong security requirements </h5>  This means that you have serious cryptography, the binaries are packed, and everything is hung with certificates. <br>  Even if so, most likely, you can find a compromise solution.  For example, in .NET you can use internal-methods and the <a href="http://msdn.microsoft.com/ru-ru/library/system.runtime.compilerservices.internalsvisibletoattribute.aspx">[InternalsVisibleTo]</a> attribute to give access to test methods from your test builds. <br><br><h5>  Performance </h5>  There are a number of tasks when architecture has to be sacrificed for the sake of performance, and for some it becomes a reason to abandon testing.  In my practice, to leave the server / upgrade iron has always been cheaper than writing untested code.  If you have a critical section, it is probably worth rewriting it at a lower level.  Your C # application?  Perhaps it makes sense to build one unmanaged assembly in C ++. <br><br>  Here are some principles that help write test code: <br><ul><li>  Think of interfaces, not classes, then you can always easily replace real implementations with fakes in test code. </li><li>  Avoid direct instantiation of objects within logic methods.  Use factories or <i>dependency injection</i> .  In this case, using the IOC container in a project can greatly simplify your work. </li><li>  Avoid directly invoking static methods. </li><li>  Avoid constructors that contain logic: it will be difficult for you to test. </li></ul><br><br><h2>  Work with legacy code </h2>  By "inherited" we will understand the code without tests.  The quality of such a code may be different.  A few tips on how to cover it with tests. <br><br><h3>  Architecture is testable </h3>  We are lucky, there are no direct creations of classes and a meat grinder, and the principles of SOLID are respected.  There is nothing simpler - we create test projects, and step by step we cover the application using the principles described in the article.  As a last resort, we will have to add a couple of setters for the factories and select several interfaces. <br><br><h3>  Architecture is not testable </h3>  We have hard ties, crutches and other joys of life.  We have to refactor.  How to conduct complex refactoring correctly is a topic that goes far beyond the scope of this article. <br>  It is necessary to highlight the basic rule.  If you do not change the interfaces - everything is simple, the technique is identical.  But if you are thinking of big changes, you should create a dependency graph and break your code into separate smaller subsystems (I hope that this is possible).  Ideally, it should look like this: kernel, module # 1, module # 2, etc. <br>  After that, select the victim.  Just do not start with the kernel.  Take something smaller first: that which you can refactor in a reasonable time.  Cover this subsystem with integration and / or acceptance tests.  And when you're done, you can cover this part with unit tests.  Sooner or later, step by step, you must succeed. <br>  Be prepared to do this quickly <s>most likely</s> will not work.  You will have to show willpower. <br><br><h2>  Test support </h2><br><img src="https://habrastorage.org/storage2/b51/49e/b95/b5149eb9594de7513ca2c79e1d1a0f41.png"><br><br>  Do not treat your tests as a second-rate code.  Many novice developers mistakenly believe that DRY, KISS and everything else is for production.  And in tests everything is permissible.  <b>This is not true.</b>  <b>Tests - the same code.</b>  The only difference is that tests have another goal - to ensure the quality of your application.  All principles applied in the development of production code can and should be applied when writing tests. <br>  There are only three reasons why the test stopped to pass: <br><br><ol><li>  Error in the production code: this is a bug, you need to start it in the bug tracker and fix it. </li><li>  Bug in test: apparently, the production code has changed, and the test is written with an error (for example, it tests too much or is not what was needed).  It is possible that before he passed erroneously.  Understand and repair the test. </li><li>  Change of requirements.  If the requirements have changed too much - the test should fall.  This is correct and normal.  You need to deal with new requirements and fix the test.  Or delete if it is no longer relevant. </li></ol><br><br>  Pay attention to the support of your tests, fix them on time, remove duplicates, select the base classes and develop the test APIs.  You can create template base test classes that require you to implement a test suite (for example, CRUD).  If you do it regularly, then soon it will not take much time. <br><br><h2>  How to "measure" progress </h2>  To measure the success of unit test implementation in your project, you should use two metrics: <br><br><ol><li>  Number of bugs in new releases (including regressions) </li><li>  Code coverage </li></ol><br><br>  The first shows whether our actions have a result, or we waste time that we could spend on features.  The second is how much more we have to do. <br><br>  The most popular tools for measuring code coverage on the .NET platform are: <br><ul><li>  NCover </li><li>  dotTrace </li><li>  built into the studio Test Coverage </li></ul><br><br><h2>  Test First? </h2><br><img src="https://habrastorage.org/storage2/a4f/4a2/11e/a4f4a211e0a89c703b0741ed55d56f65.png"><br><br>  I deliberately did not touch on this topic until the very end.  From my point of view, Test First is a good practice with a number of undeniable advantages.  However, for one reason or another, sometimes I step back from this rule and write tests after the code is ready. <br><br>  In my opinion, ‚Äúhow to write tests‚Äù is much more important than ‚Äúwhen to do it‚Äù.  Do as you like, but do not forget: if you start with tests, then you get the architecture "to boot."  If you first write code, you may have to change it to make it testable. <br><br><h2>  Read on </h2>  An excellent selection of references and books on the subject can be found in <a href="http://habrahabr.ru/post/136049/">this article on Habr√©</a> .  I especially recommend the book The Art of Unit Testing.  I read the first edition.  It turns out that the second has already happened. </div><p>Source: <a href="https://habr.com/ru/post/169381/">https://habr.com/ru/post/169381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../169369/index.html">ASUS Vivo Tab RT TF600TG tablet review</a></li>
<li><a href="../169371/index.html">Photoshop 1.0 source code published</a></li>
<li><a href="../169373/index.html">Fundamentals of the theory of computing systems: a machine with a finite number of states</a></li>
<li><a href="../169375/index.html">Little geniuses: we test applications with children</a></li>
<li><a href="../169379/index.html">Every 10 years, a cataclysm kills most of the mobile brands - and we are on the threshold of the next</a></li>
<li><a href="../169383/index.html">Love small businesses</a></li>
<li><a href="../169385/index.html">PokerAgent analysis or how to hijack 16 thousand Facebook accounts</a></li>
<li><a href="../169387/index.html">Responsive HTML5 and CSS3 Banners</a></li>
<li><a href="../169391/index.html">Sony Xperia Z sales start</a></li>
<li><a href="../169393/index.html">Changes in AD Windows Server 2012. Part 1. Dynamic Access Control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>