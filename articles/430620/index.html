<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional thinking. Part 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After a little excursion into the basic types, we can return to the functions again. In particular, to the previously mentioned riddle: if a mathemati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional thinking. Part 4</h1><div class="post__text post__text-html js-mediator-article"><p>  After a little excursion into the basic types, we can return to the functions again.  In particular, to the previously mentioned riddle: if a mathematical function can take only one parameter, then how in F # can there be a function that accepts more parameters?  More under the cut! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://habr.com/company/microsoft/blog/415189/">First part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/420039/">The second part of</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/422115/">The third part</a></strong> </li><li>  <strong><a href="https://habr.com/company/microsoft/blog/430620/">Fourth part</a></strong> </li></ul><br><p>  The answer is quite simple: a function with several parameters is rewritten as a series of new functions, each of which takes only one parameter.  The compiler performs this operation automatically, and it is called <em>currying</em> , in honor of Haskell Curry, a mathematician who greatly influenced the development of functional programming. </p><br><p>  To see how currying works in practice, let's use the simplest code example that prints two numbers: </p><br><pre><code class="plaintext hljs">//   let printTwoParameters xy = printfn "x=%iy=%i" xy</code> </pre> <br><p>  In fact, the compiler rewrites it in approximately the following form: </p><br><pre> <code class="plaintext hljs">//    let printTwoParameters x = //    let subFunction y = printfn "x=%iy=%i" xy //  ,    subFunction //  </code> </pre> <br><p>  Consider this process in more detail: </p><br><ol><li>  A function called " <code>printTwoParameters</code> " is <code>printTwoParameters</code> , but it takes only <em>one</em> parameter: "x". </li><li>  Inside it creates a local function, which also takes only <em>one</em> parameter: "y".  Note that the local function uses the "x" parameter, but x is not passed to it as an argument.  The "x" is in such a scope that the nested function can see it and use it without the need to pass it. </li><li>  Finally, the newly created local function is returned. </li><li>  The returned function is then applied to the argument "y".  The "x" parameter is closed in it so that the returned function only needs the "y" parameter to complete its logic. </li></ol><br><p>  By rewriting functions in this way, the compiler ensures that each function takes only one parameter, as required.  Thus, using " <code>printTwoParameters</code> ", you might think that this is a function with two parameters, but in fact a function with only one parameter is used.  You can verify this by passing only one argument instead of two: </p><br><pre> <code class="plaintext hljs">//     printTwoParameters 1 //    val it : (int -&gt; unit) = &lt;fun:printTwoParameters@286-3&gt;</code> </pre> <br><p>  If we calculate it with one argument, we will not get an error - the function will be returned. </p><br><p>  So, this is what actually happens when <code>printTwoParameters</code> is called with two arguments: </p><br><ul><li>  Called <code>printTwoParameters</code> with the first argument (x) </li><li>  <code>printTwoParameters</code> returns a new function, in which "x" is closed. </li><li>  Then a new function is called with the second argument (y) </li></ul><br><p>  Here is an example of step-by-step and normal versions: </p><br><pre> <code class="plaintext hljs">//   let x = 6 let y = 99 let intermediateFn = printTwoParameters x //  -  // x   let result = intermediateFn y //     let result = (printTwoParameters x) y //   let result = printTwoParameters xy</code> </pre> <br><p>  Here is another example: </p><br><pre> <code class="plaintext hljs">//  let addTwoParameters xy = x + y //   let addTwoParameters x = //   ! let subFunction y = x + y //      subFunction //   //       let x = 6 let y = 99 let intermediateFn = addTwoParameters x //  -  // x   let result = intermediateFn y //   let result = addTwoParameters xy</code> </pre> <br><p>  Again, a ‚Äútwo-parameter function‚Äù is actually a single-parameter function that returns an intermediate function. </p><br><p>  But wait, what about the " <code>+</code> " operator?  Is this a binary operation that should take two parameters?  No, it is also curried, like other functions.  This is a function called " <code>+</code> " that takes one parameter and returns a new intermediate function, exactly as <code>addTwoParameters</code> above. </p><br><p>  When we write the expression <code>x+y</code> , the compiler <em>reorders the</em> code in such a way as to convert the infix to <code>(+) xy</code> , <em>which is a function called <code>+</code> that takes two parameters.</em>  Note that the "+" function needs parentheses to indicate that it is used as a normal function, and not as an infix operator. </p><br><p>  Finally, a function with two parameters, called <code>+</code> , is treated like any other function with two parameters. </p><br><pre> <code class="plaintext hljs">//         let x = 6 let y = 99 let intermediateFn = (+) x //   ""  ""   let result = intermediateFn y //        let result = (+) xy //       let result = x + y</code> </pre> <br><p>  And yes, it works for all other operators and built-in functions, such as <code>printf</code> . </p><br><pre> <code class="plaintext hljs">//    let result = 3 * 5 //    - let intermediateFn = (*) 3 //  ""  3   let result = intermediateFn 5 //    printfn let result = printfn "x=%iy=%i" 3 5 // printfn   - let intermediateFn = printfn "x=%iy=%i" 3 // "3"   let result = intermediateFn 5</code> </pre> <br><h2>  Curry Signatures </h2><br><p>  Now that we know how the curried functions work, it's interesting to know what their signatures will look like. </p><br><p>  Returning to the first example, " <code>printTwoParameter</code> ", we saw that the function took one argument and returned an intermediate function.  The intermediate function also took one argument and did not return anything (ie, <code>unit</code> ).  Therefore, the intermediate function was of type <code>int-&gt;unit</code> .  In other words, domain <code>printTwoParameters</code> is an <code>int</code> , and range is an <code>int-&gt;unit</code> .  Putting it all together we will see the final signature: </p><br><pre> <code class="plaintext hljs">val printTwoParameters : int -&gt; (int -&gt; unit)</code> </pre> <br><p>  If you compute an explicitly curried implementation, you can see the parentheses in the signature, but if you compute an ordinary, implicitly curried implementation, the brackets will not be: </p><br><pre> <code class="plaintext hljs">val printTwoParameters : int -&gt; int -&gt; unit</code> </pre> <br><p>  Brackets are optional.  But they can be represented in the mind in order to simplify the perception of function signatures. </p><br><p>  And what is the difference between a function that returns an intermediate function and a regular function with two parameters? </p><br><p>  Here is a function with one parameter that returns another function: </p><br><pre> <code class="plaintext hljs">let add1Param x = (+) x // signature is = int -&gt; (int -&gt; int)</code> </pre> <br><p>  But a function with two parameters that returns a simple value: </p><br><pre> <code class="plaintext hljs">let add2Params xy = (+) xy // signature is = int -&gt; int -&gt; int</code> </pre> <br><p>  Their signatures are slightly different, but in practical terms there is not much difference between them, except for the fact that the second function is automatically curried. </p><br><h2>  Functions with more than two parameters </h2><br><p>  How does currying work for functions with more than two parameters?  In the same way: for each parameter, except the last, the function returns an intermediate function that closes the previous parameter. </p><br><p>  Consider this difficult example.  I have explicitly declared the types of the parameters, but the function does nothing. </p><br><pre> <code class="plaintext hljs">let multiParamFn (p1:int)(p2:bool)(p3:string)(p4:float)= () //   let intermediateFn1 = multiParamFn 42 // multoParamFn  int   (bool -&gt; string -&gt; float -&gt; unit) // intermediateFn1  bool //   (string -&gt; float -&gt; unit) let intermediateFn2 = intermediateFn1 false // intermediateFn2  string //   (float -&gt; unit) let intermediateFn3 = intermediateFn2 "hello" // intermediateFn3 float //     (unit) let finalResult = intermediateFn3 3.141</code> </pre> <br><p>  The signature of the entire function: </p><br><pre> <code class="plaintext hljs">val multiParamFn : int -&gt; bool -&gt; string -&gt; float -&gt; unit</code> </pre> <br><p>  and intermediate function signatures: </p><br><pre> <code class="plaintext hljs">val intermediateFn1 : (bool -&gt; string -&gt; float -&gt; unit) val intermediateFn2 : (string -&gt; float -&gt; unit) val intermediateFn3 : (float -&gt; unit) val finalResult : unit = ()</code> </pre> <br><p>  The function signature can indicate how many parameters the function accepts: it‚Äôs enough to count the number of arrows outside the brackets.  If the function accepts or returns another function, there will be more arrows, but they will be in brackets and they can be ignored.  Here are some examples: </p><br><pre> <code class="plaintext hljs">int-&gt;int-&gt;int // 2  int  int string-&gt;bool-&gt;int //   string,  - bool, //  int int-&gt;string-&gt;bool-&gt;unit //   (int,string,bool) //    (unit) (int-&gt;string)-&gt;int //   ,  // ( int  string) //   int (int-&gt;string)-&gt;(int-&gt;bool) //   (int  string) //   (int  bool)</code> </pre> <br><h2>  Difficulty with multiple parameters </h2><br><p>  Until you understand the logic behind the currying, it will produce some unexpected results.  Remember that you will not get an error if you run a function with fewer arguments than expected.  Instead, you get a partially applied function.  If you then use a partially applied function in a context where a value is expected, you can get a little understood error from the compiler. </p><br><p>  Consider a function that is harmless at first sight: </p><br><pre> <code class="plaintext hljs">//   let printHello() = printfn "hello"</code> </pre> <br><p>  What do you think will happen if you call it as shown below?  Will "hello" be displayed on the console?  Try to guess before execution.  Hint: look at the function signature. </p><br><pre> <code class="plaintext hljs">//   printHello</code> </pre> <br><p>  Contrary to the expectations of the call will <em>not</em> be.  The original function expects a <code>unit</code> as an argument that was not passed.  Therefore, a partially applied function was obtained (in this case without arguments). </p><br><p>  What about this case?  Will it be compiled? </p><br><pre> <code class="plaintext hljs">let addXY xy = printfn "x=%iy=%i" x x + y</code> </pre> <br><p>  If you run it, the compiler will complain about the line with <code>printfn</code> . </p><br><pre> <code class="plaintext hljs">printfn "x=%iy=%i" x //^^^^^^^^^^^^^^^^^^^^^ //warning FS0193: This expression is a function value, ie is missing //arguments. Its type is ^a -&gt; unit.</code> </pre> <br><p>  If there is no understanding of currying, this message can be very mysterious.  The point is that all expressions that are evaluated separately (i.e. are not used as a return value or a binding to something by means of "let") <em>must be</em> calculated in a <code>unit</code> value.  In this case, it is <em>not</em> calculated in the <code>unit</code> value, but instead returns a function.  This is a long way to say that <code>printfn</code> lacks an argument. </p><br><p>  In most cases, errors like this happen when interacting with the library from the .NET world.  For example, the <code>Readline</code> method of the <code>TextReader</code> class should accept the <code>unit</code> parameter.  You can often forget about this and not put brackets, in this case you cannot get a compiler error at the time of the ‚Äúcall‚Äù, but it will appear when you try to interpret the result as a string. </p><br><pre> <code class="plaintext hljs">let reader = new System.IO.StringReader("hello"); let line1 = reader.ReadLine // ,    printfn "The line is %s" line1 //    // ==&gt; error FS0001: This expression was expected to have // type string but here has type unit -&gt; string let line2 = reader.ReadLine() // printfn "The line is %s" line2 //  </code> </pre> <br><p>  In the code above, <code>line1</code> is just a pointer or delegate to the <code>Readline</code> method, not a line, as one would expect.  Using <code>()</code> in <code>reader.ReadLine()</code> will actually call the function. </p><br><h2>  Too many options </h2><br><p>  You can get the same mysterious messages, if you pass too many parameters to the function.  Some examples of passing too many parameters to <code>printf</code> : </p><br><pre> <code class="plaintext hljs">printfn "hello" 42 // ==&gt; error FS0001: This expression was expected to have // type 'a -&gt; 'b but here has type unit printfn "hello %i" 42 43 // ==&gt; Error FS0001: Type mismatch. Expecting a 'a -&gt; 'b -&gt; 'c // but given a 'a -&gt; unit printfn "hello %i %i" 42 43 44 // ==&gt; Error FS0001: Type mismatch. Expecting a 'a-&gt;'b-&gt;'c-&gt;'d // but given a 'a -&gt; 'b -&gt; unit</code> </pre> <br><p>  For example, in the latter case, the compiler reports that a formatting line with three parameters is expected (the signature <code>'a -&gt; 'b -&gt; 'c -&gt; 'd</code> has three parameters), but instead a line with two is received (at signature <code>'a -&gt; 'b -&gt; unit</code> two parameters). </p><br><p>  In cases where <code>printf</code> is not used, the transfer of a large number of parameters often means that at a certain stage of the calculations a simple value was obtained which the parameter is attempted to pass.  The compiler will be outraged that a simple value is not a function. </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 let x = add1 2 3 // ==&gt; error FS0003: This value is not a function // and cannot be applied</code> </pre> <br><p>  If we break the general call into a series of explicit intermediate functions, as we did earlier, we can see what exactly is going wrong. </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 let intermediateFn = add1 2 //   let x = intermediateFn 3 //intermediateFn  ! // ==&gt; error FS0003: This value is not a function // and cannot be applied</code> </pre> <br><h1>  Additional resources </h1><br><p>  For F #, there are many tutorials, including materials for those who come with C # or Java experience.  The following links may be helpful as you learn more about F #: </p><br><ul><li>  <a href="https://docs.microsoft.com/en-US/dotnet/fsharp/">F # Guide</a> </li><li>  <a href="https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/">F # for Fun and Profit</a> </li><li>  <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming">F # Wiki</a> </li><li>  <a href="https://learnxinyminutes.com/docs/fsharp/">Learn X in Y Minutes: F #</a> </li></ul><br><p>  Several other ways <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/">to get started with learning F # are</a> also described. </p><br><p>  Finally, the F # community is very friendly to beginners.  There is a very active Slack chat, supported by the F # Software Foundation, with rooms for beginners that you <a href="http://foundation.fsharp.org/join">can freely join</a> .  We strongly recommend that you do this! </p><br><p>  Do not forget to visit the site of the <a href="http://fsharplang.ru/">Russian-speaking community F #</a> !  If you have any questions about learning the language, we will be happy to discuss them in chat rooms: </p><br><ul><li>  Room <code>#ru_general</code> in <a href="http://foundation.fsharp.org/join">Slack chat F # Software Foundation</a> </li><li>  <a href="https://t.me/Fsharp_chat">chat in Telegram</a> </li><li>  <a href="http://gitter.im/fsharplang_ru">chat in gitter</a> </li></ul><br><h2>  About authors of translation </h2><br><p>  Translated by <a href="https://habrahabr.ru/users/kleidemos/"><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Translation and editorial changes are made by the efforts of the <a href="http://fsharplang.ru/">Russian-speaking community of F # -developers</a> .  We also thank <a href="https://habrahabr.ru/users/schvepsss/"><em>@schvepsss</em></a> and <a href="https://habr.com/users/shwars/"><em>@shwars</em></a> for preparing this article for publication. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430620/">https://habr.com/ru/post/430620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430610/index.html">How to safely get rid of their electronic devices</a></li>
<li><a href="../430612/index.html">As in the 1980s, people downloaded radio games</a></li>
<li><a href="../430614/index.html">Black Friday 2018 at Madrobots</a></li>
<li><a href="../430616/index.html">Workshop "Testing and Monitoring", November 27, Moscow</a></li>
<li><a href="../430618/index.html">Vue.js SSR & Mobile Safari: Unobvious Problem With Too Smart Software</a></li>
<li><a href="../430622/index.html">Functional thinking. Part 5</a></li>
<li><a href="../430626/index.html">Announcement of Moscow GraphQL Meetup</a></li>
<li><a href="../430628/index.html">Forchun algorithm, implementation details</a></li>
<li><a href="../430630/index.html">Comparison sneak "Two Balls" from the 60s and 2016. From the sole to the laces</a></li>
<li><a href="../430634/index.html">Creating a software module for the programmer XELTEK SuperPro 6100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>