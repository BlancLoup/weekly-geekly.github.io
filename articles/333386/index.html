<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LibGDX + Scene2d (we program on Kotlin). Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Today I will talk about texture atlas, skins, let's go through the layout work again. Further internationalization and in conclusion a couple o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LibGDX + Scene2d (we program on Kotlin). Part 2</h1><div class="post__text post__text-html js-mediator-article">  Hello.  Today I will talk about texture atlas, skins, let's go through the layout work again.  Further internationalization and in conclusion a couple of subtleties on working with color.  And in the next lesson, let's move on to the game model and the linking of game logic and UI elements. <br><br><div class="spoiler">  <b class="spoiler_title">Previous parts</b> <div class="spoiler_text">  <a href="https://habrahabr.ru/post/332144/">Part 0</a> <br>  <a href="https://habrahabr.ru/post/332298/">Part 1</a> <br>  <a href="">Repository</a> <br></div></div><br><br><h3>  Texture atlas </h3><br>  One of the most important parameters of the "comfort" of the application is the load time.  A narrow link in this regard is reading from the drive.  If we use such constructions everywhere <pre><code class="hljs lisp">Image(<span class="hljs-name"><span class="hljs-name">Texture</span></span>(<span class="hljs-string"><span class="hljs-string">"backgrounds/main-screen-background.png"</span></span>))</code> </pre>  then we create excess latency.  In this case, the texture ‚Äúbackgrounds / main-screen-background.png‚Äù will be read from the drive in synchronous mode.  It is not always evil.  As a rule, downloading a single background image does not spoil the experience of working with the program.  But if we read each element of our scene in this way, the speed and smoothness of the application can seriously sink. <br><a name="habracut"></a><br>  To optimize the work with textures, it is much cheaper for us to load one large picture once and use its fragments in our work.  This approach is called texture atlas. <br><div class="spoiler">  <b class="spoiler_title">Example atlas</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/95d/b0a/e63/95db0ae63c1a4b07abee1bc7dcd094cf.png"><br></div></div>  And although I‚Äôm a big opponent of premature optimization, working with texture atlas gives me great advantages both in terms of application speed and readability.  Ignore texture atlas is more expensive.  We already have a class AtlasGenerator in the project, which itself can combine images from a folder into an atlas.  Here is his code: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AtlasGenerator { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> settings = TexturePacker.Settings() settings.maxWidth = <span class="hljs-number"><span class="hljs-number">2048</span></span> settings.maxHeight = <span class="hljs-number"><span class="hljs-number">2048</span></span> TexturePacker.process(settings, <span class="hljs-string"><span class="hljs-string">"images"</span></span>, <span class="hljs-string"><span class="hljs-string">"atlas"</span></span>, <span class="hljs-string"><span class="hljs-string">"game"</span></span>) } }</code> </pre>  In principle, everything is simple.  Parameters: the name of the source folder, the name of the folder for the location of the atlas and the name of the atlas itself.  In large applications, it makes sense to make several atlases.  For example, the level of "ancient Egypt" - some pictures, the level of "space" - others.  At the same time they are not used.  Much faster in time to load only the part that is needed at the moment.  But in our application graphics will be at least, you can do with one atlas.  Loading atlas and reading textures looks like this: <pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> atlas = TextureAtlas(Gdx.files.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>(<span class="hljs-string"><span class="hljs-string">"atlas/game.atlas"</span></span>)) atlas.findRegion(<span class="hljs-string"><span class="hljs-string">"texture-name"</span></span>)</code> </pre><br>  In our application, the loading of the atlas is implemented a little differently, using AssetManager, but at the moment it does not matter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Skins </h3><br>  One of the features of the LibGDX library is the rigid coupling of the code of logic and representation.  We create elements, specify dimensions, position, color directly in the code.  At the same time, the visual style requires multiple repetition of the same lines of code (violation of the DRY principle).  It is very expensive in cost.  Not even the copy-paste itself, but the synchronization of changes.  For example, you wanted to change the text color from black to bronze.  And in the case of a hardcode, you need to go around the whole application, change one color to another.  The part you miss, the part change where it should not have changed.  To solve this problem, the skins mechanism is implemented in LibGDX.  Here is our example: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"font"</span></span>: <span class="hljs-string"><span class="hljs-string">"regular-font"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"large"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"font"</span></span>: <span class="hljs-string"><span class="hljs-string">"large-font"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"small"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"font"</span></span>: <span class="hljs-string"><span class="hljs-string">"small-font"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"pane-caption"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"font"</span></span>: <span class="hljs-string"><span class="hljs-string">"large-font"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fontColor"</span></span>: <span class="hljs-string"><span class="hljs-string">"color-mongoose"</span></span> } } }</code> </pre>  And here is an example of using the skin <pre> <code class="hljs lisp">Label(<span class="hljs-string"><span class="hljs-string">"some text here"</span></span>, uiSkin, <span class="hljs-string"><span class="hljs-string">"pane-caption"</span></span>)</code> </pre> <br>  How does it work inside?  Before the banal is simple.  ObjectMap &lt;Class, ObjectMap &lt;String, Object &gt;&gt; resources = new ObjectMap ();  Named instance sets are stored for each class.  Json above just fills this map with values.  An object is created through reflexion and fields are also filled through reflexion.  Here is an example of creating and working skins: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> atlas = TextureAtlas(Gdx.files.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>(<span class="hljs-string"><span class="hljs-string">"atlas/game.atlas"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> skin = Skin(atlas) skin.getDrawable(<span class="hljs-string"><span class="hljs-string">"texture-name"</span></span>) skin.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"default"</span></span>, Label.LabelStyle::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"some text here"</span></span>, skin , <span class="hljs-string"><span class="hljs-string">"pane-caption"</span></span>)</code> </pre><br><br><h3>  Layout </h3><br>  The result of today's work will be the appearance of the expedition panel when you click on the "boot" button.  In this example, we will look at how to expand the layout of the application while retaining the basic idea, adding / removing actors to the scene, a couple of new layout containers.  So our past code: <br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">let</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Image(Texture(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"backgrounds/main-screen-background.png"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setScaling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scaling.fill)</span></span></span><span class="hljs-function"> }).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre>  In the center of the window we have placed the picture.  Now we want to use this central part as a container.  There are two options.  Use Container with background or use Stack.  A stack is a layout container that draws all its children on top of itself in the order it was added.  Element dimensions are always set as Stack dimensions.  We will focus on the first option, because  The picture is a ‚Äústub‚Äù again.  In the final version, we will use the TiledMapRenderer to draw the map. <br><pre> <code class="hljs cs">val centralPanel = Container&lt;WidgetGroup&gt;() row().<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(centralPanel.apply { background = TextureRegionDrawable(TextureRegion(Texture(<span class="hljs-string"><span class="hljs-string">"backgrounds/main-screen-background.png"</span></span>))) fill() pad(AppConstants.PADDING * <span class="hljs-number"><span class="hljs-number">2</span></span>) }).expand() }</code> </pre>  In this case, we declare the variable CentralPanel outside of row (). Let {...} because  we will pass it as a parameter.  Such an idea, CommandPanel (panel with buttons below) should not know where it is located and where to insert new elements into the overall scene.  Therefore, we pass the centralPanel to the constructor and inside the CommandPanel we hang the handler on the button: <br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandPanel</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> centralPanel: Container&lt;WidgetGroup&gt;) : Table() { ... add(Button(uiSkin.getDrawable(<span class="hljs-string"><span class="hljs-string">"command-move"</span></span>)).apply { addListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ChangeListener() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ChangeEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, actor: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Actor</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (isChecked) { <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; centralPanel.actor = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; centralPanel.actor = ExplorePanel() } } }) })</code> </pre>  Since the parameter has the keyword val in the constructor, this final field will be available anywhere in the class.  If it were not, then this parameter would be available only in the block init {...}.  Instead of if-then I used when (java-switch).  it gives better readability.  When the button is pressed, ExplorePanel is embedded in the panel; when it is pressed, the center panel is cleared. <br><div class="spoiler">  <b class="spoiler_title">Layout dies terrain</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/693/6fc/bb4/6936fcbb4bca4408881d534424457327.PNG"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Expedition panel layout</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/673/031/792/6730317923384090845c397ae6845a9c.PNG" width="400"><br></div></div><br>  For layout terrain we will use two new layout-container.  VerticalGroup and HorizontalGroup.  These are ‚Äúlightweight‚Äù versions of the table, which, among other things, have one merit.  Deleting an element from them results in deleting a row / column.  This is not true for the table.  Even if you have a single row table, deleting an item in a column simply makes the cell empty.  Also, the expand / fill / space / pad modifiers for Container, VerticalGroup, HorizontalGroup apply to all elements at once.  For a table, these values ‚Äã‚Äãapply to each cell. <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ExplorePanel : <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span>() { init { background = uiSkin.getDrawable("panel-background") pad(AppConstants.PADDING) <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>().let { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(TerrainPane()) } <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>().let { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SearchPane()) } <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>().let { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(MovePane()) } <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>().let { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(TownPortalPane()) } <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>().let { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>().expand() //    } } }</code> </pre>  In this case, ExplorePanel is implemented through a table, but no one bothers to do it through VerticalGroup.  This is basically a matter of taste.  The bottommost element is the addition of an empty cell with the expand modifier.  This cell tries to occupy the maximum space, thereby ‚Äúspringing‚Äù the first elements upwards. <br><br>  And here is the location die: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TerrainPane : WoodenPane() { init { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Image(uiSkin.getDrawable("terrain-meadow"))).width(<span class="hljs-number"><span class="hljs-number">160</span></span>f).height(<span class="hljs-number"><span class="hljs-number">160</span></span>f).top() <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(VerticalGroup().apply { space(AppConstants.PADDING) addActor(Label(i18n["terrain.meadow"], uiSkin, "pane-caption")) addActor(HorizontalGroup().apply { space(AppConstants.PADDING) addActor(Image(uiSkin.getDrawable("herbs-01"))) addActor(Image(uiSkin.getDrawable("herbs-unidentified"))) addActor(Image(uiSkin.getDrawable("herbs-unidentified"))) addActor(Image(uiSkin.getDrawable("herbs-unidentified"))) addActor(Image(uiSkin.getDrawable("herbs-unidentified"))) }) }).expandX().fill() } }</code> </pre>  For now, do the ‚Äúrazvidet‚Äù internationalization (i18n) and just pay attention to the layout.  WoodenPane is actually a Table (in fact, Button, which, as I mentioned, is the heir to the Table).  It adds two actors.  Picture of the area and vertical group.  In the vertical group one cell is text, the second cell is a horizontal group of five pictures.  The action planes are made in a similar way - Search, Movement and Return to the city.  As I already mentioned, we will hang the logic and associate with the data model in the next part. <br><br><h3>  Internationalization </h3><br>  Those who have worked with internationalization, at least in any form, will have nothing new for those.  Internationalization works the same way.  There is a base .properties file in which key-value pairs are stored.  There are auxiliary files xxx_ru.properties, xxx_en.properties, xxx_fr.properties.  Depending on the device locale, the appropriate auxiliary file (if defined) or the base file (if there are no matches) is loaded.  In our case, the internationalization files look like this: <br> <code>medieval-tycoon.properties <br> medieval-tycoon_en.properties <br> medieval-tycoon_ru.properties <br> ...  ... <br> explore.move= <br> explore.search= <br> explore.town-portal=   <br> terrain.forest= <br> terrain.meadow= <br> terrain.swamp= <br></code> <br>  I rendered the name i18n to the global namespace <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i18n: I18NBundle <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = assets.i18n <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MedievalTycoonGame</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Game</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assets: Assets</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Assets</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i18n: I18NBundle <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { manager.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i18nDescriptor) }</code> </pre>  Again, the download goes through the asset manager.  The classic I18NBundle boot option looks like this: <pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i18n = I18NBundle.createBundle(Gdx.files.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>(<span class="hljs-string"><span class="hljs-string">"i18n/fifteen-puzzle"</span></span>), Locale.getDefault())</code> </pre>  Further, instead of text, we simply insert i18n.get (‚Äúname.key‚Äù) <br><br><h3>  A couple of subtleties when working with color </h3><br>  In the skins really want to use color constants.  But if you try to write like this, the program will crash with an error. <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pane-caption"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"font"</span></span>: <span class="hljs-string"><span class="hljs-string">"large-font"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fontColor"</span></span>: <span class="hljs-string"><span class="hljs-string">"color-mongoose"</span></span> } } }</code> </pre>  The point is not even that LibGDX knows nothing about the color ‚Äúmongoose‚Äù, skins by default do not even know about ‚Äúblack‚Äù &amp; ‚Äúwhite‚Äù.  But when creating the skin, we can pass the ObjectMap &lt;String, Any&gt; () parameter into which to put the running colors and the base colors of the application palette.  It looks like this: <br><div class="spoiler">  <b class="spoiler_title">Adding text color identifiers</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> skinResources = ObjectMap&lt;String, Any&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> skinDescriptor = AssetDescriptor(<span class="hljs-string"><span class="hljs-string">"default-ui-skin.json"</span></span>, Skin::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SkinLoader.SkinParameter</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"atlas/game.atlas"</span></span>, skinResources)) ... loadColors() manager.load(skinDescriptor) ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { skinResources.put(<span class="hljs-string"><span class="hljs-string">"color-mongoose"</span></span>, Color.valueOf(<span class="hljs-string"><span class="hljs-string">"BAA083"</span></span>)) skinResources.put(<span class="hljs-string"><span class="hljs-string">"clear"</span></span>, Color.CLEAR) skinResources.put(<span class="hljs-string"><span class="hljs-string">"black"</span></span>, Color.BLACK) skinResources.put(<span class="hljs-string"><span class="hljs-string">"white"</span></span>, Color.WHITE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"light_gray"</span></span>, Color.LIGHT_GRAY) skinResources.put(<span class="hljs-string"><span class="hljs-string">"gray"</span></span>, Color.GRAY) skinResources.put(<span class="hljs-string"><span class="hljs-string">"dark_gray"</span></span>, Color.DARK_GRAY) skinResources.put(<span class="hljs-string"><span class="hljs-string">"blue"</span></span>, Color.BLUE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"navy"</span></span>, Color.NAVY) skinResources.put(<span class="hljs-string"><span class="hljs-string">"royal"</span></span>, Color.ROYAL) skinResources.put(<span class="hljs-string"><span class="hljs-string">"slate"</span></span>, Color.SLATE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"sky"</span></span>, Color.SKY) skinResources.put(<span class="hljs-string"><span class="hljs-string">"cyan"</span></span>, Color.CYAN) skinResources.put(<span class="hljs-string"><span class="hljs-string">"teal"</span></span>, Color.TEAL) skinResources.put(<span class="hljs-string"><span class="hljs-string">"green"</span></span>, Color.GREEN) skinResources.put(<span class="hljs-string"><span class="hljs-string">"chartreuse"</span></span>, Color.CHARTREUSE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"lime"</span></span>, Color.LIME) skinResources.put(<span class="hljs-string"><span class="hljs-string">"forest"</span></span>, Color.FOREST) skinResources.put(<span class="hljs-string"><span class="hljs-string">"olive"</span></span>, Color.OLIVE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"yellow"</span></span>, Color.YELLOW) skinResources.put(<span class="hljs-string"><span class="hljs-string">"gold"</span></span>, Color.GOLD) skinResources.put(<span class="hljs-string"><span class="hljs-string">"goldenrod"</span></span>, Color.GOLDENROD) skinResources.put(<span class="hljs-string"><span class="hljs-string">"orange"</span></span>, Color.ORANGE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"brown"</span></span>, Color.BROWN) skinResources.put(<span class="hljs-string"><span class="hljs-string">"tan"</span></span>, Color.TAN) skinResources.put(<span class="hljs-string"><span class="hljs-string">"firebrick"</span></span>, Color.FIREBRICK) skinResources.put(<span class="hljs-string"><span class="hljs-string">"red"</span></span>, Color.RED) skinResources.put(<span class="hljs-string"><span class="hljs-string">"scarlet"</span></span>, Color.SCARLET) skinResources.put(<span class="hljs-string"><span class="hljs-string">"coral"</span></span>, Color.CORAL) skinResources.put(<span class="hljs-string"><span class="hljs-string">"salmon"</span></span>, Color.SALMON) skinResources.put(<span class="hljs-string"><span class="hljs-string">"pink"</span></span>, Color.PINK) skinResources.put(<span class="hljs-string"><span class="hljs-string">"magenta"</span></span>, Color.MAGENTA) skinResources.put(<span class="hljs-string"><span class="hljs-string">"purple"</span></span>, Color.PURPLE) skinResources.put(<span class="hljs-string"><span class="hljs-string">"violet"</span></span>, Color.VIOLET) skinResources.put(<span class="hljs-string"><span class="hljs-string">"maroon"</span></span>, Color.MAROON) }</code> </pre><br></div></div><br>  This is an example using AssetManager.  You can do this as well (the main thing is to do before loading the skin.json file): <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">uiSkin</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.add</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">Color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.BLACK</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">uiSkin</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.load</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Gdx</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.files</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.internal</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">uiskin</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.json</span></span>"))</code> </pre> <br><br>  And finally.  Label can be "painted" in two ways.  Right and wrong. <br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">color</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>.BLACK //  style.fontColor = <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>.BLACK // </code> </pre>  I do not have enough knowledge to explain the mechanics of rendering.  On the fingers it is like this: any actor can be drawn with a touch.  Take a picture made in shades of white and gray, set the color and instead of the white and gray image you get for example yellow-dark yellow or red-dark red.  The problem is that the final shade is "multiplication."  And if instead of the white-gray base there is a red picture and a shade of blue, then the result will be black.  In fact, this is a very bad and time-consuming option to get a good result.  To pick up the intensity of gray so that the red-green-yellow-blue variants looked reliably very difficult.  Plus, if I'm not mistaken, there is some kind of problem with maintaining transparency. <br><br>  The second option works fine.  The font is generated white, in my case with a translucent dark stroke. <br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> largeFont = <span class="hljs-type"><span class="hljs-type">FreetypeFontLoader</span></span>.<span class="hljs-type"><span class="hljs-type">FreeTypeFontLoaderParameter</span></span>() largeFont.fontFileName = <span class="hljs-string"><span class="hljs-string">"fonts/Merriweather-Bold.ttf"</span></span> ... largeFont.fontParameters.borderColor = <span class="hljs-type"><span class="hljs-type">Color</span></span>.valueOf(<span class="hljs-string"><span class="hljs-string">"00000080"</span></span>) largeFont.fontParameters.borderWidth = <span class="hljs-number"><span class="hljs-number">4</span></span>f ...</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/305/f0d/419/305f0d419ff54dcaad93989c124faa18.PNG" width="400"><br></div></div><br><br>  In the final example, there is no normal layout for action dies.  You can try to implement it yourself by analogy with the TerrainPane. <br><br>  <b>Update:</b> <br><div class="spoiler">  <b class="spoiler_title">A little funny offtopic</b> <div class="spoiler_text">  <a href="http://chir.ag/projects/name-that-color/">HEX code color name</a> <br><br><h4>  Color palette selection </h4>  <a href="https://color.adobe.com/ru/create/color-wheel">Cooler</a>  <a href="https://color.adobe.com/ru/create/color-wheel">Classics of the genre</a> <br>  <a href="http://paletton.com/">Paletton.com - I liked it</a> <br>  <a href="https://habrahabr.ru/post/118597/">Article from Habr</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/333386/">https://habr.com/ru/post/333386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333376/index.html">Database as Code. Digging deeper</a></li>
<li><a href="../333378/index.html">IBM and the US Air Force are developing a new generation neuromorphous supercomputer</a></li>
<li><a href="../333380/index.html">AWS DeepLearning AMI - why (and how) is it worth using</a></li>
<li><a href="../333382/index.html">Non-productive training of a single-layer perceptron. Classification task</a></li>
<li><a href="../333384/index.html">How large companies monitor employees</a></li>
<li><a href="../333388/index.html">The history of creating a library for group communication of android devices via Wi-Fi Peer-to-Peer connection</a></li>
<li><a href="../333390/index.html">Programming Contest: JSDash (Intermediate Results)</a></li>
<li><a href="../333392/index.html">Yandex shares soared after the deal with Uber</a></li>
<li><a href="../333396/index.html">PHP Reflection on closures</a></li>
<li><a href="../333398/index.html">Talk about Yii 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>