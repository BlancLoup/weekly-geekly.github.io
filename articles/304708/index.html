<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web scraping updated data with Node.js and PaaS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the fourth article in the cycle about web scraping using Node.js: 


1. Web scraping with Node.js 
2. Web scraping on Node.js and problem site...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web scraping updated data with Node.js and PaaS</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/5ae/fa8/e37/5aefa8e375d44d9b8f07715d76a6327c.png" align="right">  This is the fourth article in the cycle about web scraping using Node.js: </p><br><ol><li>  <a href="https://habrahabr.ru/post/301426/">Web scraping with Node.js</a> </li><li>  <a href="https://habrahabr.ru/post/302766/">Web scraping on Node.js and problem sites</a> </li><li>  <a href="https://habrahabr.ru/post/303726/">Node.js web scraping and bot protection</a> </li><li>  <strong>Web scraping updated data with Node.js</strong> </li></ol><br><p>  In previous articles, we reviewed the retrieval and parsing of pages, the recursive passage of links, the organization and fine-tuning of the request queue, the analysis of Ajax sites, the handling of some server errors, the initialization of sessions, and methods for overcoming bot protection. </p><br><p>  This article deals with topics such as web-scraping regularly updated data, tracking changes and using cloud platforms to run scripts and save data.  More attention is paid to the separation of tasks of web scraping and processing of finished data, as well as what should be avoided when working with updated sites. </p><br><p>  The purpose of the article is to show the whole process of creating, deploying and using a script, from setting the task to obtaining the final result.  As usual, for example, the real problem is used, which are often found on freelance exchanges. </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Formulation of the problem </h2><br><p> <a href=""><img src="https://habrastorage.org/files/13b/fa4/e78/13bfa4e78382498a9709db88fd52fa46.png" align="left"></a>  Suppose the customer wants to track real estate data on the <a href="http://buzzbuzzhome.com/">Buzzbuzzhome</a> site.  He is only interested in the city of Baltimore.  For each property offer, the customer wants to see a link to the offer page, the name of the object and price information (or what is written on the site instead of the price). </p><br><p>  The customer needs the ability to periodically update the information.  In fact, he needs the opportunity at any time to get an Excel-compatible file, in which there will be only actual offers, and in which among all the offers, new ones (which were not in the last requested file) will be marked and changed from the last time.  The customer is sure that only the price information will be changed. </p><br><p>  The customer wants to place the script on the network and work with it through the web interface.  He agrees to create a free account somewhere, independently run the script in the cloud (press a button in the browser) and download the CSV.  Data privacy does not bother him, so you can use public accounts. </p><br><h2 id="analiz-sayta">  Site analysis </h2><br><p>  On the Buzzbuzzhome website, you can get information of interest to us in two ways: drive ' <em>Baltimore</em> ' into the search field on the main page (there will be a pop-up hint ' <em>Baltimore, Maryland, United States</em> '), or find Baltimore in the catalog (select the 'Cities' in the main menu, select " <em>Maryland</em> " from the list of states, then select " <em>Baltimore</em> " from the list of cities).  In the first case, we get a map with markers and a list loaded via Ajax, and in the second - a boring list of links. </p><br><p>  The fact that the site has a simple old school catalog is a great success.  If it were not there, we would have to overcome a number of difficulties, and I‚Äôm not talking about analyzing Ajax traffic, but about the data itself.  The fact is that in the list next to the map, in addition to the proposals for Baltimore, there is a lot of garbage that just got on the map.  This is because the search is performed not by address, but by geographic coordinates.  In addition, it is worth considering that the search results by coordinates often do not contain objects whose address is not specified exactly or not fully (even if this site does not do this, it cannot be guaranteed that it will not do so in the future).  If the garbage can be simply filtered by address, then there is no unique solution for the missing objects and we would have to specify with the customer what to do. </p><br><p>  Fortunately, there is a separate page in the catalog on our site, where all the objects with the Baltimore address are listed.  Pages of individual objects easily parse (at least the name and price information). </p><br><h2 id="poluchenie-dannyh">  Data acquisition </h2><br><p>  If you do not think about updating data, then the task is extremely simple.  Even easier than it was in the first article, since there is no recursive passage through the links.  We get a list of links to real estate offers, put in a queue, parsim each page of the offer and get an array of results.  For example, like this: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> needle = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'needle'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cheerio = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cheerio'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tress = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tress'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resolve = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>).resolve; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startURL = <span class="hljs-string"><span class="hljs-string">'https://www.buzzbuzzhome.com/city/united-states/maryland/baltimore'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> q = tress(work); q.drain = done; start(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ needle.get(startURL, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $ = cheerio.load(res.body); $(<span class="hljs-string"><span class="hljs-string">'.city-dev-name&gt;a'</span></span>).each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ q.push(resolve(startURL, $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).attr(<span class="hljs-string"><span class="hljs-string">'href'</span></span>))); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, cb</span></span></span><span class="hljs-function">)</span></span>{ needle.get(url, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $ = cheerio.load(res.body); results.push([ url, $(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>).text().trim(), $(<span class="hljs-string"><span class="hljs-string">'.price-info'</span></span>).eq(<span class="hljs-number"><span class="hljs-number">0</span></span>).text().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).trim() ]); cb(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -     results // ,       console.log(results); }</span></span></code> </pre> <br><p>  This way you can make sure that we are able to get the right data.  For this, it is not even necessary to know what we will do with them next.  It is important that in our case there is little data, which means they can be processed all in one step, and not each line separately. </p><br><h2 id="sohranenie-dannyh">  Saving data </h2><br><p>  Perhaps you can omit a detailed analysis of hosting options, such as VPN, PaaS (like Heroku), or virtual hosting with support for Node.js.  This is already a lot and well written.  You can immediately start with the fact that there are specialized PaaS solutions for scraper that can significantly reduce labor costs.  This is not about ‚Äúuniversal scraper‚Äù, requiring only fine tuning of parsing, such as <a href="http://screen-scraper.com/">screen-scraper</a> , but about full-fledged platforms for running your own scripts.  Until recently, <a href="https://scraperwiki.com/">ScraperWiki</a> was the leader in this niche, but now this service has been switched to read-only mode and is gradually turning into something else.  A new leader in this niche, I would call the service <a href="https://morph.io/">Morph.io</a> .  It is convenient, free and very easy to deploy.  Morph.io users are asked to fit in 512 megabytes of memory and in 24 hours of the script, but if someone doesn‚Äôt have enough of it, you can try to negotiate individually.  There are a lot of advantages to this service: a ready-made web interface sharpened for scraping, a convenient API, automatic daily launch, web hooks, alerts and so on.  The main disadvantage of Morph.io is the lack of private accounts.  You can store all sorts of passwords, for example, in secret environment variables, but the script itself and the resulting data are visible to everyone. </p><br><p>  ( <em>On Habr√© already there was <a href="https://habrahabr.ru/post/262991/">an article about Morph.io</a> , only in the context of Ruby</em> ) </p><br><p>  On Morph.io, data is stored in SQLite, so we don‚Äôt have to worry about the choice of storage type.  If you create a <code>data.sqlite</code> database in the current directory, it will be available for download from the scraper page.  Also, a table with the name <code>data</code> will be displayed (first 10 rows) on the scraper page and will be available for download as a CSV. </p><br><p>  If we still neglect tracking changes, then saving the data can be implemented like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlite3 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sqlite3'</span></span>).verbose(); <span class="hljs-comment"><span class="hljs-comment">// ...  ,      function done(){ var db = new sqlite3.Database('data.sqlite'); db.serialize(function(){ db.run('DROP TABLE IF EXISTS data'); db.run('CREATE TABLE data (url TEXT, name TEXT, price TEXT)'); var stmt = db.prepare('INSERT INTO data VALUES (?, ?, ?)'); for (var i = 0; i &lt; results.length; i++) { stmt.run(results[i]); }; stmt.finalize(); db.close(); }); }</span></span></code> </pre> <br><p>  You can, of course, use any ORM, but this is someone you like. </p><br><h2 id="razvyortyvanie-v-oblake">  Cloud Deployment </h2><br><p>  On the Morph.io site, authorization via GitHub is used, and the scraper itself is made on the basis of git-repositories from there.  That is, you can start a customer account on GitHub, upload the correct files there, and then he can <a href="https://morph.io/scrapers/new/github">create</a> a scraper on Morph.io, run it and save the data. </p><br><p>  It is enough to upload three files to the repository: <code>scraper.js</code> , <code>package.json</code> and <code>README.md</code> .  The text from <code>README.md</code> will be displayed on the main page of the scraper (just like on GitHub).  In <code>package.json</code> enough to specify dependencies.  If the default version of Node.js does not suit you, you can immediately specify one of the versions supported on Heroku.  When you start the scraper for the first time, the service itself will understand by the extension of the main file that the scraper is written in Node.js, set up the entire environment itself and install the dependency modules itself.  If the Morph.io server is overloaded - the script will be queued, but usually it is not for long. </p><br><h2 id="otslezhivanie-izmenyayuschihsya-dannyh">  Tracking changing data </h2><br><p>  Tasks to track changing data, from the point of view of the scraper, are divided into simple and complex. </p><br><p>  Simple tasks are when the data in the source changes noticeably slower than they are scrapped.  Even if you have to optimize and parallelize queries - it is still a simple task.  Also, in simple tasks, the scrapping of the next version of the changing data can actually be done in one run of the script.  Let it be not every time, but the main thing is that there is no need to implement the ‚Äúresume‚Äù.  Simple tasks suggest that there are no conflicts or they do not particularly care about the customer.  In a simple task, you can get the next version of the data using web scraping, and then calmly do everything you need with it. </p><br><p>  Difficult tasks are when you have to abandon the scrapping and choose another engineering solution. </p><br><p>  Our task is simple.  Even in one stream, data can be obtained in a minute or two.  Data updates are needed no more than several times a day (it should be clarified with the customer, but usually so).  You can simply save the old and the new version, for example, in two different tables and merge them. </p><br><p>  Let's get another table (let's call it <code>new</code> ).  Let it be created, filled with the results of the scraping, merzhitsya and deleted.  In the <code>data</code> table, we add a <code>state</code> column to which we will write, for example, ' <code>new</code> ' if the entry is new and ' <code>upd</code> ' if the entry is old, but has changed from the previous version.  Specific notations are not important, as long as they are well read in the final CSV.  Before merging, the entire column is reset to <code>NULL</code> . </p><br><p>  Table blending is performed in three SQL queries. </p><br><div class="spoiler">  <b class="spoiler_title">Adding new entries</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, price, <span class="hljs-string"><span class="hljs-string">"new"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXCEPT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> );</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Deleting obsolete entries:</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXCEPT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> )</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Updating changed entries:</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> state = <span class="hljs-string"><span class="hljs-string">"upd"</span></span>, price = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> price <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> new.url = data.url ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> old.url <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">old</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> old.url = new.url <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> old.price &lt;&gt; new.price )</code> </pre> </div></div><br><p>  Those who chose Node.js, ‚Äúnot to learn a second language,‚Äù may want to use SQL minimum and implement the basic logic in Javascript.  This is mainly a holivarny question, but there is one point worth considering: the stability of the script on a low-powered hosting service is much higher if you use a language that is specifically designed for this to work with data.  Requests are not the most complex, and the customer will be pleased if the script drops less often. </p><br><p>  The corresponding script fragment looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlite3 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sqlite3'</span></span>).verbose(); <span class="hljs-comment"><span class="hljs-comment">// ...  ,      function done(){ var db = new sqlite3.Database('data.sqlite'); db.serialize(function(){ db.run('DROP TABLE IF EXISTS new'); db.run('CREATE TABLE new (url TEXT, name TEXT, price TEXT)'); var stmt = db.prepare('INSERT INTO new VALUES (?, ?, ?)'); for (var i = 0; i &lt; results.length; i++) { stmt.run(results[i]); }; stmt.finalize(); db.run('CREATE TABLE IF NOT EXISTS data (url TEXT, name TEXT, price TEXT, state TEXT)'); db.run('UPDATE data set state = NULL'); db.run('INSERT INTO data SELECT url, name, price, "new" AS state FROM new ' + 'WHERE url IN (SELECT url FROM new EXCEPT SELECT url FROM data)'); db.run('DELETE FROM data WHERE url IN (SELECT url FROM data EXCEPT SELECT url FROM new)'); db.run('UPDATE data SET state = "upd", price = (SELECT price FROM new WHERE new.url = data.url) ' + 'WHERE url IN (SELECT old.url FROM data AS old, new WHERE old.url = new.url AND old.price &lt;&gt; new.price)'); db.run('DROP TABLE new'); db.close(); }); }</span></span></code> </pre> <br><p>  Such a script can be <a href="https://github.com/astur/morph-io-test2">uploaded on Github</a> , <a href="https://morph.io/astur/morph-io-test2">uploaded to Morph.io</a> and run.  For the sake of readability, it is worth making the text of requests in separate string variables, but readability is not important for the customer. </p><br><div class="spoiler">  <b class="spoiler_title">Important note</b> <div class="spoiler_text"><p>  The script described in this article is good only for small amounts of data.  At the moment in Baltimore there are only about 25 real estate offers (on Buzzbuzzhome) and the scripping is set in a couple of minutes.  That is, if the script crashes due to an error on the server, it can simply be restarted, since nothing changes in the database until the scraping is completed. </p><br><p>  At the same time, there are about a thousand offers for New York on the same site, so the scrapping takes 40-50 minutes, and the Buzzbuzzhome server is very sickly.  Solving such a task, we would have to add server error handling (trite, we return the failed task to the queue and set the scrapping for a short pause, see the second article) so that the script does not fall and the customer does not have to restart it every hour.  What you shouldn‚Äôt do is save the partial results of the scraping between restarts in the database.  In real life, this may lead to the fact that some of the ‚Äúupdated‚Äù data will be very outdated. </p><br><p>  Further, if the task were to track the entire Buzzbuzzhome catalog, it would make sense to scrap and update the data for each city separately.  I would have to store in a separate table (or something else) the data on which city was updated a long time ago.  This is too big a task for Morph.io (at least we don‚Äôt meet the limits), so we would have to deploy the script in a more powerful cloud (and write the web interface to it).  The time spent on scrapping the entire catalog would be measured in days, and the data would become outdated faster than it was scraped.  This would not suit any real customer, so it would have to be very parallelized work.  How exactly - it already depends on specific requirements, but it would definitely have to. </p></div></div><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Finally, it is worth emphasizing that the task of scraping regularly updated data, although it presupposes the preservation of data between launches, does not at all imply mandatory deployment in the cloud.  You can give the same script to the customer along with instructions for installing and running his operating system from the terminal, and everything will work fine.  Just have to explain how to get CSV from SQLite, so it is better to add automatic export of the current version of the data.  However, in this case we will have no reason at all to use the database instead of, for example, a JSON file.  The real need for databases appears only when scrapping huge amounts of data that simply do not fit in memory, and storing them in ordinary files is extremely inconvenient.  But this is a topic for a separate article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/304708/">https://habr.com/ru/post/304708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304698/index.html">What is ViaLatM?</a></li>
<li><a href="../304700/index.html">Identity Cloud Services - a new generation of identity services</a></li>
<li><a href="../304702/index.html">Video of reports from Docker mitap</a></li>
<li><a href="../304704/index.html">The development of cloud technologies in Russia. New reality: vectors of development and major problems</a></li>
<li><a href="../304706/index.html">Prediction of the likelihood of each client‚Äôs transition to the status of a former member</a></li>
<li><a href="../304710/index.html">40 tutorials for creating vector illustrations</a></li>
<li><a href="../304714/index.html">Speech.framework on iOS 10</a></li>
<li><a href="../304716/index.html">How we helped a big Brazilian bank deal with the effects of the denomination</a></li>
<li><a href="../304718/index.html">Outdated CPUs or higher price? We found a compromise! 2 x E5620 / 32GB DDR3 / 6 x 240GB SSD / 1Gbps?</a></li>
<li><a href="../304720/index.html">Subtleties of selection of respondents for UX-research</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>