<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Saltan Spectroscope: laplacians for fan</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Christmas days - time to postpone the usual things and remember the fun - kaleidoscopes, mosaics, snowflakes ... Who will draw the most beautiful star...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Saltan Spectroscope: laplacians for fan</h1><div class="post__text post__text-html js-mediator-article">  Christmas days - time to postpone the usual things and remember the fun - kaleidoscopes, mosaics, snowflakes ... Who will draw the most beautiful star? <br><img src="https://habrastorage.org/files/c20/ecf/fa1/c20ecffa12c74c49b3ede917eff785b0.png"><br>  Symmetry is pleasing to the eye.  Mathematics helps the beauty, the Python language and its libraries are mathematical <a href="http://www.numpy.org/">numpy</a> and graphic <a href="http://matplotlib.org/index.html">matplotlib</a> . <br><br><h2>  Spectra of impossible gratings </h2><br>  KDPV is obtained by visualizing the values ‚Äã‚Äãof the eigenvectors of a certain symmetric matrix. <br>  The basis is the spectra of regular gratings.  Some of their properties have already been considered <a href="https://habrahabr.ru/post/262703/">previously</a> .  Here the formulas will work on aesthetics. <br><a name="habracut"></a><br>  So, let's say there is a certain basic set of points located on a plane.  There are few requirements - the configuration should be centrally symmetric.  For example, a hexagonal grid would be a good choice: <br><img src="https://habrastorage.org/files/391/d87/d5d/391d87d5d2ed4606825c93912b04aea7.png"><br>  Already beautiful, only somewhat monotonous. <br><br>  Circles are points.  Each is characterized by two coordinates.  For a given set of points, you can calculate their own coordinates based on a matrix of squares of distances between points.  This is explained in the article mentioned above.  To calculate the spectrum, it is necessary to convert the matrix of squares of distances into the Laplacian (which in this case is the correlation matrix) and calculate the spectrum of this Laplacian, that is, to find its own numbers and the corresponding vectors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we calculate the spectrum for a set of points located on a plane, then there will be only two components in the spectrum - one corresponding to the x coordinate, and the other to y. <br><br>  And it is necessary to make so that the spectrum "rang", but at the same time retains symmetry.  To achieve this is not difficult.  It is enough to change (or perturb) the function of the distance between points.  For example, you can assume that the distance between points is not equal to the square of the distance, but to its cube, or the inverse distance - you can use any function depending on the distance. <br><br>  For such a ‚Äúdistance matrix,‚Äù the spectrum can no longer be two-dimensional.  The algorithm for the decomposition of the distance matrix into the spectrum must somehow select for each point a set of coordinates in order to satisfy the non-standard distance.  Such a spectrum starts to ring, - the number of its components in the general case is equal to the total number of points (although zero can be excluded). <br><br>  If the set of points has symmetry, then part of the components will be degenerate.  This means that the same eigenvalue value will correspond to different eigenvectors.  In our case, the initial configuration of points is two-dimensional, respectively, and the degree of degeneration will be a multiple of two (probably, there is some kind of theorem for this statement).  And this means that such doubly degenerate levels ‚Äî projections ‚Äî can be drawn on the plane.  In the simplest version - also points. <br><br>  Assume that the distance function has the following form: <br><br>  <b><i>f (R2) = w * Rd + 1 / Rd</i></b> , where <b><i>w = dist / n ^ 2, Rd = R2 ^ degree</i></b> . <br><br>  Here, <b>dist</b> and <b>degree</b> are two variable disturbance parameters.  Then the first 9 degenerate levels for the above basic configuration (hexagonal lattice of size 7) with disturbance parameters <b>dist = -2</b> , <b>degree = 1</b> are: <br><img src="https://habrastorage.org/files/ab4/cde/5f4/ab4cde5f422d490487e8ad72c4412baf.png"><br>  In the upper left corner is the initial configuration.  The values ‚Äã‚Äãof the parameters are chosen in such a way that it is almost not distorted. <br><br>  All patterns are guaranteed to be different - this follows from the properties of the eigenvectors (although sometimes they are not distinguishable by eye).  Some seem more unusual than others.  Here, for example, is one of the fancy configurations: <br><img src="https://habrastorage.org/files/38f/4d8/af2/38f4d8af232d4ddcbb4ef1aff3dd1e4f.png"><br><br>  You can take as the source set a square lattice.  Then the symmetry will be square: <br><img src="https://habrastorage.org/files/896/270/a3b/896270a3b745465a9f412c28d0cca750.png"><br><br>  Since symmetry is reduced, the number of non-degenerate spectra here is twice as large as the degenerate. <br><br><h2>  Add color and size </h2><br>  If you give the points color and size, then the snowflakes (patterns) will become more fun and diverse.  The point is that the color and size of the points can also be formed on the basis of the eigenvectors of this set. <br><br>  Algorithm of color formation is simple.  We use a certain color map (from the available sets in <i>matplotlib</i> ), which converts the value of a point to color, and the very value of a point is taken from some non-degenerate eigenvector.  The same for point size.  Then you can get about this fun lace: <br><img src="https://habrastorage.org/files/b27/8b2/3ba/b278b23bacf14cb5b880cfb9f7a0a3b5.png"><br><br>  If you vary only the color, then you can play in the children's mosaic: <br><img src="https://habrastorage.org/files/8c1/20a/53c/8c120a53c4bc4746aa9e735251c2254d.png"><br>  This mathematics has painted the basic configuration of points in different colors. <br><br><h2>  Spider webs </h2><br>  If close points are connected by lines, then we get something like a web.  According to scientific such an operation is called <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_%25D0%2594%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5">triangulation</a> .  The advantage of the matplotlib package is that there such an operation is available out of the box.  The cobwebs are beautiful: <br><img src="https://habrastorage.org/files/c9e/e17/50a/c9ee1750aa624806af8696761c8315d5.png"><br><br>  You can delete part of the <a href="http://matplotlib.org/api/tri_api.html%3Fhighlight%3Dset_mask">mask-</a> based triangles: <br><img src="https://habrastorage.org/files/3fc/fdb/316/3fcfdb316dec476eacf214bf08223260.png"><br><br><h2>  Mosaics </h2><br>  Triangulation becomes colored if the triangles are filled with different colors: <br><img src="https://habrastorage.org/files/f0b/b81/8b1/f0bb818b1681478683cf1bddd0378f28.png"><br><br>  The choice of color map and color vector strongly influences the perception of the same configuration: <br><img src="https://habrastorage.org/files/481/e59/8e1/481e598e1fa34c8583b208b7a30318ab.png"><br>  The use of masks sharpens the contours of the patterns: <br><img src="https://habrastorage.org/files/b81/e5c/82a/b81e5c82a100495aba3bd882d99cedd0.png"><br>  The number of combinations and variations is almost infinite, the game of patterns is very fancy. <br><br><h2>  Contours </h2><br>  It is possible that the most sophisticated are patterns obtained by drawing contours based on triangulation.  These patterns are obtained using the <a href="http://matplotlib.org/api/axes_api.html%3Fhighlight%3Dtricontour">matplotlib tricontour ()</a> method.  Even the most inconspicuous and boring sets of points acquire completely unexpected variations. <br><img src="https://habrastorage.org/files/a17/388/607/a17388607d8048c997709f026bb885cc.png"><br>  Symmetry can be any, for example, of the 5th order: <br><img src="https://habrastorage.org/files/e28/d0e/a17/e28d0ea17de94ad0b1deeda882390880.png"><br>  Some kind of magic. <br><br><h2>  Spectroscope </h2><br>  All the above patterns were created using the program " <i>Spectroscope</i> " written in Python.  The program code is not perfect, but <a href="https://github.com/magin67/Spectroscope">is available</a> . <br><br><img src="https://habrastorage.org/files/278/2e1/32d/2782e132d23d4739a0572cff0a584f0c.png"><br><br>  With it, anyone can create patterns, varying parameters through a simple interface. <br><br>  At the top of the control panel, you can select one of the basic sets of distribution points ( <i>Base</i> ).  The base distribution always has an index of one, if the perturbation parameters are -2 ( <i>Disturb</i> ) and 1 ( <i>Degree</i> ), respectively, so you can always look at it. <br><br>  The most powerful are the basic <i>Hex</i> (hex) and <i>Square</i> (square) sets, since they have the most points.  Therefore, they give more varied patterns.  But the <i>x-border</i> sets (polygons) and especially <i>Circle</i> (circumference) on the contrary - are emasculated and more interesting for research purposes. <br><br>  For a basic set, you can specify its size ( <i>Order</i> ) using the slider (slider).  The next field ( <i>Index</i> ) sets the number of displayed spectra (levels) available for this set.  In this version, you can display 1, 4 or 9 patterns simultaneously. <br><br>  An important parameter is the pattern type ( <i>Plot type</i> ).  It is he who sets the way (mode) to display our eigenvectors.  Available are listed above ( <i>Points, Web, Mosaic, Contour</i> ). <br><br>  The flag " <i>Titles</i> " displays its numerical parameters, the sequence number in the total composition of the levels and the value of the eigenvalue of this level above each spectrum.  This is for those who are interested not only in graphics. <br><br>  Below are two sliders for variation parameters.  When they change the spectra come to life.  Recall that the right mouse button on the slider - shifts it to the current position, the left - increments. <br><br>  Then follow the parameters that affect the appearance of the spectra - color, markers and mask.  Not in all display modes they are involved.  Markers, for example, matter only for the ‚Äúpoint‚Äù mode, and masks - on the contrary, - for everyone except the point mode. <br><br>  Perhaps the most important color (Color).  To set it, you must specify a color map (Map).  But they play with color using a vector (slider with flag Use).  The color vector (and the size of the markers too) is chosen, as already noted, from non-degenerate levels. <br><br>  In the program menu, standard functions are available for saving spectra to files and exporting as images. <br><br>  There are many areas where you can develop a spectroscope.  In addition to the obvious improvements in the interface, development of capabilities (animation, for example, or web access), you need to try to build three-dimensional patterns.  They can not only look, but also sculpt). <br><br><h2>  Mathematical Aspects </h2><br>  During games with spectra, several interesting questions of varying degrees of importance arise. <br><br><h3>  Calculation of the number of degenerate spectra </h3><br>  Maybe this is not the most important question, but perhaps the simplest.  Obviously, the proportion of degenerate spectra depends on the basic distribution of points.  For the basic lattices (hexagonal and square) there are explicit formulas. <br><br>  For a hexagonal lattice, the number of "snowflakes" <b>Ns</b> is related to the total number of points (nodes) <b>N</b> as: <br><br>  <b><i>Ns = (N-1) / 3</i></b> <br><br>  In turn, the number of points quadratically depends on the size of the lattice <b>a</b> : <br><br>  <b><i>N (a) = 3a (a-1) + 1</i></b> .  Hence, <b><i>Ns (a) = a (a-1).</i></b> <br><br>  In a square lattice, the number of degenerate spectra is related to the number of points in a similar way: <br><br>  <b><i>Ns = N / 4 = a ^ 2/4</i></b> <br><br>  How to get such formulas for arbitrary configurations is not very clear.  It is possible that the general algorithm does not exist. <br><br><h3>  Spectrum Level Identification </h3><br>  Perhaps the most interesting question.  The main way to identify spectrum levels is the eigenvalue value.  If you sort the data numbers in ascending order, then you can assign an index to each level (the value of its own number).  This index seems to identify the spectrum. <br><br>  In fact, this is not a very reliable way.  When the disturbance parameters are varied, the spectra come to life - the patterns begin to breathe (you can see, for example, how the basic distribution ‚Äústomps‚Äù as the <i>Disturb</i> parameter changes), and their eigenvalues ‚Äã‚Äãalso change.  In this case, situations arise when the eigenvalues ‚Äã‚Äãof different levels approach each other and pass on.  That is, the spectra are interchanged.  In this case, by the nature of the pattern of the spectrum, you can see where the spectrum is.  This ‚Äúcharacter‚Äù must be hashed to a spectrum identifier in some way. <br><br><h3>  Phase transitions </h3><br>  The phenomenon of rapid change in patterns occurs in a narrow band of the perturbation parameter.  It looks like something on the phase transition.  It is possible that this is a known phenomenon.  In a phase transition, both the type of spectra and their relative location change.  The program selected the type of perturbed function such that when the Disturbance parameter <i>Disturb</i> is changed, the function changes sign.  It can be seen that when the parameter changes from the minimum to the maximum, the basic distribution moves from the first index to the last.  This transition seems to be carried out by moving the base pattern in indices from the smallest to the largest.  After some time, the modified base pattern appears on the last index.  Which then evolves to the original base configuration. <br><br>  However, in large configurations, it seems, no one moves anywhere (well, or it is impossible to track).  It is just that at a certain moment a rudiment of a new basic configuration appears in the right place (at the maximum index).  In short, who cares - look). <br><br>  If there was any parameter to identify one‚Äôs own levels, one could more accurately track the movement (or death and birth?) Of the spectra.  And to show on the picture always given spectra regardless of the values ‚Äã‚Äãof their own numbers. <br><br><h3>  Picture stabilization </h3><br>  also not very successful.  Patterns periodically rotate right / left.  It is not clear how the easiest way to always orient them in one direction. <br><br><h3>  Dividers </h3><br>  When the base configuration is a simple circle (points at the vertices of regular polygons), the phenomenon of divisors of integers occurs.  In this configuration, all points are equal.  Accordingly, all the degenerate levels (and there are no others here) are also coordinates of the vertices of the polygons (lie on the circle).  But at the same time, the spectra of simple polygons (the number of vertices is a prime number) differ from the composite ones.  In the spectra of simple all levels are also simple polygons with the same number of vertices.  And in the spectra of the composite levels consist of divisors of the vertices of the base polygon. <br><br>  For example, the spectrum of a 30-gon consists of 14 degenerate levels (projections).  Of these, four 30-gons, four 15-gons, two 10-gons, one 6-gon, two 5-gons and one 3-gon.  Why exactly such a distribution of levels by divisors is not clear (but strongly and did not penetrate).  Perhaps this has already been explained somewhere in group theory. <br><br>  That's all for now.  Good luck in your creative search and Merry Christmas! </div><p>Source: <a href="https://habr.com/ru/post/319060/">https://habr.com/ru/post/319060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319050/index.html">Galois field on Scala</a></li>
<li><a href="../319052/index.html">NoSQL - briefly about the main thing</a></li>
<li><a href="../319054/index.html">How to start using SSD hardware encryption using the example of Samsung EVO 850 and sedutil</a></li>
<li><a href="../319056/index.html">FuseTools - a unique tool for prototyping and development</a></li>
<li><a href="../319058/index.html">IBM Expands Serverless OpenWhisk Platform</a></li>
<li><a href="../319062/index.html">Microsoft MVP Global Summit 2016, margin notes</a></li>
<li><a href="../319066/index.html">Google earned so much that it was not necessary to think about money. Until now</a></li>
<li><a href="../319072/index.html">Configuring the virtual machine SPICE console in OpenStack</a></li>
<li><a href="../319074/index.html">Analysis of the report of Baruch Sadogursky with JPoint 2015</a></li>
<li><a href="../319076/index.html">Create an honest Forex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>