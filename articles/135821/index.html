<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is this new jQuery.Callbacks Object</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the not so long ago released version of jQuery 1.7, a new Callbacks object appeared, which will be discussed today. 
 The official documentation of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is this new jQuery.Callbacks Object</h1><div class="post__text post__text-html js-mediator-article"> In the not so long ago released version of jQuery 1.7, a new <b>Callbacks</b> object appeared, which will be discussed today. <br>  The official documentation of <a href="http://api.jquery.com/jQuery.Callbacks/">jQuery.Callbacks is</a> described as a multipurpose object, which is a list of callback functions (callbacks - hereinafter simply callbacks) and powerful tools for managing this list. <br><br>  I looked at the capabilities of this object when it was still only in development, and I must say that it initially had a bit more capabilities than it was left in the release version.  For example, now there is no possibility to create queue (callback) callbacks, which are called one for each <code>fire()</code> call.  Apparently, the jQuery team decided to cut the code a bit by removing the ‚Äúunnecessary / rarely used‚Äù features to save on the weight of the library.  This is a small excursion into the history of Callbacks, but then I will describe only the functions currently available and at the end I will write a small possible improvement to this object. <a name="habracut"></a><br><br><h4>  Purpose </h4><br>  Before starting a detailed study of this new jQuery.Callbacks object, I want to dwell on what this object is for.  Quite often in JavaScript code callbacks are used - functions that are called upon the occurrence of some event, for example, after the completion of some action, the most vivid example is the AJAX request.  And at the same time, there is often a need to call not one function, but several at once (how many, maybe a couple, maybe a couple of dozen, or maybe not even a single one) is unknown - this is the well-known and simple <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BB%25D1%258E%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">‚ÄúObserver‚Äù pattern</a> .  And for such cases, the jQuery.Callbacks object in question turns out to be useful.  In jQuery itself, this object is used (since version 1.7) inside jQuery.Deferred and jQuery.ajax.  Also, the jQuery authors made this object publicly available and documented it so that other developers could use it when implementing their own components. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Constructor: jQuery.Callbacks (flags) </h4><br>  By calling the constructor, a callbacks object is created, which has a number of methods for managing the list of callbacks. <br>  The <code>flags</code> parameter is optional and allows you to set the parameters of the object, the possible values ‚Äã‚Äãof the parameter we consider below. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks();</code> </pre> <br>  To the created <code>callbacks</code> object, we can now add <code>callbacks</code> functions to the list, delete them, call, call again (if this was not forbidden when creating the object), check the status of the object (whether there was already a call or not) using such object methods as <code>add()</code> , <code>remove()</code> , <code>fire()</code> , etc. Callbacks are executed, by the way, in the order they are added to the list. <br><br>  I note that this is not a ‚Äúreal‚Äù class instance constructor; therefore, using the <code>new</code> operator when calling it is not required (and even meaningless). <br><br>  For this reason, it will not be possible to check whether the object is an instance of Callbacks, in a manner standard for JS: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> $.Callbacks) { obj.add(fn); }</code> </pre> <br>  An if statement always returns false.  But you can rely on one of the known methods of this object (or several at once), for example, you can check this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.fire) { obj.add(fn); }</code> </pre> <br><br>  Actually, inside this function, a regular JS object is created with a certain set of methods that rely on its closure - this is a fairly common way in JavaScript to set private variables that are inaccessible outside of this pseudo-constructor. <br><br>  Also, thanks to such a pseudo-constructor, the methods of this object do not depend on the context of the call ‚Äî the object to which they belong, which means that they can be safely assigned to properties of another object without worrying about changing the context ‚Äî everything will still work correctly.  This is true for all methods except <code>fire</code> , it just depends on the context, but uses it as the execution context for callbacks from the list, i.e.  in some cases this method is not just possible, but it is <b>necessary to</b> assign the properties of another object with a change of context.  For example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = $.Callbacks(), obj = {}; obj.register = c.add; obj.register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'fired'</span></span>); }); c.fire(); <span class="hljs-comment"><span class="hljs-comment">// output: 'fired'</span></span></code> </pre> <br><br><h4>  Flags </h4><br><blockquote>  <i><b>Note</b> : hereinafter, the words "call the <code>fire()</code> method" means calling the callbacks from the list including the <code>fireWith()</code> method.</i> </blockquote><br>  The parameter of the <code>flags</code> constructor is a string in which you can specify flags ‚Äî options ‚Äî in accordance with which the created <code>callbacks</code> object will work.  The following flags are supported: <br><br>  <b>once</b> indicates that the list of callbacks can be executed only once, the second and subsequent calls to the <code>fire()</code> method will fail (as was done in the deferred object); if this flag is not specified, you can call the <code>fire()</code> method several times. <br><br>  <b>memory</b> indicates that it is necessary to memorize the parameters of the last call to the <code>fire()</code> method (and make callbacks from the list) and immediately add the added callbacks with the appropriate parameters if they are added after calling the <code>fire()</code> method (as was done in the deferred object). <br><br>  <b>unique</b> - indicates that each callback can only be added to the list once, a second attempt to add a callback to the list will lead to nothing. <br><br>  <b>stopOnFalse</b> indicates that it is necessary to stop the execution of callbacks from the list, if any of them returned <code>false</code> , during the current session, call <code>fire()</code> .  The next call to the <code>fire()</code> method starts a new session of executing the list of callbacks, and they will be executed again until one of the list returns <code>false</code> or ends. <br><br><h4>  Methods </h4><br>  Below I will give a list of methods with a brief description, examples are in the official docks and for some of the methods in the next section.  In general, the methods are quite simple and behave quite expectedly. <br><br>  <b>callbacks.add (callbacks)</b> <i>returns: callbacks</i> - adds <i>callbacks</i> to the list, you can simultaneously pass several functions (several arguments) or function arrays (you can simultaneously do both) in the arguments of this method, you can even pass nested arrays.  All arguments (or array elements) that are not functions are simply ignored.  The method (this and some further) returns the context of its call, thereby allowing to organize a chain of calls to several methods of one object in a row, as is customary in jQuery. <br><br>  <b>callbacks.remove (callbacks)</b> <i>returns: callbacks</i> - removes callbacks from the list, and even if the callback was added twice, it will be deleted from both positions.  So  If you call the method of removing some callback from the list, then you can be sure that it is no longer on the list, no matter how many times it is added.  You can pass several functions at the same time as several arguments, you cannot pass arrays, all arguments of non-functions are ignored. <br><br>  <b>callbacks.has (callback)</b> <i>returns: boolean</i> - checks if the specified function is in the callback list. <br><br>  <b>callbacks.empty ()</b> <i>returns: callbacks</i> - clears the list of callbacks. <br><br>  <b>callbacks.disable ()</b> <i>returns: callbacks</i> - ‚Äúdisables‚Äù the callbacks object, all actions with it will be ineffective.  In this case, all methods cease to work at all: <code>add</code> - does not lead to anything, <code>has</code> - always returns <code>false</code> , etc. <br><br>  <b>callbacks.disabled ()</b> <i>returns: boolean</i> - checks if the callbacks object is disabled, after a call, <code>disable()</code> will return <code>true</code> . <br><br>  <b>callbacks.lock ()</b> <i>returns: callbacks</i> - fixes the current state of the callbacks object with respect to the parameters and execution status of the callback list.  This method is relevant when using the <i>memory</i> flag and is designed to block only subsequent <code>fire()</code> calls, otherwise it is equivalent to the <code>disable()</code> call. <br><blockquote>  This method works in detail as follows: if the <i>memory</i> flag is not specified or the <code>fire()</code> method has never been called or the last session of callbacks was interrupted by one of them returning <code>false</code> , then the <code>lock()</code> call is equivalent to the <code>disable()</code> call (this is what inside) and calling <code>disabled()</code> in this case returns <code>true</code> , otherwise only subsequent <code>fire()</code> calls will be blocked - they will neither lead to callbacks, nor change the execution parameters of added callbacks (if the <i>memory</i> flag is present). </blockquote><br><br>  <b>callbacks.locked ()</b> <i>returns: boolean</i> - checks if the callbacks object is locked by the <code>lock()</code> method, also returns <code>true</code> after a call to <code>disable()</code> . <br><br>  <b>callbacks.fireWith ([context] [, args])</b> <i>returns: callbacks</i> - starts the execution of all callbacks in the list with the specified context and arguments.  <b>context</b> - indicates the execution context of the callback (an object accessible via <code>this</code> inside the function).  <b>args</b> is an array (just an array) of arguments passed to the callback. <br><br>  <b>callbacks.fire (arguments)</b> <i>returns: callbacks</i> - starts the execution of all callbacks in the list with the context of the call and the arguments of this method.  <b>arguments</b> is a list of arguments (not an array, as in the <code>fireWith()</code> method).  Those.  The call context and callback arguments will be the context and arguments of the <code>fire()</code> method. <br><br>  An example of how you can equivalently start the execution of callbacks with the same parameters and context: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks(), context = { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; callbacks.add(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.test, p, t); }); callbacks.fireWith(context, [ <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ]); <span class="hljs-comment"><span class="hljs-comment">// output: 1 2 3 context.fire = callbacks.fire; context.fire(2, 3); // output: 1 2 3</span></span></code> </pre> <br><br>  Callbacks from the list are performed in the order in which they were added to this list.  After the callbacks are executed with the specified flag <i>once, the</i> list will be cleared, and if the <i>memory</i> flag is not specified or the callbacks were interrupted by returning <code>false</code> , then the callbacks object will be disabled by the <code>disable()</code> method. <br><br><h4>  Examples </h4><br>  Let's see how the flags work with examples.  All examples use the following functions: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> value </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( value ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> value </span></span></span><span class="hljs-function">)</span></span>{ fn1(<span class="hljs-string"><span class="hljs-string">"fn2 says:"</span></span> + value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><br><h5>  $ .Callbacks (): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks(); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo bar fn2 says:bar bar foobar foobar false */</span></span></code> </pre> <br>  No flags indicated - quite expected behavior. <br><br><h5>  $ .Callbacks ('once'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"once"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo true */</span></span></code> </pre> <br>  Everything is clear here - once they did what happened, then nothing happens that they did, because  the list is already disabled. <br><br><h5>  $ .Callbacks ('memory'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"memory"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo fn2 says:foo foo bar fn2 says:bar bar foobar foobar false */</span></span></code> </pre> <br>  Here, it seems, is also nothing complicated - after the first execution, each addition of a callback causes its immediate execution, and then again we trigger the execution of the entire list.  At the same time, we added one function to the list twice - it works twice. <br><br><h5>  $ .Callbacks ('unique'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"unique"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo bar fn2 says:bar foobar false */</span></span></code> </pre> <br>  And in this case, the re-addition of the <code>fn1</code> function was ignored. <br><br><h5>  $ .Callbacks ('stopOnFalse'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"stopOnFalse"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo bar fn2 says:bar foobar foobar false */</span></span></code> </pre> <br>  <code>fn2</code> interrupts the execution chain, because  returns <code>false</code> . <br><br>  These are simple examples, and now let's try to play around with combinations of flags - it will be a little more interesting: <br><br><h5>  $ .Callbacks ('once memory'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"once memory"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo fn2 says:foo foo false */</span></span></code> </pre> <br>  We see that only the first <code>fire()</code> worked and the addition of new callbacks led to their immediate execution with the parameters of the first <code>fire()</code> . <br><br><h5>  $ .Callbacks ('once memory unique'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"once memory unique"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo fn2 says:foo foo false */</span></span></code> </pre> <br>  Here, the result is the same, despite the fact that we specified the <i>unique</i> flag and add <code>fn1</code> twice, the second time adding this function to the list worked, because with the specified flag <i>once</i> after the callbacks are executed, the list is cleared, and the <i>memory</i> flag indicates that subsequent additions of callbacks will lead to their immediate execution without being placed on the list, and since the list is empty, the addition of any function is always unique.  But this flag will play its role when you try to add several callbacks at once, among which there are duplicate ones, if in the previous code you change the 4th line as shown below, then <code>fn2</code> still be executed only once (and without the <i>unique</i> flag, three times): <br><pre> <code class="javascript hljs">callbacks.add( fn2, fn2, fn2 );</code> </pre> <br><br><h5>  $ .Callbacks ('once memory stopOnFalse'): </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.Callbacks( <span class="hljs-string"><span class="hljs-string">"once memory stopOnFalse"</span></span> ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ); callbacks.add( fn2 ); callbacks.add( fn1 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"bar"</span></span> ); callbacks.remove( fn2 ); callbacks.fire( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(callbacks.disabled()); <span class="hljs-comment"><span class="hljs-comment">/* output: foo fn2 says:foo true */</span></span></code> </pre> <br>  Returning <code>false</code> blocked all further callbacks, and if there was a flag <i>once, the</i> callbacks object was turned off altogether. <br><br>  I will not consider all possible combinations of flags, I tried to choose the most interesting (not quite simple) and explain the behavior of callbacks.  The remaining combinations can be tested independently, for example, using the stock: <a href="http://jsfiddle.net/zandroid/JXqzB/">http://jsfiddle.net/zandroid/JXqzB/</a> <br><br><h4>  Promised improvement </h4><br>  Improvement, of course, is not at all mandatory, and even, perhaps, to some degree contrived, do not judge strictly. <br>  The idea behind the improvement is to omit the call to the <code>fire()</code> method, and instead use the callbacks object itself as a function.  To do this, we write the following function: <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$, undefined</span></span></span><span class="hljs-function">)</span></span>{ $.FCallbacks = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flags, fns</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = $.type(flags) === <span class="hljs-string"><span class="hljs-string">'string'</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, callbacks = $.Callbacks(i ? flags : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); callbacks.add(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.slice.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, i)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.extend(callbacks.fire, callbacks, { <span class="hljs-attr"><span class="hljs-attr">fcallbacks</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }; })(jQuery);</code> </pre> <br>  And without further ado let's see an example of use: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p1, p2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'fn1 says:'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, p1, p2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p1, p2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'fn2 says:'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, p1, p2); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callbacks = $.FCallbacks(<span class="hljs-string"><span class="hljs-string">'once'</span></span>, fn1, rn2); callbacks.add(fn2); callbacks(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Also, the new ‚Äúconstructor‚Äù has the opportunity to immediately pass the initial callbacks in the parameters, without unnecessary calling <code>add()</code> . <br>  Well, in work: <a href="http://jsfiddle.net/zandroid/RAVtF/">jsfiddle.net/zandroid/RAVtF</a> <br><br>  All with the coming holidays, thank you for your attention. <br><br>  <b>UPD:</b> <br>  Judging by the comments, I still in vain omitted information about how this object is used inside jQuery.  Comments about ‚Äúthey did Deferred - and this is a double of such and such a method in such a framework‚Äù or ‚Äúwhy this Callbacks are needed - it only weighs the weight of the jQuery library, but I don‚Äôt come up with real-world applications‚Äù - these are, in my opinion, not understanding the essence of the issue.  Below, I want to explain this moment. <br><br><h4>  Real use </h4><br>  <b>Callbacks are</b> in fact now used by <b>so many</b> jQuery 1.7+ users and it was not easy for the development team because they wanted to make a new feature.  See, the chain and logic of this question is quite simple: <br><br>  The library implemented the <code>$.ajax()</code> method, which by its nature is nothing but an add-on for a certain Deferred - the developers improved the code, removed it separately from the <code>$.ajax()</code> main code (to be able to reuse and simplify testing) and decided, why not publish this code (give access to library users to it and document it) - it turned out <code>$.Deferred</code> . <br><br>  In turn, <code>$.Deferred</code> is initially two ( <code>done()</code> and <code>fail()</code> ), and now three (+ more <code>progress()</code> ) add-ons over Callbacks, which was made as internal code <code>$.Deferred</code> .  And again, the developers improved and separated this code from <code>$.Deferred</code> , implementing the latter through <code>$.Callbacks</code> (by the way, the <code>$.Deferred</code> source code became much clearer and more readable). <br><br>  Conclusion: the developers do not set as the main goal to add new ‚Äúuseless‚Äù features, they optimize the already existing internal code, simultaneously publishing side effects that are not less useful for it.  And every time you use <code>$.ajax()</code> , know that you are using <code>$.Deferred</code> , which means <code>$.Callbacks</code> .  This is an example of real use. </div><p>Source: <a href="https://habr.com/ru/post/135821/">https://habr.com/ru/post/135821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135815/index.html">Testing parallel threads</a></li>
<li><a href="../135816/index.html">Moving and Transforming in CSS3</a></li>
<li><a href="../135817/index.html">Slow read server vulnerabilities</a></li>
<li><a href="../135818/index.html">"Bug" is not a bug of non-centering of figures with the attribute align = center</a></li>
<li><a href="../135820/index.html">Do you use new syntax (hash, lambda) in Ruby 1.9?</a></li>
<li><a href="../135822/index.html">Script for Notepad ++ in Python</a></li>
<li><a href="../135823/index.html">Laser toy for a cat on servo drives</a></li>
<li><a href="../135824/index.html">Numbers Competently write numbers in words on the iPhone</a></li>
<li><a href="../135825/index.html">RE: Icons of popular services in runet</a></li>
<li><a href="../135827/index.html">Korean wagon. Zalman HDD pocket review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>