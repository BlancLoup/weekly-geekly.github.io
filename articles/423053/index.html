<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Struct and readonly: how to avoid performance degradation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Using the Struct type and the readonly modifier can sometimes cause a performance hit. Today we will talk about how to avoid this using one Open Sourc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Struct and readonly: how to avoid performance degradation</h1><div class="post__text post__text-html js-mediator-article">  Using the Struct type and the readonly modifier can sometimes cause a performance hit.  Today we will talk about how to avoid this using one Open Source code analyzer - ErrorProne.NET. <br><br><img src="https://habrastorage.org/webt/wc/aa/xn/wcaaxny16t6cvqvl2euetypst3o.jpeg"><a name="habracut"></a><br><br>  As you probably know from my previous publications ‚Äú <a href="https://blogs.msdn.microsoft.com/seteplia/2018/03/07/the-in-modifier-and-the-readonly-structs-in-c/">The 'in'-modifier and the readonly structs in C #</a> ‚Äù (‚ÄúThe in modifier and readonly structures in C #‚Äù) and ‚ÄúThe <a href="https://blogs.msdn.microsoft.com/seteplia/2018/04/11/performance-traps-of-ref-locals-and-ref-returns-in-c/">performance traps of the refs in C #</a> ‚Äù (‚Äú Performance hooks when using local variables and return values ‚Äã‚Äãwith the ref modifier), working with structures is more difficult than it might seem.  Leaving aside the issue of variability, I note that the behavior of structures with the readonly modifier (read-only) and without it in readonly contexts is very different. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is assumed that structures are used in programming scripts that require high performance, and to work effectively with them you need to know something about the various hidden operations generated by the compiler to ensure the structure remains unchanged. <br><br>  Here is a brief list of warnings you should remember: <br><br><ul><li>  Using large structures that are transmitted or returned by value can cause performance problems on critical program execution paths. </li><li> <code>xY</code> causes a protective copy of x to be created if: <br><ul><li>  <code>x</code> is a readonly field; </li><li>  type <code>x</code> is a structure without a readonly modifier; </li><li>  <code>Y</code> is not a field. </li></ul></li></ul><br>  The same rules work if x is a parameter with an in modifier, a local variable with a ref modifier readonly, or the result of a method call that returns a value via a readonly reference. <br><br>  Here are a few rules to remember.  And, most importantly, the code that relies on these rules is very fragile (i.e., changes made to the code immediately cause significant changes in other parts of the code or documentation - approx. Transl.).  How many people will notice that the replacement <code>public readonly int X</code> ;  on <code>public int X { get; }</code>  <code>public int X { get; }</code> in a frequently used structure without a readonly modifier significantly affects performance?  Or how easy is it to see that passing a parameter using the in modifier instead of passing by value can reduce performance?  This is indeed possible when using the in property of a parameter in a loop, when a protective copy is created at each iteration. <br><br>  Such properties of structures literally call for the development of analyzers.  And the call was heard.  Meet <a href="">ErrorProne.NET</a> - a set of analyzers that informs you about the possibility of changing the program code to improve its design and performance when working with structures. <br><br><h2>  Code analysis with the message "Make the structure X readonly" </h2><br>  The best way to avoid subtle mistakes and negative impact on performance when using structures is to make them readonly whenever possible.  The readonly modifier in the declaration of the structure clearly expresses the intention of the developer (emphasizing that the structure is immutable) and helps the compiler avoid generating protective copies in many of the contexts mentioned above. <br><br><img src="https://habrastorage.org/webt/tx/fp/5v/txfp5vx1h-8wtkuv_9epx4ulsqe.png"><br><br>  The readonly structure declaration does not violate the integrity of the code.  You can safely run the fixer (code correction process) in batch mode and declare all the structures of the entire software solution read-only. <br><br><h2>  Friendliness to the ref readonly modifier </h2><br>  The next step is to assess the safety of using new features (in modifier, ref readonly local variables, etc.).  This means that the compiler will not create hidden protective copies that can reduce performance. <br><br>  Three categories of types can be considered: <br><br><ul><li>  structures that are friendly to ref readonly, the use of which never leads to the creation of protective copies; </li><li>  structures unfriendly to ref readonly, the use of which in the context of readonly always leads to the creation of defensive copies; </li><li>  neutral structures are structures whose use can generate protective copies depending on the member used in the readonly context. </li></ul><br>  The first category includes readonly structures and POCO structures.  The compiler will never generate a defensive copy if the structure is readonly.  It is also safe in the context of readonly to use POCO structures: access to the fields is considered safe and no protective copies are created. <br><br>  The second category is the structures without the readonly modifier, which do not contain open fields.  In this case, any access to the open member in the context of readonly will cause the creation of a protective copy. <br><br>  The latter category is structures with public or internal fields and properties or public or internal methods.  In this case, the compiler creates defensive copies depending on the member used. <br><br>  This separation helps to instantly display warnings if the ‚Äúunfriendly‚Äù structure is transmitted with the in modifier, is stored in the local variable ref readonly, and so on. <br><br><img src="https://habrastorage.org/webt/nc/5a/0p/nc5a0pkfa3xsvrzqxznstyxn5yc.png"><br><br>  The analyzer does not display warnings if the ‚Äúunfriendly‚Äù structure is used as a readonly field, since there is no alternative in this case.  The in and ref modifiers are readonly designed for optimization purposes, specifically to avoid creating redundant copies.  If the structure is "unfriendly" with respect to these modifiers, you have other options: pass the argument by value or store a copy in a local variable.  In this regard, the readonly fields behave differently: if you want to make the type immutable, you must use these fields.  Remember: the code should be clear and elegant, and only secondarily - fast. <br><br><h2>  Hidden copies analysis </h2><br>  The compiler performs many actions hidden from the user.  As was shown in the previous <a href="https://blogs.msdn.microsoft.com/seteplia/2018/04/11/performance-traps-of-ref-locals-and-ref-returns-in-c/">publication</a> , it is quite difficult to see when a protective copy is created. <br><br>  The analyzer detects the following hidden copies: <br><br><ol><li>  Bcc readonly field. </li><li>  Bcc argument in. </li><li>  Bcc local variable ref readonly. </li><li>  Bcc refononly return value. </li><li>  Bcc when invoking an extension method that takes a parameter with this modifier by value for an instance of the structure. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> NonReadOnlyStruct { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublicMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NonReadOnlyStruct _ros; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Samples</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NonReadOnlyStruct nrs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ok. Public field access causes no hidden copies var x = nrs.PublicField; // Ok. No hidden copies. x = _ros.PublicField; // Hidden copy: Property access on 'in'-parameter x = nrs.PublicProperty; // Hidden copy: Method call on readonly field _ros.PublicMethod(); ref readonly var local = ref nrs; // Hidden copy: method call on ref readonly local local.PublicMethod(); // Hidden copy: method call on ref readonly return Local().PublicMethod(); ref readonly NonReadOnlyStruct Local() =&gt; ref _ros; } }</span></span></code> </pre> <br>  Note that analyzers display diagnostic messages only if the structure size is ‚â•16 bytes. <br><br><h2>  Using analyzers in real projects </h2><br>  Passing large structures by value and, as a result, the compiler's creation of defensive copies significantly affect performance.  At least, this is shown by the results of performance tests.  But how will these phenomena affect real-world applications in terms of through-passage time? <br><br>  To test the analyzers using real code, I used them for two projects: the Roslyn project and the internal project I am currently working on at Microsoft (the project is a standalone computer application with stringent performance requirements);  let's call it for clarity "Project D". <br><br>  Here are the results: <br><br><ol><li>  In projects with high performance requirements, as a rule, contains a lot of structures, and most of them can be done readonly.  For example, in the Roslyn project, the analyzer detected about 400 structures that can be made readonly, and in project D, approximately 300. </li><li>  In projects with high performance requirements, hidden copies should be created only in exceptional situations.  I found only a few such cases in the Roslyn project, since most of the structures have public fields instead of public properties.  This avoids creating security copies in a situation where the structures are stored in the readonly fields.  There were more hidden copies in project D, since at least half of them had get-only properties (read-only access). </li><li>  The transfer of even fairly large structures using the in modifier is likely to have a very weak (almost imperceptible) effect on the through-passage time of the program. </li></ol><br>  I changed all 300 structures in project D, making them readonly, and then corrected hundreds of cases of their use, indicating that they are transmitted with the in modifier.  Then I measured the end-to-end travel time for various performance scenarios.  The differences were statistically insignificant. <br><br>  Does this mean that the possibilities described above are useless?  Not at all. <br><br>  Working on a project with high performance requirements (for example, Roslyn or Project D) implies that a large number of people spend a lot of time on various types of optimization.  In fact, in some cases, the structures in our code were transmitted with the ref modifier, and some fields were declared without the readonly modifier to eliminate the generation of protective copies.  The lack of productivity growth in the transfer of structures with the in modifier may mean that the code has been well optimized and there is no redundant copying of structures on the critical paths of its passage. <br><br><h2>  What should I do with these features? </h2><br>  I believe that the issue of using the readonly modifier for structures does not require much thought.  If the structure is immutable, then the readonly modifier simply explicitly forces the compiler to make such a design decision.  And the lack of protective copies for such structures is just a bonus. <br><br>  Today my recommendations are as follows: if the structure can be made readonly, then by all means make it so. <br><br>  The use of other considered features has nuances. <br><br><h2>  Pre-optimization vs. pre-pessimization? </h2><br>  Herb Sutter in his amazing book, <a href="https://www.amazon.com/Coding-Standards-Rules-Guidelines-Practices/dp/0321113586">Coding Standards in C ++: 101 Rule, Guidelines and Best Practices</a> , introduces the concept of ‚Äúpre-pessimization.‚Äù <br><br>  ‚ÄúOther things being equal, the complexity of the code and its readability, some effective design patterns and coding idioms must naturally flow from your fingertips.  Such code is no more difficult to write than its pessimized alternatives.  You are not engaged in preliminary optimization, but avoid voluntary pessimization. ‚Äù <br><br>  From my point of view, the parameter with the in modifier is the very case.  If you know that the structure is relatively large (40 bytes or more), then you can always transfer it with the in modifier.  The price of using the modifier in is relatively small, since it does not need to correct the calls, and you can get real benefits. <br><br>  In contrast, for local variables and return values ‚Äã‚Äãwith the readonly ref modifier, the situation is different.  I would say that these features should be used when encoding libraries, and in the application code they should be discarded (only if profiling the code does not reveal that the copy operation is really a problem).  Using these features requires additional effort from you, and it becomes more difficult for the code reader to understand it. <br><br><h2>  Conclusion </h2><br><ol><li>  Use the readonly modifier for structures where possible. </li><li>  Consider using the in modifier for large structures. </li><li>  Consider using local variables and return values ‚Äã‚Äãwith the ref modifier readonly to encode libraries or in cases where the results of code profiling suggest that this might be useful. </li><li>  Use <a href="https://blogs.msdn.microsoft.com/seteplia/2018/05/03/avoiding-struct-and-readonly-reference-performance-pitfalls-with-errorprone-net/">ErrorProne.NET</a> to find problems with the code and share the results. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/423053/">https://habr.com/ru/post/423053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423043/index.html">Due to the vulnerability in the Tesla electric vehicle protection system, you can hijack a car in a few seconds</a></li>
<li><a href="../423045/index.html">Which 3D printer to choose? Video Review from 3Dtool</a></li>
<li><a href="../423047/index.html">We reserve IT systems for reasonable money</a></li>
<li><a href="../423049/index.html">Learning Linux Processes</a></li>
<li><a href="../423051/index.html">Fight for resources, part 1: Basics of Cgroups</a></li>
<li><a href="../423055/index.html">Wall Street analysts: "Apple made us eat our hats"</a></li>
<li><a href="../423057/index.html">Python also partially rejects the terms master / slave</a></li>
<li><a href="../423059/index.html">Better than they say: three things you need to make the next MacBook one of the best Apple laptops</a></li>
<li><a href="../423061/index.html">ref locals and ref returns to C #: performance pitfalls</a></li>
<li><a href="../423063/index.html">Epson WorkForce Pro: chronicles of how an office inkjet "overtighted a blanket" from a laser and what it came to today</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>