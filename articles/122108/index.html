<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding interprocess communication on Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inter-process communication (IPC) is a set of methods for exchanging data between process threads. Processes can be run on the same computer or on dif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding interprocess communication on Linux</h1><div class="post__text post__text-html js-mediator-article">  <i>Inter-process communication (IPC)</i> is a set of methods for exchanging data between process threads.  Processes can be run on the same computer or on different, connected by a network.  There are several types of IPC: ‚Äúsignal‚Äù, ‚Äúsocket‚Äù, ‚Äúsemaphore‚Äù, ‚Äúfile‚Äù, ‚Äúmessage‚Äù ... <br><br>  In this article I want to consider only 3 types of IPC: <ol><li>  <a href="https://habr.com/ru/post/122108/">named pipe</a> </li><li>  <a href="https://habr.com/ru/post/122108/">shared memory</a> </li><li>  <a href="https://habr.com/ru/post/122108/">semaphore</a> </li></ol><h6>  Retreat: this article is educational and is intended for people who are just entering the system programming path.  Its main idea is to get acquainted with various ways of interaction between processes on a POSIX-compatible OS. </h6><a name="habracut"></a><br><h3><a name="part_namedpipe"></a>  Named Channel </h3><br>  To send messages, you can use the mechanisms of sockets, channels, D-bus and other technologies.  You can read about sockets at every corner, and write a separate article about D-bus.  Therefore, I decided to dwell on obscure technologies that meet POSIX standards and give working examples. <br><br>  Consider messaging on named pipes.  Schematically, the transfer looks like this: <br><img src="https://habrastorage.org/storage/43fa1283/ad0ff2c4/dbcf15db/3c2f2fac.png"><br>  To create named pipes, we will use the function <b>mkfifo ()</b> : <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/stat.h&gt; int mkfifo(const char *pathname, mode_t mode);</span></span></span></span></code> </pre> <br>  The function creates a special <abbr title="First-In First-Out">FIFO</abbr> file named <b>pathname</b> , and the <b>mode</b> parameter sets the file permissions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Note: <b>mode is</b> used in conjunction with the current <i>umask</i> value as follows: <i>( <b>mode</b> &amp; ~ umask)</i> .  The result of this operation will be the new <i>umask</i> value for the file we are creating.  For this reason, we use 0777 ( <i>S_IRWXO | S_IRWXG | S_IRWXU</i> ) to not overwrite any bits of the current mask. </h6><br>  Once a file is created, any process can open this file for reading or writing as well as opening a regular file.  However, for correct use of the file, it is necessary to open it simultaneously with two processes / threads, one to receive data (read the file), the other to transfer (write to the file). <br><br>  Upon successful creation of the FIFO file, <b>mkfifo ()</b> returns 0 (zero).  In case of any errors, the function returns -1 and sets the error code to the variable <b>errno</b> . <br><br>  Typical errors that may occur during channel creation: <ul><li>  <i>EACCES</i> - no rights to run (execute) in one of the directories in the <b>pathname</b> path </li><li>  <i>EEXIST</i> - <b>pathname</b> file already exists, even if the file is a symbolic link </li><li>  <i>ENOENT</i> - there is no directory mentioned in <b>pathname</b> , or it is a broken link </li><li>  <i>ENOSPC</i> - no place to create a new file. </li><li>  <i>ENOTDIR</i> - one of the directories mentioned in the <b>pathname</b> is not really one </li><li>  <i>EROFS</i> - an attempt to create a FIFO file on a read-only file system </li></ul>  Reading and writing to the created file is performed using the <b>read ()</b> and <b>write ()</b> functions. <br><br><h4>  Example </h4><br><h6>  mkfifo.c </h6><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #define NAMEDPIPE_NAME "/tmp/my_named_pipe" #define BUFSIZE 50 int main (int argc, char ** argv) { int fd, len; char buf[BUFSIZE]; if ( mkfifo(NAMEDPIPE_NAME, 0777) ) { perror("mkfifo"); return 1; } printf("%s is created\n", NAMEDPIPE_NAME); if ( (fd = open(NAMEDPIPE_NAME, O_RDONLY)) &lt;= 0 ) { perror("open"); return 1; } printf("%s is opened\n", NAMEDPIPE_NAME); do { memset(buf, '\0', BUFSIZE); if ( (len = read(fd, buf, BUFSIZE-1)) &lt;= 0 ) { perror("read"); close(fd); remove(NAMEDPIPE_NAME); return 0; } printf("Incomming message (%d): %s\n", len, buf); } while ( 1 ); }</span></span></span></span></code> </pre>  [ <a href="http://codepad.org/OmewsNFb">download</a> ] <br><br>  We open the file as read only ( <i>O_RDONLY</i> ).  And they could use the <i>O_NONBLOCK</i> modifier, designed specifically for FIFO files, so as not to wait for the file to be opened on the other side.  But in the above code, this method is inconvenient. <br><br>  Compile the program, then run it: <br><pre> <code class="bash hljs">$ gcc -o mkfifo mkfifo.c $ ./mkfifo</code> </pre> <br>  In the next terminal window we execute: <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, my named pipe!'</span></span> &gt; /tmp/my_named_pipe</code> </pre> <br>  As a result, we will see the following output from the program: <br><pre> <code class="bash hljs">$ ./mkfifo /tmp/my_named_pipe is created /tmp/my_named_pipe is opened Incomming message (22): Hello, my named pipe! <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>: Success</code> </pre> <br><h3><a name="part_sharedmemory"></a>  Shared memory </h3><br>  The next type of interprocess communication is <i>shared memory</i> .  We schematically depict it as a certain named area in memory, which is accessed simultaneously by two processes: <br><img src="http://habrastorage.org/storage/21ada3b9/73647083/06cbecd2/7808382a.png"><br>  To allocate shared memory, we will use the POSIX <b>shm_open ()</b> function: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/mman.h&gt; int shm_open(const char *name, int oflag, mode_t mode);</span></span></span></span></code> </pre> <br>  The function returns the file descriptor that is associated with the memory object.  This descriptor can later be used by other functions (for example, <b>mmap ()</b> or <b>mprotect ()</b> ). <br><br>  The integrity of the memory object is preserved, including all data associated with it, until the object is disconnected / deleted ( <b>shm_unlink ()</b> ).  This means that any process can access our memory object (if it knows its name) until we <b>explicitly</b> call <b>shm_unlink ()</b> in one of the processes. <br><br>  The variable <b>oflag</b> is the bitwise "OR" of the following flags: <ul><li>  <i>O_RDONLY</i> - open with read access only </li><li>  <i>O_RDWR</i> - open with read and write permissions </li><li>  <i>O_CREAT</i> - if the object already exists, then no effect from the flag.  Otherwise, an object is created and access rights for it are set in accordance with mode. </li><li>  <i>O_EXCL</i> ‚Äî setting this flag in conjunction with O_CREATE will result in an error returning with the shm_open function if the shared memory segment already exists. </li></ul>  How the value of the <b>mode</b> parameter is specified is described in detail in the previous paragraph ‚Äúmessage passing‚Äù. <br><br>  After creating a shared memory object, we set the size of the shared memory by calling <b>ftruncate ()</b> .  At the entrance of the function, the file descriptor of our object and the size we need. <br><br><h4>  Example </h4><br>  The following code demonstrates the creation, modification, and deletion of shared memory.  It also shows how after creating shared memory, the program exits, but the next time we start we can access it, until <b>shm_unlink () is</b> executed. <br><br><h6>  shm_open.c </h6><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/mman.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define SHARED_MEMORY_OBJECT_NAME "my_shared_memory" #define SHARED_MEMORY_OBJECT_SIZE 50 #define SHM_CREATE 1 #define SHM_PRINT 3 #define SHM_CLOSE 4 void usage(const char * s) { printf("Usage: %s &lt;create|write|read|unlink&gt; ['text']\n", s); } int main (int argc, char ** argv) { int shm, len, cmd, mode = 0; char *addr; if ( argc &lt; 2 ) { usage(argv[0]); return 1; } if ( (!strcmp(argv[1], "create") || !strcmp(argv[1], "write")) &amp;&amp; (argc == 3) ) { len = strlen(argv[2]); len = (len&lt;=SHARED_MEMORY_OBJECT_SIZE)?len:SHARED_MEMORY_OBJECT_SIZE; mode = O_CREAT; cmd = SHM_CREATE; } else if ( ! strcmp(argv[1], "print" ) ) { cmd = SHM_PRINT; } else if ( ! strcmp(argv[1], "unlink" ) ) { cmd = SHM_CLOSE; } else { usage(argv[0]); return 1; } if ( (shm = shm_open(SHARED_MEMORY_OBJECT_NAME, mode|O_RDWR, 0777)) == -1 ) { perror("shm_open"); return 1; } if ( cmd == SHM_CREATE ) { if ( ftruncate(shm, SHARED_MEMORY_OBJECT_SIZE+1) == -1 ) { perror("ftruncate"); return 1; } } addr = mmap(0, SHARED_MEMORY_OBJECT_SIZE+1, PROT_WRITE|PROT_READ, MAP_SHARED, shm, 0); if ( addr == (char*)-1 ) { perror("mmap"); return 1; } switch ( cmd ) { case SHM_CREATE: memcpy(addr, argv[2], len); addr[len] = '\0'; printf("Shared memory filled in. You may run '%s print' to see value.\n", argv[0]); break; case SHM_PRINT: printf("Got from shared memory: %s\n", addr); break; } munmap(addr, SHARED_MEMORY_OBJECT_SIZE); close(shm); if ( cmd == SHM_CLOSE ) { shm_unlink(SHARED_MEMORY_OBJECT_NAME); } return 0; }</span></span></span></span></code> </pre>  [ <a href="http://codepad.org/sos8GSpI">download</a> ] <br><br>  After creating the memory object, we set the size we need to shared memory by calling <b>ftruncate ()</b> .  Then we accessed shared memory using <b>mmap ()</b> .  <i>(Generally speaking, even using the <b>mmap ()</b> call itself, you can create shared memory. But the difference with the <b>shm_open ()</b> call is that the memory will remain allocated until the computer is deleted or restarted.)</i> <br><br>  Compile the code this time with the <i>-lrt</i> option: <br><pre> <code class="bash hljs">$ gcc -o shm_open -lrt shm_open.c</code> </pre> <br>  Look what happened: <br><pre> <code class="bash hljs">$ ./shm_open create <span class="hljs-string"><span class="hljs-string">'Hello, my shared memory!'</span></span> Shared memory filled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>. You may run <span class="hljs-string"><span class="hljs-string">'./shm_open print'</span></span> to see value. $ ./shm_open <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> Got from shared memory: Hello, my shared memory! $ ./shm_open create <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span> Shared memory filled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>. You may run <span class="hljs-string"><span class="hljs-string">'./shm_open print'</span></span> to see value. $ ./shm_open <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> Got from shared memory: Hello! $ ./shm_open close $ ./shm_open <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> shm_open: No such file or directory</code> </pre> <br>  The ‚Äúcreate‚Äù argument in our program is used both to create shared memory and to change its contents. <br><br>  Knowing the name of the memory object, we can change the contents of the shared memory.  But <b>once</b> we call <b>shm_unlink ()</b> , the memory is no longer available to us and <b>shm_open ()</b> without the <i>O_CREATE</i> parameter returns the error "No such file or directory". <br><br><h3><a name="part_semaphore"></a>  Semaphore </h3><br>  A semaphore is the most commonly used method for synchronizing threads and controlling simultaneous access by multiple threads / processes to shared memory (for example, a global variable).  The interaction between processes in the case of semaphores is that the processes work with the same data set and adjust their behavior depending on this data. <br><br>  There are two types of semaphores: <ol><li>  counting semaphore, defining the limit of resources for processes accessing them </li><li>  binary semaphore (binary semaphore), having two states ‚Äú0‚Äù or ‚Äú1‚Äù (more often: ‚Äúbusy‚Äù or ‚Äúnot busy‚Äù) </li></ol>  Consider both types of semaphores. <br><br><h4>  Semaphore with counter </h4><br>  The meaning of a semaphore with a counter is to give access to some resource only to a certain number of processes.  The rest will wait in line when the resource is free. <br><br>  So, to implement semaphores, we will use the POSIX <b>sem_open ()</b> function: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;semaphore.h&gt; sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);</span></span></span></span></code> </pre> <br>  In the function to create a semaphore, we pass the name of the semaphore, built according to certain rules and control flags.  Thus we will have a named semaphore. <br>  The name of the semaphore is constructed as follows: at the beginning is the symbol "/" (slash), followed by Latin characters.  The ‚Äúslash‚Äù symbol should no longer be used.  The length of the semaphore name can be up to 251 characters. <br><br>  If we need to create a semaphore, then the <i>O_CREATE</i> control flag is <i>passed</i> .  To start using an existing semaphore, the <b>oflag</b> is zero.  If, together with the <i>O_CREATE</i> flag, to pass the <i>O_EXCL</i> flag, the <b>sem_open ()</b> function will return an error if the semaphore with the specified name already exists. <br><br>  The <b>mode</b> parameter sets permissions in the same way as explained in previous chapters.  And the <b>value</b> variable initializes the initial value of the semaphore.  Both <b>mode</b> and <b>value are</b> ignored when a semaphore with the specified name already exists, and <b>sem_open () is</b> called with the <i>O_CREATE</i> flag. <br><br>  To quickly open an existing semaphore, we use the construction: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;semaphore.h&gt; sem_t *sem_open(const char *name, int oflag);</span></span></span></span></code> </pre>  where only the semaphore name and control flag are indicated. <br><br><h4>  An example of a semaphore with a counter </h4><br>  Consider an example of using a semaphore to synchronize processes.  In our example, one process increases the value of the semaphore and waits for the second to reset it in order to continue further execution. <br><br><h6>  sem_open.c </h6><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;semaphore.h&gt; #include &lt;stdio.h&gt; #define SEMAPHORE_NAME "/my_named_semaphore" int main(int argc, char ** argv) { sem_t *sem; if ( argc == 2 ) { printf("Dropping semaphore...\n"); if ( (sem = sem_open(SEMAPHORE_NAME, 0)) == SEM_FAILED ) { perror("sem_open"); return 1; } sem_post(sem); perror("sem_post"); printf("Semaphore dropped.\n"); return 0; } if ( (sem = sem_open(SEMAPHORE_NAME, O_CREAT, 0777, 0)) == SEM_FAILED ) { perror("sem_open"); return 1; } printf("Semaphore is taken.\nWaiting for it to be dropped.\n"); if (sem_wait(sem) &lt; 0 ) perror("sem_wait"); if ( sem_close(sem) &lt; 0 ) perror("sem_close"); return 0; }</span></span></span></span></code> </pre>  [ <a href="http://codepad.org/8dzQVZ8n">download</a> ] <br><br>  In one console, run: <br><pre> <code class="bash hljs">$ ./sem_open Semaphore is taken. Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> it to be dropped. &lt;--       sem_wait: Success sem_close: Success</code> </pre> <br>  In the next console, run: <br><pre> <code class="bash hljs">$ ./sem_open 1 Dropping semaphore... sem_post: Success Semaphore dropped.</code> </pre> <br><h4>  Binary semaphore </h4><br>  Instead of a binary semaphore, for which the sem_open function is also used, I‚Äôll consider a semaphore that is often called a ‚Äúmutex‚Äù (mutex). <br><br>  A mutex is essentially the same as a binary semaphore (i.e. a two-state semaphore: busy and not busy).  But the term ‚Äúmutex‚Äù is often used to describe a scheme that prevents two processes from simultaneously using common data / variables.  While the term ‚Äúbinary semaphore‚Äù is more commonly used to describe a construct that restricts access to a single resource.  That is, a binary semaphore is used where one process ‚Äúoccupies‚Äù the semaphore, and the other ‚Äúreleases‚Äù it.  While the mutex is released by the same process / thread that occupied it. <br><br>  Without writing a mutex, for example, a database that many clients can access. <br><br>  To use a mutex, you must call the pthread_mutex_init () function: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);</span></span></span></span></code> </pre> <br>  The function initializes the mutex (variable <b>mutex</b> ) with the <b>mutexattr</b> attribute.  If <b>mutexattr</b> is <i>NULL</i> , then the mutex is initialized with the default value.  In case of successful execution of the function (return code 0), the mutex is considered initialized and ‚Äúfree‚Äù. <br><br>  Common mistakes that may occur: <ul><li>  <i>EAGAIN</i> - insufficient resources (except memory) for mutex initialization </li><li>  <i>ENOMEM</i> - not enough memory </li><li>  <i>EPERM</i> - no rights to perform an operation </li><li>  <i>EBUSY</i> - an attempt to initialize a mutex that has already been initialized, but not undefined </li><li>  <i>EINVAL</i> - <b>mutexattr</b> value <b>is</b> not valid. </li></ul>  To occupy or free a mutex, use the functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_mutex_lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_mutex_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mutex)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_mutex_trylock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_mutex_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mutex)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_mutex_unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_mutex_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mutex)</span></span></span></span>;</code> </pre> <br>  The <b>pthread_mutex_lock ()</b> function, if the <b>mutex</b> is not yet occupied, then it occupies it, becomes its owner, and immediately exits.  If the mutex is busy, it blocks further process execution and waits for the mutex to be released. <br>  The <b>pthread_mutex_trylock ()</b> function is identical in the behavior of the <b>pthread_mutex_lock ()</b> function, with one exception ‚Äî it does not block the process if <b>mutex is</b> busy, but returns an <i>EBUSY</i> code. <br>  The <b>pthread_mutex_unlock ()</b> function frees a busy mutex. <br><br>  Return codes for <b>pthread_mutex_lock ()</b> : <ul><li>  EINVAL - mutex incorrectly initialized </li><li>  EDEADLK - the mutex is already taken by the current process. </li></ul>  Return codes for <b>pthread_mutex_trylock ()</b> : <ul><li>  EBUSY - mutex is already taken </li><li>  EINVAL - mutex incorrectly initialized </li></ul>  Return codes for <b>pthread_mutex_unlock ()</b> : <ul><li>  EINVAL - mutex incorrectly initialized </li><li>  EPERM - the calling process is not the owner of the mutex </li></ul><h4>  Mutex example </h4><br><h6>  mutex.c </h6><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; static int counter; // shared resource static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; void incr_counter(void *p) { do { usleep(10); // Let's have a time slice between mutex locks pthread_mutex_lock(&amp;mutex); counter++; printf("%d\n", counter); sleep(1); pthread_mutex_unlock(&amp;mutex); } while ( 1 ); } void reset_counter(void *p) { char buf[10]; int num = 0; int rc; pthread_mutex_lock(&amp;mutex); // block mutex just to show message printf("Enter the number and press 'Enter' to initialize the counter with new value anytime.\n"); sleep(3); pthread_mutex_unlock(&amp;mutex); // unblock blocked mutex so another thread may work do { if ( gets(buf) != buf ) return; // NO fool-protection ! Risk of overflow ! num = atoi(buf); if ( (rc = pthread_mutex_trylock(&amp;mutex)) == EBUSY ) { printf("Mutex is already locked by another process.\nLet's lock mutex using pthread_mutex_lock().\n"); pthread_mutex_lock(&amp;mutex); } else if ( rc == 0 ) { printf("WOW! You are on time! Congratulation!\n"); } else { printf("Error: %d\n", rc); return; } counter = num; printf("New value for counter is %d\n", counter); pthread_mutex_unlock(&amp;mutex); } while ( 1 ); } int main(int argc, char ** argv) { pthread_t thread_1; pthread_t thread_2; counter = 0; pthread_create(&amp;thread_1, NULL, (void *)&amp;incr_counter, NULL); pthread_create(&amp;thread_2, NULL, (void *)&amp;reset_counter, NULL); pthread_join(thread_2, NULL); return 0; }</span></span></span></span></code> </pre>  [ <a href="http://codepad.org/1KdzUvAA">download</a> ] <br><br>  This example demonstrates the sharing of two threads to a common variable.  One thread (the first thread) in the automatic mode constantly increases the <b>counter</b> variable by one, while taking up this variable for a full second.  This first thread gives the second access to the <b>count</b> variable for only 10 milliseconds, then again takes it for a second.  In the second stream, it is proposed to introduce a new value for the variable from the terminal. <br><br>  If we didn‚Äôt use the mutex technology, then what value would be in the global variable, with the simultaneous access of two threads, we do not know.  Also during startup, the difference between <b>pthread_mutex_lock ()</b> and <b>pthread_mutex_trylock ()</b> becomes apparent. <br><br>  Compile the code with the optional <b>-lpthread</b> parameter: <br><pre> <code class="bash hljs">$ gcc -o mutex -lpthread mutex.c</code> </pre> <br>  We start and change the value of a variable by simply entering a new value in the terminal window: <br><pre> <code class="cpp hljs">$ ./mutex Enter the number <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> press <span class="hljs-string"><span class="hljs-string">'Enter'</span></span> to initialize the counter with <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> value anytime. <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> &lt;Enter&gt; &lt;---    Mutex is already locked by another process. Let's lock mutex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pthread_mutex_lock(). New value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> counter is <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Enter&gt; &lt;---    Mutex is already locked by another process. Let's lock mutex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pthread_mutex_lock(). New value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> counter is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><h3>  Instead of conclusion </h3><br>  In the following articles I want to look at d-bus and RPC technologies.  If there is interest, let me know. <br>  Thank. <br><br>  <b>UPD:</b> Updated the 3rd chapter on semaphores.  Added a subchapter about mutex. </div><p>Source: <a href="https://habr.com/ru/post/122108/">https://habr.com/ru/post/122108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122102/index.html">Apple patent - infrared transmitters and anti-bootleg</a></li>
<li><a href="../122103/index.html">kedDroid - S03E07. Video review software for Android</a></li>
<li><a href="../122105/index.html">Tea on the laptop keyboard - it can happen to anyone</a></li>
<li><a href="../122106/index.html">How can I get a captured image of Mac OS Lion 10.7</a></li>
<li><a href="../122107/index.html">Visit Report Russian DEFCON Group</a></li>
<li><a href="../122109/index.html">HabraFav - access to selected</a></li>
<li><a href="../122110/index.html">IT people go to help</a></li>
<li><a href="../122113/index.html">Survivor bias</a></li>
<li><a href="../122115/index.html">Navigation: bad advice</a></li>
<li><a href="../122117/index.html">Chrome beta now has support for ‚Äúinstant pages‚Äù and print preview.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>