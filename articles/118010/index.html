<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Translation of the article ‚ÄúPimp My Pimpl‚Äù, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first part of the article discusses the classic Pimpl idiom (pointer-to-implementation, pointer to implementation), shows its advantages and consi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Translation of the article ‚ÄúPimp My Pimpl‚Äù, part 1</h1><div class="post__text post__text-html js-mediator-article">  The first part of the article discusses the classic Pimpl idiom (pointer-to-implementation, pointer to implementation), shows its advantages and considers the further development of idioms based on it.  The second part will focus on how to reduce the disadvantages that inevitably arise when using Pimpl. <br><a name="habracut"></a><br><h4>  Links to the original </h4><br>  This is a translation of the first part of the article from the <i><a href="http://www.heise.de/developer/">Heise Developer</a></i> website.  The originals of both parts are here: <a href="http://www.heise.de/developer/artikel/C-Vor-und-Nachteile-des-d-Zeiger-Idioms-Teil-1-1097781.html">part 1</a> , <a href="http://www.heise.de/developer/artikel/C-Vor-und-Nachteile-des-d-Zeiger-Idioms-Teil-2-1136104.html">part 2</a> <br>  The translation was made from an English translation <a href="http://marcmutz.wordpress.com/translated-articles/pimp-my-pimpl/">from here</a> . <br><br><h4>  annotation </h4><br>  Much has been written about the idiom with the ridiculous name Pimpl.  <i>Heise Developer</i> covers some aspects of this practical design that goes beyond the classic technique. <br><br><h4>  Classic idiom </h4><br>  Every C ++ programmer must have come across a class description like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: class Private; //   Private *d; //    };</span></span></code> </pre> <br>  Here, the data fields of class <code>Class</code> transferred to the nested class <code>Class::Private</code> .  Instances of the <code>Class</code> class will contain only the pointer <code>d</code> to the <code>Class::Private</code> objects. <br><br>  To understand why the author of the class used such a cover-up, you need to go back and look at the C ++ module system.  Unlike many other languages, C ++, a successor of the C language, does not have built-in support for modules (this support was proposed for C ++ 0x, but it was not included in the final standard).  Instead, an approach is used in which the declaration of module functions (but usually not their description) is placed in header files that are made available to other modules using the <code>#include</code> preprocessor directive.  This approach gives the header files a double role: on the one hand, they are the interface of the module.  On the other hand - the place of announcement of possible details of the internal implementation. <br><br>  In the C language, this approach worked well: the details of the implementation of functions were completely encapsulated by separating the declaration and description;  it can either make only a <i>preliminary declaration of</i> structures (in this case they will be private), or describe them directly in the header file (then they will be public).  In object-oriented C, the above Class <code>Class</code> might look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   typedef struct Class * Class_t; // -&gt;    void Class_new(Class_t *cls); // Class::Class() void Class_release(Class_t cls); // Class::~Class() int Class_f(Class_t cls, double num); // int Class::f(double) // ...</span></span></code> </pre><br>  Unfortunately, this does not work in C ++.  Methods must be declared inside the class.  Classes without methods would be useless; therefore, C ++ header files usually contain class descriptions.  Since the class body, unlike the namespace, cannot be re-opened, the header file must contain all declarations (data and method fields): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ...   ... ok private: // ...     ...   ,     };</span></span></code> </pre><br>  The problem is obvious: the module interface (header file) necessarily contains implementation details - a bad approach.  Therefore, a rather crude trick is used when all implementation details (data fields and private methods) are put into a separate class: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// --- class.h --- class Class { public: Class(); ~Class(); // ...   ... void f(double n); private: class Private; Private *d; }; // -- class.cpp -- #include "class.h" class Class::Private { public: // ...     ... bool canAcceptN(double num) const { return num != 0 ; } double n; }; Class::Class() : d(new Private) {} Class::~Class() { delete d; } void Class::f(double n) { if (d-&gt;canAcceptN(n)) d-&gt;n = n; }</span></span></code> </pre><br>  Since <code>Class::Private</code> used only when declaring a pointer variable, i.e.  ‚ÄúOnly by name‚Äù (Lakos), rather than ‚Äúby size‚Äù, a preliminary declaration is sufficient, as is the case with pure C. All Class methods of the class will now access the private methods and data fields of Class <code>Class::Private</code> only through the <code>d</code> field . <br><br>  Thus, we get the convenience of a system of fully encapsulated modules in C ++.  Due to the use of an intermediate variable, one has to pay for the benefits with overhead memory allocation ( <code>new Class::Private</code> ), indirect calls to data fields, as well as a complete failure (at least in the public section) of <code>inline</code> methods.  As will be shown in the second part of the article, the semantics of constant methods also change. <br><br>  Before the second part of this article, devoted to correcting or, at least, alleviating the above shortcomings, let us try to describe the benefits of using the idiom in question. <br><br><h4>  Advantages of Pimpl Idioms </h4><br>  The benefits of using Pimpl are substantial.  Encapsulating all implementation details, we get a thin and long-term stable interface (header file).  The first is an easily readable description of the class;  under the second - support for binary compatibility, even after significant changes in implementation. <br><br>  For example, the Nokia department of Qt Development Frameworks (formerly Trolltech) at least twice during the development of the Qt 4 class library made profound changes to the rendering of widgets without having to relink applications using Qt 4. <br><br>  Don't underestimate the significant build acceleration when using the Pimpl idiom, especially in large projects.  The build is accelerated due to the reduction in the number of <code>#include</code> directives in header files and because of the significant reduction in the frequency of changes to the header files of the Pimpl classes.  In the book ‚ÄúSolving Difficult Tasks in C ++‚Äù (‚ÄúExceptional C ++‚Äù), the Coat of Arms Satter notes the constant doubling of the compilation speed, and John Lacos even claims that the assembly is accelerated by two orders of magnitude. <br><br>  Another advantage of using Pimpl: classes with d-pointers are well suited for transaction-oriented and safe regarding code exceptions.  For example, a developer can use the Copy-Swap idiom (Sutter, Alexandrescu ‚ÄúC ++ Programming Standards,‚Äù clause 56) to create a transactional (all-or-nothing) copying assignment operator: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void swap(Class &amp;other) { std::swap(d, other.d); } Class &amp;operator=(const Class &amp;other) { //    ,    *this Class copy(other); //     ,    *this swap(copy); return *this; }</span></span></code> </pre><br>  The implementation of move operations in <a href="http://ru.wikipedia.org/wiki/C%252B%252B0x">C ++ 0x is</a> trivial (and, in particular, the same for all Pimpl classes): <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    C++0x: Class(Class &amp;&amp;other) : d(other.d) { other.d = 0; } Class &amp;operator=(Class &amp;&amp;other) { std::swap(d, other.d); return *this; } // ... };</span></span></code> </pre><br>  In this model, the exchange function and assignment operators can be implemented as <code>inline</code> , without prejudice to the encapsulation of the class;  developers can find an effective use of this feature. <br><br><h4>  Advanced Composition Methods </h4><br>  The last advantage of Pimpl, which is worth noting, is the ability to reduce additional dynamic memory allocations using direct aggregation of data fields.  Without using Pimpl, aggregation can be done using pointers to separate classes from one another (using Pimpl for data fields).  By using Pimpl entirely for the whole class, you can eliminate the need to store private data of complex types only by pointers. <br><br>  For example, the idiomatic Qt dialog class <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QLineEdit</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QLabel</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDialog</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QDialog { <span class="hljs-comment"><span class="hljs-comment">// ... private: //   Qt: QLabel *m_loginLB; QLineEdit *m_loginLE; QLabel *m_passwdLB; QLineEdit *m_passwdLE; };</span></span></code> </pre><br>  turns into <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QLabel&gt; #include &lt;QLineEdit&gt; class MyDialog::Private { // ... //    Qt,       QLabel loginLB; QLineEdit loginLE; QLabel passwdLB; QLineEdit passwdLE; };</span></span></span></span></code> </pre><br>  Qt experts may notice that the <code>QDialog</code> destructor already destroys the descendants of the widgets, therefore, direct aggregation will lead to a double call of their destruction.  Indeed, the use of this technique poses the risk of errors in the memory allocation sequence (double deletion, use after release, etc.), especially if the data fields also belong to the class and vice versa.  However, the conversion shown is safe in this case, since  Qt always allows you to remove descendants in front of their parents. <br><br>  This approach is especially effective when the data fields aggregated in this way are themselves instances of Pimpl classes.  This is exactly the case in the last example, where the use of the idiom Pimpl retains four dynamic memory allocations of size size <code>sizeof(void*)</code> , instead of which there is only one additional (large) memory allocation.  This can lead to more efficient use of the heap, since  small memory allocations constantly create large overhead in the allocator. <br><br>  In addition, with this approach, the compiler has much more chances to ‚Äúvirtualize‚Äù calls to virtual functions, i.e.  it will remove double indirect calls, to which the virtuality of the called functions leads.  When using pointer aggregation, this requires interprocedural optimization.  In any case, this will give a performance gain in runtime against the background of additional indirect calls;  however, the d-pointer should be checked as necessary by profiling specific classes. <br><br>  In the case when profiling shows that dynamic memory allocation becomes a bottleneck, the application of the idiom ‚ÄúFast Pimpl‚Äù can help (‚ÄúSolving complex problems in C ++‚Äù, paragraph 30).  In this variant, to create instances of the <code>Private</code> class, instead of the global operator <code>new()</code> , a fast allocator is used, for example, <a href="http://www.boost.org/doc/libs/release/libs/pool/doc/interfaces/singleton_pool.html"><code>boost::singleton_pool</code></a> . <br><br><h4>  Intermediate conclusions </h4><br>  Pimpl is a well-known C ++ idiom that allows the programmer to separate the class interface from its implementation to the extent that C ++ does not allow to do directly.  The positive side effects of using the d-pointer are speeding up the compilation, simplifying the implementation of transaction semantics, and the ability to make the implementation potentially more efficient at runtime using advanced composition methods. <br><br>  But d-pointers also have their drawbacks: in addition to the need to create an additional <code>Private</code> class, dynamic memory allocation for it, modified semantics of constant methods, potential errors in the sequence of memory allocation are also cause for concern. <br><br>  In the second part of the article, the author will show a solution for some of the listed problems. <br>  The complexity will increase even more, so in each case it is necessary to check whether the advantages of using idioms outweigh its disadvantages.  In case of doubt, such a check must be done for every doubtful class.  As always, there is no common solution. <br><br><h4>  What's next? </h4><br>  The second (and last) part of this article will introduce us to the internal structure of Pimpl, reveal problem areas and complement the idiom with the help of a number of improvements. <br><br><h4>  Other articles about Pimpl on Habr√© </h4><br>  <a href="http://habrahabr.ru/blogs/refactoring/111602/">Idioms Pimpl and Fast Pimpl - a pointer to the implementation</a> <br>  <a href="http://habrahabr.ru/blogs/qt_software/76248/">What is a Pimpl version of Qt, and with what it is eaten!</a> <br>  <a href="http://habrahabr.ru/blogs/qt_software/76506/">Private slots in Qt's Pimpl pattern</a> </div><p>Source: <a href="https://habr.com/ru/post/118010/">https://habr.com/ru/post/118010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118000/index.html">Two gifts on the DR ZX-Spectrum</a></li>
<li><a href="../118001/index.html">AWS in Down: Why the skies collapsed</a></li>
<li><a href="../118002/index.html">Principles of design of payment pages for online stores</a></li>
<li><a href="../118003/index.html">Introduction to the Apache log4cxx logging library</a></li>
<li><a href="../118005/index.html">Android phone is also watching ...</a></li>
<li><a href="../118011/index.html">Silex - microfreemv from the creators of symfony2</a></li>
<li><a href="../118017/index.html">CNET's investigation revealed what information Android phones send to Google, and why it cannot be considered anonymous</a></li>
<li><a href="../118018/index.html">Apple is close to launching its music cloud service.</a></li>
<li><a href="../118019/index.html">Large Hadron Collider set a new world record</a></li>
<li><a href="../118020/index.html">Setup of the screw web server without RDP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>