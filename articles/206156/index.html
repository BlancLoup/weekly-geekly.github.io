<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenGL in Qt 5.1 - Part 1 and 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a translation of an OpenGL in Qt 5.1 article - Part 1 and Part 2. 


 Part 1 
 This article is the first in the series. It will show h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenGL in Qt 5.1 - Part 1 and 2</h1><div class="post__text post__text-html js-mediator-article">  This article is a translation of an <a href="http://www.kdab.com/opengl-in-qt-5-1-part-1/">OpenGL in Qt 5.1</a> article <a href="http://www.kdab.com/opengl-in-qt-5-1-part-1/">- Part 1</a> and <a href="http://www.kdab.com/opengl-in-qt-5-1-part-2/">Part 2.</a> <br><br><br><h1>  Part 1 </h1><hr><br>  This article is the first in the series.  It will show how to use OpenGL in <a href="">Qt 5</a> .  This article will be a brief insight into the history of OpenGL support in Qt.  Then we proceed to the description of the first part of the new features that are included in <a href="https://qt-project.org/qt5/qt51">Qt 5.1</a> .  Subsequent articles will describe more features, as well as some simple examples of how easy Qt can be used to work with OpenGL. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  (Very) A brief history of Qt and OpenGL </h2><br>  Qt has a long history of drawing support with OpenGL.  Most Qt developers have ideas about <a href="http://qt-project.org/doc/qt-5/qglwidget.html">QGLWidget</a> and, possibly, some OpenGL-based engines.  This allows you to work with raw OpenGL or use the convenience provided by the <a href="http://qt-project.org/doc/qt-5/qpainter.html">QPainter</a> API.  In addition to this, Qt provides several useful wrappers around various OpenGL objects: <a href="http://qt-project.org/doc/qt-5.0/qtopengl/qglshaderprogram.html">QGLShaderProgram</a> , <a href="http://qt-project.org/doc/qt-5.0/qtopengl/qglframebufferobject.html">QGLFramebufferObject</a> , <a href="http://qt-project.org/doc/qt-5.0/qtopengl/qglbuffer.html">QGLBuffer</a> , etc. <br><br>  When designing Qt 5, these QGL * classes were labeled as ‚Äúdone‚Äù and the newest QOpenGL * classes became part of the QtGui module ( <u>translator's note</u> - it used to be <a href="http://qt-project.org/doc/qt-4.8/qtopengl.html">QtOpenGL</a> ).  The reason for these changes is that the new rendering in Qt Quick 2 is based on OpenGL, and is currently the main part of the Qt graphics offerings.  In addition, new QOpenGL * classes can be used as a direct replacement for old QGL * classes.  It is now recommended to use the QOpenGL * classes from the <a href="http://qt-project.org/doc/qt-5.0/qtgui/qtgui-module.html">QtGui</a> library. <br><br>  Qt 5.0 provides (basically) the same subset of OpenGL functionality that Qt 4.8 provides.  This was required, among other things, for the functionality required in <a href="http://qt-project.org/doc/qt-5.0/qtdoc/modules.html">Qt Quick 2</a> .  In addition to the functionality of Qt 4.8, Qt 5.0 provides the means to easily create your own OpenGL windows and contexts on any platform.  You no longer have to mess around with the features of various platforms to create a context that can support the <a href="http://www.opengl.org/wiki/Core_And_Compatibility_in_Contexts">OpenGL Core profile</a> .  You can simply use <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglcontext.html">QOpenGLContext</a> and save yourself from gray hair! <br><br>  In Qt 5.1, our adventures begin with a demonstration of more and more OpenGL functionality, so as to make using OpenGL and Qt simple, elegant and, I hope, fun!  To this end, <a href="http://www.kdab.com/">KDAB</a> has invested heavily in expanding the boundaries of Qt and OpenGL. <br><br><br><h2>  Functions, functions everywhere! </h2>  Frankly speaking, working with OpenGL on some platforms can be difficult. <br>  .  One of the main reasons for these difficulties is the need to assign the address of the entry point dynamically, at runtime, and not at build time (when the linker is able to do this).  For example, on Microsoft Windows, the address of any function entered in OpenGL since version 1.1 must be assigned at run time.  That is, it must be done for almost all the functions used in modern OpenGL! <br><br>  To solve these problems, Qt provides a couple of useful utilities: <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglcontext.html">QOpenGLContext :: GetProcAddress ()</a> and <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglfunctions.html">QOpenGLFunctions</a> .  The former can be used to manually assign entry points, while the latter is a class whose methods are a display of a common subset of the functions OpenGL 2 and <a href="http://www.khronos.org/opengles/2_X/">OpenGL ES 2</a> .  These helpers are as good as possible.  The problem is that QOpenGLFunctions is limited in the methods provided (subsets of OpenGL 2 and OpenGL ES 2).  And manual assignment of entry points is very tedious work, fraught with errors.  Alternatively, you can use functions from third-party libraries that solve these problems, such as <a href="http://glew.sourceforge.net/">Glew</a> or <a href="http://www.opengl.org/sdk/libs/GLee/">GLee</a> .  True, these solutions also cause problems for obtaining the required functionality and convenient work with Qt (for example, taking into account the order of the readers). <br><br>  Use <a href="http://qt-project.org/doc/qt-5.1/qtgui/qopenglcontext.html">QOpenGLContext :: versionFunctions ()</a> !  This is a modest small function - your explorer into the ‚Äúutopia‚Äù of addresses (entry points) of OpenGL functions :) This function can be used to get a pointer to an object (with methods for each function) in the required version and OpenGL profile.  Let's take a look at a simple example.  Let's say we have a subclass of <a href="http://qt-project.org/doc/qt-5.0/qtgui/qwindow.html">QWindow</a> that renders.  We want to create an <a href="http://www.opengl.org/registry/doc/glspec43.core.20120806.pdf">OpenGL 4.3 Core profile</a> and use all the features provided.  It's very easy to do this: <br><br><pre><code class="cpp hljs">Window::Window(QScreen * screen) : QWindow(screen) { <span class="hljs-comment"><span class="hljs-comment">//  Qt    OpenGL    setSurfaceType(OpenGLSurface); //     -  QSurfaceFormat format; format.setDepthBufferSize(24); format.setMajorVersion(4); format.setMinorVersion(3); format.setSamples(4); format.setProfile(QSurfaceFormat::CoreProfile); setFormat(format); create(); //  OpenGL  m_context = new QOpenGLContext; m_context-&gt;setFormat(format); m_context-&gt;create(); //       m_context-&gt;makeCurrent(this); //         // m_funcs  : QOpenGLFunctions_4_3_Core * m_funcs m_funcs = m_context-&gt;versionFunctions(); if (!m_funcs) { qWarning("Could not obtain OpenGL versions object"); exit(1); } m_funcs-&gt;initializeOpenGLFunctions(); }</span></span></code> </pre> <br><br>  From now on, we can simply use the member functions of the <a href="http://qt-project.org/doc/qt-5.1/qtgui/qopenglfunctions-4-3-core.html">QOpenGLFunctions_4_3_Core</a> object.  For example: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  Vertex Attrib Divisor //    instanced rendering // (  OpenGL 3.3) m_funcs-&gt;glVertexAttribDivisor(pointLocation, 1); //    compute shader // (  OpenGL 4.3) m_funcs-&gt;glDispatchCompute(512 / 16, 512 / 16, 1);</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">What is this code about?</b> <div class="spoiler_text"><ul><li>  <a href="">glVertexAttribDivisor</a> </li><li>  <a href="http://ogldev.atspace.co.uk/www/tutorial33/tutorial33.html">Instanced rendering</a> </li><li>  <a href="http://www.opengl.org/wiki/Compute_Shader">Compute shader</a> </li><li>  <a href="">glDispatchCompute</a> </li></ul></div></div><br><br>  As we can see, it is easy enough to have all the OpenGL functionality in your hands for any platform that supports it.  In addition, <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglcontext.html">QOpenGLContext</a> , <a href="http://qt-project.org/doc/qt-5.1/qtgui/qopenglfunctions-4-3-core.html">QOpenGLFunctions_4_3_Core</a> and similar classes minimize the work to use functions by distributing backends containing valid function pointers.  Also, this approach automatically takes care of platform-specific addresses of functions (for example, when using multiple threads and contexts or several GPUs).  The code for these classes is generated automatically using an auxiliary utility, so it is very easy to update it when a new version of OpenGL is released. <br><br><br><h2>  OpenGL Extensions (OpenGL Extensions) </h2><br>  OpenGL has a popular <a href="http://www.opengl.org/documentation/extensions/">extension mechanism</a> that allows vendors to introduce new or experimental functionality and APIs to test whether they are useful and well thought out.  Unfortunately, if the extension introduces new functions, then they also need to specify the address as for other OpenGL functions (as indicated above). <br><br>  To use OpenGL extensions, you need to go through two stages.  Qt helps with both stages: <br><br><h4>  Stage 1: </h4>  Verify that the current implementation supports the required extension.  If the extension introduces a new API, specify the entry point.  To verify that the extension is supported, you need to use the <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglcontext.html">QOpenGLContext :: hasExtension ()</a> method.  In addition, you can use <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglcontext.html">OpenGLContext :: extensions ()</a> to get the full list of supported extensions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   QList extensions = m_context-&gt;extensions().toList(); std::sort(extensions); qDebug() &lt;&lt; "Supported extensions (" &lt;&lt; extensions.count() &lt;&lt;")"; foreach (const QByteArray &amp;extension, extensions) { qDebug() &lt;&lt; " " &lt;&lt; extension; }</span></span></code> </pre> <br><br><h4>  Stage 2: </h4>  At the second stage, we would need to use our old friend - the <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglcontext.html">QOpenGLContext :: GetProcAddress ()</a> method.  In Qt 5.1, the <a href="https://qt.gitorious.org/qt/qtbase/source/2975aa39e67e234e6478ed056da4d1b0995b121f:src/openglextensions">QtOpenGLExtensions</a> module is responsible for this.  This module is a static library and contains a class for each OpenGL extension (which introduces a new API) from the <a href="http://www.khronos.org/registry/">Khronos registry</a> .  To use the OpenGL extension, use code similar to the following: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    if (!m_context-&gt;hasExtension(QByteArrayLiteral("GL_ARB_instanced_arrays")) { qFatal("GL_ARB_instanced_arrays is not supported"); } //          QOpenGLExtension_ARB_instanced_arrays * m_instanceFuncs = new QOpenGLExtension_ARB_instanced_arrays(); m_instanceFuncs-&gt;initializeOpenGLFunctions(); //    m_instanceFuncs-&gt;glVertexAttribDivisorARB(pointLocation, 1);</span></span></code> </pre><br><br>  As with the basic functions of OpenGL, the code for the extensions is generated and, therefore, easily updated in the future. <br><br><br><h1>  Part 2 </h1><hr><br><h2>  Vertex Array Objects </h2><br>  Qt has a <a href="http://qt-project.org/doc/qt-5.0/qtgui/qopenglbuffer.html">QOpenGLBuffer</a> (previously <a href="http://qt-project.org/doc/qt-4.8/qglbuffer.html">QGLBuffer</a> ) to help manage various types of OpenGL buffer objects, such as <a href="http://www.opengl.org/wiki/Vertex_Attribute">per-vertex attribute data</a> and <a href="http://www.opengl.org/wiki/Vertex_Specification">element index buffers</a> .  OpenGL also has a special container, the type of which is called the <a href="http://www.opengl.org/wiki/Vertex_Specification">Objects Vertex Array (VAOs)</a> , which helps in working with the <a href="http://www.opengl.org/wiki/Vertex_Specification">vertex buffer object (VBO)</a> sets. <br><br>  KDAB has added code for Qt 5.1 that encapsulates several VAOs with the <a href="http://qt-project.org/doc/qt-5.1/qtgui/qopenglvertexarrayobject.html">QOpenGLVertexArrayObject</a> class.  Linking an instance of this class tells OpenGL to "remember" any vertex specification state that you would like to set later.  We can later restore the required state specifications very quickly by simply re-linking the VAO itself.  This allows us to very quickly switch between the vertex states for the ‚Äúobjects‚Äù that we want to draw in our rendering function: <div class="spoiler">  <b class="spoiler_title">Translator's Note</b> <div class="spoiler_text">  In my opinion, instead of ‚Äúbinding,‚Äù it would be more appropriate to use the ‚ÄúRussified‚Äù verb ‚Äúbandage‚Äù, which may be more common for developers to hear. </div></div><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Scene::initialize() { <span class="hljs-comment"><span class="hljs-comment">//      QOpenGLContext  // m_shaderProgram  QOpenGLShaderProgram //  VAO     m_vao1 = new QOpenGLVertexArrayObject( this ); m_vao1-&gt;create(); m_vao1-&gt;bind(); //   VBO  IBO ( QOpenGLBuffer   , //  ,    ..).   "" //    VAO m_positionBuffer.create(); m_positionBuffer.setUsagePattern(QOpenGLBuffer::StreamDraw); m_positionBuffer.bind(); m_positionBuffer.allocate(positionData, vertexCount * 3 * sizeof(float)); m_shaderProgram.enableAttributeArray("vertexPosition"); m_shaderProgram.setAttributeBuffer ("vertexPosition", GL_FLOAT, 0, 3); m_colorBuffer.create(); m_colorBuffer.setUsagePattern(QOpenGLBuffer::StaticDraw); m_colorBuffer.bind(); m_colorBuffer.allocate(colorData, vertexCount * 3 * sizeof(float)); m_shaderProgram.enableAttributeArray("vertexColor"); m_shaderProgram.setAttributeBuffer ("vertexColor", GL_FLOAT, 0, 3); //    ,  , // , ... ... //  VAO     m_vao2 = new QOpenGLVertexArrayObject(this); m_vao2-&gt;create(); m_vao2-&gt;bind(); //   VBO  IBO    ... // "  "    (.  ) m_skyBoxVAO = new QOpenGLVertexArrayObject(this); ... } void Scene::render() { //   m_funcs-&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //       m_phongShaderProgram-&gt;bind(); ... //           m_vao1-&gt;bind(); m_funcs-&gt;glDrawElements(...); //           m_vao2-&gt;bind(); m_funcs-&gt;glDrawElements(...); //    /   .. //     m_skyboxShaderProgram-&gt;bind(); ... m_skyboxVAO-&gt;bind(); m_funcs-&gt;glDrawElements(...); ... }</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Translator's Note</b> <div class="spoiler_text">  ‚ÄúRinse and repeat‚Äù is a sarcastic metaphor indicating the repetition of instructions.  It has roots in the phrase <i>‚Äúwash, rinse, repeat‚Äù</i> , which is indicated on the packaging of most brands of shampoos. </div></div><br><br>  VAOs were introduced with the OpenGL 3 version, but they are required for OpenGL version over 3.1 with Core Profile.  In addition, VAO are available as <a href="http://www.opengl.org/registry/specs/ARB/vertex_array_object.txt">GL_ARB_vertex_array_object</a> or <a href="http://www.khronos.org/registry/gles/extensions/OES/OES_vertex_array_object.txt">GL_OES_vertex_array_object extensions</a> in OpenGL 2 and OpenGL ES 2, respectively.  The QOpenGLVertexArrayObject class will use the main functionality (if possible) or access the extension (if any) if necessary. <br><br>  Using VAO can significantly simplify the visualization code and increase performance, because  the OpenGL driver will do less validation checks (than if it were doing more buffer operations). <br><br>  <i>Part 3,4,5 coming soon ...</i> PS: A big request, all stylistic and grammatical errors, as well as inaccuracies of the translation should be reported through drugs.  All will rule as they become available. </div><p>Source: <a href="https://habr.com/ru/post/206156/">https://habr.com/ru/post/206156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206146/index.html">We buy train tickets in the New Year</a></li>
<li><a href="../206148/index.html">Creating your own drivers for Linux</a></li>
<li><a href="../206150/index.html">The second life of old dial gauges</a></li>
<li><a href="../206152/index.html">Tuning mooedit, work on the bugs</a></li>
<li><a href="../206154/index.html">rusEfi: ignition and other buns</a></li>
<li><a href="../20616/index.html">The last 10 days of the legendary Netscape Navigator</a></li>
<li><a href="../206160/index.html">Basics of developing a client network I2P. Part 2</a></li>
<li><a href="../206164/index.html">Startups from Silicon Valley with Russian-speaking founders. Jacob Diener and Igor Katsman - the founders of Driveway Software</a></li>
<li><a href="../206166/index.html">Private space - Per aspera ad astra</a></li>
<li><a href="../206168/index.html">Overview of switches with 24 10Gb optical ports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>