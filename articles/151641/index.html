<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I Invented the Bike, Learning Technology</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Repeatedly heard the statement that the programming language is best studied in the process of creating something. Could not disagree with this, and d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I Invented the Bike, Learning Technology</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/4ae/f39/779/4aef39779fd17e2d1a36ccda1de121be.jpg">  Repeatedly heard the statement that the programming language is best studied in the process of creating something.  Could not disagree with this, and decided that this applies not only to the language, but also to all sorts of technologies coexisting with this language. <br>  To tread the uncharted path is not easy, it is much easier to study how someone treads this path in front of you.  I don‚Äôt have a soul to study documentation, I use it as a reference book, and it takes too much time and effort to learn something from scratch, because the authors usually assume that the reader has more knowledge, almost everything he needs is already known.  Bicycle themes also highlight the process of learning, walking on a rake and everything else.  Unfortunately, I didn‚Äôt find enough detailed articles on topics I was interested in, studied in fragments, and decided to write an article myself, hoping to make life easier for those who can follow. <br><a name="habracut"></a><br>  Most of all I wanted to master the process, or the approach, well, or ideology, if you will, which is called TDD, aka Test-Driven Development.  Also, as an assistive technology, in terms of tests, the test framework Moq was used.  Looking ahead, I‚Äôll say that it wasn‚Äôt possible to develop fully correctly, because the skills of the ‚Äúarchitect‚Äù also need experience.  I had to redo some blocks, and the test cases themselves, which I wrote, not yet fully aware of what and how the class should do.  However, things got off the ground, the experience was gained, and the next time it should be easier.  The second technology, which has long been itching to master, is dependency injection and IoC containers.  In development, I used Autofac, which is the most impressive to me. <br><br><h2>  Theme for cycling </h2><br>  It did not take long to choose, the decision came literally on its own - to write your own logger with filtering and a configurable output format.  I wanted to write my first article about ASP.Net, and the MVC3 framework.  Although now it makes sense to move towards MVC4.  Among the technologies, by the way, was supposed to use the Entity Framework.  On Habr√© there is already an article on this topic, but the author has disappeared, without finishing the promise. <br>  So why am I interrupted by a logger?  In the process of creating that application, of course, there was a need for logging.  I was advised to take the NLog available in NuGet, but after studying it, I came to the conclusion that writing my logger is not only interesting, but also justified.  I did not check it myself, but judging by the reviews on the Internet, log4net is slower than it, therefore I did not consider it. <br>  I myself work in telecom, and I already had to work with the logger when there was a need for functionality that was not available in standard syslogs.  This is filtering by id.  When the site processes 30 thousand calls per hour, then even if the bug is 100% reproducible on it, finding it in megabytes and even gigabytes of logs is not so easy.  Yes, and not all systems allow you to store gigabytes of logs, some where there are systems that only have a few minutes of traffic during peak hours and the call itself may be longer in length, that is, the beginning or end of the call may not be included in the log.  Therefore, ‚Äúfrom above‚Äù an idea came to select the right one, marking the call so that only he got into the logs.  Well, or a few calls, but only to the number where this bug periodically happens.  The syslog was successfully replaced by a macro that compares the identifier in the session with the list of identifiers given by the operator.  The identifier was tied to both the unique address of the terminal and the dialed number.  In my ASP.Net application it was supposed to filter by userid.  Of course, here it may not be very justified, but since I decided that the logger needs this feature, then so be it. <br>  I found the second reason about studying the source code for NLog.  In it, almost all actions are performed in the context of the calling thread, asynchronously only the direct write to the target is performed.  That, as I later saw, causes considerable damage to performance. <br><br><h2>  Moving operations to a separate thread </h2><br>  I immediately encapsulated this operation into a separate class.  The class will start a stream in which all messages will be processed, and allow these messages to be sent to this thread.  The message will contain the text of the log, level, and other information.  It is necessary to solve the task - to minimize the number of actions in the context of the stream that sends logs. <br>  As a basis, I took the example of ThreadSync from Language Samples, which are included in Visual Studio.  First class interface: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ReceiveHandler&lt;T&gt;(T item); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueued</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> ReceiveHandler&lt;T&gt; OnReceive; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action OnTimeout; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Active { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T msg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Terminate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br>  The flag is set at the beginning of the internal method ThreadRun, and cleared at the end.  The OnReceive event occurs when a stream has received a new message.  The event delegate type is created to avoid casting the argument type.  The timeout is created in order to allow not to write directly to the disk, but first to the buffer, for example, in StringBuilder.  After the specified time after receiving the last message, the OnTimeout event will be triggered once so that the last log received is guaranteed to hit the disk. <br>  Option in class two, you can choose depending on any reasons.  One option starts its thread, but needs to call Terminate. <br><pre> <code class="cs hljs">thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(ThreadRun); thread.Start();</code> </pre><br>  The second class implementing the same interface adds its method to the standard ThreadPool.  It has its drawbacks, in particular, if the main application already uses not many threads from the pool, then this thread can be very late with the start.  One joy - it does not need to be terminated with a call to Terminate (), it will close itself by closing the application. <br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(ThreadRun);</code> </pre><br>  The designer accepts a ManualResetEvent as input, which can be fed to several classes that operate with streams, and then use it as a centralized application termination event.  In the logger, I did not use it, but just in case I added this feature.  In addition to the completion event, an event is also used for work, which means that a new message has entered the queue.  It looks like this <br><pre> <code class="cs hljs"> EventWaitHandle[] events = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventWaitHandle[<span class="hljs-number"><span class="hljs-number">2</span></span>]; ... events[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); events[<span class="hljs-number"><span class="hljs-number">1</span></span>] = terminateEvent ?? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  It is quite obvious that the task of the Terminate method is to set events [1] to one. <br>  To store the transmitted messages, I used the queue queue;  The Send () method is simply copied from an example: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (queSync) { queue.Enqueue(msg); } events[<span class="hljs-number"><span class="hljs-number">0</span></span>].Set();</code> </pre><br>  To receive messages on the other side, I decided to resort to a little trick to minimize the blocking time of the queue with a ‚Äúgathering‚Äù stream.  That is why lock is not made on the queue itself, but on a separately created object.  The receiving thread spins inside an infinite loop, the output of which will be produced if the index is equal to one, which means that events [1] triggered, either from the Terminate method or from the outside, as I said earlier. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((index = WaitHandle.WaitAny(events, currentTimeout)) != <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  The WaitAny method blocks the flow until one of the events triggers, or a timeout, by default equal to Infinite.  That is, the logger thread will sleep and does not affect the performance of the application until it starts sending logs.  When triggered, we first check to see if there was a timeout, and activate the corresponding event. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == WaitHandle.WaitTimeout) { OnTimeout(); currentTimeout= Timeout.Infinite; }</code> </pre><br>  The second line appeared here thanks to unit tests, when I encoded it, I missed it.  Further, otherwise, the messages from the queue must be retrieved, and with each of them, trigger the OnReceive event.  The ‚Äútrick‚Äù I mentioned earlier is visible in the code. <br><pre> <code class="cs hljs"> Queue&lt;T&gt; replacement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;T&gt;(); Queue&lt;T&gt; items; <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (queSync) { items = queue; queue = replacement; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (T t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { OnReceive(t); } currentTimeout = timeout;</code> </pre><br>  For all the critical moments of this class, or of a module, I‚Äôve walked, its code, like all the other classes, can be found in the repository, I‚Äôll hang a link at the end of the article and then I‚Äôd not repeat this disclaimer, <br>  Already at the time of writing, a crazy idea occurred to me to do the same using ConcurrentQueue, naturally without the above tricks, but completely without blocking.  And at the same time it is necessary to leave the possibility of creating both types of threads.  Therefore, it was decided to encapsulate the creation of a stream behind its interface, which I will call IStarter, each class will consist of a single method.  By the way, here it would be quite possible to use the lambda expression, but the esthete in me resisted this.  As a result, what should turn out to be similar to the well-known pattern bridge, where "on this side of the bridge" there are two classes, one with locks, the other with an interlock, and "on the other side of the bridge" two options for starting the flow for them, and they are used between be able to in any combination.  The whole charm of the ideology "to interact with the interface, and not with the implementation" (c) GoF here is expressed not only in the fact that the other classes interacting with the data will not have to be touched, but also in the fact that unit tests also do not need to be changed .  Quite quite.  It is only necessary to change the polymorphic method of creating specific objects, which feeds all the options to these tests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  TDD rudiments </h2><br>  Little poteoretiruyu on.  At first, using the example of the class that was first, and the second was the same, the development behavior failed to fail TDD, where the tests first, then the code itself.  The path of my development went through the following stages - writing working code, then writing test cases, then correcting both the first and second, bringing it to standard.  After that, the tests are ‚Äúrecognized as true,‚Äù and the refactoring, which follows later, may well rely on them.  Why do I think that this approach has the right to life, at least for a beginner: If we consider the simplest function A = B + C, then testing this function suggests the formula C1 = A - B, and then the conclusion of the success of the test based on comparison C == C1.  Errors here can be contained both in the tested function and in the testing one.  Moreover, since it has more actions, an error is more likely.  At this point, one may wonder why, then, testing is needed at all, but the answer is naturally already there, everything is formulated before us.  In order for the test to show ‚Äúpassed‚Äù, it is necessary that one of the conditions be fulfilled.  The absence of errors in both functions, or the simultaneous presence of an error there and there.  The probability that both errors will occur is less than the probability of each error separately, especially the presence itself is not enough, it is also necessary that the errors be synergistic, that is, compensate for each other's influence, the probability of which is even lower.  That is, all efforts to write tests are directly aimed at reducing the likelihood of errors.  However, when writing both tests and code by the same person, the probability that he will make the same error is somewhat higher.  Well, okay, as it seems to me, for a bicycle and what is is already good. <br>  Let's go over to writing the first tests.  To do this, first create a test pattern by clicking on the interface name IQueued with the right button and selecting the appropriate menu item.  So, what you need to test this class.  It is supposed to be tested in isolation, then it is necessary to make mocks (imitators) of classes that interact with the sabzhevy class.  Another point is that since the target of the test is the interface, and there were two specific classes to test, and later 4 combinations 2 to 2 became later, it makes sense to immediately reward the abstract modifier and add a generic parameter to it. <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestClass()</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IQueuedTest</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;</code> </pre><br>  Since the class is abstract, tests will not be performed directly on it, of course, they will not, instead all test classes inherited from it will be executed. <br>  First of all, we need a service class consumer simulator. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tester</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T1</span></span>&gt;</code> </pre><br>  This class will subscribe to the events of the class being tested, count the events triggering, and remember what came about in this event. <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tester</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueued&lt;T1&gt; tested</span></span></span><span class="hljs-function">)</span></span> { tested.OnReceive += Received; tested.OnTimeout += TimeOut; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TimeOut</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { timedCount++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Received</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T1 item</span></span></span><span class="hljs-function">)</span></span> { Thread.Sleep(delay); receivedCount++; lastItem = item; }</code> </pre><br>  In addition to this inner class, you will need methods to create specific objects that we oblige all heirs to override. <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> IQueued&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSubject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre><br>  So, actually to writing tests.  By the way, when reading such articles, I noticed that the authors omit the rake, and bring a ready-made solution.  I will try to stop on some rake a little more.  The first problem I encountered is the very delayed start in the thread pool.  When you start the application, the pool keeps only a few threads, and the new starts only with a delay, which is measured in tenths of a second.  A test framework seems to execute tests in parallel.  Because of this, tests with a ‚Äúmanual‚Äù flow were successful, and some passed with a flow from the pool, some fell.  Therefore, there are two options, select all the tests in the same "long" method, which will be executed faster, but will give only one general verdict, or come up with workarounds.  I came up with the following: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActivationTestHelper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tester&lt;T&gt; tester, IQueued&lt;T&gt; subject</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retry = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!subject.Active &amp;&amp; retry &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { retry--; Thread.Sleep(SleepDelay); } Assert.AreEqual(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, subject.Active); }</code> </pre><br>  30 attempts to "wait" until the stream is activated, after which only proceed to the test.  The helper will be called immediately after creation. <br>  And, once again - so, to writing tests.  The first test to send-receive messages.  Since we know that the task of the class is to transmit to another thread, we need to make sure that the tester class does not receive the message in the context of the transmitting stream, then make sure that it successfully receives after.  For this (for the first), by the way, in the code of the Received method, the tester has a delay of 50ms.  If this delay occurs in the calling thread, then the first Assert will fail the test. <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestMethod()</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = createSubject(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tester = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tester&lt;T&gt;(subject); ActivationTestHelper(tester, subject); T item = CreateItem(); tester.delay = SleepDelay; subject.Send(item); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, tester.receivedCount);</code> </pre><br>  Next, to make sure that the message is transmitted, we will wait 100ms and check the received.  In principle, these values ‚Äã‚Äãcan be reduced, as long as the second delay is greater than the first, but here, I think it is not fundamental.  Do not forget to complete the stream, to "give way" to the following tests. <br><pre> <code class="cs hljs"> Thread.Sleep(SleepDelay2); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>, tester.receivedCount); Assert.IsTrue(tester.lastItem.Equals(item)); subject.Terminate(); }</code> </pre><br>  Next, a timeout test.  Also create objects, execute activation helper.  Let's set a timeout and check that it was not called in the context of the calling thread, but was called after.  And only once. <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestMethod()</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TimeoutTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = createSubject(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tester = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tester&lt;T&gt;(subject); subject.setTimeout(SleepDelay); ActivationTestHelper(tester, subject); T item = CreateItem(); subject.Send(item); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, tester.timedCount); Thread.Sleep(SleepDelay3); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>, tester.timedCount); }</code> </pre><br>  For this test, a delay of 200ms is specified, four times the timeout value, and it was this test that caught my first mistake, an underprint, which I mentioned earlier.  This turned out to be pleasant and unit tests, that the absolute majority of errors does not reach not only ‚Äúproduction‚Äù, but even alpha trial.  These errors, of course, would have been detected there, but the work spent on writing tests would still have to be done for debugging.  It turned out a sort of time-management technique that moves a certain amount of work from the period when the emergency roll to the period of "lazy" development.  And this is all without even mentioning the invaluable help in refactoring, which I invented myself along the way. <br>  The remaining test is the completion of the stream.  We must make sure that the stream is stopped and nothing is transmitted.  Lowering the steps common to all tests, we get the following: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerminateTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... subject.Terminate(); subject.Send(item); Thread.Sleep(SleepDelay3); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, tester.receivedCount); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">0</span></span>, tester.timedCount); }</code> </pre><br>  There are only three tests in the interface, but there are two specific classes, two more options for starting the stream and beyond that, I decided to check separately how it works with classes and structures as a message to be passed.  For this purpose, 8 specific test classes are created, one of which I will give, and the number of specific test cases turns out to be 24. Test structure: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TestMessageStruct { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> message; <span class="hljs-comment"><span class="hljs-comment">//object reference field public int id; //value field }</span></span></code> </pre><br>  And actually a specific test class that tests the variant: blocking queue, normal flow, structure. <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestClass()</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IQueuedLockRegTest</span></span> : <span class="hljs-title"><span class="hljs-title">IQueuedTest</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TestMessageStruct</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IQueued&lt;TestMessageStruct&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSubject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LockQueued&lt;TestMessageStruct&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegularThreadStarter()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> TestMessageStruct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestMessageStruct(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); item.id = rnd.Next(); item.message = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"message {0}"</span></span>, item.id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } }</code> </pre><br>  It was specific test classes that created specific experimental objects and had to be redone in this connection, if you can call it that, refactoring.  And they had to double their number, but, as you can see, it takes significantly less time and effort than when writing and thinking about the tests themselves. <br><br><h2>  Logger interface and first filter layer </h2><br>  I decided to make the interface outward like in NLog, without further ado.  I just called the static class LogAccess, for some reason it seemed to me more logical in meaning.  He himself does nothing, only proxies calls.  For this reason, he does not participate in tests, therefore I will not dwell on it, I will only list the main methods visible "outside", the first method allows you to get the actual logger to spam messages, the next two control the filtering by level, the last by id.  The name, or category, of the logger, which is present in the first filtering layer, means that the execution of this filtering before passing through the class described in the previous section, that is, the level can be set separately for each category of logs.  The absence of a category on the second filtering layer, respectively, means that this filtering is already done behind, in the stream of the logger. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Logger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> category</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> category, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLevelForAll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterAddID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterRemoveID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  The second class, which is visible from the outside, is LogLevel.  The levels in the sense I took from the telecom.  Here I decided to simplify relative to NLog, and use the usual int as a level, so as not to subtilize with the comparison of levels, etc. <br>  He added only the All level to make two levels of debug, reduced and detailed, which sometimes was not enough in practice. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Invalid = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Always = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Fatal = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Error = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Warning = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Info = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Event = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Debug = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> All = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Total = <span class="hljs-number"><span class="hljs-number">9</span></span>;</code> </pre><br>  Also included in the class property Default, to set the level of LogAccess. <br>  Well, the most important thing that can be seen from the outside is the Logger interface.  I deliberately did not add the prefix I. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Logger</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Method for unrecoverable errors. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="message"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="ex"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> void Fatal(string message, Exception ex = null); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Method for external errors, such as user input or file access. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="message"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="id"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="ex"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> void Warning(string message, int id = 0, Exception ex = null); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Method for regular debug logging. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="message"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="id"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> void Debug(string message, int id = null); }</span></span></code> </pre><br>  Methods for errors are not tied to identifiers, only the levels of Warning and above. <br>  Next, consider the class of a specific logger to show.  in what way the minimization of the performance taken by the logger from the calling thread is achieved.  By the way, the logger interface has an extended version, not visible from the outside, which adds the SetLevel method. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CheckingLogger</span></span> : <span class="hljs-title"><span class="hljs-title">InternalLogger</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] levels = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[LogLevel.Total]; Sender send; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> category; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckingLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> category, Sender sender, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send = sender; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.category = category; SetLevel(level); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = LogLevel.Fatal; n &lt; LogLevel.Total; n++) { levels[n] = (n &lt;= level); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message, Exception ex = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (levels[LogLevel.Error]) { send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogItem(category, LogLevel.Error, message, ex: ex)); } }</code> </pre><br>  One spamming method is enough for consideration, it is clear that it checks the Boolean value from the array, and sends it via the Sender delegate.  The second variant of the logger, instead of the boolean array, uses the Sender array, the delegate to the empty method is inserted into the disabled level, and there is no check in the sending method, sending immediately.  According to the results of testing, the difference in performance is insignificant, perhaps testing on different platforms would give an answer.  Logger tests are fairly simple, it checks if the message is in Sender, when it should, and when it should not.  Here I also stumbled upon typos and copy-paste errors, since  many almost identical methods, the difference is not a cursory glance. <br>  I did not think of which section to enter the class, or rather the LogItem structure used for the actual transfer of the logs, I will give here, omitting the constructor, only the content.  From it, by the way, it is clear that the id for one message can be set to more than one, it is necessary either for Broadcast, or, in the case of a call, to indicate two identifiers: the caller and the answering call.  Methods in previous classes are duplicated for this purpose, only deprived of attention. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> LogItem { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> String category; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> String message; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] ids; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Exception ex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DateTime time; }</code> </pre><br><br><h2>  Dependency injection </h2><br>  In this section, I will give an example of using an IoC container.  The next class in question is the container of loggers.  The name with the IoC container is not related, just the same.  It provides the GetLogger method, where the method of the LogAccess class is proxied.  NLog, judging by the comments in the code, does not guarantee that the twice called GetLogger method with the same category will produce the same logger instance.  I thought and decided that this method would not be a bottleneck, and put a general synchronization on it, in this case the instance should be guaranteed the same.  The log container stores all previously created loggers and distributes SetLevel to them, also proxied from LogAccess. <br>  So, we create the IoC container, the further configuration is placed between the following two lines: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerBuilder(); IContainer container = builder.Build();</code> </pre><br>  From the above it is clear that the class should be singleton.  This is achieved quite simply: <br><pre> <code class="cs hljs"> builder .RegisterType&lt;LoggerContainer&gt;() .SingleInstance();</code> </pre><br>  And by the following method we can get a link to our singleton. <br><pre> <code class="cs hljs"> Container .Resolve&lt;LoggerContainer&gt;();</code> </pre><br>  So that the container of logs itself could use the services of the IoC container from which it was created, I added the IComponentContext parameter to it in the constructor.  This allows you to take out the creation of a class to the outside, and change specific classes, for example, to classes with enhanced functionality, without changing the code that uses it, but only by changing the configuration, which including  it is possible and not to set in the code in general, but to load from xml.  Actually, this replacement of the inner creation by the outer creation is called dependency injection.  Actually, the method that a particular logger receives from the context: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> InternalLogger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> category</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context .Resolve&lt;InternalLogger&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedParameter[]{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedParameter(<span class="hljs-string"><span class="hljs-string">"category"</span></span>, category), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedParameter(<span class="hljs-string"><span class="hljs-string">"level"</span></span>,LogLevel.Default) }); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, this example shows how to set specific class parameters for the constructor from the place of the call, and not in the container configuration, which in this case remains as simple as in the previous case. The only difference is that we do not have a singleton and the access point is the interface here, and not the class itself.</font></font><br><pre> <code class="cs hljs"> builder .RegisterType&lt;CheckingLogger&gt;() .As&lt;InternalLogger&gt;();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can see some negative, with which I don‚Äôt know how to continue, except to write in the comments to the interface which input parameters, by name and type, should be present in the constructor of a particular class. Difficult to diagnose errors, which in the ordinary case would be eliminated by the compiler, are just waiting to happen here. Changing the configuration of the container, you may not know about it, because for this you will need to search for references on the interface. Probably in this case it is better to use a ‚Äúclassic‚Äù factory. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, what gives the use of IoC: container during unit testing. For the test, you can and should create your own container:</font></font><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestClass()</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LoggerContainerTest</span></span> { IContainer testContainer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoggerContainerTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerBuilder(); builder .Register&lt;LoggerContainer&gt;((c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggerContainer(c.Resolve&lt;IComponentContext&gt;())); builder .RegisterType&lt;LoggerMock&gt;() .As&lt;InternalLogger&gt;(); testContainer = builder.Build(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is illustrated another feature that is in Autofac, it allows you to configure the good old new, which actually will be called when Resolve, which works, of course, much faster than reflection. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to bring a fragment of one of the test methods.</font></font><br><pre> <code class="cs hljs"> LoggerContainer lc= testContainer .Resolve&lt;LoggerContainer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger1 = lc.GetLogger(cat1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger2 = lc.GetLogger(cat2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger3 = lc.GetLogger(cat1); Assert.AreEqual(logger1, logger3); Assert.AreNotEqual(logger1, logger2);</code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moq Test Framework </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another useful technology that allows you to simplify the writing of tests. I will show its application on the example of the next class, which I called the log collector or LogCollector. It uses the same IQueued for decoupling with the sending streams, filters by the identifier, and the second dependency has a class that writes to the file and performs the rotation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not describe in detail how it works, everything is quite simple and obvious, I‚Äôll dwell in general on one more class, which, before writing to the file, constructs a line from LogItem. I decided to make it configurable, it has long been interesting to solve such a problem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration example NLog: layout = "$ {longdate} $ {uppercase: $ {level}} $ {message}". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And an example of my logger configuration is LogMessageFormat = \ d \ l \ m \ r \ n.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is displayed in exactly the same form, date, level, the message itself and the line break. Specifically customized output format, so you can directly compare performance. Also it was in this line that I made it possible to add an identifier, an exception with its setraise, and, well, literal lines between all these identifiers. The construction proceeds along a chain, each following constructor throws its own part of the message into the StringBuilder from the transmitted LogItem. The chain is built up once, when the master line is parsed.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main task of the class is quite simple, so I will not give the code that implements it, I‚Äôll dwell on filtering a bit. Since there is also a synchronization task, that is, a method call that adds or deletes an identifier comes from another thread. One way is to block the list, or HashSet, will have an impact on performance. I went a little different way, I also saw such an opportunity provided by the language a long time ago and wanted to find a use for it. The essence of the solution is to transfer an anonymous Action method via a non-blocking queue. filterQue = new ConcurrentQueue &lt;Action &lt;HashSet &gt;&gt; (); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The filtering method checks whether the queue is empty at every filtering attempt, which should work faster than capturing the monitor, and if it is not empty, it executes the received method in the context of the logger stream.</font></font><br><pre> <code class="cs hljs"> Action&lt;HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; refresh; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!filterQue.IsEmpty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filterQue.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> refresh) &amp;&amp; refresh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { refresh(filter); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The caller method, instead of referring directly to the network, puts the desired delegate in the queue. </font></font><br><pre> <code class="cs hljs"> filterQue.Enqueue((x)=&gt; { x.Add(id); });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returning to Moq - in the above classes, I created mocks myself, which requires a lot of additional code, and it can be inconvenient and ugly, especially when you need to test a single class method. </font><font style="vertical-align: inherit;">Moq allows you to automatically create a class that either implements the specified interface, or inherits the specified class with overriding all virtual methods. </font><font style="vertical-align: inherit;">Here you can immediately see the restriction - you can‚Äôt make a mock on a class with non-virtual methods. </font><font style="vertical-align: inherit;">But, as we were bequeathed to GoF, we need to program ‚Äúto the interface‚Äù, that is, preferably all classes should be equipped with this, which, in general, allows us to apply all the above-described techniques and technologies, apart from what facilitates and formalizes chtoli, development at all.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another nuance of working with Moq is when creating tests, in some cases the studio itself adds an attribute to the assembly that allows access to the internal classes from the test project assembly, sometimes you have to add it yourself, and for Moq to also have access to the classes and interfaces, which need to be simulated, it is necessary to add access for it. </font><font style="vertical-align: inherit;">To do this, you need to find the AssemblyInfo.cs file in the project and add or modify the line so that it looks like this:</font></font><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: System.Runtime.CompilerServices.InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LoggerTest"</span></span></span><span class="hljs-meta">), System.Runtime.CompilerServices.InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DynamicProxyGenAssembly2"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing to test is for the collector to transfer the received message to the class that creates the flow isolation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mock decided not to do the message itself, since it is only transmitted to and fro by this class, and does not contact it, does not call its methods, does not read its fields.</font></font><br><pre> <code class="cs hljs"> LogItem message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogItem(category, level, msg, ids, GetException()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> qThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IQueued&lt;LogItem&gt;&gt;(MockBehavior.Strict); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;ILogWriter&gt;(MockBehavior.Strict); qThread .Setup(s =&gt; s.Send(It.IsAny&lt;LogItem&gt;())); writer .Setup(s =&gt; s.GetTimeout()) .Returns(timeout); qThread .Setup(s =&gt; s.SetTimeout(It.IsAny&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;())); LogCollector target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogCollector(qThread.Object, writer.Object); qThread .Verify(s =&gt; s.SetTimeout(It.Is&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(a =&gt; a == timeout))); target.Send(message); qThread .Verify(s =&gt; s.Send(It.Is&lt;LogItem&gt;(i =&gt; i.Equals(message))), Times.Once()); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In case explanations are needed: the first two lines create dependency tutors. The Strict parameter means that the mock will throw an exception if classes have methods called that are not configured before use, thereby zacheliv test. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next call marks the Send method of IQueued mock, indicating that it will be called during the test. Here you can also specify preconditions, if there are several methods, then after the test all preconditions can be checked by calling VerifyAll (). I stopped at a detailed, redundant description of the test. The next line means that the GetTimeout method should be called, and also indicates the mock that it should return. The next line also marks the SetTimeout method.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we create a collector object, and feed its dependencies to it, after which we make sure that the collector called GetTimeout on one dependency and passed the value to another dependency. It was better to create a separate test method for testing the constructor, but I left it as it is, for no reason, spontaneously. Next, we send a message, and make sure that it was forwarded to the junction. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can already see that the test code is complete, and does not force you to watch additional files with manually declared mocks during a review or redesign, but it reduces potential time costs, which in itself is a good enough reason to use Moq.</font></font><br><br><h2>  Stress Testing </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I expected to see the superiority of my approach over NLog, I was ready to work on micro-optimizations, save a penny in order to meet expectations even a little better. </font><font style="vertical-align: inherit;">But the results of the first tests struck me, having beaten off such a desire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the load test, I created a console application in which I took a logger and sent messages to it in a cycle.</font></font><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> log = SharpLogger.LogAccess.GetLogger(<span class="hljs-string"><span class="hljs-string">"flooder "</span></span> + tid); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, messageCount)) { log.Info(<span class="hljs-string"><span class="hljs-string">"Message"</span></span>, x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x % <span class="hljs-number"><span class="hljs-number">1000</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) Thread.Sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the exact same method for nlog. </font></font><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> log = NLog.LogManager.GetLogger(<span class="hljs-string"><span class="hljs-string">"flooder "</span></span> + tid); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, messageCount)) { log.Info(<span class="hljs-string"><span class="hljs-string">"Message"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x % <span class="hljs-number"><span class="hljs-number">1000</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) Thread.Sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method shows a tid, which means that execution occurs in several threads. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, I did a lot of tests, but I think it‚Äôs quite enough to give one test. Three streams send 200 thousand messages each. In the screenshot of Task Manager CPU load. The first small burst is my logger, then, after 5 seconds of delay, the operation of NLog. The resulting log files are identical, except for mismatched time. </font></font><br><img src="http://habrastorage.org/storage2/f41/9e8/62f/f419e862f057773af5fc93d1c0243df1.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will also give the result of measurement by the test program itself, which speaks for itself. </font></font><br><img src="http://habrastorage.org/storage2/614/d24/ca1/614d24ca1b0d1c04482d0c05b198e555.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When recompiling under x64, the result almost does not change.</font></font><br><img src="http://habrastorage.org/storage2/a7e/2e8/3e8/a7e2e83e8612c3c402bcbf9f145a3e66.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, I need to mention one nuance - because I use an additional stream that does not use Nlog, and I measure only the processor time that the sending operation took away from the calling threads, and I bypass the processor load that this thread creates. I also decided to look at this by running a test already from 40 threads that send half a million messages.</font></font><br><img src="http://habrastorage.org/storage2/d1c/54a/543/d1c54a543b03bfe807a03de61bdff62c.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result that the program produced is 7.15 seconds., But the graph shows that the logger stream worked for about 25 seconds to write to the file. This is undoubtedly a drawback, since the program can be completed before the logger, before full recording, which is excluded in the case of NLog and, in addition, the thread will have one processor completely even when the load in the main program is already over. The comforting point here is that NLog with such a number of logs will kill the processor for six hours according to approximate estimates, which gives grounds to reconcile with the indicated disadvantage. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And one more thing that needs to be mentioned is the effect of a non-blocking queue on performance relative to a regular blocking queue.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did two tests, in the first 3 threads sent 15 million messages, the non-blocking queue reduced the measured time from 22.2 seconds to 17.8. </font><font style="vertical-align: inherit;">With an increase in the number of threads to 30, and while maintaining the total number of messages, that is, 1.5 million per flow, the blocking queue slowed down the test to 23.7 seconds, while the non-blocking, on the contrary, slightly accelerated to 17.4, increasing the gap. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see from the screenshots, the testing was done on 4x 4GHz nuclear, on windows 8. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project can be downloaded from the github via the link </font></font><a href="https://github.com/repinvv/SharpLogger"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/repinvv/SharpLogger</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Errors, typos and other comments - Wellcome.</font></font></div><p>Source: <a href="https://habr.com/ru/post/151641/">https://habr.com/ru/post/151641/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151635/index.html">Erasmus Mundus Scholarship for Higher Education in Europe</a></li>
<li><a href="../151637/index.html">Apple encodes video using JPEG, JSON and <canvas></a></li>
<li><a href="../151638/index.html">How Larry Laffer spoke in Russian or About the interpreters of the Sierra quests</a></li>
<li><a href="../151639/index.html">A simple but illustrative example of using TDD</a></li>
<li><a href="../151640/index.html">Stencil Buffer Implementation Example with CUDA</a></li>
<li><a href="../151643/index.html">Admission to the magistracy in Germany</a></li>
<li><a href="../151646/index.html">We raise our own Git GitBlit server on Openshift hosting</a></li>
<li><a href="../151647/index.html">Debugging Incomprehensible Errors in Magento</a></li>
<li><a href="../151650/index.html">7 obvious rules for secure system administration of physical servers</a></li>
<li><a href="../151651/index.html">How to replace the headset? Stylish Headphones Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>