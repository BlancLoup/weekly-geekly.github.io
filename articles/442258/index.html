<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web scraping for web developers: a brief summary</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Knowing only one approach to web scraping solves the problem in the short term, but all methods have their strengths and weaknesses. Awareness of this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web scraping for web developers: a brief summary</h1><div class="post__text post__text-html js-mediator-article">  Knowing only one approach to web scraping solves the problem in the short term, but all methods have their strengths and weaknesses.  Awareness of this saves time and helps to solve the problem more effectively. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/b97/2ea/063b972eae7ba278cd3b26851d97fe24.jpg" alt="image"><br><br>  Numerous resources tell about the only correct method of extracting data from a web page.  But the reality is that for this you can use several solutions and tools. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  What are the options for software extraction from a web page? </li><li>  Pros and cons of each approach? </li><li>  How to use cloud resources to increase the degree of automation? </li></ul><br>  The article will help get answers to these questions. <br><a name="habracut"></a><br>  I assume that you already know what <b>HTTP</b> requests are, <b>DOM</b> (Document Object Model), <b>HTML</b> , <b>CSS selectors,</b> and <b>Async JavaScript</b> . <br><br>  If not, I advise you to delve into the theory, and then return to the article. <br><br><h3>  Static content </h3><br>  <b>HTML sources</b> <br><br>  Let's start with the simplest approach. <br><br>  If you are planning to scrap web pages, this is the first place to start.  It takes a little computer power and a minimum of time. <br><cut></cut><br>  However, this only works if the source HTML code contains data that you are targeting.  To check this out in Chrome, right-click the page and select View Page Code.  You should now see the HTML source code. <br><br>  Once you find the data, write a <a href="https://www.w3schools.com/cssref/css_selectors.asp">CSS selector</a> that belongs to the wrapping element so that you later have a link. <br><br>  For implementation, you can send an HTTP GET request to the URL of the page and get back the HTML source code. <br><br>  In <b>Node,</b> you can use the <a href="https://github.com/cheeriojs/cheerio">CheerioJS</a> tool to <a href="https://github.com/cheeriojs/cheerio">parse</a> raw HTML and extract data using a selector.  The code will look like this: <br><cut></cut><br><pre><code class="plaintext hljs">const fetch = require('node-fetch'); const cheerio = require('cheerio'); const url = 'https://example.com/'; const selector = '.example'; fetch(url) .then(res =&gt; res.text()) .then(html =&gt; { const $ = cheerio.load(html); const data = $(selector); console.log(data.text()); });</code> </pre> <br><h3>  Dynamic content </h3><br>  In many cases, you cannot access information from raw HTML code, because the DOM was driven by javascript, which runs in the background.  A typical example of this is the SPA (one-page application), where the HTML document contains the minimum amount of information, and JavaScript fills it at run time. <br><br>  In this situation, the solution is to create a DOM and execute the scripts located in the HTML source code, as the browser does.  After that, data can be extracted from this object using selectors. <br><cut></cut><br>  <b>Headless browsers</b> <br><br>  A headless browser is the same as a regular browser, but without a user interface.  It runs in the background, and you can control it programmatically instead of clicking and typing from the keyboard. <br><br>  <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer is</a> one of the most popular headless browsers.  It is an easy-to-use Node library that provides high-level APIs for managing Chrome offline.  It can be configured to run without a title, which is very convenient when developing.  The following code does the same thing as before, but it will work with dynamic pages: <br><br><pre> <code class="plaintext hljs">const puppeteer = require('puppeteer'); async function getData(url, selector){ const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); const data = await page.evaluate(selector =&gt; { return document.querySelector(selector).innerText; }, selector); await browser.close(); return data; } const url = 'https://example.com'; const selector = '.example'; getData(url,selector) .then(result =&gt; console.log(result));</code> </pre> <br>  Of course, you can do more interesting things with Puppeteer, so you should see the <a href="https://pptr.dev/">documentation</a> .  Here is a snippet of code that navigates through the URL, takes a screenshot and saves it: <br><br><pre> <code class="plaintext hljs">const puppeteer = require('puppeteer'); async function takeScreenshot(url,path){ const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); await page.screenshot({path: path}); await browser.close(); } const url = 'https://example.com'; const path = 'example.png'; takeScreenshot(url, path);</code> </pre> <br>  The browser requires much more processing power than sending a simple GET request and analyzing the response.  Therefore, the implementation is relatively slow.  Not only that, but also adding a browser as a dependency makes the package massive. <br><cut></cut><br>  On the other hand, this method is very flexible.  You can use it to navigate through the pages, simulate clicks, mouse movements and use the keyboard, fill out forms, create screenshots or create PDF pages, execute commands in the console, select items to extract text content.  Basically, everything that can be done manually in the browser. <br><br>  <b>Building a dom</b> <br><br>  You will think that it is unnecessary to model an entire browser just to create a DOM.  In fact, this is the case, at least under certain circumstances. <br><br>  <a href="https://github.com/jsdom/jsdom">Jsdom</a> is a Node library that analyzes HTML passed in as the browser does.  However, this is not a browser, but a <i>tool for building DOM from a given HTML source code</i> , as well as for executing JavaScript code in this HTML. <br><br>  Thanks to this abstraction, Jsdom can run faster than a headless browser.  If it's faster, why not use it instead of headless browsers all the time? <br><cut></cut><br>  <i>Quote from the documentation</i> : <br><blockquote>  People often have problems with asynchronous script loading when using jsdom.  Many pages load scripts asynchronously, but it is impossible to determine when this happened, and, therefore, when to run the code and check the resulting DOM structure.  This is a fundamental limitation. </blockquote><br>  This solution is shown in the example.  Every 100 ms, it is checked if an element has appeared or a timeout has occurred (after 2 seconds). <br><br>  It also often generates error messages when Jsdom does not implement certain browser functions on the page, such as: ‚Äú <i>Error: Not implemented: window.alert ...‚Äù or ‚ÄúError: Not implemented: window.scrollTo ...</i> ‚Äù.  This problem can also be solved with the help of some workarounds ( <a href="https://github.com/jsdom/jsdom">virtual consoles</a> ). <br><br>  As a rule, this is a lower level API than Puppeteer, so you need to implement some things yourself. <br><br>  This makes it a bit more difficult to use, as you can see from the example.  <i>Jsdom</i> for the same job offers a quick fix. <br><cut></cut><br>  Let's look at the same example, but using <i>Jsdom</i> : <br><br><pre> <code class="plaintext hljs">const jsdom = require("jsdom"); const { JSDOM } = jsdom; async function getData(url,selector,timeout) { const virtualConsole = new jsdom.VirtualConsole(); virtualConsole.sendTo(console, { omitJSDOMErrors: true }); const dom = await JSDOM.fromURL(url, { runScripts: "dangerously", resources: "usable", virtualConsole }); const data = await new Promise((res,rej)=&gt;{ const started = Date.now(); const timer = setInterval(() =&gt; { const element = dom.window.document.querySelector(selector) if (element) { res(element.textContent); clearInterval(timer); } else if(Date.now()-started &gt; timeout){ rej("Timed out"); clearInterval(timer); } }, 100); }); dom.window.close(); return data; } const url = "https://example.com/"; const selector = ".example"; getData(url,selector,2000).then(result =&gt; console.log(result));</code> </pre> <br>  <b>Reverse engineering</b> <br><br>  Jsdom is a quick and easy solution, but you can make everything even easier. <br><br>  Do we need to simulate DOM? <br><cut></cut><br>  The webpage you want to scrap is made up of the same HTML and JavaScript, the same technologies that you already know.  Thus, <i>if you find a piece of code from which target data were obtained, you can repeat the same operation to get the same result</i> . <br><br>  If you simplify everything, the data you are looking for may be: <br><br><ul><li>  part of the source HTML code (as seen from the first part of the article), </li><li>  part of a static file that is referenced in an HTML document (for example, a line in a javascript file), </li><li>  responding to a network request (for example, some JavaScript code sent an AJAX request to a server that responded with a JSON string). </li></ul><br>  <i>These data sources can be accessed via network requests</i> .  It doesn't matter if the web page uses HTTP, WebSockets, or some other communication protocol, because they are all replicable in theory. <br><br>  Having found a resource containing data, you can send a similar network request to the same server as the original page.  As a result, you will receive a response containing target data that can be easily retrieved using regular expressions, string methods, JSON.parse, etc. <br><cut></cut><br>  In simple words, you can take the resource where the data is located, instead of processing and loading all the material.  Thus, the problem shown in the previous examples can be solved with a single HTTP request instead of controlling the browser or a complex JavaScript object. <br><br>  This solution seems simple in theory, but in most cases it can be time consuming and requires experience with web pages and servers. <br><br>  Start by monitoring your network traffic.  A great tool for this is the <a href="https://developers.google.com/web/tools/chrome-devtools/network/">Network</a> tab <a href="https://developers.google.com/web/tools/chrome-devtools/network/">in Chrome DevTools</a> .  You will see all outgoing requests with responses (including static files, AJAX requests, etc.) to iterate and search for data. <br><br>  If the answer is changed by some code before being displayed on the screen, the process will be slower.  In this case, you should find this part of the code and understand what is happening. <br><br>  As you can see, this method may require much more work than the methods described above.  On the other hand, it provides the best performance. <br><br>  The diagram shows the required runtime and package size compared to Jsdom and Puppeteer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90f/d44/8a2/90fd448a2eff0e71b2980b20b1ef0936.jpg" alt="image"><br><br>  The results are not based on accurate measurements and can vary, but show well the approximate difference between these methods. <br><br><h3>  Cloud Integration </h3><br>  Suppose you have implemented one of these solutions.  One way to run the script is to turn on the computer, open the terminal and start it manually. <br><br>  But it will become annoying and inefficient, so it‚Äôs better if you could just upload the script to the server, and it would execute the code regularly, depending on the settings. <br><cut></cut><br>  This can be done by running the actual server and setting the rules for when to run the script.  In other cases, the cloud function is a simpler way. <br><br>  Cloud functions are repositories designed to execute loaded code when an event occurs.  This means that you do not need to manage the servers, this is done automatically by your cloud provider. <br><br>  A trigger can be a schedule, a network request and many other events.  You can save the collected data in a database, write it to the <a href="https://developers.google.com/sheets/api/">Google sheet</a> or send it by <a href="https://www.w3schools.com/nodejs/nodejs_email.asp">email</a> .  It all depends on your imagination. <br><br>  Popular cloud providers are <a href="https://aws.amazon.com/ru/">Amazon Web Services</a> (AWS), <a href="https://cloud.google.com/">Google Cloud Platform</a> (GCP) and <a href="https://azure.microsoft.com/ru-ru/">Microsoft Azure</a> : <br><br><ul><li>  <a href="https://aws.amazon.com/ru/lambda/">AWS Lambda</a> </li><li>  <a href="https://cloud.google.com/functions/">GCP Cloud Functions</a> </li><li>  <a href="https://azure.microsoft.com/ru-ru/services/functions/">Azure functions</a> </li></ul><br>  You can use these services for free, but not for long. <br><br>  If you use Puppeteer, <i>Google‚Äôs</i> cloud <i>functions</i> are the easiest solution.  The package size in the Headless Chrome format (~ 130 MB) exceeds the maximum allowed archive size in AWS Lambda (50 MB).  There are several methods to get it to work with Lambda, but the default GCP features <a href="https://cloud.google.com/blog/products/gcp/introducing-headless-chrome-support-in-cloud-functions-and-app-engine">support Chrome without a header</a> , you just need to enable Puppeteer as a dependency in <i>package.json</i> . <br><br>  If you want to learn more about cloud functions in general, check out the architecture information without servers.  Many good manuals have already been written on this topic, and most providers have easy-to-understand documentation. </div><p>Source: <a href="https://habr.com/ru/post/442258/">https://habr.com/ru/post/442258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442244/index.html">Rust 1.33 release</a></li>
<li><a href="../442248/index.html">NASA gave the go-ahead to the Dragon-2 unmanned test launch</a></li>
<li><a href="../442250/index.html">React and Vue: Strengths</a></li>
<li><a href="../442252/index.html">Python code life cycle - CPython execution model</a></li>
<li><a href="../442256/index.html">Digital defense from the plastic world of domestic Internet regulators</a></li>
<li><a href="../442260/index.html">10 Git Commands A Developer Should Know</a></li>
<li><a href="../442266/index.html">Delta Chat - decentralized messenger on top of email</a></li>
<li><a href="../442268/index.html">AsyncIO Micropython: Synchronization Methods in Asynchronous Programming</a></li>
<li><a href="../442270/index.html">5 mistakes to avoid when creating 3D models for 3D printing</a></li>
<li><a href="../442272/index.html">Go + = package version control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>