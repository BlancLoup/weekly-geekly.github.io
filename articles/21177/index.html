<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>offsetHeight or unintentional avalanche reflow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The note by Vladimir Tokmakov states: 
 The HTML element in the document can be hidden using JavaScript or the CSS display property. The logic embedde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>offsetHeight or unintentional avalanche reflow</h1><div class="post__text post__text-html js-mediator-article">  The <a href="http://www.artlebedev.ru/tools/technogrette/js/is_display_none/">note by</a> Vladimir Tokmakov states: <br><blockquote>  The HTML element in the document can be hidden using JavaScript or the CSS display property.  The logic embedded in CSS is difficult and unnecessary to reproduce in JavaScript.  It's easier to query the offsetHeight object (if 0 = the item is hidden). </blockquote><br>  Easier, of course, simpler, but what is the price? <br><br><a name="habracut"></a><br><br>  To check the visibility of an element, it is customary to check the <code>display</code> style value or the presence of a <code>hide</code> class.  When we write the function of hiding / displaying ourselves, we know which value of the default <code>display</code> style of the object, or which class corresponds to which state.  However, the universal (library) function cannot be aware of this. <br>  Let's test the speed of calculating the values ‚Äã‚Äãof <code>offsetHeight</code> and <code>style.display</code> . <br>  For the convenience of profiling, we will move access to these values ‚Äã‚Äãinto separate functions: <br><pre> function fnOffset (el)
 {
 return !! el.offsetHeight;
 }<font></font>
<font></font>
 function fnStyle (el)
 {
 return el.style.display == 'none';
 }
</pre><br>  Where <code>el</code> is a test container. <br>  After testing a thousand iterations, we see that access to <code>offsetHeight</code> only two times slower than to <code>style.display</code> . <br>  Now let's complicate the test - at each iteration we will add a <code>SPAN</code> element to the test container. <br>  Profiling results: <br><img src="http://paul.dovbush.googlepages.com/test0-offset-profile.gif" alt="profile results" width="564" height="161"><br>  Now the relationship between the test is completely different.  Why did this happen?  Let's check the time it takes to add thousands of elements, without calling the test functions ‚Äî the "clean" test.  We will conduct testing in all browsers, measuring the time in the following way: <br><pre> var time_start = new Date (). getTime ();
 / * ... test ... * /
 var time_stop = new Date (). getTime ();
 var time_taken = time_stop-time_start;
</pre><br>  Where <code>time_taken</code> is the time spent per test, in milliseconds. <br>  Test data is given in milliseconds and the average is taken for 5 runs: <br><img src="http://paul.dovbush.googlepages.com/test1-display.gif" alt="test results" width="523" height="122"><br>  Judging by the test results, access to <code>offsetHeight</code> is 50-150 times slower. <br>  It turns out that in terms of length and <code>offsetHeight</code> and adding elements works quickly, and together - very slowly.  How so? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Why such a gap between the test? <br>  A bit of theory. </h2><br><br>  <strong>Reflow</strong> is the process of recursively traversing a branch of a DOM tree that calculates the geometry of the elements and their position relative to the parent.  The beginning of the traversal is a changed element, but it is also possible to spread from the bottom up.  There are the following types of reflow: <br><ul><li>  the initial is the first mapping of the tree; </li><li>  incremental - occurs when changes in the DOM; </li><li>  resizing; </li><li>  style change; </li><li>  "dirty" - the union of several incremental reflow having a common parent. </li></ul><br>  Reflow are divided into <em>urgent</em> (resizing windows or changing the font of the document) and <em>asynchronous</em> , which can be postponed and merged later. <br>  When manipulating DOM, incremental reflows occur, which the browser defers until the end of the script.  However, based on the definition of a reflow, the ‚Äúmeasurement‚Äù of the element will force the browser to perform deferred reflow.  it is possible to propagate from bottom to top, all reflow is performed, even if the element being measured belongs to the unchanged branch. <br>  Reflow is very resource intensive and is one of the reasons for slowing down web applications. <br><br>  Judging by the test "clean", all browsers do a good job with caching numerous reflow.  However, by requesting <code>offsetHeight</code> , we "measure" the element, which causes the browser to perform deferred reflow.  Thus, the browser does a thousand reflow in one case and only one in the other. <br>  <strong>Note:</strong> Opera's reflow also runs on a timer, which, however, does not prevent it from passing the test faster than other browsers.  Due to this, the course of the tests is visible in the Opera - the added stars appear.  Such behavior is justified, since  causes the user to feel a faster browser speed. <br><br>  Summarize.  What did the testing show?  At least, it is incorrect to compare the universal ( <code>offsetHeight</code> ) and private ( <code>style.display</code> ) cases.  Testing has shown that you have to pay for universality. <br>  And if you still want versatility, then you can offer another approach - the definition of Computed Style - the final style of the element (after all the CSS transformations). <br><pre> getStyle = function ()
 {
 var view = document.defaultView;<font></font>
<font></font>
 if (view &amp;&amp; view.getComputedStyle)
 return function getStyle (el, property)
 {
 return view.getComputedStyle (el, null) [property] ||  el.style [property];
 };<font></font>
<font></font>
 return function getStyle (el, property)
 {
 return el.currentStyle &amp;&amp; el.currentStyle [property] ||  el.style [property];
 };
 } ();
</pre><br>  We will test this method and put all the results in a table. <br><img src="http://paul.dovbush.googlepages.com/test2-getStyle.gif" alt="test results 2" width="523" height="103"><br><br>  In IE and FF, the computed style is calculated as quickly as the style of the element itself, and in Opera and Safari even a slightly longer <code>offsetHeight</code> .  The cited article clearly states that the call to <code>getComputedStyle</code> also causes reflow, and the reasons for the lack of this in IE and FF are not clear, although they are encouraging.  <strong>UPD:</strong> early rejoiced;) Thanks to <a href="https://habrahabr.ru/users/aks/" class="user_link">AKS</a> for pointing out that <code>getComputedStyle</code> in IE and FF returns incorrect results. <br>  When searching the Internet for ways to optimize computed style calculations for Opera and Safari, the article <a href="http://erik.eae.net/archives/2007/07/27/18.54.15/">Computed vs Cascaded Style</a> was found, in which Erik Arvidsson recommends not using such universal functions ( <code>getStyle</code> is in almost every js library), and implement the necessary functionality in each case .  After all, if we agree that the hidden elements must have a <code>hide</code> class, then everything will be reduced to determining whether the element or its parents have this class. <br><br><br><br><h2>  Optimization: class definition hide </h2><br>  Let's take a closer look at the solution I proposed.  I suggest the following implementation: <br><pre> function isHidden (el)
 {
 var p = el;
 var b = document.body;
 var re = / (^ | \ s) hide ($ | \ s) /;
 while (p &amp;&amp; p! = b &amp;&amp;! re.test (p.className))
 p = p.parentNode;
 return !! p &amp;&amp; p! = b;
 }
</pre><br>  It is assumed that it does not make sense to hide the root elements of the DOM and therefore checks are carried out only until <code>document.body</code> . <br>  The proposed solution will obviously not lower the reflow avalanche.  no calculations and measurements are carried out.  However, the traverse to the root of the document is a little confusing: what happens if the elements are nested?  Let's check.  The isHidden test is performed for nesting 2 ( <code>document.body / test_div</code> ).  And the isHidden2 test for nesting is 10 ( <code>document.body / div * 8 / test_div</code> ). <br><img src="http://paul.dovbush.googlepages.com/test3-hide.gif" alt="test results 3" width="523" height="157"><br>  As the tests show, even with a large nesting speed drop is small.  Thus, we got a universal solution that is 30-100 times faster to access offsetHeight. <br>  This article is intended not so much to solve the problem of determining the visibility of an element in the general case, but rather to explain one of the most frequently encountered bottlenecks of interaction with DOM and a detailed analysis of optimization methods.  During the tests, I deliberately reproduced the worst case.  In real situations, such an increase in speed will be obtained only when used in animation.  However, understanding the reasons and the reflow mechanism will allow writing more optimal code. <br><br>  References: <br><ul><li>  <a href="http://www.artlebedev.ru/tools/technogrette/js/is_display_none/">Note by</a> Vladimir Tokmakov, which was the reason for writing this article. </li><li>  Article <a href="http://dev.opera.com/articles/view/efficient-javascript/%3Fpage%3D3">Efficient JavaScript</a> , which describes how to optimize JavaScript, and in particular how to minimize the amount of reflow. </li><li>  Article <a href="http://www.mozilla.org/newlayout/doc/reflow.html">Notes on HTML reflow</a> , which describes the nuances of the implementation of reflow in Gecko. </li><li>  Article <a href="http://erik.eae.net/archives/2007/07/27/18.54.15/">Computed vs Cascaded Style</a> which addresses the shortcomings of getStyle functions </li></ul><br>  Tests: <a href="http://paul.dovbush.googlepages.com/test-offset-speed.htm">for all browsers</a> , <a href="http://paul.dovbush.googlepages.com/test-offset-speed.profile.htm">for profiling in FireBug</a> . <br>  Ps.  Thanks to <a href="https://habrahabr.ru/users/aks/" class="user_link">AKS</a> for the comments that made me more clearly define the definition of reflow. </div><p>Source: <a href="https://habr.com/ru/post/21177/">https://habr.com/ru/post/21177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../21176/index.html">The action "Gather your friends and get a notebook" is completed!</a></li>
<li><a href="../211761/index.html">New buttons and a single payment solution Yandex.Money: two free seminars in Moscow</a></li>
<li><a href="../211763/index.html">IT certification from an employer's perspective</a></li>
<li><a href="../211765/index.html">The first version of the Cppcheck integration module in Visual Studio with open source has been released.</a></li>
<li><a href="../211767/index.html">What bread crumbs do online stores need (68% of websites make mistakes)?</a></li>
<li><a href="../211771/index.html">Athletes in Sochi allowed to use Apple devices</a></li>
<li><a href="../211773/index.html">Image search by fragment</a></li>
<li><a href="../211775/index.html">Rating hubs and companies by posts / subscribers</a></li>
<li><a href="../211777/index.html">Personalization: debunking myths</a></li>
<li><a href="../211779/index.html">Open Terminal Client - some history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>