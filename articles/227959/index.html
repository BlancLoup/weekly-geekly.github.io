<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to PostgreSQL BDR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction to PostgreSQL BDR 

 PostgreSQL is not only a stable and reliable database, but plus to all it is a dynamically developing product, in wh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to PostgreSQL BDR</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction to PostgreSQL BDR </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/025/cd1/ddc/025cd1ddcfe0fdd580cd717dd09a708a.jpg" align="right" alt="image"><br>  PostgreSQL is not only a stable and reliable database, but plus to all it is a dynamically developing product, in which a variety of breakthrough things emerge from release to release.  At one time, one of these technologies was streaming replication.  This is a high-performance replication that makes it very easy and cheap to scale a database for reading.  Using it you can create reliable configurations by distributing the load on the reading between nodes.  However, as I wrote above, the product is developing, and today the article will deal with the new technology BDR (Bi-Directional Replication). <br><a name="habracut"></a><br>  Some terms for those who are not in the subject: <br>  <b>WAL (Write Ahead Log)</b> is a transaction log, the built-in stream replication is based on it in a postgres, the DBMS writes there everything that happens to the data in the database. <br>  <b>SR (Streaming Replication)</b> is a generic name for embedded streaming replication that is based on WAL, everything written in WAL, then sent to slaves and played back.  There are physical and logical stream replication. <br>  <b>PLSR (Physical Log Streaming Replication)</b> - physical stream replication (something that is already implemented and working), everything that got into WAL without subsequent parsing is replicated to the server slave, this is both a change in data / schema and lower-level things (full page writes, vacuum, hint bit settings). <br>  <b>LLSR (Logical Log Streaming Replication)</b> - logical stream replication (will appear in 9.4) is also based on WAL logs, but more intelligent and only a certain part of the logs are extracted for replication, which describe changes in the database schema and data (that is, some low-level things are eliminated) . <br><br>  What is the term BDR? <br>  <b>BDR (Bi-Directional Replication)</b> is a new functionality added to the PostgreSQL core that provides advanced replication tools.  At the moment it is implemented in the form of a small patch and module.  It is declared that it will only be fully in PostgreSQL 9.5 (now 9.3-stable and 9.4-beta1). <br><br>  In short, the BDR allows you to create geographically distributed asynchronous multi-master configurations (oh yeah, baby) using the built-in logical stream replication LLSR. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, BDR is not a clustering tool;  there are no global lock managers or transaction coordinators (hi <a href="http://www.thislinux.org/2013/03/postgres-xc.html">Postgres-XC</a> / XL).  Each node is independent of the others, which would be impossible if lock managers were used.  Each node contains a local copy of the data identical to the data on the other nodes.  Requests are also performed only locally (to make it clearer, I'll compare with Postgres-XC / Postgres-XL, where all servers work as if in one team, transactions are controlled by the global transaction manager, and requests from the application go to the coordinator (s) ) which sends executed requests to any work node, here).  Moreover, each of the nodes is internally consistent at all times, the entire server group is eventually ( <a href="http://habrahabr.ru/post/100891/">consistently consistent</a> ). <br><br>  The uniqueness of BDR lies in the fact that it is unlike neither the built-in stream replication nor the existing trigger-based solutions (Londiste, Slony, Bucardo). <br><br>  The most notable difference from stream replication is that BDR (LLSR) operates with databases (per-database replication), and classic PLSR replicates the entire instance (per-cluster replication), i.e.  all bases inside the instance. <br><br>  Existing restrictions and features: <br>  1. All data changes caused by INSERT / DELETE / UPDATE are replicated (TRUNCATE at the time of this writing has not yet been implemented) <br>  2. Most schema change (DDL) operations are replicated successfully.  Unsupported DDLs are fixed by the replication module and are rejected with an error (at the time of writing, the article CREATE TABLE‚Ä¶ AS was not working) <br>  3. Definitions of tables, types, extensions, etc.  must be identical between upstream and downstream masters. <br>  4. Actions that are reflected in WAL, but not represented as logical changes are not replicated to another node (writing full pages, vacuuming tables, etc.).  Thus, logical stream replication (LLSR) is free from some of the overhead that is present in physical PLSR streaming replication (nevertheless, this does not mean that LLSR requires less network bandwidth than for PLSR). <br><br>  So perhaps enough theory, a little practice.  Already now there is an opportunity to test Bi-Directional replication. <br><br>  Installation is performed on two virtual machines with CentOS 6.5 minimal.  Install the necessary packages for the assembly: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># yum install readline-devel zlib-devel yum-utils -y # yum groupinstall "Development Tools" -y</span></span></code> </pre> <br><br>  Go to the postgres account and install postgresql with BDR support.  It is worth noting here that the guys from 2ndQuadrant wrote an installer so that those who would like to try would not make much effort to install and configure, for which they are a bunch of greens. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># su - postgres $ curl -s "http://git.postgresql.org/gitweb/?p=2ndquadrant_bdr.git;a=blob_plain;f=contrib/bdr/scripts/bdr_quickstart.sh;hb=refs/heads/bdr-next" | bash</span></span></code> </pre><br><br>  Add the directory with the postgres executables to the PATH environment variable and immediately check for <i>psql</i> .  Who does not know, the <i>export</i> command is one-time, so if you plan to use or play with BDR for a long time, then add this command to.  Your user's <i>bashrc</i> (if you have <i>bash of</i> course). <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/2ndquadrant_bdr/bdr/bin:<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span> $ psql --version psql (PostgreSQL) 9.4beta1_bdr0601</code> </pre><br><br>  We initialize the database directories on both nodes and then immediately start.  It is not necessary to edit <i>postgresql.conf</i> beforehand, at the first start we will create a test database which will be replicated in the future. <br><br><pre> <code class="bash hljs">$ initdb -D data/ -A trust -U postgres $ pg_ctl -l logfile -D data/ -w start $ psql -c <span class="hljs-string"><span class="hljs-string">'create database staging_db'</span></span></code> </pre><br><br>  We created a database, and then proceed to configure postgresql.conf.  First we set up an upstream wizard.  In the configuration below, we specify the need to load the bdr library ( <i>shared_preload_libraries</i> ), determine the level of WAL logs to logical ( <i>wal_level</i> ), determine the number of slots for replication, the maximum number of processes involved in sending WAL logs ( <i>wal_senders</i> ), and <i>enable</i> time tracking for the operation COMMIT what is needed to resolve conflicts (last-UPDATE-wins).  Then at the end of the file we define the configuration for the BDR: we specify the name of the connection and the settings for connecting to the remote node.  It is worth noting that the name specified in <i>bdr.connections</i> is arbitrary (I have this virtual machine name), the main thing is that the specified name should participate in the names of the underlying parameters. <br><br><pre> <code class="bash hljs">$ vi data/postgresql.conf listen_address = <span class="hljs-string"><span class="hljs-string">'*'</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'bdr'</span></span> wal_level = logical wal_senders = 4 max_replication_slots = 4 track_commit_timestamp = on bdr.connections = <span class="hljs-string"><span class="hljs-string">'vm13'</span></span> bdr.vm13_dsn = <span class="hljs-string"><span class="hljs-string">'host=192.168.122.13 port=5432 user=postgres dbname=staging_db'</span></span></code> </pre><br><br>  Now configuration downstream wizard.  First, I give a description of the configuration and then its analysis below. <br><br><pre> <code class="bash hljs">$ vi data/postgresql.conf listen_address = <span class="hljs-string"><span class="hljs-string">'*'</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'bdr'</span></span> wal_level = logical wal_senders = 4 max_replication_slots = 4 track_commit_timestamp = on bdr.connections = <span class="hljs-string"><span class="hljs-string">'vm12'</span></span> bdr.vm12_dsn = <span class="hljs-string"><span class="hljs-string">'host=192.168.122.12 port=5432 user=postgres dbname=staging_db'</span></span> bdr.vm12_init_replica = on bdr.vm12_replica_local_dsn = <span class="hljs-string"><span class="hljs-string">'host=127.0.0.1 port=5432 user=postgres dbname=staging_db'</span></span></code> </pre><br><br>  Configuring the second node differs little, in particular here in the BDR configuration we indicate the need to perform initialization of the replica ( <i>bdr.vm12_init_replica</i> ) from the node specified in <i>bdr.vm12_dsn</i> to the local database whose details are specified in <i>bdr.vm12_replica_local_dsn</i> .  The last parameter is required if the database cluster is initialized using <i>initdb</i> (just our case) and in this case there should be an empty database in the cluster that will later participate in replication. <br><br>  In the case of initialization via <i>pg_basebackup, the</i> option bdr.vm12_replica_local_dsn is not needed. <br><br>  Now we define the authentication settings on both nodes, in my case everything is allowed.  For production installations, of course, you can't do that. <br><br><pre> <code class="bash hljs">$ vi data/pg_hba.conf host all all 192.168.122.0/24 trust host replication postgres 192.168.122.0/24 trust</code> </pre><br>  We restart both nodes and look at the logs. <br><pre> <code class="bash hljs">$ pg_ctl -l logfile -D data/ -w restart</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">upstream master:</b> <div class="spoiler_text">  vm12 ~ $ tail -f logfile <br>  LOG: unexpected EOF on standby connection <br>  LOG: starting logical decoding for slot bdr_16384_6029905891437956874_1_16384__ <br>  DETAIL: streaming transactions committing after 0 / 1898F90, reading WAL from 0 / 1898C30 <br>  LOG: logical decoding found point point at 0 / 1898C30 <br>  DETAIL: running xacts with xcnt == 0 <br>  LOG: starting background worker process "bdr (6029905879776466735,1,16384,): vm13: apply" <br></div></div><br><div class="spoiler">  <b class="spoiler_title">downstream master:</b> <div class="spoiler_text">  vm13 ~ $ tail -f logfile <br>  LOG: registering background worker "bdr (6029905891437956874,1,16384,): vm12: apply" <br>  LOG: starting background worker process "bdr (6029905891437956874,1,16384,): vm12: apply" <br>  LOG: logical decoding found point point at 0 / 18A4290 <br>  DETAIL: running xacts with xcnt == 0 <br>  LOG: exported logical decoding snapshot: "0000071B-1" with 0 xids <br>  LOG: starting logical decoding for slot bdr_16384_6029905879776466735_1_16384__ <br>  DETAIL: streaming transactions committing after 0 / 18A42C8, reading WAL from 0 / 18A4290 <br>  LOG: logical decoding found point point at 0 / 18A4290 <br>  DETAIL: running xacts with xcnt == 0 <br></div></div><br><br>  Everything is good in the logs and there are no ERROR messages (and if there is, check the configs or sin on the developers))).  This completes the setup and launch.  Now you can check the work through the creation of tables in both databases. <br><br>  Another couple of moments.  Temporary replication is stopped by turning off the downstream wizard.  However, it is worth noting that a stopped replica causes the upstream wizard to continue accumulating WAL logs, which in turn can lead to uncontrollable disk space consumption.  Therefore, it is not recommended to permanently turn off the replica. <br>  Permanently delete the replica by removing the BDR configuration on the downstream server and then restarting the downstream wizard.  Then you need to remove the corresponding replication slot on the upstream wizard using the pg_drop_replication_slot ('slotname') function.  Available slots can be viewed using the pg_get_replication_slots () function. <br><br>  As a conclusion, I will say my impressions ... Of course, I have some questions about the operation of BDR, the answers to which will most likely have to be clarified experimentally.  But already at this stage I like this new tool, it is configured quickly and easily, plus it already works, despite the fact that it will officially appear only at 9.5 (about a year later).  Thus, with the release will be added another tool with which you can create reliable fault-tolerant configurations, and that's fine.  PostgreSQL from release to release only gets better and better. <br><br>  Actually that's all.  Thank you all for your attention. <br><br>  PS Links to read: <br>  <a href="https://wiki.postgresql.org/wiki/BDR_User_Guide">BDR User Guide</a> <br>  <a href="https://wiki.postgresql.org/wiki/Logical_Log_Streaming_Replication">Logical Log Streaming Replication</a> <br>  <a href="http://www.postgresql.org/docs/current/static/warm-standby.html">PostgreSQL WAL Shipping and Streaming Replication</a> </div><p>Source: <a href="https://habr.com/ru/post/227959/">https://habr.com/ru/post/227959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227945/index.html">Generating CSS Sprites with Gulp</a></li>
<li><a href="../227949/index.html">How are Internet things created ?!</a></li>
<li><a href="../227951/index.html">Happy birthday, Elon Musk!</a></li>
<li><a href="../227953/index.html">Energy transfer by water and single wire transmission</a></li>
<li><a href="../227957/index.html">Parallella board sales from Adapteva resumed.</a></li>
<li><a href="../227961/index.html">Case 3d metal printing (DMLS): microreactor for oil refining</a></li>
<li><a href="../227963/index.html">Smart watch or just a watch? (Poll)</a></li>
<li><a href="../227969/index.html">Some interesting and useful things for web developer # 20</a></li>
<li><a href="../227971/index.html">A detailed review of the Wolfram Programming Cloud (Wolfram Programming Clouds)</a></li>
<li><a href="../227973/index.html">Do not pour me salt into the reactor or non-pulsed nuclear rocket engines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>