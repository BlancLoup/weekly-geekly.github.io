<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>First steps with STM32 and mikroC compiler for ARM architecture - Part 4 - I2C, pcf8574 and HD4478 LCD connection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to devote the following article to work with the widespread i2c interface, which is often used in various microcircuits connected to the microc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>First steps with STM32 and mikroC compiler for ARM architecture - Part 4 - I2C, pcf8574 and HD4478 LCD connection</h1><div class="post__text post__text-html js-mediator-article">  I want to devote the following article to work with the widespread i2c interface, which is often used in various microcircuits connected to the microcontroller. <br><br>  I2C is a bus operating on two physical connections (in addition to the common wire).  Quite a lot about it is painted on the Internet, there are quite good articles in <a href="https://ru.wikipedia.org/wiki/I%25C2%25B2C">Wikipedia</a> .  In addition, the bus operation algorithm is very clearly described <a href="http://easyelectronics.ru/interface-bus-iic-i2c.html">here</a> .  In short, the bus will be a two-wire synchronous bus.  Up to 127 devices can be on the bus at the same time (the device address is 7-bit, we will return to this later).  Below is a typical diagram of connecting devices to the i2c bus, with the MK as the master device. <br><br><img src="https://habrastorage.org/files/c9e/609/2cd/c9e6092cd6a245468280ed4728830858.JPG"><br><a name="habracut"></a><br>  For i2c, all devices (both master and slaves) use open-drain outputs.  Simply put, they can attract the tire ONLY TO EARTH.  A high bus level is provided by pull-up resistors.  The value of these resistors is usually chosen in the range from 4.7 to 10 kŒ©.  i2c is sufficiently sensitive to the physical lines connecting devices, so if you use a connection with a large capacitance (for example, a long thin or shielded cable), the effect of this capacitance can ‚Äúblur‚Äù the edges of the signals and interfere with the normal bus operation.  The smaller the pull-up resistor, the less this capacitance affects the characteristic of the signal fronts, but THE MORE LOAD ON the output transistors on the i2c interfaces.  The value of these resistors is chosen for each specific implementation, but they should not be less than 2.2 kOhms, otherwise you can simply burn the output transistors in the devices working with the bus. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The bus consists of two lines: SDA (data lines) and SCL (clocking signal).  <b>Tacts bus Master device</b> , usually our MK.  When the SCL high level information is read from the data bus.  <b>Changing the state of SDA is possible only when the clock signal is low</b> .  When SCL is high, the signal on SDA changes when forming <b><u>START</u></b> signals (when SCL is high, the signal on SDA changes from high to low) and <b><u>STOP</u></b> - when SCL is high, the signal on SDA changes from low to high. <br><br>  Separately, it should be said that in i2c the address is specified by a 7-bit number.  8 - the low bit indicates the direction of data transfer <u>0 - means that the slave will transmit data, 1 - to receive.</u>  .  In short, the algorithm for working with i2c is: <br><br><ul><li>  <b>High level on SDA and SCL</b> - the tire is free, you can start working </li><li>  The master raises the <b>SCL</b> to 1, and changes the state of the <b>SDA</b> from 1 to 0 ‚Äî pulls it to the ground ‚Äî a <b>START</b> signal is generated </li><li>  The master transmits a 7-bit slave address with a direction bit (data on <b>SDA is</b> set when the <b>SCL is</b> pulled to the ground, and read by the slave when it is released).  If the slave does not have time to ‚Äúshake‚Äù the previous bit, it attracts <b>SCL</b> to the ground, letting the master know that the data bus status does not need to be changed: ‚ÄúI am still reading the previous one‚Äù.  After the master releases the tire, he checks <u>whether the slave has released it</u> . </li><li>  After transmitting 8 bits of the address, the master generates the 9th cycle and releases the data bus.  If the slave heard its address and accepted it, it will <u>squeeze the <b>SDA</b> to the ground</u> .  This is how the <b>ASK</b> signal is formed - received, everything is OK.  If the slave did not understand anything, or he was simply not there, then there would be no one to press the tire.  the master will wait for the timeout and understand that they did not understand him. </li><li>  After sending the address, if we have a direction <u>from master to slave</u> (8 bits of the address is 1), then the master sends data to the slave, not forgetting to check the presence of <b>ASK</b> from the slave after transmitting each byte, waiting for the slave to process the received information. </li><li>  When the master receives data from the slave, the master itself generates the <b>ASK</b> signal after receiving each byte, and the slave controls its presence.  The master may not specifically send <b>ASK</b> before sending the <b>STOP</b> command, usually, thus letting the slave understand that it is not necessary to betray the data anymore. </li><li>  If after sending the data by the master (write mode) it is necessary to read the data from the slave, <u>then the master generates again the <b>START</b> signal</u> , sending the slave address with the read flag.  (if before the <b>START</b> command the <b>STOP</b> command was not transmitted, the <b>RESTART</b> command is formed).  This is used to change the direction of communication master slave.  For example, we pass the address of the register to the slave, and then we read data from it.) <br></li><li>  Upon completion of work with the slave, the master generates a <b>STOP</b> signal ‚Äî with a high level of the clock signal, it forms the data bus transition from 0 to 1. </li></ul><br>  The STM 32 has hardware-implemented i2c bus transceivers.  Such modules in the MC can be 2 or 3. For their configuration, special registers are used, described in the reference to the MC used. <br><br>  In MicroC, before using i2c (as well as any peripherals), it must be properly initialized.  For this we use the following function (Initialization as a master): <br><br><pre><code class="cpp hljs">I2Cn_Init_Advanced(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> : I2C_ClockSpeed, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module_Struct *<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>);</code> </pre> <br><ul><li>  <b>n</b> is the number of the module used, for example, <i>I2C1</i> or <i>I2C2</i> . </li><li>  <b>I2C_ClockSpeed</b> - bus speed, 100000 (100 kbs, standard mode) or 400000 (400 kbs, fast mode).  The second is 4 times faster, but not all devices support it </li><li>  <b>* module</b> - a pointer to a peripheral module, for example <i>&amp; _GPIO_MODULE_I2C1_PB67</i> , do not forget here that the <b>Code Assistant</b> ( <i><b>ctrl-space</b></i> ) helps a lot. </li></ul><br>  First we check the bus <b>freeness</b> , for this there is a function <b>I2Cn_Is_Idle ();</b>  returning 1 if the bus is free, and 0 if it is being exchanged. <br><br>  Next, we form the <b>START</b> signal, for which we use: <br><br><pre> <code class="cpp hljs">I2Cn_Start();</code> </pre><br>  where <b>n</b> is the number of the used i2c module of our microcontroller.  The function returns 0 if an error occurred on the bus and 1 if everything is OK. <br><br>  In order to transfer the data to the slave, use the function: <br><br><pre> <code class="cpp hljs">I2Cn_Write(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> slave_address, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> END_mode);</code> </pre><br><ul><li>  <b>n</b> - the number of the module used </li><li>  <b>slave_address</b> is the 7-bit slave address. </li><li>  <b>* buf</b> - a pointer to our data - a byte or an array of bytes. </li><li>  <b>count</b> - the number of data bytes transferred. </li><li>  <b>END_mode</b> - what to do after the data transfer to the slave, <b><u>END_MODE_STOP</u></b> - send a <b>STOP</b> signal, or <b><u>END_MODE_RESTART</u></b> send the <b>START</b> again, <b><u>generating a</u></b> <b>RESTART</b> signal and making it clear to the department that the session with it is not over and will be read from it now. </li></ul><br>  To read data from the slave, use the function: <br><br><pre> <code class="cpp hljs">I2Cn_Read(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> slave_address, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptrdata, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> END_mode);</code> </pre><br><ul><li>  <b>n</b> - the number of the module used </li><li>  <b>slave_address</b> is the 7-bit slave address. </li><li>  <b>* buf</b> - a pointer to a variable or array into which we accept data, type char or short int </li><li>  <b>count</b> - the number of data bytes received. </li><li>  <b>END_mode</b> - what to do after receiving data from the slave <b>- <u>END_MODE_STOP</u></b> - send a <b>STOP</b> signal, or <b><u>END_MODE_RESTART</u></b> send a <b>RESTART</b> signal. </li></ul><br>  Let's try to connect something to our MK.  For a start: a <a href="http://www.ti.com/lit/ds/symlink/pcf8574.pdf">widespread PCF8574 (A)</a> chip, <a href="http://www.ti.com/lit/ds/symlink/pcf8574.pdf">which</a> is an I / O port expander with control via i2c bus.  This chip contains only one internal register, which is its physical I / O port.  Ie if you pass it a byte, he will also be exposed to her conclusions.  If we read a byte from it (Send <b>START</b> address with read flag, <b>RESTERT</b> signal <b>,</b> read data and at the end generate <b>STOP</b> signal), it will reflect logical states on its outputs.  Let's connect our microchip according to the datasheet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c89/2c7/2d2/c892c72d2b9c4e159e9aeb1b424eeeba.JPG" alt="image"></div><br>  The address of the microcircuit is formed from the state of the pins <b>A0, A1, A2</b> .  For <b>PCF8574, the</b> address is <b>0100A0A1A2</b> .  (For example, we have A0, A1, A2 have a high level, respectively, the address of our chip is 0b0100 <b>111</b> = 0x27).  For <b>PCF8574A</b> - <b>0111A0A1A2</b> , which with our connection scheme will give the address 0b0111 <b>111</b> = <b>0x3F</b> .  If, say, A2 is connected to ground, then the address for <b>PCF8574A</b> will be <b>0x3B</b> .  Total for one bus i2c can simultaneously hang 16 chips, 8 PCF8574A and PCF8574. <br><br>  Let's try to transfer something to initialize the i2c bus and transfer something to our PCF8574. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCF8574A_ADDR 0x3F </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//c  PCF8574 void I2C_PCF8574_WriteReg(unsigned char wData) { I2C1_Start(); //   START I2C1_Write(PCF8574A_ADDR,&amp;wData, 1, END_MODE_STOP); //  1      STOP } char PCF8574A_reg; //      PCF8574 void main () { I2C1_Init_Advanced(400000, &amp;_GPIO_MODULE_I2C1_PB67); //  I2C delay_ms(25); //   PCF8574A_reg.b0 = 0; //   PCF8574A_reg.b1 = 1; //    while (1) { delay_ms(500); PCF8574A_reg.b0 = ~PCF8574A_reg.b0; PCF8574A_reg.b1 = ~PCF8574A_reg.b1; //   I2C_PCF8574_WriteReg (PCF8574A_reg); //  PCF8574  } }</span></span></span></span></code> </pre><br>  We compile and run our program and see that our LEDs blink alternately. <br>  I did not just connect the cathode LEDs to our PCF8574.  The fact is that the microcircuit, when a logical 0 is applied to the output, honestly attracts its output to the ground, but when a logical 1 is applied, it connects it to the + supply through a current source of 100 ŒºA.  Ie "honest" logical 1 at the output does not get.  And the LED from 100 ŒºA does not light up.  This is done in order to customize the PCF8574 input to the input without additional registers.  We just write to the output register 1 (in fact, we set the state of the foot in Vdd) and we can simply short it to the ground.  The current source will not ‚Äúburn‚Äù the output stage of our I / O expander.  If the leg is attracted to the earth, then the earth potential is on it, and logical 0 is read. If the leg is attracted to +, then the logical 1 is read. On the one hand, it is simple, but on the other hand, you should always remember about it while working with these microchips. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f4c/484/c93/f4c484c932404446a8640f732c7f9903.JPG" alt="image"></div><br>  Let's try to read the state of the findings of our expander microcircuit. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCF8574A_ADDR 0x3F </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//c  PCF8574 void I2C_PCF8574_WriteReg(unsigned char wData) { I2C1_Start(); //   START I2C1_Write(PCF8574A_ADDR, &amp;wData, 1, END_MODE_STOP); //  1      STOP } void I2C_PCF8574_ReadReg(unsigned char rData) { I2C1_Start(); //   START I2C1_Read(PCF8574A_ADDR, &amp;rData, 1, END_MODE_STOP); //  1      STOP } char PCF8574A_reg; //     PCF8574 char PCF8574A_out; //       PCF8574 char lad_state; //     void main () { I2C1_Init_Advanced(400000, &amp;_GPIO_MODULE_I2C1_PB67); //  I2C delay_ms(25); //   PCF8574A_reg.b0 = 0; //    PCF8574A_reg.b1 = 1; //    PCF8574A_reg.b6 = 1; //   6  7  . PCF8574A_reg.b7 = 1; while (1) { delay_ms(100); I2C_PCF8574_WriteReg (PCF8574A_reg); //    CF8574 I2C_PCF8574_ReadReg (PCF8574A_out); //   CF8574 if (~PCF8574A_out.b6) PCF8574A_reg.b0 = ~PCF8574A_reg.b0; //   1  (6     CF8574  0,  /  ) if (~PCF8574A_out.b7) PCF8574A_reg.b1 = ~PCF8574A_reg.b1; //   2   2  } }</span></span></span></span></code> </pre><br>  Now by pressing the buttons we turn on or off our LED.  The microcircuit has an <b>INT</b> pin.  A pulse is formed on it every time the state of the outputs of our I / O expander changes.  Having connected it to the external interrupt input of our MC (how to configure external interrupts and how to work with them, I will tell in one of the following articles). <br><br>  Let's use our port extender to connect a character display through it.  There are a great many, but almost all of them are based on the <b>HD44780</b> controller chip and its clones.  For example, I used the LCD2004 display. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cc7/650/d84/cc7650d84c2e48c0a65dd54a5699a8f0.png"></div><br><p>  The datashit on <a href="https://www.beta-estore.com/download/rk/RK-10290_410.pdf">it</a> and the <a href="https://www.sparkfun.com/datasheets/LCD/HD44780.pdf">HD44780</a> controller can be easily found on the Internet.  We connect our display to the RCF8574, and its, respectively, to our STM32. <br><br><img src="https://habrastorage.org/files/7cd/3eb/6a0/7cd3eb6a01f54f23a8454c14f09fcaeb.JPG"><br><br>  <b>HD44780</b> uses a parallel gated interface.  Data is transmitted over 8 (in one clock) or 4 (in 2 clock cycles) of the strobe pulse at pin <b>E.</b>  (read by the display controller on the descending front, the transition from 1 to 0).  The <b>RS</b> output indicates whether we send data to our display ( <b>RS = 1</b> ) (the characters it should display, in fact, from ASCII codes) or commands ( <b>RS = 0</b> ).  <b>RW</b> indicates the direction of data transfer, write or read.  Usually we write data to the display, therefore ( <b>RW = 0</b> ).  Resistor R6 controls the display contrast.  <i>Just connect the input contrast adjustment to the ground or power can not, otherwise you will not see anything.</i>  .  VT1 is used to turn on and off the backlight display commands MK.  MicroC has a library for working with such displays on a parallel interface, but usually it‚Äôs expensive to spend 8 feet on a display, so I almost always use the F8574 to work with such small screens.  (If someone is interested, I will write an article about working with HD44780-based displays built into MicroC via a parallel interface.) The exchange protocol is not particularly complicated (we will use 4 data lines and transmit information in 2 cycles), the following shows it timing chart: <br><img src="https://habrastorage.org/files/9b3/706/8c2/9b37068c203349cca841bd7a002ea4fc.JPG"><br>  Before transferring data to our display, it must be initialized by passing service commands.  (Described in the datasheet, here we give only the most used) <br><br></p><ul><li>  <b>0x28</b> - communication with the indicator by 4 lines </li><li>  <b>0x0C</b> - enable image output, disable cursor display </li><li>  <b>0x0E</b> - <b>enable</b> image output, <b>enable</b> cursor display </li><li>  <b>0x01</b> - clear the indicator </li><li>  <b>0x08</b> - disable image output </li><li>  <b>0x06</b> - after the character is <b>displayed</b> , the cursor moves by 1 familiarity </li></ul><br>  Since we will need to work with this indicator quite often, we will create a plug-in library <i><b>‚Äúi2c_lcd.h‚Äù</b></i> .  To do this, right click on the <b><i>Header Files</i></b> folder in the <b>Project Maneger</b> and select <b><i>Add New File</i></b> .  Create our header file. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCF8574A_ADDR 0x3F </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//c  PCF8574 #define DB4 b4 //   PCF8574   #define DB5 b5 #define DB6 b6 #define DB7 b7 #define EN b3 #define RW b2 #define RS b1 #define BL b0 //  #define displenth 20 //       static unsigned char BL_status; //     (/) void lcd_I2C_Init(void); //     PCF8574 void lcd_I2C_txt(char *pnt); //     ,  -     void lcd_I2C_int(int pnt); //       ,  -   void lcd_I2C_Goto(unsigned short row, unsigned short col); //     ,  row -  ( 1  2  4    )  col - ( 1  displenth)) void lcd_I2C_cls(); //   void lcd_I2C_backlight (unsigned short int state); //  (  1   -   0  )</span></span></span></span></code> </pre><br>  Now we will describe our functions, again go to the <b>Project Maneger</b> , right click on the <b><i>Sources</i></b> folder and select <b><i>Add New File</i></b> .  Create the file <i><b>"i2c_lcd.c"</b></i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i2c_lcd.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  - char lcd_reg; //      PCF8574 void I2C_PCF8574_WriteReg(unsigned char wData) //    i2c   PCF8574 { I2C1_Start(); I2C1_Write(PCF8574A_ADDR,&amp;wData, 1, END_MODE_STOP); } void LCD_COMMAND (char com) //     { lcd_reg = 0; // 0    lcd_reg.BL = BL_status.b0; //       ,    lcd_reg.DB4 = com.b4; //     4     lcd_reg.DB5 = com.b5; lcd_reg.DB6 = com.b6; lcd_reg.DB7 = com.b7; lcd_reg.EN = 1; // .   1 I2C_PCF8574_WriteReg (lcd_reg); //   PCF8574,      delay_us (300); //  lcd_reg.EN = 0; //    0,    I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); lcd_reg = 0; lcd_reg.BL = BL_status.b0; lcd_reg.DB4 = com.b0; //    4   lcd_reg.DB5 = com.b1; lcd_reg.DB6 = com.b2; lcd_reg.DB7 = com.b3; lcd_reg.EN = 1; I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); lcd_reg.EN = 0; I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); } void LCD_CHAR (unsigned char com) //   (ASCII  ) { lcd_reg = 0; lcd_reg.BL = BL_status.b0; lcd_reg.EN = 1; lcd_reg.RS = 1; //        1  RS lcd_reg.DB4 = com.b4; //   4   lcd_reg.DB5 = com.b5; lcd_reg.DB6 = com.b6; lcd_reg.DB7 = com.b7; I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); lcd_reg.EN = 0; // .   0,    I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); lcd_reg = 0; lcd_reg.BL = BL_status.b0; lcd_reg.EN = 1; lcd_reg.RS = 1; lcd_reg.DB4 = com.b0; //   4   lcd_reg.DB5 = com.b1; lcd_reg.DB6 = com.b2; lcd_reg.DB7 = com.b3; I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); lcd_reg.EN = 0; I2C_PCF8574_WriteReg (lcd_reg); delay_us (300); } void lcd_I2C_Init(void) { I2C1_Init_Advanced(400000, &amp;_GPIO_MODULE_I2C1_PB67); //  I2c    delay_ms(200); lcd_Command(0x28); //    4    delay_ms (5); lcd_Command(0x08); //     delay_ms (5); lcd_Command(0x01); //  delay_ms (5); lcd_Command(0x06); //       delay_ms (5); lcd_Command(0x0C); //      delay_ms (25); } void lcd_I2C_txt(char *pnt) //     { unsigned short int i; //     char tmp_str[displenth + 1]; //  ,   1    ,      v  NULL ASCII 0x00 strncpy(tmp_str, pnt, displenth); //       displenth    for (i=0; i&lt;displenth; i++) { if (tmp_str[i] == 0) break; //  NULL , —ñ   LCD_CHAR(tmp_str[i]); //     } } void lcd_I2C_int(int pnt) //     { char tmp_str[8]; //  unsigned short i, j; IntToStr(pnt,tmp_str); //   ,  6  + NULL  while (tmp_str[0]==32) { for (i=0; i&lt;7; i++) { tmp_str[i]=tmp_str[i+1]; //   (ASCII  32) tmp_str[6-j]=0; } j++; } lcd_I2C_txt (tmp_str); //    } void lcd_I2C_Goto(unsigned short row, unsigned short col) //     { col--; //      0,    1  switch (row) { case 1: lcd_Command(0x80 + col); //     break; case 2: lcd_Command(0x80 + col + 0x40); break; case 3: lcd_Command(0x80 + col + 0x14); break; case 4: lcd_Command(0x80 + col + 0x54); break; } } void lcd_I2C_cls() //  { lcd_Command(0x01); delay_ms (5); } void lcd_I2C_backlight (unsigned short int state) //     { lcd_reg = 0; BL_status.b0 = state.b0; //  ,            lcd_reg.BL = state.b0; I2C_PCF8574_WriteReg (lcd_reg); delay_ms (1); }</span></span></span></span></code> </pre><br>  Now connect the newly created library to the file with our main function: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i2c_lcd.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  - unsigned int i; //   void main() { lcd_I2C_Init(); //  lcd_I2C_backlight (1); //  lcd_I2C_txt ("Hellow habrahabr"); //    while (1) { delay_ms(1000); lcd_I2C_Goto (2,1); //  1  2  lcd_i2c_int (i); //    i++; //   } }</span></span></span></span></code> </pre><br><br>  If everything is correctly assembled, then we should see a text on the indicator and an incremented counter every second.  In general, nothing complicated :) <br><br><p>  In the next article, we will continue to deal with the i2c protocol and devices working with it.  Consider working with EEPROM 24XX memory and MPU6050 accelerometer / gyroscope. </p><p></p></div><p>Source: <a href="https://habr.com/ru/post/322184/">https://habr.com/ru/post/322184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322172/index.html">As in Canada, looking for missing children</a></li>
<li><a href="../322176/index.html">Infrared optics instead of optical fiber in the data center: the original project of engineers from the United States</a></li>
<li><a href="../322178/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ250 (February 13 - 19, 2017)</a></li>
<li><a href="../322180/index.html">Azure-IaaS-Digest number 13 (January-February)</a></li>
<li><a href="../322182/index.html">Displaying parameters of IOT & GPS objects on charts</a></li>
<li><a href="../322186/index.html">SafeNet Authentication Service - one-time password management system</a></li>
<li><a href="../322188/index.html">Review of materials on machine learning (February 13 - 20, 2017)</a></li>
<li><a href="../322190/index.html">Small business stories: as in Yuzhno-Sakhalinsk, just flooded</a></li>
<li><a href="../322192/index.html">How we created a hosting provider with our own data center (continued)</a></li>
<li><a href="../322194/index.html">The book "The Basics of Data Science and Big Data. Python and the science of data "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>