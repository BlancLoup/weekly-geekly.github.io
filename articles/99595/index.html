<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compilation. 7: register assignment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="File names are infinite in length, where infinity is set to 255 characters. 
 --Peter Collinson: The Unix File System 
 So, we have a program on the p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compilation. 7: register assignment</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  File names are infinite in length, where infinity is set to 255 characters. <br>  <i>--Peter Collinson: The Unix File System</i> </blockquote><br>  So, we have a program on the p-code, and at its disposal an unlimited number of registers (ie, 255).  The number of registers in a real processor is much smaller (suppose four).  What do we do? <br><br><h3>  Further in the post: </h3><ol><li>  P-code parsing </li><li>  Lifetime </li><li>  Implementation </li><li>  Simple optimizations </li><li>  Version splitting </li><li>  Work with memory </li><li>  What happened? </li></ol><a name="habracut"></a><h3>  P-code parsing </h3><br>  In the last post there was a dump of the compiled program.  Her 40 teams are easy to decipher: <pre> 00 mov r01, 0
 01 mov r02, 0x3e8
 02 echo 0x126
 03 echo r01
 04 echo 0xa0
 05 echo r02
 06 echo 0xa7
 07 le r03, r01, r02
 08 jz r03, + 0x1d (= 0x26)
 09 add r04, r01, r02
 0a mov r05,2
 0b div r06, r04, r05
 0c echo 0x162
 0d echo r06
 0e echo 0xcc
 0f input r07
 10 mov r08, 1
 11 eq r09, r07, r08
 12 jz r09, +4 (= 0x17)
 13 mov r0a, 1
 14 sub r0b, r06, r0a
 15 add r02, r0b, 0
 16 jz 0, + e (= 0x25)
 17 mov r0c, 2
 18 eq r0d, r07, r0c
 19 jz r0d, +4 (= 0x1e)
 1a mov r0e, 1
 1b add r0f, r06, r0e
 1c add r01, r0f, 0
 1d jz 0, +7 (= 0x25)
 1e mov r10, 3
 1f eq r11, r07, r10
 20 jz r11, +3 (= 0x24)
 21 echo 0x146
 22 hlt
 23 jz 0, +1 (= 0x25)
 24 echo 0x16a
 25 jz 0, -0x1f (= 7)
 26 echo 0xff
 27 hlt
</pre><br>  It can be seen that not all registers are used at the same time: most store intermediate values ‚Äã‚Äãthat are needed only for the next command.  For example, <code>r03</code> used only in commands <code>07-08</code> , and <code>r0f</code> only in commands <code>1b-1c</code> .  It means that there are no obstacles to use the same physical register for the stored values: in the <code>07-08</code> commands it will be used for one value, and in <code>1b-1c</code> - for another.  Any two registers that are not used <i>simultaneously for different values</i> can be combined into one physical register. <br><br>  There is a small subtlety about the definition of "being used simultaneously for different values."  Firstly, it is impossible to consider the register lifetime as just a gap from its first mention to the last: the code may contain jumps in all directions, for example: <pre>    ...
 10 mov r, 42
 11 jz 0, 20
 12 echo r
    ...
 20 ...
    ...
 30 jz 0, 12
    ...
</pre><br>  Even though <code>r</code> is mentioned only in commands 10‚Äì12, it is implicitly used in command 20, because after it, a jump back to 12 is possible;  therefore, <code>r</code> cannot be combined with other registers used in command 20. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second subtlety: <pre>    ...
 10 mov r, 42
 11 echo r
    ...
 20 ...
    ...
 30 mov r, 24
 31 echo r
    ...
</pre><br>  In command 20, the <code>r</code> register is not actually used, although it is mentioned before this (10-11), and after that (30-31).  We can store any other values ‚Äã‚Äãin it, because before the next use (31) it will be assigned a new value.  In principle, we can even assign different physical registers for <code>r</code> in 10-11 and 31-31, because the values ‚Äã‚Äãwill still be stored different.  But for this you need to find out that <code>r</code> two independent ‚Äúversions‚Äù and process them separately. <br><br><h3>  Lifetime </h3><br>  You can determine the set of commands in which the register is used iteratively: <br><ul><li>  the register is needed by the command that <i>reads</i> its value; </li><li>  if from team A you can go to B (directly or by jumping), and the register is needed by B, then A is also needed; </li><li>  the register is not needed by the command that <i>sets</i> its value. </li></ul>  For each command, we determine the set of registers that it needs at the input and at the output, and apply three rules until these sets are established.  Here is what we get for our program: <pre>              iteration number: 1 (input / output) 2 (input / output) 3 (input / output) 4 (input / output) ... total (input / output)
 00 mov r01, 0 / r01
 01 mov r02, 0x3e8 / r01 r01 / r01, r02
 02 echo 0x126 / r01 r01 / r01 r01 / r01 r01, r02 / r01, r02
 03 echo r01 r01 / r01 / r01 / r01 / r02 r01, r02 / r01, r02
 04 echo 0xa0 / r02 r02 / r02 r02 / r02 r01, r02 / r01, r02
 05 echo r02 r02 / r02 / r02 / r02 / r01, r02 r01, r02 / r01, r02
 06 echo 0xa7 / r01, r02 r01, r02 / r01, r02 r01, r02 / r01, r02 r01, r02 / r01, r02
 07 le r03, r01, r02 r01, r02 / r01, r02 / r03 r01, r02 / r03 r01, r02 / r01, r02, r03 r01, r02 / r01, r02, r03
 08 jz r03, + 0x1d (= 0x26) r03 / r03 / r01, r02 r01, r02, r03 / r01, r02 r01, r02, r03 / r01, r02 r01, r02, r03 / r01, r02
 09 add r04, r01, r02 r01, r02 / r01, r02 / r01, r02 / r01, r02 / r04 r01, r02 / r01, r02, r04
 0a mov r05,2 / r04, r05 r04 / r04, r05 r04 / r04, r05 r01, r02, r04 / r01, r02, r04, r05
 0b div r06, r04, r05 r04, r05 / r04, r05 / r04, r05 / r04, r05 / r06 r01, r02, r04, r05 / r01, r02, r06
 0c echo 0x162 / r06 r06 / r06 r06 / r06 r01, r02, r06 / r01, r02, r06
 0d echo r06 r06 / r06 / r06 / r06 / r01, r02, r06 / r01, r02, r06
 0e echo 0xcc r01, r02, r06 / r01, r02, r06
 0f input r07 / r07 r01, r02, r06 / r01, r02, r06, r07
 10 mov r08, 1 / r07, r08 r07 / r07, r08 r07 / r07, r08 r01, r02, r06, r07 / r01, r02, r06, r07, r08
 11 eq r09, r07, r08 r07, r08 / r07, r08 / r09 r07, r08 / r09 r07, r08 / r09 r01, r02, r06, r07, r08 / r01, r02, r06, r07, r09
 12 jz r09, +4 (= 0x17) r09 / r09 / r09 / r09 / r06, r07 r01, r02, r06, r07, r09 / r01, r02, r06, r07
 13 mov r0a, 1 / r06, r0a r06 / r06, r0a r06 / r06, r0a r01, r06 / r01, r06, r0a
 14 sub r0b, r06, r0a r06, r0a / r06, r0a / r0b r06, r0a / r0b r06, r0a / r0b r01, r06, r0a / r01, r0b
 15 add r02, r0b, 0 r0b / r0b / r0b / r0b / r01, r0b / r01, r02
 16 jz 0, + e (= 0x25) r01, r02 / r01, r02
 17 mov r0c, 2 / r07, r0c r07 / r07, r0c r07 / r07, r0c r01, r02, r06, r07 / r01, r02, r06, r07, r0c
 18 eq r0d, r07, r0c r07, r0c / r07, r0c / r0d r07, r0c / r0d r07, r0c / r0d r01, r02, r06, r07, r0c / r01, r02, r06, r07, r0d
 19 jz r0d, +4 (= 0x1e) r0d / r0d / r0d / r0d / r06, r07 r01, r02, r06, r07, r0d / r01, r02, r06, r07
 1a mov r0e, 1 / r06, r0e r06 / r06, r0e r06 / r06, r0e r02, r06 / r02, r06, r0e
 1b add r0f, r06, r0e r06, r0e / r06, r0e / r0f r06, r0e / r0f r06, r0e / r0f r02, r06, r0e / r02, r0f
 1c add r01, r0f, 0 r0f / r0f / r0f / r0f / r02, r0f / r01, r02
 1d jz 0, +7 (= 0x25) / r01, r02 r01, r02 / r01, r02
 1e mov r10, 3 / r07, r10 r07 / r07, r10 r07 / r07, r10 r01, r02, r07 / r01, r02, r07, r10
 1f eq r11, r07, r10 r07, r10 / r07, r10 / r11 r07, r10 / r11 r07, r10 / r11 r01, r02, r07, r10 / r01, r02, r11
 20 jz r11, +3 (= 0x24) r11 / r11 / r11 / r11 / r01, r02, r11 / r01, r02
 21 echo 0x146
 22 hlt
 23 jz 0, +1 (= 0x25) / r01, r02 r01, r02 / r01, r02
 24 echo 0x16a / r01, r02 r01, r02 / r01, r02
 25 jz 0, -0x1f (= 7) / r01, r02 r01, r02 / r01, r02 r01, r02 / r01, r02 r01, r02 / r01, r02
 26 echo 0xff
 27 hlt
</pre>  Concerning separate iterations: <ol><li>  At the input of each command are the registers it uses;  (rule number 1) </li><li>  At the output of each command, copy the input of the commands reachable from it;  (rule number 2) </li><li>  At the input of each command we copy its output, excluding the register recorded by the command;  (rule number 3) </li><li>  At the output of each command, copy the input of the commands reachable from it;  (rule number 2) </li></ol>  Further, the rules number 2 and number 3 are repeated in turn. <br><br>  After several iterations, we get the final markup of the ‚Äúsurvivability of the registers‚Äù - which registers are needed by each team.  Then we can rename the registers of the p-code to physical ones - for example, ‚Äúgreedily‚Äù: we take the ‚Äúmost necessary‚Äù register (the one that is needed by the largest number of commands);  rename to physical, which is not yet engaged in the relevant teams;  repeat. <br>  The optimal choice of which n-registers should be provided for the physical in order to last as much as possible is possible only by exhaustive search: this task is equivalent to ‚Äúcoloring the graph in a minimum of colors,‚Äù about which mathematicians believe that there is no effective solution for it.  Our ‚Äúgreedy‚Äù approach is not the worst possible. <br><br>  What if there is no free physical for the next p-register?  For example, in our code there are commands (10-12, 17-19) that use 5 n-registers in each: at least one of them does not have enough space.  It is clear that you have to keep it in memory. <br>  But just saying the register ‚Äúyou are not lucky, you will be stored in memory‚Äù is not enough: after all, the commands of our p-code do not know how to work with the values ‚Äã‚Äãfrom memory, as well as the commands of most real processors.  It is necessary at the time of use to get the value from memory in the register.  Only what?  After all, this is why they removed the value in memory, because all the registers are occupied! <br><br>  At this point, the theory I learned ends, and guesses and heuristics come along.  I decided to ‚Äúpour out into memory‚Äù extra registers before a command for which there are not enough registers, and then read them back from memory.  Thus, in the ‚Äúlifetime‚Äù of the poured registers, a hole will appear in the place of this command, and in this hole we will be able to use the released registers for other purposes. <br><br>  To be able to ‚Äúpush‚Äù the code and insert read / write commands into the memory, you have to change the intermediate format a bit: now it will be a linked list, and the jump target will be stored not as an offset, but as a pointer (turning the list into a digraph).  During the generation of the p-code, for <a href="http://habrahabr.ru/blogs/programming/99592/">backpathing,</a> we will need to refer to the commands and by index;  for this we will get a separate displacement vector. <br> <code><font color="#008000">typedef</font> std::list&lt; <font color="#008000">struct</font> commandn&gt;::iterator pcommandn; <br> <font color="#008000">struct</font> commandn { <br> command cmd; <br> pcommandn tgt; <font color="#8080ff">//  </font> <br> commandn( <font color="#008000">const</font> command&amp; cmd) : cmd(cmd), tgt( <font color="#ff6060">NULL</font> ) {} <br> }; <br> <br> std::list&lt;commandn&gt; pcode; <br> std::vector&lt;pcommandn&gt; pcodeidx; <br> <br> <font color="#008000">inline</font> <font color="#008000">int</font> emit( <font color="#008000">const</font> command&amp; cmd) { <br> pcodeidx.push_back(pcode.insert(pcode.end(), commandn(cmd))); <br> <font color="#800000">return</font> pcode.size()- <font color="#ff6060">1</font> ; <br> } <br> <font color="#008000">inline</font> <font color="#008000">int</font> emit(command::opcodes opcode, regnum dest, regnum src1, regnum src2) { <br> <font color="#800000">return</font> emit(command(opcode, dest, src1, src2)); <br> } <br> <font color="#008000">inline</font> <font color="#008000">int</font> emit(command::opcodes opcode, regnum dest, <font color="#008000">short</font> imm) { <br> <font color="#800000">return</font> emit(command(opcode, dest, imm)); <br> } <br> <font color="#008000">inline</font> <font color="#008000">void</font> fix( <font color="#008000">int</font> index, command::opcodes opcode, regnum dest, <font color="#008000">short</font> imm) { <br> *pcodeidx[index] = commandn(command(opcode, dest, imm)); <br> } <br></code> <br>  Pointers to a jump target are difficult to fill in during the generation of the p-code: at the time of creating the jumps, the target index is already known, but it is not yet known what kind of team will be there;  to put a pointer to a team that has not yet been created is problematic.  Therefore, after the end of the parsing and generation of the p-code, we bypass the generated code, and place the jump pointers;  then do all the necessary work with the allocation of registers;  and at the end, before dumping the p-code to a file, you will need to ‚Äúserialize‚Äù it - determine the final index of each command, and fill in the jump offsets.  For this, add the field <code>int index;</code> to the <code>struct commandn</code> <code>int index;</code> <br><br> <code><font color="#008000">int</font> main() { <br> yyparse(); <br> <font color="#8080ff">//   </font> <br> <font color="#800000">for</font> ( <font color="#008000">int</font> i= <font color="#ff6060">0</font> ; i&lt;pcode.size(); i++) <br> <font color="#800000">if</font> (pcodeidx[i]-&gt;cmd.opcode==command::jz) <br> pcodeidx[i]-&gt;tgt = pcodeidx[i+ <font color="#ff6060">1</font> +pcodeidx[i]-&gt;cmd.imm]; <br> <br> <font color="#8080ff">//  / </font> <br> <font color="#8080ff">// ...</font> <br> <br> <font color="#8080ff">//  /  </font> <br> <font color="#008000">int</font> index = <font color="#ff6060">0</font> ; <br> foreach(i, pcode) i-&gt;index = index++; <br> foreach(i, pcode) <br> <font color="#800000">if</font> (i-&gt;cmd.opcode==command::jz) <br> i-&gt;cmd.imm = i-&gt;tgt-&gt;index-i-&gt;index- <font color="#ff6060">1</font> ; <br> <br> <font color="#8080ff">//  -  </font> <br> <font color="#8080ff">// ...</font> <br> } <br></code> <br>  Things are easy: implement "processing / optimization".  It takes, as you might expect, most of the entire compiler code. <br><br><h3>  Implementation </h3><br>  For assigning registers, we will store for each command (directly in the <code>struct commandn</code> ) sets of living at the input and output registers: separately - registers of the p-code, to determine the lifetime;  and separately - physical registers, to determine the compatibility with the actual appointment. <br> <code><font color="#008000">typedef</font> std::set&lt;regnum&gt; aliveset; <br> <font color="#008000">enum</font> physreg { firstp = <font color="#ff6060">1</font> , lastp = <font color="#ff6060">4</font> }; <br> <font color="#008000">typedef</font> std::set&lt;physreg&gt; alivesetp; <br> <font color="#008000">struct</font> commandn { <br> <font color="#8080ff">// ...</font> <br> aliveset onenter, onexit; <font color="#8080ff">// liveness check</font> <br> alivesetp onenterp, onexitp; <font color="#8080ff">// phys reg allocation</font> <br> <font color="#8080ff">// ...</font> <br> }; <br></code> <br>  Another useful thing is to determine by opcode which registers are used by the command: <br> <code><font color="#008000">inline</font> <font color="#008000">bool</font> hasnext(pcommandn cmd) { <br> <font color="#800000">return</font> (cmd-&gt;cmd.opcode!=command::hlt &amp;&amp;! <br> (cmd-&gt;cmd.opcode==command::jz &amp;&amp; !cmd-&gt;cmd.dest)); <br> } <br> <font color="#008000">inline</font> <font color="#008000">bool</font> has2src(pcommandn cmd) { <br> <font color="#800000">return</font> cmd-&gt;cmd.opcode&gt;=command::add; <br> } <br> <font color="#008000">inline</font> <font color="#008000">bool</font> writesdest(pcommandn cmd) { <br> <font color="#800000">return</font> cmd-&gt;cmd.opcode&gt;=command::mov; <br> } <br> <font color="#008000">inline</font> <font color="#008000">bool</font> readsdest(pcommandn cmd) { <br> <font color="#800000">return</font> cmd-&gt;cmd.opcode&gt;=command::store &amp;&amp; <br> cmd-&gt;cmd.opcode&lt;=command::echo; <br> } <br></code> <br>  After that, according to the scheme above, we calculate for each command the set of registers needed at the input and at the output;  at the same time we consider how many times each register is needed for a greedy assignment. <br> <code>std::vector&lt; <font color="#008000">int</font> &gt; liveness() { <font color="#8080ff">// returns usecount</font> <br> std::vector&lt; <font color="#008000">int</font> &gt; usecount(lastreg+ <font color="#ff6060">1</font> ); <br> <font color="#008000">bool</font> changed = <font color="#ff6060">false</font> ; <br> <font color="#8080ff">// rule 1</font> <br> foreach(i, pcode) { <br> i-&gt;onenter = i-&gt;onexit = aliveset(); <br> <font color="#800000">if</font> (has2src(i)) { <br> <font color="#800000">if</font> (i-&gt;cmd.src1) { <br> usecount[i-&gt;cmd.src1]++; <br> i-&gt;onenter.insert(i-&gt;cmd.src1); <br> } <br> <font color="#800000">if</font> (i-&gt;cmd.src2) { <br> usecount[i-&gt;cmd.src2]++; <br> i-&gt;onenter.insert(i-&gt;cmd.src2); <br> } <br> } <font color="#800000">else</font> <font color="#800000">if</font> (readsdest(i) &amp;&amp; i-&gt;cmd.dest) { <br> usecount[i-&gt;cmd.dest]++; <br> i-&gt;onenter.insert(i-&gt;cmd.dest); <br> } <br> <font color="#800000">if</font> (i-&gt;onenter.size()) <br> changed = <font color="#ff6060">true</font> ; <br> } <br> <font color="#800000">while</font> (changed) { <br> changed = <font color="#ff6060">false</font> ; <br> foreach2(i, pcode, next) { <br> <font color="#008000">int</font> oldsize = i-&gt;onenter.size()+i-&gt;onexit.size(); <br> <font color="#8080ff">// rule 2 (next command)</font> <br> <font color="#800000">if</font> (hasnext(i)) <br> i-&gt;onexit.insert(next-&gt;onenter.begin(), next-&gt;onenter.end()); <br> <font color="#8080ff">// rule 2 (jmp target)</font> <br> <font color="#800000">if</font> (i-&gt;cmd.opcode==command::jz) <br> i-&gt;onexit.insert(i-&gt;tgt-&gt;onenter.begin(), i-&gt;tgt-&gt;onenter.end()); <br> <font color="#8080ff">// rule 3</font> <br> i-&gt;onenter.insert(i-&gt;onexit.begin(), i-&gt;onexit.end()); <br> <font color="#800000">if</font> (writesdest(i)) <br> i-&gt;onenter.erase(i-&gt;cmd.dest); <br> <br> <font color="#800000">if</font> (i-&gt;onenter.size()+i-&gt;onexit.size() != oldsize) <br> changed = <font color="#ff6060">true</font> ; <br> } <br> } <br> <font color="#800000">return</font> usecount; <br> } <br></code> <br>  The <code>foreach2</code> macro <code>foreach2</code> allows us to look both at the current and at the next element in the loop body: <br> <code><font color="#ff40ff">#define foreach2(i, list, next)</font> <font color="#008000">typedef</font> <font color="#ff40ff">typeof(list) TOKENPASTE2(T,</font> <font color="#ff6060">__LINE__</font> <font color="#ff40ff">); \</font> <br> <font color="#ff40ff">&nbsp; &nbsp; &nbsp; &nbsp; </font> <font color="#800000">for</font> <font color="#ff40ff">(TOKENPASTE2(T,</font> <font color="#ff6060">__LINE__</font> <font color="#ff40ff">)::iterator next = list.begin(), i=next++; i != list.end(); i=next, next++)</font> <br></code> <br>  In principle, it was possible to reduce the total number of iterations, if we bypass the commands not ‚Äúfrom the top down‚Äù, but ‚Äúfrom the bottom up‚Äù, because the need ‚Äúspreads‚Äù from each command to the previous ones;  the top-down bypass is selected to simplify the code.  In the worst case, for a code of length <i>N</i> commands, 2 <i>N</i> iterations will be required (at each iteration, the need extends to the distance of a half-team).  For <code>test.jsk</code> 35 iterations were enough, because jumping reduces the distance. <br><br>  Finally, why we did all this: <br> <code><font color="#8080ff">//  / :</font> <br> <font color="#800000">while</font> ( <font color="#ff6060">1</font> ) { <font color="#8080ff">//       </font> <br> <br> <font color="#8080ff">//  </font> <br> <font color="#8080ff">// ...</font> <br> <br> std::vector&lt; <font color="#008000">int</font> &gt; usecount = liveness(); <br> std::vector&lt;physreg&gt; physmap(lastreg+ <font color="#ff6060">1</font> ); <br> foreach(i, pcode) <br> i-&gt;onenterp = i-&gt;onexitp = alivesetp(); <br> <font color="#800000">while</font> ( <font color="#ff6060">1</font> ) { <br> <font color="#8080ff">//   </font> <br> std::vector&lt; <font color="#008000">int</font> &gt;::iterator max = std::max_element(usecount.begin(), usecount.end()); <br> <font color="#800000">if</font> (!*max) <font color="#800000">break</font> ; <font color="#8080ff">//   </font> <br> *max = <font color="#ff6060">0</font> ; <br> regnum r = max - usecount.begin(); <br> <font color="#8080ff">//  .   - ‚Ññr</font> <br> std::vector&lt; <font color="#008000">int</font> &gt; collisions(lastp); <font color="#8080ff">// 0-based</font> <br> <font color="#800000">for</font> (physreg p=firstp; p&lt;=lastp; p=(physreg)(p+ <font color="#ff6060">1</font> )) { <font color="#8080ff">// error: ISO C++ forbids incrementing an enum</font> <br> foreach(i, pcode) { <br> <font color="#800000">if</font> (contains(i-&gt;onenter, r) &amp;&amp; contains(i-&gt;onenterp, p)) <br> collisions[p- <font color="#ff6060">1</font> ]++; <br> <font color="#800000">if</font> (contains(i-&gt;onexit, r) &amp;&amp; contains(i-&gt;onexitp, p)) <br> collisions[p- <font color="#ff6060">1</font> ]++; <br> } <br> <font color="#800000">if</font> (collisions[p- <font color="#ff6060">1</font> ]) <font color="#800000">continue</font> ; <font color="#8080ff">//   . </font> <br> physmap[r] = p; <br> <font color="#8080ff">//  - ‚Ññr   ‚Ññp</font> <br> foreach(i, pcode) { <br> <font color="#800000">if</font> (contains(i-&gt;onenter, r)) <br> i-&gt;onenterp.insert(p); <br> <font color="#800000">if</font> (contains(i-&gt;onexit, r)) <br> i-&gt;onexitp.insert(p); <br> } <br> <font color="#800000">break</font> ; <font color="#8080ff">//  </font> <br> } <br> <font color="#800000">if</font> (physmap[r]) <font color="#800000">continue</font> ; <font color="#8080ff">//   </font> <br> <font color="#8080ff">//   .   - ‚Ññr</font> <br> <font color="#8080ff">// :  ,     </font> <br> foreach2(i, pcode, next) <br> <font color="#800000">if</font> ((i-&gt;cmd.opcode!=command::load &amp;&amp; i-&gt;cmd.opcode!=command::store) &amp;&amp; <br> ((contains(i-&gt;onenter, r) &amp;&amp; i-&gt;onenterp.size()==lastp) || <br> (contains(i-&gt;onexit, r) &amp;&amp; i-&gt;onexitp.size()==lastp))) { <br> <font color="#8080ff">// ,    ,  </font> <br> <font color="#8080ff">// ...</font> <br> <font color="#800000">goto</font> afterspill; <br> } <br> <font color="#8080ff">//   :   ?</font> <br> yyerror( <font color="#ff6060">"don't know how to proceed"</font> ); <br> } <br> <font color="#8080ff">//   ; </font> <br> foreach(i, pcode) { <br> i-&gt;cmd.dest = physmap[i-&gt;cmd.dest]; <br> <font color="#800000">if</font> (has2src(i)) { <br> i-&gt;cmd.src1 = physmap[i-&gt;cmd.src1]; <br> i-&gt;cmd.src2 = physmap[i-&gt;cmd.src2]; <br> } <br> } <br> <font color="#800000">break</font> ; <br> <br> <font color="#800000">afterspill</font> : <font color="#8080ff">// -  " "</font> <br> } <br></code> <br>  Without going into how exactly we poured the register, it is worth mentioning that the code above has a lot of problems.  First, heuristics work only in the simplest cases;  more common situations like <pre>    ...
 10 need r1, r2, r3, r4
    ...
 20 need r1, r3, r4, r5
    ...
 30 need r2, r3, r4, r5
    ...
</pre>  The <code>r5</code> lacks the physical, because all the physical ones were spent on <code>r1,r2,r3,r4</code> ;  but there is not a single command where all five registers are needed at the same time. <br><br>  A tougher problem is that each spout clogs the program with useless <code>store/load</code> pairs, and they need to be cleaned - otherwise the registers used in them create enough ‚Äúnoise‚Äù so that the registers are not enough for anything else. <br><br>  Another idea: a hole in the lifetime caused by the outflow can divide the original n-register into two independent ‚Äúversions‚Äù that can be placed in different physical registers.  For the sake of the flexibility of our system, it is necessary to implement the splitting of versions: then with each iteration of the external cycle, the lifetimes of the registers will be reduced, and it will become easier and simpler to distribute physical ones to them. <br><br>  And, since we went to remove the extra <code>load</code> and <code>store</code> , we will also remove other extra commands at the same time.  Given that our p-code operations have no other side effects, other than calculating the register with the result, you can delete commands whose result is not alive at the output.  Maybe the programmer assigned the value of an unused variable, or used an operator like <code>(2+2);</code> <br>  We delete everything - so we will delete the unreachable code to the heap (for example, jz after hlt), and compress the chains of jumps (we will replace the jump for the jump with one jump). <br><br>  To remove a command, in order not to look for and fix all jumps on it, it is convenient to replace it with <code>nop</code> ;  as it, let's assign an unconditional jump to the next command ( <code>jz r00, +0</code> ).  The benefit is that at the next iteration, the jump to <code>nop</code> shrink along the chain, and the <code>nop</code> itself will be cleaned up as an unreachable command. <br><br><h3>  Simple optimizations </h3><br>  To detect unreachable commands we use depth traversal;  to keep track of which teams have already bypassed, add a new <code>int reachcnt;</code> field to the <code>struct commandn</code> <code>int reachcnt;</code> <br>  A boolean field would be enough for us;  but the ‚Äúdegree of approach‚Äù of each team may still be useful sometime later. <br> <code><font color="#008000">void</font> markReachable(pcommandn cmd) { <br> <font color="#808000">while</font> (!cmd-&gt;reachcnt++) { <br> <font color="#808000">if</font> (cmd-&gt;cmd.opcode==command::jz) <br> markReachable(cmd-&gt;tgt); <br> <font color="#808000">if</font> (hasnext(cmd)) <br> cmd++; <br> <font color="#808000">else</font> <br> <font color="#808000">break</font> ; <br> } <br> } <br> <br> <font color="#008000">void</font> nopOut(pcommandn cmd) { <br> pcommandn next = cmd; next++; <br> cmd-&gt;cmd = command(command::jz, <font color="#ff6060">0</font> , <font color="#ff6060">0</font> ); <br> cmd-&gt;tgt = next; <br> } <br> <br> <font color="#008000">void</font> simpleopt() { <br> <font color="#8080ff">//   </font> <br> foreach(i, pcode) <br> <font color="#808000">if</font> (i-&gt;cmd.opcode==command::jz) <br> <font color="#808000">while</font> (i-&gt;tgt-&gt;cmd.opcode==command::jz &amp;&amp; !i-&gt;tgt-&gt;cmd.dest) <br> i-&gt;tgt = i-&gt;tgt-&gt;tgt; <br> <font color="#8080ff">//   </font> <br> foreach(i, pcode) i-&gt;reachcnt = <font color="#ff6060">0</font> ; <br> markReachable(pcode.begin()); <br> foreach2(i, pcode, next) <br> <font color="#808000">if</font> (!i-&gt;reachcnt) <br> pcode.erase(i); <br> <font color="#8080ff">//   nop:      </font> <br> foreach2(i, pcode, next) <br> <font color="#808000">if</font> (i-&gt;cmd.opcode==command::jz &amp;&amp; <br> !i-&gt;cmd.dest &amp;&amp; i-&gt;tgt==next) <br> pcode.erase(i); <br> } <br> <br> <font color="#8080ff">//      :</font> <br> simpleopt(); <br> <font color="#8080ff">//     </font> <br> liveness(); <br> <font color="#008000">bool</font> changed = <font color="#ff6060">false</font> ; <br> foreach(i, pcode) <br> <font color="#808000">if</font> (writesdest(i) &amp;&amp; !contains(i-&gt;onexit, i-&gt;cmd.dest)) { <br> nopOut(i); <br> changed = <font color="#ff6060">true</font> ; <br> } <br> <font color="#808000">if</font> (changed) <font color="#808000">continue</font> ; <br> <font color="#8080ff">//  </font> <br> <font color="#8080ff">// ...</font> <br></code> <br><br><h3>  Version splitting </h3><br>  If there is a gap in the ‚Äúinterval of use‚Äù of the register, i.e.  a value from one command set never penetrates another set ‚Äî it means that a register can be ‚Äúsplit‚Äù into a couple of registers with shorter lifetimes. <br>  To isolate the unbroken fragments from the lifetimes, another graph algorithm is useful: the search for connected components. <br>  We strive more for code clarity than for its effectiveness;  therefore, we have pvg inside pvg, and the merging of components is performed by traversing the entire graph. <br><br>  The <code>struct commandn</code> will require another field, the last for today: <code>std::map&lt;regnum,regnum&gt; version;</code> <br>  In it we will store for each match command ‚Äún-register -&gt; version number‚Äù. <br>  If the register in the command is used, but there is still no correspondence in <code>version</code> , it means that the detour has not yet reached this command. <br>  For the external pvg, in order not to start a new field, we use the same <code>reachcnt</code> as in <code>markReachable()</code> <br> <code>std::map&lt;regnum,regnum&gt; renameto; <font color="#8080ff">//   </font> <br> <br> <font color="#008000">void</font> versionizeReg(pcommandn cmd, regnum r, regnum rv) <font color="#ff40ff">{</font> <font color="#8080ff">//  r  rv   </font> <br> <font color="#808000">while</font> (!contains(cmd- <font color="#808000">&gt;</font> version, r) &amp;&amp; <br> (contains(cmd- <font color="#808000">&gt;</font> onenter, r) || contains(cmd- <font color="#808000">&gt;</font> onexit, r))) <font color="#ff40ff">{</font> <br> <font color="#8080ff">// </font> <br> cmd- <font color="#808000">&gt;</font> version[r] = renameto[rv]; <br> <font color="#808000">if</font> (cmd- <font color="#808000">&gt;</font> cmd.dest==r) cmd- <font color="#808000">&gt;</font> cmd.dest=renameto[rv]; <br> <font color="#808000">if</font> (has2src(cmd)) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (cmd- <font color="#808000">&gt;</font> cmd.src1==r) cmd- <font color="#808000">&gt;</font> cmd.src <font color="#ff6060">1</font> =renameto[rv]; <br> <font color="#808000">if</font> (cmd- <font color="#808000">&gt;</font> cmd.src2==r) cmd- <font color="#808000">&gt;</font> cmd.src <font color="#ff6060">2</font> =renameto[rv]; <br> <font color="#ff40ff">}</font> <br> <font color="#808000">if</font> (!contains(cmd- <font color="#808000">&gt;</font> onexit,r)) <font color="#808000">return</font> ; <font color="#8080ff">//   </font> <br> <font color="#808000">if</font> (cmd- <font color="#808000">&gt;</font> cmd.opcode==command::jz &amp;&amp; <br> contains(cmd- <font color="#808000">&gt;</font> tgt- <font color="#808000">&gt;</font> onenter, r)) <font color="#ff40ff">{</font> <br> versionizeReg(cmd- <font color="#808000">&gt;</font> tgt, r, rv); <br> <font color="#ff40ff">}</font> <br> <font color="#808000">if</font> (hasnext(cmd)) <font color="#ff40ff">{</font> <br> cmd++; <br> <font color="#808000">if</font> (contains(cmd- <font color="#808000">&gt;</font> onenter, r)) <br> <font color="#808000">continue</font> ; <br> <font color="#ff40ff">}</font> <br> <font color="#808000">return</font> ; <font color="#8080ff">//   </font> <br> <font color="#ff40ff">}</font> <br> <font color="#8080ff">//    ?</font> <br> <font color="#808000">if</font> (contains(cmd- <font color="#808000">&gt;</font> version, r) &amp;&amp; cmd- <font color="#808000">&gt;</font> version[r]!=renameto[rv]) <font color="#ff40ff">{</font> <br> <font color="#8080ff">//  renameto[rv]  cmd-&gt;version[r]</font> <br> regnum from = std::max(cmd- <font color="#808000">&gt;</font> version[r], renameto[rv]), <br> to = std::min(cmd- <font color="#808000">&gt;</font> version[r], renameto[rv]); <br> renameto[from] = to; <br> foreach(i, pcode) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (i- <font color="#808000">&gt;</font> cmd.dest==from) i- <font color="#808000">&gt;</font> cmd.dest = to; <br> <font color="#808000">if</font> (has2src(i)) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (i- <font color="#808000">&gt;</font> cmd.src1==from) i- <font color="#808000">&gt;</font> cmd.src <font color="#ff6060">1</font> = to; <br> <font color="#808000">if</font> (i- <font color="#808000">&gt;</font> cmd.src2==from) i- <font color="#808000">&gt;</font> cmd.src <font color="#ff6060">2</font> = to; <br> <font color="#ff40ff">}</font> <br> <font color="#808000">if</font> (contains(i- <font color="#808000">&gt;</font> version, r) &amp;&amp; i- <font color="#808000">&gt;</font> version[r]==from) <br> i- <font color="#808000">&gt;</font> version[r] = to; <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">}</font> <br> <br> <font color="#008000">void</font> versionize(pcommandn cmd) <font color="#ff40ff">{</font> <br> <font color="#808000">while</font> (!cmd- <font color="#808000">&gt;</font> reachcnt++) <font color="#ff40ff">{</font> <br> <font color="#8080ff">// versionize registers that live on exit</font> <br> foreach(r, cmd- <font color="#808000">&gt;</font> onexit) <br> <font color="#808000">if</font> (!contains(cmd- <font color="#808000">&gt;</font> version, *r)) <font color="#ff40ff">{</font> <br> regnum rv = newreg(); <br> renameto[rv] = rv; <br> versionizeReg(cmd, *r, rv); <br> <font color="#ff40ff">}</font> <br> <font color="#808000">if</font> (cmd- <font color="#808000">&gt;</font> cmd.opcode==command::jz) <br> versionize(cmd- <font color="#808000">&gt;</font> tgt); <br> <font color="#808000">if</font> (hasnext(cmd)) <br> cmd++; <br> <font color="#808000">else</font> <br> <font color="#808000">break</font> ; <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">}</font> <br> <br> <font color="#8080ff">//  :</font> <br> foreach(i, pcode) <font color="#ff40ff">{</font> <br> i- <font color="#808000">&gt;</font> version.clear(); <br> i- <font color="#808000">&gt;</font> reachcnt = <font color="#ff6060">0</font> ; <br> <font color="#ff40ff">}</font> <br> renameto.clear(); <br> <font color="#008000">int</font> lastbasereg = lastreg; <br> versionize(pcode.begin()); <br> <font color="#8080ff">//  ,    1</font> <br> foreach(i, pcode) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (i- <font color="#808000">&gt;</font> cmd.dest) i- <font color="#808000">&gt;</font> cmd.dest-=lastbasereg; <br> <font color="#808000">if</font> (has2src(i)) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (i- <font color="#808000">&gt;</font> cmd.src1) i- <font color="#808000">&gt;</font> cmd.src <font color="#ff6060">1</font> -=lastbasereg; <br> <font color="#808000">if</font> (i- <font color="#808000">&gt;</font> cmd.src2) i- <font color="#808000">&gt;</font> cmd.src <font color="#ff6060">2</font> -=lastbasereg; <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">}</font> <br> lastreg -= lastbasereg; <br></code> <br>  It remains to implement the actual register outflow.  Let us concretize the heuristics: you can pour out any register that is alive, but the command is not used. <br> <code>regnum spillable(pcommandn cmd) { <font color="#8080ff">//  ,   </font> <br> aliveset alive; <br> alive.insert(cmd-&gt;onenter.begin(), cmd-&gt;onenter.end()); <br> alive.insert(cmd-&gt;onexit.begin(), cmd-&gt;onexit.end()); <br> alive.erase(cmd-&gt;cmd.dest); <br> <font color="#808000">if</font> (has2src(cmd)) { <br> alive.erase(cmd-&gt;cmd.src1); <br> alive.erase(cmd-&gt;cmd.src2); <br> } <br> <font color="#808000">if</font> (!alive.size()) <font color="#808000">return</font> <font color="#ff6060">0</font> ; <br> <font color="#808000">return</font> *alive.begin(); <br> } <br></code> <br>  In a separate <code>map</code> we will store by register number the ‚Äúaddress‚Äù of its copy in memory so that all register outflows fall into the same place.  The address is assigned to the register only at the moment of the first flood. <br> <code><font color="#8080ff">// spill slots</font> <br> std::map&lt;regnum, <font color="#008000">int</font> &gt; spill; <br> <font color="#008000">int</font> lastspill = <font color="#ff6060">0</font> ; <br> <br> <font color="#008000">void</font> spillAt(pcommandn cmd, regnum victim, pcommandn next) { <br> <font color="#8080ff">//  /  </font> <br> <font color="#008000">int</font> spslot = spill[victim]; <br> <font color="#808000">if</font> (!spslot) { <br> spslot = ++lastspill; <br> spill[victim] = spslot; <br> } <br> <font color="#8080ff">//  store   load </font> <br> pcommandn me = pcode.insert(next, *cmd); <br> cmd-&gt;cmd = command(command::store, victim, spslot); <br> commandn load(command(command::load, victim, spslot)); <br> <font color="#808000">if</font> (hasnext(me)) <br> pcode.insert(next, load); <br> <font color="#808000">if</font> (me-&gt;cmd.opcode==command::jz) <br> me-&gt;tgt = pcode.insert(me-&gt;tgt, load); <br> } <br></code> <br>  Since the team is replaced with the <code>store-cmd-load</code> troika, it is necessary that the existing jumps on the team jump to the <code>store</code> inserted in front of it.  In order not to look for such jumps throughout the code, we insert the <code>cmd</code> copy with the <i>following</i> command, and then replace the <i>original</i> command with the <code>store</code> . <br>  Similarly, if the command is a conditional transition, then it is necessary that the <code>load</code> executed on both outcomes;  therefore, we add it to the next command, and insert it in front of the goal of the jump. <br><br>  (It is a bit annoying that because of the possibility of moving teams from one <code>commandn</code> to another, we will have to associate the lines for <code>echo</code> with the commands themselves by ‚Äúidentifier‚Äù, as in the first tree implementation: neither command indices nor pointers remain unchanged.) <br><br>  The second heuristics: if you could not find a team that has all the physical registers in, then take the physical register that ‚Äúbest fits‚Äù (least of all collisions with already assigned registers) and try to release it wherever it is needed, but busy . <br> <code><font color="#8080ff">//   .   - ‚Ññr</font> <br> regnum victim; <br> <font color="#8080ff">//  1:  ,     </font> <br> foreach2(i, pcode, next) <br> <font color="#808000">if</font> ((i-&gt;cmd.opcode!=command::load &amp;&amp; i-&gt;cmd.opcode!=command::store) &amp;&amp; <br> ((contains(i-&gt;onenter, r) &amp;&amp; i-&gt;onenterp.size()==lastp) || <br> (contains(i-&gt;onexit, r) &amp;&amp; i-&gt;onexitp.size()==lastp))) { <br> victim = spillable(i); <br> assert(victim); <br> spillAt(i, victim, next); <br> <font color="#808000">goto</font> afterspill; <br> } <br> <font color="#8080ff">//  2:  " " </font> <br> physreg bestfit = (physreg)(std::max_element(collisions.begin(), collisions.end())-collisions.begin()+ <font color="#ff6060">1</font> ); <br> foreach2(i, pcode, next) <br> <font color="#808000">if</font> ((i-&gt;cmd.opcode!=command::load &amp;&amp; i-&gt;cmd.opcode!=command::store) &amp;&amp; <br> ((contains(i-&gt;onenter, r) &amp;&amp; contains(i-&gt;onenterp, bestfit)) || <br> (contains(i-&gt;onexit, r) &amp;&amp; contains(i-&gt;onexitp, bestfit))) &amp;&amp; <br> (victim = spillable(i))) { <br> spillAt(i, victim, next); <br> <font color="#808000">goto</font> afterspill; <br> } <br> yyerror( <font color="#ff6060">"don't know how to proceed"</font> ); <br></code> <br>  When splitting versions, you need to remember to copy the slot number (all versions of one register are stored in one slot), and then, when renaming versions, remember to update the <code>spill</code> . <br><br>  The compiler is almost working;  The last problem is that a bunch of useless <code>load</code> and <code>store</code> is generated, and because of them there are no registers left for meaningful commands. <br><br><h3>  Work with memory </h3><br>  First, it may turn out that some registers are used exclusively in <code>load/store</code> commands <code>load/store</code> <br>  Such commands are useless: the register is always written in the same slot from which it was read. <br>  Let's insert cleaning after splitting versions: there we should have just got a lot of registers with a short lifetime. <br> <code><font color="#8080ff">//   </font> <br> std::vector&lt; <font color="#008000">bool</font> &gt; used(lastreg+ <font color="#ff6060">1</font> ); <br> foreach(i, pcode) { <br> <font color="#808000">if</font> (writesdest(i) &amp;&amp; i-&gt;cmd.opcode!=command::load) <br> used[i-&gt;cmd.dest] = <font color="#ff6060">true</font> ; <br> <font color="#808000">if</font> (readsdest(i) &amp;&amp; i-&gt;cmd.opcode!=command::store) <br> used[i-&gt;cmd.dest] = <font color="#ff6060">true</font> ; <br> <font color="#808000">if</font> (has2src(i)) { <br> used[i-&gt;cmd.src1] = <font color="#ff6060">true</font> ; <br> used[i-&gt;cmd.src2] = <font color="#ff6060">true</font> ; <br> } <br> } <br> foreach(i, pcode) <br> <font color="#808000">if</font> ((i-&gt;cmd.opcode==command::load &amp;&amp; !used[i-&gt;cmd.dest]) || <br> (i-&gt;cmd.opcode==command::store &amp;&amp; !used[i-&gt;cmd.dest])) <br> nopOut(i); <br></code> <br>  Secondly, if we have chains of identical <code>load</code> , then everything except the last one will be deleted because the read register is not alive.  But if we have chains of the same <code>store</code> , then to remove them you need to come up with something new.  The algorithm is very similar to the iterative determination of the need for registers, only now we define ‚Äúunpreserved‚Äù - in order to clear all the saved registers already saved. <ul><li>  the register is not stored in the command that <i>sets</i> its value; </li><li>  if from team A you can go to B (directly or by jumping), and the register is not saved in A, then it is not saved in B either; </li><li>  the register is stored in a command that <i>saves</i> its value. </li></ul>  We see that this algorithm differs from the previous one only in the direction of propagation: the need spreads from each command to the previous ones, and the non-conserved - to the subsequent ones. <br>  In general, the iterative algorithm for calculating the sets of registers at each point of the program is called <i>data flow analysis</i> , and applies, in addition to the two mentioned, and for many other optimizations. <br><br> <code><font color="#008000">void</font> unsaved() { <br> <font color="#008000">bool</font> changed = <font color="#ff6060">false</font> ; <br> <font color="#8080ff">// rule 1</font> <br> foreach(i, pcode) { <br> i-&gt;onenter = i-&gt;onexit = aliveset(); <br> <font color="#808000">if</font> (writesdest(i)) { <br> i-&gt;onexit.insert(i-&gt;cmd.dest); <br> changed = <font color="#ff6060">true</font> ; <br> } <br> } <br> <font color="#808000">while</font> (changed) { <br> changed = <font color="#ff6060">false</font> ; <br> foreach2(i, pcode, next) { <br> <font color="#008000">int</font> oldsize = i-&gt;onenter.size()+i-&gt;onexit.size(); <br> <font color="#8080ff">// rule 2 (next command)</font> <br> <font color="#808000">if</font> (hasnext(i)) <br> next-&gt;onenter.insert(i-&gt;onexit.begin(), i-&gt;onexit.end()); <br> <font color="#8080ff">// rule 2 (jmp target)</font> <br> <font color="#808000">if</font> (i-&gt;cmd.opcode==command::jz) <br> i-&gt;tgt-&gt;onenter.insert(i-&gt;onexit.begin(), i-&gt;onexit.end()); <br> <font color="#8080ff">// rule 3</font> <br> i-&gt;onexit.insert(i-&gt;onenter.begin(), i-&gt;onenter.end()); <br> <font color="#808000">if</font> (i-&gt;cmd.opcode==command::store) <br> i-&gt;onexit.erase(i-&gt;cmd.dest); <br> <br> <font color="#808000">if</font> (i-&gt;onenter.size()+i-&gt;onexit.size() != oldsize) <br> changed = <font color="#ff6060">true</font> ; <br> } <br> } <br> } <br> <br> <font color="#808000">afterspill</font> : <font color="#8080ff">// -  " "</font> <br> unsaved(); <br> foreach(i, pcode) <br> <font color="#808000">if</font> (i-&gt;cmd.opcode==command::store &amp;&amp; !contains(i-&gt;onenter, i-&gt;cmd.dest)) <br> nopOut(i); <br> } <br></code> <br><br><h3>  What happened? </h3><br>  All compiler together: <a href="http://tyomitch.net.ru/jsk.y.regs.html">tyomitch.net.ru/jsk.y.regs.html</a> <br>  Of the five hundred lines, only one-fifth is part of the parsing.  Indeed, it seems that, compared to the labor costs for the rest of the compiler, the parser is an uninteresting little thing on the side.  But this is only because the creation of parsers is sucked to the bone, and we can only use the ready;  whereas when processing the code, there is more room for fiction. <br><br>  As a result of the assignment of registers and first optimizations, the generated code was lengthened by just a couple of commands: <br><pre> 00 mov r01, 0
 01 mov r02, 0x3e8
 02 echo 0x12e
 03 echo r01
 04 echo 0xa8
 05 echo r02
 06 echo 0xaf
 07 le r03, r01, r02
 08 jz r03, + 0x1f (= 0x28)
 09 add r03, r01, r02
 0a mov r04,2
 0b div r03, r03, r04
 0c echo 0x16a
 0d echo r03
 0e echo 0xd4
 0f input r04
 10 store r01, 1
 11 mov r01, 1
 12 eq r01, r04, r01
 13 jz r01, +5 (= 0x19)
 14 load r01, 1
 15 mov r02, 1
 16 sub r02, r03, r02
 17 add r02, r02, 0
 18 jz 0, -0x12 (= 0x7)
 19 mov r01,2
 1a eq r01, r04, r01
 1b jz r01, +4 (= 0x20)
 1c mov r01, 1
 1d add r01, r03, r01
 1e add r01, r01, 0
 1f jz 0, -0x19 (= 0x7)
 20 load r01, 1
 21 mov r03, 3
 22 eq r03, r04, r03
 23 jz r03, +2 (= 0x26)
 24 echo 0x14e
 25 hlt
 26 echo 0x172
 27 jz 0, -0x21 (= 7)
 28 echo 0x107
 29 hlt
</pre><br>  But since only four registers are used, this p-code will probably be translated into machine code of a real processor. <br><br>  We will continue in August: I am leaving for vacation, and I finish this post directly from the airport. <br>  Have a nice summer everyone! </div><p>Source: <a href="https://habr.com/ru/post/99595/">https://habr.com/ru/post/99595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99584/index.html">Nokia began searching for a new CEO</a></li>
<li><a href="../99589/index.html">ASP.NET MVC: My Rules for Views</a></li>
<li><a href="../99590/index.html">Droider Chart. Release 10</a></li>
<li><a href="../99592/index.html">Compilation. 6: intermediate code</a></li>
<li><a href="../99594/index.html">Electrons in silicon dispersed to 0.3% of the speed of light</a></li>
<li><a href="../99597/index.html">ITrack's CMS Rating - Results of Distribution of Market Shares for the II Quarter of 2010</a></li>
<li><a href="../99598/index.html">Vim 7.3 public beta released</a></li>
<li><a href="../99599/index.html">HP has applied for registration of the trademark "PALMPAD"</a></li>
<li><a href="../99600/index.html">Sharp eBooks will be available this year.</a></li>
<li><a href="../99603/index.html">Cyrillization of the domains .com.ua and .kiev.ua is postponed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>