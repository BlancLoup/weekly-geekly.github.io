<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Switch for strings in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, the C ++ standard does not allow the use of switch-case operators to string constants. Although in other languages, like C #, there is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Switch for strings in C ++ 11</h1><div class="post__text post__text-html js-mediator-article">  Unfortunately, the C ++ standard does not allow the use of switch-case operators to string constants.  Although in other languages, like C #, there is such a possibility right out of the box.  Therefore, of course, many C ++ programmers have tried to write their own version of ‚Äúswitch for strings‚Äù - and I am not an exception. <br>  For C ++ 03, the solutions did not differ in beauty and only complicated the code, additionally loading the application in runtime.  However, with the advent of C ++ 11, it finally became possible to implement such code: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> month; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> days; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Enter month name: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; month; SWITCH (month) { CASE(<span class="hljs-string"><span class="hljs-string">"february"</span></span>): days = <span class="hljs-string"><span class="hljs-string">"28 or 29"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; CASE(<span class="hljs-string"><span class="hljs-string">"april"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"june"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"september"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"november"</span></span>): days = <span class="hljs-string"><span class="hljs-string">"30"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; CASE(<span class="hljs-string"><span class="hljs-string">"january"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"march"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"may"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"july"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"august"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"october"</span></span>): CASE(<span class="hljs-string"><span class="hljs-string">"december"</span></span>): days = <span class="hljs-string"><span class="hljs-string">"31"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; DEFAULT: days = <span class="hljs-string"><span class="hljs-string">"?"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; month &lt;&lt; <span class="hljs-string"><span class="hljs-string">" has "</span></span> &lt;&lt; days &lt;&lt; <span class="hljs-string"><span class="hljs-string">" days."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  The implementation of this design is very simple.  It is based on constexpr-functions from C ++ 11, due to which almost all calculations are performed at the compilation stage.  If someone is interested in its details, welcome under the cut - the benefit of Habr√© says nothing about the ‚Äúswitch for strings‚Äù. <br><a name="habracut"></a><br><br><h2>  What do we want? </h2><br>  First of all, it should be a full-fledged <b>switch</b> , and not its ‚Äúemulation‚Äù by hiding <b>if-</b> operators and functions for comparing strings inside macros, since comparing strings in runtime is an expensive operation, and it is too wasteful for each row from CASE.  Therefore, <a href="http://ghodbane.web.cern.ch/ghodbane/tpc/doc/html/string__switch_8h-source.html">this solution</a> does not suit us - besides, incomprehensible macros like END_STRING_SWITCH inevitably appear in it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, it is very desirable to use the compiler to the maximum.  For example, what will happen to the ‚Äúnormal‚Äù switch-case in the case when the arguments of two <b>cases</b> turn out to be the same?  That's right, the compiler will immediately curse us: <i>‚Äúduplicate case value‚Äù</i> , and stop compiling.  And in the example of the above link, of course, no compiler will be able to notice this error. <br><br>  The final syntax is also important, simple and without unnecessary constructions.  That is why the <a href="http://www.codeguru.com/cpp/cpp/cpp_mfc/article.php/c4067/Switch-on-Strings-in-C.htm">well-known version of</a> " <b>std :: map</b> with a string key" does not suit us either: firstly, the <b>case</b> arguments in it do not look vivid - and secondly, it requires mandatory initialization of the used <b>std :: map</b> in runtime.  The function of this initialization can be anywhere, constantly looking into it is too tiring. <br><br><br><h2>  We start to calculate the hash </h2><br>  The last option remains: calculate the hash of the string in the <b>switch</b> , and compare it with the hash of each string in the <b>case</b> .  That is, it all comes down to comparing two integers for which the switch-case works great.  However, the C ++ standard says that the argument of each <b>case</b> should be known when compiling - therefore, the function ‚Äúcalculate hash from a string‚Äù should work in compile-time.  In C ++ 03, it can only be implemented using templates, like the CRC calculation in <a href="http://habrahabr.ru/post/38622/">this article</a> .  But in C ++ 11, fortunately, there appeared clearer <b>constexpr</b> functions, the values ‚Äã‚Äãof which can also be computed by the compiler. <br><br>  So, we need to write a constexpr-function, which would operate with numeric codes of <b>char-</b> symbols.  As you know, the body of such a function is " <b>return</b> <i>&lt;an expression&gt; known in compile-time&gt;</i> ".  Let us try to implement its most ‚Äúdegenerate‚Äù version, namely, the function of calculating the length of the <b>const char *</b> string.  But here the first difficulties await us: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str_len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *str ? (<span class="hljs-number"><span class="hljs-number">1</span></span> + str_len(str + <span class="hljs-number"><span class="hljs-number">1</span></span>)) : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) str_len(<span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) str_len(<span class="hljs-string"><span class="hljs-string">""</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br>  The compiler does not swear, the function is correct.  However, for some reason she didn‚Äôt bring me ‚Äú6 6‚Äù, but ‚Äú6 12‚Äù.  Why so?  And the thing is that I typed this source code under Windows in the ‚ÄúLinux‚Äù encoding of UTF-8, and not in the standard Win-1251 - and therefore each ‚ÄúCyrillic‚Äù character was perceived as two.  Now, if you change the encoding to the standard one, then "6 6" is really displayed.  Well, it turns out, our idea failed?  After all, this is not the case when, with different encodings, different hashes are obtained ... <br><br><br><h2>  We check the contents of the line </h2><br>  But why do we need Cyrillic or Asian characters?  In the overwhelming majority of cases, for source codes, only English letters and standard punctuation marks are sufficient - that is, characters that fit in the range from 0 to 127 in the <a href="http://ru.wikipedia.org/wiki/ASCII">ASCII table</a> .  And their <b>char-</b> codes will not change when changing the encoding - and therefore the hash from the string composed only of them will <i>always</i> be the same.  But what if the programmer accidentally enters one of these characters?  The following compile-time function comes to the rescue: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str_is_correct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(*str) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? str_is_correct(str + <span class="hljs-number"><span class="hljs-number">1</span></span>) : (*str ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  It checks whether the string known at the compilation stage contains only characters from the range 0-127, and returns <b>false</b> if the "forbidden" character is found.  Why do I need a forced caste to <b>signed char</b> ?  The fact is that in the C ++ standard it is not defined what exactly the type is <b>char</b> - it can be either signed or unsigned.  But its <b>sizeof</b> will always be equal to 1, which is why we shift to the right by one.  Thus, the CASE macro we need will look like: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CASE(str) static_assert(str_is_correct(str), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CASE string contains wrong characters"</span></span></span><span class="hljs-meta">);\ case str_hash(...)</span></span></code> </pre><br>  Here one more feature of C ++ 11 is used - <b>assert</b> when compiling.  That is, if the string argument of the CASE macro contains at least one ‚Äúforbidden‚Äù character, the compilation will stop with an understandable error.  Otherwise, the hash will be calculated, the value of which will be substituted in the <b>case</b> .  This solution will save us from problems with the encoding.  It remains only to write the function str_hash () itself, which will calculate the desired hash. <br><br><br><h2>  Go back to the hash calculation </h2><br>  You can choose a hash function in different ways, and the most important question here is the possibility of collisions.  If the hashes of the two different strings match, then the program can jump to the false <b>case</b> with the <b>switch</b> .  And the satellite will fall into the ocean ... Therefore, we will use the hash function, which has no collisions at all.  Since it is already established that all characters of the string are in the range of 0-127, the function will be: <img src="http://habrastorage.org/storage2/b23/466/cd3/b23466cd30101e0e6abeb30c6d615f01.png" alt="image">  .  Its implementation is as follows: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> uchar; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ullong; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> ullong </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uchar current_len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *str ? (raise_128_to(current_len - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;uchar&gt;(*str) + str_hash(str + <span class="hljs-number"><span class="hljs-number">1</span></span>, current_len - <span class="hljs-number"><span class="hljs-number">1</span></span>)) : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Here raise_128_to () is the compile-time function of raising 128 to the power, and <b>current_len</b> is the length of the current line.  Of course, the length can be calculated at each recursion step, but this will only slow down the compilation - it is better to count it before the first run of str_hash (), and then always substitute it as an additional argument.  For what is the maximum length of the string, this function will not have collisions?  Obviously, only when the value obtained by it always fits in the range of the <b>unsigned long long type</b> (also finally entered in C ++ 11), that is, if it does not exceed 2 <sup>64</sup> -1. <br><br>  It can be calculated that this maximum length will be equal to 9 (we denote this number as MAX_LEN).  But the maximum possible hash value will be exactly 2 <sup>63</sup> for a string, all characters of which have code 127 (and <a href="http://mmb.mediachance.com/mmbhelp/ru/index.html%3Fasciitable.htm">are unreadable</a> in ASCII, so under CASE we will not chase it anyway).  But what if under CASE will be a string of 10 characters?  If we really don‚Äôt want the occurrence of collisions, then we need to prohibit this possibility as well - that is, extend the <b>static_assert</b> we already use: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CASE(str) static_assert(str_is_correct(str) &amp;&amp; (str_len(str) &lt;= MAX_LEN),\ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CASE string contains wrong characters, or its length is greater than 9"</span></span></span><span class="hljs-meta">);\ case str_hash(str, str_len(str))</span></span></code> </pre><br><br><h2>  Make final touches </h2><br>  Everything with the CASE macro is over.  It will either give us a compilation error, or calculate a unique hash value.  Here for calculating the hash in the SWITCH macro, we will have to make a separate function, since it will work in runtime.  And if its argument string has a length of more than 9 characters, then we agree to return 2 <sup>64</sup> -1 (we denote this number as N_HASH).  So: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SWITCH(str) switch(str_hash_for_switch(str)) const ullong N_HASH = static_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ullong&gt;(-1); //    std::string::npos inline ullong str_hash_for_switch(const char* const str) { return (str_is_correct(str) &amp;&amp; (str_len(str) &lt;= MAX_LEN)) ? str_hash(str, str_len(str)) : N_HASH; }</span></span></span></span></code> </pre><br>  Actually, that's all.  In runtime, the hash for the string in SWITCH is calculated, and if one row in CASE has the same hash, the execution will go to it.  If any string from CASE contains ‚Äúforbidden‚Äù characters, or its length is more than 9 characters, we will get a reliable compilation error.  There is almost no load in runtime (except for a single hash calculation for SWITCH), the readability of the code does not suffer.  It remains only to overload the str_hash_for_switch () function for <b>std :: string</b> , and conclude everything inside the namespace. <br><br>  The final h-file of source codes <a href="">lies on Gitkhab</a> .  It is suitable for any compiler with C ++ 11 support.  To use ‚Äúswitch for strings‚Äù, simply turn on <i>str_switch.h</i> wherever you want, and that‚Äôs all - the SWITCH, CASE and DEFAULT macros are in front of you.  Do not forget about the limit on the length of the string in CASE (9 characters). <br>  In general, I hope that this implementation will be useful to somebody;) <br><br>  <b>PS</b> <i>Upd:</i> a couple of inaccuracies were found in the code - so now it has been updated, along with the article.  The comments also suggested using another function to calculate the hash - of course, everyone can write their own implementation. </div><p>Source: <a href="https://habr.com/ru/post/166201/">https://habr.com/ru/post/166201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166179/index.html">Meet the long-awaited plugins.jquery.com</a></li>
<li><a href="../166185/index.html">Well, Centos 5.9 was released</a></li>
<li><a href="../166187/index.html">Lenovo launches Chromebook for schools based on ThinkPad X131E</a></li>
<li><a href="../166197/index.html">Internet access in difficult administrative conditions</a></li>
<li><a href="../166199/index.html">Ask a question to the driver of a mars rover</a></li>
<li><a href="../166205/index.html">Creating a map cache in Geoserver using third-party services</a></li>
<li><a href="../166207/index.html">Unified Communication Center - Imo.im</a></li>
<li><a href="../166211/index.html">Control of employee access to cloud servers</a></li>
<li><a href="../166213/index.html">iOS developer: Book review for beginner</a></li>
<li><a href="../166215/index.html">Geocoding addresses into coordinates and geolocation of your current location in OpenLayers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>