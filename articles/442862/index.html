<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proof-of-Stake: Inside View</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many philistine articles and discussions on the Internet, but there is not enough information on the merits. At a certain moment, it became ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Proof-of-Stake: Inside View</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/yj/8k/rq/yj8krqpp54tlsgp9p1vupdz-ofi.jpeg"></p><br><blockquote>  There are many philistine articles and discussions on the Internet, but there is not enough information on the merits.  At a certain moment, it became clear to the author that the mechanics and the many safety related nuances are not completely understood even by many cryptocurrency developers.  This was revealed in the real case of porting the implementation of PoS for one of the cryptocurrencies and in further publishing information about the vulnerabilities found by third-party experts. </blockquote><p>  This article will be useful to all developers who have already encountered PoS vulnerabilities or who are still to come. </p><br><p>  Horror under the cut. </p><a name="habracut"></a><br><h2 id="krupica-istorii">  Bit of history </h2><br><p> The birth of the Proof-of-Stake (PoS) in Peercoin after the discussion at one of the forums in 2011, the subsequent use of the Novaoin and further distribution in the PIVX and other Bitcoin forks is traced on the Internet.  The rather primitive PoS-logic was brought to the module <code>kernel.h</code> / <code>kernel.cpp</code> , which wanders through forks in the form of various Frankensteins. </p><br><p>  The PoS algorithm has gone through several stages of development, someone gives them versions.  Now the PoS options are divided for natural reasons, DPoS appeared.  One of the most advanced solutions is the Casper protocol in Ethereum. </p><br><p>  Any blockchain needs block generation and for someone there must be the right to build a new block.  If the author does this in a blockchain like the Git version control system without much competition, then in cryptocurrencies there is a fierce struggle for the block reward within the Proof-of-Work (PoW) - finding such a combination of variable input parameters by selecting deterministic target (mining, mining). </p><br><p>  PoS replaces Proof-of-Work (PoW) in order to avoid wasting resources on mining.  Instead, all input parameters are strictly set with a constant characteristic based on the existing savings of the coin holders.  Therefore, PoW is required as a starting point for PoS, if you do not resort to different variants of the initial pledged enrichment of the coin's creators. </p><br><h2 id="zachem">  What for? </h2><br><p>  Saving energy is about as important for developers and coin holders as limiting greenhouse gas emissions for producers and consumers.  Cruel truth in another: </p><br><ol><li>  PoW-based projects are subject to so-called.  "51 percent attacks": attackers can throw more power, create a parallel chain, and then suddenly publish it with a different movement of coins on the accounts (ie, double waste) </li><li>  PoW miners need to cover their costs and invest in building capacity - this is a direct outflow of capital from projects, </li><li>  savers want to maintain their purchasing power by self-capitalizing themselves, rather than looking at natural inflation. </li></ol><br><p>  <em>On a live example: in November-December 2018 there were attempts to attack;</em>  <em>then in December and February there was an excitement like on the most profitable coin for mining on video cards;</em>  <em>the rate sank from 2+ to 0.5 USD;</em>  <em>after switching to PoS, the rate went up to 1 USD in a week and the inflow of investments increased.</em> </p><br><hr><br><h2 id="tehnicheskie-momenty">  Technical points </h2><br><p>  <strong>Attention: in this context, we are talking about the "traditional" PoS in the form as it is in Peercoin, PIVX and their forks.</strong> </p><br><p>  It is necessary to understand that there is no centralization and accounting of "points".  In this embodiment, the same principle of luck works as in PoW. </p><br><h3 id="1-terminologiya">  1. Terminology </h3><br><p>  Terminology is relatively common, but its implementation has different nuances: </p><br><ul><li>  <strong>PoW target</strong> - target = basic target, usually 2 ^ 240 (0x0000ffff ...), divided by the complexity of the block (increases the number of zeros from the front). </li><li>  <strong>Block difficulty</strong> - the complexity of the block relative to the base goal, deterministically set based on the current growth rate of the chain. </li><li>  <strong>UTXO</strong> - Unspent Transaction Output, a pair of transaction hash and output number. </li><li>  <strong>CoinBase</strong> is a special transaction with an index of 0 in the block that contains the reward. </li><li>  <strong>Stake</strong> or <strong>CoinStake</strong> is a special transaction with index 1 in the block. </li><li>  <strong>Stake Input</strong> - UTXO, which meets the requirements for bet on size and age. </li><li>  <strong>Stake Modifier</strong> is a special deterministic calculated parameter for each <strong>Stake Input</strong> . </li><li>  <strong>Stake Hash</strong> is the result of hashing, which must be arithmetically less than <strong>Stake Target</strong> . </li><li>  <strong>Stake Target</strong> - the same as the PoW target, but proportionally increased by the amount of <strong>Stake Input</strong> relative to the minimum rate. </li><li>  <strong>Block Signature</strong> - block signature. </li><li>  <strong>Fork</strong> - branching chain. </li><li>  <strong>Split</strong> - network split. </li><li>  <strong>Orphan</strong> - dropped blocks due to the choice of another alternative. </li></ul><br><h3 id="2-anatomiya">  2. Anatomy </h3><br><p>  Generation process: </p><br><ol><li>  Find all utxo that meet the requirements of Stake Input. </li><li>  Find Stake Modifier. </li><li>  Multiply the PoW Target by the amount of Stake Input. <br><ul><li>  <em>in ppm in fact - so the 1 MH PoW hash experimentally goes out to be equal to one coin.</em> </li></ul></li><li>  We <code>Stake Hash = H(Stake Modifier, Stake Block Time, UTXO output index, UTXO txid, Current Block Time)</code> . <br><ul><li>  <em>variable parameter only current block time</em> </li></ul></li><li>  If <code>Stake Hash &gt;= Stake Target</code> , then we try to pick up the <code>Current Block Time</code> in the allowed interval. <br><ul><li>  <em>consider the possibility of an overflow of Stake Target when multiplying by the amount of Stake Input, depending on the implementation.</em> </li></ul></li><li>  We put Coinbase at tx [0], and CoinStake at tx [1]. <br><ul><li>  <em>The beneficiary of Coinbase is the same script (address) as that of Stake Input.</em> </li></ul></li><li>  Sign the block. </li></ol><br><h4 id="21-vremya-bloka">  2.1.  Block time: </h4><br><p>  It is easy to see that a scam over time can provide some benefits.  Standard consensus limits the lower and upper limits. </p><br><p>  The lower ones always set the average block time for the last N blocks, usually over 11. This is the tolerance for time inaccuracy on the generating nodes. </p><br><p>  The historic upper limit was set for PoW with a finger at the sky at 2 o'clock.  Increasing the intervals reduces the complexity and makes the branch less attractive - so there is no point.  But for PoS there is a sense. </p><br><p>  PIVX and others limit future time to a maximum of 3 minutes.  Some put a more rigid restriction, but this creates problems for users.  Some PoS implementations have decided to change the minimum intervals of the Current Block Time from one second to 15-16 seconds. </p><br><h4 id="22-stake-modifier">  2.2.  Stake Modifier: </h4><br><p>  Stake Modifier was conceived as a means to obscure the prediction and construction of the chain in advance, but something went wrong ... </p><br><p>  There are various ways to calculate it: the last bits of block hashes at the ends of progressively specified time intervals, [bad times] poorly predictable values ‚Äã‚Äãfrom previous blocks, etc.  In some places it looks more like obfuscation of a code than something imputed. </p><br><p>  In the original, a gap of 64 intervals is taken.  This gap is progressively divided into 64 unequal parts.  Borders are rounded to minutes.  Existing blocks are selected along the borders and one last bit is taken from them.  So it turns out the number in 64-bit, something similar to Nonce. </p><br><p>  The interval in Peercon is 20 minutes, but the guys from PIVX decided that the interval of 1 minute, rounded to the minute, is what the doctor prescribed. </p><br><p>  In general, in some implementations of the Blackcoin V2 + type, everything is fixed and Stake Modifier is counted from the head, and in Peercoin V03, PIVX, Blackcoin V1 and others from the Stake Input block.  The latter almost completely destroys the meaning.  There is an assumption that the confusion has gone because of the banal problem of naming variables, further metamorphosis and thoughtless copy-paste.  And the author himself rather late discovered the problem while all the attention was focused on protection against DoS.  Do not get caught! </p><br><h4 id="23-podpis-bloka">  2.3.  Block signature </h4><br><p>  Since the block hash no longer serves as proof of work, and anyone can take a signed CoinStake transaction from another block, you need to check that the block was created by the owner of Stake.  Therefore, the header is signed with the same private key as CoinStake. </p><br><h4 id="24-skript-vyhoda-coinbase-i-coinstake">  2.4.  CoinBase and CoinStake exit script </h4><br><p>  The same exit scripts, or as the wallet addresses are called, are required to preserve privacy and avoid linking individual addresses in the same wallet. </p><br><h4 id="25-chto-i-kuda">  2.5 What and where? </h4><br><p>  There are different variations on how to manage the amounts in CoinBase and CoinStake.  Logic and motivation in a specific case: </p><br><ol><li>  Amounts must be split to avoid even the smallest possible loss of user funds due to processing errors. </li><li>  CoinBase retains its 100 confirmations, but CoinStake can be spent immediately, which of course leaves the risk of double spending. <br><ul><li>  tying in to the depth of the blocks also contradicts the age requirement for use as Stake Input. </li></ul></li><li>  CoinBase and CoinStake should never fall into the mempool, and all transactions based on them should be deleted when the chain is rebuilt. </li></ol><br><h3 id="3-polnye-bloki-protiv-zagolovkov">  3. Complete blocks against headers </h3><br><p>  The entry of a full-fledged node into the network begins with synchronization.  In Bitcoin, synchronization is primarily based on block headers, since  they contain sufficient information to pre-test compliance with consensus.  First, relative small headers are packaged and checked up to 2,000 packs from one third-party node.  If the initial test was successful, then all blocks are drawn in parallel from all connected nodes. </p><br><p>  Protection against flooding is based on the fact that the local node compares the best known header with what it has and requests the entire chain of headers.  As you download, everything is checked by the small cost of disk space and calculations.  Chains are compared in their weight based on characteristics such as <strong>chainwork</strong> , which is the sum of the complexity of each individual unit.  To build such a strong alternative chain will require extremely large investments of resources, which makes attacks unpromising. </p><br><p>  With PoS, this approach does not work, because  to check the blocks, it is required to process complete previous blocks at least up to the minimum age limit of Stake.  The implementations reviewed by the author did not pervert, but simply refused to work with the headings. </p><br><p>  <strong>Therefore, the</strong> author implemented a parallel opportunistic downloading of blocks after the headers, which significantly increases the synchronization speed due to the use of all connections.  Minor delays occur only if peers are on different circuits - then the connection is broken after a minor timeout, as in the standard scheme.  As a minus, the tendency to choose a false chain at the time of synchronization. </p><br><p>  <em>By the way, the standard Bitcoin client and its forks dial the minimum standard number of outgoing connections into 8 pieces for quite a long time, if some of them break down for various reasons.</em>  <em>This was resolved by asynchronous outgoing connections.</em> </p><br><h3 id="4-forki-splity-i-orfany">  4. Forks, splits and orphans </h3><br><p>  When competing to create blocks, alternative chains of 1-2 links are relatively commonplace.  Longer forks in developed networks naturally occur only during epic failures in consensus due to a programming error or a global Internet break. </p><br><p>  Even with separation, there is usually no threat to the integrity of transaction processing, since  when blocks are disconnected, all transactions fall back into the mempool and are included in other blocks.  Mempool is a temporary repository of transactions after they are created.  The mempool itself is saved to disk in recent versions.  The reward for the block is destroyed.  That is why for awards set the minimum number of confirmations (depth). </p><br><p>  It happens that local network segments lose contact with the outside world and continue to mine, assuming a connection to the main network.  Such branches are usually not a threat because of their natural weakness. </p><br><p>  The main attack of 51% for PoW is already described above - it is extremely resource-intensive, but for PoS it becomes relatively accessible.  For this reason, it becomes technically possible to produce many branches from different chain links.  One of the classic solutions is to prohibit forks below a certain depth. </p><br><p>  The main problem of such protection is the impossibility of nodes from hermit segments to return to the main circuit independently after restarting. </p><br><p>  <strong>Therefore</strong> , an approach was adopted to ban forks over a certain period of time only if the top of the chain is quite young. </p><br><p>  <em>With a target interval of blocks of 1 minute, the criterion of the old fork was chosen at 1 hour, which roughly corresponds to 60% of CoinBase confirmations, and the criterion of youth of the crown at 15 minutes is 3+ times higher than the maximum statistical block lag.</em> </p><br><h3 id="5-hesh-bloka-i-splity">  5. Block hash and splits </h3><br><p>  In PoW, the block hash completely covers all the data.  It is used to check against the target.  In PoS, Stake Hash is a separate value, because  it is necessary to exclude the possibility of its selection.  This opens up the main threat - the ability to produce an unlimited number of different versions of the block based on the same matched Stake, with which it is easy to flood and put a network or its individual nodes. </p><br><p>  Naive approaches to protection generate new even more serious vulnerabilities of the split.  One of these approaches in different variations is to allow the use of Stake Input only once.  A simple attack is to send different blocks to different nodes, which immediately gives rise to a soft split. </p><br><p>  Even more fatally, it is possible to exacerbate it with DoS-ban, which will divide not only the chains, but also the network itself into different segments. </p><br><p>  There are other problems - the inability to use Stake from a dropped block. </p><br><p>  <strong>Therefore</strong> , the choke method was chosen as the safest solution - the same Stake can be used no more than once per minute.  The logic is simple: an attack can last only in the interval of 1 hour (see the old fork above), for which it is possible to flood no more than 60 blocks.  At best, on the next block, the network will already go over to a single chain.  In the worst case, with a continuous attack, this will happen in an hour.  The probability of the worst case - finding several blocks in a row, melts exponentially. </p><br><p>  <em>Still, there are some moments at which the nodes are vulnerable to moderate flood until full synchronization</em> . </p><br><h3 id="6-minimalnyy-vozrast">  6. Minimum age </h3><br><p>  For some, this limitation is puzzling, but it is extremely important for network stability, since  This parameter is directly related to the maximum length of the alternative network, which the local node can check without serious technical distortions. </p><br><p>  As mentioned earlier, the local node must process all blocks before the time boundary of the age in order to be able to verify that Stake Input a) takes place to be b) is indeed UTXO and has not been spent. </p><br><p>  Check this is possible only through the functionality of the so-called.  CoinView, which is the state of movement of coins at the time of a particular block, is the top of the main chain in the sense of the local node. </p><br><p>  The implementation of a complete test of alternative circuits at time intervals or even in a special way saved by the CoinView looks unpromising, since  The number of these alternative chains is infinitely large. </p><br><p>  Too big a bar for the age qualification of UTXO adversely affects users who want to spend or merge part of their coins. </p><br><p>  If you specify this boundary in the depth of the blocks, then a hypothetical stalemate situation is possible to completely stop the circuit due to the fact that there is no suitable UTXO.  In the case of units of time, at least some movement occurs. </p><br><p>  <strong>Therefore</strong> , a balanced and working choice in other networks is used at 1 o'clock in absolute time units, and not the depth of the blocks. </p><br><h3 id="7-chto-luchshe-n-utxo-po-minimalnoy-summe-ili-odin-utxo-s-n-summoy">  7. What is better than N UTXO for the minimum amount or one UTXO with N amount? </h3><br><p>  Here the analogy suggests itself: that one gun is better with an accuracy of 0.9 or three guns with an accuracy of 0.3, but with probabilities of the order of 1/2 ^ 20, the results of such calculations would seem to be leveled.  A little card confuses the qualification of maturity. </p><br><p>  The prevailing view that many small transactions find more blocks, probably went from the time when the age of Stake Input was also taken into account for determining the weight.  Then the old small transactions really had significant meaning. </p><br><p>  At the moment, on the basis of practical experiments and theoretical calculations, grouped in large UTXO amounts bring more blocks.  In addition, fewer UTXOs require less CPU.  Someone claims the opposite. </p><br><p>  <strong>So</strong> think for yourself. </p><br><h3 id="8-zabeganie-blokov-vperyod">  8. Running Forward </h3><br><p>  PoS miners naturally a little ahead of the time blocks.  This reflects the complexity of the network for the worse.  The standard Bitcoin code selects the first block received, regardless of the time specified in it.  Most PoS implementations do the same. </p><br><p>  <strong>Therefore, the</strong> logic of the PoS miner has been changed to begin the selection of the average time of the blocks, if the time of the current block has gone ahead.  At the same time, before comparing the sequence, the nodes compare the indicated time of the blocks.  The PoS miner sends the found block to the network even if it sees that it generates a fork. </p><br><p>  In this way, the network is also protected from hypothetical prematurely sent out blocks, whose Stake Input cannot be used in the next 60 seconds with the same Stake Modifier due to DoS protection.  As if double punishment for cheating with time. </p><br><h3 id="9-nebolshoy-cheklist">  9. Small checklist </h3><br><ol><li>  Stake Input must be valid UTXO before fork point: <br><ul><li>  in the case of the main chain, the fork point is the tip, </li><li>  in the case of an alternative circuit, the UTXO after the fork point may result in self-DoS when switching, </li><li>  it goes without saying that UTXO should not be in mempool. </li></ul></li><li>  Do not take CoinStake in mempool when rebuilding the main circuit: <br><ul><li>  the same happens with CoinBase, </li><li>  this may destroy the transaction chain (unlikely). </li></ul></li><li>  Do not take forks from old blocks, if the top is quite lively. </li><li>  The age requirement in absolute time units for Stake Input is necessary for stability and security. </li><li>  Stake Hash should change only from block time. </li><li>  Stake Modifier should not be tied to a Stake Input block. </li><li>  Working with block headers requires special processing on the network and during reindexing. </li><li>  CoinStake is recorded in the local wallet and requires some changes to correctly display orphans. </li><li>  PoS miners most likely have enough jambs and need to be modified by a file. </li><li>  Re-index needs some work, because  works by analogy with headers - at first it loads and checks only the index of blocks, and then only tries to process the blocks. </li><li>  If the transition to PoS is not rigidly set, but through spork, then it should be caught on the boot, because  sporks are not saved. </li><li>  Checkpoints in Dash and Bitcoin are almost props and require very serious work. </li><li>  If the fork of Dash is up to version 0.13, then there are problems with the processing of the master data in the mode of using a simple user. <br><ul><li>  If the client restarts frequently, the network view is distorted. </li><li>  It is better to simply ignore the cache if running in graphical mode. </li></ul></li><li>  Change the choice of the best block, taking into account the block time. </li><li>    Bitcoin          . </li><li>         mempool CoinStake  . </li></ol><br><hr><br><p><img src="https://habrastorage.org/webt/gw/fh/up/gwfhupvzahev6mwinu2-idrfpp8.png"></p><br><h2 id="vnedrenie-v-zhizn">    </h2><br><p>     .   mainnet    PoW       ,    ,      PoS,      . PoS       Ethereum   Casper'. </p><br><p>  GPU        -    ‚Äî ethminer'.           150-200 GH (ethash).  -                PoS  . </p><br><p>       PoS   PIVX 2.x  "   ".  -    PIVX     ,             ,  .         ,     PIVX 2.x    .      Dash         0.12      Bitcoin'. </p><br><p>          ,     PoS      .       ,         ,     . </p><br><h3 id="podgotovitelnye-raboty">   </h3><br><h4 id="dokumentaciya">  Documentation </h4><br><p>      .           .   whitepaper    -. </p><br><h4 id="pervoe-priblizhenie">   </h4><br><p>        PoS  PIVX       Bitcoin/Dash.     CoinStake          .      PoS    . </p><br><p>      ,      Stake Modifier   Stake Hash  ,       Stake Input   . -      ,  -    PIVX    . </p><br><h4 id="dinamichnye-chekpoynty">   </h4><br><p>          ‚Äî      .    : </p><br><ol><li>            . </li><li>         . </li><li>       ‚Äî ..    ,       . </li><li>      ,  -      ,         . </li></ol><br><p>            .    spork'    ,       . </p><br><p> <em>,        .    spork'     .</em> </p><br><h4 id="perehod-na-pos-ne-dolzhen-byt-zhyostko-zashit">   PoS      </h4><br><p>              ,   -    .        spork,   ,     . </p><br><h4 id="novaya-versiya-protokola">    </h4><br><p>  , ..              .  ,         . </p><br><h4 id="publichnoe-testirovanie">   </h4><br><p>      testnet,       . </p><br><p>  testnet      3   1   mainnet,        . </p><br><h4 id="kalkulyator-dohodnosti">   </h4><br><p>    PoW ,  PoS     - ,            1e6       PoW. </p><br><p>           .   mainnet          Stake Input. </p><br><p>           . </p><br><h3 id="perehod-na-pos-v-zhizni">   PoS   </h3><br><p>     X   spork    PoS . -       ,      . </p><br><p>             .  ,   .        . </p><br><p>     ,      ,     . </p><br><h3 id="lozhka-dyogtya">   </h3><br><p>      Stake Modifier  .        .    PIVX  - ‚Ä¶ ,     ,        Ethereum,    . </p><br><hr><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>    -      ,          .   ,          PoS   ,        .        . </p><br><p> <em>:       -           .</em> </p><br><p> <em><a href="https://github.com/energicryptocurrency/energi">  GitHub       </a></em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/442862/">https://habr.com/ru/post/442862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442846/index.html">Our space industry. A look at the problems of the industry from the perspective of an ordinary developer</a></li>
<li><a href="../442852/index.html">Dell 6000 or hello from 2005</a></li>
<li><a href="../442854/index.html">How did we make the metro scheme of Minsk</a></li>
<li><a href="../442856/index.html">Two in one: Wi-Fi programmable air quality monitor and analogue clock</a></li>
<li><a href="../442858/index.html">Are there too many elephants in Africa? How peaceful coexistence with human communities can help</a></li>
<li><a href="../442864/index.html">How old is your liege?</a></li>
<li><a href="../442866/index.html">AI, trained on the basis of decades of culinary experiments, creates new dishes</a></li>
<li><a href="../442868/index.html">A brief excursion into the data center cooling system. Advantages and disadvantages</a></li>
<li><a href="../442870/index.html">The best of the world of Angular for the week - Digest number 2 (January 26 - March 7)</a></li>
<li><a href="../442876/index.html">Noise mapping with KSQL, Raspberry Pi and radio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>