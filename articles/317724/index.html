<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Discord processes more than 1,000,000 push requests per minute with Elixir GenStage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Discord 

 Discord experienced an unprecedented growth. To cope with it, our development department got a pleasant problem - to look for a way to scal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Discord processes more than 1,000,000 push requests per minute with Elixir GenStage</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/285/80e/8af/28580e8af4eb4ae08c83127326a5270f.jpg"><br>  <i>Discord</i> <br><br>  <abbr title="Free voice and video chat for gamers">Discord</abbr> experienced an unprecedented growth.  To cope with it, our development department got a pleasant problem - to look for a way to scale back-end services. <br><br>  In this case, we have achieved great success with the help of one technology called Elixir GenStage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  The Perfect Storm: Overwatch and Pok√©mon GO </h1><br>  This summer, our system of mobile push-notifications began to creak from the load.  Chat / r / Overwatch passed for 25,000 simultaneous users, and the Pok√©mon GO chat groups were everywhere, so that sudden spikes in the flow of notifications became a serious problem. <br><a name="habracut"></a><br>  Bursts of the flow of notifications inhibit the entire system of push-notifications, and sometimes put it.  Push notifications either come late, or do not come at all. <br><br><h1>  GenStage comes to the rescue </h1><br>  After a small investigation, we found out that the main bottleneck was sending push notifications to Google Firebase Cloud Messaging. <br><br>  We realized that we can immediately improve throughput if we send push requests to Firebase via XMPP, and not via HTTP. <br><br>  Firebase XMPP is slightly more complicated than HTTP.  Firebase requires that each XMPP connection at a time does not have more than 100 requests in a queue.  If 100 requests have flown away from you, then you should wait until Firebase acknowledges receipt of the request before sending the next one. <br><br>  Since only 100 requests are allowed in the queue at a time, we had to design a new system so that XMPP connections would not overflow during requests bursts. <br><br>  At first glance, it seemed that GenStage would be the perfect solution to the problem. <br><br><h1>  Genstage </h1><br>  What is GenStage? <br><br><blockquote>  <i>GenStage is a new mode (Elixir) for exchanging events under back pressure between Elixir processes.</i>  <i>[ <a href="http://elixir-lang.org/blog/2016/07/14/announcing-genstage/">0</a> ]</i> </blockquote><br>  What does this really mean?  Essentially, this mode gives you the tools you need so that not a single part of your system is overloaded. <br><br>  In practice, a system with GenStage modes usually has several stages. <br><br><blockquote>  <i>The stages are the computational steps that send and / or receive data from other stages.</i> <i><br><br></i>  <i>When a stage sends data, it acts as a manufacturer.</i>  <i>When receives data, then as a consumer.</i>  <i>Stages can play the roles of both the producer and the consumer at the same time.</i> <i><br><br></i>  <i>In addition to assigning producer and consumer roles, a stage can be designated as a ‚Äúsource‚Äù (source) if it only produces elements, or it can be designated as a ‚Äúdrain‚Äù (sink) if it only consumes them.</i>  <i>[ <a href="https://hexdocs.pm/gen_stage/Experimental.GenStage.html">1</a> ]</i> </blockquote><br><h1>  An approach </h1><br><img src="https://habrastorage.org/files/3cc/494/ffa/3cc494ffaa744052bd29535b44343cf9.gif"><br><br>  We divided the system into two stages of GenStage.  One source and one drain. <br><br><ul><li>  Stage 1 - Push Collector.  This is the manufacturer that receives push requests.  Now we have one Erlang process for Push Collector per machine. <br><br></li><li>  Stage 2 - Pusher.  This is a consumer who requires push requests from the Push Collector and sends them to Firebase.  It requests only 100 requests at a time, in order not to exceed the Firebase limit on the number of simultaneous requests.  Pusher-type processes (also on Erlang) are many on each machine. </li></ul><br><h1>  Back pressure and load shedding with GenStage </h1><br>  GenStage has two key functions that help us during the surge in requests: back pressure (pressure) and load shedding. <br><br><h2>  Back pressure </h2><br>  Pusher uses the GenStage functionality to request Push Collector the maximum number of requests that Pusher can process.  This guarantees an upper bound for the number of push requests that are pending.  When Firebase confirms the request, then Pusher also requires Push Collector. <br><br>  Pusher knows the exact number of requests that the Firebase XMPP connection can handle, and never requires too much.  But Push Collector never sends a request to Pusher, if he did not ask. <br><br><h2>  Load shedding </h2><br>  Since the Pushers put back pressure on the Push Collector, a potential bottleneck appears in the Push Collector.  Super-duper powerful bursts can overload it. <br><br>  GenStage has another built-in function for these situations: buffered events. <br><br>  In Push Collector, we determine how many push requests to buffer.  <b>In the normal state, the buffer is empty, but once a month, when catastrophic events occur, it comes in handy.</b> <br><br>  If a lot of events pass through the system, and the buffer is filled, then Push Collector discards incoming push requests.  This happens by itself simply by specifying the <code>buffer_size</code> option in the <code>init</code> function of Push Collector. <br><br>  With these two functions, we are able to cope with bursts of push notifications. <br><br><h1>  Code (finally, the most important part) </h1><br>  Below is a sample code of how we set up the Pusher and Push Collector stages.  For simplicity, we have removed many fragments that are responsible for handling failures when a connection is lost, Firebase returns errors, etc. <br><br>  You can skip the code if you want to see the result. <br><br><h2>  Push Collector (manufacturer) </h2><br>  <a href="https://gist.github.com/jhowarth/40df1170d58c046da3315405fec965bf">push_collector.ex</a> <br><br><pre> <code class="erlang hljs">defmodule GCM.PushCollector do use GenStage # Client def push(pid, push_requests) do GenServer.cast(pid, {:push, push_requests}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # Server def init(_args) do # Run as producer <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> specify the max amount # <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> push requests to buffer. {:producer, :ok, buffer_size: @max_buffer_size} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def handle_cast({:push, push_requests}, state) do # Dispatch the push_requests as events. # These will be buffered <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> there are no consumers ready. {:noreply, push_requests, state} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def handle_demand(_demand, state) do # Do nothing. Events will be dispatched as-is. {:noreply, [], state} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2>  Pusher (consumer) </h2><br>  <a href="https://gist.github.com/jhowarth/4e8c37ad61c197e68d2cb456ac28797d">pusher.ex</a> <br><br><pre> <code class="erlang hljs">defmodule GCM.Pusher do use GenStage # The maximum number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> requests Firebase allows at once per XMPP connection @max_demand <span class="hljs-number"><span class="hljs-number">100</span></span> defstruct [ :producer, :producer_from, :fcm_conn_pid, :pending_requests, ] def start_link(producer, fcm_conn_pid, opts \\ []) do GenStage.start_link(__MODULE__, {producer, fcm_conn_pid}, opts) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def init({producer, fcm_conn_pid}) do state = <span class="hljs-comment"><span class="hljs-comment">%__MODULE__{ next_id: 1, pending_requests: Map.new, producer: producer, fcm_conn_pid: fcm_conn_pid, } send(self, :init) # Run as consumer {:consumer, state} end def handle_info(:init, %{producer: producer}=state) do # Subscribe to the Push Collector GenStage.async_subscribe(self, to: producer, cancel: :temporary) {:noreply, [], state} end def handle_subscribe(:producer, _opts, from, state) do # Start demanding requests now that we are subscribed GenStage.ask(from, @max_demand) {:manual, %{state | producer_from: from}} end def handle_events(push_requests, _from, state) do # We got some push requests from the Push Collector. # Let's send them. state = Enum.reduce(push_requests, state, &amp;do_send/2) {:noreply, [], state} end # Send the message to FCM, track as a pending request defp do_send(%{fcm_conn_pid: fcm_conn_pid, pending_requests: pending_requests}=state, push_request) do {message_id, state} = generate_id(state) xml = PushRequest.to_xml(push_request, message_id) :ok = FCM.Connection.send(fcm_conn_pid, xml) pending_requests = Map.put(pending_requests, message_id, push_request) %{state | pending_requests: pending_requests} end # FCM response handling defp handle_response(%{message_id: message_id}=response, %{pending_requests: pending_requests, producer_from: producer_from}=state) do {push_request, pending_requests} = Map.pop(pending_requests, message_id) # Since we finished a request, ask the Push Collector for more. GenStage.ask(producer_from, 1) %{state | pending_requests: pending_requests} end defp generate_id(%{next_id: next_id}=state) do {to_string(next_id), %{state | next_id: next_id + 1}} end end</span></span></code> </pre> <br>  <b>Example incident</b> <br><br>  The following is a real incident that the system encountered.  The upper graph shows the number of push requests per second passing through the system.  On the lower graph - the number of push requests placed in the Push Collector buffer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/003/4a0/735/0034a0735ad3aef41878e1f91dd527d4.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b4/460/164/9b44601642a8372622abff0e3a345072.png"><br><br>  <b>Chronicle of events:</b> <br><br><ul><li>  ~ 17: 47: 00 - The system is operating normally. </li><li>  ~ 17: 47: 30 - We begin to receive a stream of messages.  Push Collector tapped the buffer a bit, waiting for the Pusher reaction.  Soon the buffer was a bit free. </li><li>  ~ 17: 48: 50 - Pushers can't send messages to Firebase faster than they arrive, so the Push Collector's buffer starts to fill up. </li><li>  ~ 17: 50: 00 - The Pusher Collector buffer peaks and begins to reset some requests. </li><li>  ~ 17: 50: 50 - Buffer Pusher Collector begins to free up and stops dropping requests. </li><li>  ~ 17: 51: 30 - The influx of requests began to decline. </li><li>  ~ 17: 52: 30 - The system is completely back to normal. </li></ul><br><h1>  Success elixir </h1><br>  We at Discord are very pleased with the use of Elixir and Erlang as a key technology on our backend services.  It's nice to see extensions like GenStage, which rely on the unbreakable Erlang / OTP technologies. <br><br>  We are looking for a brave spirit to help solve such problems as Discord continues to grow.  If you like games and these kinds of tasks make your heart beat faster, <a href="https://discordapp.com/company">check out our jobs</a> . </div><p>Source: <a href="https://habr.com/ru/post/317724/">https://habr.com/ru/post/317724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317714/index.html">Immigration with the Crimea to Russia</a></li>
<li><a href="../317716/index.html">Gogland: JetBrains New Go IDE</a></li>
<li><a href="../317718/index.html">Russian software in the offices of companies - current realities and prospects, opinions and experience of experts</a></li>
<li><a href="../317720/index.html">Exotic HTTP Headers</a></li>
<li><a href="../317722/index.html">Instructions: How to choose the right indicators for monitoring and optimization, so that IT businesses grow faster</a></li>
<li><a href="../317726/index.html">Splitting text into sentences using Tomita Parser</a></li>
<li><a href="../317728/index.html">Button or link?</a></li>
<li><a href="../317730/index.html">How IT professionals work. Maxim Zelinsky, Sberbank-Technology</a></li>
<li><a href="../317732/index.html">Chatbot on the basis of a recurrent neural network do-it-yourself for 1 evening / $ 6 and ~ 100 lines of code</a></li>
<li><a href="../317736/index.html">New promising sites for HTML5 games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>