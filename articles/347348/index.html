<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LittleFS is a compact and economical file system for ARM microcontrollers comprising mbed os. Fast start</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In December 2017, ARM introduced to the public a new version of the operating system for ARM microcontrollers ‚Äúarm mbed os v.5.7‚Äù (version 5.7.3 was r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LittleFS is a compact and economical file system for ARM microcontrollers comprising mbed os. Fast start</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/93d/3ee/4f893d3ee8c153caa0d073794f57174e.jpg" alt="image alt" align="left">  In December 2017, ARM introduced to the public a new version of the operating system for ARM microcontrollers ‚Äúarm mbed os v.5.7‚Äù (version 5.7.3 was released on January 17, 2018), which received an integrated author file system, simply called ‚ÄúLittleFileSystem‚Äù, or just "LittleFS".  I suggest today to talk about this new product. <br><a name="habracut"></a><br>  The main advantages of the file system "LittleFS" are: <br><br><ul><li>  Low requirements for microcontroller resources.  The code does not use recursive calls and works without dynamic memory allocation.  In ‚ÄúLittleFS‚Äù, the amount of RAM consumed always remains constant, regardless of what volumes are written to the drive and the amount of the drive itself; </li><li>  Availability of software for leveling media wear (so-called wear leveling), which allows minimizing reuse of media blocks; </li><li>  Resilience to power failure.  This feature is regularly considering the cessation of power supply of the carrier, and uses the ‚Äúcopy-on-write (COW)‚Äù mechanism, in which data is not overwritten, but saved to a new location. </li></ul><br>  The system supports a complete set of <b>POSIX</b> functions for working with files and directories. <br><br>  Let me remind you that the file system is integrated into the <b>arm mbed os</b> operating system that is being actively developed and maintained by the manufacturer, so I will have to say a little about this OS for <b>ARM</b> , in spite of a certain amount of materials about it, published on the resource.  So here I‚Äôm a little distracted by <b>mbed os</b> , and someone who already has experience with it can skim the next few paragraphs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The operating system is written in C / C ++, and the main advantage of the OS, and its main drawback, in my opinion (however paradoxical it may sound), is a really high level of abstraction from the hardware. <br><br>  Those who, when working with <b>STM32</b> microcontrollers (I am talking to them in association with them) used the <b>HAL</b> and <b>SPL</b> libraries (and even more so those who were crawling in the registers manually), remember how many lines of code needed to be created to configure, for example, interrupts on the falling edge at the <b>PA_5 pin</b> : enabling the clocking of the port, setting the operating mode of a particular pin, setting the interrupt itself, enabling the interrupt ‚Äî and only then describing the handler. <br><br>  In <b>mbed os</b> everything is much easier. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">InterruptIn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq_button1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PA_5)</span></span></span></span>; irq_button1.fall(led_blink);</code> </pre> <br>  At first I gave the name of the interrupt and indicated the output, by the change of the state of which I want to cause an interrupt.  In the second line I indicated the sign by which I needed to go to the handler ( <b>fall</b> , the falling edge of the signal), and indicated the name of the interrupt handler itself ( <b>led_blink</b> ). <br><br>  The high level of abstraction is convenient, but at the same time the novice novice does not understand at all what is happening in the microcontroller at the moment, and that in fact one line of code causes tens of values ‚Äã‚Äãto be written to dozens of registers.  And this, of course, is not very good. <br><br>  The easiest way to get started with mbed os is to go to the <a href="https://os.mbed.com/">mbed.com</a> portal and register there as a developer (basic registration with confirmation by e-mail).  From this point on, an online compiler is available to you, which will play an important role for the start.  In short, what we are going to do: as a start and make it easier for us, we will take any example that includes <b>mbed os</b> from the repository on the <b>os.mbed.com</b> portal, and then import it as a project for our <b>IDE</b> and ideally for our microcontroller.  The OS, by the way, is also a marketing tool, and <b>ARM</b> recommends so-called ‚Äú <b>mbed-enabled</b> ‚Äù debugging boards, and at first glance it may seem that only boards from the catalog on the site are suitable for mbed os.  But this, of course, is not so. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/4fc/df2/4304fcdf23fb9b683e120bffd15900be.jpg" alt="image"></div><br>  In the upper right corner, we have the button for choosing a debugging board, with which we are going to work (of course, it is assumed that we purchased one of the boards located in the catalog). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/147/5b6/9ba1475b699283bce5d79cce091b3efc.jpg" alt="image"></div><br>  After clicking on the button, a window for selecting a specific board will appear.  In the same place, in a window, there will be a button with a big green plus of " <b>Add Platform</b> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/936/16c/112/93616c112bbd84ea1b95fdfcc2595796.jpg" alt="image"></div><br>  In a separate browser window, the platform selection window will open, among which we will select ‚Äú <b>STMicroelectronics</b> ‚Äù, and select a board on which the same microcontroller is installed as the one with which we are going to work.  I was lucky - on my self-made debug board there is a microcontroller " <b>STM32F103RBT6</b> ", as well as on the " <b>Nucleo-F103RB</b> " <b>board</b> . <br><br>  In the near future I plan to write a little material on how to implement a project with <b>arm mbed os</b> under any arbitrary MK. <br><br>  On the page with the description of the board that we selected in the selector, on the right, click the ‚Äú <b>Add to your Mbed Compiler</b> ‚Äù button. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9f/e5e/f45/a9fe5ef45c92372feea92f2d211ff262.jpg" alt="image"></div><br>  Immediately below are examples.  We will choose the smallest and simplest - ‚Äú <b>Nucleo_blink_led</b> ‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ed/b41/dbc/0edb41dbc943b81fca3a4b601cae820b.jpg" alt="image"></div><br>  In the window that opens, in the upper right, click the ‚Äú <b>Import Into Compiler</b> ‚Äù button. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd2/b12/a9e/dd2b12a9e8dd0ecbc5c7135a81dbbe34.jpg" alt="image"></div><br>  Your online compiler will open and ask for confirmation of the project import.  After confirmation, we will see our project in the project tree on the left. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c8/b92/8fe/4c8b928fedfdb4a0aad6e4d8c3220ad5.jpg" alt="image"></div><br>  It remains the case for the small - to import the project under our desktop IDE.  The online compiler supports a lot of IDE, including ‚Äú <b>IAR for ARM</b> ‚Äù, ‚Äú <b>KEIL uVision</b> ‚Äù, ‚Äú <b>CooCox CoIDE</b> ‚Äù, and many other environments.  I use the <b>IAR for ARM v.8.20.1 environment</b> , while ARM recommends <b>IAR</b> version 7.5 or <b>higher</b> for working with <b>mbed os</b> . <br><br>  On the right, in the ‚ÄúProgram Details‚Äù block, click on the ‚Äú <b>Export</b> ‚Äù button. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/d68/8fd/0ebd688fdf06527cb5b2a536cb582555.jpg" alt="image"></div><br>  In the ‚ÄúExport program‚Äù pop-up window that appears, choose the platform and development environment that is installed on our computer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/b80/41f/9ddb8041f0755bedb6e004fb7888c20f.jpg" alt="image"></div><br>  After clicking on the ‚Äú <b>Export</b> ‚Äù button, the online compiler will think a little, and the download of the archive with the project will start in the browser.  We unpack in any place convenient for us, open the development environment, open the project, clean up everything we don‚Äôt need in the main file ‚Äúmain.cpp‚Äù, start working. <br><br>  By the way, everything in the same ‚Äú <b>Program details</b> ‚Äù block, before exporting a project, you can evaluate the degree of project load on the built-in flash and the RAM of our target controller.  Open the " <b>Build</b> " tab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/2fd/c95/7692fdc9588565fec3d6a69ce6bcad23.jpg" alt="image"></div><br>  On this, perhaps, I will finish the already prolonged excursion into the quick start with <b>mbed os</b> , and return to the conversation about <b>LittleFS</b> . <br><br>  To work correctly with the file system, we must include in the project the header files ‚Äú <b>LittleFileSystem.h</b> ‚Äù and, necessarily, the header file of the media.  I assume to work with the SD card, so I include the file ‚Äú <b>SDBlockDevice.h</b> ‚Äù in the project.  Among other devices are available <b>MBRBlockDevice</b> , <b>HeapBlockDevice</b> (very convenient for training, as it does not require the presence of physical media), and other types of devices. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Block device #include "SDBlockDevice.h" // File system #include "LittleFileSystem.h"</span></span></code> </pre><br>  So, I propose to consider our sequence of actions when building a starting project for working with ‚Äú <b>LittleFS</b> ‚Äù.  First we need to create the device objects (and initialize its output) and the file system.  Then we will mount the file system, create a couple of files on the media, open the root directory and count from it the list of files contained in it. <br><br>  Note the tree of class inheritance for working with streams implemented in <b>mbed os</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/7f6/bf5/9147f6bf50f69d2ea362d6909d015647.png" alt="image"></div><br>  As you can see, we have implemented a whole ‚Äú <b>File</b> ‚Äù class for working with files.  To work with directories there is a class " <b>Dir</b> ".  Their description can be read on the pages <a href="https://os.mbed.com/docs/v5.7/mbed-os-api-doxy/classmbed_1_1_file.html">File</a> and <a href="https://os.mbed.com/docs/v5.7/mbed-os-api-doxy/classmbed_1_1_dir_handle.html">Dir</a> . <br><br>  However, in practice there was one interesting nuance. <br>  When trying to declare an object of the ‚Äú <b>File</b> ‚Äù class and use the <b>File</b> method <b>(FileSystem * fs, const char * path, int flags = O_RDONLY)</b> , which was designed to create files, the compiler refused to recognize the object. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/b3f/3e5/d64b3f3e596c73ee4ee4b72dd54b0a22.jpg" alt="image"></div><br>  And when using standard methods of working with streams (‚Äú <b>stdio.h</b> ‚Äù) to create a file, and when trying to further work with it using methods of the ‚Äú <b>File</b> ‚Äù class, such as, for example, <b>read</b> or <b>write</b> , the operating system merrily dumped into <b>mbed_die ()</b> , unrecoverable system error handler. <br><br>  Therefore, for the time being, I will limit myself to writing a letter to <b>ARM</b> support, and we will work with files using the tools of <b>stdio</b> , which, perhaps, will turn out to be more familiar to someone.  A full description of the <b>stdio</b> functionality can be found, for example, on <a href="http://cppstudio.com/cat/309/323/">this site</a> . <br><br>  So, the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;errno.h&gt; // Block device #include "SDBlockDevice.h" // File systems #include "LittleFileSystem.h" SDBlockDevice bdsd(PB_15, PB_14, PB_13, PB_12); // mosi, miso, sclk, cs LittleFileSystem fs("fs"); /******************************************************************************/ // main() runs in its own thread in the OS int main() { printf("--- Mbed OS filesystem example ---\n"); // Try to mount the filesystem printf("Mounting the filesystem... "); fflush(stdout); int err = fs.mount(&amp;bdsd); printf("%s\n", (err ? "Fail :(" : "OK")); if (err) { // Reformat if we can't mount the filesystem // this should only happen on the first boot printf("No filesystem found, formatting... "); fflush(stdout); err = fs.reformat(&amp;bdsd); printf("%s\n", (err ? "Fail :(" : "OK")); if (err) { error("error: %s (%d)\n", strerror(-err), err); } } // Open the LittleFS.txt file FILE *f = fopen("/fs/LittleFS.txt", "r+"); printf("%s\n", (!f ? "Fail :(" : "OK")); if (!f) { // Create the LittleFS file if it doesn't exist printf("No file found, creating a new file... "); fflush(stdout); f = fopen("/fs/LittleFS.txt", "w+"); printf("%s\n", (!f ? "Fail :(" : "OK")); if (!f) { error("error: %s (%d)\n", strerror(errno), -errno); } } printf("\r Closing \"/fs/LittleFS.txt\"... "); fflush(stdout); err = fclose(f); printf("%s\n", (err &lt; 0 ? "Fail :(" : "OK")); if (err &lt; 0) { error("error: %s (%d)\n", strerror(errno), -errno); } // Open the Habrahabr.txt file f = fopen("/fs/Habrahabr.txt", "r+"); printf("%s\n", (!f ? "Fail :(" : "OK")); if (!f) { // Create the LittleFS file if it doesn't exist printf("No file found, creating a new file... "); fflush(stdout); f = fopen("/fs/Habrahabr.txt", "w+"); printf("%s\n", (!f ? "Fail :(" : "OK")); if (!f) { error("error: %s (%d)\n", strerror(errno), -errno); } } printf("\r Closing \"/fs/Habrahabr.txt\"... "); fflush(stdout); err = fclose(f); printf("%s\n", (err &lt; 0 ? "Fail :(" : "OK")); if (err &lt; 0) { error("error: %s (%d)\n", strerror(errno), -errno); } // Display the root directory printf("Opening the root directory... "); fflush(stdout); DIR *d = opendir("/fs/"); printf("%s\n", (!d ? "Fail :(" : "OK")); if (!d) { error("error: %s (%d)\n", strerror(errno), -errno); } printf("root directory:\n"); while (true) { struct dirent *e = readdir(d); if (!e) { break; } printf(" %s\n", e-&gt;d_name); } printf("Closing the root directory... "); fflush(stdout); err = closedir(d); printf("%s\n", (err &lt; 0 ? "Fail :(" : "OK")); if (err &lt; 0) { error("error: %s (%d)\n", strerror(errno), -errno); } // Unmounting printf("Unmounting... "); fflush(stdout); err = fs.unmount(); printf("%s\n", (err &lt; 0 ? "Fail :(" : "OK")); if (err &lt; 0) { error("error: %s (%d)\n", strerror(-err), err); } printf("LittleFS tested successfully!\n"); }</span></span></span></span></code> </pre><br>  First, we create objects of the <b>SDBlockDevice</b> classes (and immediately initialize them, passing the names of the outputs in a strict sequence in accordance with the purpose: <b>mosi</b> , <b>miso</b> , <b>sclk</b> , <b>cs</b> ) and <b>LittleFileSystem (fs)</b> . <br>  Then, already in the ‚Äú <b>main</b> ‚Äù function, we try to mount the file system (which we, of course, will fail when using the new SD card).  Format the media, and mount the file system again. <br><br>  Next, we try to open the files ‚Äú <b>LittleFS.txt</b> ‚Äù and ‚Äú <b>Habrahabr.txt</b> ‚Äù one by one, and, without finding them, create them.  After opening the file must be closed. <br><br>  After successful operations with files, we read the contents of the root directory and output the file names to the I / O terminal.  Close the directory. <br><br>  We dismount the file system and report to the terminal about the successful verification of the file system operation. <br><br>  And here is a screenshot of messages in the debugger terminal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/a81/14b/ef8a8114b78bcf72fc8c4977ced5e3d9.jpg" alt="image"></div><br>  So, today we talked about a promising and, in my opinion, very modern file system for microcontrollers called ‚Äú <b>LittleFileSystem</b> ‚Äù. <br><br>  When the issue is resolved with the use of "native" means of working with files and directories (using the <b>File</b> and <b>Dir</b> classes), I promise an update to the article. <br>  Thank you for attention. <br><br><h3>  UPDATE. </h3><br>  I did not have time to go through the premoderation of the material, as it dawned on me - I incorrectly tried to use the methods of the <b>File</b> class.  To create (or open an existing) file, use the <b>open (FileSystem * fs, const char * path, int flags = O_RDONLY)</b> method <b>;</b>  . <br>  As a result, the code will be supplemented with new objects of the <b>File</b> and <b>Dir</b> classes for working with files and directories, for example, <br><pre> <code class="cpp hljs">File fhandle; Dir dhandle;</code> </pre><br><br>  So the whole example of working with the tools for working with files and directories integrated in <b>mbed os</b> OS will change a little.  Also, besides the fact that we are creating and / or opening files, let's write something down and count it already.  For these purposes we will create two buffers: from one a string will be written to the file, and in the second we count the contents of the file. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 16 char block[BLOCK_SIZE] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"tasty cake"</span></span></span><span class="hljs-meta">; char rblock[BLOCK_SIZE];</span></span></code> </pre><br><br>  So, the code for operations with the contents of the SD card (meanwhile, as we mount and unmount the file system). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************/</span></span> err = fhandle.open(&amp;fs,<span class="hljs-string"><span class="hljs-string">"testing.txt"</span></span>, (O_RDWR|O_TRUNC)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"No file found, creating a new file...\n"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); err = fhandle.open(&amp;fs,<span class="hljs-string"><span class="hljs-string">"testing.txt"</span></span>, (O_RDWR|O_CREAT));} err = fhandle.write(block,<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Writing error!\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Written bytes (%d) ones\n"</span></span>, err); fhandle.rewind(); <span class="hljs-comment"><span class="hljs-comment">//go to the file beginning err = fhandle.read(rblock,10); if (err&lt;0) printf("Reading error!\n"); printf("Read bytes (%d) ones\n", err); printf("Read from file: %s\n", rblock); err = fhandle.size(); printf("File size (%d) bytes\n", err); printf("Closing file..."); err = fhandle.close(); if (err&lt;0) printf("Closing file failure!\n"); else printf("...OK\n"); /******************************************************************************/ // Display the root directory printf("Opening the root directory... "); fflush(stdout); err = dhandle.open(&amp;fs,"/"); if (err&lt;0) printf("Opening directory error\n"); else printf("OK\n"); printf("root directory:\n"); struct dirent *e = dhandle.readdir(); //Get the directory entry while (true) { err = dhandle.read(e); //Read while != 0 (end) if (!err) { break; } printf(" %s\n", e-&gt;d_name); } printf("Closing the root directory... "); fflush(stdout); err = dhandle.close(); if (err&lt;0) printf("Closing directory error\n"); else printf("OK\n"); /******************************************************************************/</span></span></code> </pre><br>  At the very beginning we are trying to open the <b>testing.txt</b> file for reading / writing.  Note that in addition to the basic parameters (file system and file name), we pass the <b>O_RDWR</b> and <b>O_TRUNC</b> flags to the method, combined using the ‚Äúor‚Äù bit operation: this is how the operating system rules work.  The first means that we create or open a file for writing / reading, the second - that the file will be completely overwritten, even if it exists, and is filled with any information.  The full list of flags is given in the header file " <b>mbed_retarget.h</b> ": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDONLY 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///&lt; Open for reading #define O_WRONLY 1 ///&lt; Open for writing #define O_RDWR 2 ///&lt; Open for reading and writing #define O_CREAT 0x0200 ///&lt; Create file if it does not exist #define O_TRUNC 0x0400 ///&lt; Truncate file to zero length #define O_EXCL 0x0800 ///&lt; Fail if file exists #define O_APPEND 0x0008 ///&lt; Set file offset to end of file prior to each write #define O_BINARY 0x8000 ///&lt; Open file in binary mode</span></span></span></span></code> </pre><br>  In case of successful opening (creating) a file, we write to it what is contained in the <b>block</b> buffer, or rather, the first 10 bytes.  The result of the operation will be the number of bytes written upon successful recording, and we output this value to the terminal during debugging. <br>  To successfully read data from a file, we need to go back to the beginning of the file, and we do this with <b>fhandle.rewind ()</b> .  We also count the few bytes, and output their number to the terminal, as well as the file size ( <b>fhandle.size ()</b> ). <br>  In the process of debugging, we look into the <b>rblock</b> buffer, in which we read a line from a file.  Everything is good: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfc/4d1/4c6/cfc4d14c60d81467a2d4813ed13f7bd6.jpg" alt="image"></div><br>  We indulged with the file, now let's see what is in the root directory of the file system.  Open the directory and get the number of entries in the directory: <b>dhandle.readdir ()</b> .  Now we read the name of all files, until <b>dhandle.read (e)</b> returns ‚Äú0‚Äù - there are no more entries in the directory.  Print the file names, close the directory. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/058/a60/e67/058a60e675c52dd53d6c53490fc79342.jpg" alt="image"></div><br>  We admire the lines in the debug terminal. <br>  Thanks again to everyone. </div><p>Source: <a href="https://habr.com/ru/post/347348/">https://habr.com/ru/post/347348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347338/index.html">The obvious benefit: how and why to use the service approach beyond IT</a></li>
<li><a href="../347340/index.html">Scales and barcodes: How retailers and manufacturers ended up in a deep ... puddle</a></li>
<li><a href="../347342/index.html">Navalny Headquarters IT infrastructure and signature collection: project management</a></li>
<li><a href="../347344/index.html">Features of industrial aerial photography. Part I. Preparatory rake</a></li>
<li><a href="../347346/index.html">How to use all the features of mobile OS in React Native</a></li>
<li><a href="../347350/index.html">Style Tips. How to write a readable React code</a></li>
<li><a href="../347352/index.html">Interaction of C # and C ++ cross-platform</a></li>
<li><a href="../347354/index.html">Learn OpenGL. Lesson 4.5 - Framebuffer</a></li>
<li><a href="../347358/index.html">Unit tests. Quick start - effective result (with examples in C ++)</a></li>
<li><a href="../347360/index.html">How we built the data infrastructure in Wish</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>