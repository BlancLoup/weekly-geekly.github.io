<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ReactiveX 2.0 with examples, or grokay reactive programming 2.0. Part 1: Observable vs Flowable, Backpressure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Alex. I write Backend's on Kotlin, as well as developing Android applications. I suffered for a long time: I was tormented with CallBac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ReactiveX 2.0 with examples, or grokay reactive programming 2.0. Part 1: Observable vs Flowable, Backpressure</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/02f/800/552/02f8005527394df1806c26165843aa17.jpg" alt="image"><br><p>  Hi, my name is Alex.  I write Backend's on Kotlin, as well as developing Android applications.  I suffered for a long time: I was tormented with CallBack Hell, imperative style, thread synchronization and other classic Java problems on Android.  It was a huge pain.  And I started looking for some solution to somehow get rid of this pain.  And a happy occasion comes - I meet the increasing hype on RxJava.  After trying, I can not stop to this day.  At the time of this writing, RxJava 2.0 has been released and there is a strong desire to understand the innovations.  At the official source, in the Github Wiki, the chapter appeared RxJava 2.0: What's different in 2.0.  But, unfortunately, I am not the owner of "fluent" English, and reading of such important docks took time.  Accumulated some notes, there was a concept that I want to share.  But in order not to become the ‚ÄúArt Director of Art Space‚Äù and not to bring a banal translation, but some kind of profit, this article will be a mixture of tutorial and wiki translation, seasoned with real examples of user cases on RxKotlin. </p><br><p>  Since the approaches to the development of Web and Android applications differ, as is the context for using Rx, respectively, the conversation will be conducted in the context of Android development.  Who are interested, please under the cat. </p><a name="habracut"></a><br><h2>  Brief introduction </h2><br><p>  Before starting, I would advise you to read a chic series of articles </p><br><ul><li>  <a href="https://habrahabr.ru/post/265269/">Grokay * RxJava, Part One: The Basics</a> </li><li>  <a href="https://habrahabr.ru/post/265583/">Grokayem RxJava, part two: Operators</a> </li><li>  <a href="https://habrahabr.ru/post/265727/">Grokayem RxJava, Part Three: Reactivity with Benefit</a> </li><li>  <a href="https://habrahabr.ru/post/265997/">Grokay RxJava, part four: Jet Android</a> </li></ul><br><p>  And I also liked <a href="https://habrahabr.ru/post/317928/">this article</a> , which I also recommend reading. </p><br><p>  RxJava 2.0 has been completely rewritten from scratch on top of the Reactive Streams specification.  The specification itself evolved from RxJava 1.x and provides a common baseline for reactive systems and libraries. </p><br><p>  Since Reactive-Streams has a different architecture, it provides for modifications of some known types of RxJava.  For a few articles, I will try to summarize what has changed and tell you how to rewrite code 1.x to code 2.x. </p><br><h2>  NullPointerException </h2><br><p> Yes, RxJava 2.x will no longer accept NULL values, and the following code will immediately result in a <code>NullPointerException</code> , or an <code>Emitter</code> (spawning thread) will throw an onError event. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullPointerActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obsJust: TextView? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> singleJust: TextView? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callable: TextView? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nullMaping: TextView? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> verticalLayout { obsJust = textView() singleJust = textView() callable = textView() nullMaping = textView() } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Observable.just(<span class="hljs-literal"><span class="hljs-literal">null</span></span>).subscribe() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { obsJust?.text = e.localizedMessage e.printStackTrace() } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Single.just(<span class="hljs-literal"><span class="hljs-literal">null</span></span>).subscribe() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { singleJust?.text = e.localizedMessage e.printStackTrace() } Observable.fromCallable{<span class="hljs-literal"><span class="hljs-literal">null</span></span>}.subscribe({Log.d(<span class="hljs-string"><span class="hljs-string">"NullPointerActivity"</span></span>, it)}, { callable?.text = it.localizedMessage it.printStackTrace() }) Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>).map{<span class="hljs-literal"><span class="hljs-literal">null</span></span>}.subscribe({Log.d(<span class="hljs-string"><span class="hljs-string">"NullPointerActivity"</span></span>, it)}, { nullMaping?.text = it.localizedMessage it.printStackTrace() }) } }</code> </pre><br><p>  This means that <code>Observable&lt;Void&gt;</code> can no longer generate any events, and the stream, whether hot or cold, can only end with an <code>onComplete</code> or <code>onError</code> .  Well, in some cases, it can just throw Exception even before wrapping the value into a stream, as happens with <code>Single.just(null)</code> and <code>Observable.just(null)</code> </p><br><p>  When designing / implementing custom <code>Observable</code> you do not need to define specific types for <code>ObservableEmitter&lt;Any&gt;</code> , which replaced <code>Observable.OnSubscribe&lt;Any&gt;</code> .  For example, if you need a source that is similar to signaller, you can define <i>Enum</i> and throw its singleton on <code>onNext</code> : </p><br><pre> <code class="hljs pgsql">enum <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Irrelevant { INSTANCE; } val source = Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>&gt; {emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>.d(TAG, "Side-effect 1") emitter.onNext(Irrelevant.INSTANCE) <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>.d(TAG, "Side-effect 2") emitter.onNext(Irrelevant.INSTANCE) <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>.d(TAG, "Side-effect 3") emitter.onNext(Irrelevant.INSTANCE) } source.subscribe({<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>.d(TAG, it.toString())}, Throwable::printStackTrace)</code> </pre><br><p>  And as a result, the log will write what was expected: </p><br><blockquote>  D / NullPointerActivity: Side-effect 1 <br>  D / NullPointerActivity: INSTANCE <br>  D / NullPointerActivity: Side-effect 2 <br>  D / NullPointerActivity: INSTANCE <br>  D / NullPointerActivity: Side-effect 3 <br>  D / NullPointerActivity: INSTANCE </blockquote><br><h2>  Observable vs.  Flowable </h2><br><p>  Unfortunately, prior to Rx 2.0, Backpressure was introduced directly into Observable, rather than a separate class with its support.  The main problem with Backpressure is that many hot Observables cannot be sufficiently reliable, and under certain circumstances can cause an unexpected <b>MissingBackpressureException</b> .  And without a certain accumulated experience, it is very difficult to predict such an exception. </p><br><p>  Rx 2.0 fixes this situation.  Observable is a class without backpressure, and the new Flowable has been endowed with a backpressure out of the box.  Next, we consider the variations where and in which case to use Flowable, and where Observable. </p><br><h3>  So what time to use? </h3><br><p>  This question is perhaps the most logical.  When implementing your repository classes, business logic classes, when deciding which type, <code>Observable</code> or <code>Flowable</code> , should be accepted and returned, you should consider several factors that will help you avoid problems in getting exceptions such as <b>MissingBackpressureException</b> or <b>OutOfMemoryError</b> because  inaccurate use of the wrong type leads to a drop in fps on a performance. </p><br><h3>  When to use Observable </h3><br><p>  In those cases, when you have in iteration, relatively speaking, no more than 1000 elements, while this is the worst case and does not imply scaling, you do not need backpressure.  In general, we can say that if you feel that there is no chance for an <b>OutOfMemoryException</b> in any particular case, then this is exactly the case when Observable can and should be used.  These are mainly UI use cases, a wide variety of events onClick, Touch, Pointer-movement, etc.  In fact, these are any events whose frequency does not exceed 1000 Hz.  Agree, you are unlikely to be able to click on the touchscreen more than 1000 times per second.  But still do not forget the operator debounce. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span><span class="hljs-class">() { override fun onCreate(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">savedInstanceState</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bundle</span></span></span><span class="hljs-class">?) { super.onCreate(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">savedInstanceState</span></span></span><span class="hljs-class">) setContentView(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layout</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">activity_main</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RxView</span></span></span><span class="hljs-class">.clicks(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">backpressure</span></span></span><span class="hljs-class">) .debounce(200, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TimeUnit</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MILLISECONDS</span></span></span><span class="hljs-class">) .subscribe ({ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">openNewScreen</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BackpressureExampleActivity</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Throwable</span></span></span><span class="hljs-class">::printStackTrace) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RxView</span></span></span><span class="hljs-class">.clicks(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullpointer</span></span></span><span class="hljs-class">) .debounce(200, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TimeUnit</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MILLISECONDS</span></span></span><span class="hljs-class">) .subscribe ({ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">openNewScreen</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullPointerActivity</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Throwable</span></span></span><span class="hljs-class">::printStackTrace) } }</span></span></code> </pre> <br><p>  <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> I think everyone knows that the Jake Wharton library returns Observable when binding View, and this fully justifies the concept of Rx2.x </p><br><h3>  When is Flowable? </h3><br><p>  When you are already dealing with large or unpredictable amounts of data, say over 10,000 items, or in situations with continuous data generation.  Also, the reason for using Flowable is parsing, reading data from a variety of storage media (Internal / External storage). </p><br><p>  Reading from a database using SQLiteOpenHelper is also a pretext for using Flowable.  Therefore, if you use the <a href="https://github.com/square/sqlbrite">https://github.com/square/sqlbrite</a> and <a href="https://github.com/pushtorefresh/storio">https://github.com/pushtorefresh/storio</a> libraries, it would not be superfluous to bring the Observable to Flowable.  Querying backends is another reason to use Flowable. </p><br><p>  If you take a closer look, you can notice a common detail in all the listed cases - they block the UI thread.  Accordingly, if you perform any operations blocking MainThread, this is a reason to use Flowable. </p><br><p>  And finally.  Many blocking and / or pull-based data sources, from which you can eventually get a non-blocking reactive API (Retrofit) are also grounds for using Flowable. </p><br><h3 id="popodrobnee-o-backpressure">  More about Backpressure </h3><br><p>  <strong>Backpressure</strong> is a phenomenon that can be found in the spawning thread, where some asynchronous operations cannot process values ‚Äã‚Äãquickly enough and need to slow down the manufacturer. </p><br><p>  A classic case for using backpressure when a generating thread is hot: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BackpressureExampleActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n = <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContentView(R.layout.activity_backpressure) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source = PublishProcessor.create&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() source .observeOn(AndroidSchedulers.mainThread()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::addToIntListAdapter, Throwable::printStackTrace, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onComplete) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n) { source.onNext(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == n) { source.onComplete() } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToIntListAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { Log.d(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, number.toString()) <span class="hljs-comment"><span class="hljs-comment">// do something } private fun onComplete() { textView?.text = "completed" } }</span></span></code> </pre> <br><p>  <strong>PublishProcessor</strong> is a slightly different form of the <strong>Observable</strong> we are used to.  As you can see, it has a more imperative form. </p><br><p>  In this example, the main thread will produce N elements.  Imagine that the <code>addToIntListAdapter(int number)</code> method adds the next incoming element to the adapter that is attached to <code>RecyclerView</code> .  This will take some time, and Overhead for the current request stack may be longer than the execution time.  However, the producing thread with a <code>for</code> loop cannot know this and continues to call <code>onNext</code> . </p><br><p>  Inside asynchronous statements, there are buffers for storing such elements until they are processed.  In RxJava 1.x, these buffers were unlimited, which means that they are likely to contain all n elements from the example.  The problem begins when n = 1000000. In the classic view, this would lead to <code>OutOfMemoryError</code> or, as a rule, to friezes of performance due to excessive GC-intensive work and, as a result, to its frequent call. </p><br><p>  Just as error handling became a mandatory part of Rx and received operators for working with it (via the <code>onErrorReturn</code> , <code>onErrorResumeNext</code> , <code>doOnError</code> ), Backpressure is another property of data streams that the developer must think about and process, directly through the <code>onBackpressureBuffer</code> , <code>onBackpressureDrop</code> , <code>onBackpressureLast</code> . </p><br><p>  In the case of n = 1000000 we get: </p><br><blockquote>  W / System.err: io.reactivex.exceptions.MissingBackpressureException: Could not emit value due to lack of requests <br>  W / System.err: at io.reactivex.processors.PublishProcessor $ PublishSubscription.onNext (PublishProcessor.java:322) <br>  W / System.err: at io.reactivex.processors.PublishProcessor.onNext (PublishProcessor.java:198) <br>  W / System.err: at mobile.geekbit.rx20habrahabrproject.backpressure.BackpressureExampleActivity.onCreate (BackpressureExampleActivity.kt: 30) <br>  W / System.err: at android.app.Activity.performCreate (Activity.java:6679) <br>  W / System.err: at android.app.Instrumentation.callActivityOnCreate (Instrumentation.java:1118) <br>  W / System.err: at android.app.ActivityThread.performLaunchActivity (ActivityThread.java:2618) <br>  W / System.err: at android.app.ActivityThread.handleLaunchActivity (ActivityThread.java:2726) <br>  W / System.err: at android.app.ActivityThread.-wrap12 (ActivityThread.java) <br>  W / System.err: at android.app.ActivityThread $ H.handleMessage (ActivityThread.java:1477) <br>  W / System.err: at android.os.Handler.dispatchMessage (Handler.java:102) <br>  W / System.err: at android.os.Looper.loop (Looper.java:15) <br>  W / System.err: at android.app.ActivityThread.main (ActivityThread.java:6119) <br>  W / System.err: at java.lang.reflect.Method.invoke (Native Method) <br>  W / System.err: at com.android.internal.os.ZygoteInit $ MethodAndArgsCaller.run (ZygoteInit.java:886) <br>  W / System.err: at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:776) </blockquote><p>  And if we still call <code>Thread.sleep(10000)</code> on the UI thread, then the Activity will start, of course, with terrible friezes, calling GC 7-8 times! </p><br><p>  In addition to the above-mentioned <code>PublishProcessor</code> there are other operators that do not support backpressure.  For example, <code>Observable.interval</code> periodically generates values ‚Äã‚Äãfaster than they can be processed. </p><br><p>  In RxJava 2.x, most asynchronous operators now have a limited internal buffer, and any attempt to overflow this buffer completes the entire sequence using a MissingBackpressureException.  The documentation has a section on Backpressure and the operators that support it <a href="http://reactivex.io/documentation/operators/backpressure.html">http://reactivex.io/documentation/operators/backpressure.html</a> </p><br><p>  However, backpressure is also found in more unexpected places: in normal cold streams that do not and should not give a MissingBackpressureException.  If we take our example above and refactor: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BackpressureExampleActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> n = <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContentView(R.layout.activity_backpressure) Flowable.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n) .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::addToIntListAdapter, Throwable::printStackTrace, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToIntListAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { Log.d(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, number.toString()) <span class="hljs-comment"><span class="hljs-comment">// do something } private fun onComplete() { textView?.text = "completed" } }</span></span></code> </pre><br><p>  Everything will start without <code>MissingBackpressureException</code> , perfomance will work in stable fps, smoothly and with adequate memory usage, the amount of which will be allocated much less.  The reason for this is that many manufacturing operators can ‚Äúgenerate‚Äù values ‚Äã‚Äãon demand and, thus, oversee the operator.  We can say that <code>Flowable.range(0, n)</code> generates as many values ‚Äã‚Äãas the buffer can hold without overflowing.  Let's all look at a more specific example: </p><br><pre> <code class="hljs kotlin"> Flowable.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n) .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : DisposableSubscriber&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { request(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { addToIntListAdapter(v) request(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ex: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ex.printStackTrace() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { onComplete() } })</code> </pre> <br><p>  Here, the <code>onStart</code> implementation specifies the range to create its first value, which is then taken in <code>onNext</code> .  Upon completion of the operation, another value is requested from the range.  In the normal implementation of the range, such a call recursively calls onNext, which results in a <code>StackOverflowError</code> , which, of course, is undesirable. </p><br><p>  To prevent <code>StackOverflowError</code> , operators use <em>trampolining</em> (in translation, the term can be defined as a <strong>trampoline</strong> ).  This is conventionally called logic, which prevents repeated calls.  It can very often be found in functional languages ‚Äã‚Äãsuch as Clojure, Scala, and, in particular, in recursive calls.  In terms of the range, the trampoline will remember that there was a call to request (1), while it called onNext ().  And as soon as onNext () returns, it will call the next onNext () with the following value.  Therefore, if they change places, the example above will still work identically: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { addToIntListAdapter(v) request(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  However, this does not work for onStart.  Although the Flowable infrastructure guarantees that it will be called no more than once for each Subscriber, calling request (1) can immediately trigger a new element.  If you have initialization logic after calling request (1), which is necessary for onNext, you may have exceptions: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntMapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> KOFF = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = int ?: <span class="hljs-number"><span class="hljs-number">0</span></span> * KOFF } Flowable.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : DisposableSubscriber&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapper: IntMapper <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { request(<span class="hljs-number"><span class="hljs-number">1</span></span>) mapper = IntMapper() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { addToIntListAdapter(mapper.map(v)) request(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ex: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ex.printStackTrace() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { onComplete() } })</code> </pre><br><p>  In this case, you may throw a NullPointerException.  And given the feature of Null Safety in Kotlin, I had to try to get this exception.  And please take into account one feature - I removed the operators </p><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.subscribeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Schedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.computation</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.observeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">AndroidSchedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mainThread</span></span>())</code> </pre> <br><p>  because with them, you will not get a NullPointerException, because the nature of these operators is asynchronous. <br>  And it is in this synchronous case that you will receive an immediate NullPointerException as soon as the onStart call occurs.  Moreover, this error is more difficult to catch if the request (1) call is accompanied by an asynchronous onNext call in another thread, due to which Race Condition occurs. </p><br><p>  Thus, you need to perform all initializing operations in onStart or, even better, before it, and request request () last. </p><br><h4 id="operatory-onbackpressurebuffer-onbackpressuredrop-onbackpressurelast">  Operators onBackpressureBuffer, onBackpressureDrop, onBackpressureLast </h4><br><p>  Most developers face back pressure when their application crashes with a MissingBackpressureException, and the logs usually point to the observeOn operator.  The actual reason is, as a rule, the use of PublishProcessor, Observable, as well as the timer (), interval () or custom lift () operators, as well as the operations that occur in create (). </p><br><p>  There are several ways to solve such situations, and now we will consider them. </p><br><ol><li>  Increasing buffer sizes </li></ol><br><p>  Sometimes such overflows occur due to potentially dangerous sources.  For example, all of a sudden, the user drops too fast on the screen and the observeOn buffer is very quickly and actively overflowing. </p><br><p>  I would like to dwell on the buffer itself.  An appropriate question may arise: what is it all about and how is it involved in the Rx mechanism?  Everything is actually quite simple.  To begin with, the default buffer dimension is calculated as <code>Math.max(1, Integer.getInteger("rx2.buffer-size", 128))</code> , and according to my observations, this method always returns 128 (the captain obviously does not sleep).  As a result, we get a buffer with a dimension of 128 ... mm ... what?  Bit?  Byte?  Parrots?  We can get the answer to this question here: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@CheckReturnValue</span></span> <span class="hljs-meta"><span class="hljs-meta">@BackpressureSupport</span></span>(BackpressureKind.FULL) <span class="hljs-meta"><span class="hljs-meta">@SchedulerSupport</span></span>(SchedulerSupport.CUSTOM) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Flowable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scheduler scheduler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delayError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bufferSize)</span></span></span><span class="hljs-function"> </span></span>{ ObjectHelper.requireNonNull(scheduler, <span class="hljs-string"><span class="hljs-string">"scheduler is null"</span></span>); ObjectHelper.verifyPositive(bufferSize, <span class="hljs-string"><span class="hljs-string">"bufferSize"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RxJavaPlugins.onAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowableObserveOn&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, scheduler, delayError, bufferSize)); }</code> </pre> <br><p>  The <code>bufferSize</code> parameter <code>bufferSize</code> checked modulo and sent to the <code>FlowableObserveOn</code> instance. </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prefetch; <span class="hljs-comment"><span class="hljs-comment">//    bufferSize public FlowableObserveOn( Flowable&lt;T&gt; source, Scheduler scheduler, boolean delayError, int prefetch) { super(source); this.scheduler = scheduler; this.delayError = delayError; this.prefetch = prefetch; }</span></span></code> </pre> <br><p>  Further in onSubscribe we already see something familiar. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -  s.request(prefetch); // -  }</span></span></code> </pre><br><p>  And it turns out that we actually already used the buffer, just did not know about it. <br>  request (1) remember?  So, this is what the <code>Subscription</code> interface actually looks like. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Where <code>request(long n)</code> nothing more than the number of elements for requests to the upstream. <br>  So, we can conclude that the buffer is the same <code>request(n)</code> .  But how to tell Flowable its buffer size?  About this below. </p><br><p>  Most of the backpressure-sensitive operators in the latest versions of RxJava now allow developers to specify the size of their internal buffers.  The corresponding parameters are called bufferSize, prefetch or capacityHint.  Given the overflowed example in the introduction, we can simply increase the buffer size for the PublishProcessor to have enough space for all values. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source = PublishProcessor.create&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() source .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::addToIntListAdapter, Throwable::printStackTrace, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onComplete) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n) { source.onNext(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == n) { source.onComplete() } } Thread.sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>)</code> </pre> <br><p>  But note that, in principle, this is a crutch, since an overflow can still occur if the manufacturer generates more than the size of the predicted buffer.  In this case, you can use one of the operators in the next section. </p><br><ol><li>  Grouping / passing / buffering values ‚Äã‚Äãwith standard operators </li></ol><br><p>  If the source data can be processed more efficiently in a grouped form, you can reduce the chance of eliminating MissingBackpressureException using one of the standard batch processing operators (by size or by time). </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source = PublishProcessor.create&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() source .buffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) .flatMap { PublishProcessor.fromIterable(it) } .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::addToIntListAdapter, Throwable::printStackTrace, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onComplete) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n) { source.onNext(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == n) { source.onComplete() } } Thread.sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>)</code> </pre> <br><p>  In that case, when some of the values ‚Äã‚Äãcan be safely ignored, you can use the sampling (sample operator) and throttling operators (throttleFirst, throttleLast, throttleWithTimeout). </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source = PublishProcessor.create&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() source .sample(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::addToIntListAdapter, Throwable::printStackTrace, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onComplete) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n) { source.onNext(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == n) { source.onComplete() } }</code> </pre> <br><p>  However, these operators only reduce the downstream admission rate and, therefore, may still result in a MissingBackpressureException exception. </p><br><ol><li>  OnBackpressureBuffer () operator </li></ol><br><p>  This operator in its basic form re-introduces an unrestricted buffer between the original source and the downstream operator.  This means that until memory is exhausted, it can handle almost any amount from a continuously generating source. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Flowable</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.range</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.onBackpressureBuffer</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Schedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.computation</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.observeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">AndroidSchedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mainThread</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::addToIntListAdapter</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Throwable</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::printStackTrace</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::onComplete)</span></span></code> </pre> <br><p>  In this example, the <code>observeOn</code> function has a very low buffer size (recall that it is 128 by default), but there is no <code>MissingBackpressureException</code> exception, since <code>onBackpressureBuffer</code> absorbs all <strong>n</strong> values ‚Äã‚Äã(of which <code>val n = 1000000</code> ) and transmits to <br>  Execution packets (batch) values ‚Äã‚Äãin small batches. <br>  It is worth noting that the <code>onBackpressureBuffer</code> operator consumes the generating source in an unlimited way, that is, without applying back pressure to it.  This leads to the fact that even manufacturers such as range () will be fully executed. </p><br><p>  There are also several overloaded forms with the <code>onBackpressureBuffer</code> operator.  I will give the most necessary. </p><br><p>  <strong>onBackpressureBuffer (int capacity)</strong> </p><br><p>  This is a limited version that will notify about the occurrence of a <code>BufferOverflowException</code> when the buffer reaches the specified capacity. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Flowable</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.range</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.onBackpressureBuffer</span></span>(16) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Schedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.computation</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.observeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">AndroidSchedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mainThread</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::addToIntListAdapter</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Throwable</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::printStackTrace</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::onComplete)</span></span></code> </pre> <br><p>  The adequacy of this operator decreases, as more and more operators now allow you to set the size of your buffers.  Otherwise, it gives you the opportunity to expand your internal buffer. </p><br><p>  <strong>onBackpressureBuffer (int capacity, Action onOverflow)</strong> </p><br><p>  This overloaded method causes a callback in case of overflow.  Action itself does not represent <br>  nothing out of the ordinary </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br><p>  But it is worth noting that its utility is rather limited, since there is no other information about overflow than the current call stack. </p><br><p>  <strong>onBackpressureBuffer (int capacity, Action0 onOverflow, BackpressureOverflowStrategy strategy)</strong> </p><br><p>  But this option is really something interesting.  Its utility is somewhat higher, as it allows you to determine what to do if the capacity has been reached.  BackpressureOverflowStrategy is enum, which offers 3 static fields with implementations representing typical actions on: </p><br><p>  <strong>ERROR</strong> is the default behavior for all previous overloads, throwing a BufferOverflowException. </p><br><p>  <strong>DROP_OLDES</strong> - in essence, this means updating the buffer when it overflows.  All old values ‚Äã‚Äãare discarded and the buffer is filled with a new stack. </p><br><p>  <strong>DROP_LATEST</strong> is a slightly different behavior, characterized in that if an overflow occurs, the current value will simply be ignored and only the old values ‚Äã‚Äãwill be delivered after downstream requests. </p><br><pre> <code class="hljs kotlin">Flowable.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n) .onBackpressureBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>, { Toast.makeText(baseContext, BufferOverflowException::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simpleName</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Toast.LENGTH_SHORT).show</span></span></span></span>() }, BackpressureOverflowStrategy.DROP_LATEST) .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::addToIntListAdapter, Throwable::printStackTrace, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onComplete)</code> </pre> <br><p>   ,   ,           .  ,        BufferOverflowException. </p><br><p>      BackpressureOverflowStrategy.      onBackpressureDrop()  onBackpressureLatest().      . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Flowable</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.range</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.onBackpressureDrop</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Schedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.computation</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.observeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">AndroidSchedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mainThread</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::addToIntListAdapter</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Throwable</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::printStackTrace</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::onComplete)</span></span></code> </pre> <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Flowable</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.range</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.onBackpressureLatest</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Schedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.computation</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.observeOn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">AndroidSchedulers</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mainThread</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::addToIntListAdapter</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Throwable</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::printStackTrace</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::onComplete)</span></span></code> </pre> <br><p>  ,    ,   backpressure         .        ,     ,      , .. ...     ,    <code>onBackpressure</code>     ,        . </p><br><p>        backpressured datasources,      .      . </p><br><p>      <a href="https://github.com/scrobot/Rx2.0habrahabrproject">https://github.com/scrobot/Rx2.0habrahabrproject</a> </p><br><p>        </p><br><ul><li> Single </li><li> Completable- </li><li> Maybe- </li><li>    </li><li> Subjects  Processors </li><li>  interfaces </li><li> Subscriber </li><li>  Subscription </li><li> Backpressured datasources </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336268/">https://habr.com/ru/post/336268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336258/index.html">Reporting in 1C: Data Composition System (ACS), idea and architecture</a></li>
<li><a href="../336260/index.html">Swift Mutexes and Capture</a></li>
<li><a href="../336262/index.html">Configuring IDE Clion and Cmake to work with STM32 and C ++</a></li>
<li><a href="../336264/index.html">One step closer to C ++ 20. Results of the meeting in Toronto</a></li>
<li><a href="../336266/index.html">Advanced Jekyll</a></li>
<li><a href="../336270/index.html">Brief reaction to Xored material</a></li>
<li><a href="../336272/index.html">Types of models</a></li>
<li><a href="../336276/index.html">How I created a monitoring system for computers at work and moved the service to Amazon AWS</a></li>
<li><a href="../336278/index.html">Using the system API in Sailfish OS</a></li>
<li><a href="../336280/index.html">Angular Basics: HttpClient</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>