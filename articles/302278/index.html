<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker Container Development with Sparrow Multipurpose Scripting System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to tell how you can create image building scripts for Docker containers using the Sparrow * multi-purpose scripts system...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker Container Development with Sparrow Multipurpose Scripting System</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, I would like to tell how you can create image building scripts for <a href="https://www.docker.com/">Docker</a> containers using the <a href="https://github.com/melezhik/sparrow">Sparrow *</a> multi-purpose scripts <a href="https://github.com/melezhik/sparrow">system</a> . </p><br><a name="habracut"></a><br><p>  <em>(*) Note - to understand some of the technical nuances of this article, it is desirable to have at least a superficial acquaintance with the Sparrow multipurpose scripting system, a brief introduction to which (besides the <a href="https://github.com/melezhik/sparrow">documentation pages</a> ) can be found in my <a href="https://habrahabr.ru/post/300876/">previous article</a> on habrahabr.ru.</em> </p><br><h1>  Docker Container Development </h1><br><p>  Initially, a little problematic.  We have the task to describe the Docker image assembly using the <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> .  If the build script is non-trivial and contains many instructions, you need to somehow get out.  Besides the fact that the Dockerfile cannot contain more than 120 layers (as far as I correctly understood from the Docker documentation), it‚Äôs not very pleasant to deal with the spreading Dockerfile.  What can you do about it?  The obvious options are to put the build code into separate Bash scripts in the working directory and install and configure the system directly from them.  Another way is to fasten a configuration management tool like chef or ansible to the side.  I leave it at the mercy of the reader to evaluate these alternatives (IMHO they have their pros and cons) and suggest a third way - using Sparrow. </p><br><p>  Before giving the details of the implementation I want to say: </p><br><ul><li><p>  The variant with Sparrow is very similar to the use of Bash scripts, with the only difference that the entire installation logic is placed in the Sparrow plugin, with its source code stored in a separate place (git repository or central repository). </p><br></li><li><p>  Thus, the basic configuration of the system in the context of Docker is described in the Dockerfile, and the more subtle and complex inside the Sparrow plugin. </p><br></li><li> Plug-in development can be <em>separated</em> from the Dockerfile context - which is convenient, for example, you can debug the installation process on an existing Docker container, using the <code>docker build</code> command to build the image each time, and once the plugin is debugged and ready for work, you can run full system build cycle using the same <code>docker build</code> (while dropping the docker cache, of course). </li></ul><br><h1>  Implementation example </h1><br><p>  So, we will show everything on a specific system.  It is required to build an image with the CentOS distribution and install an application written in <a href="https://www.ruby-lang.org/en/">Ruby</a> version equal to 2.3.  After that, run the main application script from under the selected user.  The source code of the application is downloaded from a certain archive server.  The example is taken from real life, although some details are intentionally omitted so as not to overload the article with material. </p><br><h1>  Basic system configuration </h1><br><p>  Before writing the plugin code, create a Dockerfile.  I took <a href="https://hub.docker.com/r/tutum/centos/">tutum / centos</a> for a basic image because of its lightness.  For the same reason, some packages have to be delivered, but in general this is not a problem. </p><br><pre> <code class="hljs cmake">$ cat Dockerfile FROM tutum/centos MAINTAINER <span class="hljs-string"><span class="hljs-string">"melezhik"</span></span> &lt;melezhik@gmail.com&gt; RUN yum clean all RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> nano git-core RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> make RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> gcc RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> perl perl-devel \ perl-<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>-Simple perl-Digest-SHA perl-Digest-MD5 perl-CPAN-Meta \ perl-CPAN-Meta-Requirements perl-Getopt-Long \ perl-JSON perl-Module-CoreList perl-Module-Metadata perl-parent perl-Path-Tiny perl-Try-Tiny \ perl-App-cpanminus perl-JSON-PP perl-Algorithm-Diff perl-Text-Diff \ perl-Spiffy perl-<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>-Base perl-YAML perl-<span class="hljs-keyword"><span class="hljs-keyword">File</span></span>-ShareDir-<span class="hljs-keyword"><span class="hljs-keyword">Install</span></span> perl-Class-Inspector \ perl-<span class="hljs-keyword"><span class="hljs-keyword">File</span></span>-ShareDir perl-<span class="hljs-keyword"><span class="hljs-keyword">File</span></span>-ShareDir-<span class="hljs-keyword"><span class="hljs-keyword">Install</span></span> perl-Config-General RUN cd /bin/ &amp;&amp; curl -L https://cpanmin.us/ -o cpanm &amp;&amp; chmod +x cpanm RUN cpanm Sparrow -q</code> </pre> <br><p>  A few comments on the Dockerfile. </p><br><ul><li><p>  <code>nano</code> and <code>git-core</code> needed to develop the Sparrow plugin (see below) - we will edit the script code and commit the changes to the remote <a href="https://git-scm.com/">git</a> repository. </p><br></li><li><p>  <code>gcc</code> , <code>make</code> will be required to build <a href="https://rubygems.org/">RubyGems</a> and <a href="http://www.cpan.org/">CPAN</a> packages.  The first will be required when installing Ruby via <a href="https://rvm.io/">rvm</a> , the last to install Sparrow. </p><br></li><li><p>  Installing multiple <code>perl-*</code> packages through <code>yum</code> necessary to optimize the build process for speed, one would not have to do this, because  The following <code>cpanm -q Sparrow</code> instruction would install the required dependencies itself, but installing dependencies via <a href="https://metacpan.org/pod/distribution/App-cpanminus/bin/cpanm">cpanm</a> generally takes much longer than setting the ‚Äúnative‚Äù rpm- <a href="https://metacpan.org/pod/distribution/App-cpanminus/bin/cpanm">centOS</a> for CentOS. </p><br></li><li>  The <code>cpanm Sparrow -q</code> instruction <code>cpanm Sparrow -q</code> a multi-purpose scripting development environment, do not forget that we are going to develop Sparrow directly on a running Docker container. </li></ul><br><p>  So, let's try to create an image: </p><br><pre> <code class="hljs ruby">$ docker build -t ruby_app . ... ... Successfully built <span class="hljs-number"><span class="hljs-number">25</span></span>e7cd784c99</code> </pre> <br><h1>  We are starting to develop a plugin </h1><br><p>  Great, we have an image with the basic infrastructure, you can run the Docker container and start developing the plugin right on it. </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>docker run -t -i ruby_app /bin/bash <span class="hljs-string"><span class="hljs-string">$ </span></span>mkdir ruby-app <span class="hljs-string"><span class="hljs-string">$ </span></span>cd ruby-app <span class="hljs-string"><span class="hljs-string">$ </span></span>git init . <span class="hljs-string"><span class="hljs-string">$ </span></span>git remote add origin https://github.com/melezhik/ruby-app.git <span class="hljs-string"><span class="hljs-string">$ </span></span>touch <span class="hljs-type"><span class="hljs-type">README</span></span>.md <span class="hljs-string"><span class="hljs-string">$ </span></span>git add <span class="hljs-type"><span class="hljs-type">README</span></span>.md <span class="hljs-string"><span class="hljs-string">$ </span></span>git config --global user.email <span class="hljs-comment"><span class="hljs-comment">"melezhik@gmail.com"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git config --global user.name <span class="hljs-comment"><span class="hljs-comment">"Alexey Melezhik"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit -a -m <span class="hljs-string"><span class="hljs-string">'first commit'</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push -u origin master</code> </pre> <br><p>  With the above commands, we created a project template for our plugin and committed everything to a remote git repository.  We will remember the repository URL, we will need it later when we will do a full-fledged image <code>docker build</code> with the <code>docker build</code> </p><br><p>  Now make a small digression.  Recall our task.  For convenience, let's try to break it up into independent parts: </p><br><ul><li>  Creating an application user account </li><li>  Installing Ruby with rvm </li><li>  Download the application archive, unpacking and installing dependencies </li></ul><br><p>  For logically separate tasks, Sparrow provides a mechanism for the modules; we use it.  But first of all we will create the main <a href="https://github.com/melezhik/outthentic">story</a> in which we will delegate the execution of tasks to different modules.  So, all on the same container launched by Docker: </p><br><pre> <code class="hljs ruby">$ nano hook.bash action=$(config action) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $action <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> run_story $s done set_stdout install-ok $ nano story.check install-ok</code> </pre> <br><p>  A few comments on the code.  We have three minor histories (modules) and one main history, given by a hook file (hook.bash), in order to show how all this works, we will create stubs for scripts in modules.  Yes, and the default value for the <code>action</code> input parameter must be specified in the <code>suite.ini</code> file. </p><br><pre> <code class="hljs sql">$ nano suite.ini action <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app</code> </pre> <br><p>  Create script stubs: </p><br><pre> <code class="hljs sql">$ mkdir -p modules/<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> $ mkdir -p modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby $ mkdir -p modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app $ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/story.bash echo <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-ok $ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby/story.bash echo <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby-ok $ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app/story.bash echo <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app-ok</code> </pre> <br><p>  As well as verification files: </p><br><pre> <code class="hljs sql">$ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/story.check <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-ok $ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby/story.check <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby-ok $ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app/story.check <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app-ok</code> </pre> <br><p>  Now we‚Äôll run everything through <a href="https://github.com/melezhik/outthentic">strun</a> , a console script for running Sparrow scripts: </p><br><pre> <code class="hljs lua">$ strun /tmp/.outthentic/<span class="hljs-number"><span class="hljs-number">93</span></span>/ruby-app/story.t .. # [/ruby-app/modules/<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>-user] # <span class="hljs-built_in"><span class="hljs-built_in">create</span></span>-user-ok ok <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> <span class="hljs-string"><span class="hljs-string">'create-user-ok'</span></span> # [/ruby-app/modules/install-ruby] # install-ruby-ok ok <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> <span class="hljs-string"><span class="hljs-string">'install-ruby-ok'</span></span> # [/ruby-app/modules/install-app] # install-app-ok ok <span class="hljs-number"><span class="hljs-number">3</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> <span class="hljs-string"><span class="hljs-string">'install-app-ok'</span></span> # [/ruby-app] # install-ok ok <span class="hljs-number"><span class="hljs-number">4</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> <span class="hljs-string"><span class="hljs-string">'install-ok'</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span> ok All tests successful. Files=<span class="hljs-number"><span class="hljs-number">1</span></span>, Tests=<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> wallclock secs ( <span class="hljs-number"><span class="hljs-number">0.00</span></span> usr <span class="hljs-number"><span class="hljs-number">0.02</span></span> sys + <span class="hljs-number"><span class="hljs-number">0.09</span></span> cusr <span class="hljs-number"><span class="hljs-number">0.01</span></span> csys = <span class="hljs-number"><span class="hljs-number">0.12</span></span> CPU) Result: PASS</code> </pre> <br><p>  Fine.  We see that all the scripts have worked successfully, this will be the skeleton of our future plug-in.  It remains only to tighten the plugs of our modules. </p><br><h1>  User creation script </h1><br><p>  Let us assume that the username is customizable, we define the default value in the <code>suite.ini</code> file: </p><br><pre> <code class="hljs sql">$ cat suite.ini action <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-app user_name app-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span></code> </pre> <br><p>  Now the script implementation: </p><br><pre> <code class="hljs sql">$ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/story.bash user_id=$(config user_name) echo <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: $user_id useradd -r -m -d /home/$user_id $user_id || <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ls -d /home/$user_id || <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> $user_id || <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> echo <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-ok</code> </pre> <br><p>  And start (note that here we used the opportunity to run a separate script using the <code>action</code> parameter): </p><br><pre> <code class="hljs erlang-repl">$ strun --param action=create-user /tmp/.outthentic/<span class="hljs-number"><span class="hljs-number">135</span></span>/ruby-app/story.t .. # [/ruby-app/modules/create-user] # create user id: app-user # /home/app-user # uid=<span class="hljs-number"><span class="hljs-number">997</span></span>(app-user) gid=<span class="hljs-number"><span class="hljs-number">995</span></span>(app-user) groups=<span class="hljs-number"><span class="hljs-number">995</span></span>(app-user) # create-user-ok ok <span class="hljs-number"><span class="hljs-number">1</span></span> - output match <span class="hljs-string"><span class="hljs-string">'create-user-ok'</span></span> # [/ruby-app] # install-ok ok <span class="hljs-number"><span class="hljs-number">2</span></span> - output match <span class="hljs-string"><span class="hljs-string">'install-ok'</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span> ok All tests successful. Files=<span class="hljs-number"><span class="hljs-number">1</span></span>, Tests=<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> wallclock secs ( <span class="hljs-number"><span class="hljs-number">0.03</span></span> usr <span class="hljs-number"><span class="hljs-number">0.00</span></span> sys + <span class="hljs-number"><span class="hljs-number">0.11</span></span> cusr <span class="hljs-number"><span class="hljs-number">0.04</span></span> csys = <span class="hljs-number"><span class="hljs-number">0.18</span></span> CPU) Result: PASS</code> </pre> <br><p>  We see that the script worked and the user was created.  Note that most of the Bash commands inside the script end with the idiomatic construction <code>cmd || exit 1</code>  <code>cmd || exit 1</code> , <code>strun</code> checks the script execution code and if it fails, the corresponding test fails, for example like this - try to create a user with an invalid name for the system: </p><br><pre> <code class="hljs delphi">$ strun --param action=create-user --param user_name=<span class="hljs-string"><span class="hljs-string">'/'</span></span> /tmp/.outthentic/<span class="hljs-number"><span class="hljs-number">160</span></span>/ruby-app/story.t .. # [/ruby-app/modules/create-user] # create user id: / # useradd: invalid user <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'/'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ok <span class="hljs-number"><span class="hljs-number">1</span></span> - scenario succeeded <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ok <span class="hljs-number"><span class="hljs-number">2</span></span> - output match <span class="hljs-string"><span class="hljs-string">'create-user-ok'</span></span> # [/ruby-app] # install-ok ok <span class="hljs-number"><span class="hljs-number">3</span></span> - output match <span class="hljs-string"><span class="hljs-string">'install-ok'</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> # Failed test <span class="hljs-string"><span class="hljs-string">'scenario succeeded'</span></span> # at /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/share/perl5/Outthentic.pm line <span class="hljs-number"><span class="hljs-number">167</span></span>. # Failed test <span class="hljs-string"><span class="hljs-string">'output match '</span></span>create-user-ok<span class="hljs-string"><span class="hljs-string">''</span></span> # at /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/share/perl5/Outthentic.pm line <span class="hljs-number"><span class="hljs-number">213</span></span>. # Looks like you failed <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. Dubious, test returned <span class="hljs-number"><span class="hljs-number">2</span></span> (wstat <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x200) Failed <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span> subtests Test Summary Report ------------------- /tmp/.outthentic/<span class="hljs-number"><span class="hljs-number">160</span></span>/ruby-app/story.t (Wstat: <span class="hljs-number"><span class="hljs-number">512</span></span> Tests: <span class="hljs-number"><span class="hljs-number">3</span></span> Failed: <span class="hljs-number"><span class="hljs-number">2</span></span>) Failed tests: <span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span> Non-zero <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> status: <span class="hljs-number"><span class="hljs-number">2</span></span> Files=<span class="hljs-number"><span class="hljs-number">1</span></span>, Tests=<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> wallclock secs ( <span class="hljs-number"><span class="hljs-number">0.02</span></span> usr <span class="hljs-number"><span class="hljs-number">0.00</span></span> sys + <span class="hljs-number"><span class="hljs-number">0.10</span></span> cusr <span class="hljs-number"><span class="hljs-number">0.00</span></span> csys = <span class="hljs-number"><span class="hljs-number">0.12</span></span> CPU) Result: FAIL</code> </pre> <br><p>  I will make a small digression here.  Let us ask ourselves why we need verification files if, in essence, verification of the script's completion code should be enough.  Reasonable question.  We can think of the verification rules of the Sparrow framework as an <em>alternative</em> way to monitor or verify the execution of our scripts.  In the ideology of Sparrow, any executed script is history in the sense that it is a kind of script that runs and most often "reports" something about its work - figuratively speaking, "leaving a mark on history."  This trace is the standard stdout output, the contents of which can be validated.  Why this may be useful: </p><br><ul><li><p>  Not always successful completion code means everything goes well </p><br></li><li>  Sometimes you want to leave the script in an emergency (using <code>cmd || exit 1</code> ), allowing the script to do its work to the end and postpone verification by checking through the verification file. </li></ul><br><p>  As a concrete example, we can give the Ruby installation script via rvm, which is next in the list in our plan. </p><br><h1>  Ruby install script from rvm </h1><br><p>  Here is what the installation script will look like: </p><br><pre> <code class="hljs bash">$ nano modules/install-ruby/story.bash yum -y install <span class="hljs-built_in"><span class="hljs-built_in">which</span></span> curl -sSL https://rvm.io/mpapis.asc | gpg2 --import - || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 \curl -sSL https://get.rvm.io | bash -s stable --ruby || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/rvm/scripts/rvm gem install bundler --no-ri --no-rdoc <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ruby version: $(ruby --version) bundler --version <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> install-ruby-ok</code> </pre> <br><p>  And this is the verification file: </p><br><pre> <code class="hljs sql">$ nano modules/<span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby/story.check regexp: ruby <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: ruby <span class="hljs-number"><span class="hljs-number">2</span></span>\<span class="hljs-number"><span class="hljs-number">.3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>-ruby-ok</code> </pre> <br><p>  Now run this script: </p><br><pre> <code class="hljs erlang-repl">$ strun --param action=install-ruby #    #   # ... # ... # ... # ruby version: ruby <span class="hljs-number"><span class="hljs-number">2.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>p0 (<span class="hljs-number"><span class="hljs-number">2015</span></span>-<span class="hljs-number"><span class="hljs-number">12</span></span>-<span class="hljs-number"><span class="hljs-number">25</span></span> revision <span class="hljs-number"><span class="hljs-number">53290</span></span>) [x86_64-linux] # Bundler version <span class="hljs-number"><span class="hljs-number">1.12</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> # install-ruby-ok ok <span class="hljs-number"><span class="hljs-number">1</span></span> - output match /ruby version: ruby <span class="hljs-number"><span class="hljs-number">2</span></span>\.<span class="hljs-number"><span class="hljs-number">3</span></span>/ ok <span class="hljs-number"><span class="hljs-number">2</span></span> - output match <span class="hljs-string"><span class="hljs-string">'install-ruby-ok'</span></span> # [/ruby-app] # install-ok ok <span class="hljs-number"><span class="hljs-number">3</span></span> - output match <span class="hljs-string"><span class="hljs-string">'install-ok'</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> ok All tests successful. Files=<span class="hljs-number"><span class="hljs-number">1</span></span>, Tests=<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span> wallclock secs ( <span class="hljs-number"><span class="hljs-number">0.03</span></span> usr <span class="hljs-number"><span class="hljs-number">0.00</span></span> sys + <span class="hljs-number"><span class="hljs-number">3.24</span></span> cusr <span class="hljs-number"><span class="hljs-number">1.03</span></span> csys = <span class="hljs-number"><span class="hljs-number">4.30</span></span> CPU) Result: PASS</code> </pre> <br><p>  I would like to note that in order to verify the version of the installed Ruby, we used the checkout rule in the form of a regular expression: </p><br><pre> <code class="hljs pgsql">regexp: ruby <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: ruby <span class="hljs-number"><span class="hljs-number">2</span></span>\<span class="hljs-number"><span class="hljs-number">.3</span></span></code> </pre> <br><p>  Of course, rvm allows you to install the required version explicitly, just wanted to give an example here when the checks defined in the test files allow you to add additional verification of the script with minimal effort. </p><br><p>  Now you can go to the application installation script. </p><br><h1>  Application Installation Scenario </h1><br><p>  I will remind you.  We will need: </p><br><ul><li>  download tarball for a given urla </li><li>  unpack archive </li><li>  go to the unpacked folder and execute the command <code>bundle install --target ./local</code> to install dependencies </li></ul><br><p>  That's all.  Of course, in a real application, we would have to start some service or perform some additional operations, but this should be enough to demonstrate the work of the plugin. </p><br><p>  Again, for the sake of simplicity, let us have a <a href="https://github.com/melezhik/app">Ruby application</a> consisting of: </p><br><ul><li>  <code>Gemfile</code> - in which dependencies will be written </li><li>  <code>hello.rb</code> - a launch of a squeak that simply prints the <code>Hello World</code> line to the console </li></ul><br><p>  We pack all the archive and upload everything to the archive server on the local nginx, now the distribution will be available at the URL: </p><br><pre> <code class="hljs">127.0.0.1/app.tar.gz</code> </pre> <br><p>  Update script code. </p><br><pre> <code class="hljs bash">$ cat suite.ini action create-user install-ruby install-app user_name app-user source_url 127.0.0.1/app.tar.gz $ cat modules/install-app/story.bash user_id=$(config user_name) source_url=$(config source_url) yum -y -q install sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> downloading <span class="hljs-variable"><span class="hljs-variable">$source_url</span></span> ... sudo -u <span class="hljs-variable"><span class="hljs-variable">$user_id</span></span> -E bash --login -c <span class="hljs-string"><span class="hljs-string">"curl -f -o ~/app.tar.gz </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$source_url</span></span></span><span class="hljs-string"> -s"</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> unpacking tarball ... sudo -u <span class="hljs-variable"><span class="hljs-variable">$user_id</span></span> -E bash --login -c <span class="hljs-string"><span class="hljs-string">"cd ~/ &amp;&amp; tar -xzf app.tar.gz"</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> installing dependencies via bundler sudo -u <span class="hljs-variable"><span class="hljs-variable">$user_id</span></span> -E bash --login -c <span class="hljs-string"><span class="hljs-string">"cd ~/app &amp;&amp; bundle install --quiet --path vendor/bundle "</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 sudo -u <span class="hljs-variable"><span class="hljs-variable">$user_id</span></span> -E bash --login -c <span class="hljs-string"><span class="hljs-string">"cd ~/app &amp;&amp; bundle exec ruby hello.rb "</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> install-app-ok $ nano modules/install-app/story.check install-app-ok Hello World</code> </pre> <br><p>  Small comments on the script: </p><br><ul><li><p>  Installation is done from under the user specified in the configuration of the plugin suite.ini.  For this we need the <code>sudo</code> package </p><br></li><li><p>  The last command runs the <code>hello.rb</code> application script <code>hello.rb</code> </p><br></li><li>  In the test file, we require that the <code>stdout</code> see the "trace" of the script - the line 'Hello World' </li></ul><br><p>  So, run the script: </p><br><pre> <code class="hljs erlang-repl">$ strun --param action=install-app /tmp/.outthentic/<span class="hljs-number"><span class="hljs-number">16462</span></span>/ruby-app/story.t .. # [/ruby-app/modules/install-app] # Package sudo-<span class="hljs-number"><span class="hljs-number">1.8</span></span>.<span class="hljs-number"><span class="hljs-number">6</span></span>p7-<span class="hljs-number"><span class="hljs-number">17</span></span>.el7_2.x86_64 already installed and latest version # downloading <span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0.1</span></span>/app.tar.gz ... # unpacking app ... # installing dependencies via bundler # Hello World # install-app-ok ok <span class="hljs-number"><span class="hljs-number">1</span></span> - output match <span class="hljs-string"><span class="hljs-string">'install-app-ok'</span></span> ok <span class="hljs-number"><span class="hljs-number">2</span></span> - output match <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span> # [/ruby-app] # install-ok ok <span class="hljs-number"><span class="hljs-number">3</span></span> - output match <span class="hljs-string"><span class="hljs-string">'install-ok'</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span> ok All tests successful. Files=<span class="hljs-number"><span class="hljs-number">1</span></span>, Tests=<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> wallclock secs ( <span class="hljs-number"><span class="hljs-number">0.01</span></span> usr <span class="hljs-number"><span class="hljs-number">0.00</span></span> sys + <span class="hljs-number"><span class="hljs-number">1.61</span></span> cusr <span class="hljs-number"><span class="hljs-number">0.50</span></span> csys = <span class="hljs-number"><span class="hljs-number">2.12</span></span> CPU) Result: PASS</code> </pre> <br><p>  As we see, the application is really installed and the <code>hello.rb</code> script <code>hello.rb</code> launched.  Add another ‚Äúparanoid‚Äù assort to the verification file to demonstrate the capabilities of the Sparrow verification system: </p><br><pre> <code class="hljs pgsql">$ nano modules/install-app/story.<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> install-app-ok Hello World generator: &lt;&lt;CODE !bash <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test -d /home/$(config user_name)/app; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> echo <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> directory /home/$(config user_name)/app <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> echo <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> directory /home/$(config user_name)/app <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> fi CODE</code> </pre> <br><p>  And run the script again. </p><br><pre> <code class="hljs pgsql">$ strun <span class="hljs-comment"><span class="hljs-comment">--param action=install-app</span></span></code> </pre> <br><p>  In the output we get: </p><br><pre> <code class="hljs pgsql">$ ok <span class="hljs-number"><span class="hljs-number">3</span></span> - directory /home/app-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>/app <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span></code> </pre> <br><h1>  Publishing Sparrow Plugin </h1><br><p>  This completes the creation of the plugin.  Let's finish the changes and push the git repository: </p><br><pre> <code class="hljs ruby">$ git add . $ git commit -a -m <span class="hljs-string"><span class="hljs-string">'all done'</span></span> $ git push $ exit</code> </pre> <br><p>  We left the docker container, we no longer need it, you can delete it: </p><br><pre> <code class="hljs ruby">$ docker rm <span class="hljs-number"><span class="hljs-number">5</span></span>e1037fa4aef</code> </pre> <br><h1>  Full Image Build Cycle for Docker Container </h1><br><p>  It remains to slightly change the Dockerfile, remembering that we will need a link to the remote git repository, where we placed the code of our Sparrow plugin, the final version will be like this: </p><br><pre> <code class="hljs cmake">FROM tutum/centos MAINTAINER <span class="hljs-string"><span class="hljs-string">"melezhik"</span></span> &lt;melezhik@gmail.com&gt; RUN yum clean all RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> nano git-core RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> make RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> gcc RUN yum -y <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> perl perl-devel \ perl-<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>-Simple perl-Digest-SHA perl-Digest-MD5 perl-CPAN-Meta \ perl-CPAN-Meta-Requirements perl-Getopt-Long \ perl-JSON perl-Module-CoreList perl-Module-Metadata perl-parent perl-Path-Tiny perl-Try-Tiny \ perl-App-cpanminus perl-JSON-PP perl-Algorithm-Diff perl-Text-Diff \ perl-Spiffy perl-<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>-Base perl-YAML perl-<span class="hljs-keyword"><span class="hljs-keyword">File</span></span>-ShareDir-<span class="hljs-keyword"><span class="hljs-keyword">Install</span></span> perl-Class-Inspector \ perl-<span class="hljs-keyword"><span class="hljs-keyword">File</span></span>-ShareDir perl-<span class="hljs-keyword"><span class="hljs-keyword">File</span></span>-ShareDir-<span class="hljs-keyword"><span class="hljs-keyword">Install</span></span> perl-Config-General RUN cd /bin/ &amp;&amp; curl -L https://cpanmin.us/ -o cpanm &amp;&amp; chmod +x cpanm RUN cpanm Sparrow -q RUN echo ruby-app https://github.com/melezhik/ruby-app.git &gt; /root/sparrow.<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> RUN sparrow plg <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> ruby-app RUN sparrow plg run ruby-app</code> </pre> <br><p>  Now we can carry out a complete image building cycle, ‚Äúlosing‚Äù all over again: </p><br><pre> <code class="hljs ruby">$ docker build -t ruby_app --no-cache=<span class="hljs-literal"><span class="hljs-literal">true</span></span> .</code> </pre> <br><p>  As a result, we get a Docker image with the required system. </p><br><h1>  Conclusion </h1><br><p>  The use of <a href="https://github.com/melezhik/sparrow">Sparrow</a> multipurpose scripting <a href="https://github.com/melezhik/sparrow">system</a> can be an effective tool for building Docker images, since  allows you to build complex configurations, leaving the main Dockerfile simple and concise, as well as simplifying the process of developing the configuration scripts themselves required system. </p><br><p>  Thanks for attention. </p><br><p>  As usual, I am waiting for questions and constructive criticism!  :) </p><br><p>  Alexey </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302278/">https://habr.com/ru/post/302278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302268/index.html">Email - not a sparrow, fly out - you won't catch it or how we did email marketing with a machine</a></li>
<li><a href="../302270/index.html">ESET specialists released a tool to decrypt TeslaCrypt files</a></li>
<li><a href="../302272/index.html">HPE StoreVirtual VSA Architecture</a></li>
<li><a href="../302274/index.html">We get control back to Jenkins Pipeline</a></li>
<li><a href="../302276/index.html">Virus living exclusively in PLC</a></li>
<li><a href="../302280/index.html">Events in Angular Light</a></li>
<li><a href="../302284/index.html">RxJS: Reactive Extension for Front End Development</a></li>
<li><a href="../302286/index.html">DUMP-2016: video of all reports in one post. Is free. Without SMS</a></li>
<li><a href="../302288/index.html">Requests to the Rest API from JavaScript are compact and beautiful</a></li>
<li><a href="../302290/index.html">Tehnostart-2016 Student IT Project Championship</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>