<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RabbitMQ tutorial 1 - Hello World</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RabbitMQ allows you to interact with different programs using the AMQP protocol. RabbitMQ is an excellent solution for building SOA (Service Oriented ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RabbitMQ tutorial 1 - Hello World</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0e8/6a0/e5d/0e86a0e5d613a89ce9eda5c64769bef1.png"><br><br>  RabbitMQ allows you to interact with different programs using the AMQP protocol.  RabbitMQ is an excellent solution for building SOA (Service Oriented Architecture) and the distribution of deferred resource-intensive tasks. <br><br>  Under the cut translation of the <a href="http://www.rabbitmq.com/tutorials/tutorial-one-python.html">first</a> of the six lessons of the official site.  Examples in python, but his knowledge is not at all necessary.  Similar to the example program can be played on almost any popular PL.  <i>[This is how translator comments look, i.e.</i>  <i>me]</i> <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Introduction </h4><br>  RabbitMQ is a message broker.  His main goal is to receive and give messages.  You can think of it as a post office: when you drop a letter in the box, you can be sure that sooner or later the postman will deliver it to the addressee <i>[apparently, the author has never dealt with Russian Post]</i> .  In this analogy, RabbitMQ is simultaneously a mailbox, post office, and postman. <br><br>  The biggest difference between RabbitMQ and the post office is that it does not deal with paper envelopes - RabbitMQ accepts, stores and gives binary data - messages. <br><br>  RabbitMQ, as well as messaging in general, uses the following terminology: <br><br><ul><li>  <b>Producer</b> (supplier) - a program that sends messages.  In the diagrams, it will be represented by a circle with the letter ‚ÄúP‚Äù: <br><img src="https://habrastorage.org/storage2/546/6c4/d2e/5466c4d2e902e8cd0db71c7ba06e3e95.png"><br></li><li>  <b>Queue</b> - the name of the ‚Äúmailbox‚Äù.  It exists inside RabbitMQ.  Although messages pass through RabbitMQ and applications, they are stored only in queues.  The queue has no restrictions on the number of messages, it can take an arbitrarily large number of them - it can be considered an endless buffer.  Any number of suppliers can send messages to one queue, and any number of subscribers can receive messages from one queue.  In the schemes, the queue will be indicated by the stack and signed with the name: <br><br><img src="https://habrastorage.org/storage2/64c/bc5/37e/64cbc537e28a8441119f1ce8f13421e1.png"><br></li><li>  <b>Consumer</b> (subscriber) - a program that receives messages.  Typically, the subscriber is in a message waiting state.  In the diagrams, it will be represented by a circle with the letter ‚ÄúC‚Äù: <br><br><img src="https://habrastorage.org/storage2/8ce/aed/6d5/8ceaed6d537b1951a5aee11b3dbcc9b7.png"><br></li></ul><br>  The supplier, subscriber and broker are not required to be on the same physical machine, usually they are on different ones. <br><br><h4>  Hello World! </h4><br>  The first example will not be particularly difficult - let's just send a message, accept it and display it.  For this we need two programs: one will send messages, the other will receive and display them on the screen. <br>  The general scheme is as follows: <br><br><img src="https://habrastorage.org/storage2/0e8/6a0/e5d/0e86a0e5d613a89ce9eda5c64769bef1.png"><br><br>  The provider sends messages to the queue with the name "hello", and the subscriber receives messages from this queue. <br><br><h5>  RabbitMQ library </h5><br>  RabbitMQ uses the AMQP protocol.  RabbitMQ requires a library that supports this protocol.  Such libraries can be found for almost every programming language.  Python is not an exception; there are several libraries for it: <br><br><ul><li>  <a href="http://barryp.org/software/py-amqplib/">py-amqplib</a> </li><li>  <a href="https://launchpad.net/txamqp">txAMQP</a> </li><li>  <a href="http://github.com/pika/pika">pika</a> </li></ul><br>  The examples will use the pika library.  It can be installed using the pip package manager: <br><br><pre><code class="bash hljs">$ sudo pip install pika==0.9.5</code> </pre> <br>  If pip or git-core is missing, you must first install them: <br><ul><li>  For Ubuntu: <br><br><pre> <code class="bash hljs">$ sudo apt-get install python-pip git-core</code> </pre><br></li><li>  For Debian: <br><br><pre> <code class="bash hljs">$ sudo apt-get install python-setuptools git-core $ sudo easy_install pip</code> </pre><br></li><li>  For Windows (to install easy_install, you must run MS Windows Installer for setuptools): <br><br><pre> <code class="bash hljs">&gt; easy_install pip &gt; pip install pika==0.9.5</code> </pre><br></li></ul><br><br><h4>  Sending messages </h4><br><img src="https://habrastorage.org/storage2/218/7dc/291/2187dc2912ce5aa0f6e0c22bbd9eea1b.png"><br><br>  Our first <b>send.py</b> program will simply send one message to the queue. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters( 'localhost')) channel = connection.channel()</span></span></code> </pre><br>  We have connected to a message broker located on the local host.  To connect to a broker located on another machine, it is enough to replace ‚Äúlocalhost‚Äù with the IP address of this machine. <br><br>  Before sending a message, we must make sure that the queue receiving the message exists.  If you send a message to a nonexistent queue, RabbitMQ will ignore it.  Let's create a queue to which the message will be sent, let's call it ‚Äúhello‚Äù: <br><br><pre> <code class="python hljs">channel.queue_declare(queue=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>)</code> </pre><br>  Now everything is ready to send a message.  Our first message will contain the string <nobr>‚ÄúHello World!‚Äù</nobr> And will be sent to the queue with the name ‚Äúhello‚Äù. <br><br>  In general, in RabbitMQ messages are not sent directly to the queue, they must go through the <b>exchange</b> ( <b>exchange</b> point).  But now we will not focus on this, exchange points will be discussed in the third lesson.  Now it‚Äôs enough to know that the default exchange point can be determined by specifying an empty string.  This is a special exchange point - it allows you to determine exactly which message was sent to the queue.  The queue name must be specified in the <b>routing_key</b> parameter: <br><br><pre> <code class="python hljs">channel.basic_publish(exchange=<span class="hljs-string"><span class="hljs-string">''</span></span>, routing_key=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, body=<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Sent 'Hello World!'"</span></span></code> </pre><br>  Before exiting the program, you need to make sure that the buffer has been cleared and the message reached RabbitMQ.  You can be sure of this if you use secure broker connection closure. <br><br><pre> <code class="python hljs">connection.close()</code> </pre><br><h4>  Receive messages </h4><br><img src="https://habrastorage.org/storage2/400/9f5/3c7/4009f53c71c8ac8258f65352ed07005c.png"><br><br>  Our second program <b>receive.py</b> will receive messages from the queue and display them on the screen. <br><br>  As well as in the first program, you first need to connect to RabbitMQ.  To do this, use the same code as before.  The next step, as before, is to make sure the queue exists.  The <b>queue_declare</b> command <b>will</b> not create a new queue if it already exists, so no matter how many times this command is called, only one queue will be created anyway. <br><br><pre> <code class="python hljs">channel.queue_declare(queue=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>)</code> </pre><br>  You may wonder why we declare the queue again, because it has already been announced in the first program.  This is necessary to make sure that there is a queue, as it will be if the <b>send.py</b> program is started <b>first</b> .  But we do not know which program will be launched earlier.  In such cases it is better to declare a queue in both programs. <br><br><h5>  Queue Monitoring </h5><br>  If you want to see which queues exist in RabbitMQ at the moment, you can do this with the <b>rabbitmqctl command</b> (you need root privileges): <br><br><pre> <code class="bash hljs">$ sudo rabbitmqctl list_queues Listing queues ... hello 0 ...<span class="hljs-keyword"><span class="hljs-keyword">done</span></span>.</code> </pre><br>  (for Windows - without sudo) <br><br>  <i>[Our company uses a more convenient monitoring script:]</i> <br><br><pre> <code class="bash hljs">watch <span class="hljs-string"><span class="hljs-string">'sudo /usr/sbin/rabbitmqctl list_queues name messages_unacknowledged messages_ready messages durable auto_delete consumers | grep -v "\.\.\." | sort | column -t;'</span></span></code> </pre><br>  <i>[the script outputs and updates every 2 seconds a table with a list of queues: the name of the queue;</i>  <i>number of messages in processing;</i>  <i>number of messages ready for processing;</i>  <i>total number of messages;</i>  <i>queue stability to restart the service;</i>  <i>is it a temporary queue;</i>  <i>number of subscribers]</i> <br><br>  Retrieving messages from a queue is more complicated than sending.  Receiving is done using a subscription using the callback function.  Upon receipt of each message, the Pika library calls this callback function.  In our example, it will display the message text. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch, method, properties, body)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Received %r"</span></span> % (body,)</code> </pre><br>  Next, we need to designate that the callback function will receive messages from the queue with the name ‚Äúhello‚Äù: <br><br><pre> <code class="python hljs">channel.basic_consume(callback, queue=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, no_ack=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre><br>  Here you need to be sure that the queue we want to subscribe to has been announced.  We did this earlier with the <b>queue_declare command</b> . <br><br>  The parameter <b>no_ack</b> will be discussed later <i>[in the <a href="http://habrahabr.ru/post/150134/">second lesson</a> ]</i> . <br>  And, finally, start an infinite process that waits for messages from the queue and calls the callback function when necessary. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">' [*] Waiting for messages. To exit press CTRL+C'</span></span> channel.start_consuming()</code> </pre><br><br><h4>  Well, now all together </h4><br>  Full <b>send.py</b> code: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print " [x] Sent 'Hello World!'" connection.close()</span></span></code> </pre><br>  Full <b>receive.py</b> code: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') print ' [*] Waiting for messages. To exit press CTRL+C' def callback(ch, method, properties, body): print " [x] Received %r" % (body,) channel.basic_consume(callback, queue='hello', no_ack=True) channel.start_consuming()</span></span></code> </pre><br>  Now we can try to run our programs in the terminal.  First, send a message using the <b>send.py</b> program: <br><br><pre> <code class="python hljs">$ python send.py [x] Sent <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span></code> </pre><br>  The execution of this program will terminate after sending each message.  Now you need to get the message: <br><br><pre> <code class="python hljs">$ python receive.py [*] Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> messages. To exit press CTRL+C [x] Received <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span></code> </pre><br>  Fine!  We sent our first message through RabbitMQ.  As you may have noticed, the execution of the <b>receive.py</b> program <b>has</b> not ended.  She will wait for the next messages, and you can stop her by pressing <b>Ctrl + C.</b> <br>  Try running <b>send.py</b> again in a new terminal window. <br><br>  We learned how to send and receive messages through named queues.  In the <a href="http://habrahabr.ru/post/150134/">next lesson</a> we will create a simple task queue <i>[resource-intensive]</i> . <br><br>  <b>UPD:</b> library working with RabbitMQ, for your beloved PL, you can find on the official site <a href="http://www.rabbitmq.com/devtools.html">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/149694/">https://habr.com/ru/post/149694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149685/index.html">Black color - taboo, myth or necessity?</a></li>
<li><a href="../149686/index.html">Forth processor on VHDL</a></li>
<li><a href="../149687/index.html">Create a Qt interface style using a table as an example.</a></li>
<li><a href="../149691/index.html">Pleasant trifle in the "Express Office" - comfortable keyboard</a></li>
<li><a href="../149693/index.html">KNN classifier</a></li>
<li><a href="../149695/index.html">Monitoring PHP Code Performance with Pinba</a></li>
<li><a href="../149696/index.html">CERN - what is the organization for $ 900 million</a></li>
<li><a href="../149698/index.html">Radio 60-1700 MHz on RTL2832 for 20 bucks or SDR for beginners</a></li>
<li><a href="../149699/index.html">Ya.Subbotnik: BEM in the development of interfaces</a></li>
<li><a href="../149701/index.html">Multi-threaded file uploader on JS (jQuery)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>