<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WAL in PostgreSQL: 1. Buffer cache</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous cycle was devoted to the isolation and multiversion of PostgreSQL, and today we are starting a new one - about the journaling mechanism (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WAL in PostgreSQL: 1. Buffer cache</h1><div class="post__text post__text-html js-mediator-article">  The previous cycle was devoted to the <a href="https://habr.com/ru/company/postgrespro/blog/442804/">isolation and multiversion of</a> PostgreSQL, and today we are starting a new one - <strong>about the journaling mechanism</strong> (write-ahead logging).  Let me remind you that the material is based on <a href="https://postgrespro.ru/education/courses">training courses</a> in administration, which we do with Pavel <a href="https://habr.com/ru/users/pluzanov/" class="user_link">pluzanov</a> , but does not repeat them verbatim and is intended for thoughtful reading and independent experimentation. <br><br>  This cycle will consist of four parts: <br><br><ul><li>  Buffer cache (this article); </li><li>  Prerecord log - how it works and how it is used during restoration; </li><li>  Checkpoint and background recording - why you need it and how it is configured; </li><li>  Log settings - levels and tasks to be solved, reliability and performance. </li></ul><br><h1>  Why do you need journaling? </h1><br>  In the process of work, part of the data with which the DBMS deals, is stored in RAM and is written to disk (or to another non-volatile medium) in a deferred manner.  The less often this happens, the less I / O and the faster the system works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But what happens in the event of a failure, for example, when the power is turned off or when an error occurs in the DBMS or operating system code?  The entire contents of the RAM will be lost, and only the data recorded on the disk will remain (with some types of failures, the disk may suffer, but in this case only a backup will help).  In principle, you can organize I / O in such a way that the data on the disk is always maintained in a consistent state, but it is difficult and not very efficient (as far as I know, only Firebird went this way). <br><br>  Usually, including in PostgreSQL, the data recorded on the disc is inconsistent and special actions are required for recovery after a crash in order to restore consistency.  Journaling is the very mechanism that makes this possible. <br><a name="habracut"></a><br><h1>  Buffer cache </h1><br>  Speaking of journaling, we, oddly enough, start with the buffer cache.  The buffer cache is not the only structure that is stored in RAM, but one of the most important and complex.  Understanding the principle of its work is important in itself, besides on this example we will get acquainted with how data is exchanged between the RAM and the disk. <br><br>  Caching is used in modern computing systems everywhere; only one processor can count three or four cache levels.  In general, any cache is needed in order to smooth the difference in performance of two types of memory, one of which is relatively fast, but not enough for everyone, and the other is relatively slow, but available in abundance.  So the buffer cache smoothes the difference between the access time to the RAM (nanoseconds) and the disk (milliseconds). <br><br>  Note that the operating system also has a disk cache, which solves the same problem.  Therefore, usually DBMSs try to avoid double caching by accessing the disk directly, bypassing the OS cache.  But in the case of PostgreSQL, this is not the case: all data is read and written using ordinary file operations. <br><br>  In addition, the cache is also a controller of disk arrays, and even the disks themselves.  This fact is still useful to us when we get to the question of reliability. <br><br>  But back to the database buffer cache. <br><br>  It is called so because it is an array of <em>buffers</em> .  Each buffer is a place under one data page (block), plus a header.  The title, among other things, contains: <br><br><ul><li>  location on disk of the page in the buffer (file and block number in it); </li><li>  a sign that the data on the page has changed and sooner or later should be written to disk (this buffer is called <em>dirty</em> ); </li><li>  the number of calls to the buffer (usage count); </li><li>  flag of pin counting. </li></ul><br>  The buffer cache is located in the shared memory of the server and is accessible to all processes.  To work with data ‚Äî read or modify ‚Äî processes read pages in the cache.  While the page is in the cache, we work with it in RAM and save on disk access. <br><br><img src="https://habrastorage.org/webt/1u/-j/fd/1u-jfdnjvzjwvrddgb7tbvohhge.png"><br><br>  Initially, the cache contains empty buffers, and they are all linked into a list of free buffers.  The meaning of the pointer to the "next victim" will become clear a little later.  To quickly find the desired page in the cache, a hash table is used. <br><br><h1>  Search page in the cache </h1><br>  When a process needs to read a page, it first tries to find it in the buffer cache using a hash table.  The hash key is the file number and page number within the file.  In the corresponding hash table basket, the process finds the buffer number and checks whether it really contains the desired page.  As with any hash table, collisions are possible here;  in this case, the process will have to check several pages. <br><br><blockquote>  Using a hash table has long been a criticism.  This structure allows you to quickly find a buffer on the page, but it is completely useless if, for example, you need to find all the buffers occupied by a particular table.  But no one has proposed a good replacement. <br></blockquote><br>  If the desired page is found in the cache, the process must ‚Äúpin‚Äù the buffer by increasing the pin count counter (several processes can do this at the same time).  As long as the buffer is fixed (the counter value is greater than zero), it is considered that the buffer is used and its contents should not "radically" change.  For example, a new version of a line may appear in a page - this does not bother anyone thanks to multiversion and visibility rules.  But another page cannot be read into the pinned buffer. <br><br><h1>  crowding out </h1><br>  It may happen that the necessary page will not be found in the cache.  In this case, it must be read from disk into any buffer. <br><br>  If there are still free buffers in the cache, the first free one is selected.  But sooner or later they will run out (usually the size of the database is larger than the memory allocated for the cache) and then you have to choose one of the busy buffers, force out the page there and read a new one to the empty seat. <br><br>  The displacement mechanism is based on the fact that each time a buffer is accessed, the processes increase the count of the number of accesses (usage count) in the buffer header.  Thus, those buffers that are used less frequently than others have a smaller counter value and are good candidates for crowding out. <br><br>  The clock-sweep algorithm iterates through all buffers (using a pointer to the ‚Äúnext victim‚Äù), decreasing their hit counts by one.  For displacement, the first buffer is selected, which: <br><br><ol><li>  has a zero count of appeals (usage count), </li><li>  and not fixed (zero pin count). </li></ol><br>  It can be noted that if all buffers have a nonzero call counter, the algorithm will have to do more than one circle, resetting the counters until one of them finally turns to zero.  To avoid ‚Äúwinding up the circles‚Äù, the maximum value of the hit counter is limited to 5. But all the same, if the buffer cache size is large, this algorithm can cause significant overhead. <br><br>  After the buffer is found, the following happens to it. <br><br>  The buffer is fixed to show the rest of the processes that it is being used.  In addition to fastening, other means of blocking are used, but we will talk more about this separately. <br><br>  If the buffer is dirty, that is, it contains modified data, the page cannot be simply discarded - it must first be saved to disk.  This is not a good situation, since the process that is going to read the page has to wait for the recording of ‚Äúforeign‚Äù data, but this effect is smoothed out by the checkpoint and background recording processes, which will be discussed later. <br><br>  Next, a new page is read into the selected buffer from the disk.  The count of the number of calls is set to one.  In addition, a link to the downloaded page must be registered in the hash table, so that in the future it can be found. <br><br>  Now the link to the ‚Äúnext victim‚Äù points to the next buffer, and the newly loaded one has time to increase the count of hits until the pointer walks around the entire buffer cache and returns again. <br><br><h1>  With my own eyes </h1><br>  As is customary in PostgreSQL, there is an extension that allows you to look inside the buffer cache. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache;</code> </pre> <br>  Create a table and insert one row into it. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cacheme( id <span class="hljs-type"><span class="hljs-type">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  What will be in the buffer cache?  At a minimum, a page should appear on it, to which a single line has been added.  Check it with the following query, in which we select only the buffers related to our table (by the file number relfilenode), and decrypt the layer number (relforknumber): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bufferid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> relforknumber <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'fsm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'vm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> relfork, relblocknumber, isdirty, usagecount, pinning_backends <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'cacheme'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 1 | 0 (1 row)</code> </pre><br>  So it is - in the buffer one page.  It is dirty (is dirty), the call counter is equal to one (usagecount), and it is not fixed by any process (pinning_backends). <br><br>  Now add another line and repeat the request.  To save letters, we insert a string in another session, and repeat the long query with the <code>\g</code> command. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 2 | 0 (1 row)</code> </pre><br>  New buffers did not increase - the second line fit on the same page.  Please note that the usage count has increased. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cacheme;</code> </pre><pre> <code class="plaintext hljs">| id | ---- | 1 | 2 | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 3 | 0 (1 row)</code> </pre><br>  And after accessing the page for reading, the counter also increases. <br><br>  And if you do the cleaning? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> cacheme;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15731 | fsm | 1 | t | 1 | 0 15732 | fsm | 0 | t | 1 | 0 15733 | fsm | 2 | t | 2 | 0 15734 | vm | 0 | t | 2 | 0 15735 | main | 0 | t | 3 | 0 (5 rows)</code> </pre><br>  Cleaning created a visibility map (one page) and a free space map (three pages - the minimum size of this map). <br><br>  Well, and so on. <br><br><h1>  Size setting </h1><br>  The size of the cache is set by the <em>shared_buffers</em> parameter.  The default is a ridiculous 128 MB.  This is one of the parameters that it makes sense to increase immediately after installing PostgreSQL. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'shared_buffers'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> setting | unit ---------+------ 16384 | 8kB (1 row)</code> </pre><br>  Keep in mind that changing a parameter requires restarting the server, since all the necessary cache memory is allocated when the server starts. <br><br>  From what considerations to choose the appropriate value? <br><br>  Even the largest database has a limited set of "hot" data, which is actively working with at any time.  Ideally, this particular set should be placed in the buffer cache (plus some space for ‚Äúone-time‚Äù data).  If the cache size is smaller, then actively used pages will constantly displace each other, creating redundant I / O.  But mindlessly increasing the cache is also wrong.  With a large amount will increase the overhead of its maintenance, and in addition, RAM is required for other needs. <br><br>  Thus, the optimal size of the buffer cache will be different in different systems: it depends on the data, on the application, on the load.  Unfortunately, there is no such magical value that is equally well suited to all. <br><br>  The standard recommendation is to take 1/4 of the RAM as the first approximation (for Windows up to the PostgreSQL 10 version, it was recommended to choose a size smaller). <br><br>  And then we must look at the situation.  It is best to conduct an experiment: increase or decrease the cache size and compare the characteristics of the system.  Of course, for this you need to have a test bench and be able to reproduce the typical load - in a production environment such experiments look dubious pleasure. <br><br><blockquote>  Be sure to check out the report by Nikolay Samokhvalov at PgConf-2019: "An <a href="https://pgconf.ru/2019/242809">Industrial Approach to Tuning PostgreSQL: Experiments on Databases</a> " <br></blockquote><br>  But some information about what is happening can be gleaned directly on the living system using the same pg_buffercache extension - the main thing is to look at the right angle. <br><br>  For example, you can study the distribution of buffers according to the degree of their use: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> usagecount, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount;</code> </pre><pre> <code class="plaintext hljs"> usagecount | count ------------+------- 1 | 221 2 | 869 3 | 29 4 | 12 5 | 564 | 14689 (6 rows)</code> </pre><br>  In this case, many empty counter values ‚Äã‚Äãare free buffers.  Not surprising for a system in which nothing happens. <br><br>  You can see what percentage of which tables in our database are cached and how actively this data is used (in this query, active use refers to buffers with a usage counter greater than 3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.relname, count(*) blocks, round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) / pg_table_size(c.oid) ) "% of rel", round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) <span class="hljs-keyword"><span class="hljs-keyword">FILTER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.usagecount &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) / pg_table_size(c.oid) ) "% hot" <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pg_relation_filenode(c.oid) = b.relfilenode <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.reldatabase <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = current_database()) ) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> b.usagecount <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c.relname, c.oid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relname | blocks | % of rel | % hot ---------------------------+--------+----------+------- vac | 833 | 100 | 0 pg_proc | 71 | 85 | 37 pg_depend | 57 | 98 | 19 pg_attribute | 55 | 100 | 64 vac_s | 32 | 4 | 0 pg_statistic | 27 | 71 | 63 autovac | 22 | 100 | 95 pg_depend_reference_index | 19 | 48 | 35 pg_rewrite | 17 | 23 | 8 pg_class | 16 | 100 | 100 (10 rows)</code> </pre><br>  Here, for example, it can be seen that the vac table occupies the most place (we used it in one of the past topics), but no one has addressed it for a long time and it has not been supplanted just because the free buffers have not yet ended. <br><br>  You can come up with other cuts that will give useful information for thought.  It is only necessary to take into account that such requests: <br><br><ul><li>  must be repeated several times: the numbers will vary within certain limits; </li><li>  it is not necessary to perform continuously (as part of monitoring) due to the fact that the extension briefly blocks work with the buffer cache. </li></ul><br>  And one moment.  We should not forget that PostgreSQL works with files through the usual calls of the operating system and, thus, double caching occurs: the pages get into both the buffer database cache and the OS cache.  Thus, ‚Äúmissing‚Äù the buffer cache does not always lead to the need for real I / O.  But the OS preemption strategy is different from the DBMS strategy: the operating system knows nothing about the meaning of the data read. <br><br><h1>  Mass extrusion </h1><br>  For operations that perform mass reading or writing data, there is a danger of quickly crowding out useful pages from the buffer cache with ‚Äúone-time‚Äù data. <br><br>  To prevent this from happening, so-called <em>buffer rings</em> (buffer <em>rings</em> ) are used for such operations ‚Äî for each operation, a small part of the buffer cache is allocated.  Preemption works only within the ring, so the rest of the buffer cache data does not suffer. <br><br>  For sequential reading (sequential scan) of large tables (the size of which exceeds a quarter of the buffer cache) 32 pages are allocated.  If, in the process of reading a table, another process also needs this data, it does not start reading the table from the beginning, but connects to an already existing buffer ring.  After the end of the scan, he reads out the ‚Äúskipped‚Äù beginning of the table. <br><br>  Let's check.  To do this, create a table so that one line takes up a whole page - it is more convenient to read this way.  The default buffer cache size is 128 MB = 16384 pages of 8 KB each.  It means that more than 4096 pages-lines should be inserted into the table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> big( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor=<span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> big(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4096</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Let's analyze the table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> big; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 4097 (1 row)</code> </pre><br>  Now we have to restart the server in order to clear the cache from the table data that the analysis has read. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  After the reboot, read the entire table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Aggregate (actual time=14.472..14.473 rows=1 loops=1) -&gt; Seq Scan on big (actual time=0.031..13.022 rows=4097 loops=1) Planning Time: 0.528 ms Execution Time: 14.590 ms (4 rows)</code> </pre><br>  And make sure that only 32 buffers are occupied by table pages in the buffer cache: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 32 (1 row)</code> </pre><br>  If you prohibit sequential scanning, the table will be read by index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------- Aggregate (actual time=50.300..50.301 rows=1 loops=1) -&gt; Index Only Scan using big_pkey on big (actual time=0.098..48.547 rows=4097 loops=1) Heap Fetches: 4097 Planning Time: 0.067 ms Execution Time: 50.340 ms (5 rows)</code> </pre><br>  In this case, the buffer ring is not used and the entire table will be in the buffer cache (and almost the entire index, too): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  Similarly, buffer rings are used for the cleaning process (also 32 pages) and for mass write operations COPY IN and CREATE TABLE AS SELECT (usually 2048 pages, but not more than 1/8 of the entire buffer cache). <br><br><h1>  Temporary tables </h1><br>  The exception to the general rule is temporary tables.  Since temporal data is visible to only one process, they have nothing to do in the shared buffer cache.  Moreover, temporary data exists only within a single session, so it does not need to be protected from failure. <br><br>  For temporary data, the cache is used in the local memory of the process that owns the table.  Since such data is available to only one process, it is not necessary to protect it with locks.  The local cache uses the usual displacement algorithm. <br><br>  Unlike the common buffer cache, memory for the local cache is allocated as needed, because temporary tables are not used in all sessions.  The maximum amount of memory for temporary tables in one session is limited by the <em>temp_buffers</em> parameter. <br><br><h1>  Warming up the cache </h1><br>  After restarting the server, some time should pass in order for the cache to ‚Äúwarm up‚Äù - to collect actual data that is actively used.  Sometimes it may be useful to immediately read the data of certain tables in the cache, and for this purpose a special extension is intended: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_prewarm;</code> </pre><br>  Previously, an extension could only read certain tables in the buffer cache (or only in the OS cache).  But in PostgreSQL 11, it was able to save the current state of the cache to disk and restore it after restarting the server.  To use this, you need to add the library to the <em>shared_preload_libraries</em> and reload the server. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_prewarm'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  The restart field, if the value of the <em>pg_prewarm.autoprewarm</em> parameter did not change, will automatically start the background autoprewarm master process, which once in <em>pg_prewarm.autoprewarm_interval</em> will <em>flush the</em> list of pages in the cache (remember to take into account the new process when setting <em>max_parallel_processes</em> ). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>, setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'pg_prewarm%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | setting | unit ---------------------------------+---------+------ pg_prewarm.autoprewarm | on | pg_prewarm.autoprewarm_interval | 300 | s (2 rows)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ps -o pid,command --ppid `head -n 1 /var/lib/postgresql/11/main/postmaster.pid` | grep prewarm</code> </pre><pre> <code class="plaintext hljs">10436 postgres: 11/main: autoprewarm master</code> </pre><br>  Now there is no big table in the cache: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  If we assume that all its contents are very important, we can read it into the buffer cache by calling the following function: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_prewarm(<span class="hljs-string"><span class="hljs-string">'big'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_prewarm ------------ 4097 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  The page list is reset to the autoprewarm.blocks file.  To see it, you can simply wait until the autoprewarm master process runs for the first time, but we initiate it manually: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> autoprewarm_dump_now();</code> </pre><pre> <code class="plaintext hljs"> autoprewarm_dump_now ---------------------- 4340 (1 row)</code> </pre><br>  The number of pages dropped is more than 4097 - this includes the pages of system catalog objects already read by the server.  And here is the file: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 102078  29 15:51 /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><br>  Now restart the server again. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  And right after the launch, our table is again in the cache. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  This is provided by the same autoprewarm master process: it reads a file, splits pages into databases, sorts them (so that the read from the disk is as consistent as possible) and sends the autoprewarm worker to a separate workflow for processing. <br><br>  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/458186/">https://habr.com/ru/post/458186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458172/index.html">Coupling methods for electrical connections when tracing differential pairs on printed circuit boards</a></li>
<li><a href="../458176/index.html">Exaflops barrier will be overcome in 2021</a></li>
<li><a href="../458180/index.html">Failover Kea based DHCP server</a></li>
<li><a href="../458182/index.html">We read VKontakte via RSS</a></li>
<li><a href="../458184/index.html">Haxe and PHP: static typing, arrow functions, metaprogramming and much more</a></li>
<li><a href="../458188/index.html">How I did a social network in 2019</a></li>
<li><a href="../458192/index.html">STM32 + PPP + GSM + LwIp + TLS 1.2</a></li>
<li><a href="../4582/index.html">Ru-Center: by the end of 2007 there will be 1 million domains in RuNet</a></li>
<li><a href="../458204/index.html">How to evaluate the performance of storage on Linux: benchmarking using open tools</a></li>
<li><a href="../458206/index.html">Sublime Text 3 for website layout. Customize the appearance and installation of plug-ins. Beginner's Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>