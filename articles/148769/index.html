<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Verified QuickSort on Agda</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear habrauzer! 

 Having read several books on typed lambda calculus, namely on dependent types, I saw an interesting pattern: everywhere t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Verified QuickSort on Agda</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear habrauzer! <br><br>  Having read several books on typed lambda calculus, namely on dependent types, I saw an interesting pattern: everywhere the first example is the definition of the ‚Äúsorted list‚Äù type.  Everything would be fine, but there was nothing beyond this definition.  So I thought up to fill this gap and implement a function that accepts the list, and returns another list and two proofs.  One proves that the result is a permutation of the input, and the other proves that the result is a sorted list. <br><a name="habracut"></a><br><br><h4>  Formal description </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this section, I will provide the basic types that will be used further, and some auxiliary functions.  Also here will be shown some interesting syntactic charms of Agda.  For those who are not very familiar with Agda, I recommend watching the <a href="http://lanyrd.com/2012/fprog-07/swpxb/">video / slides of</a> Jan Malakhovsky at the <a href="http://lanyrd.com/2012/fprog-07/">SPbHUG / FProg 2012-07 meeting</a> - in my opinion, this is the only introduction to Agda in Russian (well, I haven‚Äôt met again).  Or browse through the <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DReferenceManual.TOC">manual from the Agda site</a> (it is not large) or <a href="http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf">this tutorial</a> . <br><br><h5>  List definitions </h5><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> a where [] : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> _‚à∑_ : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">) ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> [_] : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> [ x ] = x ‚à∑ [] _++_ : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> [] ++ ys = ys (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) ++ ys = x ‚à∑ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> ++ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ys</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  Here we have a list.  The definition is taken from the standard library.  As you can see, the elements of the list can be values ‚Äã‚Äãof any type, even types and types of types and so on.  This is possible due to the use of high-order polymorphism: the parameter <b>a</b> is introduced, which is responsible for the level, that is, the usual types are of type <b>Set 0</b> , <b>Set 0</b> is of type <b>Set 1</b> , etc. <br>  Also in this definition you can see how in Agda operators are declared, namely through underscores, in which place there will be arguments.  It should be noted that this method allows you to define very different and very interesting forms, such as a function that returns a list from a single element <b>[_]</b> . <br><br>  It should be noted that for all operators (combinators with underscores) you can specify the priority and associativity.  Also in Agda, any Unicode sequence without spaces and brackets (round and curly) is a term. <br>  You should also pay attention to the parentheses and curly braces: curly brackets in the type indication say that this argument is implicit and will be output by the compiler. <br><br><h5>  Type "sorted list" </h5><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">‚â§</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where nil : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> _‚â§_ [] one : {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> _‚â§_ [ x ] two : {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} ‚Üí ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yl</span></span></span><span class="hljs-class">} ‚Üí x ‚â§ y ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> _‚â§_ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class"> ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">) ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> _‚â§_ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class"> ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  This definition of the predicate is "sorted list".  Designers should be considered as axioms.  We have axioms <b>nil</b> and <b>one</b> which say that the empty list and the list with one element are sorted.  We also see that the <b>Sorted</b> type depends on the predicate <b>_‚â§_</b> , which is responsible for the order ‚Äî something like the comparison function, but dependently type (the arguments are values ‚Äã‚Äãof the usual type, and the result is some type whose value is proof).  Axiom <b>two</b> says the following: if we have evidence that <b>x ‚â§ y</b> ( <b>x ‚â§ y</b> is a type, and a value of type <b>x ‚â§ y</b> is proof that <b>x ‚â§ y</b> . See the <a href="http://en.wikipedia.org/wiki/Curry%25E2%2580%2593Howard_correspondence">Curry-Howard isomorphism</a> ), and proof that some list with head <b>y</b> is sorted (this proof is a value of type <b>Sorted _‚â§_ (y l))</b> , then the list <b>x ‚à∑ y ‚à∑ l</b> will also be sorted. <br><br><h5>  Type "permutation" </h5><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Permutation</span></span></span><span class="hljs-class"> {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where refl : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Permutation</span></span></span><span class="hljs-class"> ll perm : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Permutation</span></span></span><span class="hljs-class"> l (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">‚ÇÅ ++ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">‚ÇÇ ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">‚ÇÅ ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">‚ÇÇ) ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Permutation</span></span></span><span class="hljs-class"> l (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">‚ÇÅ ++ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">‚ÇÅ ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">‚ÇÇ ‚à∑ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">‚ÇÇ)</span></span></code> </pre><br>  Type (predicate) "permutation".  Arguments are two lists.  Input axioms: <b>refl</b> - the list is a permutation of itself;  <b>perm</b> - if we have a proof that some list <b>l</b> is a permutation of another list <b>l‚ÇÅ ++ x‚ÇÇ ‚à∑ x‚ÇÅ ‚à∑ l‚ÇÇ</b> (proof of this is a value of type <b>Permutation l (l‚ÇÅ ++ x‚ÇÇ ‚à∑ x‚ÇÅ ‚à∑ l‚ÇÇ)</b> ), then if you rearrange two arbitrary element in places, we get that the new list is a permutation of the first one. <br><br><h5>  Type "amount" </h5><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> _‚äé_ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">} (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> ‚äî </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) where inj‚ÇÅ : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">) ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚äé </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class"> inj‚ÇÇ : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">) ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚äé </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span></span></code> </pre><br>  Well, everything is simple - it is not dependent type - analog of Either in Haskell. <br><br><h5>  Type Product </h5><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">record</span></span> Œ£ {ab} (<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span> a) (<span class="hljs-type"><span class="hljs-type">B</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Set</span></span> b) : <span class="hljs-type"><span class="hljs-type">Set</span></span> (a ‚äî b) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> constructor _,_ field proj‚ÇÅ : <span class="hljs-type"><span class="hljs-type">A</span></span> proj‚ÇÇ : <span class="hljs-type"><span class="hljs-type">B</span></span> proj‚ÇÅ syntax Œ£ <span class="hljs-type"><span class="hljs-type">A</span></span> (Œª x ‚Üí <span class="hljs-type"><span class="hljs-type">B</span></span>) = Œ£[ x ‚à∂ <span class="hljs-type"><span class="hljs-type">A</span></span> ] <span class="hljs-type"><span class="hljs-type">B</span></span> _√ó_ : ‚àÄ {ab} (<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span> a) (<span class="hljs-type"><span class="hljs-type">B</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span> b) ‚Üí <span class="hljs-type"><span class="hljs-type">Set</span></span> (a ‚äî b) <span class="hljs-type"><span class="hljs-type">A</span></span> √ó <span class="hljs-type"><span class="hljs-type">B</span></span> = Œ£[ _ ‚à∂ <span class="hljs-type"><span class="hljs-type">A</span></span> ] <span class="hljs-type"><span class="hljs-type">B</span></span></code> </pre><br>  This is an analogue of a tuple.  The <b>record is</b> used, since this type can have only one constructor.  This definition uses the dependent type: the first element is a value, and the second is the proof of the execution of a predicate on this element.  But, of course, you don‚Äôt have to use it this way, you can just like a regular tuple (through <b>_ √ó _</b> ) - then the dependence between the elements is ignored.  <b>syntax</b> allows new syntaxes to be defined if there are few simple possibilities. <br><br><h5>  Sort function </h5><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sort</span></span> : {<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span>} {_‚â§_ : <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Set</span></span>} ‚Üí (‚àÄ xy ‚Üí (x ‚â§ y) ‚äé (y ‚â§ x)) ‚Üí (l : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí Œ£[ l' ‚à∂ <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> ] (<span class="hljs-type"><span class="hljs-type">Sorted</span></span> _‚â§_ l' √ó <span class="hljs-type"><span class="hljs-type">Permutation</span></span> l l')</code> </pre><br>  Finally, we describe the type of the sort function: this function accepts (implicitly) a predicate that determines the order, also a function that for input values ‚Äã‚Äãreturns a proof that the first is greater than the second or that the second is greater than the first.  I think the reader guessed that this function will be used to build evidence of the sorting of the result list.  Also, of course, one of the input parameters is a list that will be sorted. <br>  The <b>sort</b> function returns a list and two proofs (sorting and permutations). <br><br><h4>  Implement the sort function </h4><br>  Of course, no implementation of this function will be here - not that I would be sorry to show the code, I feel sorry for myself to explain it.  Therefore, I will give proofs (implementations) of some auxiliary functions that I needed while writing the sort function. <br><div class="spoiler">  <b class="spoiler_title">A working source can be found here.</b> <div class="spoiler_text">  Used by Agda-2.3.1 and Standard Library-0.6 <br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS --no-termination-check #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> QuickSort <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> IO.Primitive using () renaming (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> <span class="hljs-title"><span class="hljs-title">to</span></span> <span class="hljs-title"><span class="hljs-title">putCoStrLn</span></span>) open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.String using (<span class="hljs-title"><span class="hljs-title">toCostring</span></span>; <span class="hljs-type"><span class="hljs-type">String</span></span>) renaming (<span class="hljs-title"><span class="hljs-title">_</span></span>++<span class="hljs-title"><span class="hljs-title">_</span></span> <span class="hljs-title"><span class="hljs-title">to</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span>+<span class="hljs-title"><span class="hljs-title">s</span></span>+<span class="hljs-title"><span class="hljs-title">_</span></span>) open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Nat open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Nat.Show open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Sum open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Product open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Relation.Binary.Core open <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Function data Sorted {A} (<span class="hljs-title"><span class="hljs-title">_</span></span>‚â§<span class="hljs-title"><span class="hljs-title">_</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Set</span></span>) : List A ‚Üí Set where nil : Sorted _‚â§_ [] one : {x : A} ‚Üí Sorted _‚â§_ [ x ] two : {x : A} ‚Üí ‚àÄ {yl} ‚Üí x ‚â§ y ‚Üí Sorted _‚â§_ (<span class="hljs-title"><span class="hljs-title">y</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>) ‚Üí Sorted _‚â§_ (<span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">y</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>) data Permutation {A} : List A ‚Üí List A ‚Üí Set where refl : ‚àÄ {l} ‚Üí Permutation ll perm : ‚àÄ {l} l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ ‚Üí Permutation l (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ‚Üí Permutation l (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ‚â°-elim : ‚àÄ {l} {A : Set l} {xy : A} ‚Üí x ‚â° y ‚Üí (<span class="hljs-type"><span class="hljs-type">P</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Set</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>) ‚Üí P x ‚Üí P y ‚â°-elim refl _ p = p ‚â°-sym : ‚àÄ {l} {A : Set l} {xy : A} ‚Üí x ‚â° y ‚Üí y ‚â° x ‚â°-sym refl = refl ‚â°-trans : ‚àÄ {l} {A : Set l} {xyz : A} ‚Üí x ‚â° y ‚Üí y ‚â° z ‚Üí x ‚â° z ‚â°-trans refl refl = refl ++-assoc : ‚àÄ {l} {A : Set l} (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ l‚ÇÉ ‚â° l‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) ++-assoc [] l‚ÇÇ l‚ÇÉ = refl ++-assoc (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) l‚ÇÇ l‚ÇÉ = ‚â°-elim (‚â°-<span class="hljs-title"><span class="hljs-title">sym</span></span> $ ++-<span class="hljs-title"><span class="hljs-title">assoc</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚â° <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ)) refl decNat : (<span class="hljs-title"><span class="hljs-title">xy</span></span> : ‚Ñï) ‚Üí (<span class="hljs-title"><span class="hljs-title">x</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">y</span></span>) ‚äé (<span class="hljs-title"><span class="hljs-title">y</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">x</span></span>) decNat zero y = inj‚ÇÅ z‚â§n decNat (<span class="hljs-title"><span class="hljs-title">suc</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) (<span class="hljs-title"><span class="hljs-title">suc</span></span> <span class="hljs-title"><span class="hljs-title">y</span></span>) with decNat xy ... | inj‚ÇÅ p = inj‚ÇÅ (<span class="hljs-title"><span class="hljs-title">s</span></span>‚â§<span class="hljs-title"><span class="hljs-title">sp</span></span>) ... | inj‚ÇÇ p = inj‚ÇÇ (<span class="hljs-title"><span class="hljs-title">s</span></span>‚â§<span class="hljs-title"><span class="hljs-title">sp</span></span>) decNat (<span class="hljs-title"><span class="hljs-title">suc</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) zero = inj‚ÇÇ z‚â§n perm-trans : ‚àÄ {A} {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List A} ‚Üí Permutation l‚ÇÅ l‚ÇÇ ‚Üí Permutation l‚ÇÇ l‚ÇÉ ‚Üí Permutation l‚ÇÅ l‚ÇÉ perm-trans p refl = p perm-trans p‚ÇÅ (<span class="hljs-title"><span class="hljs-title">perm</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÇ) = perm l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ $ perm-trans p‚ÇÅ p‚ÇÇ perm-sym : ‚àÄ {A} {l‚ÇÅ l‚ÇÇ : List A} ‚Üí Permutation l‚ÇÅ l‚ÇÇ ‚Üí Permutation l‚ÇÇ l‚ÇÅ perm-sym refl = refl perm-sym (<span class="hljs-title"><span class="hljs-title">perm</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>) = perm-trans (<span class="hljs-title"><span class="hljs-title">perm</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">refl</span></span>) (<span class="hljs-title"><span class="hljs-title">perm</span></span>-<span class="hljs-title"><span class="hljs-title">sym</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span>) perm-del-ins-r : ‚àÄ {A} (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) (<span class="hljs-title"><span class="hljs-title">x</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span>) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) perm-del-ins-r l‚ÇÅ x [] l‚ÇÉ = refl perm-del-ins-r l‚ÇÅ x (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) l‚ÇÉ = perm-trans p‚ÇÄ p‚ÇÖ where p‚ÇÄ : Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) p‚ÇÄ = perm l‚ÇÅ hx (<span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) refl p‚ÇÅ : Permutation ((<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) ++ x ‚à∑ t ++ l‚ÇÉ) ((<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) ++ t ++ x ‚à∑ l‚ÇÉ) p‚ÇÅ = perm-del-ins-r (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) xt l‚ÇÉ p‚ÇÇ : (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) ++ t ++ x ‚à∑ l‚ÇÉ ‚â° l‚ÇÅ ++ h ‚à∑ t ++ x ‚à∑ l‚ÇÉ p‚ÇÇ = ++-assoc l‚ÇÅ [ h ] (<span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) p‚ÇÉ : (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) ++ x ‚à∑ t ++ l‚ÇÉ ‚â° l‚ÇÅ ++ h ‚à∑ x ‚à∑ t ++ l‚ÇÉ p‚ÇÉ = ++-assoc l‚ÇÅ [ h ] (<span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) p‚ÇÑ : Permutation ((<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) ++ x ‚à∑ t ++ l‚ÇÉ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) p‚ÇÑ = ‚â°-elim p‚ÇÇ (Œª <span class="hljs-title"><span class="hljs-title">y</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> ((<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">h</span></span> ]) ++ x ‚à∑ t ++ l‚ÇÉ) y) p‚ÇÅ p‚ÇÖ : Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) p‚ÇÖ = ‚â°-elim p‚ÇÉ (Œª <span class="hljs-title"><span class="hljs-title">y</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> <span class="hljs-title"><span class="hljs-title">y</span></span> (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ)) p‚ÇÑ perm-del-ins-l : ‚àÄ {A} (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) (<span class="hljs-title"><span class="hljs-title">x</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span>) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÉ) perm-del-ins-l l‚ÇÅ l‚ÇÇ x l‚ÇÉ = perm-sym $ perm-del-ins-r l‚ÇÅ x l‚ÇÇ l‚ÇÉ perm-++ : ‚àÄ {A} {x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : List A} ‚Üí Permutation x‚ÇÅ y‚ÇÅ ‚Üí Permutation x‚ÇÇ y‚ÇÇ ‚Üí Permutation (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ) (<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÇ) perm-++ refl refl = refl perm-++ (<span class="hljs-title"><span class="hljs-title">perm</span></span> {<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ} <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>) (<span class="hljs-title"><span class="hljs-title">refl</span></span> {<span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ}) = perm-trans p‚ÇÖ p‚Çá where p‚ÇÅ : Permutation (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) ((<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ) p‚ÇÅ = perm-++ p refl p‚ÇÇ : (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ p‚ÇÇ = ++-assoc l‚ÇÅ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) z‚ÇÇ p‚ÇÉ : l‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ e‚ÇÇ ‚à∑ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ p‚ÇÉ = ‚â°-elim (++-<span class="hljs-title"><span class="hljs-title">assoc</span></span> [ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ] (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) z‚ÇÇ) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ x) refl p‚ÇÑ : l‚ÇÅ ++ e‚ÇÇ ‚à∑ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ e‚ÇÇ ‚à∑ e‚ÇÅ ‚à∑ l‚ÇÇ ++ z‚ÇÇ p‚ÇÑ = ‚â°-elim (++-<span class="hljs-title"><span class="hljs-title">assoc</span></span> [ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ] <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ e‚ÇÇ ‚à∑ x) refl g‚ÇÇ : (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ g‚ÇÇ = ++-assoc l‚ÇÅ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) z‚ÇÇ g‚ÇÉ : l‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ e‚ÇÅ ‚à∑ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ g‚ÇÉ = ‚â°-elim (++-<span class="hljs-title"><span class="hljs-title">assoc</span></span> [ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ] (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) z‚ÇÇ) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ x) refl g‚ÇÑ : l‚ÇÅ ++ e‚ÇÅ ‚à∑ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ e‚ÇÅ ‚à∑ e‚ÇÇ ‚à∑ l‚ÇÇ ++ z‚ÇÇ g‚ÇÑ = ‚â°-elim (++-<span class="hljs-title"><span class="hljs-title">assoc</span></span> [ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ] <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ ‚â° l‚ÇÅ ++ e‚ÇÅ ‚à∑ x) refl p‚ÇÖ : Permutation (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) p‚ÇÖ = ‚â°-elim (‚â°-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÇ $ ‚â°-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÉ <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÑ) (<span class="hljs-type"><span class="hljs-type">Permutation</span></span> (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ)) p‚ÇÅ p‚ÇÜ : Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) p‚ÇÜ = perm l‚ÇÅ e‚ÇÅ e‚ÇÇ (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) refl p‚Çá : Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ) ((<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++ z‚ÇÇ) p‚Çá = ‚â°-elim (‚â°-<span class="hljs-title"><span class="hljs-title">sym</span></span> $ ‚â°-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">g</span></span>‚ÇÇ $ ‚â°-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">g</span></span>‚ÇÉ <span class="hljs-title"><span class="hljs-title">g</span></span>‚ÇÑ) (<span class="hljs-type"><span class="hljs-type">Permutation</span></span> (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">z</span></span>‚ÇÇ)) p‚ÇÜ perm-++ {_} {x‚ÇÅ} {y‚ÇÅ} .{_} .{_} p‚ÇÅ (<span class="hljs-title"><span class="hljs-title">perm</span></span> {<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ} <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÇ) = ‚â°-elim p‚Çá (<span class="hljs-type"><span class="hljs-type">Permutation</span></span> (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ)) p‚ÇÜ where p' : Permutation (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ) (<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) p' = perm-++ p‚ÇÅ p‚ÇÇ p‚ÇÉ : y‚ÇÅ ++ l‚ÇÅ ++ e‚ÇÇ ‚à∑ e‚ÇÅ ‚à∑ l‚ÇÇ ‚â° (<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) ++ e‚ÇÇ ‚à∑ e‚ÇÅ ‚à∑ l‚ÇÇ p‚ÇÉ = ‚â°-sym $ ++-assoc y‚ÇÅ l‚ÇÅ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) p‚ÇÑ : Permutation (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ) ((<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) ++ e‚ÇÇ ‚à∑ e‚ÇÅ ‚à∑ l‚ÇÇ) p‚ÇÑ = ‚â°-elim p‚ÇÉ (<span class="hljs-type"><span class="hljs-type">Permutation</span></span> (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ)) p' p‚ÇÖ : Permutation ((<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) ++ e‚ÇÇ ‚à∑ e‚ÇÅ ‚à∑ l‚ÇÇ) ((<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) ++ e‚ÇÅ ‚à∑ e‚ÇÇ ‚à∑ l‚ÇÇ) p‚ÇÖ = perm (<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) e‚ÇÅ e‚ÇÇ l‚ÇÇ refl p‚ÇÜ : Permutation (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ) ((<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) ++ e‚ÇÅ ‚à∑ e‚ÇÇ ‚à∑ l‚ÇÇ) p‚ÇÜ = perm-trans p‚ÇÑ p‚ÇÖ p‚Çá : (<span class="hljs-title"><span class="hljs-title">y</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ) ++ e‚ÇÅ ‚à∑ e‚ÇÇ ‚à∑ l‚ÇÇ ‚â° y‚ÇÅ ++ l‚ÇÅ ++ e‚ÇÅ ‚à∑ e‚ÇÇ ‚à∑ l‚ÇÇ p‚Çá = ++-assoc y‚ÇÅ l‚ÇÅ (<span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">e</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) ++-[] : ‚àÄ {l} {A : Set l} (<span class="hljs-title"><span class="hljs-title">l</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí l ++ [] ‚â° l ++-[] [] = refl ++-[] (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) = ‚â°-trans p‚ÇÄ p‚ÇÅ where p‚ÇÄ : (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) ++ [] ‚â° h ‚à∑ t ++ [] p‚ÇÄ = ++-assoc [ h ] t [] p‚ÇÅ : h ‚à∑ t ++ [] ‚â° h ‚à∑ t p‚ÇÅ = ‚â°-elim (++-[] <span class="hljs-title"><span class="hljs-title">t</span></span>) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span> ++ [] ‚â° <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span>) refl data ConstrainedList {A} (<span class="hljs-type"><span class="hljs-type">P</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Set</span></span>) : List A ‚Üí Set where [] : ConstrainedList P [] _‚à∑_ : {x : A} {xs : List A} (<span class="hljs-title"><span class="hljs-title">p</span></span> : <span class="hljs-type"><span class="hljs-type">P</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) ‚Üí ConstrainedList P xs ‚Üí ConstrainedList P (<span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">xs</span></span>) infix 2 _‚àà_ data _‚àà_ {A} : A ‚Üí List A ‚Üí Set where exact : ‚àÄ ht ‚Üí h ‚àà h ‚à∑ t cons : ‚àÄ h {xl} ‚Üí x ‚àà l ‚Üí x ‚àà h ‚à∑ l create-‚àà : ‚àÄ {A} (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) (<span class="hljs-title"><span class="hljs-title">x</span></span> : <span class="hljs-type"><span class="hljs-type">A</span></span>) (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí x ‚àà (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) create-‚àà [] x l‚ÇÇ = exact x l‚ÇÇ create-‚àà (<span class="hljs-title"><span class="hljs-title">h</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>‚ÇÅ) x l‚ÇÇ = cons h‚ÇÅ $ create-‚àà t‚ÇÅ x l‚ÇÇ perm-‚àà : ‚àÄ {A l l'} {x : A} ‚Üí x ‚àà l ‚Üí Permutation l' l ‚Üí x ‚àà l' perm-‚àà p refl = p perm-‚àà {A} .{l‚ÇÅ ++ x‚ÇÅ ‚à∑ x‚ÇÇ ‚à∑ l‚ÇÇ} {l'} {x} p‚ÇÅ (<span class="hljs-title"><span class="hljs-title">perm</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÇ) = perm-‚àà (<span class="hljs-title"><span class="hljs-title">loop</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÅ) p‚ÇÇ where loop : ‚àÄ l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ ‚Üí x ‚àà l‚ÇÅ ++ x‚ÇÅ ‚à∑ x‚ÇÇ ‚à∑ l‚ÇÇ ‚Üí x ‚àà l‚ÇÅ ++ x‚ÇÇ ‚à∑ x‚ÇÅ ‚à∑ l‚ÇÇ loop [] .x x‚ÇÇ l‚ÇÇ (<span class="hljs-title"><span class="hljs-title">exact</span></span> .<span class="hljs-title"><span class="hljs-title">x</span></span> .(<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ)) = cons x‚ÇÇ $ exact x l‚ÇÇ loop [] .x‚ÇÅ .x .l‚ÇÇ (<span class="hljs-title"><span class="hljs-title">cons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ (<span class="hljs-title"><span class="hljs-title">exact</span></span> .<span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ)) = exact x (<span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) loop [] .x‚ÇÅ .x‚ÇÇ l‚ÇÇ (<span class="hljs-title"><span class="hljs-title">cons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ (<span class="hljs-title"><span class="hljs-title">cons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ <span class="hljs-title"><span class="hljs-title">p</span></span>)) = cons x‚ÇÇ $ cons x‚ÇÅ p loop (.<span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>‚ÇÅ) x‚ÇÅ x‚ÇÇ l‚ÇÇ (<span class="hljs-title"><span class="hljs-title">exact</span></span> .<span class="hljs-title"><span class="hljs-title">x</span></span> .(<span class="hljs-title"><span class="hljs-title">t</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ)) = exact x (<span class="hljs-title"><span class="hljs-title">t</span></span>‚ÇÅ ++ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÇ ‚à∑ <span class="hljs-title"><span class="hljs-title">x</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ) loop (.<span class="hljs-title"><span class="hljs-title">h</span></span>‚ÇÅ ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>‚ÇÅ) x‚ÇÅ x‚ÇÇ l‚ÇÇ (<span class="hljs-title"><span class="hljs-title">cons</span></span> <span class="hljs-title"><span class="hljs-title">h</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">p</span></span>) = cons h‚ÇÅ $ loop t‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ p constr-‚àà : ‚àÄ {A l} {x : A} ‚Üí ‚àÄ {P} ‚Üí ConstrainedList P l ‚Üí x ‚àà l ‚Üí P x constr-‚àà [] () constr-‚àà (<span class="hljs-title"><span class="hljs-title">p</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">_</span></span>) (<span class="hljs-title"><span class="hljs-title">exact</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span>) = p constr-‚àà (<span class="hljs-title"><span class="hljs-title">_</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">cl</span></span>) (<span class="hljs-title"><span class="hljs-title">cons</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span>) = constr-‚àà cl p sortedHelper‚ÇÇ : ‚àÄ {A _‚â§_} {h : A} ‚Üí ‚àÄ {l'} ‚Üí Sorted _‚â§_ l' ‚Üí ‚àÄ {l} ‚Üí Permutation ll' ‚Üí ConstrainedList (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">x</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">h</span></span>) l ‚Üí ‚àÄ {g'} ‚Üí Sorted _‚â§_ (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g'</span></span>) ‚Üí Sorted _‚â§_ (<span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g'</span></span>) sortedHelper‚ÇÇ {_} {_‚â§_} {h} {l'} sl' pll' cl {g'} sg' = loop [] l' refl sl' where loop : ‚àÄ l‚ÇÅ l‚ÇÇ ‚Üí l‚ÇÅ ++ l‚ÇÇ ‚â° l' ‚Üí Sorted _‚â§_ l‚ÇÇ ‚Üí Sorted _‚â§_ (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÇ ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g'</span></span>) loop _ .[] _ nil = sg' loop l‚ÇÅ .(<span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ []) p (<span class="hljs-title"><span class="hljs-title">one</span></span> {<span class="hljs-title"><span class="hljs-title">x</span></span>}) = two (<span class="hljs-title"><span class="hljs-title">constr</span></span>-‚àà <span class="hljs-title"><span class="hljs-title">cl</span></span> $ <span class="hljs-title"><span class="hljs-title">perm</span></span>-‚àà <span class="hljs-title"><span class="hljs-title">x</span></span>‚àà<span class="hljs-title"><span class="hljs-title">l'</span></span> <span class="hljs-title"><span class="hljs-title">pll'</span></span>) sg' where x‚ààl' : x ‚àà l' x‚ààl' = ‚â°-elim p (Œª <span class="hljs-title"><span class="hljs-title">l</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">x</span></span> ‚àà <span class="hljs-title"><span class="hljs-title">l</span></span>) (<span class="hljs-title"><span class="hljs-title">create</span></span>-‚àà <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ <span class="hljs-title"><span class="hljs-title">x</span></span> []) loop l‚ÇÅ .(<span class="hljs-title"><span class="hljs-title">x</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">y</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>) p‚â° (<span class="hljs-title"><span class="hljs-title">two</span></span> {<span class="hljs-title"><span class="hljs-title">x</span></span>} {<span class="hljs-title"><span class="hljs-title">y</span></span>} {<span class="hljs-title"><span class="hljs-title">l</span></span>} <span class="hljs-title"><span class="hljs-title">x</span></span>‚â§<span class="hljs-title"><span class="hljs-title">y</span></span> <span class="hljs-title"><span class="hljs-title">ps</span></span>) = two x‚â§y $ loop (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">x</span></span> ]) (<span class="hljs-title"><span class="hljs-title">y</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>) p' ps where p' : (<span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ ++ [ <span class="hljs-title"><span class="hljs-title">x</span></span> ]) ++ y ‚à∑ l ‚â° l' p' = ‚â°-trans (++-<span class="hljs-title"><span class="hljs-title">assoc</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ [ <span class="hljs-title"><span class="hljs-title">x</span></span> ] (<span class="hljs-title"><span class="hljs-title">y</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>)) p‚â° sortedHelper‚ÇÅ : ‚àÄ {A _‚â§_} {h : A} ‚Üí ‚àÄ {l'} ‚Üí Sorted _‚â§_ l' ‚Üí ‚àÄ {l} ‚Üí Permutation ll' ‚Üí ConstrainedList (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">x</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">h</span></span>) l ‚Üí ‚àÄ {g'} ‚Üí Sorted _‚â§_ g' ‚Üí ‚àÄ {g} ‚Üí Permutation gg' ‚Üí ConstrainedList (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">h</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">x</span></span>) g ‚Üí Sorted _‚â§_ (<span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g'</span></span>) sortedHelper‚ÇÅ sl' pll' cl nil _ _ = sortedHelper‚ÇÇ sl' pll' cl one sortedHelper‚ÇÅ sl' pll' cl {h ‚à∑ t} sg' pgg' cg = sortedHelper‚ÇÇ sl' pll' cl $ two (<span class="hljs-title"><span class="hljs-title">constr</span></span>-‚àà <span class="hljs-title"><span class="hljs-title">cg</span></span> $ <span class="hljs-title"><span class="hljs-title">perm</span></span>-‚àà (<span class="hljs-title"><span class="hljs-title">exact</span></span> <span class="hljs-title"><span class="hljs-title">ht</span></span>) pgg') sg' quickSort : {A : Set} {_‚â§_ : A ‚Üí A ‚Üí Set} ‚Üí (‚àÄ <span class="hljs-title"><span class="hljs-title">xy</span></span> ‚Üí (<span class="hljs-title"><span class="hljs-title">x</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">y</span></span>) ‚äé (<span class="hljs-title"><span class="hljs-title">y</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">x</span></span>)) ‚Üí (<span class="hljs-title"><span class="hljs-title">l</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí Œ£[ l' ‚à∂ List A ] (<span class="hljs-type"><span class="hljs-type">Sorted</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span>‚â§<span class="hljs-title"><span class="hljs-title">_</span></span> <span class="hljs-title"><span class="hljs-title">l'</span></span> √ó <span class="hljs-type"><span class="hljs-type">Permutation</span></span> <span class="hljs-title"><span class="hljs-title">l</span></span> <span class="hljs-title"><span class="hljs-title">l'</span></span>) quickSort _ [] = [] , nil , refl quickSort {A} {_‚â§_} _‚â§?_ (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) = loop t [] [] [] [] refl where loop : ‚àÄ ilg ‚Üí ConstrainedList (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">x</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">h</span></span>) l ‚Üí ConstrainedList (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">h</span></span> ‚â§ <span class="hljs-title"><span class="hljs-title">x</span></span>) g ‚Üí Permutation t ((<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ i) ‚Üí Œ£[ l' ‚à∂ List A ] (<span class="hljs-type"><span class="hljs-type">Sorted</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span>‚â§<span class="hljs-title"><span class="hljs-title">_</span></span> <span class="hljs-title"><span class="hljs-title">l'</span></span> √ó <span class="hljs-type"><span class="hljs-type">Permutation</span></span> (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) l') loop [] lg cl cg p = l' ++ h ‚à∑ g' , sortedHelper‚ÇÅ sl' pll' cl sg' pgg' cg , perm-trans p‚ÇÉ p‚ÇÑ where lSort = quickSort _‚â§?_ l gSort = quickSort _‚â§?_ g l' = proj‚ÇÅ lSort g' = proj‚ÇÅ gSort sl' = proj‚ÇÅ $ proj‚ÇÇ lSort sg' = proj‚ÇÅ $ proj‚ÇÇ gSort pll' = proj‚ÇÇ $ proj‚ÇÇ lSort pgg' = proj‚ÇÇ $ proj‚ÇÇ gSort p‚ÇÅ : Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) (<span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">g'</span></span>) p‚ÇÅ = perm-++ pll' pgg' p‚ÇÇ : Permutation t (<span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">g'</span></span>) p‚ÇÇ = perm-trans (‚â°-<span class="hljs-title"><span class="hljs-title">elim</span></span> (++-[] (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>)) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> <span class="hljs-title"><span class="hljs-title">tx</span></span>) p) p‚ÇÅ p‚ÇÉ : Permutation (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">g'</span></span>) p‚ÇÉ = perm-++ (<span class="hljs-title"><span class="hljs-title">refl</span></span> {<span class="hljs-title"><span class="hljs-title">_</span></span>} {[ <span class="hljs-title"><span class="hljs-title">h</span></span> ]}) p‚ÇÇ p‚ÇÑ : Permutation (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">g'</span></span>) (<span class="hljs-title"><span class="hljs-title">l'</span></span> ++ <span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g'</span></span>) p‚ÇÑ = perm-del-ins-r [] hl' g' loop (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) lg cl cg p with h' ‚â§? h ... | inj‚ÇÅ h'‚â§h = loop t (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">l</span></span>) g (<span class="hljs-title"><span class="hljs-title">h'</span></span>‚â§<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">cl</span></span>) cg (<span class="hljs-title"><span class="hljs-title">perm</span></span>-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span> <span class="hljs-title"><span class="hljs-title">p'</span></span>) where p' : Permutation ((<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ h' ‚à∑ t) (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ t) p' = perm-del-ins-l [] (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) h' t ... | inj‚ÇÇ h‚â§h' = loop tl (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) cl (<span class="hljs-title"><span class="hljs-title">h</span></span>‚â§<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">cg</span></span>) (<span class="hljs-title"><span class="hljs-title">perm</span></span>-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span> <span class="hljs-title"><span class="hljs-title">p'</span></span>) where p‚ÇÅ : l ++ g ++ h' ‚à∑ t ‚â° (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ h' ‚à∑ t p‚ÇÅ = ‚â°-sym $ ++-assoc lg (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) p‚ÇÇ : l ++ (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ t ‚â° (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ t p‚ÇÇ = ‚â°-sym $ ++-assoc l (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) t p‚ÇÉ : (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ t ‚â° h' ‚à∑ g ++ t p‚ÇÉ = ++-assoc [ h' ] gt p‚ÇÑ : l ++ h' ‚à∑ g ++ t ‚â° l ++ (<span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ t p‚ÇÑ = ‚â°-sym $ ‚â°-elim p‚ÇÉ (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">x</span></span> ‚â° <span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span> ++ <span class="hljs-title"><span class="hljs-title">t</span></span>) refl p‚ÇÖ : Permutation (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span> ++ <span class="hljs-title"><span class="hljs-title">t</span></span>) p‚ÇÖ = perm-del-ins-l lgh' t p‚ÇÜ : Permutation ((<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ h' ‚à∑ t) (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span> ++ <span class="hljs-title"><span class="hljs-title">t</span></span>) p‚ÇÜ = ‚â°-elim p‚ÇÅ (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> (<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span> ++ <span class="hljs-title"><span class="hljs-title">t</span></span>)) p‚ÇÖ p' : Permutation ((<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ h' ‚à∑ t) ((<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">h'</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ t) p' = ‚â°-elim (‚â°-<span class="hljs-title"><span class="hljs-title">trans</span></span> <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÑ <span class="hljs-title"><span class="hljs-title">p</span></span>‚ÇÇ) (Œª <span class="hljs-title"><span class="hljs-title">x</span></span> ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> ((<span class="hljs-title"><span class="hljs-title">l</span></span> ++ <span class="hljs-title"><span class="hljs-title">g</span></span>) ++ h' ‚à∑ t) x) p‚ÇÜ showl : List ‚Ñï ‚Üí String showl [] = "[]" showl (<span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ <span class="hljs-title"><span class="hljs-title">t</span></span>) = show h +s+ "‚à∑" +s+ showl t l‚ÇÅ : List ‚Ñï l‚ÇÅ = 19 ‚à∑ 6 ‚à∑ 13 ‚à∑ 2 ‚à∑ 8 ‚à∑ 15 ‚à∑ 1 ‚à∑ 10 ‚à∑ 11 ‚à∑ 2 ‚à∑ 17 ‚à∑ 4 ‚à∑ [ 3 ] l‚ÇÇ = quickSort decNat l‚ÇÅ main = putCoStrLn ‚àò toCostring $ showl $ proj‚ÇÅ l‚ÇÇ</code> </pre><br></div></div><br><br><h5>  Propositional Equivalence </h5><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> _‚â°_ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> a where refl : x ‚â° x ‚â°-cong : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">} {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xy</span></span></span><span class="hljs-class">} ‚Üí x ‚â° y ‚Üí (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">) ‚Üí fx ‚â° fy ‚â°-cong refl _ = refl ‚â°-elim : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xy</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} ‚Üí x ‚â° y ‚Üí (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">) ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class"> x ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class"> y ‚â°-elim refl _ p = p ‚â°-sym : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xy</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} ‚Üí x ‚â° y ‚Üí y ‚â° x ‚â°-sym refl = refl ‚â°-trans : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">} {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} ‚Üí x ‚â° y ‚Üí y ‚â° z ‚Üí x ‚â° z ‚â°-trans refl refl = refl</span></span></code> </pre><br>  As you can see, everything is simple: only one axiom that says that two objects are equal, if they are one and the same.  Also here auxiliary functions are defined for working with proofs of equivalence.  I think it's more understandable here.  Let me explain only with the example of <b>‚â°-elim</b> : the only value of the argument of the type <b>x ‚â° y</b> can be <b>refl</b> , which has one implicit parameter, which in the <b>‚â°-elim refl _ p line is</b> equal to both <b>x</b> and <b>y</b> , therefore, <b>p</b> has the same value type and <b>P x</b> and <b>P y</b> , and if the value of <b>p</b> is of type <b>P y</b> , then in this situation it will be the result of the function <b>‚â°-elim</b> . <br><br><h5>  Associative concatenation operation </h5><br><pre> <code class="haskell hljs">++-assoc : ‚àÄ {l} {<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span> l} (l‚ÇÅ l‚ÇÇ l‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí (l‚ÇÅ ++ l‚ÇÇ) ++ l‚ÇÉ ‚â° l‚ÇÅ ++ (l‚ÇÇ ++ l‚ÇÉ) ++-assoc [] l‚ÇÇ l‚ÇÉ = refl ++-assoc (h ‚à∑ t) l‚ÇÇ l‚ÇÉ = ‚â°-cong (++-assoc t l‚ÇÇ l‚ÇÉ) (Œª x ‚Üí h ‚à∑ x)</code> </pre><br>  Here <b>$</b> is nothing more than an application operator, like in Haskell.  It is clear from the definition that this function (or, one can say, the lemma) proves for three arbitrary lists the associativity of the concatenation operation.  I want to note that during the compilation terms are partially reduced using the existing definitions.  In this function, the following happens: <br>  term <br><pre> <code class="haskell hljs">‚â°-cong (++-assoc t l‚ÇÇ l‚ÇÉ) (Œª x ‚Üí h ‚à∑ x)</code> </pre> <br>  has a type <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ (t ++ l‚ÇÇ) ++ l‚ÇÉ ‚â° h ‚à∑ t ++ (l‚ÇÇ ++ l‚ÇÉ)</code> </pre> <br>  and we need a type <br><pre> <code class="haskell hljs">(l‚ÇÅ ++ l‚ÇÇ) ++ l‚ÇÉ ‚â° l‚ÇÅ ++ (l‚ÇÇ ++ l‚ÇÉ)</code> </pre> <br>  or <br><pre> <code class="haskell hljs">((h ‚à∑ t) ++ l‚ÇÇ) ++ l‚ÇÉ ‚â° (h ‚à∑ t) ++ (l‚ÇÇ ++ l‚ÇÉ)</code> </pre> <br>  this given that <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">l</span></span>‚ÇÅ = h ‚à∑ t</code> </pre> <br>  further, the compiler, using the definition of concatenation, reduces these terms to some general form. <br>  Try with a term using concatenation definition, <br><pre> <code class="haskell hljs">((h ‚à∑ t) ++ l‚ÇÇ) ++ l‚ÇÉ ‚â° (h ‚à∑ t) ++ (l‚ÇÇ ++ l‚ÇÉ)</code> </pre> <br>  get a term <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">h</span></span> ‚à∑ (t ++ l‚ÇÇ) ++ l‚ÇÉ ‚â° h ‚à∑ t ++ (l‚ÇÇ ++ l‚ÇÉ)</code> </pre> <br>  It should also be borne in mind that the concatenation operation is right associative - but this is not important for understanding. <br><br><h5>  The transitivity and symmetry of the permutation </h5><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">perm</span></span>-trans : ‚àÄ {<span class="hljs-type"><span class="hljs-type">A</span></span>} {l‚ÇÅ l‚ÇÇ l‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>} ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> l‚ÇÅ l‚ÇÇ ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> l‚ÇÇ l‚ÇÉ ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> l‚ÇÅ l‚ÇÉ perm-trans p refl = p perm-trans p‚ÇÅ (perm l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ p‚ÇÇ) = perm l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ $ perm-trans p‚ÇÅ p‚ÇÇ perm-sym : ‚àÄ {<span class="hljs-type"><span class="hljs-type">A</span></span>} {l‚ÇÅ l‚ÇÇ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>} ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> l‚ÇÅ l‚ÇÇ ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> l‚ÇÇ l‚ÇÅ perm-sym refl = refl perm-sym (perm l‚ÇÅ x‚ÇÅ x‚ÇÇ l‚ÇÇ p) = perm-trans (perm l‚ÇÅ x‚ÇÇ x‚ÇÅ l‚ÇÇ refl) (perm-sym p)</code> </pre><br><br><h5>  "Long" rearrangement left and right </h5><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">perm</span></span>-del-ins-r : ‚àÄ {<span class="hljs-type"><span class="hljs-type">A</span></span>} (l‚ÇÅ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) (x : <span class="hljs-type"><span class="hljs-type">A</span></span>) (l‚ÇÇ l‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> (l‚ÇÅ ++ x ‚à∑ l‚ÇÇ ++ l‚ÇÉ) (l‚ÇÅ ++ l‚ÇÇ ++ x ‚à∑ l‚ÇÉ) perm-del-ins-r l‚ÇÅ x [] l‚ÇÉ = refl perm-del-ins-r l‚ÇÅ x (h ‚à∑ t) l‚ÇÉ = perm-trans p‚ÇÄ p‚ÇÖ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p‚ÇÄ : <span class="hljs-type"><span class="hljs-type">Permutation</span></span> (l‚ÇÅ ++ x ‚à∑ h ‚à∑ t ++ l‚ÇÉ) (l‚ÇÅ ++ h ‚à∑ x ‚à∑ t ++ l‚ÇÉ) p‚ÇÄ = perm l‚ÇÅ hx (t ++ l‚ÇÉ) refl p‚ÇÅ : <span class="hljs-type"><span class="hljs-type">Permutation</span></span> ((l‚ÇÅ ++ [ h ]) ++ x ‚à∑ t ++ l‚ÇÉ) ((l‚ÇÅ ++ [ h ]) ++ t ++ x ‚à∑ l‚ÇÉ) p‚ÇÅ = perm-del-ins-r (l‚ÇÅ ++ [ h ]) xt l‚ÇÉ p‚ÇÇ : (l‚ÇÅ ++ [ h ]) ++ t ++ x ‚à∑ l‚ÇÉ ‚â° l‚ÇÅ ++ h ‚à∑ t ++ x ‚à∑ l‚ÇÉ p‚ÇÇ = ++-assoc l‚ÇÅ [ h ] (t ++ x ‚à∑ l‚ÇÉ) p‚ÇÉ : (l‚ÇÅ ++ [ h ]) ++ x ‚à∑ t ++ l‚ÇÉ ‚â° l‚ÇÅ ++ h ‚à∑ x ‚à∑ t ++ l‚ÇÉ p‚ÇÉ = ++-assoc l‚ÇÅ [ h ] (x ‚à∑ t ++ l‚ÇÉ) p‚ÇÑ : <span class="hljs-type"><span class="hljs-type">Permutation</span></span> ((l‚ÇÅ ++ [ h ]) ++ x ‚à∑ t ++ l‚ÇÉ) (l‚ÇÅ ++ h ‚à∑ t ++ x ‚à∑ l‚ÇÉ) p‚ÇÑ = ‚â°-elim p‚ÇÇ (Œª y ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> ((l‚ÇÅ ++ [ h ]) ++ x ‚à∑ t ++ l‚ÇÉ) y) p‚ÇÅ p‚ÇÖ : <span class="hljs-type"><span class="hljs-type">Permutation</span></span> (l‚ÇÅ ++ h ‚à∑ x ‚à∑ t ++ l‚ÇÉ) (l‚ÇÅ ++ h ‚à∑ t ++ x ‚à∑ l‚ÇÉ) p‚ÇÖ = ‚â°-elim p‚ÇÉ (Œª y ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> y (l‚ÇÅ ++ h ‚à∑ t ++ x ‚à∑ l‚ÇÉ)) p‚ÇÑ perm-del-ins-l : ‚àÄ {<span class="hljs-type"><span class="hljs-type">A</span></span>} (l‚ÇÅ l‚ÇÇ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) (x : <span class="hljs-type"><span class="hljs-type">A</span></span>) (l‚ÇÉ : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">Permutation</span></span> (l‚ÇÅ ++ l‚ÇÇ ++ x ‚à∑ l‚ÇÉ) (l‚ÇÅ ++ x ‚à∑ l‚ÇÇ ++ l‚ÇÉ) perm-del-ins-l l‚ÇÅ l‚ÇÇ x l‚ÇÉ = perm-sym $ perm-del-ins-r l‚ÇÅ x l‚ÇÇ l‚ÇÉ</code> </pre><br>  These features are more interesting.  Here I just want to note that if we consider types as theorems or lemmas, and terms of a corresponding type as evidence, then it is obvious that there can be any number of proofs of a certain statement (as well as terms of a corresponding type).  For example, it seems to me that the function above can be proved easier  It is also interesting that the ‚Äúsorted list‚Äù type I cited is a kind of singleton: each type has one representative.  As for the permutation, for one type there can be an infinite number of different terms (for example, you can rearrange the same elements twice so that the lists will not change). <br><br><h5>  Order on natural numbers </h5><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> ‚Ñï : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where zero : ‚Ñï suc : ‚Ñï ‚Üí ‚Ñï </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> _‚â§_ : ‚Ñï ‚Üí ‚Ñï ‚Üí </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where z‚â§n : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">} ‚Üí zero ‚â§ n s‚â§s : ‚àÄ {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mn</span></span></span><span class="hljs-class">} (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">‚â§</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> ‚â§ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) ‚Üí suc m ‚â§ suc n decNat : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xy</span></span></span><span class="hljs-class"> : ‚Ñï) ‚Üí (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> ‚â§ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) ‚äé (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class"> ‚â§ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) decNat zero y = inj‚ÇÅ z‚â§n decNat (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">suc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">suc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) with decNat xy ... | inj‚ÇÅ p = inj‚ÇÅ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">‚â§</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sp</span></span></span><span class="hljs-class">) ... | inj‚ÇÇ p = inj‚ÇÇ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">‚â§</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sp</span></span></span><span class="hljs-class">) decNat (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">suc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) zero = inj‚ÇÇ z‚â§n</span></span></code> </pre><br><br>  Finally, the resolving procedure for determining the order on natural numbers.  (Pay attention to how variables are named - all that there is a term without spaces.) The predicate is <b>_‚â§_</b> .  Two axioms are introduced, one of which says that any number is greater than or equal to zero, and the other that if one number is greater than the other, then the ratio will remain if you add one to them. <br>  It also uses a <b>with</b> construction - but I think its use is very clear. <br><br><h5>  That's all:) </h5><br>  From myself I will say that it is very interesting to write such programs. </div><p>Source: <a href="https://habr.com/ru/post/148769/">https://habr.com/ru/post/148769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148762/index.html">Conclusions on SQL injection</a></li>
<li><a href="../148764/index.html">Effective webinar checklist</a></li>
<li><a href="../148765/index.html">Flask-admin</a></li>
<li><a href="../148767/index.html">New Digg will start on Wednesday: ‚Äúbeautiful, with pictures and without advertising‚Äù</a></li>
<li><a href="../148768/index.html">RailsClub'Moscow 2012 - September 15 in Moscow. Conference ruby ‚Äã‚Äã/ ruby ‚Äã‚Äãon rails developers</a></li>
<li><a href="../148770/index.html">Mikhalkov demanded $ 7.5 million from Russian Apple resellers</a></li>
<li><a href="../148773/index.html">Self-executable phar as a way to distribute web applications</a></li>
<li><a href="../148774/index.html">Today, a free Internet database of blood donors has started. AnyBlood.ru</a></li>
<li><a href="../148775/index.html">Capturing webcam images via QCamera</a></li>
<li><a href="../148776/index.html">Anniversary of BTCsec.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>