<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Anatomy of the program in memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memory management is one of the main tasks of the OS. It is critical for both programming and system administration. I will try to explain how the OS ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Anatomy of the program in memory</h1><div class="post__text post__text-html js-mediator-article"> Memory management is one of the main tasks of the OS.  It is critical for both programming and system administration.  I will try to explain how the OS works with memory.  The concepts will be of a general nature, and I will take examples from Linux and Windows on 32-bit x86.  First I will describe how the programs are located in memory. <br><br>  Each process in a multitasking OS works in its sandbox in memory.  This is a virtual address space, which in 32-bit mode is a 4GB block of addresses.  These virtual addresses are mapped to physical memory with page tables that are supported by the OS kernel.  Each process has its own set of tables.  But if we begin to use virtual addressing, we have to use it for all programs running on the computer ‚Äî including the kernel itself.  Therefore, a portion of the virtual address space must be reserved for the kernel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc3/380/eba/cc3380ebad2255adc77a24364e46e731.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This does not mean that the kernel uses so much physical memory - it just has a part of the address space at its disposal that can be assigned to the necessary amount of physical memory.  The memory space for the kernel is marked in the page tables as exclusively used by the privileged code, so if a program tries to access it, a page fault happens.  In Linux, the memory space for the kernel is constantly present, and sets in correspondence the same part of the physical memory of all processes.  Kernel code and data always have addresses, and are ready to handle interrupts and system calls at any time.  For user programs, on the contrary, the correspondence of virtual addresses of real memory changes when the switching process occurs: <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/dba/601/4b0/dba6014b007cf28aa8bd8a06a074feaf.png" alt="image"><br><br>  Blue indicates virtual addresses corresponding to physical memory.  White is the space to which addresses are not assigned.  In our example, Firefox uses much more space in virtual memory because of its legendary gluttony.  The strips in the address space correspond to memory segments such as heap, stack, and so on.  These segments are just memory address intervals, and have nothing to do with segments from Intel.  Here is the standard segment diagram for a process under Linux: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/fb9/eee/405fb9eeebf87d5281ad3ddcecdbc5b5.png" alt="image"><br><br>  When programming was white and fluffy, the initial virtual segment addresses were the same for all processes.  This made it easy to remotely exploit security vulnerabilities.  Malicious programs often need to access memory at absolute addresses ‚Äî the stack address, the library function address, and so on.  Remote attacks had to be done blindly, counting on the fact that all address spaces remain on permanent addresses.  In this regard, the random address selection system has gained popularity.  Linux randomizes the stack, the memory map segment and the heap by adding offsets to their starting addresses.  Unfortunately, in the 32-bit address space you can‚Äôt really expand, and there is not enough space to assign random addresses, which makes this system not very effective. <br><br>  The topmost segment in the process's address space is the stack, which in most languages ‚Äã‚Äãstores local variables and function arguments.  Calling a method or function adds a new stack frame (stack frame) to an existing stack.  After returning from the function, the frame is deleted.  This simple scheme leads to the fact that to track the contents of the stack does not require any complex structure - just enough pointer to the beginning of the stack.  Adding and deleting data becomes a simple and unambiguous process.  The constant reuse of memory areas for the stack causes these parts to be cached in the CPU, which adds speed.  Each thread in the process gets its own stack. <br><br>  You can come to a situation in which the memory allocated for the stack ends.  This results in a page fault, which in Linux is handled by the expand_stack () function, which, in turn, calls acct_stack_growth () to check if the stack can still be expanded.  If its size does not exceed RLIMIT_STACK (usually it is 8 MB), then the stack grows and the program continues execution, as if nothing had happened.  But if the maximum stack size is reached, we get a stack overflow and the program receives a Segmentation Fault error.  At the same time, the stack can only grow - like the state budget, it does not decrease back. <br><br>  Dynamic stack growth is the only situation in which free memory can be accessed, which is shown in white in the diagram.  All other attempts to access this memory cause a page fault error leading to a Segmentation Fault.  And some occupied memory areas are read-only, so attempts to write to these areas also result in a Segmentation Fault. <br><br>  After the stack comes the memory mapping segment.  Here the kernel places the contents of the files directly in memory.  Any application can request to do this through the mmap () system call on Linux or CreateFileMapping () / MapViewOfFile () on Windows.  This is a convenient and fast way to organize input and output operations in files, so it is used to load dynamic libraries.  It is also possible to create an anonymous memory location, not associated with the files that will be used for the program data.  If you make a request to Linux for large amounts of memory through malloc (), the C library will create such an anonymous mapping instead of using heap memory.  By ‚Äúlarge‚Äù is meant a volume larger than MMAP_THRESHOLD (128 kB by default, it is configured via mallopt ().) <br><br>  The heap itself is located at the following positions in memory.  It provides memory allocation during program execution, as well as the stack - but, unlike it, it stores the data that must survive the function that allocates them.  Most languages ‚Äã‚Äãhave tools for managing the heap.  In this case, the satisfaction of the request for the allocation of memory is performed jointly by the program and the kernel.  In With the heap interface, malloc () is used with friends, and in a language that has automatic garbage collection, such as C #, the interface is the keyword new. <br><br>  If there is not enough space on the heap to fulfill the request, the program itself can handle the problem without the intervention of the kernel.  Otherwise, the heap is incremented by the brk () system call.  Heap management is a tricky business, it requires ingenious algorithms that tend to work quickly and efficiently to cater to the chaotic method of data placement used by the program.  The time to process a request for a heap can vary widely.  Real-time systems have special tools for working with it.  Heaps can also be fragmented: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/303/684/735/3036847357d5f1b126b06f5ec417ef34.png" alt="image"><br><br>  And so we got to the very bottom of the scheme - BSS, data and program text.  BSS and data store static (global) variables in C. The difference is that BSS stores the contents of non-initialized static variables whose values ‚Äã‚Äãwere not set by the programmer.  In addition, the BSS is anonymous, it does not correspond to any file.  If you write <code>static int cntActiveUsers</code> , then the contents of cntActiveUsers live in the BSS. <br><br>  The data segment, on the contrary, contains those variables that were initialized in the code.  This part of the memory corresponds to the binary image of the program containing the initial static values ‚Äã‚Äãspecified in the code.  If you write <code>static int cntWorkerBees = 10</code> , then the contents of cntWorkerBees live in the data segment, and begin their lives as 10. But, although the data segment corresponds to the program file, this is a private memory mapping - which means that the updates memory is not reflected in the corresponding file.  Otherwise, changes to the value of variables would be reflected in a file stored on disk. <br><br>  The sample data in the diagram will be a bit more complicated because it uses a pointer.  In this case, the contents of the pointer, the 4-byte memory address, lives in the data segment.  And the line on which it shows lives in a segment of text that is intended only for reading.  It stores all the code and various other details, including string literals.  It also keeps your binary in memory.  Attempts to write to this segment end with an error Segmentation Fault.  This prevents pointer-related errors (although not as effective as if you didn‚Äôt use C at all).  The diagram shows these segments and examples of variables: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30d/ef6/605/30def6605cd45a02fbd27ff8df6c3474.png" alt="image"><br><br>  You can study the memory areas of a Linux process by reading the / proc / pid_of_process / maps file.  Note that a single segment can contain many areas.  For example, each file duplicated into memory has its own region in the mmap segment, and dynamic libraries have additional regions that resemble BSS and data.  By the way, sometimes when people say "data segment", they mean data + bss + heap. <br><br>  Binary images can be studied using the commands nm and objdump - you will see characters, their addresses, segments, etc.  The virtual address scheme described in this article is so-called.  The ‚Äúflexible‚Äù scheme, which has been used by default for several years.  It implies that a value has been assigned to the RLIMIT_STACK variable.  Otherwise, Linux uses the ‚Äúclassic‚Äù scheme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3b/397/4a0/a3b3974a03065f5c6a399e83e3cc0ad8.png" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/265509/">https://habr.com/ru/post/265509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265499/index.html">Unstructured data analysis and storage optimization</a></li>
<li><a href="../265501/index.html">Creating a test DB context in tests using xUnit</a></li>
<li><a href="../265503/index.html">Motivational tale for indie game developers</a></li>
<li><a href="../265505/index.html">IBM adds support for Apache Spark for z Systems</a></li>
<li><a href="../265507/index.html">New Memory Profiler in Visual Studio 2015</a></li>
<li><a href="../265511/index.html">How to make friends JavaFX and Spring Boot</a></li>
<li><a href="../265513/index.html">Creative attempt to hack the site: write on behalf of Roskomnadzor</a></li>
<li><a href="../265515/index.html">Unusual divorce under the guise of Roskomnadzor</a></li>
<li><a href="../265517/index.html">Making a paranoiac messenger on Webix and DataBoom</a></li>
<li><a href="../265519/index.html">Armory - plugin for IntelliJ IDEA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>