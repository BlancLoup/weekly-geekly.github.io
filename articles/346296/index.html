<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Improving session control in Spring Security</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear Community. 

 While developing a multi-user web application, I ran into the problem of multiple logins (new login during an unfin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Improving session control in Spring Security</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear Community. <br><br>  While developing a multi-user web application, I ran into the problem of multiple logins (new login during an unfinished old session), the solution of which required an unusual workaround in order to preserve the logical work of the program and its clear design.  In this article I want to share with you your experience, highlighting first the traditional approaches to session management in Spring Security, and completing the review with a rational proposal in the form of a ‚Äúcrutch‚Äù of our own design. <br><br>  The problem of controlling sessions is relevant for many projects.  In my case it was a game (Java + Spring backend), where registered users can choose who to fight from the list of free players on the site.  After the player is logged in (login), information about him is added to the data structure in memory.  Some of this data is asynchronously displayed in the game interface, as a list of players present in the arena.  When a player quits, information about him should be saved in the database, removed from the data structure, and the player will no longer be displayed in the list of opponents online.  There were some difficulties due to asynchrony, but we will not touch them, because they lie away from the topic of the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let us dwell on the management strategy for a variety of situations related to login and logout.  First of all, it was necessary to take into account the fact that a player‚Äôs exit from the arena may occur as a result of his actions: <br><br><ul><li>  he can log out in good faith (by clicking the logout button); </li><li>  It can simply close the browser, the lid of the laptop, press the reset, etc., in general, leave in English. </li></ul><br><br><h3>  <font color="#3AC1EF">Leaving in English</font> </h3><br>  For such 'English' scenarios, the following approach is used. <br><br>  1. A SessionEventListener is added when registering a DispatcherServlet during standard initialization and configuration of the Spring MVC application: <br><a name="habracut"></a><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplicationInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...   //    @Override protected void registerDispatcherServlet(ServletContext servletContext) { super.registerDispatcherServlet(servletContext); servletContext.addListener(new SessionEventListener()); } }</span></span></code> </pre> <br>  2. A session event listener is implemented: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SessionEventListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpSessionEventPublisher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...   @Override public void sessionCreated(HttpSessionEvent event) { super.sessionCreated(event); // ...   //   event.getSession().setMaxInactiveInterval(60*10); } @Override public void sessionDestroyed(HttpSessionEvent event) { String name=null; //---- login    SessionRegistry SessionRegistry sessionRegistry = getAnyBean(event, "sessionRegistry"); SessionInformation sessionInfo = (sessionRegistry != null ? sessionRegistry .getSessionInformation(event.getSession().getId()) : null); UserDetails ud = null; if (sessionInfo != null) ud = (UserDetails) sessionInfo.getPrincipal(); if (ud != null) { name=ud.getUsername(); //      ,    getAnyBean(event, "allGames").removeByName(name); } super.sessionDestroyed(event); } //        public AllGames getAnyBean(HttpSessionEvent event, String name){ HttpSession session = event.getSession(); ApplicationContext ctx = WebApplicationContextUtils. getWebApplicationContext(session.getServletContext()); return (AllGames) ctx.getBean(name); } }</span></span></code> </pre><br>  3. Add SessionRegistry to the Spring Security configuration: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableWebSecurity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecurityConfiguration</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSecurityConfigurerAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//...  @Override protected void configure(HttpSecurity http) throws Exception { http .formLogin() .loginPage("/login") .failureHandler(new SecurityErrorHandler()) //...   .and() .sessionManagement() .invalidSessionUrl("/home") .maximumSessions(1) .maxSessionsPreventsLogin(true) .sessionRegistry(sessionRegistry()); } //  Spring  SessionRegistry @Bean(name = "sessionRegistry") public SessionRegistry sessionRegistry() { return new SessionRegistryImpl(); } }</span></span></code> </pre><br>  Now, due to the fact that we set the timeout 'event.getSession (). SetMaxInactiveInterval (60 * 10)' for each new session (in SessionEventListener), we have any exit script in English will lead to the fact that after a short time ( in our example - 10 minutes) the session becomes expired.  The sessionDestroyed event will immediately be thrown out, it will be processed by the listener, who will call the appropriate service to remove the player from the arena, save his persistent data, clear caches, etc.  What we wanted.  Placing all this logic in a single method called from sessionDestroyed processing, we greatly simplify the design. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/2cd/07c/d7f2cd07cc53624f62dfd2d9424b789d.jpg" alt="image" width="50%"><br><br><h3>  <font color="#3AC1EF">Log in - freedom of choice</font> </h3><br><br>  Until now, Spring Security has demonstrated the necessary flexibility.  But here there was a desire to also take into account the various options for user behavior during authorization.  So, a player can: <br><br><ul><li>  make a clean login when he does not have open sessions; </li><li>  may forget / do not want to end the old session by pressing the logout button (for example, simply closing the browser window, the lid of the laptop) and, until the timeout of 10 minutes has passed, the session remains open.  And the player eagerly wants to enter from another more convenient browser, as an option from a mobile phone, tablet, another computer. </li></ul><br>  Moreover, the latter behavior of the player can be either intentional (change the device) or a simple mistake (distracted). <br><br>  What does the standard approach of Spring Security offer in this case?  When configuring, set the following properties: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ http <span class="hljs-comment"><span class="hljs-comment">//...   .and() .maximumSessions(1) .maxSessionsPreventsLogin(false); //    </span></span></code> </pre><br>  With this configuration, the player cannot open more than one session at the same time '.maximumSessions (1)' and when trying to open a second session, the first will be immediately killed by '.maxSessionsPreventsLogin (false)' and, if the browser window with the old session was opened, the user will see in it how the transition automatically takes place from the <sup>[ <b>*</b> ]</sup> page where the game was spinning, to the specified page due to the configuration of '.invalidSessionUrl ("/ home")'. <br><br>  It just did not tire.  Since this behavior of Spring Security was similar to a preventive nuclear bombardment.  The player may re-log in by mistake, and his last game without warning stops.  It was necessary to modify this scenario so that the player would be shown a warning window with a choice: <br><br><ul><li>  stop, think again and do not log in again, and return to the already open game; </li><li>  log in again, killing the last session (and this should happen correctly, with saving data, etc., even if the player simply closed the browser window from the last, but still active session). </li></ul><br>  For this reason, preference was given to the following settings: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ http <span class="hljs-comment"><span class="hljs-comment">//...   .and() .maximumSessions(1) // .maxSessionsPreventsLogin(false) //  .maxSessionsPreventsLogin(true);</span></span></code> </pre><br><br>  Now, as a result of setting up '.maxSessionsPreventsLogin (true)', re-login a player with an unclosed last session results in a certain SessionAuthenticationException defined in the Spring Security exception.  We should only process it and redirect the user to the html warning page, which, in addition, sets the choice: a) not to continue and return to the last open session (where the game may be playing);  b) after all log in and then the last session should be killed. <br><br>  The handler of such an exception is registered during the Spring Security configuration as '.failureHandler (new SecurityErrorHandler ())', and the handler class itself is implemented as follows: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecurityErrorHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleUrlAuthenticationFailureHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ServletException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception.getClass() .isAssignableFrom(SessionAuthenticationException.class)) { <span class="hljs-comment"><span class="hljs-comment">//  warning-page,  login  URL //   (  login  ) request.getRequestDispatcher("/double_login_warning/"+ request.getParameterValues("username")[0]) .forward(request, response); //...   } }</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/385/f09/b48/385f09b481979b0f630428bfebe231d5.jpg" alt="image" width="50%"><br><br><h3>  <font color="#3AC1EF">Let me cut off the head session</font> </h3><br>  It remains to perform the appropriate actions, if the user chooses the option - login again and kill the last session.  In Spring Security there is such a possibility, it is implemented in the SessionInformation class by its expireNow () method.  This method is proposed to use to terminate any session of any user.  To find the SessionInformation for a specific user using his login, the following service was created: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span>(<span class="hljs-string"><span class="hljs-string">"expireUsereService"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Scope</span></span>(value = <span class="hljs-string"><span class="hljs-string">"session"</span></span>, proxyMode = ScopedProxyMode.TARGET_CLASS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SessionServise</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// sessionRegistry private SessionRegistry sessionRegistry; @Autowired public void setSessionRegistry(SessionRegistry sessionRegistry) { this.sessionRegistry = sessionRegistry; } //      public void expireUserSessions(String username) { for (Object principal : sessionRegistry.getAllPrincipals()) { if (principal instanceof User) { UserDetails userDetails = (UserDetails) principal; if (userDetails.getUsername().equals(username)) { for (SessionInformation information : sessionRegistry .getAllSessions(userDetails, true)) { //  information.expireNow(); } } } } } }</span></span></code> </pre><br>  Although this approach has been repeatedly described in the Spring Security community, it has a significant drawback.  With its implementation does not occur intuitively expected action.  Session of course declared to be outdated (expired), but not closed.  In other words, the session will not be destroyed (destroyed) after we manually called the recommended expireNow () for it.  And that means: <br><br><ul><li>  on the frontend in the past browser (the session in which we deliberately refused and expect it to be already destroyed with all the consequences) the player sees the game going on (if there is javascript autonomously scrolls the animation, then the illusion is quite realistic); </li><li>  The sessionDestroyed event did not occur, user data was not saved, and the game arena was not updated.  This significantly violates the logic of the multi-user system. </li></ul><br><br><h3>  <font color="#3AC1EF">Tired sessions shoot, is not it?</font> </h3><br>  Why it happens.  Calling the expireNow () method on a SessionInformation object simply simply sets the value of its field expired = true.  No other actions are performed and should not be performed.  Only when a user sends a new HTTP request from his outdated session, then this expired session will be killed, and the user will see the redirect to the login page of the login page in his browser, handle the sessionDestroyed event (expected behavior).  This is due to the fact that: a) the servlet container is engaged in the destruction of a session and it does so in this case after receiving a new HTTP request;  b) Spring Security functionality implemented using filter chains (Java Servlet Filter) does not do anything without receiving a request;  c) the SessionEventListener that we added to the servlet will handle the sessionDestroyed event, also due to a new HTTP request. <br><br>  The method recommended by many, including <a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/session-mgmt.html">Spring documentation</a> , for controlling sessions of 'expireNow ()', thus, works contrary to naive expectations.  In our case, this violated the synchronization of the application.  It is important that <u>re-login after 'expireNow ()' is already possible, as the control of sessions of Spring Security resolves this after the last session was declared expired = true (exceptions SessionAuthenticationException are not thrown away)</u> .  Spring documentation says this rather superficially.  At the same time, the last session was not actually destroyed, the sessionDestroyed event was not processed, respectively, the information about the player who expects him to go out (in order to login again) is not saved.  A game (like a chat or other interactive application) sends messages to an old session, etc.  If the player is now logged in again, chaos will occur due to the competitive creation of a new session and working out sessionDestroyed, which can be dealt with with heavy threadsafe tools.  But you can make everything easier. <br><br>  To correct this situation and make the logic of re-login and closing the old session more predictable, the following approach was used.  In our SessionService (bin is named as 'expireUsereService') we add the following method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">killExpiredSessionForSure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   //id -  SessionID,     //  getSessionId()  SessionInformation try { HttpHeaders requestHeaders = new HttpHeaders(); requestHeaders.add("Cookie", "JSESSIONID=" + id); HttpEntity requestEntity = new HttpEntity(null, requestHeaders); RestTemplate rt = new RestTemplate(); rt.exchange("http://localhost:8080", HttpMethod.GET, requestEntity, String.class); } catch (Exception ex) {} //      }</span></span></code> </pre><br>  By calling this method, we simulate an http request from a user whose session we have marked as obsolete.  It is better to call 'killExpiredSessionForSure (id)' immediately after 'expireNow ()', then the desired behavior will occur: <br><br><ul><li>  in an open browser window with an outdated session, the user (passively watching and not pressing anything) immediately sees the 'beautiful' <sup>[ <b>*</b> ]</sup> forced transition to the login / home-page; </li><li>  the session event is triggered and our entire logic for updating and saving the players arena and their data is triggered.  No crutches are needed anymore. </li></ul><br>  At first, my colleagues and I had ideas for storing open sessions in an additional data structure, keeping track of open sessions from a separate stream, etc.  But in my opinion, the proposed option with a simple call to the http request on behalf of an obsolete session (substituting the desired JSESSIONID) is more elegant. <br><br><br><h3>  <font color="#3AC1EF">We will summarize</font> </h3><br>  In general, thanks to this, the application began to work more intuitively, and ideas for its design came true.  The idea, which was to place all the code that updates data about online users and saves user data, in any way out of the system, in the sessionDestroy event handler, was sound.  For its correct implementation, it was necessary only to create an additional mechanism for the destruction of expired sessions, which is described in the conclusion of this article. <br><br>  In addition, this approach, that is, the use of a combination of method calls - the well-known 'expireNow ()' and the proposed 'killExpiredSessionForSure (String id), can be used in such cases: <br><br><ul><li>  if you are an administrator and you want to securely beat the session of any user logged in to the system.  As a result, the user will instantly see the 'outflow' from the system (transition <sup>[ <b>*</b> ]</sup> to home / login-page), and the whole logic of saving the update of his data can be implemented in the sessionDestroyed handler; </li><li>  for the implementation of the demanded script, when the session is killed a minimum time after the user closes the browser window.  In this case, you will need to create a special heartbeat in the client part of the application, transmitting signals to the backend, and a lot more, but this may be the topic of the following publications. </li></ul><br><br>  <i><b>Note</b></i> <i><br></i>  <i>* - The transition occurs due to the code on the frontend.</i>  <i>In our case, the current messages in the course of the game are transmitted using WebSocket.</i>  <i>WebSocket uses the HTTP protocol (modified) only to establish a connection, and then exchanges messages on its WebSocket protocol running over TCP.</i>  <i>Accordingly, the exchange of these messages is not filtered by the Servlet Filter in general, and the chain of Spring Security filters in particular.</i>  <i>Therefore, even in an expired session, prior to our improvement, there was an exchange of game messages.</i>  <i>The transfer of such messages did not lead to the destruction of the expired session.</i>  <i>So there was the illusion of continuing the game where it should not have been.</i>  <i>But if the session is finally destroyed (by calling killExpiredSessionForSure (id)), then the WebSocket connection is automatically terminated.</i>  <i>The front-end code notices this (when the WebSocket connection is broken, the specified callback is executed) and goes to the home / login-page page.</i>  <i>This method allows you to interrupt the WebSocket connection by the backend, since the implementation of Stomp in Spring out of the box does not have an API for breaking the WebSocket session from the server side.</i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/346296/">https://habr.com/ru/post/346296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346284/index.html">We select passwords using Google Chrome</a></li>
<li><a href="../346286/index.html">We write our own miniature Redis server in Python</a></li>
<li><a href="../346290/index.html">Testing of software documentation</a></li>
<li><a href="../346292/index.html">We turn speakers into speakers # 2: analysis of the speech of Artem Danilov, Avito</a></li>
<li><a href="../346294/index.html">What does Product Marketing Manager in JetBrains do?</a></li>
<li><a href="../346298/index.html">Which is better - 1 mobile development team or 15?</a></li>
<li><a href="../346300/index.html">Welcome to PGConf.Russia 2018</a></li>
<li><a href="../346302/index.html">IT 2018: the future came yesterday</a></li>
<li><a href="../346304/index.html">An illustrative guide to networking in Kubernetes. Parts 1 and 2</a></li>
<li><a href="../346306/index.html">Flask Mega-Tutorial Chapter 1: Hello world! (edition 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>