<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to avoid mistakes using modern C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the problems of C ++ is a large number of constructions whose behavior is undefined or just unexpected for a programmer. We often encounter suc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to avoid mistakes using modern C ++</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/3be/f20/4f0/3bef204f0fa44b4f8ade9198f65a56c2.png"></div><p></p><br>  One of the problems of C ++ is a large number of constructions whose behavior is undefined or just unexpected for a programmer.  We often encounter such errors when using a static code analyzer on different projects.  But, as you know, it is best to find errors at the compilation stage.  Let's see which techniques from modern C ++ allow us to write not only more simple and expressive code, but also make our code more secure and reliable. <br><a name="habracut"></a><br><h2>  What is Modern C ++? </h2><br><p><img src="https://habrastorage.org/files/922/82d/ffa/92282dffa2274a9ea91fefa0b0329fa4.png"></p><br><br>  The term Modern C ++ has become very popular since C ++ 11.  What does he mean?  First of all, Modern C ++ is a set of patterns and idioms that are designed to eliminate the flaws of the good old ‚ÄúC with classes‚Äù that many C ++ programmers are used to, especially if they started to program in C. C ++ 11 code looks in many cases more concisely and clearly, that is very important. <br><br>  What do people usually remember when they talk about Modern C ++?  Parallelism, compile-time calculations, RAII, lambdas, ranges (ranges), concepts, modules and other equally important components of the standard library (for example, API for working with the file system).  These are very cool innovations, and we are waiting for them in the following standards.  At the same time, I would like to pay attention to how new standards allow writing more secure code.  When developing a static code analyzer, we encounter a large number of different types of errors, and sometimes the thought arises: "But in modern C ++, this could have been avoided."  Therefore, I propose to consider a series of errors found by us with the help of PVS-Studio in various Open Source projects.  At the same time and see how to fix them better. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p><img src="https://habrastorage.org/files/a21/8f6/f86/a218f6f86eea4781b31c77c3db96c5fa.png"></p><br><br><h2>  Automatic type inference </h2><br>  The keywords <i>auto</i> and <i>decltype</i> have been added to C ++ 11.  Of course you know how they work: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = m.find(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">//C++98: std::map&lt;int, int&gt;::iterator it = m.find(42);</span></span></code> </pre> <br>  With the help of auto, you can very conveniently reduce long types without losing readability of the code.  However, these keywords are really revealed in combination with templates: c <i>auto</i> or <i>decltype</i> do not need to explicitly specify the type of the return value. <br><br>  But back to our topic.  Here is an example of a <a href="http://www.viva64.com/ru/t/0002/">64-bit error</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = .....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> n = str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n != <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos)</code> </pre> <br>  In a 64-bit application, the value of <i>string :: npos is</i> greater than the maximum value of <i>UINT_MAX</i> , which is contained by an <i>unsigned</i> variable.  It would seem that this is the case where auto can save us from this kind of problems: the type of the variable <i>n</i> is not important to us, the main thing is that it accommodates all possible values ‚Äã‚Äãof <i>string :: find</i> .  And indeed, if we rewrite this example with <i>auto</i> , the error will disappear: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = .....; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> n = str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n != <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos)</code> </pre> <br>  But here is not so simple.  Using <i>auto is</i> not a panacea and there are many errors associated with it.  For example, you can write this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> n = <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[n];</code> </pre> <br>  <i>auto</i> will not save from overflow and memory for the buffer will be allocated less than 5GiB. <br><br>  In a common error with an incorrectly recorded cycle, <i>auto</i> is also not our helper.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; bigVector; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bigVector.size(); ++i) { ... }</code> </pre> <br>  For large arrays, this cycle becomes infinite.  The presence of such errors in the code is not surprising: they manifest themselves in quite rare situations that the tests most likely did not write. <br><br>  Can this fragment be rewritten via <i>auto</i> ? <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; bigVector; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bigVector.size(); ++i) { ... }</code> </pre> <br>  No, the error has not gone away.  It got even worse. <br><br>  With simple types of <i>auto</i> behaves very badly.  Yes, in the most simple cases <i>(auto x = y)</i> it works, but as soon as additional constructions appear, the behavior may become more unpredictable.  And worst of all, the error will be harder to notice, since the types of variables will not be obvious at first glance.  Fortunately for static analyzers, calculating the type is not a problem: they do not get tired and do not lose attention.  But it is better for mere mortals to indicate simple types explicitly.  Fortunately, it is possible to get rid of the narrowing reduction in other ways, but about them a bit later. <br><br><h2>  Dangerous countof </h2><br>  One of the ‚Äúdangerous‚Äù types in C ++ is an array.  Often, when passing it to a function, they forget that it is passed as a pointer, and they try to count the number of elements through the <i>sizeof</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RTL_NUMBER_OF_V1(A) (sizeof(A)/sizeof((A)[0])) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ARRAYSIZE(A) RTL_NUMBER_OF_V1(A) int GetAllNeighbors( const CCoreDispInfo *pDisp, int iNeighbors[512] ) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( nNeighbors </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; _ARRAYSIZE( iNeighbors ) ) iNeighbors[nNeighbors++] = pCorner-&gt;m_Neighbors[i]; .... }</span></span></span></span></code> </pre> <br>  Note.  Code taken from the Source Engine SDK. <br><br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0100/">warning</a> : <a href="http://www.viva64.com/ru/d/0100/">V511</a> The sizeof () operator returns the sizeof (iNeighbors) expression.  Vrad_dll disp_vrad.cpp 60 <br><br>  Such confusion may arise from specifying the size of the array in the argument: this number means nothing to the compiler and is just a hint to the programmer. <br><br>  The trouble is that such code is compiled and the programmer does not suspect that something is amiss.  The obvious solution would be to use metaprogramming: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">countof</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> (&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array</span></span></span><span class="hljs-class">)[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">] ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> N; } countof(iNeighbors); <span class="hljs-comment"><span class="hljs-comment">//compile-time error</span></span></code> </pre> <br>  In the case when we pass to this function not an array, we get a compilation error.  In C ++ 17, you can use <i>std :: size</i> . <br><br>  In C ++ 11, the <i>std :: extent</i> function was added, but it is not suitable as a <i>countof</i> , since it returns <i>0</i> for unsuitable types. <br><br><p><img src="https://habrastorage.org/files/92c/0c2/551/92c0c25512bf45c8b10784215c58dcd6.png"></p><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::extent&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(iNeighbors)&gt;(); <span class="hljs-comment"><span class="hljs-comment">//=&gt; 0</span></span></code> </pre> <br>  You can make a mistake not only with the <i>countof</i> , but also with the <i>sizeof</i> . <br><br><pre> <code class="cpp hljs">VisitedLinkMaster::TableBuilder::TableBuilder( VisitedLinkMaster* master, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 salt[LINK_SALT_LENGTH]) : master_(master), success_(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { fingerprints_.reserve(<span class="hljs-number"><span class="hljs-number">4096</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(salt_, salt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(salt)); }</code> </pre> <br>  Note.  Code taken from Chromium. <br><br>  PVS-Studio warnings: <ul><li>  <a href="http://www.viva64.com/ru/d/0100/">V511</a> The sizeof () operator, the sizeof (salt) expression.  browser visitedlink_master.cc 968 </li><li>  <a href="http://www.viva64.com/ru/d/0101/">V512</a> A call of the memcpy function will lead to under salt of the buffer salt.  browser visitedlink_master.cc 968 </li></ul><br>  As you can see, standard arrays in C ++ have a lot of problems.  Therefore, in modern C ++ it is worth using <i>std :: array</i> : its API is similar to <i>std :: vector</i> and other containers and it is more difficult to make a mistake when using it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;uint8, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>.size(); <span class="hljs-comment"><span class="hljs-comment">//=&gt; 16 }</span></span></code> </pre> <br><h2>  How wrong in simple for </h2><br>  Another source of errors is a simple <i>for</i> loop.  It would seem, where there can be mistaken?  Is there anything related to the difficult condition of exit or savings on the lines?  No, they are mistaken in the simplest cycles. <br><br>  Let's look at fragments from the projects: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SerialWindow::kBaudrates[] = { <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span>, .... }; SerialWindow::SerialWindow() : .... { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(kBaudrates) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*); --i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>;) { message-&gt;AddInt32(<span class="hljs-string"><span class="hljs-string">"baudrate"</span></span>, kBaudrateConstants[i]); .... } }</code> </pre> <br>  Note.  Code taken from Haiku Operation System. <br><br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0347/">warning</a> : <a href="http://www.viva64.com/ru/d/0347/">V706</a> Suspicious division: sizeof (kBaudrates) / sizeof (char *).  Size of each element in the kBaudrates array does not equal to divisor.  SerialWindow.cpp 162 <br><br>  We considered such errors in detail in the previous paragraph: again, the size of the array was incorrectly calculated.  You can easily fix the situation using <i>std :: size</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SerialWindow::kBaudrates[] = { <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span>, .... }; SerialWindow::SerialWindow() : .... { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::size(kBaudrates); --i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>;) { message-&gt;AddInt32(<span class="hljs-string"><span class="hljs-string">"baudrate"</span></span>, kBaudrateConstants[i]); .... } }</code> </pre> <br>  But there is a better way.  In the meantime, look at another piece. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CXmlReader::CXmlInputStream::UnsafePutCharsBack( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TCHAR* pChars, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nNumChars) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nNumChars &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nCharPos = nNumChars - <span class="hljs-number"><span class="hljs-number">1</span></span>; nCharPos &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --nCharPos) UnsafePutCharBack(pChars[nCharPos]); } }</code> </pre> <br>  Note.  Code taken from Shareaza. <br><br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0137/">warning</a> : <a href="http://www.viva64.com/ru/d/0137/">V547</a> Expression 'nCharPos&gt; = 0' is always true.  Unsigned type value is always&gt; = 0. BugTrap xmlreader.h 946 <br><br>  A typical mistake when writing a reverse loop: forgot that the iterator is unsigned and the test returns <i>true</i> always.  Perhaps you thought: ‚ÄúHow so?  Only beginners and students are mistaken.  We, professionals, do not have such mistakes. ‚Äù  Unfortunately, this is not entirely true.  Of course, everyone understands that <i>(unsigned&gt; = 0)</i> is <i>true</i> .  Where do these errors come from?  Often they arise as a result of refactoring.  Imagine this situation: the project moves from a 32-bit platform to a 64-bit one.  Previously, <i>int / unsigned</i> was used for indexing, and it was decided to replace them with <i>size_t / ptrdiff_t</i> .  And in one place they overlooked and used the unsigned type instead of the sign type. <br><br><p><img src="https://habrastorage.org/files/176/168/fbc/176168fbc01f44dca57ff4a7235878ce.png"></p><br><br>  What to do to avoid such a situation in your code?  Some advise the use of signed types, as in C # or Qt.  Maybe this is a good way, but if we want to work with large amounts of data, the use of <i>size_t</i> cannot be avoided.  Is there any safer way to get around an array in C ++?  Of course have.  Let's start with the simplest: non-member functions.  To work with collections, arrays and <i>initializer_list,</i> there are unified functions, the working principle of which you should be familiar with: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = rbegin(buf); it != rend(buf); ++it) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *it; }</code> </pre> <br>  Fine, now we don‚Äôt need to remember the difference between the forward and reverse loop.  No need to think about whether we are using a simple array or an array ‚Äî the loop will work anyway.  Using iterators is a good way to get rid of a headache, but even it is not good enough.  It is best to use a <a href="http://en.cppreference.com/w/cpp/language/range-for">range for</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it : buf) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; it; }</code> </pre> <br>  Of course, the range <i>for</i> has its drawbacks: it does not allow the cycle progress to be managed so flexibly, and if more complex work with indexes is required, this <i>for</i> will not help us.  But such situations should be considered separately.  Our situation is quite simple: you must go through the elements of the array in the reverse order.  However, at this stage difficulties arise.  In the standard library there are no helper classes for <i>range-based for</i> .  Let's see how it could be implemented: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reversed_wrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; _v; reversed_wrapper (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; v) : _v(v) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rbegin(_v))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rbegin(_v); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rend(_v))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rend(_v); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; reversed_wrapper&lt;T&gt; reversed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; v) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversed_wrapper&lt;T&gt;(v); }</code> </pre> <br>  In C ++ 14, you can simplify the code by removing the <i>decltype</i> .  You can see how auto helps writing template functions ‚Äî <i>reversed_wrapper</i> will work with an array and with <i>std :: vector</i> . <br><br>  Now you can rewrite the fragment as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it : reversed(buf)) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; it; }</code> </pre> <br>  What good is this code?  First, it is very easy to read.  We immediately see that here the array of elements is reversed.  Secondly, it is much more difficult to make a mistake.  And thirdly, it works with any type.  This is significantly better than what it was. <br><br>  In <i>boost</i> you can use <i>boost :: adapters :: reverse (arr)</i> . <br><br>  But back to the original example.  There the array is passed in a pointer-size pair.  Obviously, our solution with reversed for it will not work.  What to do?  Use classes like <i>span / array_view</i> .  In C ++ 17 there is a <i>string_view</i> , I suggest them and use: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::string_view s)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); Foo(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>); Foo(str);</code> </pre> <br>  <i>string_view</i> does not own a string, in fact it is a wrapper over <i>const char *</i> and length.  Therefore, in the example code, the string is passed by value, not by reference.  A key feature of <i>string_view</i> is compatibility with different ways of representing strings: <i>const char *</i> , <i>std :: string,</i> and non-null-terminated <i>const char *</i> . <br><br>  As a result, the function takes the following form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CXmlReader::CXmlInputStream::UnsafePutCharsBack( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring_view chars) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> ch : reversed(chars)) UnsafePutCharBack(ch); }</code> </pre> <br>  When passing to a function, it is important not to forget that the constructor <i>string_view (const char *) is</i> implicit, so you can write like this: <br><br><pre> <code class="cpp hljs">Foo(pChars);</code> </pre> <br>  Not so: <br><br><pre> <code class="cpp hljs">Foo(wstring_view(pChars, nNumChars));</code> </pre> <br>  The string pointed to by <i>string_view</i> does not have to be null-terminated, as hinted at by the name of the method <i>string_view :: data</i> , and this should be <i>kept</i> in mind when using it.  By passing its value to a function from <i>cstdlib</i> that expects a C string, you can get an undefined behavior.  And you can easily skip this if in most cases you are testing, <i>std :: string</i> or null-terminated strings are used. <br><br><h2>  Enum </h2><br>  Let's take a look at C ++ and remember the good old C. How is security there?  After all, there are no problems with implicit calls of constructors and transformation operators, and there are no problems with different kinds of strings.  In practice, errors are often found in the simplest structures: the most complex are already carefully reviewed and debugged, as they cause suspicion.  At the same time, simple designs often forget to check.  Here is an example of a dangerous construction that came to us from C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> iscsi_param { .... ISCSI_PARAM_CONN_PORT, ISCSI_PARAM_CONN_ADDRESS, .... }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> iscsi_host_param { .... ISCSI_HOST_PARAM_IPADDRESS, .... }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iscsi_conn_get_addr_param</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iscsi_param param, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (param) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ISCSI_PARAM_CONN_ADDRESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ISCSI_HOST_PARAM_IPADDRESS: .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len; }</code> </pre> <br><p><img src="https://habrastorage.org/files/462/9f0/f47/4629f0f471684b3a88a88b6683ee6535.png"></p><br><br>  Linux kernel example.  PVS-Studio <a href="http://www.viva64.com/ru/d/0147/">warning</a> : <a href="http://www.viva64.com/ru/d/0147/">V556</a> The values ‚Äã‚Äãof different enum types are compared: switch (ENUM_TYPE_A) {case ENUM_TYPE_B: ...}.  libiscsi.c 3501 <br><br>  Note the values ‚Äã‚Äãin the <i>switch-case</i> : one of the named constants is taken from another enumeration.  In the original, of course, the code and the possible values ‚Äã‚Äãare much larger and the error is not so visual.  The reason for this is the non-strict typing of <i>enum</i> - they can be implicitly cast to <i>int</i> , and this gives a great scope for various errors. <br><br>  In C ++ 11, it is possible and necessary to use the <i>enum class</i> : such a trick will not work with them, and the error will manifest itself during compilation.  As a result, the code below does not compile, which is what we need: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISCSI_PARAM</span></span></span><span class="hljs-class"> {</span></span> .... CONN_PORT, CONN_ADDRESS, .... }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISCSI_HOST</span></span></span><span class="hljs-class"> {</span></span> .... PARAM_IPADDRESS, .... }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iscsi_conn_get_addr_param</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ISCSI_PARAM param, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (param) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ISCSI_PARAM::CONN_ADDRESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ISCSI_HOST::PARAM_IPADDRESS: .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len; }</code> </pre> <br>  The following fragment is not entirely related to <i>enum</i> , but has similar symptoms: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adns__querysend_tcp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(errno == EAGAIN || EWOULDBLOCK || errno == EINTR || errno == ENOSPC || errno == ENOBUFS || errno == ENOMEM)) { ... }</code> </pre> <br>  Note.  Code taken from ReactOS. <br><br>  Yes, <i>errno</i> values ‚Äã‚Äãare declared by macros, which in itself is a bad practice in C ++ (and in C too), but even if you used <i>enum</i> , it would not have been any easier.  The lost comparison does not appear in the case of <i>enum</i> (and even more so the macro).  But the <i>enum class</i> would not allow this, since an implicit cast to <i>bool</i> will not occur. <br><br><h2>  Initialization in the constructor </h2><br>  But back to the original C ++ problems.  One of them manifests itself when it is necessary to initialize an object in a similar way in several constructors.  A simple situation: there is a class, there are two constructors, one of them calls the other.  Everything looks logical: the common code is put into a separate method - no one likes to duplicate the code.  What's the catch? <br><br><pre> <code class="cpp hljs">Guess::Guess() { language_str = DEFAULT_LANGUAGE; country_str = DEFAULT_COUNTRY; encoding_str = DEFAULT_ENCODING; } Guess::Guess(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * guess_str) { Guess(); .... }</code> </pre> <br>  Note.  The code is from LibreOffice. <br><br>  PVS-Studio warning: <a href="http://www.viva64.com/ru/d/0215/">V603</a> The object was not used.  If you wish to call constructor, 'this-&gt; Guess :: Guess (....)' should be used.  guess.cxx 56 <br><br>  A trick in the syntax of the constructor call.  Often they forget about it and create another instance of the class, which will be immediately destroyed.  That is, the initial instance does not initialize.  Naturally there are 1000 and 1 ways to fix this.  For example, you can explicitly call a constructor through this or put everything into a separate function: <br><br><pre> <code class="cpp hljs">Guess::Guess(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * guess_str) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Guess(); .... } Guess::Guess(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * guess_str) { Init(); .... }</code> </pre> <br>  By the way, an explicit re-call of the constructor, for example, through this is a dangerous game and you need to understand well what is happening.  The variant with the Init () function is much better and clearer.  For those who want to deal in more detail with the dirty tricks, I suggest to get acquainted with the 19th chapter "How to call one constructor from another correctly" from this <a href="http://www.viva64.com/ru/b/0391/">book</a> . <br><br>  But it is best to use a delegation of designers.  So we can explicitly call one constructor from another: <br><br><pre> <code class="cpp hljs">Guess::Guess(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * guess_str) : Guess() { .... }</code> </pre> <br>  Such constructors have several limitations.  First: the delegated constructor takes full responsibility for initializing the object.  That is, with it, initializing another class field in the initialization list will not work: <br><br><pre> <code class="cpp hljs">Guess::Guess(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * guess_str) : Guess(), m_member(<span class="hljs-number"><span class="hljs-number">42</span></span>) { .... }</code> </pre> <br>  And naturally, it is necessary to ensure that the delegation does not form a cycle, since it will not work out of it.  Unfortunately, this code is compiled: <br><br><p><img src="https://habrastorage.org/files/77b/b41/363/77bb4136304e486eb8832c9043a7dd96.png"></p><br><br><pre> <code class="cpp hljs">Guess::Guess(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * guess_str) : Guess(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(guess_str)) { .... } Guess::Guess(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> guess_str) : Guess(guess_str.c_str()) { .... }</code> </pre> <br><h2>  About virtual functions </h2><br>  Virtual functions pose a potential problem: the fact is that it is very easy in the inherited class to make a mistake in the signature and, as a result, not to redefine the function, but to declare a new one.  Consider this situation by example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre> <br>  The <i>Derived :: Foo</i> method cannot be called by the pointer / reference to <i>Base</i> .  But this example is simple and one can say that no one is wrong.  And usually make mistakes like this: <br><br>  Note.  Code taken from MongoDB. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBClientBase</span></span></span><span class="hljs-class"> :</span></span> .... { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;DBClientCursor&gt; query( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;ns, Query query, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nToReturn = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nToSkip = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BSONObj *fieldsToReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> queryOptions = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> batchSize = <span class="hljs-number"><span class="hljs-number">0</span></span> ); }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBDirectClient</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DBClientBase { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;DBClientCursor&gt; query( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;ns, Query query, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nToReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nToSkip = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BSONObj *fieldsToReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> queryOptions = <span class="hljs-number"><span class="hljs-number">0</span></span>); };</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0516/">warning</a> : <a href="http://www.viva64.com/ru/d/0516/">V762</a> Consider inspecting virtual function arguments.  See seventh argument of the function 'query' in the derived class 'DBDirectClient' and base class 'DBClientBase'.  dbdirectclient.cpp 61 <br><br>  There are many arguments and there is no last argument in the function of the class of the heir  These are already two different unrelated functions.  Very often, this error manifests itself with arguments that have a default value. <br><br>  In the next fragment, the situation is more cunning.  Such code will work if it is compiled as 32-bit, but will not work in the 64-bit version.  Initially, the parameter in the base class was a <i>DWORD</i> type, but then it was fixed to <i>DWORD_PTR</i> .  And in the inherited classes did not change.  Long live the sleepless night, debugging and coffee! <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CWnd</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CCmdTarget { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WinHelp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT)</span></span></span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CFrameWnd</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CWnd { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CFrameWndEx</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CFrameWnd { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WinHelp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwData, UINT nCmd = HELP_CONTEXT)</span></span></span></span>; .... };</code> </pre> <br>  It is possible to make a mistake in the signature in more extravagant ways.  You can forget to <i>const</i> a function or argument.  You can forget that the function in the base class is not virtual.  You can confuse signed / unsigned type. <br><br>  In C ++ 11, several keywords have been added that can govern the redefinition of virtual functions.  <i>Override</i> will help us.  Such code is simply not compiled. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBDirectClient</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DBClientBase { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;DBClientCursor&gt; query( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;ns, Query query, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nToReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nToSkip = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BSONObj *fieldsToReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> queryOptions = <span class="hljs-number"><span class="hljs-number">0</span></span>) override; };</code> </pre> <br><h2>  Null vs nullptr </h2><br>  Using <i>NULL</i> to indicate a null pointer leads to a number of unexpected situations.  The fact is that <i>NULL</i> is a normal macro, which is expanded to 0, having the type <i>int</i> .  From here it is easy to understand why in this example the second function is selected: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ResourceID)</span></span></span></span>; Foo(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  But even though this is understandable, it is certainly not logical.  Therefore, there is a need for <i>nullptr</i> , which has its own type of <i>nullptr_t</i> .  Therefore, to use <i>NULL</i> (and even more so <i>0</i> ) in modern C ++ is absolutely impossible. <br><br>  Another example: <i>NULL</i> can be used to compare with other integer types.  Imagine that there is a certain <i>WinAPI</i> function that returns a <i>HRESULT</i> .  This type has nothing to do with the pointer, so comparing it with <i>NULL</i> does not make sense.  And <i>nullptr</i> this underscores the compilation error, while <i>NULL</i> works: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WinApiFoo(a, b) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  if (WinApiFoo(a, b) != nullptr) // ,  // </span></span></code> </pre> <br><h2>  va_arg </h2><br>  There are situations when an indefinite number of arguments must be passed to a function.  A typical example is the formatted input / output function.  Yes, it can be designed in such a way that a variable number of arguments is not needed, but I see no reason to abandon this syntax, since it is much more convenient and intuitive.  What do old C ++ standards offer us?  They suggest using <i>va_list</i> .  What problems may arise?  It is very easy to pass an argument of the wrong type to such a function.  Or do not pass the argument.  Let's look more at the fragments. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring string16; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> base::<span class="hljs-function"><span class="hljs-function">string16&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">relaunch_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RelaunchChrome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DelegateExecuteOperation&amp; operation)</span></span></span><span class="hljs-function"> </span></span>{ AtlTrace(<span class="hljs-string"><span class="hljs-string">"Relaunching [%ls] with flags [%s]\n"</span></span>, operation.mutex().c_str(), operation.relaunch_flags()); .... }</code> </pre> <br>  Note.  Code taken from Chromium. <br><br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0099/">warning</a> : <a href="http://www.viva64.com/ru/d/0099/">V510</a> The "AtlTrace" function is not expected.  delegate_execute.cc 96 <br><br>  They wanted to print the string <i>std :: wstring</i> , but forgot to call the <i>c_str ()</i> method.  That is, the <i>wstring</i> type will be interpreted as <i>const wchar_t *</i> in the function.  Naturally, nothing good will come of it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">cairo_status_t</span></span> _cairo_win32_print_gdi_error (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *context) { .... fwprintf (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">L"%s: %S"</span></span>, context, (<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> *)lpMsgBuf); .... }</code> </pre> <br>  Note.  Code taken from Cairo. <br><br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0176/">warning</a> : <a href="http://www.viva64.com/ru/d/0176/">V576</a> Incorrect format.  Consider checking the fwprintf function.  Wchar_t type symbols is expected.  cairo-win32-surface.c 130 <br><br>  In this snippet, the format specifiers for strings are confused.  The fact is that in Visual C ++ for <i>wprintf</i> % s expects <i>wchar_t *</i> , and% S - <i>char *</i> .  It is noteworthy that these errors are in the lines intended for displaying errors or debugging information - for sure these are rare situations, so they missed them. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNameForFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* baseFileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint32 fileIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outputName[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">512</span></span></span></span><span class="hljs-function"><span class="hljs-params">] )</span></span></span><span class="hljs-function"> </span></span>{ assert(baseFileName != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>( outputName, <span class="hljs-string"><span class="hljs-string">"%s_%d"</span></span>, baseFileName, fileIdx ); }</code> </pre> <br>  Note.  Code taken from CryEngine 3 SDK. <br><br>  PVS-Studio warning: V576 Incorrect format.  Consider checking the fourth argument of the 'sprintf' function.  The SIGNED integer type argument is expected.  igame.h 66 <br><br>  Equally easy to confuse and integer types.  Especially when their size depends on the platform.  Here, however, everything is more banal: mixed sign and unsigned types.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Large numbers will be printed as negative. </font></font><br><br><pre> <code class="cpp hljs">ReadAndDumpLargeSttb(cb,err) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cb; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; { .... <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n - %d strings were read, "</span></span> <span class="hljs-string"><span class="hljs-string">"%d were expected (decimal numbers) -\n"</span></span>); .... }</code> </pre> <br>  Note.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code taken from Word for Windows 1.1a. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V576 Incorrect format. </font><font style="vertical-align: inherit;">A different number of actual arguments is expected while calling 'printf' function. </font><font style="vertical-align: inherit;">Expected: 3. Present: 1. dini.c 498 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example found in one of the </font></font><a href="http://www.viva64.com/ru/b/0245/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archaeological research</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The string implies the presence of three arguments, but they are not. </font><font style="vertical-align: inherit;">Maybe they wanted to print out the data on the stack, but it‚Äôs still not worth making such assumptions about what lies there. </font><font style="vertical-align: inherit;">Definitely need to pass arguments explicitly.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL CALLBACK </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumPickIconResourceProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;br&gt; HMODULE hModule, LPCWSTR lpszType, &lt;br&gt; LPWSTR lpszName, LONG_PTR lParam)</span></span></span><span class="hljs-function">&lt;br&gt;</span></span>{&lt;br&gt; ....&lt;br&gt; swprintf(szName, <span class="hljs-string"><span class="hljs-string">L"%u"</span></span>, lpszName);&lt;br&gt; ....&lt;br&gt;}</code> </pre> <br>  Note.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code taken from ReactOS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V576 Incorrect format. Consider checking the swprintf function. To print the value of the% p 'should be used. dialogs.cpp 66 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example of a 64-bit error. The size of the pointer depends on the architecture and using% u for it is a bad idea. What to use instead? The analyzer itself tells us the correct answer -% p. Well, if the pointer is simply printed for debugging. It will be much more interesting if it is then attempted to be read and used from the buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are bad functions with a variable number of arguments? Almost everyone! They can not check the type of the argument or the number of arguments. Step left, step right - undefined behavior.</font></font><br><br><p><img src="https://habrastorage.org/files/3f9/222/035/3f92220353604f72950573071db20fdb.png"></p><br><br> ,     . -,  <i>variadic templates</i> .                 ,  .      <i>printf</i> ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s, T value, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &amp;&amp; *s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*s==<span class="hljs-string"><span class="hljs-string">'%'</span></span> &amp;&amp; *++s!=<span class="hljs-string"><span class="hljs-string">'%'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(++s, args...); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *s++; } }</code> </pre> <br>     :     .   <i>variadic</i> templates       ,    . <br><br>   ,   ,      , ‚Äî  <i>std::initializer_list</i> .       .    ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">initializer_list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; a)</span></span></span></span>; Foo({<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>});</code> </pre> <br>      ,        <i>begin</i> , <i>end</i>   <i>for</i> . <br><br><h2> Narrowing </h2><br>  (narrowing)      . ,      64- . ,       .      :          .      ,     . <br><br><p><img src="https://habrastorage.org/files/5c7/9a2/0f2/5c79a20f2aef4232b24a77700557b9a8.png"></p><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ptr; .... ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) n;</code> </pre> <br>    64- .    :         .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMappingWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMappingHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CDetailObjectSystem::LevelInitPreEntity() { .... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> flRatio = pMat-&gt;GetMappingWidth() / pMat-&gt;GetMappingHeight(); .... }</code> </pre> <br>  Note.    Source Engine SDK. <br><br>  PVS-Studio: <a href="http://www.viva64.com/ru/d/0254/">V636</a> The expression was implicitly cast from 'int' type to 'float' type.  Consider using a fractional part.  An example: double A = (double) (X) / Y ;. Client (HL2) detailobjectsystem.cpp 1480 <br><br>  ,         ‚Äî           .       C++11    :    .              . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> flRatio { pMat-&gt;GetMappingWidth() / pMat-&gt;GetMappingHeight() };</code> </pre> <br><h2> No news is good news </h2><br>         .      ‚Äî     .  C++            .     ‚Äî     ,       .     : <br><br><p><img src="https://habrastorage.org/files/af4/c14/599/af4c14599449499598e58f47b93188c8.png"></p><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AccessibleContainsAccessible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;VARIANT&gt; child_array( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VARIANT[child_count]); ... }</code> </pre> <br>  Note.    Chromium. <br><br>  PVS-Studio: <a href="http://www.viva64.com/ru/d/0145/">V554</a> Incorrect use of auto_ptr.  The memory is allocated with 'new []' will be cleaned using 'delete'. interactive_ui_tests accessibility_win_browsertest.cc 171 <br><br> ,     : ,    <i>std::auto_ptr</i> .       ,     deprecated  C++11,   C++17 .      - ,  <i>auto_ptr</i>  :      ,     <i>delete</i> ,   <i>delete[]</i> .   <i>auto_ptr</i>  <i>unique_ptr</i> ,       ,     <i>deleter</i> ,     <i>delete</i> ,     . ,      ? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> text_editor::_m_draw_string(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; pxbuf_ptr( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>[len]); .... }</code> </pre> <br>  Note.    nana. <br><br>  PVS-Studio: V554 Incorrect use of unique_ptr.  The memory is allocated with 'new []' will be cleaned using 'delete'.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">text_editor.cpp 3137 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that you can make exactly the same mistake. Yes, it is enough to write </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr &lt;unsigned []&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and it will disappear, nevertheless, the code also compiles in this form. That is, it is also possible to make a mistake in this way, but as practice shows, if somewhere it is possible to make a mistake, they will necessarily make a mistake. The code snippet only confirms this. So, using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with arrays, be extremely careful: it is easier to shoot yourself in the foot than it seems. Maybe then it is better to use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: vector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> according to the principles of Modern C ++? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider another type of accident.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TOpenGLStage</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FString</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetShaderStageSource</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TOpenGLStage</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shader</span></span></span><span class="hljs-class">) {</span></span> .... ANSICHAR* Code = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ANSICHAR[Len + <span class="hljs-number"><span class="hljs-number">1</span></span>]; glGetShaderSource(Shaders[i], Len + <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;Len, Code); Source += Code; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Code; .... }</code> </pre> <br>  Note.    Unreal Engine 4. <br><br>  PVS-Studio: <a href="http://www.viva64.com/ru/d/0226/">V611</a> The memory was allocated using 'new T[]' operator but was released using the 'delete' operator. Consider inspecting this code. It's probably better to use 'delete [] Code;'. openglshaders.cpp 1790 <br><br>         : ,    <i>new[]</i> ,   <i>free</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CxImage::LayerCreate(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> position) { .... CxImage** ptmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CxImage*[info.nNumLayers + <span class="hljs-number"><span class="hljs-number">1</span></span>]; .... <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ptmp); .... }</code> </pre> <br>  Note.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code taken from CxImage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio warning: V611 </font><font style="vertical-align: inherit;">Consider inspecting operation logics behind the 'ptmp' variable. </font><font style="vertical-align: inherit;">ximalyr.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in this fragment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new / delete were</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> confused </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This can happen during refactoring: there were functions from C everywhere, we decided to change, we got UB.</font></font><br><br><p><img src="https://habrastorage.org/files/342/fb2/d91/342fb2d91a354b83999aee26444986d6.png"></p><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">settings_proc_language_packs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mem_files) { mem_files = <span class="hljs-number"><span class="hljs-number">0</span></span>; sys_mem_free(mem_files); } .... }</code> </pre> <br>  Note.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code taken from Fennec Media. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio </font></font><a href="http://www.viva64.com/ru/d/0175/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warning</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="http://www.viva64.com/ru/d/0175/"><font style="vertical-align: inherit;">V575</font></a><font style="vertical-align: inherit;"> The null pointer is passed into the 'free' function.</font></font> Inspect the first argument. settings interface.c 3096 <br><br>      .  ,      .       .     :        .        free     (    ). <br><br><pre> <code class="cpp hljs">ETOOLS_API <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ogg_enc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ format = open_audio_file(in, &amp;enc_opts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!format) { fclose(in); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; out = fopen(out_fn, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (out == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { fclose(out); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the problem concerns not only memory management, but also resource management. You can, for example, forget to close the file, as in the fragment above. And the key word in both cases is RAII. The same concept stands behind smart pointers. In combination with move-semantics, RAII eliminates many memory leak errors. And the code written in this style allows you to more clearly determine the ownership of the resource. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a small example, I‚Äôll give a wrapper over </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FILE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that uses the capabilities of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> deleter = [](FILE* f) {fclose(f);}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;FILE, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(deleter)&gt; p(fopen(<span class="hljs-string"><span class="hljs-string">"1.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>), deleter);</code> </pre> <br>             (     ).   ,   C++17  API      ‚Äî <i>std::filesystem</i> .            <i>fread/fwrite</i>  i/o-,    <i>unique_ptr</i>    <i>File</i> ,         ,   . <br><br><h2>    ? </h2><br>  C++   ,      .     compile-time   .          . <br><br>             .    ++       ,    , .      - :     , -           ,     -  . <br><br><p><img src="https://habrastorage.org/files/550/30b/68d/55030b68d56f499ba0f7540674d5cd65.png"></p><br><br>    .   PVS-Studio:       Linux     <a href="http://www.viva64.com/ru/b/0415/"></a>  :          ,   .   Windows-       Visual Studio,   <a href="http://www.viva64.com/ru/pvs-studio/"> </a>  trial-. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0429/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br>        ,      : Pavel Belikov. <a href="http://www.viva64.com/en/b/0429/">How to avoid bugs using modern C++</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/310064/">https://habr.com/ru/post/310064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310054/index.html">Overview of the OPCache extension for PHP</a></li>
<li><a href="../310056/index.html">Launch Linux on FPGA: Hello, World</a></li>
<li><a href="../310058/index.html">How to stop being afraid and fall in love with mbed [Part 3]</a></li>
<li><a href="../310060/index.html">Cycle of articles "NetRack Guards: guarding the client IT infrastructure": the story of a man who knows everything</a></li>
<li><a href="../310062/index.html">Pitfalls of conditional formatting in MS Access</a></li>
<li><a href="../310066/index.html">31 best email marketing automation tools</a></li>
<li><a href="../310068/index.html">PHP: fractal misuse</a></li>
<li><a href="../310070/index.html">Hackathon in the company: how to do it and why to participate in it</a></li>
<li><a href="../310074/index.html">Dropbox on macOS uses malware tricks to get privileges that it doesn't need</a></li>
<li><a href="../310076/index.html">What game evaluation window to integrate into your mobile phone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>