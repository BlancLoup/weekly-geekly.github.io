<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multithreading - as a means of increasing efficiency</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A good practice in creating a responsive application is to ensure that your user interface requires a minimum of processing time. Each potentially lon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multithreading - as a means of increasing efficiency</h1><div class="post__text post__text-html js-mediator-article">  A good practice in creating a responsive application is to ensure that your user interface requires a minimum of processing time.  Each potentially long action that your application can hang should be put into a separate thread.  Typical examples of such actions are network operations that carry unpredictable delays.  Users can put up with small pauses, especially if you inform them about the progress, but the frozen application does not give them any choice but to close it. <br><br>  In this tutorial, we will create a picture uploader that illustrates this situation.  We will populate the <b>ListView with</b> thumbnails of images downloaded from the web.  The created asynchronous process loading images in the background will speed up our application. <br><a name="habracut"></a><br><br><h3>  Picture Loader </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Downloading images from the Internet is very simple and is done using the related HTTP class from the framework.  Here is one of the implementations: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">static</font> <font color="#2B91AF">Bitmap</font> downloadBitmap( <font color="#2B91AF">String</font> url) { <br> final AndroidHttpClient client = AndroidHttpClient.newInstance( <font color="#A31515">"Android"</font> ); <br> final HttpGet getRequest = <font color="#0000ff">new</font> HttpGet(url); <br> <br> <font color="#0000ff">try</font> { <br> HttpResponse response = client.execute(getRequest); <br> final <font color="#0000ff">int</font> statusCode = response.getStatusLine().getStatusCode(); <br> <font color="#0000ff">if</font> (statusCode != HttpStatus.SC_OK) { <br> Log.w( <font color="#A31515">"ImageDownloader"</font> , <font color="#A31515">"Error "</font> + statusCode + <font color="#A31515">" while retrieving bitmap from "</font> + url); <br> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <br> <br> final HttpEntity entity = response.getEntity(); <br> <font color="#0000ff">if</font> (entity != <font color="#0000ff">null</font> ) { <br> InputStream inputStream = <font color="#0000ff">null</font> ; <br> <font color="#0000ff">try</font> { <br> inputStream = entity.getContent(); <br> final <font color="#2B91AF">Bitmap</font> bitmap = BitmapFactory.decodeStream(inputStream); <br> <font color="#0000ff">return</font> bitmap; <br> } <font color="#0000ff">finally</font> { <br> <font color="#0000ff">if</font> (inputStream != <font color="#0000ff">null</font> ) { <br> inputStream.close(); <br> } <br> entity.consumeContent(); <br> } <br> } <br> } <font color="#0000ff">catch</font> (Exception e) { <br> <font color="#008000">//         IOException  IllegalStateException</font> <br> getRequest.abort(); <br> Log.w( <font color="#A31515">"ImageDownloader"</font> , <font color="#A31515">"Error while retrieving bitmap from "</font> + url, e.toString()); <br> } <font color="#0000ff">finally</font> { <br> <font color="#0000ff">if</font> (client != <font color="#0000ff">null</font> ) { <br> client.close(); <br> } <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Client and HTTP request created.  If the request is successful, then the response flow will contain a picture, which will then be turned into a final icon.  For normal operation of your application, its manifest should require <b>INTERNET</b> . <br>  Caution: a bug in the previous version of <b>BitmapFactory.decodeStream</b> may interfere with the execution of your code during a slow connection.  To avoid this problem, use FlushedInputStream (inputStream).  Here is an example of this helper class: <br><br><blockquote> <code><font color="black"><font color="#0000ff">static</font> <font color="#0000ff">class</font> FlushedInputStream extends FilterInputStream { <br> <font color="#0000ff">public</font> FlushedInputStream(InputStream inputStream) { <br> super(inputStream); <br> } <br> <br> @Override <br> <font color="#0000ff">public</font> <font color="#0000ff">long</font> skip( <font color="#0000ff">long</font> n) throws IOException { <br> <font color="#0000ff">long</font> totalBytesSkipped = 0L; <br> <font color="#0000ff">while</font> (totalBytesSkipped &lt; n) { <br> <font color="#0000ff">long</font> bytesSkipped = <font color="#0000ff">in</font> .skip(n - totalBytesSkipped); <br> <font color="#0000ff">if</font> (bytesSkipped == 0L) { <br> <font color="#0000ff">int</font> <font color="#0000ff">byte</font> = read(); <br> <font color="#0000ff">if</font> ( <font color="#0000ff">byte</font> &lt; 0) { <br> } <br> totalBytesSkipped += bytesSkipped; <br> } <br> <font color="#0000ff">return</font> totalBytesSkipped; <br> } <br> }</font> <br> <br></code> </blockquote><br><br>  It grants that skip () will really miss that many bytes when we reach the end of the file. <br><br>  If you suddenly use this method directly in the <b>ListView</b> method of the <b>ListAdapter</b> , then as a result you will get incredibly intermittent scrolling. <br><br>  Moreover, this is a very bad idea, because  <b>AndroidHttpClient</b> cannot be started along with the main thread.  Instead, this code will display the error ‚ÄúThis thread forbids HTTP requests‚Äù (‚ÄúThis thread loses HTTP requests‚Äù).  Better use <b>DefaultHttpClient</b> , if you really want to put a stick in the wheel. <br><br><h3>  About asynchronous tasks </h3><br><br>  The <b>AsyncTask</b> class provides one of the simplest ways to launch a new task directly from the user interface thread.  Let's create an <b>ImageDownloader</b> class that will be responsible for creating these tasks.  It will provide a <b>download</b> method that will assign the downloaded image with its URL in the ImageView: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> ImageDownloader { <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> download( <font color="#2B91AF">String</font> url, ImageView imageView) { <br> BitmapDownloaderTask task = <font color="#0000ff">new</font> BitmapDownloaderTask(imageView); <br> task.execute(url); <br> } <br> } <br> <br> <font color="#008000">/*  BitmapDownloaderTask,   */</font> <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  BitmapDownloaderTask is an asynchronous task that actually downloads the image.  It starts using <b>execute</b> , which returns the value immediately, making this method really fast.  Here is an example of the implementation of this class: <br><br><blockquote> <code><font color="black"><font color="#0000ff">class</font> BitmapDownloaderTask extends AsyncTask&lt; <font color="#2B91AF">String</font> , Void, <font color="#2B91AF">Bitmap</font> &gt; { <br> <font color="#0000ff">private</font> <font color="#2B91AF">String</font> url; <br> <font color="#0000ff">private</font> final WeakReference&lt;ImageView&gt; imageViewReference; <br> <font color="#0000ff">public</font> BitmapDownloaderTask(ImageView imageView) { <br> imageViewReference = <font color="#0000ff">new</font> WeakReference&lt;ImageView&gt;(imageView); <br> } <br> @Override <br> <font color="#008000">// Actual download method, run in the task thread</font> <br> <font color="#0000ff">protected</font> <font color="#2B91AF">Bitmap</font> doInBackground( <font color="#2B91AF">String</font> ... <font color="#0000ff">params</font> ) { <br> <font color="#008000">// params comes from the execute() call: params[0] is the url.</font> <br> <font color="#0000ff">return</font> downloadBitmap( <font color="#0000ff">params</font> [0]); <br> } <br> @Override <br> <font color="#008000">// Once the image is downloaded, associates it to the imageView</font> <br> <font color="#0000ff">protected</font> <font color="#0000ff">void</font> onPostExecute( <font color="#2B91AF">Bitmap</font> bitmap) { <br> <font color="#0000ff">if</font> (isCancelled()) { <br> bitmap = <font color="#0000ff">null</font> ; <br> <br> } <br> <font color="#0000ff">if</font> (imageViewReference != <font color="#0000ff">null</font> ) { <br> ImageView imageView = imageViewReference. <font color="#0000ff">get</font> (); <br> <font color="#0000ff">if</font> (imageView != <font color="#0000ff">null&lt;/fonthttp://habrahabr.ru/edit/topic/99631/#&gt;) { <br> imageView.setImageBitmap(bitmap); <br> }}}}</font></font></code> <br> </blockquote><br>  The <b>doInBackground</b> method actually works on the task in its own process.  It will simply use the <b>downloadBitmap</b> method that we introduced at the beginning of this article. <br><br>  <b>onPostExecute is</b> launched on the called UI thread when the task is completed.  It takes the resulting image as a parameter associated with <b>imageView</b> from <b>download</b> and stored in <b>BitmapDownloaderTask</b> .  Remember that <b>imageView</b> is stored as <b>WeakReference</b> , so in the process of loading it will not hurt to clear it from the collected garbage.  This explains why we need to make sure that both the links and <b>imageView</b> have a non-zero value (that is, they were not compiled) before using them in <b>onPostExecute</b> . <br><br>  This example shows a simplified use of <b>AsyncTask</b> , and if you try this method, you will see that these few lines of code significantly increase the performance in <b>ListView</b> , which will now scroll smoothly. <br><br>  However, the specific <b>ListView</b> behavior causes a problem in our implementation.  Moreover, for efficiency reasons, <b>ListView</b> recycles images that appear on the screen during scrolling.  If one object is skipped, it will be used by <b>imageView</b> repeatedly.  Another time, the pictogram is displayed correctly at boot time, and is replaced with an image after the download.  But what is the problem?  As with most parallel applications, the whole problem is streamlined.  In our case there is no guarantee that the download of tasks will end in the same order in which the download began.  The result may be such that the displayed image will refer to the previous object in the list, since  it took longer to load.  It is not a question if the images you downloaded are linked once, and <b>ImageViews are</b> set for all, but let's fix this in the general case when they are used as a list. <br><br><h3>  Concurrency control </h3><br><br>  To solve this problem, we need to remember the order of the start of downloads, since the last download started is the most effective for displaying (?).  Indeed, it is enough for each <b>ImageView to</b> remember its latest download.  We will set this additional information using a special <b>Drawable</b> subclass that will communicate with the <b>ImageView</b> while it is loading.  Here is the code of our <b>DownloadedDrawable</b> class: <br><br><blockquote> <code><font color="black"><font color="#0000ff">static</font> <font color="#0000ff">class</font> DownloadedDrawable extends ColorDrawable { <br> <font color="#0000ff">private</font> final WeakReference&lt;BitmapDownloaderTask&gt; bitmapDownloaderTaskReference; <br> <font color="#0000ff">public</font> DownloadedDrawable(BitmapDownloaderTask bitmapDownloaderTask) { <br> super(Color.BLACK); <br> bitmapDownloaderTaskReference = <br> <font color="#0000ff">new</font> WeakReference&lt;BitmapDownloaderTask&gt;(bitmapDownloaderTask); <br> } <br> <font color="#0000ff">public</font> BitmapDownloaderTask getBitmapDownloaderTask() { <br> <font color="#0000ff">return</font> bitmapDownloaderTaskReference. <font color="#0000ff">get</font> (); <br> } <br> } <br></font></code> </blockquote><br><br>  This is an implementation using <b>ColorDrawable</b> , the result of which in <b>ImageView</b> will be a black screen when loading.  You can use the ‚Äúloading in process‚Äù image to inform the user.  Again, note the use of <b>WeakReference</b> to reduce dependencies. <br><br>  Let's change our code to take into account the new class.  First, the <b>download</b> method must create an instance of this class, and associate it with <b>imageView</b> . <br><br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">void</font> download( <font color="#2B91AF">String</font> url, ImageView imageView) { <br> <font color="#0000ff">if</font> (cancelPotentialDownload(url, imageView)) { <br> BitmapDownloaderTask task = <font color="#0000ff">new</font> BitmapDownloaderTask(imageView); <br> DownloadedDrawable downloadedDrawable = <font color="#0000ff">new</font> DownloadedDrawable(task); <br> imageView.setImageDrawable(downloadedDrawable); <br> task.execute(url, cookie); <br> } <br> }</font></code> </blockquote> <br><br>  The <b>cancelPotentialDownload</b> method stops possible <b>imageView</b> downloads that will start soon.  Please note that this is not enough to ensure that the newest downloads are always displayed, since the task can be completed and waiting for its <b>onPostExecute</b> method, which can only be completed after the download. <br><br><blockquote> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">static</font> boolean cancelPotentialDownload( <font color="#2B91AF">String</font> url, ImageView imageView) { <br> BitmapDownloaderTask bitmapDownloaderTask = getBitmapDownloaderTask(imageView); <br> <br> <font color="#0000ff">if</font> (bitmapDownloaderTask != <font color="#0000ff">null</font> ) { <br> <font color="#2B91AF">String</font> bitmapUrl = bitmapDownloaderTask.url; <br> <font color="#0000ff">if</font> ((bitmapUrl == <font color="#0000ff">null</font> ) || (!bitmapUrl.equals(url))) { <br> bitmapDownloaderTask.cancel( <font color="#0000ff">true</font> ); <br> } <font color="#0000ff">else</font> { <br> <font color="#008000">// The same URL is already being downloaded.</font> <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> }</font></code> </blockquote> <br><br>  cancelPotentialDownload uses the <b>cancel</b> method from the <b>AsyncTask</b> class to stop active downloads.  It returns <b>true</b> most of the time, so the download can be started in <b>download</b> .  The only case in which we do not want this is when the download comes from the same URL, then we let it end.  Remember that with this implementation, if the <b>ImageView has</b> garbage collected, the downloads associated with it will not stop.  <b>RecyclerListener</b> must be used for this. <br><br>  This method uses the <b>getBitmapDownloaderTask</b> helper function: <br><br><blockquote> <code><font color="black"><font color="#0000ff">private</font> <font color="#0000ff">static</font> BitmapDownloaderTask getBitmapDownloaderTask(ImageView imageView) { <br> <font color="#0000ff">if</font> (imageView != <font color="#0000ff">null</font> ) { <br> Drawable drawable = imageView.getDrawable(); <br> <font color="#0000ff">if</font> (drawable instanceof DownloadedDrawable) { <br> DownloadedDrawable downloadedDrawable = (DownloadedDrawable)drawable; <br> <font color="#0000ff">return</font> downloadedDrawable.getBitmapDownloaderTask(); <br> } <br> } <br> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> }</font></code> </blockquote> <br><br>  Finally, <b>onPostExecute</b> should be modified so that it associates icons only if the <b>ImageView</b> is still associated with this particular loading process. <br><br><blockquote> <code><font color="black"><font color="#0000ff">if</font> (imageViewReference != <font color="#0000ff">null</font> ) { <br> ImageView imageView = imageViewReference. <font color="#0000ff">get</font> (); <br> BitmapDownloaderTask bitmapDownloaderTask = getBitmapDownloaderTask(imageView); <br> <font color="#008000">// Change bitmap only if this process is still associated with it</font> <br> <font color="#0000ff">if</font> ( <font color="#0000ff">this</font> == bitmapDownloaderTask) { <br> imageView.setImageBitmap(bitmap); <br> } <br> }</font></code> </blockquote> <br><br>  With these modifications, our <b>ImageDownloader</b> class now provides the basic services we expected from it.  Feel free to use it, or an asynchronous template that provides the flexibility of your applications. <br><br><h3>  Demonstration </h3><br><br>  The source code of this application <a href="http://code.google.com/p/android-imagedownloader/">is available on Google Code</a> .  You can switch between three different implementations described in this article.  Remember that the cache size was limited to ten images in order to better demonstrate how different methods work. <br><br><img src="http://1.bp.blogspot.com/_GTM_W5mVPTU/TETLoIzCOaI/AAAAAAAAAIU/1_u5-WwQT_I/s1600/thr.png" alt="image"><br><br><h3>  For the future </h3><br><br>  This code has been simplified in order to focus your attention on concurrency and many other functions that are missing from our implementation.  The <b>ImageDownloader</b> class will benefit from the cache, especially if used in conjunction with a <b>ListView</b> , which will most likely display the same image as many times as the user will use to scroll the screen up and down.  Also, if necessary, you can add thumbnails and resize images. <br><br>  Download errors and timeouts are correctly displayed in our implementation, it will simply generate an empty picture in this case.  If you want, you can show any image that reports an error. <br><br>  Our HTTP request is very simple.  You can add parameters or connect cookies that some sites require. <br><br>  The <code>AsyncTask</code> class used in this article is really a very convenient way to reduce user interface load.  You can also use the <code>Handler</code> class to more finely control actions, such as controlling the total number of parallel downloads. <br><br>  <b>UPD.</b>  Thanks for the comments, corrected. </div><p>Source: <a href="https://habr.com/ru/post/99631/">https://habr.com/ru/post/99631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99618/index.html">IPad reading and editing</a></li>
<li><a href="../99619/index.html">Get rid of subfolders in Applications</a></li>
<li><a href="../99620/index.html">Starcraft II Gear by Razer</a></li>
<li><a href="../99623/index.html">Higher education 2</a></li>
<li><a href="../99625/index.html">LauncherPro Plus - HTC Sense replacement</a></li>
<li><a href="../99633/index.html">In a new way</a></li>
<li><a href="../99635/index.html">Why is Jabber Spam Free?</a></li>
<li><a href="../99636/index.html">Convenient callback</a></li>
<li><a href="../99637/index.html">10 ways to store your wiring</a></li>
<li><a href="../99640/index.html">Bubble Engine - plugin for jQuery. Bubble machine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>