<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Backlit editor. Problems and Solutions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most of the audience Habra regularly writes code. In a text editor or IDE. And no matter how many windows and menus are in it, the heart of any editor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Backlit editor. Problems and Solutions</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/6bb/381/e8c/6bb381e8c73e13c35a2a536affdb8206.png" alt="image" align="left"><br>  Most of the audience Habra regularly writes code.  In a text editor or IDE.  And no matter how many windows and menus are in it, the heart of any editor is the component (widget) that edits and highlights the code. <br><br>  More than a year ago on Habr√© there was a cycle of articles from the <a href="http://habrahabr.ru/users/namespace/" class="user_link">namespace</a> about the QScintilla component ( <a href="http://habrahabr.ru/post/144411/">1</a> , <a href="http://habrahabr.ru/post/144714/">2</a> , <a href="http://habrahabr.ru/post/144855/">3</a> ), and my article with its <a href="http://habrahabr.ru/post/144848/">criticism</a> .  It turned out some understatement.  It is clear that everything is bad, but it is not clear what to do. <br><br>  Now I wrote my <s>bike</s> component called Qutepart, and the cycle has a sequel. <br>  This article will tell about the syntax highlighting in my project: what problems arose and how they were solved.  It is about approaches, and not about the specifics of a specific GUI-toolkit.  If it is interesting to look under the hood of a text editor, welcome under the cat. <br><a name="habracut"></a><br>  At once I will make a reservation that this is not a fundamental scientific article.  This is my experience.  It will be very interesting to read in the comments about alternative approaches and solutions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Motivation </h5><br>  I make a text editor in the spirit of vim and emacs.  Universal, cross-platform, extensible, focused on advanced users.  But with a slightly more intuitive and modern GUI on <a href="http://www.riverbankcomputing.com/software/pyqt/intro">PyQt</a> .  And for that, I need a code editor. <br>  There were only 2 options: QScintilla and katepart. <br>  I initially used QScintilla, but because of the flaws listed <a href="http://habrahabr.ru/post/144848/">here</a> , I decided to give it up. <br>  <a href="http://kate-editor.org/about-katepart/">katepart is</a> very good, but does not like what depends on the KDE libraries.  And having them in dependencies is not very convenient, especially for Windows and MacOS. <br><br><h5>  Parsing code </h5><br>  My project is not focused on any particular technology, I want to highlight a lot of languages.  More than I am able to master myself.  Therefore, it was decided to use the existing database of syntax descriptions from katepart. <br><br>  For each of the supported programming languages ‚Äã‚Äãin katepart there is a <a href="http://kate-editor.org/2005/03/24/writing-a-syntax-highlighting-file/">Highlight Definition</a> - an XML file describing the syntax and highlighting. <br>  Highlight Definition describes something like a finite state machine.  The machine sequentially parses the text, changing its state - ‚ÄúContext‚Äù.  Each of the contexts has a set of rules according to which it is necessary to switch to another context.  The automaton remembers from which state it has moved to the current one, and can return to previous contexts (the stack of contexts). <br>  Example: C ++.  In the context, the <i>code</i> is a rule: <i>if the character "meets" - go to the context "string"</i> . The context "string" highlights the characters in red and supports the rule: <i>if the character "meets" - return to the previous context</i> . <br>  For each of the contexts, the style by which it highlights the text is set. <br><br>  The system is very convenient and versatile.  The file format is well documented.  Perhaps that is why katepart highlights about 2 hundred languages ‚Äã‚Äãand formats. <br>  The downside, in my opinion, is only that the interpreter, which parses the code based on Syntax Definition, will in most cases be worse in performance than a parser for a specific programming language. <br><br><h5>  Optimization </h5><br><img src="https://habrastorage.org/storage2/df8/65f/0cd/df865f0cd239e5ff19036f148f50abe7.png" align="right"><br>  When I wrote syntax highlighting, there was no limit to my joy.  Everything works, everything is beautiful.  All 59 files in different languages ‚Äã‚Äãfrom the katepart collection look right and open quickly.  Hooray!  Who said Python is a slow language ?! <br>  And then I tried to open a large file.  Really big.  And <s>suddenly</s> it turned out that my parser is not so fast.  I had to take on the optimization. <br><br>  A couple of hours with a profiler accelerated the backlight several times.  But it still worked too slowly.  And the space for optimization has been almost exhausted.  It was possible to speed up the parser by a couple of tens of percent due to the terribly confusing code, but such weather optimization does not. <br><br>  I began to learn how to write modules in C. It turned out to be not at all difficult, Python for extensions is very friendly. <br>  In the process of writing the parser, a problem arose: there are no regular expressions in C.  And I really didn‚Äôt want to connect dependencies.  The problem was solved due to the fact that the interaction of C-Python works in 2 directions.  Python calls C for parsing, and from C a Python function is jerked to check the regular expression. <br><br>  When I started testing the parser with the extension, it turned out that the performance is not significantly different from the version in Python.  I took the profiler again and went to look for the problem. <br>  It turned out that 90% of the time, my parser calls Python to check regular expressions.  Well, the hack failed.  I had to use an external library.  So the component has a single dependency - a regular expression processing library on C <a href="http://pcre.org/">pcre</a> .  With her, the performance was quite acceptable (the numbers will be lower). <br><br>  As a result, I was not disappointed in the expediency of using Python.  The C parser is about 1/3 of the code base of my component.  I think that in terms of labor costs such a hybrid version turned out to be easier than a C ++ solution. <br><br><h5>  Asynchronous backlight </h5><br>  Most text files are rather small in size.  But sometimes I had to edit the source, in which more than 300K lines.  No matter how cool the parser developer is, and how quick his language is, the final file will be longer to understand than the user agrees to wait. <br><br>  katepart highlights code in a GUI stream.  And it does it lazily - it highlights as much as it needs to be drawn on the screen.  This approach works very well if the file is opened at the beginning.  However, if you jump to the end of a large file, the GUI just hangs.  I did not accept this approach. <br><br><img src="https://habrastorage.org/storage2/6d1/fc0/af3/6d1fc0af37cd85eea7b28c7f8f044ff8.png" align="right"><br>  vim and emacs, if necessary, draw the end of a large file and parse the text from the middle.  The approach is good because it allows not to block the GUI for a long time when highlighting.  But not everything is so simple.  Programming languages ‚Äã‚Äãare sequenced.  For example, in order to correctly handle the end character of a multi-line comment, you need to know whether the comment began in the previous line.  It turns out that in some cases the parsing from the middle will produce the wrong highlighting (as in the screenshot from vim). <br><br>  Now, when the increase in clock speeds has shifted to an increase in the number of cores, it is often relevant to optimize the calculations due to the separation by cores.  But even here problems arise, and not only because the file needs to be parsed sequentially. <br>  The user is constantly editing the code.  The GUI thread handles keystrokes and changes the document.  If the document is parsed and highlighted in the streams, the changes need to be synchronized.  The Qt toolkit is not everywhere focused on multithreading, I have not found a way to reliably synchronize access to the document.  It was necessary to refuse threads. <br><br>  As a result of the experiments, I got the following solution: the file is parsed and highlighted in the GUI stream by timer.  The timer works 20 milliseconds, then returns control to the main loop to process user actions, then it is called again ... If the user opened a huge file and immediately jumped to its end, the file is displayed, but without illumination. <br>  The code can be edited, and the backlight will appear a little later. <br><br><h5>  Incremental backlight </h5><br>  When a user edits a code, the text should be highlighted again from the place being edited, not from the beginning.  And, as a rule, one or several lines change. <br><img src="https://habrastorage.org/storage2/26a/2f0/79e/26a2f079e88dfeb6c757f38de64947c2.png"><br>  In the process of parsing, a block of metadata with the state of the parser is attached to each line of the file.  If the text has been modified, metadata is used to begin parsing from a specific line. <br>  The incremental parsing continues until a string is found whose metadata has not changed after the new parsing. <br><br><h5>  Performance comparison </h5><br>  Comparison of the performance of the backlight is not a thankful business.  It depends on many factors: hardware, software versions, language, content of a specific file, phase of the moon, ... <br>  However, without it, the article would not be complete.  Therefore, it is necessary to add a section. <br><div class="spoiler">  <b class="spoiler_title">Denial of responsibility</b> <div class="spoiler_text">  As mentioned above, performance depends on many factors, and in other circumstances, the picture may be completely different. <br>  This section is not the main purpose of the article.  Measurements were made only on one file in one language, very superficially.  Figures, observations and conclusions may contain gross errors. <br>  Therefore, the measurement method is not published;  I propose to assume that the information below, I invented myself exclusively for the entertainment of the Habr audience. <br>  The information given in no way can be used to conclude that the text editor X is better than the text editor Y. <br></div></div><br>  I opened a large C ++ file (364121 line) in several editors that are interesting to me, and collected my observations into this table. <br><table border="1"><tbody><tr><th>  Component or editor </th><th>  Time to highlight the entire file </th><th>  Blocks GUI </th><th>  Backlight problems </th></tr><tr><td>  Qutepart </td><td>  44 seconds </td><td>  Never </td><td>  Open file 3 seconds </td></tr><tr><td>  katepart </td><td>  Was killed after 6 minutes </td><td>  While not highlight as much as you want to display </td><td></td></tr><tr><td>  QScintilla </td><td>  3 seconds </td><td>  Never </td><td> Brakes when editing </td></tr><tr><td>  Scintilla </td><td>  3 seconds </td><td>  Never </td><td>  Brakes when editing </td></tr><tr><td>  Sublime text </td><td>  23 seconds </td><td>  When editing, until it updates all the changed backlight </td><td></td></tr><tr><td>  gedit </td><td>  8 seconds </td><td>  Never </td><td>  Brakes when editing </td></tr><tr><td>  Qt creator </td><td>  20 seconds </td><td>  When editing, hangs until it updates all the changed backlight </td><td></td></tr><tr><td>  Ninja IDE </td><td>  14 seconds </td><td>  When opening </td><td>  Highlighted only the first 51 lines.  Terribly slow when editing. </td></tr><tr><td>  vim </td><td>  Instantly </td><td>  Never </td><td>  Parsit file from the middle, in some cases shows the wrong result. </td></tr><tr><td>  emacs </td><td>  Instantly </td><td>  Never </td><td>  Parsit file from the middle, in some cases shows the wrong result.  It is hung up for about a minute when rewinding up. </td></tr></tbody></table>  <a href="http://goo.gl/Tmtpzc">Detailed version of the table</a> <br>  As you can see, the Qutepart is the slowest to highlight the text.  This is natural, since it uses an interpreted language, a bunch of Python-Qt, and interpreted syntax definitions in the form of XML. <br>  On the other hand, high-level language and technology allow us to highlight many languages, not to block GUI and not to show artifacts. <br>  When working with real files in the absolute majority of cases, the file is opened already highlighted, and when editing, the user does not see how the backlight is updated.  Therefore, the current state of affairs suits me and I have refused further optimization. <br><br><h5>  And what happened? </h5><br><img src="https://habrastorage.org/storage2/d25/87a/120/d2587a1206357246e4172df4fb99121a.png" align="right"><br>  I have a component for editing the <a href="https://github.com/hlamer/qutepart">Qutepart</a> code and a text editor based on it, <a href="http://enki-editor.org/">Enki</a> . <br>  The component depends on PyQt and pcre.  Requires building an extension module for C. For small files, you can do without the extension and without pcre. <br>  Syntax Definition files and code alignment algorithms are borrowed from katepart. <br>  Like the katepart, the project is available under the LGPL. <br><br>  Today I released the first version of Qutepart and Enki based on it, because I decided that the current version is already better than the QScintilla version.  Functionality is not much.  TODO-list is big.  It is periodically updated due to the wishes of users and becomes less due to the features made. <br><br>  I will be glad to get feedback from the Habra community! </div><p>Source: <a href="https://habr.com/ru/post/188144/">https://habr.com/ru/post/188144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188132/index.html">Cross-promotion of Android applications using the AppFlood network</a></li>
<li><a href="../188136/index.html">Learn PHP programming. Introductory</a></li>
<li><a href="../188138/index.html">Want to create your own mobile app?</a></li>
<li><a href="../188140/index.html">Space Race of the USSR and the USA</a></li>
<li><a href="../188142/index.html">Samsung S4 Google Edition (GT-I9505G) - review and purchase</a></li>
<li><a href="../188146/index.html">Google offers to start developing applications for Google Glass before the release of the Glass Development Kit</a></li>
<li><a href="../188150/index.html">Proper adaptive alignment of the site header</a></li>
<li><a href="../188152/index.html">Hash function Stribog or in the city of the new sheriff</a></li>
<li><a href="../188154/index.html">Discovery of highly porous material</a></li>
<li><a href="../188156/index.html">The digest of interesting news and materials from the world of PHP over the last two weeks, No. 22 (July 15, 2013 - July 28, 2013)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>