<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Evolution of the Analytical Infrastructure (continued)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article I told how and why we chose Vertica. In this part I will try to tell about the features of this unusual database, which we hav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Evolution of the Analytical Infrastructure (continued)</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/company/lifestreet/blog/146224/">previous article</a> I told how and why we chose Vertica.  In this part I will try to tell about the features of this unusual database, which we have been using for more than two years.  Writing this article took a little more time than I had planned, in particular due to the fact that it was necessary to tell on the one hand rather technically detailed, on the other - available, and not to violate the NDA.  As a result, I chose a compromise path: I will try to describe how Vertika works and works in principle, without touching on details. <br><br><h4>  Part 3. Vertica.  Simply Fast </h4><br>  <i>Simply Fast</i> - this vertical slogan did not originate from scratch.  She is really very fast.  Fast even with the ‚Äúboxed‚Äù settings that our tests showed during the selection of the solution.  During the migration of infrastructure, we have learned well how to make Vertic even faster and get maximum performance from it.  But first things first. <br><a name="habracut"></a><br>  To begin with, in Vertic there are not a few obvious things.  This may be surprising, but in Vertic, compared with many popular SQL databases, there is no: <br><ul><li>  stored procedures and nondetermined functions </li><li>  strict constraints - that is, you can add entries that violate constraints </li><li>  ability to delete columns </li><li>  indexes </li><li>  caches </li></ul><br>  If the availability of indices is compensated by a special way of storing data, then the remaining limitations are rather a forced necessity, a performance charge.  Some things are not very convenient to do, however, they are not a serious problem.  Separately, I will say about the lack of cache.  Vertika believes that the data volumes used for analysis (and these are terabytes) still cannot fit into the cache, so you should not do it.  Any request goes for data to disk.  There is some special area of ‚Äã‚Äãmemory that is used for intermediate data storage when writing or changing.  But as a rule, everything is on disk.  This somewhat contradicts the stable opinion that the slowest place in the database is the disk subsystem, and therefore we must strive to maximize the data in memory.  However. <br><br>  I will not discuss in detail the high performance of the download, in fact it is limited by the speed with which the disks manage to write, taking into account that the data is encoded to reduce the volume.  From the point of view of users, the performance of SQL queries is much more interesting.  Vertika is a specialized analytical database, so you don‚Äôt need to expect high performance from it for simple key queries.  It is fully disclosed on aggregative queries with filters that are typical for analytics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      High performance of analytical queries is provided in several ways of organizing physical storage of data: <br><ul><li>  Column-oriented data storage </li><li>  Optimized for certain types of queries, how to store columns </li><li>  The ability to have many physical views of the table optimized for different tasks </li><li>  Linear scaling of the cluster, MPP - massive parallel processing, that is, one request can be parallelized to all nodes of the cluster and to all processor cores simultaneously </li></ul><br><br>  Let us dwell on these methods and how they affect the performance in more detail. <br><br><h5>  Column-oriented storage </h5><br>  Usually the tables used in analytical tasks have tens and hundreds of columns characterizing some events (facts).  For example, sales statistics, statistics of calls or Internet connections, statistics of impressions and clicks, price dynamics of a market asset, etc.  Event characteristics are usually called dimensions (dimensions), and all together - a multidimensional data cube.  However, a person never analyzes all characteristics together, but considers, firstly, certain data slices, and secondly, projections onto a relatively small number of measurements.  (Decision theory specialists have long established that a person cannot analyze more than seven parameters at the same time).  Translating into a database language, a slice is a predicate or a where condition, and a projection on specific dimensions is aggregation with group by.  I simplify a little, there are still joins, there are analytical functions, etc., but these are already minor details.  In any case, of all the columns in the query, only a small number is used.  Therefore, the ability to read from the disk not all data, but only a part of it, significantly speeds up requests.  Physically, each column is stored in one or several relatively small files that never change (they are only created or deleted).  Therefore, reading a column is a very fast operation. <br><br><h5>  Specific Encoding Methods for Columns </h5><br>  Vertical column coding is used for two purposes: <br><ul><li>  reducing the size of data on the disk, thereby speeding up the read-write </li><li>  data placement on the disk so that it is convenient to filter, join, group, sort and other standard operations </li></ul><br><br>  As you remember, there are no indices in Vertic.  Instead, the data on the disk itself is ‚Äústacked‚Äù so that it can be quickly found.  The method of laying is called projection.  This is a hint that the projection may not be all columns, but we will return to this later.  Fast search is achieved using a combination of order (order by) and RLE (run length encoding, i.e. encoding the number of repetitions of a value in a row).  How RLE works with order is easiest to demonstrate with an example.  Imagine that there is a table with fields event_date, amount and another 100 fields.  There are 365 days a year. There are 1 billion records in each day.  If a typical request is to calculate money for a period (day, week, etc.), then we use RLE coding for event_date sorted by event_date.  If you sort the table by event_date, then in the event_date column there would be blocks of 1,000,000,000 of the same values.  RLE encoding means that physically there will only be the date and the number of repetitions (billion in our case) on the disk for the event_date column for each day.  In the year - 365 such records.  To lift from the disk and find one is a matter of seconds.  An entry with event_date contains something like a pointer to blocks with the remaining columns.  That is, to execute <code>‚Äúselect sum(amount) from t where event_date='2012-07-01'‚Äù</code> , it suffices to read the event_date column, and then the block or amount blocks that relate to the desired date.  It's very fast.  It is clear that there can be several ordered columns with RLE.  And it is also clear that this encoding method is best suited for columns where there are not very many unique values.  Which is typical for measurements. <br><br>  In general, this is somewhat similar to the index.  However, it works somewhat differently.  Imagine that we still have the column account_type (two values), and, say, department (five values).  And for them, too, often have to do a search.  In the case of the indexes would have to do separate, for each case.  And in Vertical, one projection is enough, which will work on searching through all three columns in any combination.  For example, with the following order: order by account_type, department, event_date.  All columns with RLE encoding.  It would seem that the search for event_date thus ‚Äúbreaks down‚Äù.  With the index on account_type, department, event_date, this is how it would be.  However, in the case of Vertic, the request for event_date will be executed only slightly slower than in the previous example ... Instead of one event_date block, you now have to read ten of them (2 account_type * 5 department), in each you find ‚Äúyour‚Äù event_date, and read the corresponding block amount.  Given the small size of event_date blocks due to RLE, this difference will be almost imperceptible. <br><br>  Hope the idea is clear.  Instead of an index, some columns on the disk are sorted and tricky connected.  This is usually illustrated with a picture or table, which, unfortunately, will not be here. <br><br>  In addition to searching, RLE encoding is also used to speed up sorting in group by, since the data is already located in such a way that it is sometimes not necessary to sort them.  As in the case of search, acceleration (the so-called pipelined group by) also occurs if the group by field is not in the first position in the projection. <br><br>  Vertika supports many ways of encoding columns, but the rest are used for more compact data placement, which, of course, also affects performance, but not first of all. <br><br>  In addition to Vertik's coding, traditional data partitioning is supported, and, accordingly, partition elimination or partition pruning, which in some cases makes it possible to further reduce the amount of data read from the disk. <br><br><h5>  Ability to have many physical views of the table optimized for different tasks </h5><br>  After reading the previous section, a reasonable suspicion may creep in that it is not always possible to dispense with a single physical representation of a table or a projection.  Since even the most sophisticated RLE / order-by does not help for all occasions.  Therefore, Vertika supports multiple projections for a single table.  At least one projection must contain all the columns (super-projection), and the rest can contain only a part.  This allows for different types of queries to build specific small projections.  The approach is a bit like materialized views.  But MVs are a ‚Äúside‚Äù lotion, and projections are the main and only way to store data.  Vertikovskim engineers managed to make the use of projections completely invisible to users.  They themselves are kept up to date, and the query optimizer correctly, as far as I can tell, chooses the most appropriate projection for each query. <br><br>  Having understood the basic principles, it is quite simple to independently develop the design of projections for specific tasks.  But for beginners or lazy complete with Vertic there is a special utility - DB Designer, which helps to generate the optimal design for a set of tables and test queries. <br><br>  All design changes can be made on a working database.  The existing super projection is used to create new ones.  This, of course, brings productivity, but with small projections (by the number of columns) it does not take much time. <br><br><h5>  Linear scaling.  MPP </h5><br>  Vertika almost linearly scaled by quantity: <br><ul><li>  drives </li><li>  cores </li><li>  servers </li></ul><br><br>  Scaling by servers is ensured by uniform ‚Äúsmearing‚Äù (segmentation) of projections by servers (nodes) of the cluster.  The segmentation method is specified by the developer - usually it is a hash function from one or several columns, ng can be an explicitly specified condition.  When a request is made, each of the servers performs operations on its own part, including all the cores for this, and then the results are combined on the server that initiated the request.  Nothing extraordinary except that it really works.  Not all tables make sense to segment.  Small dimension tables, which are almost always used only in joins, are usually not segmented, and a full copy is stored on each node.  For the same table, one projection can be segmented, while others are not.  All this allows very flexible configuration of the physical design for specific tasks, achieving optimal performance. <br><br>  In addition to performance, the cluster allows you to configure fault tolerance.  In this case, each data block is stored in two or more instances on different nodes of the cluster.  The level of duplication is called the K-safety level.  With standard level 1, a cluster experiences a loss from one (guaranteed) to floor (N / 1) nodes at best.  However, we have found that the performance of a cluster with one or several fallen nodes for some (not for all) types of requests may decrease significantly (by orders of magnitude).  Vertikovtsy confirmed that this is a bug and it will be fixed (already in Vertica 6), and we managed to change the requests so as not to fall for this problem.  By the way, the iron breaks down often, and we repeatedly had to live on the ‚Äúlame‚Äù cluster. <br><br>  Vertika supports transparent cluster expansion, and the process is fully manageable.  After adding new ones, you need to manually or automatically rebalance all the projections.  On the production system, it is better to do it manually in not-so-working hours, since rebalancing loads the disks heavily.  Starting with version 5, data is stored on disks in such a way that it is convenient to rebalance them (elastic cluster).  It is enough to move the blocks without recoding them.  It is much faster and less costly in performance. <br><br>  A little more practice.  We had to make several different copies of the database on Vertic on different hardware for different tasks (see my <a href="http://habrahabr.ru/company/lifestreet/blog/146249/">not very successful article</a> about backup and data cloning).  This happened due to the fact that with all the scalability, the cluster is relatively slow to perform short simple queries.  Probably, network delays and the need for an extra ‚Äúpass‚Äù to combine the results from different nodes have an effect.  The strength of a cluster is revealed when a lot of data is actually required to execute a query, a large amount of sorting, etc. <br><br><h5>  Vertic extensions </h5><br>  Vertika is one of the first manufacturers of RDBMS to offer integration with Hadup.  Therefore, it was natural to try the same task to count on Vertical and on Hadup.  In some ways, we followed in the footsteps of the article <a href="http://www.cse.nd.edu/~dthain/courses/cse598z/spring2010/benchmarks-sigmod09.pdf">‚ÄúA Comparison of Approaches to Large-Scale Data Analysis‚Äù</a> .  For the experiment was used the real task of counting unique visitors for a number of measurements.  It should be noted that the vertical adapter is not very fast, so we tested both through the adapter and through data storage first in HDFS. <br><br>  We tried several implementations for this task.  Test scenario - counting the number of unique visitors, broken down by country and some other measurements.  The volume of test data is about 300 million records, in which 60-70 million are unique.  We intentionally did not use a cluster, since both Vertika and Hadup are scaled almost linearly, and the results of a single-server experiment would be sufficient.  It is clear that Hadup on one server in reality, there is no sense to use much.  The locations were as follows: <br><ul><li>  Google Big Query is the fastest, the query was executed in a couple of minutes.  I had to refuse, after the Google users wanted a lot of money for their service (it turned out several hundred dollars per request).  Here we used md5 visitor identifier;  otherwise, 8-byte int.  That is, GBQ could be even faster.  A separate problem is data loading. </li><li>  Vertica is a standalone server (not a cluster) on a good hardware, which was used only for this task.  The request is about 15 minutes.  The task could be quite easy to parallelize if there was such a need.  Speed ‚Äã‚Äãsuited us. </li><li>  1-thread Plain Java.  2 hours.  Single Pass and HashMap. </li><li>  Hadoop (not a cluster).  Request for Pig.  In the forehead about 8-10 hours.  With data storage locally and loading of all cores - 2 hours (that is, comparable to a single-stream Java application).  Probably, expansion to a cluster would give a linear or close to linear increase.  But the difference with Vertic is still very big. </li></ul><br><br>  As a result of this experiment, which is quite a side for us, we were convinced that integration works, and Hadoop, as expected, is rather slow.  The advantage of writing queries directly to Pig / Hive is rather dubious, and it is completely absent when the same task can be expressed in terms of SQL.  Perhaps we still have tasks that require a full-fledged MapReduce. <br><br>  Hadoop is not the only way to extend the functionality of Vertika.  Vertika allows you to write UDF in C ++, including its aggregate and analytical functions, and in the latest version it offers integration with the R. language. We have tried to integrate with R before (and even as an interesting exercise with J), solving problems complex in terms of SQL.  ODBC or our own REST service was used for this.  Now this integration is even more simplified. <br><br><h5>  Conclusion </h5><br>  Currently Vertika has been working in production for more than a year and a half.  We have both single-server and cluster systems.  Vertika proved to be a very reliable database, we have never had any data loss or failure due to a database.  There were errors in one of the first versions, which led to incorrect results of some queries, but they were quickly corrected.  There were performance problems, especially on the ‚Äúchrome‚Äù cluster, but they too were solved.  Currently, we load into our vertices about a billion facts per day (and on one of the servers - 5 billion), which are aggregated into a couple of hundred million records in different aggregates.  Vertika performs about 10 thousand user requests per day, and approximately twice the number of requests from runtime systems, monitoring and other internal robots.  Most user requests, usually requesting statistics for days or weeks, are performed in 5‚Äì10 seconds, and runtime (fairly simple) 1.5‚Äì2 seconds.  This is not an OLTP database, it is an analytics, so these response times are quite satisfactory.  However, now we are migrating to a more powerful cluster, which reduces query execution time by an average of 3 times. <br><br>  But time does not stand still, we think about the need to have something like multi-tier datawarehouse or in-memory OLAP.  But more about that in the next article. <br><br>  PS July 11th I can answer any Vertical questions on our meeting in Moscow: <a href="http://habrahabr.ru/events/836/">habrahabr.ru/events/836</a> <br></div><p>Source: <a href="https://habr.com/ru/post/147254/">https://habr.com/ru/post/147254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147243/index.html">Free ways to promote Android applications</a></li>
<li><a href="../147244/index.html">Contrast and durable marker board</a></li>
<li><a href="../147250/index.html">Where I am? Where am I? Or how users are guided</a></li>
<li><a href="../147251/index.html">Feature-donation driven development</a></li>
<li><a href="../147253/index.html">Testing Digium phones with AsteriskNow distribution</a></li>
<li><a href="../147255/index.html">Keyboard Shortcuts with Javascript</a></li>
<li><a href="../147257/index.html">PHP is much better than you think.</a></li>
<li><a href="../147258/index.html">Bitcoin and Futures Trading Basics</a></li>
<li><a href="../147259/index.html">Thermometer reading - via the web interface on the router</a></li>
<li><a href="../147261/index.html">Amazon plans to release a smartphone?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>