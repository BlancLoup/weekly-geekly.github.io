<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data synchronization in real-time applications with Theron</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes I draw myself a graph of how the architecture of modern systems should look and find those aspects of the development process that can be im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data synchronization in real-time applications with Theron</h1><div class="post__text post__text-html js-mediator-article">  Sometimes I draw myself a graph of how the architecture of modern systems should look and find those aspects of the development process that can be improved and those practices that can be applied to improve these processes.  After another such iteration, I was once again convinced that there are amazing frameworks and methodologies for developing both server and client parts, but the synchronization of data between the client, server and database does not work in the way that modern realities require: fast response to changes in the system state, distribution and asynchronous processing of data, reuse of previously processed data. <br><br>  In recent years, requirements for modern applications and methods for their development have changed significantly.  Most of these applications use an asynchronous model consisting of many loosely coupled components (microservices).  Users want the application to work smoothly and always be up to date (data should be synchronized at any time), in other words, users feel more comfortable when they don‚Äôt need to click the Refresh button every time or reload the application completely, if something went wrong.  Under the cut there is a little theory and practice and a full-fledged open source application with React, Redux / Saga, Node, TypeScript and our project Theron. <br><br><img src="https://habrastorage.org/files/1b7/d50/b1a/1b7d50b1af2e4de0ac6f4b8f29ed3f05.jpg" alt="image"><br>  <i>Rick and Morty.</i>  <i>Rick opens many portals.</i> <br><a name="habracut"></a><br>  I used various services to synchronize and store real-time data, most of which are mentioned in <a href="https://habrahabr.ru/post/277979">this article</a> .  But every time the application developed into a more complex product, it became obvious that the system depended too much on one service provider and did not have the necessary flexibility that the creation of its micro-architecture with a multitude of diversified satellite services gives it ( SQL and NoSQL) and writing code, instead of designers and control panels BaaS.  Such an approach is indeed more complicated at the initial stage of prototype development, but it pays for itself in the future. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The result of my research was Theron.  <a href="https://therondb.com/">Theron</a> is a service for creating modern real-time applications.  Theron‚Äôs reactive data repository continuously transmits changes to the database based on a request to it.  In just more than four months, we have implemented a basic architecture with a small team of two developers, the main criteria of which are: <br><br><ul><li>  The rapid creation of new applications and painless migration of existing ones on Theron. </li><li>  The use of modern practices in the creation of asynchronous, distributed and fault-tolerant systems and the isomorphism of system components. </li><li>  Distributed low-level integration with databases such as Postgres and Mongo. </li><li>  Easy integration with modern frameworks such as React, Angular and their friends: ReactiveX, Redux etc. </li><li>  Focus on solving the problem of data synchronization, rather than providing a complete development stack and the subsequent " <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BA%25D0%25B0_%25D0%25BA_%25D0%25BF%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D1%2589%25D0%25B8%25D0%25BA%25D1%2583">locking vendor</a> ". </li><li>  The basic application logic (including authentication and access rights) should be implemented by developers on their side. </li></ul><br><h3>  Reactive Channels </h3><br>  I liked the functional approach even when I met one of the oldest functional programming languages ‚Äã‚Äãfocused on symbolic calculations <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%2595%25D0%25A4%25D0%2590%25D0%259B">Refal</a> .  Later, without realizing it, I began to use the reactive programming paradigm, and, over time, most of my work was built on these approaches. <br><br>  Theron is based on <a href="http://reactivex.io/">ReactiveX</a> .  Theron's fundamental concept is reactive channels that provide a flexible way to broadcast data to different user segments.  Theron uses the classic <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B7%25D0%25B4%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C-%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%2587%25D0%25B8%25D0%25BA_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Pub / Sub design pattern</a> .  To create a new channel (unlimited amount) and streaming data, you just need to create a new subscription. <br><br>  After <a href="https://therondb.com/docs/guide/installing-theron.html">installation</a> , import Theron and create a new client: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Theron } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'theron'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> theron = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Theron(<span class="hljs-string"><span class="hljs-string">'https://therondb.com'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'YOUR_APP_NAME'</span></span> });</code> </pre> <br>  Creating a new client does not establish a new WebSocket connection and does not begin to synchronize data.  A connection is established only when a subscription is created, provided that there is no other active connection.  That is, in the context of reactive programming, the Theron client and the channels are <a href="">cold observable</a> objects. <br><br>  Create a new subscription: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> channel = theron.join(<span class="hljs-string"><span class="hljs-string">'the-world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = channel.subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(message.payload); }, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); }, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); } );</code> </pre><br>  When the channel is no longer needed - accomplish your goal: <br><br><pre> <code class="javascript hljs">subscription.unsubscribe();</code> </pre><br>  Sending data to clients subscribed to this channel from the server side (Node.js) is also simple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Theron } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'theron'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> theron = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Theron(<span class="hljs-string"><span class="hljs-string">'https://therondb.com'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'YOUR_APP_NAME'</span></span>, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: <span class="hljs-string"><span class="hljs-string">'YOUR_SECRET_KEY'</span></span> }); theron.publish(<span class="hljs-string"><span class="hljs-string">'the-world'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Greatings from Cybertron!'</span></span> }).subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); }, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); }, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); }, );</code> </pre><br>  Theron uses exponential backoff (enabled by default) when connection is lost or when <a href="https://therondb.com/docs/guide/error-handling.html">non-critical errors occur (English)</a> : errors when a repeated subscription to the channel is possible. <br><br>  The implementation of many algorithms in the framework of reactive programming is elegant and simple, for example, the exponential backoff in the Theron client library looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attemp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rescueChannel = channel.retryWhen(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errs</span></span></span><span class="hljs-function"> =&gt;</span></span> errs.switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.timer(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, attemp + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">500</span></span>).do(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> attemp++)) ).do(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> attemp = <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><h3>  Database Integration </h3><br>  As mentioned above, Theron is a reactive data repository: a change notification system that continuously transmits updates via secure channels for your application, based on the usual SQL query to the database.  Theron analyzes the database query and sends data artifacts that can be used to recreate the original data. <br><br><blockquote>  Theron is currently integrated with Postgres;  integration with Mongo in the development process. </blockquote><br>  Consider how it works on the example of the life cycle of a simple list consisting of the first three elements, ordered alphabetically: <br><br><img src="https://habrastorage.org/files/aaa/a3f/224/aaaa3f2243b2405ca469a1b47b3a9f06.png" alt="image"><br><br>  Before we continue, connect the database to Theron by entering data to access it in the control panel: <br><br><img src="https://habrastorage.org/files/59c/bc2/991/59cbc29913154c06af4646bd4af47904.jpg" alt="image"><br><br>  The internal structure of locking a database is a big topic for a separate article in the future.  Theron is a distributed system, so the pool of connections to the database is limited to the 10th (with the possibility of increasing to 20) by common connections. <br><br>  <b>1. Creating a new subscription</b> <br><br>  Theron works with SQL queries, so your server should not return the result of the query, but the original SQL query.  For example, in our case, the JSON response of the server might look like this: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">"SELECT * FROM todos ORDER BY name LIMIT 3"</span></span> }</code> </pre><br>  On the client side, we will begin translating the data for our SQL query by creating a new subscription: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Theron } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'theron'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> theron = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Theron(<span class="hljs-string"><span class="hljs-string">'https://therondb.com'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'YOUR_APP_NAME'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = theron.watch(<span class="hljs-string"><span class="hljs-string">'/todos'</span></span>).subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(action); <span class="hljs-comment"><span class="hljs-comment">//  Theron' }, err =&gt; { console.log(err); }, () =&gt; { console.log('complete'); } );</span></span></code> </pre><br>  Theron will send a GET request '/ todos' to your server, check the validity of the returned SQL query and start translating the initial instructions with the necessary data, if this query has not been previously cached on the client side. <br><br>  The <a href="https://therondb.com/docs/api/TheronRowArtefact.html">TheronRowArtefact</a> instruction is a regular JavaScript object with the `payload 'data itself and the` type` instruction type.  The main types of instructions: <br><br><ul><li>  ROW_ADDED - added new item. </li><li>  ROW_REMOVED - the item has been deleted. </li><li>  ROW_MOVED - the item has been changed. </li><li>  ROW_CHANGED - the item has been changed. </li><li>  BEGIN_TRANSACTION - new sync block. </li><li>  COMMIT_TRANSACTION - synchronization completed successfully. </li><li>  ROLLBACK_TRANSACTION - An error occurred during synchronization. </li></ul><br>  Suppose that several elements <b>A</b> , <b>B</b> , <b>C</b> already exist in the database.  Then the change in the state of the client can be represented as follows (on the left - it was, on the right - it became): <br><br><table><tbody><tr><th>  Id </th><th>  Name </th><th>  Id </th><th>  Name </th></tr><tr><td></td><td></td><td>  <font color="#449d44">one</font> </td><td>  <font color="#449d44">A</font> </td></tr><tr><td></td><td></td><td>  <font color="#449d44">2</font> </td><td>  <font color="#449d44">B</font> </td></tr><tr><td></td><td></td><td>  <font color="#449d44">3</font> </td><td>  <font color="#449d44">C</font> </td></tr></tbody></table><br>  Theron instructions for this state: <br><br><ol><li> <code>{ type: BEGIN_TRANSACTION }</code> </li> <li> <code>{ type: <font color="#449d44">ROW_ADDED</font> , payload: { row: { id: 1, name: 'A' }, prevRowId: null } }</code> </li> <li> <code>{ type: <font color="#449d44">ROW_ADDED</font> , payload: { row: { id: 2, name: 'B' }, prevRowId: 1 }</code> </li> <li> <code>{ type: <font color="#449d44">ROW_ADDED</font> , payload: { row: { id: 3, name: 'C' }, prevRowId: 2 } }</code> </li> <li> <code>{ type: BEGIN_TRANSACTION }</code> </li> </ol><br>  Each synchronization block starts and ends with the BEGIN_TRANSACTION and COMMIT_TRANSACTION instructions.  For the correct sorting of items on the client side, Theron additionally sends data about the previous item. <br><br>  <b>2. User renames A (1) to D (1)</b> <br><br>  Suppose the user renames <b>A (1)</b> to <b>D (1)</b> .  Since the SQL query arranges the elements in alphabetical order, the elements will be sorted, and the client state will change as follows: <br><table><tbody><tr><th>  Id </th><th>  Name </th><th>  Id </th><th>  Name </th></tr><tr><td>  one </td><td>  A </td><td>  <font color="#ec971f">2</font> </td><td>  <font color="#ec971f">B</font> </td></tr><tr><td>  2 </td><td>  B </td><td>  <font color="#ec971f">3</font> </td><td>  <font color="#ec971f">C</font> </td></tr><tr><td>  3 </td><td>  C </td><td>  <font color="#31b0d5">one</font> </td><td>  <font color="#31b0d5">D</font> </td></tr></tbody></table><br>  Theron instructions for this state: <br><br><ol><li> <code>{ type: BEGIN_TRANSACTION }</code> </li> <li> <code>{ type: <font color="#31b0d5">ROW_CHANGED</font> , payload: { row: { id: 1, name: 'D' }, prevRowId: 3 } }</code> </li> <li> <code>{ type: <font color="#ec971f">ROW_MOVED</font> , payload: { row: { id: 1, name: 'D' }, prevRowId: 3 } }</code> </li> <li> <code>{ type: <font color="#ec971f">ROW_MOVED</font> , payload: { row: { id: 2, name: 'B' }, prevRowId: null } }</code> </li> <li> <code>{ type: <font color="#ec971f">ROW_MOVED</font> , payload: { row: { id: 3, name: 'C' }, prevRowId: 2 } }</code> </li> <li> <code>{ type: COMMIT_TRANSACTION }</code> </li> </ol><br>  <b>3. User creates new item A (4)</b> <br><br>  Suppose a user creates a new item <b>A (4)</b> .  Since our SQL query limits the data to the first three elements, on the client side, the <b>D (1)</b> element will be deleted, and the client state will change as follows: <br><table><tbody><tr><th>  Id </th><th>  Name </th><th>  Id </th><th>  Name </th></tr><tr><td>  2 </td><td>  B </td><td>  <font color="#449d44">four</font> </td><td>  <font color="#449d44">A</font> </td></tr><tr><td>  3 </td><td>  C </td><td>  <font color="#ec971f">2</font> </td><td>  <font color="#ec971f">B</font> </td></tr><tr><td>  one </td><td>  D </td><td>  <font color="#ec971f">3</font> </td><td>  <font color="#ec971f">C</font> </td></tr><tr><td></td><td></td><td>  <font color="#c9302c"><s>one</s></font> </td><td>  <font color="#c9302c"><s>D</s></font> </td></tr></tbody></table><br>  Theron instructions for this state: <br><br><ul><li> <code>{ type: BEGIN_TRANSACTION }</code> </li> <li> <code>{ type: <font color="#449d44">ROW_ADDED</font> , payload: { row: { id: 4, name: 'A' }, prevRowId: null } }</code> </li> <li> <code>{ type: <font color="#ec971f">ROW_MOVED</font> , payload: { row: { id: 2, name: 'B' }, prevRowId: 4 } }</code> </li> <li> <code>{ type: <font color="#ec971f">ROW_MOVED</font> , payload: { row: { id: 3, name: 'C' }, prevRowId: 2 } }</code> </li> <li> <code>{ type: <font color="#c9302c">ROW_REMOVED</font> , payload: { row: { id: 1, name: 'D' }, prevRowId: 3 } }</code> </li> <li> <code>{ type: COMMIT_TRANSACTION }</code> </li> </ul><br>  <b>4. User deletes element D (1)</b> <br><br>  Suppose the user deletes the <b>D (1)</b> entry from the database.  In this case, Theron will not send new instructions, since this change in the database does not affect the data returned by our SQL query, and therefore does not affect the state of the client: <br><table><tbody><tr><th>  Id </th><th>  Name </th><th>  Id </th><th>  Name </th></tr><tr><td>  four </td><td>  A </td><td>  four </td><td>  A </td></tr><tr><td>  2 </td><td>  B </td><td>  2 </td><td>  B </td></tr><tr><td>  3 </td><td>  C </td><td>  3 </td><td>  C </td></tr></tbody></table><br>  <b>Client-side processing of instructions</b> <br><br>  Now, knowing how Theron works with data, we can implement logic to recreate the data on the client side.  The algorithm is quite simple: we will use the type of instruction and the metadata of the previous element for the correct positioning of the elements in the array.  In a real application, you need to use, for example, the <a href="https://facebook.github.io/immutable-js">Immutable.js</a> library for working with arrays and the <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">scan</a> operator as <a href="">an example</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ROW_ADDED, ROW_CHANGED, ROW_MOVED, ROW_REMOVED } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'theron'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> todos = []; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = theron.watch(<span class="hljs-string"><span class="hljs-string">'/todos'</span></span>).subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ROW_ADDED: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> index = nextIndexForRow(rows, action.prevRowId) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index !== <span class="hljs-number"><span class="hljs-number">-1</span></span>) { rows.splice(index, <span class="hljs-number"><span class="hljs-number">0</span></span>, action.row); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ROW_CHANGED: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> index = indexForRow(rows, action.row.id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index !== <span class="hljs-number"><span class="hljs-number">-1</span></span>) { rows[index] = action.row; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ROW_MOVED: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> index = indexForRow(rows, action.row.id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index !== <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> row = list.splice(curPos, <span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newIndex = nextIndexForRow(rows, action.prevRowId); rows.splice(newIndex, <span class="hljs-number"><span class="hljs-number">0</span></span>, row); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ROW_REMOVED: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> index = indexForRow(rows, action.row.id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index !== <span class="hljs-number"><span class="hljs-number">-1</span></span>) { list.splice(index, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); } ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexForRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rows, rowId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function"> =&gt;</span></span> row.id === rowId); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextIndexForRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rows, prevRowId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prevRowId === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> index = indexForRow(rows, prevRowId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows.length; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br><h3>  Time examples </h3><br>  Sometimes it is better to study, based on ready-made examples: therefore, here is the promised application published under the MIT license - <a href="https://github.com/therondb/figure">https://github.com/therondb/figure</a> .  Figure is a service for working with HTML forms in static sites;  The development strategy is React, Redux / Saga, Node, TypeScript and, of course, Theron.  For example, we use Figure to create a list of subscribers to our blog and documentation site ( <a href="">https://github.com/therondb/therondb.com</a> ): <br><br><img src="https://habrastorage.org/files/020/f83/630/020f836307d24011b5d964f7e2eb2d06.jpg" alt="image"><br><br><h3>  Conclusion </h3><br>  In addition to correcting a hypothetical ton of errors and the classic writing of client libraries for popular platforms, we are working on separating the reverse proxy server and the balancer into an independent component.  The idea is to create an API on the server side, which can be accessed both through regular HTTP requests and through a permanent WebSocket connection.  In the following article about Theron architecture I will write about it in more detail. <br><br>  Our team is small but energetic, and we love to experiment.  Theron is in active development: there are many ideas and points that need to be implemented and improved.  We will be happy to hear any criticism, take advice and discuss it constructively. </div><p>Source: <a href="https://habr.com/ru/post/303436/">https://habr.com/ru/post/303436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303422/index.html">Salary negotiations - how not to burn</a></li>
<li><a href="../303424/index.html">Errors and problems of the Big Three servers: part three. Ibm</a></li>
<li><a href="../303426/index.html">Debugging php functions using phpdbg, as an alternative to Xdebug via IDE</a></li>
<li><a href="../303428/index.html">New L4 Load Balancer with native SRV record service discovery and Docker API service Discovery</a></li>
<li><a href="../303430/index.html">Energy Efficiency Options from Coolan, MacroAir, AMCA International and Cradle</a></li>
<li><a href="../303438/index.html">Microsoft has published information about the implementation of VFS in the Linux subsystem on Windows 10</a></li>
<li><a href="../303442/index.html">We write an application for analyzing tweets in real-time mode in 30 minutes</a></li>
<li><a href="../303446/index.html">Let's see DNS</a></li>
<li><a href="../303448/index.html">Another 0day vulnerability found in Adobe Flash Player</a></li>
<li><a href="../303450/index.html">High-Density WiFi. Part 3: About technology. Part 4: About Money</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>