<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why NSURLSession is Better than NSURLConnection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="iOS 7 officially came out in September, then Apple provided developers with a new way to work with the network - NSURLSession. This is quite a fundame...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why NSURLSession is Better than NSURLConnection</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/776/4e6/a0f/7764e6a0f91b056b2fa19c3b39714585.png"><br><br>  iOS 7 officially came out in September, then Apple provided developers with a new way to work with the network - NSURLSession.  This is quite a fundamental thing, because if you need to support iOS 6 and below, parallelizing the code relative to the system version will be extremely problematic.  But nevertheless, time is ticking, and now, according to various data, from 75 to 85 percent of users switched to the latest iOS, so I would advise you to try the NSURLSession in the next project. <br><br>  As conceived by Apple, NSURLSession should change the NSURLConnection, and then the question really arises: ‚Äúwhy is all this necessary?‚Äù Because immediately, the advantages compared with NSURLConnection: <br><ol><li>  Loading and sending data in the background </li><li>  Ability to stop and continue downloading </li><li>  We can use blocks and delegates at the same time, for example, we use blocks to get data and handle errors, and the delegate method can be used to pass authentication. </li><li>  The session has a special configuration container in which you can put all the necessary properties for all tasks (requests) in the session, as well as, for example, headers for all requests in the session </li><li>  You can use private storage for cookies, caches and other things. </li><li>  We get a more rigorous and structured code, as opposed to a messy NSURLConnection set </li></ol><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will show that the new method is not at all scary and that it really should be used.  So let's get started, the key class is NSURLSession, as the name implies, it creates a certain session for downloading / uploading data via HTTP.  There are three types of session: <b>default</b> is what NSURLConnection used to do, <b>ephemeral</b> - nothing is cached in it and everything is stored in RAM (like a private browser mode), <b>download</b> - the result is presented as files. <br><br><h2>  NSURLSessionConfiguration </h2><br>  The session properties are controlled by the NSURLSessionConfiguration class, in which there are a huge number of parameters, in addition to the choice of session type: the ability to download via the mobile network, cookies, cache, proxy, security.  There is one interesting feature of discretionary - it allows you to give the download to the discretion of the system (when there is wi-fi and a lot of battery power). <br><br><h2>  NSURLSession </h2><br>  Having set the session configuration, we create the session itself, taking the configuration in the constructor.  We get the data in the usual two ways: set the delegate or catch the data in the completion block (about them later). <br><br><h2>  NSURLTask </h2><br>  It is a minimal task, that before this was an NSURLConnection.  The class itself is abstract, but it has 3 subclasses: NSURLSessionDataTask, NSURLSessionUploadTask (a subclass of the first) and NSURLSessionDownloadTask, however, they do not have their own constructor.  All of them are created by the session itself with or without a completion block (it is quite logical that in the first case the session delegate is not needed).  It all looks somewhat exotic: <br><pre><code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionDownloadTask</span></span> *downloadTask = [ourSession downloadTaskWithRequest:simpleNSURLRequest];</code> </pre> <br><br><h2>  Blocks and delegates </h2><br>  In general, the download process itself is very similar to working with NSURLConnection, quickly consider two ways to work with sessions. <br><br>  <b>Through delegates:</b> <br>  Sessions ask the delegate during creation. <br><pre> <code class="objectivec hljs">[<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> sessionWithConfiguration:config delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> delegateQueue:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>];</code> </pre> <br>  Then all delegate methods (including tasks) are called in the delegate. <br><br>  <b>Through the blocks:</b> <br>  It is enough to create Tasks using <br><pre> <code class="objectivec hljs"> -(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionDownloadTask</span></span> *)downloadTaskWithRequest:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span> *)request completionHandler:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^)(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *location, <span class="hljs-built_in"><span class="hljs-built_in">NSURLResponse</span></span> *response, <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error))completionHandler</code> </pre> <br>  Again, nothing new, all this is familiar to us from NSURLConnection -sendAsynchronousRequest: queue: completionHandler: <br>  In this case, we can add a delegate method to pass authentication if necessary. <br><br><h2>  Examples </h2><br>  Understood with the general scheme, we will postpone the theory, time to look at examples! <br><br><h5>  Stop / continue loading. </h5><br>  The whole scheme rather closely resembles the work through NSURLConnection, but, unlike it, we can simply cancel any download task.  Also, when canceled, the delegate method URLSession: task: didCompleteWithError: will be called, so that all the necessary UI manipulations can be performed there.  And you can not only cancel, but just stop. <br><pre> <code class="objectivec hljs"> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.resumableTask cancelByProducingResumeData:^(<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> *resumeData) { partialDownload = resumeData; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.resumableTask = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }]; <span class="hljs-comment"><span class="hljs-comment">//        if(partialDownload) { self.resumableTask = [inProcessSession downloadTaskWithResumeData:partialDownload]; } else { ... } [self.resumableTask resume];</span></span></code> </pre><br>  By stopping the task, you can save all the received data, and after that you can give it to the new download task. <br><br><h5>  Upload to file </h5><br>  Another thing that I would like to disassemble is download task.  Let me remind you, they allow the downloaded immediately put in the file. <br><br>  through the unit: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionConfiguration</span></span>* sessionConfig = [<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionConfiguration</span></span> defaultSessionConfiguration]; <span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *session = [<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> sessionWithConfiguration:sessionConfig]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>* downloadTaskURL = [<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> URLWithString:<span class="hljs-string"><span class="hljs-string">@"http://upload.wikimedia.org/wikipedia/commons/1/14/Proton_Zvezda_crop.jpg"</span></span>]; [[session downloadTaskWithURL: downloadTaskURL completionHandler:^(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *location, <span class="hljs-built_in"><span class="hljs-built_in">NSURLResponse</span></span> *response, <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error) { <span class="hljs-built_in"><span class="hljs-built_in">NSFileManager</span></span> *fileManager = [<span class="hljs-built_in"><span class="hljs-built_in">NSFileManager</span></span> defaultManager]; <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *urls = [fileManager URLsForDirectory:<span class="hljs-built_in"><span class="hljs-built_in">NSDocumentDirectory</span></span> inDomains:<span class="hljs-built_in"><span class="hljs-built_in">NSUserDomainMask</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *documentsDirectory = [urls objectAtIndex:<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *originalUrl = [<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> URLWithString:[downloadTaskURL lastPathComponent]]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *destinationUrl = [documentsDirectory URLByAppendingPathComponent:[originalUrl lastPathComponent]]; <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *fileManagerError; [fileManager removeItemAtURL:destinationUrl error:<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// ! [fileManager copyItemAtURL:location toURL:destinationUrl error:&amp;fileManagerError]; }] resume];</span></span></code> </pre><br><br>  via delegate method: <br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionConfiguration</span></span>* sessionConfig = [<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionConfiguration</span></span> defaultSessionConfiguration]; <span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *session = [<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> sessionWithConfiguration:sessionConfig delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> delegateQueue:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>* downloadTaskURL = [<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> URLWithString:<span class="hljs-string"><span class="hljs-string">@"http://upload.wikimedia.org/wikipedia/commons/1/14/Proton_Zvezda_crop.jpg"</span></span>]; [[session downloadTaskWithURL:downloadTaskURL] resume]; <span class="hljs-comment"><span class="hljs-comment">//    - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { //  }</span></span></code> </pre><br><br>  I must say that we get the address on our device to the location variable: <br>  file: /// private / var / mobile / Applications / {appUUID} /tmp/CFNetworkDownload_fileID.tmp, then save the file to a safer place, in the example file: /// var / mobile / Applications / {appUUID} / Documents /Proton_Zvezda_crop.jpg <br><br><h5>  We send a finite number of requests at once </h5><br>  Sometimes we need to limit the number of simultaneous requests, for example - 5. In this case, we just need to specify the maximum number of connections: <pre> <code class="objectivec hljs">sessionConfig.HTTPMaximumConnectionsPerHost = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Further there will be an example to try, it is better to pick up more files, I advise you also to simulate the download via 3g (Settings -&gt; Developer -&gt; Network link conditioner -&gt; Choose a profile -&gt; 3g -&gt; Enable) <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) methodForNSURLSession{ <span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionConfiguration</span></span> *sessionConfig = [<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionConfiguration</span></span> defaultSessionConfiguration]; _tasksArray = [[<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> alloc] init]; sessionConfig.HTTPMaximumConnectionsPerHost = <span class="hljs-number"><span class="hljs-number">5</span></span>; sessionConfig.timeoutIntervalForResource = <span class="hljs-number"><span class="hljs-number">0</span></span>; sessionConfig.timeoutIntervalForRequest = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span>* session = [<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> sessionWithConfiguration:sessionConfig delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> delegateQueue:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// download tasks // [self createDataTasksWithSession:session]; // data tasks [self createDownloadTasksWithSession:session]; } - (void) createDownloadTasksWithSession:(NSURLSession *)session{ for (int i = 0; i &lt; 10; i++) { NSURLSessionDownloadTask *sessionDownloadTask = [session downloadTaskWithURL: [NSURL URLWithString:@"https://discussions.apple.com/servlet/JiveServlet/showImage/2-20930244-204399/iPhone%2B5%2BProblem2.jpg"]]; [_tasksArray addObject:sessionDownloadTask]; [sessionDownloadTask addObserver:self forKeyPath:@"countOfBytesReceived" options:NSKeyValueObservingOptionOld context:nil]; [sessionDownloadTask resume]; } } - (void) createDataTasksWithSession:(NSURLSession *)session{ for (int i = 0; i &lt; 10; i++) { NSURLSessionDataTask *sessionDataTask = [session dataTaskWithURL: [NSURL URLWithString:@"https://discussions.apple.com/servlet/JiveServlet/showImage/2-20930244-204399/iPhone%2B5%2BProblem2.jpg"]]; [_tasksArray addObject:sessionDataTask]; [sessionDataTask addObserver:self forKeyPath:@"countOfBytesReceived" options:NSKeyValueObservingOptionOld context:nil]; [sessionDataTask resume]; } } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{ if([[change objectForKey:@"old"] integerValue] == 0){ NSLog(@"task %d: started", [_tasksArray indexOfObject: object]); } } - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{ NSLog(@"task %d: finished!", [_tasksArray indexOfObject:task]); }</span></span></code> </pre><br><br>  The example is quite simple and transparent, but I will focus your attention on one point: <br><pre> <code class="objectivec hljs">sessionConfig.timeoutIntervalForResource = <span class="hljs-number"><span class="hljs-number">0</span></span>; sessionConfig.timeoutIntervalForRequest = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  According to the documentation: <br>  timeoutIntervalForRequest - the time that is allotted for loading each task <br>  timeoutIntervalForResource - the time allotted for downloading all requests <br>  and here we have a problem, the fact is that at the moment when we start the task ([task resume]) the timeoutIntervalForRequest counter started ticking, and nobody cares that we have 100 tasks, and at the same time only 5 can work. the reason it turns out that the values ‚Äã‚Äãof these parameters must be the same, because the tasks that will be caused by the latter may end up without getting a data bit. <br><br>  Therefore, we have no choice but to set both variables to the same values, it is also possible to set it to 0, in this case the counter will go to infinity. <br><br>  Yes, of course, you can invent a bicycle and independently monitor the number of tasks, but you want the ‚Äúout of the box‚Äù option.  Here, in my opinion, Apple engineers are not completely thought out. <br><br><h5>  Download tracking </h5><br>  The download task has a special delegate method: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)URLSession:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *)session downloadTask:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionDownloadTask</span></span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> progress = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)totalBytesWritten / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)totalBytesExpectedToWrite; <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"download: %@ progress: %f"</span></span>, downloadTask, progress); <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_main_queue(), ^{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressView.progress = progress; }); }</code> *) session downloadTask: (NSURLSessionDownloadTask *) downloadTask didWriteData: (int64_t) bytesWritten totalBytesWritten: (int64_t) totalBytesWritten totalBytesExpectedToWrite: (int64_t) totalBytesExpectedToWrite <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)URLSession:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *)session downloadTask:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionDownloadTask</span></span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> progress = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)totalBytesWritten / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)totalBytesExpectedToWrite; <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"download: %@ progress: %f"</span></span>, downloadTask, progress); <span class="hljs-built_in"><span class="hljs-built_in">dispatch_async</span></span>(dispatch_get_main_queue(), ^{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.progressView.progress = progress; }); }</code> </pre><br>  For the rest of the tasks, you can use KVO as in the previous example. <br><br><h5>  Loading in the background </h5><br>  Well, in the end we will deal with the example of loading in the background, the example repeats the demo from wwdc'13 705. Personally, the demo shook me.  We start loading the picture, exit the application, come back - the picture is loaded and already laid out, and this can be seen even in the multitask menu (the one that by double pressing the home button).  But more than that, if we drop the application at the time of download, the download will end and everything will return as if nothing happened!  Moreover, after loading, our UI is updated right in the background, and the snapshot in the multitasking menu changes.  The only case where the download does not end is when the user himself kills the application, but there's nothing you can do, the owner is the master. <br><br>  Why does this ‚Äúmagic‚Äù work?  The thing is that when an application starts a background process, the system creates a daemon, which transfers data to the application.  It is logical, we need something that will live independently of the application.  For this reason, we are not afraid of either stopping or crashing the application.  After the download is complete, the daemon ‚Äúwakes up‚Äù the application, after which we can restore the session and get all the data.  Creating a new session with the old identifier will ‚Äúconnect‚Äù us to the existing background of the session. <br><br>  Now let's look at the main points, the test project itself can be <a href="https://github.com/AlloyDev/ADBackgroundDownloadExample">collected here</a> . <br><br>  First, in the singleton style, create a session: <br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *)backgroundSession{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *session = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">dispatch_once_t</span></span> onceToken; <span class="hljs-built_in"><span class="hljs-built_in">dispatch_once</span></span>(&amp;onceToken, ^{ <span class="hljs-comment"><span class="hljs-comment">//         ,      NSURLSessionConfiguration *config = [NSURLSessionConfiguration backgroundSessionConfiguration:@"com.dev.BackgroundDownloadTest.BackgroundSession"]; [config setAllowsCellularAccess:YES]; session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil]; }); return session; }</span></span></code> </pre><br>  We start the download (there should be no questions here): <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadTask = [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> backgroundSession] downloadTaskWithURL:[<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> URLWithString:<span class="hljs-string"><span class="hljs-string">@"https://discussions.apple.com/servlet/JiveServlet/showImage/2-20930244-204399/iPhone%2B5%2BProblem2.jpg"</span></span>]]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadTask resume];</code> </pre><br>  In the delegate method for the background task, save the image and display it: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)URLSession:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *)session downloadTask:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionDownloadTask</span></span> *)downloadTask didFinishDownloadingToURL:(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *)location { <span class="hljs-comment"><span class="hljs-comment">// save image //   //... // set image if (success) { dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = [UIImage imageWithContentsOfFile:[destinationPath path]]; [self.progressView setHidden:YES]; }); } }</span></span></code> </pre><br><br>  In the delegate method, to end all tasks, we catch the end of the load (in this case, both this and the previous methods will be called) <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)URLSession:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSession</span></span> *)session task:(<span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionTask</span></span> *)task didCompleteWithError:(<span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *)error { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"error: %@ - %@"</span></span>, task, error); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"success: %@"</span></span>, task); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadTask = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     [self callCompletionHandlerIfFinished]; }</span></span></code> </pre><br><br>  Now let's move to AppDelegate.m <br>  We need to catch messages from the system when the download is complete: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)application:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> *)application handleEventsForBackgroundURLSession:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)identifier completionHandler:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^)())completionHandler { <span class="hljs-comment"><span class="hljs-comment">//    ,    UILocalNotification* locNot = [[UILocalNotification alloc] init]; locNot.fireDate = [NSDate dateWithTimeIntervalSinceNow:1]; locNot.alertBody = [NSString stringWithFormat:@"still alive!"]; locNot.timeZone = [NSTimeZone defaultTimeZone]; [[UIApplication sharedApplication] scheduleLocalNotification:locNot]; //     -   ,     , //   UI        . //      self.backgroundSessionCompletionHandler = completionHandler; }</span></span></code> </pre><br><br>  We return to the main controller. <br>  Restore the session if necessary: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> backgroundSession]; }</code> </pre><br><br>  The method that is called at the very end: <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)callCompletionHandlerIfFinished { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"call completion handler"</span></span>); [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> backgroundSession] getTasksWithCompletionHandler:^(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *dataTasks, <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *uploadTasks, <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *downloadTasks) { <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> count = [dataTasks count] + [uploadTasks count] + [downloadTasks count]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    //       //      UI NSLog(@"all tasks ended"); AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate]; if (appDelegate.backgroundSessionCompletionHandler == nil) return; void (^comletionHandler)() = appDelegate.backgroundSessionCompletionHandler; appDelegate.backgroundSessionCompletionHandler = nil; comletionHandler(); } }]; }</span></span></code> </pre><br><br>  I‚Äôll add that if we don‚Äôt call this handler, we‚Äôll get a warning to the log: <br><pre> <code class="objectivec hljs">Warning: Application delegate received call to - application:handleEventsForBackgroundURLSession:completionHandler: but the completion handler was never called.</code> </pre><br><br>  Also, if we open a multitasking menu, we will not see our updated interface.  Actually, this example demonstrates one of the parties to the multi-tasking "UI", which Apple told us about. <br><br>  That's all, I hope this article will encourage you to use NSURLSession in the next projects! </div><p>Source: <a href="https://habr.com/ru/post/209736/">https://habr.com/ru/post/209736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209726/index.html">NeoQUEST-2014: registration is announced open</a></li>
<li><a href="../209728/index.html">What is the difference between the security of the behavior of the average user and the conscious?</a></li>
<li><a href="../209730/index.html">Forth and shaders</a></li>
<li><a href="../209732/index.html">Porting FreeRTOS to the processor from Multiklet</a></li>
<li><a href="../209734/index.html">Incoding rapid development framework</a></li>
<li><a href="../209738/index.html">The basics of color theory. CIE XYZ system</a></li>
<li><a href="../209742/index.html">Team work on interfaces</a></li>
<li><a href="../209744/index.html">Successful or unsuccessful, that is the question: other crowdfunding statistics</a></li>
<li><a href="../209746/index.html">NSA Spy Gadgets</a></li>
<li><a href="../209752/index.html">Selenium and BrowserMobProxy: more fun together!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>