<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AES-128. Details and implementation in python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The idea of ‚Äã‚Äãwriting something encryptive for yourself was born rather trivial - I had to start another debit card and, therefore, keep another PIN c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AES-128. Details and implementation in python</h1><div class="post__text post__text-html js-mediator-article">  The idea of ‚Äã‚Äãwriting something encryptive for yourself was born rather trivial - I had to start another debit card and, therefore, keep another PIN code in my head.  Paranoia does not allow storing such information in the clear, and also uses third-party services, so after some searches I stopped at the AES standard.  I immediately wanted to understand and implement the algorithm myself, without resorting to additional modules. <br><br>  In the article I will tell in detail about the components of the algorithm, a little dip in the mat part and give an example implementation in python.  In development, I was limited only to what is included in the standard library. <br><a name="habracut"></a><br><h4>  Little introduction </h4><br>  Advanced Encryption Standard is the well-known name of the Rijndael algorithm ([r…õindaÀêl]), which was developed by two Belgian cryptographers Joan Dimen and Vincent Raim.  The algorithm is block and symmetric.  Adopted as a data encryption standard for government agencies in the United States.  The recently acclaimed National Security Agency uses it to store documents: down to the SECRET level, encryption with a key length of 128 bits is used, the TOP SECRET information requires a key of 192 or 256 bits.  In addition to high cryptographic strength, the algorithm is based on not the most difficult mathematics. <br><br><h4>  A lot of encryption </h4><br>  To work, we need a set of bytes as an encryption object and a secret key that will be required when decrypting.  It is inconvenient to keep long keys in the head, and it is believed that the key length is 128 bits, more than enough for inaccessibility, so I did not look at options 192/256.  In addition, as stated <a href="http://habrahabr.ru/post/68328/">here</a> , under certain conditions a longer key may lag behind in stability. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We introduce some notation: <br><ul><li>  State is an intermediate result of encryption, which can be represented as a rectangular byte array having 4 rows and Nb columns.  Each State cell contains a value of 1 byte. </li><li>  Nb is the number of columns (32-bit words) that make up the State.  For the standard is regulated Nb = 4 </li><li>  Nk - key length in 32-bit words.  For AES, Nk = 4, 6, 8. We have already decided that we will use Nk = 4 </li><li>  Nr is the number of encryption rounds.  Depending on the key length, Nr = 10, 12 or 14 </li></ul><br>  The algorithm has four transformations, each of which affects the state in its own way and ultimately leads to the result: <i>SubBytes (), ShiftRows (), MixColumns ()</i> and <i>AddRoundKey ()</i> .  The general encryption scheme can be represented as: <br><img src="https://habrastorage.org/getpro/habr/post_images/f4f/d1d/f2c/f4fd1df2c7f4581a59566d1f5ed31cfd.jpg" alt="image"><br>  At the beginning, the State array is filled with input values ‚Äã‚Äãaccording to the formula <b>State [r] [c] = input [r + 4c], r = 0.1 ... 4;</b>  <b>c = 0.1..Nb</b> .  That is, the columns.  A block of 16 bytes is encrypted at a time. <br><img src="https://habrastorage.org/getpro/habr/post_images/6ff/2e3/f2e/6ff2e3f2e708db869072595bc9f04ca2.jpg" alt="image"><br><br>  The algorithm operates on bytes, considering them to be elements of a finite field or a <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D0%25B5_%25D0%2593%25D0%25B0%25D0%25BB%25D1%2583%25D0%25B0">Galois</a> field GF (2 <sup>8</sup> ).  The number in brackets is the number of field elements or its power.  The elements of the field GF (2 <sup>8</sup> ) are polynomials of degree at most 7, which can be given by a line of their coefficients.  Bytes are very easy to imagine as a polynomial.  For example, byte {1,1,1,0,0,0,1,1} corresponds to the field element 1x <sup>7</sup> + 1x <sup>6</sup> + 1x <sup>5</sup> + 0x <sup>4</sup> + 0x <sup>3</sup> + 0x <sup>2</sup> + 1x <sup>1</sup> + 1x <sup>0</sup> = 1x <sup>7</sup> + 1x <sup>6</sup> + 1x <sup>5</sup> + x +1.  The fact that we work with field elements is very important because it changes the rules of the operations of addition and multiplication.  This we touch on later. <br><br>  Next, we consider in detail each of the transformations. <br><br><h5>  SybButes () </h5><br>  A conversion is the replacement of each byte from State with its corresponding Sbox constant table.  The values ‚Äã‚Äãof the Sbox elements are represented in hexadecimal notation.  The table itself is obtained by means of transformations of the field GF (2 <sup>8</sup> ) already known to us. <br><img src="https://habrastorage.org/getpro/habr/post_images/01d/b9c/7f9/01db9c7f91439b60b48d5dfee225ceec.jpg" alt="image"><br>  Each byte from State can be represented as {xy} in hexadecimal notation.  Then it should be replaced with an element at the intersection of row x and column y.  For example, {6e} will be replaced by {9f}, and {15} by {59}. <br><br><h5>  ShiftRows () </h5><br>  Simple transformation.  It performs a cyclic left shift by 1 element for the first row, by 2 for the second and by 3 for the third.  The zero line does not move. <br><img src="https://habrastorage.org/getpro/habr/post_images/03d/232/661/03d232661e0b54428b62400536b9b4d1.jpg"><br><br><h5>  MixColumns () </h5><br>  Within the framework of this transformation, each column in State is represented as a polynomial and multiplied in the GF (2 <sup>8</sup> ) field modulo x <sup>4</sup> + 1 with a fixed polynomial 3x <sup>3</sup> + x <sup>2</sup> + x + 2. It sounds like a simple, but hardly understandable way .  The picture becomes easier if you look at the equivalent matrix entry provided in the official document of the standard: <br><img src="https://habrastorage.org/getpro/habr/post_images/ac1/5d5/612/ac15d56121b00249dff95a706d661dc0.jpg"><br>  When multiplying matrices, the value of a <sub>ij is</sub> obtained as the sum of the products of the corresponding elements of the i-th row of the first matrix and the j-th column of the second, i.e. <br><img src="https://habrastorage.org/getpro/habr/post_images/92f/8ab/2fb/92f8ab2fbf6f77681e872d7d9dc18de4.jpg"><br>  Here we need to recall the inoperability of the usual rules of addition and multiplication. <br>  New rules: <br><ul><li>  Adding to the GF (2 <sup>8</sup> ) field is equivalent to the XOR operation </li><li>  Multiplication by {01} does not change multiply </li><li>  Multiplication by {02} is made according to the rule: if the multiplied value is less than {80}, it is shifted to the left by 1 bit.  If the multiplied value is greater than or equal to {80}, it is first shifted to the left by 1 bit, and then an XOR operation with the value {1b} is applied to the shift result.  The result can jump beyond the value of {ff}, that is, beyond the boundaries of one byte.  In this case, you need to return the remainder of dividing the result by {100}. </li><li>  Multiplication by other constants can be expressed through previous </li></ul><br>  Naturally, these are not general rules of arithmetic in a finite field, but within the framework of the algorithm, it is necessary to multiply by three constants for encryption and four for decryption, so there will be enough of such local life hacks. <br>  MixColumns () together with ShiftRows () adds diffusion to the cipher. <br><br><h5>  AddRoundKey () </h5><br>  The transformation produces a bitwise XOR of each element in the State with the corresponding element in the RoundKey.  RoundKey is an array of the same size as State, which is built for each round based on the secret key by the KeyExpansion () function, which we will consider further. <br><br><h5>  KeyExpansion () </h5><br>  This auxiliary transformation forms a set of round keys - KeySchedule.  KeySchedule is a long table consisting of Nb * (Nr + 1) columns or (Nr + 1) blocks, each of which is equal in size to State.  The first round key is filled based on the secret key that you come up with, according to the formula <br>  KeySchedule [r] [c] = SecretKey [r + 4c], r = 0.1 ... 4;  c = 0.1..Nk. <br><br>  It is clear that in KeySchedule we have to enter bytes so that further operations are possible.  If you use this algorithm for home encryption, then storing a sequence of numbers in your head is not at all comfortable, so in our implementation KeyExpansion () will take the plaintext line as an input and use <code>ord()</code> for each of the characters to write the result to the KeySchedule cells.  Hence the limitations: no more than 16 characters long and, since we work with bytes, the <code>ord()</code> character should not return values ‚Äã‚Äãlarger than 255 or 11111111 in binary, otherwise we will get incorrect encryption at the output.  It turns out that it will not be possible to encrypt using a key in Russian. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b6/e8d/5cb/8b6e8d5cb7133fb03080e537d4b95046.jpg"><br><br>  The figure shows the KeySchedule layout for AES-128: 11 blocks with 4 columns.  For other variations of the algorithm, there will be (Nr + 1) blocks of Nb columns, respectively.  Now we have to fill the empty places.  For conversions, a constant table is again defined - Rcon - whose values ‚Äã‚Äãare in hexadecimal notation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/631/e45/54f/631e4554f8368120368715b029c0f10b.jpg"><br><br>  KeySchedule replenishment algorithm: <br><ul><li>  At each iteration we work with a table column.  Columns 0, .., (Nk - 1) are already pre-filled with the values ‚Äã‚Äãfrom the secret word.  We start with the column number Nk (in our case, the fourth) </li><li>  If the W <sub>i</sub> column number is a multiple of Nk (in our case, every fourth), then we take the W <sub>i-1</sub> column, perform a cyclic left shift on it by one element, then replace all the bytes of the column with the corresponding ones from the Sbox table, as we did in SubBytes () .  Next, perform the XOR operation between the W <sub>i-Nk</sub> column, the modified W <sub>i-1</sub> and the Rcon <sub>i / Nk-1</sub> column.  The result is written to the column W <sub>i</sub> .  To make it a little clearer, the illustration for i = 4. <br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/794/ab5/2d4794ab5223cbac3518bf7a4aa1b92d.jpg"></li><li>  For the remaining columns, perform XOR between W <sub>i-Nk</sub> and W <sub>i-1</sub> .  The result is recorded in W <sub>i</sub> </li></ul><br>  This auxiliary transformation is the most voluminous in writing and, probably, the most complex, after comprehension of mathematics in MixColumns (), in the algorithm.  The cipher key must consist of 4 * Nk elements (in our case 16).  But since we do all this for home use, it is quite likely that not everyone will come up with a 16-character key and remember it.  Therefore, if an input line has a length of less than 16, I will enter the {01} values ‚Äã‚Äãto the norm in KeySchedule. <br><div class="spoiler">  <b class="spoiler_title">KeyExpansion Code ()</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">key_expansion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key)</span></span></span><span class="hljs-function">:</span></span> key_symbols = [ord(symbol) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symbol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> key] <span class="hljs-comment"><span class="hljs-comment"># ChipherKey shoul contain 16 symbols to fill 4*Nk table. If it's less # complement the key with "0x01" if len(key_symbols) &lt; 4*nk: for i in range(4*nk - len(key_symbols)): key_symbols.append(0x01) # make ChipherKey(which is base of KeySchedule) key_schedule = [[] for i in range(4)] for r in range(4): for c in range(nk): key_schedule[r].append(key_symbols[r + 4*c]) # Comtinue to fill KeySchedule for col in range(nk, nb*(nr + 1)): # col - column number if col % nk == 0: # take shifted (col - 1)th column... tmp = [key_schedule[row][col-1] for row in range(1, 4)] tmp.append(key_schedule[0][col-1]) # change its elements using Sbox-table like in SubBytes... for j in range(len(tmp)): sbox_row = tmp[j] // 0x10 sbox_col = tmp[j] % 0x10 sbox_elem = sbox[16*sbox_row + sbox_col] tmp[j] = sbox_elem # and finally make XOR of 3 columns for row in range(4): s = key_schedule[row][col - 4]^tmp[row]^rcon[row][col/nk - 1] key_schedule[row].append(s) else: # just make XOR of 2 columns for row in range(4): s = key_schedule[row][col - 4]^key_schedule[row][col - 1] key_schedule[row].append(s) return key_schedule</span></span></code> </pre></div></div><br>  As mentioned earlier, KeySchedule is used in the transformation AddRoundKey ().  In the round of initialization, the round key will be columns with numbers 0, .., 3, in the first one - with numbers 4, .., 7 and so on.  The whole point of AddRoundKey () is to generate an XOR State and a round key. <br><br>  This is, in fact, all that concerns the encryption process.  The output array of encrypted bytes is composed of State according to the formula <b>output [r + 4c] = State [r] [c], r = 0.1 ... 4;</b>  <b>c = 0.1..Nb</b> .  In the meantime, the article is being dragged out, so now we will quickly run through the decryption procedure. <br><br><h4>  Quick decoding </h4><br>  The idea here is simple: if you perform a sequence of transformations inverse with encryption transformations with the same keyword, you will get the original message.  Such inverse transformations are <i>InvSubBytes (), InvShiftRows (), InvMixColumns ()</i> and <i>AddRoundKey ()</i> .  General scheme of the decryption algorithm: <br><img src="https://habrastorage.org/getpro/habr/post_images/548/fee/2cc/548fee2cc053abe7d7f85cd20c0c9e66.jpg"><br>  It should be noted that the sequence of adding round keys to AddRoundKey () must be reversed: from Nr + 1 to 0. Initially, as with encryption, the State table is formed from the array of input bytes.  Then, transformations are performed on it in each round, at the end of which the decrypted file should turn out.  The order of transformations has changed a bit.  What will be the first, InvSubBytes () or InvShiftRows (), is actually not important, because one of them works with the values ‚Äã‚Äãof bytes, and the second rearranges the bytes, without changing these same values, but I followed the sequence of transformations in the pseudocode of the standard. <br><br><h5>  InvSubBytes () </h5><br>  It works in the same way as SubBytes (), except that replacements are made from the InvSbox constant table. <br><img src="https://habrastorage.org/getpro/habr/post_images/494/808/474/494808474076a568c24c7f2bc0725dd7.jpg"><br>  The remaining reverse transformations will also be very similar to their direct counterparts, therefore, in the code, we do not allocate separate functions for them.  Each function describing the transformation will have an input variable <code>inv</code> .  If it is <code>False</code> , then the function will work in normal or direct mode (encryption), if <code>True</code> - in inverse (decryption). <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, inv=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inv == <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: <span class="hljs-comment"><span class="hljs-comment"># encrypt box = sbox else: # decrypt box = inv_sbox for i in range(len(state)): for j in range(len(state[i])): row = state[i][j] // 0x10 col = state[i][j] % 0x10 # Our Sbox is a flat array, not a bable. So, we use this trich to find elem: box_elem = box[16*row + col] state[i][j] = box_elem return state</span></span></code> </pre></div></div><br><br><h5>  InvShiftRows () </h5><br>  The transformation makes a cyclical shift to the right by 1 element for the first line of the State, by 2 for the second and by 3 for the third.  The zero line does not rotate. <br><img src="https://habrastorage.org/getpro/habr/post_images/801/c40/a41/801c40a41488987cafb9a9b239448217.jpg"><br>  Explanation of the code: <code>left_shift/right_shift(array, count)</code> rotate the input <code>array</code> in the appropriate direction <code>count</code> times <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shift_rows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, inv=False)</span></span></span><span class="hljs-function">:</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inv == <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: <span class="hljs-comment"><span class="hljs-comment"># encrypting for i in range(1, nb): state[i] = left_shift(state[i], count) count += 1 else: # decryption for i in range(1, nb): state[i] = right_shift(state[i], count) count += 1 return state</span></span></code> </pre></div></div><br><br><h5>  InvMixColumns () </h5><br>  The operations are the same, but each State column is multiplied with another polynomial {0b} x <sup>3</sup> + {0d} x <sup>2</sup> + {09} x + {0e}.  In matrix form, it looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/c6a/eef/37c/c6aeef37cb25208c4064c6384e67d4e1.jpg"><br>  Or ready-made formulas.  All values, of course, in hexadecimal notation. <br><img src="https://habrastorage.org/getpro/habr/post_images/6c1/7ba/0f4/6c17ba0f48831d5d7a7704d7806a548d.jpg"><br>  Here we need to make a digression towards mathematics and explain how to get the functions of multiplication by constants larger than {02}.  As I said, they are obtained by decomposing them through {01} and {02}, namely: <br><div class="spoiler">  <b class="spoiler_title">Transformations</b> <div class="spoiler_text">  n * {03} = n * ({02} + {01}) = n * {02} + n * {01} <br>  n * {09} = n * ({08} + {01}) = n * {02} * {02} * {02} + n * {01} <br>  n * {0b} = n * ({08} + {02} + {01}) = b * {02} * {02} * {02} + n * {02} + n * {01} <br>  n * {0d} = n * ({08} + {04} + {01}) = n * {08} + n * {04} + n * {01} = n * {02} * {02} * {02} + n * {02} * {02} + n * {01} <br>  n * {0} = n * ({08} + {04} + {02} = n * {08} + n * {04} + n * {02} = n * {02} * {02} * { 02} + n * {02} * {02} + b * {02} <br></div></div><br>  Of course, you can decompose the numbers in a different way, but personally verified that the decomposition <br>  n * {09} = n * {03} + n * {03} + n * {03} <br>  and the call of the corresponding functions will give an incorrect result (reference tables with results are in one of the links in the list of sources).  Specially left alternative (commented) computational options, because they are clearer, more elegant, but for some reason they do not work correctly. <br><div class="spoiler">  <b class="spoiler_title">Auxiliary functions of multiplication</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_by_02</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>: res = (num &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = (num &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>)^<span class="hljs-number"><span class="hljs-number">0x1b</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res % <span class="hljs-number"><span class="hljs-number">0x100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_by_03</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mul_by_02(num)^num <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_by_09</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#return mul_by_03(num)^mul_by_03(num)^mul_by_03(num) - works wrong, I don't know why return mul_by_02(mul_by_02(mul_by_02(num)))^num def mul_by_0b(num): #return mul_by_09(num)^mul_by_02(num) return mul_by_02(mul_by_02(mul_by_02(num)))^mul_by_02(num)^num def mul_by_0d(num): #return mul_by_0b(num)^mul_by_02(num) return mul_by_02(mul_by_02(mul_by_02(num)))^mul_by_02(mul_by_02(num))^num def mul_by_0e(num): #return mul_by_0d(num)^num return mul_by_02(mul_by_02(mul_by_02(num)))^mul_by_02(mul_by_02(num))^mul_by_02(num)</span></span></code> </pre></div></div><br>  Explanation of the code: the <code>mul_by_&lt;&gt;</code> functions perform multiplication by the corresponding constant in GF (2 <sup>8</sup> ) according to the rules described in the section about <i>MixColumns ()</i> . <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mix_columns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, inv=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(nb): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inv == <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: <span class="hljs-comment"><span class="hljs-comment"># encryption s0 = mul_by_02(state[0][i])^mul_by_03(state[1][i])^state[2][i]^state[3][i] s1 = state[0][i]^mul_by_02(state[1][i])^mul_by_03(state[2][i])^state[3][i] s2 = state[0][i]^state[1][i]^mul_by_02(state[2][i])^mul_by_03(state[3][i]) s3 = mul_by_03(state[0][i])^state[1][i]^state[2][i]^mul_by_02(state[3][i]) else: # decryption s0 = mul_by_0e(state[0][i])^mul_by_0b(state[1][i])^mul_by_0d(state[2][i])^mul_by_09(state[3][i]) s1 = mul_by_09(state[0][i])^mul_by_0e(state[1][i])^mul_by_0b(state[2][i])^mul_by_0d(state[3][i]) s2 = mul_by_0d(state[0][i])^mul_by_09(state[1][i])^mul_by_0e(state[2][i])^mul_by_0b(state[3][i]) s3 = mul_by_0b(state[0][i])^mul_by_0d(state[1][i])^mul_by_09(state[2][i])^mul_by_0e(state[3][i]) state[0][i] = s0 state[1][i] = s1 state[2][i] = s2 state[3][i] = s3 return state</span></span></code> </pre></div></div><br><br><h5>  AddRoundKey () </h5><br>  This transformation is inverse to itself due to the properties of the XOR operation: <br><blockquote>  <i>(a XOR b) XOR b = a</i> </blockquote><br>  Therefore, no changes need to be made.  The set of round keys is formed in the same way as for encryption using the KeyExpansion () function, but round keys must be substituted in the reverse order. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_round_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, key_schedule, round=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(nk): <span class="hljs-comment"><span class="hljs-comment"># nb*round is a shift which indicates start of a part of the KeySchedule s0 = state[0][col]^key_schedule[0][nb*round + col] s1 = state[1][col]^key_schedule[1][nb*round + col] s2 = state[2][col]^key_schedule[2][nb*round + col] s3 = state[3][col]^key_schedule[3][nb*round + col] state[0][col] = s0 state[1][col] = s1 state[2][col] = s2 state[3][col] = s3 return state</span></span></code> </pre></div></div><br>  Now we have a comprehensive set of auxiliary transformation functions to write <br><div class="spoiler">  <b class="spoiler_title">Encryption function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input_bytes, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># let's prepare our input data: State array and KeySchedule state = [[] for j in range(4)] for r in range(4): for c in range(nb): state[r].append(input_bytes[r + 4*c]) key_schedule = key_expansion(key) state = add_round_key(state, key_schedule) for rnd in range(1, nr): state = sub_bytes(state) state = shift_rows(state) state = mix_columns(state) state = add_round_key(state, key_schedule, rnd) state = sub_bytes(state) state = shift_rows(state) state = add_round_key(state, key_schedule, rnd + 1) output = [None for i in range(4*nb)] for r in range(4): for c in range(nb): output[r + 4*c] = state[r][c] return output</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Decryption function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cipher, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># let's prepare our algorithm enter data: State array and KeySchedule state = [[] for i in range(nb)] for r in range(4): for c in range(nb): state[r].append(cipher[r + 4*c]) key_schedule = key_expansion(key) state = add_round_key(state, key_schedule, nr) rnd = nr - 1 while rnd &gt;= 1: state = shift_rows(state, inv=True) state = sub_bytes(state, inv=True) state = add_round_key(state, key_schedule, rnd) state = mix_columns(state, inv=True) rnd -= 1 state = shift_rows(state, inv=True) state = sub_bytes(state, inv=True) state = add_round_key(state, key_schedule, rnd) output = [None for i in range(4*nb)] for r in range(4): for c in range(nb): output[r + 4*c] = state[r][c] return output</span></span></code> </pre></div></div><br>  These two functions take as input a list of bytes not encrypted or encrypted, and plaintext a string with a secret keyword. <br><br><h4>  Conclusion, interesting links </h4><br>  The article was quite long.  I tried to dilute the text with pictures and, I hope, it was interesting for you and nobody got bored.  The code presented in the article is not entirely exhaustive.  I did not insert the global declaration of constant tables, small functions for MixColumns (), but explained only in words that they exist somewhere.  Do not think that I am PR, but you can take the complete code glued together in the <a href="https://github.com/Skycker/AES">repository</a> .  There is also a modest CLI interface that allows you to simply specify the path to the file, enter the secret key and get the encrypted file in the same directory as the source (you can get the decrypted file in the same way).  Encrypt for health! <br><br>  And at the end it is necessary to say about one important nuance - padding or addition to the block.  AES is a block encryption algorithm, the <code>encrypt()/decrypt()</code> functions take exactly one block of input bytes as input (for our version with a 128-bit key, this is 16 bytes).  At the end of the file can remain from 1 to 15 bytes, which do not form a solid block.  They can simply, without encrypting, give to write to the final file, but in some cases, something important may be contained at the end of the file, and this option is not suitable.  The second option was suggested to me by <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580">an article</a> on Wikipedia about block ciphers. <br><blockquote>  The simple addition of zero bits does not solve the problem, since the recipient cannot find the end of the payload.  In addition, this option leads to the attacks of the Oracle additions.  Therefore, in practice, a solution that is standardized as ‚ÄúSupplement Method 2‚Äù in ISO / IEC 9797-1 is applicable, adding a single bit to the end of the message and filling the remaining space with zeros.  In this case, resistance to such attacks has been proven. </blockquote><br>  So I did (although the first option remained, just commented out. Suddenly, it will come in handy). <br><br>  Selection of sources: <br><ul><li>  <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Official documentation</a> </li><li>  <a href="">Very visual visual interpretation of the encryption part of the algorithm</a> .  Yes, the author does not sue me, made from there a couple of screenshots. </li><li>  <a href="http://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">Nowhere without Wikipedia</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Rijndael_mix_columns">Separate article about MixColumns ()</a> .  It has tables with the results of multiplying the list of numbers 0 ... 255 by constants used in the cipher in the GF field (2 <sup>8</sup> ) </li><li>  <a href="http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html">Funny comic about the history of AES and the algorithm itself</a> .  It is a pity that I found it only when I already wrote the article. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/212235/">https://habr.com/ru/post/212235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212221/index.html">The system of collecting and processing information "Safe City"</a></li>
<li><a href="../212225/index.html">Developer - to designers. Frome Hart Tou Hart</a></li>
<li><a href="../212229/index.html">Escene CC800 Contact Center IP Phone Overview</a></li>
<li><a href="../212231/index.html">Virgin Atlantic uses Google Glass and smart watches to work with passengers.</a></li>
<li><a href="../212233/index.html">Crowdsourcing in translation: is it so cool?</a></li>
<li><a href="../212237/index.html">Tame ZoG (Part 2: Whack!)</a></li>
<li><a href="../212241/index.html">Fujitsu Conference in St. Petersburg</a></li>
<li><a href="../212245/index.html">Openness API Telegram</a></li>
<li><a href="../212247/index.html">Processors and their little documented functions</a></li>
<li><a href="../212249/index.html">Transferring data to Windows Azure SQL Database from PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>