<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lighting is harmful, or how to save the charge of the car battery</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the cycle of articles devoted to cycling in the field of low-voltage power circuit control. This time I‚Äôll tell you about a device that pre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lighting is harmful, or how to save the charge of the car battery</h1><div class="post__text post__text-html js-mediator-article">  I continue the cycle of articles devoted to cycling in the field of low-voltage power circuit control.  This time I‚Äôll tell you about a device that prevents a car battery from being deeply discharged by various secondary consumers. <br><br><img src="https://habrastorage.org/webt/_p/pt/zv/_pptzvndfwivnln2xsqz7aae224.jpeg"><br>  <i>One of the possible consequences of an uncontrolled discharge.</i> <br><a name="habracut"></a><br>  Buying a first car or motorcycle is a significant milestone in the life of every person, and especially the engineer.  After all, who else besides the obvious advantages of his new iron horse immediately draws attention to its non-obvious drawbacks?  Who immediately begins to think about all sorts of improvements and additions to the standard equipment?  Of course, if this is a car from the upper segment, and even a ‚Äúfashionable‚Äù brand, then at first it may seem that there is absolutely everything in it.  But as practice shows, in this case time refutes the first impressions.  If you buy an economy class car, then your hands begin to itch literally on the very first day! <br><br>  The desire to maximally ‚Äústuff‚Äù your car with various auxiliary electronic devices is quite natural.  However, soon after the implementation of all these plans, life confronts the car owner with the harsh reality.  It turns out that even the most modern, built on the latest elemental base, the device is still pretty eager for electricity.  And the seemingly so huge automobile battery is not a nuclear reactor at all and can easily ‚Äúsit down‚Äù under the weight of all these seemingly innocuous consumers in a matter of days. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order not to spread further with abstract and hypothetical situations, I will go straight to my own history.  After buying a car, the first was the desire to put a registrar in it.  This was done within the shortest possible period, almost completely dictated by the speed of delivery of the package from Aliexpress.  It is clear that regular power supply from the cigarette lighter was extremely inconvenient, and the recorder quickly received a stationary connection to the nearest onboard power line via a 12 / 5v switching converter.  And since  the matter was, to put it mildly, not yesterday, this converter was not like modern, for its own needs, as it turned out later, it ate as much as 21 mA of current.  Now let us estimate how much this converter alone could feed a new and fully charged battery with a capacity of 60 Ah.  Arithmetic is extremely simple and disappointing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/kz/tb/ljkztbra63ol-bs6xwdpdxd4xjg.png"></div><br>  So for less than four months, the converter, which is not loaded with anything, will drop the battery literally ‚Äúto zero‚Äù.  If we take into account that the capacity of a not quite fresh battery can easily be widowed less, and the charge after city rides is far from 100%, a rainy day easily comes after a month with a hook. <br><br>  And this is all, I repeat, only the voltage converter.  Yes, today you can buy a converter that takes only half a milliampere for your own needs, but I gave an example just to show how slowly and confidently the <s>water wears away a stone,</s> even a trifling, but constantly acting, consumer drains energy out of such a huge battery <br><br>  We go further, the recorder itself in FHD @ 30fps recording mode consumes almost 300 mA from a + 5v source, which, after conversion taking into account efficiency, yields about 150 mA of current from the on-board network.  Let us assume that the converter is replaced by a modern one, and we calculate the discharge time only by this current. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/p8/fl/ufp8fldn4t5bfzpl8u8udb6fd3o.png"></div><br>  Just over two weeks, but in practice - ten days.  Now the prospect of lighting (and possibly changing the battery) looms unwittingly after the next vacation or business trip. <br><br>  So it happened to me: when I left for a small forced vacation, I did not think that after a week or so even the central lock could not open the door for me. <br><br>  Many will say that he himself is to blame, that everything must be de-energized, or, at least, to stop recording, and they will be right.  But life is life, and memory is no longer the same, and how long a trifling hospital will last will not always be known in advance.  Therefore, the idea of ‚Äã‚Äãa circuit breaker immediately appeared. <br><br>  There is, of course, an option to power the recorder from the ignition switch, so that it only works on the move, but this option is also not very good, because  If the car hit in the parking lot, I would like to have a chance to see the culprit.  Plus, after a short time after installing the recorder, the car was added with several more devices, including a hidden GPS tracker that should work if not to the bitter end, then at least until the moment when ‚Äúalmost everything‚Äù is already. <br><br>  In general, within a few weeks of passive thinking, the idea of ‚Äã‚Äãa device that should monitor the voltage of the on-board network and on the basis of this data manage the power supply to two groups of consumers: the secondary ones (recorder, USB socket) and the main ones (GPS tracker and some more) finally took shape. what). <br><br><h3>  How could this be done </h3><br>  The first virtual prototypes of the device were ‚Äúbuilt‚Äù on the basis of the LM393N analog comparators and were able to do everything that was originally planned to receive from the device.  Abstract scheme was obtained approximately as follows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/la/yb/cflaybsmn6m3e6o7mshcfb_1j20.png"></div><br>  Here two comparators are used for switching loads.  General generator of the reference voltage, two dividers, determining the response thresholds, piping of comparators, two power switches.  External strapping of the finished device is planned as follows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0m/77/ew/0m77ewzvozy52h6zr-fg7uaivg0.png"></div><br>  The primary key is kept on longer than the secondary key, so the downconverter itself is powered through it.  Directly connected to the converter primary load.  The secondary key switches the secondary loads already in the + 5v circuit at the output of the converter. <br><br><h3>  What happened in the end </h3><br>  It seems to be all that is needed, but, as is often the case, as we think about the details, ideas for alternative implementations have emerged.  First, the analog circuit contained a decent mountain of discrete elements providing comparators' operating modes, second, setting off thresholds is assumed using trimming resistors, which complicates tuning and creates the likelihood of "shaking" from jolting and time.  Therefore, in the end, it was decided to dwell on the digital implementation, which turned out to be much simpler and schematic and customizable, opening up enormous opportunities for improving the control algorithm, and, most importantly in this context, turned out to be an order of magnitude more economical in terms of current consumption. <br><br>  As the heart of the device, the ATtiny13A controller, which, apart from simplicity and cheapness, is still being produced, is still being produced in a warm Dip package for the oldfaga.  Initially, the capabilities of even such a small controller seemed redundant on all fronts, from the number of inputs / outputs to the amount of software and RAM, however, the appetite, as you know, comes with eating.  As a result, looking ahead, I will say that in the final version, all the outputs of the microcircuit were in the case, and no more than two dozen bytes remained of the free program memory. <br><br>  To measure the voltage of the on-board network, the microcontroller required only one input, which is linked to the ADC.  Two more logical outputs were to control consumers.  First of all, after the final mental transition to the ‚Äúfigure‚Äù, there was a desire to adapt two free GPIOs to the task, and the decision was not long in coming.  When once again in the cold the starter turned the engine with a poorly concealed strain, the presence of a thermal sensor in the circuit and algorithm seemed very useful.  As a result, the second ADC was used to measure the temperature.  And so that the thermistor consumes current only when it is needed, it was decided to power it from the last remaining logic output. <br><br>  As a result, the scheme of the device has acquired such a final look. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/jh/ct/dt/jhctdt_pol1pk6xum1wwn_n7jzo.png"></a> </div><br>  Here we see the very minimum of details, and among them nothing is subject to any kind of ‚Äútwisting‚Äù.  Let us run briefly on the main points. <br><br>  To power the controller, you need a stable voltage from 1.8 to 5.5 V, which means that the circuit must have a stabilizer, which will lower the voltage of the on-board network to the required level.  From the point of view of energy saving, it may seem that there is a place exclusively for the pulse stepdown converter, but this is only at first glance.  The fact is that ATtiny13A even in the very energy-intensive mode of operation (frequency 8 MHz, active code execution) consumes no more than 6 mA.  In this scheme, the controller is 99% of the time in deep sleep mode and also operates at a frequency of 1.2 MHz, with the result that the average consumption is approximately less than 15 ŒºA.  Plus approximately 80 ¬µA per base current of the driving transistors (if both loads are included).  Well, for a small fraction of a second, the power of the thermistor is activated, which adds about 25 microamps to the average current.  And the answer to the question ‚ÄúIs it worth it for the load with a consumption of no more than 120 ¬µA to fence a pulse converter?‚Äù Seems not so straightforward.  And if we consider that we are dealing with analog measurements, then definitely not worth it.  Therefore, a linear stabilizer LP2950 was used, a functional analogue of the popular 78L05, but much more economical.  This converter can produce up to 100 mA of output current, while consuming up to 75 ¬µA of a loved one. <br><br>  The voltage divider of the on-board network, protected by a zener diode and a capacitor, allows to measure voltages up to 15 V. <br><br><blockquote>  I know that now a wave of criticism for such a decision will fall upon me, but we will be objective.  Firstly, I‚Äôm not developing a satellite, and secondly, there is no such single factor that would lead to a catastrophe.  The resistance of the shoulders is high, the zener diode is able to divert much more current than the one that can flow through the divider even in the most pessimistic scenario.  From high-frequency pulses, when the Zener diode does not have enough speed, it protects the capacitor C2 (with a resistor R7 creates a low-pass filter with a cut-off frequency of just 7 Hz).  D1 and R6 to some extent insure the scheme from dumping each other.  And about linearity we should not forget, any method of galvanic isolation in such a place would make a theoretical calculation of values ‚Äã‚Äãcompletely unrealistic, we will have to calibrate at least a prototype, but we don‚Äôt need it. </blockquote><br>  The output resistance of the divider is ten times higher than the recommended 10 kŒ© for the ADC signal source, but thanks to capacitor C2, measurement problems do not arise. <br><br><blockquote>  In general, the input resistance of the AVR controllers of AVR controllers is not less than 100 MŒ© according to the datasheet.  However, nevertheless, the same datasheet recommends using sources with an internal resistance of up to 10 kŒ©.  Why is that?  The matter is in the principle of operation of this very ADC.  The converter itself works on the principle of a <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25BE-%25D1%2586%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">successive approximation</a> , and its input circuit is a low-pass filter from a resistor and a capacitor.  Obtaining a 10-bit sample is performed iteratively and it is necessary that during the entire measurement time the capacitor is charged to the full measured voltage.  If the output impedance of the source is too large, the capacitor will continue to charge directly during the conversion process and the result will be inaccurate.  In our case, the capacity of C2 is more than seven thousand times greater than the capacity of the ADC filter, which means that when the charge is redistributed between these capacitors when they are switched on in parallel at the time of measurement, the input voltage will decrease by no more than 1/7000, which is seven times less than the 10-bit ADC limit accuracy.  However, you need to keep in mind that such a trick works only for single measurements with significant pauses between them, so you should not ‚Äúimprove‚Äù the control program by adding a cycle to it for several consecutive measurements with averaging the result. </blockquote><br>  A divider with a thermistor due to the presence of a controlled power source is built using the recommended ratings.  NTCLE100E3 is used as a sensor, but there are no limitations, you can use any thermistor of approximately the same rating, the main thing is to make adjustments to the source code constants corresponding to its characteristics so that the voltage of the divider is converted to the correct temperature value. <br><br>  As control keys, power P-channel MOSFETs of any type with acceptable open channel resistance and maximum drain-source voltage of at least 30 volts are used.  The above circuit uses different transistors.  This is done because they have to switch different voltages and the type of each of them was chosen for specific working conditions.  The upper transistor should be more high-voltage, and the lower should have as little as possible an open channel resistance.  But, I repeat, this decision is dictated by the device switching circuit (see above), with other switching on the requirements for the lower transistor may be different. <br><br>  To control the power switches used a pair of identical bipolar transistors.  At first, it may seem that these transistors are superfluous, but not everything is so simple.  Insulated gate field-effect transistors begin to open not from any voltage of the required polarity on the gate, but only after reaching a certain threshold level, which appears in datasheets under the name ‚Äúgate-to-source threshold voltage‚Äù and is usually equal to 2..4 V. Now let's just count.  The output circuit of the controller can form two logical levels: a logical "0" with a voltage tending to zero;  and logical "1" with voltage aspiring to the supply.  When powered at 5 volts, these will be voltages of about 0 and 5 V, respectively.  As a result, when switching a 12-volt source, a logical "0" on the gate will create a voltage difference source-gate 12 - 0 = 12 volts, the power transistor is open.  It seems everything is normal, but the logical ‚Äú1‚Äù with its voltage of 5 V will create a voltage of 12 - 5 = 7 volts between the source and the gate, and the power transistor will still remain open.  Thus, a five-volt control signal cannot control a key that commutes a voltage higher than 7..9 volts.  Therefore, control bipolar transistors actually work not so much with signal switches, as with amplifiers that raise the control voltage from 5 volts to the voltage of the on-board network. <br><br>  The resistor in the base circuit of each of the control transistors simply limits the current of the controller outputs to a level sufficient to control.  Their nominal values ‚Äã‚Äãcan be reduced by two or three times with no effect on the operation of the circuit. <br><br><blockquote>  It is easy to see that the control transistors were not in the analog circuit based on LM393N.  The whole point is that the output stage of the selected comparator is built according to the open collector scheme, that is, its output is simply the output of the terminal transistor collector.  Such a construction principle requires additional details to be mounted on the microchip to create the output stage load, but on the other hand it makes the microcircuit very flexible.  An open collector allows the comparator to control any permissible current source, and not only compatible with that which provides power to the comparator itself. </blockquote><br>  It must be said that limiting the threshold voltage of a power MOSFET works not only towards high voltages, as mentioned above, but also towards low voltages.  After all, if the minimum opening voltage of the transistor is, say, 4 volts, then when switching a 3.3 V source, even connecting the gate to the ground does not create the desired voltage difference between the source and the gate, and the transistor will remain closed.  So 5 volts is perhaps the minimum voltage that can be switched by the selected transistors reliably. <br><br><h3>  Customization </h3><br>  Device setup is a separate conversation.  On the one hand, there is not a single setting element in the scheme, but on the other hand, we are dealing with the measurement of stresses with an accuracy not worse than 0.1 V. How to connect all this?  There are two ways.  The first is the use of resistors R6, R7 and R8 with a tolerance not worse than 1% (and better than 0.1%).  The second involves the use of conventional resistors with the measurement of their real resistance and correction coefficients in the source code of the program. <br><br>  The first method is good for mass production, but it is much more attractive for us not to bother with finding the right high-precision nominal values, so let's take the second way.  You can measure resistance using a conventional multimeter, its accuracy is quite enough here.  Another object of measurement will be the voltage of the stabilizer supplying the circuit.  The ADC of the controller can operate in different modes, but for a number of reasons it is more convenient for us to use one in which the digital conversion result is read off relative to the supply voltage.  That is why it is important to know him as accurately as possible. <br><br>  The calculation is extremely simple and consists of calculating the division ratio of the resistive divider and the proportion of transferring the result to LSB for analog-to-digital conversion. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s-/-q/vf/s--qvfm_z0imo_xg5r7tnskhze0.png"></div><br>  Ux is the input voltage of the divider; <br>  Ru is the resistance of the upper arm of the divider (to which Ux is supplied); <br>  Rd is the resistance of the lower arm of the divider (which is connected to ground); <br>  Uref is the reference voltage of the ADC (i.e., the controller supply voltage); <br>  1024 - the number of discrete values ‚Äã‚Äãat the output of a 10-bit ADC; <br>  LSB is the numeric value received by the program from the ADC. <br><br>  Let's start with the voltage divider R6-R7.  For example, let's take real resistances completely corresponding to those indicated in the diagram.  Power, too, take exactly 5.0 V. An example of calculating the results of a voltage conversion of 13.5 volts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/ic/a2/nrica2q5vtygw-ck3mstvspkm4y.png"></div><br>  With due accuracy of measurement of the initial values, the result is quite accurate in order not to adjust it in field tests, but to use as is. <br><br>  The formula for calculating a divider that measures temperature is basically no different; only the variable will be Ru, and Ux can be taken equal to Uref.  The result will look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/t7/qi/zvt7qi05g21ecwvaquqnjdbhjli.png"></div><br>  For example, take the value of R8 from the circuit, and R9 from the datasheet to NTCLE100E3 at a temperature of 0‚Å∞C: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j5/gp/_k/j5gp_kzjcx3buv0ayejxoazlwcu.png"></div><br><blockquote>  If someone says that under the influence of the load from the series-connected R8 and R9, the voltage at the logic output can subside, then of course he will be right.  In theory.  And in practice, even the most pessimistic scenario, when the resistance of R9 thermistor will be equal to zero, the consumption from the controller output will be no more than 0.5 mA, which will not cause any noticeable drop.  At least, in the course of field tests, this fall could not be recorded with a voltmeter having an accuracy of 0.01 V. </blockquote><br>  The resistance of the thermistor at different temperatures can be found in the datasheet, but it is better, of course, to measure them yourself.  The latter may present some problem, therefore, as a compromise, I propose to measure the real resistance at one temperature and thus find the correction factor for resistance at all other temperatures from the datasheet.  Most thermistors have a more or less linear dependence of resistance on temperature, so this method can be considered quite reliable. <br><br>  Actually, all the constants in the program are calculated based on the assumption that the real values ‚Äã‚Äãfully comply with the scheme, in case the parts with small tolerances will be used. <br><br><h3>  Firmware </h3><br>  The complete project archive for AtmelStudio (compiler gcc-avr 5.4.0) can be downloaded <a href="">here</a> , also laid out the already assembled <a href="">hex</a> .  And under the cut listing of the source file, not to go far. <br><br><div class="spoiler">  <b class="spoiler_title">Source code</b> <div class="spoiler_text"><pre><code class="cpp">//#define F_CPU 1200000UL //    

#include &lt;avr/io.h&gt;
#include &lt;avr/wdt.h&gt;
#include &lt;avr/sleep.h&gt;
#include &lt;avr/interrupt.h&gt; 
#include &lt;util/delay.h&gt;

//#define DBG

#define TEMPERATURE_OVERHEAT 753 // LSB-  +50‚Å∞C
#define TEMPERATURE_GIST     8   //    ( LSB)     
#define VOLTAGE_GIST         3   //    ( LSB)     

#define INTERVAL             WDTO_1S //     (1 )
#ifndef DBG
#define CELL_CHANGE_TIMEOUT  90  //      (  INTERVAL,   254)
#define OVERHEAT_TIMEOUT     300 //      "" (  INTERVAL)
#else
#define CELL_CHANGE_TIMEOUT  2
#define OVERHEAT_TIMEOUT     3
#endif

typedef unsigned char bool; //    
#define true  0 == 0        //     
#define false 0 != 0        //      

typedef enum {st_none = 0b00, st_primary = 0b01, st_secondary = 0b10, st_both = 0b11} t_states; //    
                                                                                                //       ,      
typedef enum {adc_temperature, adc_voltage} t_measure;                                          //   
typedef enum {move_null, move_up, move_down} t_movement;                                        //      

//    
struct t_coordidates {
  signed char row, col;
};

//       
struct t_correction {
  t_movement voltage, temperature;
};

#define CELLS_ROWS 3 //      ( )
#define CELLS_COLS 5 //      ( )

//  
const t_states CELLS[CELLS_ROWS][CELLS_COLS] = {
  {st_both, st_both,    st_both,    st_primary, st_none},
  {st_both, st_both,    st_primary, st_none,    st_none},
  {st_both, st_primary, st_none,    st_none,    st_none}
};

// LSB- ,      
const unsigned int ROWS_EDGES[CELLS_ROWS - 1] = {
  241, // 0‚Å∞C
  157  // -10‚Å∞C
};

// LSB- ,      
const unsigned int COLS_EDGES[CELLS_COLS - 1] = {
  864, // 13.5V
  800, // 12.5V
  787, // 12.3V
  768  // 12.0V
};

unsigned int overheat_rest_time = 0; //       ""
unsigned char cell_change_time  = 0; //      
unsigned char no_cur_cell_time  = 0; //  ,            

#define NULL_CELL (struct t_coordidates){.col = -1, .row = -1} // ,   
#define NULL_CORRECTION (struct t_correction){.voltage = move_null, .temperature = move_null} // ,   

struct t_correction moved_from = NULL_CORRECTION; //       
struct t_coordidates cur_cell  = NULL_CELL,       //      
                     next_cell = NULL_CELL;       //  -   

//  
static void init_pins() {
  DDRB |= (1 &lt;&lt; PB0) | (1 &lt;&lt; PB1) | (1 &lt;&lt; PB3);     //   2 (PB3), 5 (PB0)  6 (PB1)  
  PORTB &amp;= ~(1 &lt;&lt; PB0) &amp; ~(1 &lt;&lt; PB1) &amp; ~(1 &lt;&lt; PB3); //      2 (PB3), 5 (PB0)  6 (PB1)
}

// /    
static void toggle_thermal_sensor(bool state) {
  if(state) {
    PORTB |= (1 &lt;&lt; PB1);  //  state ,      6 (PB1)

    _delay_ms(5); //    
  } else {
    PORTB &amp;= ~(1 &lt;&lt; PB1); //  state  ,      6 (PB1)
  }
}

//   
static unsigned int measure_adc(t_measure measure) {
  if(measure == adc_temperature) {
    toggle_thermal_sensor(true); //    ,    

    ADMUX = 0b10; //      -   3 (PB4)
  } else {
    ADMUX = 0b01; //      -   7 (PB2)
  }

  ADCSRA = (1 &lt;&lt; ADPS2) | //       = 16 (75 )
           (1 &lt;&lt; ADIE) |  //    
           (1 &lt;&lt; ADEN);   //  

  set_sleep_mode(SLEEP_MODE_ADC); //   "" 
  do {
    sleep_cpu(); //      ,      ,   
  } while(ADCSRA &amp; (1 &lt;&lt; ADSC)); //        ,  

  ADCSRA = 0; //  

  toggle_thermal_sensor(false); //     

  return ADC; //  10-  
}

//    watchdog
static void init_interrupts(void) {
  sleep_enable(); //   

  WDTCR = (1 &lt;&lt; WDCE) | (1 &lt;&lt; WDE); //  watchdog
  WDTCR = (1 &lt;&lt; WDTIE) | INTERVAL; // watchdog      ,  1 

  sei(); //  
}

//          
static void toggle_loads(t_states states) {
  unsigned char port = PORTB &amp; ~((1 &lt;&lt; PB3) | (1 &lt;&lt; PB0)),     //           ,   
                bits = (((states &amp; st_primary) &gt;&gt; 0) &lt;&lt; PB3) | //        
                       (((states &amp; st_secondary) &gt;&gt; 1) &lt;&lt; PB0);

  PORTB = port | bits; //    
}

//     t_coordidates
static bool cells_equal(struct t_coordidates cell1, struct t_coordidates cell2) {
  return cell1.row == cell2.row &amp;&amp; cell1.col == cell2.col;
}

//          LSB- 
static signed char get_cell_row(unsigned int temperature) {
  signed char row = 0;

  while(row &lt; CELLS_ROWS - 1) {          //          
    if(temperature &gt;= ROWS_EDGES[row]) { //  temperature     ,    
      return row;
    } else {
      ++row;
    }
  }

  return CELLS_ROWS - 1; //  temperature         ,       
}

//          LSB- 
static signed char get_cell_col(unsigned int voltage) {
  signed char col = 0;

  while(col &lt; CELLS_COLS - 1) {      //          
    if(voltage &gt;= COLS_EDGES[col]) { //  voltage     ,    
      return col;
    } else {
      ++col;
    }
  }

  return CELLS_COLS - 1; //  voltage         ,       
}

//    ,       
static void get_row_edges(signed char row, unsigned int *upper, unsigned int *lower) {
  *upper = row &gt; 0 ? ROWS_EDGES[row - 1] : 0xffff - TEMPERATURE_GIST; //       ,    
  *lower = row &lt; CELLS_ROWS - 1 ? ROWS_EDGES[row] : TEMPERATURE_GIST; //       ,    
}

//    ,       
static void get_col_edges(signed char col, unsigned int *upper, unsigned int *lower) {
  *upper = col &gt; 0 ? COLS_EDGES[col - 1] : 0xffff - VOLTAGE_GIST; //      (  )  ,    
  *lower = col &lt; CELLS_COLS - 1 ? COLS_EDGES[col] : VOLTAGE_GIST; //      (  )  ,    
}

//    -              
static void gisteresis_correction(struct t_coordidates* new_cell, unsigned int temperature, unsigned int voltage) {
  unsigned int upper_edge, lower_edge;

  get_row_edges(cur_cell.row, &amp;upper_edge, &amp;lower_edge); //    
  if(new_cell-&gt;row &gt; cur_cell.row &amp;&amp; moved_from.temperature == move_up &amp;&amp; temperature &gt;= lower_edge - TEMPERATURE_GIST) {
    --new_cell-&gt;row; //   -   ,    ,        ,    
  }

  if(new_cell-&gt;row &lt; cur_cell.row &amp;&amp; moved_from.temperature == move_down &amp;&amp; temperature &lt;= upper_edge + TEMPERATURE_GIST) {
    ++new_cell-&gt;row; //   -   ,    ,        ,    
  }

  get_col_edges(cur_cell.col, &amp;upper_edge, &amp;lower_edge); //    
  if(new_cell-&gt;col &gt; cur_cell.col &amp;&amp; moved_from.voltage == move_up &amp;&amp; voltage &gt;= lower_edge - VOLTAGE_GIST) {
    --new_cell-&gt;col; //   -   ,     (  ),        ,    
  }

  if(new_cell-&gt;col &lt; cur_cell.col &amp;&amp; moved_from.voltage == move_down &amp;&amp; voltage &lt;= upper_edge + VOLTAGE_GIST) {
    ++new_cell-&gt;col; //   -   ,     (  ),        ,    
  }
}

//       stdlib::abs()
 static unsigned char absolute(signed char value) {
  return value &gt;= 0 ? value : -value;
}

//      -
static void calc_movement(struct t_coordidates new_cell) {
  moved_from = NULL_CORRECTION;                                                   // -   
  if(!cells_equal(new_cell, NULL_CELL) &amp;&amp; !cells_equal(cur_cell, NULL_CELL)) {    //         ,  -
    if(absolute(new_cell.row - cur_cell.row) == 1) {                              //      
      moved_from.temperature = new_cell.row &lt; cur_cell.row ? move_up : move_down; //   
    }

    if(absolute(new_cell.col - cur_cell.col) == 1) {                              //      
      moved_from.voltage = new_cell.col &lt; cur_cell.col ? move_up : move_down;     //   
    }
  }
}

//   -
static void set_next_cell(struct t_coordidates cell) {
  next_cell = cell;
  cell_change_time = 0; //    
}

//    
static void set_cur_cell(struct t_coordidates cell) {
  cur_cell = cell;
  no_cur_cell_time = 0; //        
  set_next_cell(NULL_CELL); //  -
}

// ,      
static void change_cell(struct t_coordidates new_cell) {
  if(cells_equal(new_cell, NULL_CELL)) { //         
    toggle_loads(st_none);
  } else {
    toggle_loads(CELLS[new_cell.row][new_cell.col]); //         
  }

  calc_movement(new_cell); //     
  set_cur_cell(new_cell);  //   
}

//  
static void main_proc(void) {
  unsigned int temperature, voltage; // 10- LSB-    
  struct t_coordidates cell;         //      -

  if(overheat_rest_time) { //      ""  ,          
    --overheat_rest_time;
  } else {
    temperature = measure_adc(adc_temperature); //  
    if(temperature &gt;= TEMPERATURE_OVERHEAT) {   //      +50C,  :
      change_cell(NULL_CELL);                   //      (   )
      overheat_rest_time = OVERHEAT_TIMEOUT;    //        
    } else {
      voltage = measure_adc(adc_voltage);   //  

      cell.col = get_cell_col(voltage);     //    -  
      cell.row = get_cell_row(temperature); //    -  

      if(cells_equal(cur_cell, NULL_CELL)) { //        ,         
        change_cell(cell);
      } else {
        gisteresis_correction(&amp;cell, temperature, voltage); //              

        if(cells_equal(cell, cur_cell)) { //   -   ,      
          set_next_cell(NULL_CELL);
          no_cur_cell_time = 0; //    ,  
        } else {
          if(no_cur_cell_time++ &gt; CELL_CHANGE_TIMEOUT) { //    CELL_CHANGE_TIMEOUT+1        cur_cell,      
            change_cell(cell); //    ,     
          } else {
            if(cells_equal(next_cell, NULL_CELL) || !cells_equal(next_cell, cell)) { //  -       ,   
              set_next_cell(cell);
            } else {
              if(++cell_change_time &gt;= CELL_CHANGE_TIMEOUT) { //   ,       , ,    
                change_cell(cell);
              }
            }
          }
        }
      }
    }
  }
}

//    watchdog
ISR(WDT_vect) {
  WDTCR |= (1 &lt;&lt; WDTIE); //    watchdog   ""    
}

//    ,        ADSC  measure_adc()
EMPTY_INTERRUPT(ADC_vect);

//  
int main(void) {
  init_pins();       //  
  init_interrupts(); //    watchdog
	
  while(true) {                          //  ,       
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); //        
    sleep_cpu();                         //        watchdog 

    main_proc();                         //          
  }
}
</code></pre><br>
<br>
    : L:0x6A, H:0xFF.<br>
</div></div><br>
   .    ,     ‚Äì  ,    ‚Äì .            ,    .     :<br>
<br>
<a href=""><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/wx/ez/0jwxezo197qadbln8crg05zwlhq.png"></div></a><br>
           ,      .<br>
<br>
           .        ,        .   ,        ,       .<br>
<br>
<blockquote>,  -      ,       .                ,    ,      . , - ,  ,    ,   ,                .  ..  -   ,           ,      .    .         .      ,      ,     .</blockquote><br>
        ,                  .  ,  , ,  12.5   ,      ,      12.4 .                . ,             .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/d5/9e/_od59e61ylpgaqhsrwwlwsro3dw.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/bu/uu/lobuuuqhkbahdsyinpg5hhokeyw.png"></div><br>
 ,               , ,   .            ,    .           ¬´¬ª 8-9 .<br>
<br>
<blockquote>         ,     .        ¬´¬ª    ,          .   ,      ,    ¬´¬ª ,     -    (,   ,   ,    ,  ,     -  ).</blockquote><br>
              +50‚Å∞C       .        ,  ,  ,       .                 .<br>
<br>
  ¬´¬ª,   ,    (watchdog).                    .<br>
<br>
<blockquote> ,          ‚Äì  .       . Watchdog   ,  ,     ,     .  ,    ,         ,     watchdog.   ,      ,        .</blockquote><br>
           .       1006 ,      -  .<br>
<br>
<blockquote>,       ,  .   ,        O2,   ,       Os  ,      1024 .             -,      .</blockquote><br>
                       .<br>
<br>
<div class="spoiler"><b class="spoiler_title">    </b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/gg/nv/1bggnvmw6h-x7nab-h9ljuag1lq.png"></div><br>
     Eagle  <a href=""></a>.<br>
</div></div></div><p>Source: <a href="https://habr.com/ru/post/446956/">https://habr.com/ru/post/446956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446944/index.html">Why invest in loss-making companies?</a></li>
<li><a href="../446948/index.html">How Android Trojan Gustuff removes cream (fiat and crypt) from your accounts</a></li>
<li><a href="../44695/index.html">The best article of the first half of November (details and links under the cut)</a></li>
<li><a href="../446950/index.html">76% of manufacturers do not have experience in adding additive - why it‚Äôs good</a></li>
<li><a href="../446952/index.html">Create animated histograms with R</a></li>
<li><a href="../446958/index.html">Cunning Perl Quine</a></li>
<li><a href="../446960/index.html">The house that Jack built</a></li>
<li><a href="../446962/index.html">Phishing and no chemistry</a></li>
<li><a href="../446964/index.html">Integration with SAP ERP. The implementation of mobile price-checker in the store</a></li>
<li><a href="../446966/index.html">News of the week: major events in IT and science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>