<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dictionary implementation in Python 2.7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss how the dictionary is implemented in Python. I will try to answer the question of why the elements of the dictionary are not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dictionary implementation in Python 2.7</h1><div class="post__text post__text-html js-mediator-article">  This article will discuss how the dictionary is implemented in Python.  I will try to answer the question of why the elements of the dictionary are not ordered, to describe how the dictionaries store, add and delete their elements.  I hope that the article will be useful not only to people who learn Python, but also to everyone who is interested in the internal structure and organization of data structures. <br><a name="habracut"></a><br>  To write this article I pushed a <a href="http://stackoverflow.com/questions/8271139/why-is-early-return-slower-than-else">question</a> on the Stack Overflow. <br>  The article discusses the implementation of CPython version 2.7.  All examples were prepared in the 32-bit version of Python on a 64-bit OS, for another version the values ‚Äã‚Äãwill be different. <br><br><h4>  Python dictionary </h4><br>  A dictionary in Python is an associative array, that is, it stores data in the form of pairs (key, value).  A dictionary is a variable data type.  This means that you can add elements to it, change them and delete them from the dictionary.  It also provides the operation of finding and returning an item by key. <br><br>  Initializing and adding elements: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {} <span class="hljs-comment"><span class="hljs-comment">#   ,  d = dict() &gt;&gt;&gt; d['a'] = 123 &gt;&gt;&gt; d['b'] = 345 &gt;&gt;&gt; d['c'] = 678 &gt;&gt;&gt; d {'a': 123, 'c': 678, 'b': 345}</span></span></code> </pre> <br>  Item receipt: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'b'</span></span>] <span class="hljs-number"><span class="hljs-number">345</span></span></code> </pre><br>  Deleting an item: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">del</span></span> d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] &gt;&gt;&gt; d {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">345</span></span>}</code> </pre><br>  The keys of the dictionary can be values ‚Äã‚Äãof only hashable types, that is, types that can have a hash (for this they must have __hash __ () method).  Therefore, values ‚Äã‚Äãof such types as a list (list), a set (set) and the dictionary itself (dict) cannot be keys of a dictionary: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[list()] = <span class="hljs-number"><span class="hljs-number">1</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: unhashable type: <span class="hljs-string"><span class="hljs-string">'list'</span></span> &gt;&gt;&gt; d[set()] = <span class="hljs-number"><span class="hljs-number">2</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: unhashable type: <span class="hljs-string"><span class="hljs-string">'set'</span></span> &gt;&gt;&gt; d[dict()] = <span class="hljs-number"><span class="hljs-number">3</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: unhashable type: <span class="hljs-string"><span class="hljs-string">'dict'</span></span></code> </pre><br><br><h4>  Implementation </h4><br>  The Python dictionary is implemented as a hash table.  As is known, the implementation of a hash table should take into account the possibility of collisions - situations where different keys have the same hash value.  There should be a way to insert and extract elements with regard to collisions.  There are several ways to resolve collisions, such as the chaining method and the open addressing method.  Python uses an open addressing method.  The developers preferred the open addressing method to the chaining method due to the fact that it can significantly save memory on storing pointers that are used in hash tables with chains. <br><br>  In the implementation under consideration, each entry (PyDictEntry) in the hash table of the dictionary consists of three elements ‚Äî a hash, a key, and a value. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t me_hash; PyObject *me_key; PyObject *me_value; } PyDictEntry;</code> </pre><br>  The structure of PyDictObject is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PyDict_MINSIZE 8 typedef struct _dictobject PyDictObject; struct _dictobject { PyObject_HEAD Py_ssize_t ma_fill; Py_ssize_t ma_used; Py_ssize_t ma_mask; PyDictEntry *ma_table; PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash); PyDictEntry ma_smalltable[PyDict_MINSIZE]; };</span></span></code> </pre><br>  When creating a new dictionary object, its size is 8. This value is determined by the constant PyDict_MINSIZE.  To store a hash table, the variables ma_smalltable and ma_table have been entered into PyDictObject.  The pre-allocated ma_smalltable variable, PyDict_MINSIZE (that is, 8), allows small dictionaries (up to 8 PyDictEntry objects) to be stored without additional memory allocation.  Experiments conducted by developers have shown that this size is quite enough for most dictionaries: small dictionaries of instances and usually small dictionaries created for passing named arguments (kwargs).  The variable ma_table corresponds to ma_smalltable for small tables (that is, for tables of 8 cells).  For larger tables, ma_table memory is allocated separately.  The variable ma_table cannot be NULL. <br><br>  If someone suddenly wants to change the value of PyDict_MINSIZE, it can be done in the source, and then rebuild Python.  The value is recommended to be equal to the power of two, but not less than four. <br><br><h4>  A cell in a hash table can have three states. </h4><br>  1) Unused (me_key == me_value == NULL) <br>  This state means that the cell does not contain and has never yet contained a pair (key, value). <br>  After the key is inserted, the ‚Äúunused‚Äù cell changes to the ‚Äúactive‚Äù state. <br>  This state is the only case when me_key = NULL and is the initial state for all cells in the table. <br>  2) Active (me_key! = NULL and me_key! = Dummy and me_value! = NULL) <br>  Indicates that the cell contains an active pair (key, value). <br>  After the key is removed, the cell from the ‚Äúactive‚Äù state changes to the ‚Äúempty‚Äù state (that is, me_key = dummy, <br>  dummy = PyString_FromString ("&lt;dummy key&gt;")). <br>  This is the only state when me_value! = NULL. <br>  3) Empty (me_key == dummy and me_value == NULL) <br>  This state indicates that the cell previously contained an active pair (key, value), but it was deleted, and the new active pair has not yet been recorded in the cell. <br>  In the same way as in the ‚Äúunused‚Äù state, after inserting the key, the cell from the ‚Äúempty‚Äù state changes to the ‚Äúactive‚Äù state. <br>  The ‚Äúempty‚Äù cell cannot return to the ‚Äúunused‚Äù state, that is, return me_key = NULL, since in this case the sequence of samples in the event of a collision will not be able to find out whether the cells were ‚Äúactive‚Äù. <br><br><h4>  Member variables </h4><br>  ma_fill is the number of non-zero keys (me_key! = NULL), that is, the sum of ‚Äúactive‚Äù and ‚Äúempty‚Äù cells. <br>  ma_used is the number of non-zero and non-empty keys (me_key! = NULL, me_key! = dummy), that is, the number of "active" cells. <br>  ma_mask - mask equal to PyDict_MINSIZE - 1. <br>  ma_lookup - search function.  By default, when creating a new dictionary, lookdict_string is used.  This is done because the developers thought that most dictionaries contain only string keys. <br><br><h4>  Main details </h4><br>  The effectiveness of a hash table depends on the availability of ‚Äúgood‚Äù hash functions.  A ‚Äúgood‚Äù hash function should be calculated quickly and with a minimum of collisions.  But, unfortunately, the most frequently used and important hash functions (for string and integer types) return fairly regular values, which leads to collisions.  Take an example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>map(hash, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]) [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; map(hash, [<span class="hljs-string"><span class="hljs-string">'abca'</span></span>, <span class="hljs-string"><span class="hljs-string">'abcb'</span></span>, <span class="hljs-string"><span class="hljs-string">'abcc'</span></span>, <span class="hljs-string"><span class="hljs-string">'abcd'</span></span>, <span class="hljs-string"><span class="hljs-string">'abce'</span></span>]) [<span class="hljs-number"><span class="hljs-number">1540938117</span></span>, <span class="hljs-number"><span class="hljs-number">1540938118</span></span>, <span class="hljs-number"><span class="hljs-number">1540938119</span></span>, <span class="hljs-number"><span class="hljs-number">1540938112</span></span>, <span class="hljs-number"><span class="hljs-number">1540938113</span></span>]</code> </pre><br>  For integers, hashes are their values, so the successive numbers will have consecutive hashes, and for rows, the successive lines have almost successive hashes.  This is not necessarily bad, on the contrary, in a table of 2 ** i size, taking i low hash bits as the initial index of the table is very fast, and there will be no collisions for dictionaries indexed by a sequence of integers: <br><br><img src="https://habrastorage.org/files/608/1d4/f5c/6081d4f5c6a5432192e379b3f2b5cf5e.png"><br><br>  The same will be almost completely observed if the dictionary keys are ‚Äúconsecutive‚Äù lines (as in the example above).  In general cases, this gives more than random behavior, which is what is required. <br><br><img src="https://habrastorage.org/files/262/99b/969/26299b969d0d4f8eaf00de6fc4db3e93.png"><br><br>  Taking only i low hash bits as an index is also vulnerable to collisions: for example, take the list [i &lt;&lt; 16 for i in range (20000)] as a set of keys.  Since the integers are their own hashes and this fits into a dictionary of size 2 ** 15 (since 20000 &lt;32768), the last 15 bits from each hash will all be 0. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">'{0:016b}'</span></span>.format(x), [i &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">20000</span></span>)]) [<span class="hljs-string"><span class="hljs-string">'0000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'10000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'100000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'110000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'1000000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'1010000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'1100000000000000000'</span></span>, <span class="hljs-string"><span class="hljs-string">'1110000000000000000'</span></span>, ...]</code> </pre><br>  It turns out that all keys will have the same index.  That is, for all keys (except the first one) collisions will occur. <br>  Examples of specially selected "bad" cases should not affect ordinary cases, so just leave the last i bits taken.  Everything else is at the mercy of the collision resolution method. <br><br><h4>  Collision resolution method </h4><br>  The procedure for selecting the appropriate cell to insert an element into a hash table is called probing, and the candidate cell in question is a sample. <br><br>  Usually, the cell is located on the first attempt (and this is true, because the fill factor of the hash table is below 2/3), which allows not to waste time on probing and makes the calculation of the initial index very fast.  But let's consider what happens if a collision occurs. <br><br>  The first part of the collision resolution method is to calculate the indexes of the table for probing using the formula: <br><br><pre> <code class="python hljs">j = ((<span class="hljs-number"><span class="hljs-number">5</span></span> * j) + <span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">2</span></span>**i</code> </pre><br>  For any initial j within [0 .. (2 ** i - 1)], calling this formula 2 ** i will return each number within [0 .. (2 ** i - 1)] exactly once.  For example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>j = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; i = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>**i): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> j, ... j = ((<span class="hljs-number"><span class="hljs-number">5</span></span> * j) + <span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">2</span></span>**i ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  You will say that this is no better than using linear probing with a constant step, because in this case, the cells in the hash table are also viewed in a certain order, but this is not the only difference.  In general cases, when the hash of key values ‚Äã‚Äãgoes in a row, this method is better than linear probing.  From the example above, we can see that for a table of size 8 (2 ** 3) the order of the indices will be as follows: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">7</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; ‚Ä¶ (  )</code> </pre><br>  If a collision occurs for a sample with an index of 5, then the next sample index will be 2, not 6, as in the case of linear probing with a step of +1, therefore for a key added in the future, the sample index of which will be equal to 6, there will be no collision .  Linear probing in this case (with consecutive key values) would be a bad option, since many collisions would occur.  The probability that the hash of the keys will go in the order of 5 * j + 1 is much less. <br><br>  The second part of the collision resolution method is to use not only the lower i bits of the hash, but the rest of the bits too.  This is implemented using the perturb variable as follows: <br><br><pre> <code class="python hljs"> j = (<span class="hljs-number"><span class="hljs-number">5</span></span> * j) + <span class="hljs-number"><span class="hljs-number">1</span></span> + perturb perturb &gt;&gt;= PERTURB_SHIFT  j % <span class="hljs-number"><span class="hljs-number">2</span></span>**i      : perturb = hash(key) PERTURB_SHIFT = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  After that, the sequence of samples will depend on each bit of hash.  A pseudo-random change is very effective because it quickly increases bit differences.  Since the perturb variable is unsigned, if probing is performed often enough, the perturb variable eventually becomes and remains zero.  At this moment (which is very rarely achieved), the result j again becomes equal to 5 * j + 1. Next, the search is performed in the same way as in the first part of the method, and the free cell will eventually be found, because, as was said earlier, each a number in the range [0 .. (2 ** i - 1)] will be returned exactly once, and we are sure that there is always at least one ‚Äúunused‚Äù cell. <br><br>  Choosing a ‚Äúgood‚Äù value for PERTURB_SHIFT is a matter of balancing.  If you make it small, the high-order bits of the hash will affect the sample sequence in iterations.  If you make it big, then in really ‚Äúbad‚Äù cases, the high-order bits of the hash will only affect early iterations.  As a result of the experiments that were conducted by one of the Python developers, Tim Peters, the PERTURB_SHIFT value was chosen equal to 5, since this value turned out to be ‚Äúthe best‚Äù.  That is, it showed the minimum total number of collisions for both normal and specially selected "bad" cases, although the values ‚Äã‚Äã4 and 6 were not significantly worse. <br><br>  Historical note: One of the Python developers, Reimer Berends, proposed the idea of ‚Äã‚Äãusing a polynomial-based index calculation approach, which was then improved by Christian Tismer.  This approach also showed excellent results on the occurrence of collisions, but required more operations, as well as an additional variable for storing the table polynomial in the PyDictObject structure.  In Tim Peters' experiments, the current method used in Python turned out to be faster, showing equally good results for collisions, but required less code and used less memory. <br><br><h4>  Dictionary initialization </h4><br>  When you create a dictionary, the PyDict_New function is called.  In this function, the following operations are performed sequentially: memory is allocated for a new PyDictObject dictionary object.  The variable ma_smalltable is cleared.  The variables ma_used and ma_fill are equal to 0, ma_table becomes equal to ma_smalltable.  The ma_mask value is equal to PyDict_MINSIZE - 1. The ma_lookup search function is set to lookdict_string.  The created dictionary object is returned. <br><br><h4>  Add item </h4><br>  When adding an item to the dictionary or changing the value of an item in the dictionary, the PyDict_SetItem function is called.  In this function, the hash value is taken and the insertdict function is called, as well as the dictresize function, if the table is 2/3 full of the current size. <br><br>  In turn, the function insertdict calls the lookdict_string (or lookdict, if the dictionary has a non-string key), in which a free cell is searched in the hash table for insertion.  The same function is used to find the key when extracting. <br><br>  The initial sample index in this function is calculated as a hash of the key divided by the module by the size of the table (thus, the lower bits of the hash are taken).  I.e: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>PyDict_MINSIZE = <span class="hljs-number"><span class="hljs-number">8</span></span> &gt;&gt;&gt; key = <span class="hljs-number"><span class="hljs-number">123</span></span> &gt;&gt;&gt; hash(key) % PyDict_MINSIZE &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  In Python, this is implemented using a logical AND operation and a mask.  The mask is equal to the following value: mask = PyDict_MINSIZE - 1. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>PyDict_MINSIZE = <span class="hljs-number"><span class="hljs-number">8</span></span> &gt;&gt;&gt; mask = PyDict_MINSIZE - <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; key = <span class="hljs-number"><span class="hljs-number">123</span></span> &gt;&gt;&gt; hash(key) &amp; mask &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  This is how the lower bits of the hash are obtained: <br>  2 ** i = PyDict_MINSIZE, hence i = 3, that is, three low bits are enough. <br>  hash (123) = 123 = 1111011 <sub>2</sub> <br>  mask = PyDict_MINSIZE - 1 = 8 - 1 = 7 = 111 <sub>2</sub> <br>  index = hash (123) &amp; mask = 1111 <font color="blue">011</font> <sub>2</sub> &amp; <font color="blue">111</font> <sub>2</sub> = <font color="blue">011</font> <sub>2</sub> = 3 <br><br>  After the index is calculated, the cell is checked by its index, and if it is ‚Äúunused‚Äù, then an entry is added to it (hash, key, value).  But if this cell is busy, because the other entry has the same hash (that is, a collision has occurred), the hash and key of the inserted entry and the entry in the cell are compared.  If the hash and the key for the entries match, then it is considered that the entry already exists in the dictionary, and it is updated. <br><br>  This explains the tricky moment associated with the addition of equal in value but different in type keys (for example, float, int and complex): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">7.0</span></span> == <span class="hljs-number"><span class="hljs-number">7</span></span> == (<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">0j</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; d = {} &gt;&gt;&gt; d[<span class="hljs-number"><span class="hljs-number">7.0</span></span>]=<span class="hljs-string"><span class="hljs-string">'float'</span></span> &gt;&gt;&gt; d {<span class="hljs-number"><span class="hljs-number">7.0</span></span>: <span class="hljs-string"><span class="hljs-string">'float'</span></span>} &gt;&gt;&gt; d[<span class="hljs-number"><span class="hljs-number">7</span></span>]=<span class="hljs-string"><span class="hljs-string">'int'</span></span> &gt;&gt;&gt; d {<span class="hljs-number"><span class="hljs-number">7.0</span></span>: <span class="hljs-string"><span class="hljs-string">'int'</span></span>} &gt;&gt;&gt; d[<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">0j</span></span>]=<span class="hljs-string"><span class="hljs-string">'complex'</span></span> &gt;&gt;&gt; d {<span class="hljs-number"><span class="hljs-number">7.0</span></span>: <span class="hljs-string"><span class="hljs-string">'complex'</span></span>} &gt;&gt;&gt; type(d.keys()[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &lt;type <span class="hljs-string"><span class="hljs-string">'float'</span></span>&gt;</code> </pre><br>  That is, the type that was added to the dictionary first, and will be the type of key, despite the update.  This is because the implementation of the hash for float values ‚Äã‚Äãreturns a hash of an int if the fractional part is 0.0.  An example of a hash calculation for float rewritten in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float_value)</span></span></span><span class="hljs-function">:</span></span> ... fractpart, intpart = math.modf(float_value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fractpart == <span class="hljs-number"><span class="hljs-number">0.0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> int_hash(int(float_value)) <span class="hljs-comment"><span class="hljs-comment">#   int ...</span></span></code> </pre><br>  And the hash from the complex returns the hash from the float.  In this case, only the real part hash is returned, since the imaginary part is zero: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complex_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(complex_value)</span></span></span><span class="hljs-function">:</span></span> hashreal = float_hash(complex_value.real) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hashreal == <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> hashimag = float_hash(complex_value.imag) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hashimag == <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> res = hashreal + <span class="hljs-number"><span class="hljs-number">1000003</span></span> * hashimag res = handle_overflow(res) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res == <span class="hljs-number"><span class="hljs-number">-1</span></span>: res = <span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br>  Example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>hash(<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span> &gt;&gt;&gt; hash(<span class="hljs-number"><span class="hljs-number">7.0</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span> &gt;&gt;&gt; hash(<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">0j</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br>  Since both the hashes and the values ‚Äã‚Äãfor all three types are equal, a simple update of the value of the found record is performed. <br><br>  Note about adding items: Python prohibits adding items to the dictionary during iteration, so when you try to add a new item, an error occurs: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> d: ... d[<span class="hljs-string"><span class="hljs-string">'new item'</span></span>] = <span class="hljs-number"><span class="hljs-number">123</span></span> ... Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; RuntimeError: dictionary changed size during iteration</code> </pre><br>  Let's return to the procedure of adding an element to the dictionary.  After successfully adding or updating a record in the hash table, the next candidate entry is compared.  If the hash or key of the records do not match, probing begins.  A search for an ‚Äúunused‚Äù cell for insertion.  In this Python implementation, random (and if perturb variable is zero - quadratic) probing is used.  As described above, when randomly probing, the index of the next cell is selected in a pseudo-random manner.  The entry is added to the first ‚Äúunused‚Äù cell found.  That is, two keys a and b, in which hash (a) == hash (b), but a! = B can easily exist in one dictionary.  If the cell according to the initial sample index is ‚Äúempty‚Äù, probing will occur.  And if the first cell found is ‚Äúzero‚Äù, then the ‚Äúempty‚Äù cell will be used again.  This allows you to overwrite deleted cells, while still saving unused ones. <br><br>  It turns out that the indexes of the elements added to the dictionary depend on the elements already in it, and the order of the keys for two dictionaries consisting of the same set of pairs (key, value) may be different and is determined by the order of adding elements: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d1 = {<span class="hljs-string"><span class="hljs-string">'one'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'three'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'four'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'five'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>} &gt;&gt;&gt; d2 = {<span class="hljs-string"><span class="hljs-string">'three'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'five'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'four'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'one'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} &gt;&gt;&gt; d1 == d2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; d1.keys() [<span class="hljs-string"><span class="hljs-string">'four'</span></span>, <span class="hljs-string"><span class="hljs-string">'three'</span></span>, <span class="hljs-string"><span class="hljs-string">'five'</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>, <span class="hljs-string"><span class="hljs-string">'one'</span></span>] &gt;&gt;&gt; d2.keys() [<span class="hljs-string"><span class="hljs-string">'four'</span></span>, <span class="hljs-string"><span class="hljs-string">'one'</span></span>, <span class="hljs-string"><span class="hljs-string">'five'</span></span>, <span class="hljs-string"><span class="hljs-string">'three'</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>]</code> </pre><br>  This explains why dictionaries in Python display stored pairs (key, value) in the order in which they are added to the dictionary when displaying content.  Dictionaries output them in order of location in the hash table (that is, in the order of the indices). <br><br>  Consider an example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {} &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'habr'</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><img src="//habrastorage.org/files/66c/c2a/7dd/66cc2a7dda0b48648ca4cc24d1b18c3a.png"><br><br>  Insertion occurred at index 5. The variables ma_fill and ma_used have become equal to 1. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'python'</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><img src="//habrastorage.org/files/256/7ac/9dc/2567ac9dcc114eb495b25b080eed866b.png"><br><br>  Insertion occurred at index 0. The variables ma_fill and ma_used have become equal to 2. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'dict'</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><img src="//habrastorage.org/files/90b/150/fc4/90b150fc4ca6437691d9152cff3dea47.png"><br><br>  Insertion occurred at index 4. The ma_fill and ma_used variables are equal to 3. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'article'</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br><img src="//habrastorage.org/files/d3e/98d/81e/d3e98d81e22e46bea0874036fc47576e.png"><br><br>  Insertion has occurred at index 1. The variables ma_fill and ma_used have become equal to 4. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'!!!'</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br><img src="//habrastorage.org/files/b64/28f/61a/b6428f61a9e5444ebd4b177da29cacc3.png"><br><br>  The following happened: <br>  hash ('!!!') = -1297030748 <br>  i = -1297030748 &amp; 7 = 4 <br>  But as can be seen from the table, index 4 is already occupied by writing with the 'dict' key.  That is, a collision occurred.  Testing begins: <br>  perturb = -1297030748 <br>  i = (i * 5) + 1 + perturb <br>  i = (4 * 5) + 1 + (-1297030748) = -1297030727 <br>  index = -1297030727 &amp; 7 = 1 <br>  The new sample index is 1, but this index is also occupied (with the 'article' key).  Another collision has occurred, we continue probing: <br>  perturb = perturb &gt;&gt; PERTURB_SHIFT <br>  perturb = -1297030748 &gt;&gt; 5 = -40532211 <br>  i = (i * 5) + 1 + perturb <br>  i = (-1297030727 * 5) + 1 + (-40532211) = -6525685845 <br>  index = -6525685845 &amp; 7 = 3 <br>  The new sample index is 3, and since it is not busy, an entry is inserted with the key '!!!'  in the cell with the third index.  In this case, the record was added after two trials due to collisions.  The variables ma_fill and ma_used have become equal to 5. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d {<span class="hljs-string"><span class="hljs-string">'python'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'article'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'!!!'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'dict'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'habr'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}</code> </pre><br>  We try to add the sixth element to the dictionary. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">';)'</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br><img src="//habrastorage.org/files/a30/9c5/624/a309c56248754f7fb83c5c7081380543.png"><br><br>  After adding the sixth element, the table will be filled to 2/3, and accordingly, its size will change.  After the size changes (in this case it will increase by 4 times), the hash table will be completely rebuilt to take into account the new size - all ‚Äúactive‚Äù cells will be redistributed, and ‚Äúempty‚Äù and ‚Äúunused‚Äù cells will be ignored. <br><br>  The size of the hash table is now 32, and the variables ma_fill and ma_used are equal to 6. As you can see, the order of the elements has completely changed: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d {<span class="hljs-string"><span class="hljs-string">'!!!'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'python'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'habr'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dict'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'article'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">';)'</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>}</code> </pre><br><br><h4>  Item Search </h4><br>  The search for an entry in the dictionary hash table is similar, starting with cell i, where i depends on the key hash.             (        ) ‚Äì  ,  ,     ,      .      ,    ,  . <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">345</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>: <span class="hljs-number"><span class="hljs-number">678</span></span>} &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'x'</span></span>] Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; KeyError: <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre><br><br><h4>   - </h4><br>   ,     2/3.      - ,  8,    ,    6 . <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">2.0</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5.333333333333333</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the hash table is rebuilt with regard to its new size, and, accordingly, the indexes of all records change. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A value of 2/3 of the size was chosen as optimal in order for probing not to take too much time, that is, the insertion of a new record occurred quickly. Increasing this value leads to the fact that the dictionary is more densely filled with entries, which in turn increases the number of collisions. The decrease also increases the sparseness of the records to the detriment of the increase in the cache lines of the processor they occupy and to the detriment of the increase in the total amount of memory. The check of the table is filled in a very time sensitive part of the code. Attempts to make the check more complex (for example, changing the fill factor for different sizes of the hash table) reduced performance.</font></font><br><br> ,     ,  : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = dict.fromkeys(range(<span class="hljs-number"><span class="hljs-number">5</span></span>)) &gt;&gt;&gt; d.__sizeof__() <span class="hljs-number"><span class="hljs-number">248</span></span> &gt;&gt;&gt; d = dict.fromkeys(range(<span class="hljs-number"><span class="hljs-number">6</span></span>)) &gt;&gt;&gt; d.__sizeof__() <span class="hljs-number"><span class="hljs-number">1016</span></span></code> </pre><br>       PyDictObject  64-  . <br>     8.  ,       6 (   2/3  ),     32. ,     22,   128.  86   512,  342 ‚Äì  2048   . <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The increase in the size of the table when the maximum fill level is reached is 4 if the size of the table is less than 50,000 elements, and 2 for larger tables. This approach may be useful for applications with memory limitations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increasing the size of the table improves the average sparseness, that is, the spread of entries in the dictionary table (reducing collisions), by increasing the amount of memory consumed and the speed of iterations, and also reduces the number of expensive memory allocation operations when resizing for a growing dictionary.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually adding an item to a dictionary can increase its size 4 or 2 times depending on the current size of the dictionary, but it is also possible that the size of the dictionary will decrease. </font><font style="vertical-align: inherit;">Such a situation can occur if ma_fill (the number of non-zero keys, the sum of ‚Äúactive‚Äù and ‚Äúempty‚Äù cells) is much more than ma_used (the number of ‚Äúactive‚Äù cells), that is, many keys have been deleted.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remove item </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When an item is removed from the dictionary, the PyDict_DelItem function is called. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deletion from the dictionary occurs by key, although in reality the memory is not freed. </font><font style="vertical-align: inherit;">In this function, the hash value of the key is calculated, and then a record is searched in the hash table using the same lookdict_string or lookdict function. </font><font style="vertical-align: inherit;">If an entry with such a key and a hash is found, the key of this entry is set to ‚Äúempty‚Äù (that is, me_key = dummy), and the value of the entry is set to NULL (me_value = NULL). </font><font style="vertical-align: inherit;">After that, the variable ma_used will decrease by one, and ma_fill will remain unchanged. </font><font style="vertical-align: inherit;">If the record is not found, an error is returned.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">del</span></span> d[<span class="hljs-string"><span class="hljs-string">'!!!'</span></span>]</code> </pre><br><img src="//habrastorage.org/files/8cc/3b0/b62/8cc3b0b625c6437eb8e0d83f8e67433a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After deletion, the ma_used variable became equal to 4, and ma_fill remained equal to 5, since the cell was not deleted, but was only marked as ‚Äúempty‚Äù and continues to occupy the cell in the hash table. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Randomization hashes </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When running python, you can use the -R switch to use a pseudo-random salt. </font><font style="vertical-align: inherit;">In this case, the hash values ‚Äã‚Äãof such types as strings, buffer, bytes, and datetime objects (date, time, and datetime) will be unpredictable between interpreter calls. </font><font style="vertical-align: inherit;">This method is proposed as a defense against DoS attacks.</font></font><br><br><h4>  Links </h4><br> <a href="">github.com/python/cpython/blob/2.7/Objects/dictobject.c</a> <br> <a href="">github.com/python/cpython/blob/2.7/Include/dictobject.h</a> <br> <a href="https://github.com/python/cpython/blob/2.7/Objects/dictnotes.txt">github.com/python/cpython/blob/2.7/Objects/dictnotes.txt</a> <br> <a href="http://www.shutupandship.com/2012/02/how-hash-collisions-are-resolved-in.html">www.shutupandship.com/2012/02/how-hash-collisions-are-resolved-in.html</a> <br> <a href="http://www.laurentluce.com/posts/python-dictionary-implementation/">www.laurentluce.com/posts/python-dictionary-implementation</a> <br> <a href="http://rhodesmill.org/brandon/slides/2010-03-pycon/">rhodesmill.org/brandon/slides/2010-03-pycon</a> <br> <a href="http://www.slideshare.net/MinskPythonMeetup/ss-26224561">www.slideshare.net/MinskPythonMeetup/ss-26224561</a> ‚Äì Dictionary  Python.   Objects/dictnotes.txt ‚Äì SlideShare (Cyril <a href="http://habrahabr.ru/users/notorca/" class="user_link">notorca</a> Lashkevich) <br> <a href="http://www.youtube.com/watch%3Fv%3DJhixzgVpmdM">www.youtube.com/watch?v=JhixzgVpmdM</a> ‚Äì   ¬´Dictionary  Python.   Objects/dictnotes.txt¬ª </div><p>Source: <a href="https://habr.com/ru/post/247843/">https://habr.com/ru/post/247843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247831/index.html">Kevin Hale: the subtleties of working with user experience (part 1)</a></li>
<li><a href="../247833/index.html">VMware ESXi 5.X and NetApp ONTAP 8: Tuning</a></li>
<li><a href="../247837/index.html">It is finished! io.js Version 1.0.1 (Beta stability) released!</a></li>
<li><a href="../247839/index.html">Intel RealSense Hands-On Lab Workshop. From idea to project - 6 hours</a></li>
<li><a href="../247841/index.html">The App Store breaks records, Rovio experiments with genres, 9GAG takes on games - and other news of the week for a mobile developer</a></li>
<li><a href="../247847/index.html">Simple site parsing with SlimerJS</a></li>
<li><a href="../247849/index.html">Meteor. How to sip this your iron: router for CRUD?</a></li>
<li><a href="../247853/index.html">Experience and practical tips to launch iOS applications</a></li>
<li><a href="../247855/index.html">Torment with LED cube 4x4x4 (Arduino + 74HC595)</a></li>
<li><a href="../247857/index.html">All ways to iterate an array in javascript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>