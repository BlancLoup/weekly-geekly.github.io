<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiplayer in fast games (Part III: the appearance of the enemy)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Parts I, II (single player with authoritarian server) 
2. Part III (The appearance of the enemy) 
3. Part IV (Headshot!) 
 Introduction 
 In the fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiplayer in fast games (Part III: the appearance of the enemy)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/8bc/68b/599/8bc68b5994f4492a812e5367e9789bf8.jpg"><br><br><ol><li>  <a href="https://habrahabr.ru/post/302394/">Parts I, II (single player with authoritarian server)</a> </li><li>  <a href="https://habrahabr.ru/post/302834/">Part III (The appearance of the enemy)</a> </li><li>  <a href="https://habrahabr.ru/post/303006/">Part IV (Headshot!)</a> </li></ol><br><h3>  Introduction </h3><br>  In the first article I talked about the authoritarian server and its usefulness for protection against cheats.  As a result of the second part, we got a set of techniques that allow the player to control the character on a remote server without lag. <br><br>  In this article we will consider the consequences of simultaneous connection of several players to one server. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>From the translator: in this and subsequent articles for gifs, a demo written by me and <a href="https://habrahabr.ru/users/bogotoff/" class="user_link">bogotoff</a> from NerfGame is used.</i> <br><br><h3>  Server update rate </h3><br>  In the previous article, server behavior was extremely simple ‚Äî it reads client input;  updates the state of the game;  sends it back to the client.  But when there are many customers, they send teams very often.  Updating the game world for each team and then notifying all customers about the changed state would weigh heavily on the processor and the network. <br><br>  A better approach would be to accumulate all the commands without executing.  Instead, the world will be updated periodically with a low frequency, for example 10 times per second.  During each update, all the accumulated teams are applied (possibly with a few physics steps so that it is more stable) and the new game state is sent to the clients. <br>  <i>Note</i>  <i>Trans.</i>  <i>In fast games, you most likely want to set the update rate at least 20 times per second (as in Overwatch) and raise it up to 120 (as in CS: GO).</i> <br><br>  In short, the game world has its own fixed refresh rate, independent of the presence of teams or their number. <br><br><h3>  We cope with rare updates </h3><br>  While the player is alone, from his point of view, everything works as smoothly and instantly as before, since the prediction on the client side works regardless of the frequency of server responses. <br><br>  But he receives too rare updates about what is happening on the server with other players.  The naive implementation of other players works like this: the client applies another player's status update as soon as it receives it.  Naturally, this leads to jerks, since the frequency of updating the enemy players will be 10 frames per second. <br><br><div class="spoiler">  <b class="spoiler_title">The problem is not only this</b> <div class="spoiler_text">  approx.  trans.  Even if the server sends updates 60 times per second, this does not mean that the client will receive them 60 times per second.  Networks are not reliable - the package with the next update may come later than we would like, or not reach at all, so the player will still see jerks. <br></div></div><br><img src="https://habrastorage.org/files/c6a/09d/bac/c6a09dbaca3c4439a0b3e8826cbb01eb.png"><br><br><img src="https://habrastorage.org/files/49f/5e1/132/49f5e11320df4befb5c5aab56399b399.gif"><br><br>  Depending on the type of game being developed, there are various ways to deal with this.  And the more predictable the game, the easier it is to get out of this situation. <br><br><h3>  Extrapolation </h3><br>  Suppose you do a race.  The cars are quite predictable - if the car travels 100 m / s, in a second it will be about 100 meters ahead of where it was. <br><br>  Why "about"?  During this second the car could accelerate a little, or slow down;  turn a little.  The key word here is a <b>bit</b> .  Machines are designed so that the position mainly depends on the previous position, speed and direction;  and to a lesser extent on user action.  In other words, a race car cannot instantly turn 180 degrees. <br><br>  How does this work with server updates every 100 ms?  The client receives the speed and direction of each machine;  for the next 100 ms, it will not receive new information, but it must show that the cars are going.  The simplest thing that can be assumed is that the direction and acceleration will be constant during this time and locally reproduce the physics of the machine with these parameters taken into account.  Later, when the update comes, the position of the machine will be adjusted. <br><br>  This correction may be large or small depending on a variety of parameters.  If the player drove the car directly and did not change the speed, the extrapolated position will ideally coincide with the adjusted one.  On the other hand, if a player hits something, the predicted position will be absolutely wrong. <br><br>  This method is suitable only for objects with large inertia: cars, ships. <br><br><h3>  Interpolation </h3><br>  There are situations when extrapolation cannot be applied at all.  Actually, in all scenarios where the direction and speed of the character change quickly.  For example, in a 3d shooter, players usually stop and go around obstacles at high speeds, making extrapolation meaningless, since positions cannot be predicted from outdated information. <br><br>  In this case, you still can not naively apply updates from the server: players will teleport every 100 ms <i>and for each lost / delayed packet</i> . <br><br>  You have information about the position of enemies every 100 ms.  So the trick is to show the player what happened between these updates <b>in the past</b> . <br><br>  Let you get positions at <b>t = 1000</b> .  You have already received information about <b>t = 900</b> , so from <b>t = 1000</b> to <b>t = 1100</b> , you show what this player did with <b>t = 900</b> to <b>t = 1000</b> .  So you show the real movement of the enemies, but 100 ms later. <br><br><img src="https://habrastorage.org/files/8ea/5b4/751/8ea5b47511b24b6d9a5526d0e32b3417.png"><br><br>  Note that when using this technique, players see a slightly different state of the world, since the player sees himself in the present tense (this is necessary for the absence of lag when entering), and sees enemies in the past (it would be even without interpolation, due to non-zero ping ).  But even in fast games, a delay of 100 ms is usually invisible. <br><br><img src="https://habrastorage.org/files/d5c/2d1/b55/d5c2d1b55d924b9eb958fdd81a4e0a61.gif"><br><br>  But there are exceptions - if you need high spatial and temporal accuracy, for example, when firing one player into another.  Since other players are visible in the past, you aim with a delay of 100 ms + ping, that is, where the enemy was more than 100 ms back!  We will deal with this in the next article. <br><img src="https://habrastorage.org/files/554/12a/350/55412a350f33432e85a885114c114bb2.gif"><br><br><h3>  Total </h3><br>  In the client-server model with an authoritarian server, rare updates and delays in communication, you still need to give the player the illusion of continuous movement.  In the previous section, we looked at ways to instantly respond to user input using <b>client side prediction</b> and <b>server negotiation</b> . <br><br>  But other players were still a problem for us.  In this article, we looked at two ways to deal with them: <br><br>  <b>Extrapolation</b> - applies when a position can be predicted from previous information - position, velocity and acceleration. <br><br>  <b>Interpolation</b> - does not predict the future, but uses only real information provided by the server, showing enemy players from the recent past. <br><br>  As a result, the player sees himself in the present, and the other players in the past.  This usually creates a great gaming experience. <br><br>  But if nothing else is done, the illusion will break when events require high space-time accuracy, for example, when fired. </div><p>Source: <a href="https://habr.com/ru/post/302834/">https://habr.com/ru/post/302834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302824/index.html">Gateways in IoT development: when, why and why</a></li>
<li><a href="../302826/index.html">OOXML parser (docx, xlsx, pptx) on Ruby: our errors and findings</a></li>
<li><a href="../302828/index.html">Spark / Scala Young Fighter Course</a></li>
<li><a href="../302830/index.html">12 unwritten design rules</a></li>
<li><a href="../302832/index.html">Lazarus: Who is behind the attacks on the SWIFT bank transfer system</a></li>
<li><a href="../302836/index.html">Another major fraud using payment cards</a></li>
<li><a href="../302838/index.html">Lab penetration testing v.9: nothing is impossible</a></li>
<li><a href="../302840/index.html">Install and configure Collectd to collect and send data to Graphite (Grafana)</a></li>
<li><a href="../302842/index.html">How Microsoft implemented Yammer (Part II)</a></li>
<li><a href="../302844/index.html">Prepare a simple blog on microservices, write your microframe in php and run everything on Docker with examples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>