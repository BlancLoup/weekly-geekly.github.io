<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Processing and classification of requests. Part One: Query Parser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What does the request processing department do in Mail.Ru Search? If in one sentence, we try to ‚Äúunderstand‚Äù the request, that is, we prepare the requ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Processing and classification of requests. Part One: Query Parser</h1><div class="post__text post__text-html js-mediator-article">  What does the request processing department do in Mail.Ru Search?  If in one sentence, we try to ‚Äúunderstand‚Äù the request, that is, we prepare the request for the search, we bring it into a form suitable for interacting with our index, ranking, mixes and other components.  If you want to know more about our work - welcome under cat.  In this post I will talk about one of the areas of our work - the query parser. <br><a name="habracut"></a><br><br><h4>  Where are we, who are we and where is the parser? </h4><br>  The figure shows the structure of the search service.  The parts of the system in which we work are highlighted in pink. <br><br><img src="https://habrastorage.org/storage2/759/e3e/632/759e3e6322f80eaf860b5c16c6f27a1a.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Fig.</i>  <i>1. Our place in the search</i> <br><br>  The frontend provides the user with a form for entering a request, when ready, the request is sent to MetaSM, where it falls into the Query Parser, which analyzes it and classifies it.  Then the query, enriched with additional parameters, is transmitted in the form of a tree to the backends, where, on the basis of this tree, the relevant query data is extracted from the index to the final processing of the ranking. <br><br>  Before the request is submitted to the search system, it is processed by two more components.  The first is sadzhesty, a service that responds to virtually every keystroke, suggesting suitable, in his opinion, options for continuing the query.  The second is a spell checker to whom the request is sent after sending: it analyzes the request for typos. <br><br>  The navigation base is shown separately based on the functionality;  in fact, it is integrated into the query parser, but more on that later. <br><br><h4>  Classes and query types </h4><br>  Why do we need any classification of the request and preliminary analysis?  The reason is that different classes of queries require different data, different ranking formulas, different visual representations of the results. <br><br><img src="https://habrastorage.org/storage2/f6b/72b/d3d/f6b72bd3d856cfaa0485878cf273ebd3.png"><br>  <i>Fig.</i>  <i>2. Varieties of requests</i> <br><br>  Traditionally, all search queries are divided into three classes: <br>  ‚óè informational <br>  ‚óè navigation <br>  ‚óè transactional <br>  Each of them, in turn, breaks up into smaller classes.  This diagram does not pretend to be complete, the process of segmentation of the entire set of requests is, in fact, fractal - it is rather a matter of patience and resources.  Here are only the most basic elements. <br><br>  Transactional requests include searching for content contained on the Internet and searching for objects that are "offline", that is, above all, various goods and services.  Navigation queries - search for explicitly specified sites, blogs and microblogs, personal pages, organizations.  Informational is the broadest class of queries in terms of meaning, everything else applies to it: news, reference queries on facts and terms, a search for opinions and feedback, answers to questions, and much more. <br><br>  Immediately, I note that a single request often has signs of several classes at once.  Therefore, classification is not the creation of a tree structure, in each cell of which a part of the request falls, but rather tagging, that is, endowing the request with additional properties. <br><br><h4>  Distribution of topics </h4><br><img src="https://habrastorage.org/storage2/f25/112/600/f2511260003ba4e667257bd8e743f9d5.png"><br>  <i>Fig.</i>  <i>3. Frequency distribution of different classes of queries</i> <br><br>  By estimating the sizes of various classes of queries, it is clear that a small number of classes contain a large proportion of the query flow, followed by a long tail of decreasing fragments of the query flow.  The narrower the topic, the fewer requests for it and the more such topics. <br><br>  From a practical point of view, this means that we do not strive to classify absolutely all requests - rather, we are trying to pinch the most important requests from the general flow of requests.  As a rule, the criterion for choosing a class is its frequency, but not only: it can be requests that we can process, it is interesting to visualize the results, and so on. <br><br><h4>  Parser architecture </h4><br><img src="https://habrastorage.org/storage2/628/2f5/47e/6282f547ee836290dc658d03f943f8fa.png"><br>  <i>Fig.</i>  <i>4. Architecture of the query parser</i> <br><br>  A parser is a queue of agents, each of which performs some more or less atomic action on the request, starting from breaking it up into words and other regular entities like URLs and phone numbers, and ending with complex classifiers like a citation detector. <br><br>  Agents lined up.  Each request is run through this queue, and the results of the work of each agent affect the further logical path of the request ‚Äî for example, a request classified as navigational does not fall into the processing of a citation detector.  The request itself is presented here as a kind of message board on which each agent can leave a message, read the messages of other agents and, if necessary, change or cancel them.  Upon completion, the request is sent to additional submasters, and is ultimately sent to backends, where all additional parameters written by agents are used as ranking factors. <br><br><h4>  Dictionaries </h4><br>  The main data provider for the query parser are dictionaries.  These are huge files containing grouped arrays of strings, each of which has a specific meaning. <br><br><img src="https://habrastorage.org/storage2/cef/3d7/322/cef3d73223f460bc0eb10bbf1882c780.png"><br>  <i>Fig.</i>  <i>5. Dictionaries: a life example</i> <br><br>  The figure shows a fragment of one of the dictionaries, which contains the words most typical for the requests of the ‚ÄúFilms‚Äù class.  Each of these groups of words can be associated with a marker (in the figure it is surrounded by a green frame).  It means that if the request contains such a fragment, the entire request will be flagged indicating that the movie is the subject of this request. <br><br>  In the same dictionaries are synonyms (red frame in the figure).  Thanks to them, if, for example, the query has the word ‚Äúsoundtrack‚Äù, then the query will be expanded with the phrases ‚Äúaudio track‚Äù, ‚Äúsound track‚Äù and the abbreviation OST. <br><br>  There are dozens of such dictionaries.  The size of some of them is hundreds of thousands, even millions of similar lines.  Based on them, the initial processing of the request, its colorization takes place, after which the more complex logic works. <br><br><h4>  Markers </h4><br>  Take three queries: <br>  ‚óè Pirates of the Caribbean <br>  ‚óè depth of the Caribbean <br>  ‚óè consequences of the Caribbean crisis <br>  From the point of view of text search, all of them are simply strings containing three words each, while from the point of view of the user, each of them has completely different meanings.  Our goal is to inform the system as much as possible about these differences. <br><br><img src="https://habrastorage.org/storage2/3d8/5b0/a75/3d85b0a75428697c64bd710d23a0197c.png"><br>  <i>Fig.</i>  <i>6. Dictionaries and markers</i> <br><br>  The four dictionaries in the figure are chosen for clarity and do not quite correspond to the real ones.  These dictionaries contain facts suitable for mixing, a dictionary with historical events, a dictionary with films and a dictionary with geographical objects.  All the words and phrases of the query are run through these dictionaries, resulting in the following fragments: <br>  ‚óè Pirates of the Caribbean is tagged as a movie with some kind of geography inside. <br>  ‚óè The depth of the Caribbean is a certain objective fact. <br>  ‚óè The aftermath of the Caribbean crisis contains a marker of fact, as evidenced by the word ‚Äúaftermath‚Äù, and a historical event - the Caribbean crisis. <br><br><img src="https://habrastorage.org/storage2/25e/a69/957/25ea699574f1ff17216fa6d83e9f9153.png"><br>  <i>Fig.</i>  <i>7. Dictionaries and markers: intermediate result</i> <br><br>  At the final stage, we remove the geographical object included in the film so that it does not interfere with the sample.  The need for such a deletion is also configured by syntax in the dictionary.  This is called marker greed: as a rule (but not always), a large number of markers and the inclusion of one in the other means that the internal marker should be ignored. <br><br><img src="https://habrastorage.org/storage2/e68/d33/7e6/e68d337e6d56294a6b676ff270b478ba.png"><br>  <i>Fig.</i>  <i>8. Dictionaries and markers: summary</i> <br><br><h4>  Types of dictionaries </h4><br>  The contents of the dictionaries are divided into two large classes: <br>  ‚óè Frequency expressions markers, describing a specific theme or intention of the user.  Such dictionaries are compiled manually. <br>  ‚óè Objects (movies, recipes, dishes, famous personalities, place names, etc.). <br><br>  From the point of view of filling dictionaries, objects are of the greatest interest.  There are several approaches here.  The first is, again, to compile them manually.  This is the best way to get data, but also the most time consuming. <br><br>  Automatic creation of a dictionary of objects is a topic for a separate post, but briefly described, this is an intricate set of simple algorithms that, based on a small training sample of objects of a given type, selects from the log all queries containing objects of the same type, breaking each of these requests on the object and its context. <br><br><img src="https://habrastorage.org/storage2/a25/100/4a5/a251004a540c9fe737cc306bcb172036.png"><br><br>  It should be noted that many requests are ambiguous: for example, on the request ‚Äúdownload the hobbit‚Äù it is absolutely impossible to say exactly what the user wants to download ‚Äî a film, a cartoon, a book or a game. <br><br>  The final stage of the query parser is to transfer the received information to the ranking.  Before this, there is an intersection of data about the request and about the structure and data from the index.  In short, for each word of the query, lists of documents are extracted from the reverse index, which are then intersected by the rules specified by the structure of the query tree.  The difficulty lies in the fact that all words have different weights, some words can be considered optional, the order of words, their forms in the query, the distances between them, and other properties matter.  All the data received along with all the query flags are transferred to the ranking, where they become part of a multitude of factors determining the final search result. <br><br><img src="https://habrastorage.org/storage2/1c7/ea2/794/1c7ea27949c5f296f97c7ae41bfefd17.png"><br>  <i>Fig.</i>  <i>9. Request tree: Moscow Tel Aviv flights</i> <br><br><h4>  Quotes inquiries </h4><br>  Quotation queries are an example of a more complex classification that cannot be done qualitatively on the basis of dictionaries alone.  Initially, when processing quotes, the query log was simply analyzed: it was revealed what quotations are there, how they differ.  The main, most obvious signs of a quotation request are a large length, grammatical consistency of words, the presence of capital letters and punctuation marks.  On the basis of these signs, the first agent was implemented, which, using manually selected coefficients and primitive if-then-else logic, calculated the probability that the request is a quote. <br><br>  However, when there are a lot of factors, and it is no longer possible or even harmful to assess the influence of each of them manually, various machine inclusion algorithms are applied.  When identifying quotes using the same code that is used in the ranking.  The response to a quote query is not only the influence of this factor on the ranking, but also a change in the algorithm for gluing similar documents.  In the case of a false trigger of the classifier, the result of which is an unsuccessful search as a whole, it is necessary to do a re-request, in which the request is no longer considered a quotation.  Thus, the parser also affects the search algorithm as a whole. <br><br><img src="https://habrastorage.org/storage2/702/90f/ef2/70290fef2cca2bf38ec656edd01afa4c.png"><br>  <i>Fig.</i>  <i>10. Quotes inquiries</i> <br><br>  For machine learning, decision trees and methods based on Markov models are used.  More complex methods are prohibitively expensive for real-time.  Therefore, the clustering of requests or selection of objects is made in the preliminary processing, and not done on the fly. <br><br><h4>  To be continued </h4><br>  I will tell you about navigation queries separately - wait for the continuation in the coming days.  In addition, in the next series I will focus on spellchecker and sagesta. <br><br>  If you have questions or useful experience that you would like to share, welcome to comments. <br><br>  <i>Mikhail Dolinin,</i> <i><br></i>  <i>search request manager</i> </div><p>Source: <a href="https://habr.com/ru/post/174321/">https://habr.com/ru/post/174321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../174311/index.html">Digest of upcoming IT events for April 2013</a></li>
<li><a href="../174315/index.html">Getting ready to turn off Google Reader</a></li>
<li><a href="../174317/index.html">CamBoard Pico - the next generation of gesture control interface</a></li>
<li><a href="../174319/index.html">What I hate outsourcing system administration for. Customer perspective</a></li>
<li><a href="../17432/index.html">About flows of meaningless information</a></li>
<li><a href="../174323/index.html">Video review laptop Lenovo IdeaPad Z400 Touch</a></li>
<li><a href="../174325/index.html">Google Maps: 103 Russian cities received a significant update</a></li>
<li><a href="../174327/index.html">Service Logs - Users</a></li>
<li><a href="../174329/index.html">Light control via browser</a></li>
<li><a href="../17433/index.html">do you need a 404 page</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>