<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real unit testing in AngularJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AngularJS is young and hot when it comes to modern web development. Its unique approach to compiling HTML and two-way data binding makes it an effecti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real unit testing in AngularJS</h1><div class="post__text post__text-html js-mediator-article">  AngularJS is young and hot when it comes to modern web development.  Its unique approach to compiling HTML and two-way data binding makes it an effective tool for creating client web applications.  When I learned that Quick Left (the studio in which the author works. Note. Ln.) Will use it to create an application for one of our clients, I was excited and tried to learn about angular as much as I could.  I went around the whole internet, every lesson and guide I could find on Google.  They were really helpful in understanding how directives, templates, compilation, and event looping work (digest), but when it came to testing, I discovered that this topic was simply missed. <br><br>  I was trained in the TDD (Development through Testing) approach and I feel at ease without the Red-Green-Refactoring approach.  Since we still figured out what was happening in Angular testing, the team sometimes had to rely on a ‚Äútest-after‚Äù approach.  This started to make me nervous, so I decided to focus on testing.  I spent weeks on it, and soon the test coverage rose from 40% to 86% (By the way, if you haven‚Äôt done this yet, you can try <a href="http://gotwarlost.github.io/istanbul/">Istabul</a> to check the code coverage in your JS application). <br><br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Today I want to share some of the things I learned.  As good as <a href="https://docs.angularjs.org/api">Angular's documentation</a> , testing a combat application is rarely as easy as the examples you'll see below.  There are many pitfalls that I had to go through to get some things to work.  I found several workarounds that came to me again and again.  In this article we will look at some of them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Reuse pages in End-to-End (e2e) tests </li><li>  Work with Promise Return Functions </li><li>  Mocking controller dependencies and directives </li><li>  Access to child and isolated scope </li></ul><br><br>  This article is intended for medium and advanced developers using AngularJS to write combat applications that will help reduce the pain of testing.  I hope a sense of security in the testing workflow will allow the reader to start practicing the TDD approach and develop more sustainable applications. <br><br><h4>  Testing Tools </h4><br>  There are many frameworks and tools for testing the available Angular developer, and perhaps you already have your own preferences.  Here is a list of tools that we have chosen and will use in the course of the article. <br><br><ul><li>  <a href="http://karma-runner.github.io/0.12/index.html">Karma</a> : A test launcher from the AngularJS team.  Use it to launch Chrome, Firefox, and PhantomJS. </li><li>  <a href="">AngularMocks</a> : Gives support for injection and mock Angular services in unit testing. </li><li>  <a href="https://github.com/angular/protractor">Protractor</a> : Functional testing tool for AngularJS, which runs your application in a browser and interacts with it through Selenium. </li><li> <a href="http://visionmedia.github.io/mocha/">Mocha</a> : A testing framework written in node.js.  Allows you to write <code>describe</code> blocks and do checks in them. </li><li>  <a href="http://chaijs.com/">Chai</a> : An Assertion library that integrates into Mocha, and gives access to the BDD approach and the ability to write <code>expect</code> , <code>should</code> , and <code>assert</code> .  In the examples we will use <code>expect</code> . </li><li>  <a href="http://chaijs.com/plugins/chai-as-promised">Chai-as-promised</a> : A plugin for Chai that is really useful when working with promise return functions.  It gives us the opportunity to write like this: <code>expect(foo).to.be.fulfilled</code> , or <code>expect(foo).to.eventually.equal(bar)</code> . </li><li>  <a href="http://sinonjs.org/">Sinon</a> : Stub and Mock Library.  Use it to create dependency stubs in your directives and controllers, and check that there was a function call with the correct arguments. </li><li>  <a href="http://browserify.org/">Browserify</a> : Allows you to easily connect modules between files in a project. </li><li>  <a href="https://www.npmjs.org/package/partialify">Partialify</a> : Allows you to connect HTML templates directly to AngularJS directives. </li><li>  <a href="http://lodash.com/">Lodash</a> : A library with buns and sugar that extends standard JavaScript functionality. </li></ul><br><br><h4>  Configuring Helpers for the Test </h4><br>  Let's start by writing a helper that will connect the dependencies we need.  Here we will use Angular Mocks, Chai, Chai-as-promised and Sinon <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test/test-helper.js //    require('widgetProject'); //  require('angular-mocks'); var chai = require('chai'); chai.use('sinon-chai'); chai.use('chai-as-promised'); var sinon = require('sinon'); beforeEach(function() { //       this.sinon = sinon.sandbox.create(); }); afterEach(function() { //  ,     this.sinon.restore(); }); module.exports = { rootUrl: 'http://localhost:9000', expect: chai.expect }</span></span></code> </pre><br><h4>  Getting Started: Testing Top-Down </h4><br>  I am a big believer in top-down testing style.  Everything starts with the functionality that I want to create, I write a pseudo script describing the functionality and create a feature test.  I run this test and it crashes with an error.  Now I can start designing all the parts of the system that I need for the feature test to work using unit tests that guide me along the way. <br><br>  For example, I will create an imaginary ‚ÄúWidgets‚Äù application that can display a list of widgets, create new ones, and edit current ones.  The code that you see here is not enough to build a full-fledged application, but enough to understand the examples of tests.  We will start by writing an e2e test describing the behavior of creating a new widget. <br><br><h4>  Reuse of Pages in e2e testing </h4><br>  When working on a one-page application, it makes sense to follow the principle of DRY by writing reusable "pages" that can be connected to many e2e tests. <br><br>  There are many ways to structure tests in the Angular project.  Today, we will use the following structure: <br><br><pre> <code class="bash hljs">widgets-project |-<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> | | | |-e2e | | |-pages | | | |-unit</code> </pre><br>  Inside the <code>pages</code> folder, we will create a <code>WidgetsPage</code> function that can be enabled in the e2e tests.  Five tests refer to it: <br><br><ul><li>  <code>widgetRepeater</code> : the list of widgets contained in <code>ng-repeat</code> </li><li>  <code>firstWidget</code> : the first widget in the list </li><li>  <code>widgetCreateForm</code> : form to create a widget </li><li>  <code>widgetCreateNameField</code> : field to enter the name of the widget </li><li>  <code>widgetCreateSubmit</code> : form submit button </li></ul><br>  In the end you get something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test/e2e/pages/widgets-page.js var helpers = require('../../test-helper'); function WidgetsPage() { this.get = function() { browser.get(helpers.rootUrl + '/widgets'); } this.widgetRepeater = by.repeater('widget in widgets'); this.firstWidget = element(this.widgetRepeater.row(0)); this.widgetCreateForm = element(by.css('.widget-create-form')); this.widgetCreateNameField = this.widgetCreateForm.element(by.model('widget.name'); this.widgetCreateSubmit = this.widgetCreateForm.element(by.buttonText('Create'); } module.exports = WidgetsPage</span></span></code> </pre><br>  From within my e2e tests, I can now connect this page and interact with its elements.  Here's how to use it: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// e2e/widgets_test.js var helpers = require('../test-helper'); var expect = helpers.expect; var WidgetsPage = require('./pages/widgets-page'); describe('creating widgets', function() { beforeEach(function() { this.page = new WidgetsPage(); this.page.get(); }); it('should create a new widget', function() { expect(this.page.firstWidget).to.be.undefined; expect(this.page.widgetCreateForm.isDisplayed()).to.eventually.be.true; this.page.widgetCreateNameField.sendKeys('New Widget'); this.page.widgetCreateSubmit.click(); expect(this.page.firstWidget.getText()).to.eventually.equal('Name: New Widget'); }); });</span></span></code> </pre><br>  Let's see what happens here.  First, we connect the helper test, then we take the <code>expect</code> and <code>WidgetsPage</code> from it.  In <code>beforeEach</code> we load into the browser page.  Then, in the example, we use elements that are defined in the <code>WidgetsPage</code> to interact with the page.  We check that there are no widgets, fill out the form to create one of them with the value ‚ÄúNew Widget‚Äù and check that it is displayed on the page. <br><br>  Now, by dividing the logic for a form into a reusable ‚Äúpage‚Äù, we can reuse it to test form validation, for example, or later in other directives. <br><br><h4>  Work with Promise Return Functions </h4><br>  The Assert methods we took from Protractor in the test above return Promise, so we use Chai-as-promised to check that the <code>isDisplayed</code> and <code>getText</code> return what we expect. <br><br>  We can also work with promise objects inside unit tests.  Let's look at an example in which we are testing a modal window that can be used to edit an existing widget.  It uses the <code>$modal</code> service from UI Bootstrap.  When a user opens a modal window, the service returns promise.  When it cancels or saves the window, the promise is allowed or rejected. <br>  Let us test that the <code>save</code> and <code>cancel</code> methods are properly connected by running Chai-as-promised. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// widget-editor-service.js var angular = require('angular'); var _ = require('lodash'); angular.module('widgetProject.widgetEditor').service('widgetEditor', ['$modal', '$q', '$templateCache', function ( $modal, $q, $templateCache ) { return function(widgetObject) { var deferred = $q.defer(); var templateId = _.uniqueId('widgetEditorTemplate'); $templateCache.put(templateId, require('./widget-editor-template.html')); var dialog = $modal({ template: templateId }); dialog.$scope.widget = widgetObject; dialog.$scope.save = function() { //   - deferred.resolve(); dialog.destroy(); }); dialog.$scope.cancel = function() { deferred.reject(); dialog.destroy(); }); return deferred.promise; }; }]);</span></span></code> </pre><br>  The service will load the template for editing the widget into the template cache, the widget itself, and create a deferred object that will be allowed or rejected depending on whether the user rejects or saves the editing form, which returns the promise. <br><br>  Here's how to test something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test/unit/widget-editor-directive_test.js var angular = require('angular'); var helpers = require('../test_helper'); var expect = helpers.expect; describe('widget storage service', function() { beforeEach(function() { var self = this; self.modal = function() { return { $scope: {}, destroy: self.sinon.stub() } } angular.mock.module('widgetProject.widgetEditor', { $modal: self.modal }); }); it('should persist changes when the user saves', function(done) { var self = this; angular.mock.inject(['widgetModal', '$rootScope', function(widgetModal, $rootScope) { var widget = { name: 'Widget' }; var promise = widgetModal(widget); self.modal.$scope.save(); //       expect(self.modal.destroy).to.have.been.called; expect(promise).to.be.fulfilled.and.notify(done); st $rootScope.$digest(); }]); }); it('should not save when the user cancels', function(done) { var self = this; angular.mock.inject(['widgetModal', '$rootScope', function(widgetModal, $rootScope) { var widget = { name: 'Widget' }; var promise = widgetModal(widget); self.modal.$scope.cancel(); expect(self.modal.destroy).to.have.been.called; expect(promise).to.be.rejected.and.notify(done); $rootScope.$digest(); }]); }); });</span></span></code> </pre><br>  To cope with the complexity of the promise, which returns a modal window in the widget editing test, we can do several things.  Create a mock from the <code>$modal</code> service in the <code>beforeEach</code> function, replacing the function output with an empty <code>$scope</code> object, and blocking the <code>destroy</code> call.  In <code>angular.mock.module</code> , we pass a copy of the modal window so that Angular Mocks can use it instead of the real <code>$modal</code> service.  This approach is quite useful for dependency stubs, as we will see soon. <br><br>  We have two examples, and each must wait for the promise result returned by the editing widget before it is completed.  In this regard, we must pass <code>done</code> as a parameter to the example ourselves, and <code>done</code> when the test is completed. <br><br>  In the tests, we again use Angular Mocks for injection into the widget's modal window and the <code>$rootScope</code> service from AngularJS.  Having <code>$rootScope</code> we can call the <code>$digest</code> loop.  In each of the tests, we load the modal window, cancel or enable it, and use Chai-as-expected to check, return the promise as <code>rejected</code> or as <code>resolved</code> .  To actually call promise and <code>destroy</code> , we need to start <code>$digest</code> , so it is called at the end of each assert block. <br><br>  We looked at how to work with promises in both cases, in e2e and unit tests, using the following assert calls: <br><br><ul><li> <code>expect(foo).to.eventually.equal(bar)</code> </li> <li> <code>expect(foo).to.be.fulfilled</code> </li> <li> <code>expect(foo).to.be.rejected</code> </li> </ul><br><br><h4>  Mock dependencies Directives and Controllers </h4><br>  In the last example, we had a service that relied on the $ modal service, which we locked in order to make sure that the <code>destroy</code> was actually called.  The technique we used is quite useful and allows unit tests to work more correctly in Angular. <br><br>  Admission is as follows: <br><br><ul><li>  Assign <code>var self = this</code> in the <code>beforeEach</code> block. </li><li>  Create a copy and get the methods, then make them properties of the <code>self</code> object: <br><br><pre> <code class="javascript hljs">self.dependency = { <span class="hljs-attr"><span class="hljs-attr">dependencyMethod</span></span>: self.sinon.stub() }</code> </pre></li><li>  Transfer copies to the test module: <br><pre> <code class="javascript hljs">angular.mock.module(<span class="hljs-string"><span class="hljs-string">'mymodule'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">dependency</span></span>: self.dependecy, <span class="hljs-attr"><span class="hljs-attr">otherDependency</span></span>: self.otherDependency });</code> </pre></li><li>  Check locking methods in test examples.  You can use <code>expect(foo).to.have.been.called.withArgs</code> , passing in arguments you expect, for better coverage. </li></ul><br>  Sometimes directives or controllers depend on many internal and external dependencies, and you need to lock them all. <br>  Let's take a look at a more complex example in which the directive monitors the <code>widgetStorage</code> service and updates the widgets in its environment as the collection changes.  There is also an <code>edit</code> method that opens <code>widgetEditor</code> that we created earlier. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// widget-viewer-directive.js var angular = require('angular'); angular.module('widgetProject.widgetViewer').directive('widgetViewer', ['widgetStorage', 'widgetEditor', function( widgetStorage, widgetEditor ) { return { restrict: 'E', template: require('./widget-viewer-template.html'), link: function($scope, $element, $attributes) { $scope.$watch(function() { return widgetStorage.notify; }, function(widgets) { $scope.widgets = widgets; }); $scope.edit = function(widget) { widgetEditor(widget); }); } }; }]);</span></span></code> </pre><br>  Here's how we could test something like this by fixing the <code>widgetStorage</code> and <code>widgetEditor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test/unit/widget-viewer-directive_test.js var angular = require('angular'); var helpers = require('../test_helper'); var expect = helpers.expect; describe('widget viewer directive', function() { beforeEach(function() { var self = this; self.widgetStorage = { notify: self.sinon.stub() }; self.widgetEditor = self.sinon.stub(); angular.mock.module('widgetProject.widgetViewer', { widgetStorage: self.widgetStorage, widgetEditor: self.widgetEditor }); }); //   ... });</span></span></code> </pre><br><h4>  Access to the Child and Insulated Scope </h4><br>  Sometimes you need to write a directive that has an isolated or child scope inside.  For example, when using the <code>$dropdown</code> service from <a href="http://mgcrea.github.io/angular-strap/">Angular Strap</a> , an isolated scope is created.  Getting access to such a scope can be quite painful.  But knowing <code>self.element.isolateScope()</code> can fix this.  Here is one example of using <code>$dropdown</code> , which creates an isolated scope: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// nested-widget-directive.js var angular = require('angular'); angular.module('widgetSidebar.nestedWidget').directive('nestedSidebar', ['$dropdown', 'widgetStorage', 'widgetEditor', function( $dropdown, widgetStorage, widgetEditor ) { return { restrict: 'E', template: require('./widget-sidebar-template.html'), scope: { widget: '=' }, link: function($scope, $element, $attributes) { $scope.actions = [{ text: 'Edit', click: 'edit()' }, { text: 'Delete', click: 'delete()' }] $scope.edit = function() { widgetEditor($scope.widget); }); $scope.delete = function() { widgetStorage.destroy($scope.widget); }); } }; }]);</span></span></code> </pre><br>  Assuming that a directive inherits a widget from a parent directive that has a collection of widgets, it can be quite difficult to access the child scope to check whether its properties have changed as expected.  But it can be done.  Let's look at how: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// test/unit/nested-widget-directive_test.js var angular = require('angular'); var helpers = require('../test_helper'); var expect = helpers.expect; describe('nested widget directive', function() { beforeEach(function() { var self = this; self.widgetStorage = { destroy: self.sinon.stub() }; self.widgetEditor = self.sinon.stub(); angular.mock.module('widgetProject.widgetViewer', { widgetStorage: self.widgetStorage, widgetEditor: self.widgetEditor }); angular.mock.inject(['$rootScope', '$compile', '$controller', function($rootScope, $compile, $controller) { self.parentScope = $rootScope.new(); self.childScope = $rootScope.new(); self.compile = function() { self.childScope.widget = { id: 1, name: 'widget1' }; self.parentElement = $compile('&lt;widget-organizer&gt;&lt;/widget-organizer&gt;')(self.parentScope); self.parentScope.$digest(); self.childElement = angular.element('&lt;nested-widget widget="widget"&gt;&lt;/nested-widget&gt;'); self.parentElement.append(self.childElement); self.element = $compile(self.childElement)(self.childScope); self.childScope.$digest(); }]); }); self.compile(); self.isolateScope = self.element.isolateScope(); }); it('edits the widget', function() { var self = this; self.isolateScope.edit(); self.rootScope.$digest(); expect(self.widgetEditor).to.have.been.calledWith(self.childScope.widget); });</span></span></code> </pre><br><br>  Madness, isn't it?  First we mock <code>widgetStorage</code> and <code>widgetEditor</code> , then we start writing the <code>compile</code> function.  This function will create two instances of the scope, <code>parentScope</code> and <code>childScope</code> , overwrite the widget and put it in the child scope.  Next, <code>compile</code> will set up the scope and complex template: first, compiles the parent <code>widget-organizer</code> , to which the parent scope will be passed.  When this is all completed, we will add a <code>nested-widget</code> child element to it, passing the child scope and at the end run <code>$digest</code> . <br><br>  At the end, we get to magic: we can call the <code>compile</code> function, then climb into the compiled isolated scope of the template (which is the scope from <code>$dropdown</code> ) via <code>self.element.isolateScope()</code> .  At the end of the test, we can crawl into the isolated scope for an <code>edit</code> call, and finally verify that the stuck <code>widgetEditor</code> been called with the stuck widget. <br><br><h4>  Conclusion </h4><br>  Testing can be painful.  I remember several cases when our project had so much pain in figuring out how to do it all, that there was a temptation to go back to writing code and ‚Äúclick testing‚Äù, to test its performance.  Unfortunately, when you get out of this process, the feeling of insecurity only increases. <br><br>  After we set aside time to understand how to deal with difficult cases, it became much easier to understand when such cases occur again.  Armed with the techniques described in this article, we were able to join the TDD process and confidently moved forward. <br><br>  I hope that the techniques that we have looked at today will be useful in your daily practice.  AngularJS is still a young and growing framework.  And what techniques do you use? </div><p>Source: <a href="https://habr.com/ru/post/233705/">https://habr.com/ru/post/233705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233691/index.html">Autodesk will not sell software to sanctioned companies</a></li>
<li><a href="../233693/index.html">Setting up a Cyclos cluster based on Jelastic Platform-as-Infrastructure</a></li>
<li><a href="../233695/index.html">The implementation of the tag system in the admin with the SonataAdminBundle bundle</a></li>
<li><a href="../233699/index.html">Principles of work of one Python-developer</a></li>
<li><a href="../233703/index.html">Autodesk tool for displaying 3d models on the web</a></li>
<li><a href="../233707/index.html">Linux book selling</a></li>
<li><a href="../233711/index.html">Sly Lamb Company Experience: Adapting an iOS App Design for Windows Phone</a></li>
<li><a href="../233713/index.html">Video of reports from the CodeFest 2014 conference</a></li>
<li><a href="../233715/index.html">Acquaintancesemey.rf - service for the formation of the circle of communication of their children</a></li>
<li><a href="../233717/index.html">Make a backup Google or paranoia about the sanctions. Owncloud and other open source solutions.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>