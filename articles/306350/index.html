<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift Features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I wanted to talk about the features and difficulties of Swift, which I encountered when I first met. For writing, the language version...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift Features</h1><div class="post__text post__text-html js-mediator-article">  In this article I wanted to talk about the features and difficulties of Swift, which I encountered when I first met.  For writing, the language version 2.0 was used.  It is assumed that you have already read the documentation and have the basic knowledge for developing a mobile application. <br><a name="habracut"></a><br><h4>  Generic Protocols </h4><br>  By this term, I mean any protocols that have open typealias (associatedtype in Swift 2.2).  In my first application on Swift there were two such protocols: (for example, I simplified them a little) <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didDataChangedNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: DataType)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObservable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeData</span></span></span><span class="hljs-function">&lt;TObserver: DataObserver where TObserver.DataType == DataType&gt; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(observer: TObserver)</span></span></span></span> }</code> </pre> <br>  DataObservable is responsible for tracking data changes.  It does not matter where this data is stored (on the server, locally or else how).  DataObserver receives alerts that data has changed.  First of all, we will be interested in the DataObservable protocol, and here is its simplest implementation. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleDataObservable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TData</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObservable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> = <span class="hljs-type"><span class="hljs-type">TData</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer: <span class="hljs-type"><span class="hljs-type">DataObserver?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data: <span class="hljs-type"><span class="hljs-type">DataType</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { observer?.didDataChangedNotification(data) } } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(data: <span class="hljs-type"><span class="hljs-type">TData</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data = data } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeData</span></span></span><span class="hljs-function">&lt;TObserver : DataObserver where TObserver.DataType == DataType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(observer: TObserver)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.observer = observer } }</code> </pre><br>  Everything is simple: save the reference to the last observer, and call it didDataChangedNotification method when the data is changed for some reason.  But hey ... this code doesn't compile.  The compiler gives the error "Protocol 'DataObserver' can be used.  This is because generic protocols can only be used to impose restrictions on generic parameters.  Those.  It is not possible to declare a variable of type DataObserver.  I was not satisfied with this state of affairs.  Having a little rummaged in a network, I have found the decision which helps to understand with the developed problem, and a name to it Type Erasure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is a pattern that represents a small wrapper over a given protocol.  To begin with, we introduce a new class AnyDataObserver, which implements the DataObserver protocol. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyDataObserver</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TData</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> = <span class="hljs-type"><span class="hljs-type">TData</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didDataChangedNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: DataType)</span></span></span></span> { } }</code> </pre><br>  The body of the didDataChangedNotification method is left empty for now.  Go ahead.  We enter into the generic init class (for which I‚Äôm going to tell you just below): <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyDataObserver</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TData</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> = <span class="hljs-type"><span class="hljs-type">TData</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didDataChangedNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: DataType)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TObserver</span></span> : <span class="hljs-type"><span class="hljs-type">DataObserver</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">TObserver</span></span>.<span class="hljs-type"><span class="hljs-type">DataType</span></span> == <span class="hljs-type"><span class="hljs-type">DataType</span></span>&gt;(sourceObserver: <span class="hljs-type"><span class="hljs-type">TObserver</span></span>) { } }</code> </pre><br>  The sourceObserver TObserver parameter is passed to it.  It can be seen that restrictions are imposed on TObserver: first, it must implement the DataObserver protocol, secondly, its DataType must exactly match the DataType of our class.  Actually, sourceObserver is the source observer object that we want to wrap.  And finally the final class code: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyDataObserver</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TData</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> = <span class="hljs-type"><span class="hljs-type">TData</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observerHandler: <span class="hljs-type"><span class="hljs-type">TData</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didDataChangedNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: DataType)</span></span></span></span> { observerHandler(data) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TObserver</span></span> : <span class="hljs-type"><span class="hljs-type">DataObserver</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">TObserver</span></span>.<span class="hljs-type"><span class="hljs-type">DataType</span></span> == <span class="hljs-type"><span class="hljs-type">DataType</span></span>&gt;(sourceObserver: <span class="hljs-type"><span class="hljs-type">TObserver</span></span>) { observerHandler = sourceObserver.didDataChangedNotification } }</code> </pre><br>  Actually here all the "magic" happens.  The private field observerHandler is added to the class, which stores the implementation of the didDataChangedNotification method of the sourceObserver object.  In the didDataChangedNotification method of our class itself, we simply call this implementation. <br><br>  Now we will rewrite SimpleDataObservable: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleDataObservable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TData</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObservable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataType</span></span> = <span class="hljs-type"><span class="hljs-type">TData</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer: <span class="hljs-type"><span class="hljs-type">AnyDataObserver</span></span>&lt;<span class="hljs-type"><span class="hljs-type">DataType</span></span>&gt;? <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data: <span class="hljs-type"><span class="hljs-type">DataType</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { observer?.didDataChangedNotification(data) } } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(data: <span class="hljs-type"><span class="hljs-type">TData</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data = data } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeData</span></span></span><span class="hljs-function">&lt;TObserver : DataObserver where TObserver.DataType == DataType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(observer: TObserver)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.observer = <span class="hljs-type"><span class="hljs-type">AnyDataObserver</span></span>(sourceObserver: observer) } }</code> </pre><br>  Now the code is compiled and works great.  I can note that some classes from the standard library Swift work on a similar principle (for example, AnySequence). <br><br><h4>  Self type </h4><br>  At a certain point I needed to enter the copy protocol into the project: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopyableType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; ??? }</code> </pre><br><br>  But what should the copy method return?  Any?  CopyableType?  Then at each call I would have to write let copyObject = someObject.copy as!  SomeClass, which is not very good.  In addition to this, this code is not secure.  The keyword Self comes to the rescue. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopyableType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> }</code> </pre><br><br>  Thus, we inform the compiler that the implementation of this method must return an object of the same type as the object for which it was invoked.  Here you can draw an analogy with instancetype from Objective-C. <br><br>  Consider the implementation of this protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopyableClass</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopyableType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldA = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldB = <span class="hljs-string"><span class="hljs-string">"Field"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">dynamicType</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() copy.fieldA = fieldA copy.fieldB = fieldB <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> copy } }</code> </pre><br><br>  To create a new instance, use the dynamicType keyword.  It serves to get a reference to an object-type (it all resembles the class method from Objective-C).  After receiving the type object, init is called to it (to ensure that init with no parameters really exists in the class, we enter it with the required keyword).  After that, we copy all the required fields into the created instance and return it from our function. <br><br>  As soon as I finished copying, it became necessary to use Self in another place.  I needed to write a protocol for the View Controller, in which there was a static method for creating a new instance of this very View Controller. <br><br>  Since this protocol was not directly related to the UIViewController class, I made it fairly general and called AutofactoryType: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutofactoryType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> }</code> </pre><br><br>  Let's try using it to create a View Conotroller: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutofactoryType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newInstance = <span class="hljs-type"><span class="hljs-type">UIStoryboard</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Main"</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).instantiateViewControllerWithIdentifier(<span class="hljs-string"><span class="hljs-string">"ViewController"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newInstance <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ViewController</span></span> } }</code> </pre><br>  Everything would be fine, but this code will not compile: ‚ÄúCannot convert return expression of the type ViewController to return type 'Self'‚Äù The fact is that the compiler cannot convert ViewController to Self.  In this case, ViewController and Self are the same thing, but in general, this is not the case (for example, when using inheritance). <br><br>  How to make this code work?  For this, there is not quite honest (in relation to strict typing), but quite a working method.  Add a function: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafeCast</span></span></span><span class="hljs-function">&lt;T, E&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sourceValue: T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">E</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> castedValue = sourceValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">E</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> castedValue } <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unsafe casting value \(sourceValue) to type \(E.self) failed"</span></span>) }</code> </pre><br>  Its purpose is to convert an object of one type to another type.  If the conversion fails, the function simply fails. <br><br>  Use this function in createInstance: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutofactoryType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newInstance = <span class="hljs-type"><span class="hljs-type">UIStoryboard</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Main"</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).instantiateViewControllerWithIdentifier(<span class="hljs-string"><span class="hljs-string">"ViewController"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unsafeCast(newInstance) } }</code> </pre><br>  Thanks to automatic type inference, newInstance is now converted to Self (which could not be done directly).  This code compiles and works. <br><br><h4>  Specific extensions </h4><br>  Type extensions in Swift would not be so useful if you could not write specific code for different types.  Take, for example, the SequenceType protocol from the standard library and write the following extension for it: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SequenceType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Generator</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-type"><span class="hljs-type">String</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { result += value } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } }</code> </pre><br>  The extension introduced a restriction on the element of the sequence, it must be of type String.  Thus, for any sequence consisting of strings (and only for them), it will be possible to call the function concat. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> strings = [‚Äú<span class="hljs-type"><span class="hljs-type">Alpha</span></span>‚Äù, ‚Äú<span class="hljs-type"><span class="hljs-type">Beta</span></span>‚Äù, ‚Äú<span class="hljs-type"><span class="hljs-type">Gamma</span></span>‚Äù] <span class="hljs-comment"><span class="hljs-comment">//printing ‚ÄúAlphaBetaGamma‚Äù print("Strings concat: \(strings.concat())") }</span></span></code> </pre><br>  This allows a significant part of the code to be put into extensions, and called in the right context, while gaining all the advantages of reuse. <br><br><h4>  The implementation of the default protocol methods. </h4><br>  The implementation of the default protocol methods. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniqueIdentifierProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniqueId: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre><br>  As follows from the description, any type that implements this protocol must have a unique identifier unique of type String.  But if you think a little, it becomes clear that within one module for any type its unique identifier is.  So let's write an extension for our new protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniqueIdentifierProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniqueId: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } } }</code> </pre><br>  In this case, the Self keyword is used to impose restrictions on the type object.  The logic of this code is approximately the following: ‚Äúif this protocol is implemented by the UIViewController class (or its successor), then the following uniqueId implementation can be used‚Äù.  This is the default protocol implementation.  In fact, you can write this extension without any restrictions: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniqueIdentifierProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniqueId: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } } }</code> </pre><br>  And then all types that implement the UniqueIdentifierProvider will receive a uniqueId out of the box. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniqueIdentifierProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Nothing } func test() { //printing "ViewController" print(ViewController.uniqueId) }</span></span></code> </pre><br>  The beauty is that the class may have its own implementation of this method.  And in this case, the default implementation will be ignored: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniqueIdentifierProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniqueId: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"I'm ViewController‚Äù } } } func test() { //printing "</span></span><span class="hljs-type"><span class="hljs-type">I'm</span></span> <span class="hljs-type"><span class="hljs-type">ViewController</span></span><span class="hljs-string"><span class="hljs-string">" print(ViewController.uniqueId) }</span></span></code> </pre><br><h4>  Explicitly Specifying a Generic Argument </h4><br>  In my project I used MVVM, and the method responsible for creating the ViewModel was: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createViewModel</span></span></span><span class="hljs-function">&lt;TViewModel: ViewModelType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel = <span class="hljs-type"><span class="hljs-type">TViewModel</span></span>.createIntsance() <span class="hljs-comment"><span class="hljs-comment">//View model configurate return viewModel }</span></span></code> </pre><br><br>  Accordingly, it was used this way: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel: <span class="hljs-type"><span class="hljs-type">MyViewModel</span></span> = createViewModel() }</code> </pre><br>  In this case, the MyViewModel will be supplied to the createViewModel function as a generic argument.  All because Swift itself deduces types from a context.  But is it always good?  In my opinion, it is not.  In some cases it may even lead to errors: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: FactoryMode)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ViewModelBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> mode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NormalMode</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createViewModel() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">NormalViewModel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PreviewMode</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createViewModel() <span class="hljs-comment"><span class="hljs-comment">// as PreviewViewModel } }</span></span></code> </pre><br><br>  In the first case, the NormalViewModel is substituted into the createViewModel method. <br>  In the second, we forgot to write ‚Äúas PreviewViewModel‚Äù, which is why the ViewModelBase type is substituted into the createViewModel method (which at best will lead to an error in runtime). <br><br>  Therefore, it is necessary to make the type indication explicit.  To do this, we will add a new viewModelType parameter of type TViewModel.Type to createViewModel.  Type here means that the method takes as an argument not a type instance, but an object-type itself. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createViewModel</span></span></span><span class="hljs-function">&lt;TViewModel: ViewModelType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModelType: TViewModel.</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">TViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel = viewModelType.createIntsance() <span class="hljs-comment"><span class="hljs-comment">//View model configurate return viewModel }</span></span></code> </pre><br>  After this, our switch-case looks like this: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: FactoryMode)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel: <span class="hljs-type"><span class="hljs-type">ViewModelBase?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> mode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NormalMode</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createViewModel(<span class="hljs-type"><span class="hljs-type">NormalViewModel</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PreviewMode</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createViewModel(<span class="hljs-type"><span class="hljs-type">PreviewViewModel</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } }</code> </pre><br>  Now the CreateViewModel function is passed the arguments NormalViewModel.self and PreviewViewModel.self.  These are the objects of type NormalViewModel and PreviewViewModel.  In Swift there is a rather strange feature: if a function has one parameter, you can not write self. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mode: FactoryMode)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel: <span class="hljs-type"><span class="hljs-type">ViewModelBase?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> mode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NormalMode</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createViewModel(<span class="hljs-type"><span class="hljs-type">NormalViewModel</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PreviewMode</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createViewModel(<span class="hljs-type"><span class="hljs-type">PreviewViewModel</span></span>) } }</code> </pre><br><br>  But if there are two or more arguments, the self keyword is required. <br><br><h4>  PS </h4><br>  I hope that this article will be useful to someone.  It is also planned to continue about Swift (and not only). </div><p>Source: <a href="https://habr.com/ru/post/306350/">https://habr.com/ru/post/306350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306338/index.html">Stripe: your dream service to automate money transfers</a></li>
<li><a href="../306340/index.html">Summer update on Habr√©: ‚ÄúAdministration‚Äù, voice weight and much more</a></li>
<li><a href="../306342/index.html">Prospects for the commercial use of IPv6 in Russia (year 2016)</a></li>
<li><a href="../306344/index.html">11 design projects that "blew up" the world</a></li>
<li><a href="../306348/index.html">Functional animation in UX design. What makes it effective?</a></li>
<li><a href="../306352/index.html">Summer Practice: Top 10 Microsoft Virtual Academy Courses</a></li>
<li><a href="../306354/index.html">Linus Torvalds introduced the release of the Linux kernel 4.7</a></li>
<li><a href="../306356/index.html">2 + 2 * 2 = ::::::</a></li>
<li><a href="../306358/index.html">TerraServer useless service or missed opportunity?</a></li>
<li><a href="../306362/index.html">Working with the framework for iterative processing of graphs Giraph using RBM as an example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>