<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of the new features of C ++ 14: Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In April, a meeting of the C ++ committee was held in Bristol, at which the first proposals for amending the new C ++ 14 standard were considered. All...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of the new features of C ++ 14: Part 1</h1><div class="post__text post__text-html js-mediator-article">  In April, a meeting of the C ++ committee was held in Bristol, at which the first proposals for amending the new C ++ 14 standard were considered.  All the changes considered in this article were approved at this meeting and already occupy their place of honor in the latest version of the draft of the new standard (N3690 dated May 15, 2013). <br><br>  Short list: <br><ul><li>  Automatic detection of return type for normal functions </li><li>  Generalized initialization of captured lambda variables with support for capture-by-movement </li><li>  Generalized (polymorphic) lambda expressions </li><li>  Simplified restrictions on creating <code>constexpr</code> functions </li><li>  Variable patterns </li><li> <code>exchange</code> </li> <li> <code>make_unique</code> </li> <li>  Detached lines </li><li>  Custom literals for standard library types </li><li> <code>optional</code> </li> <li>  <code>shared_mutex</code> and <code>shared_lock</code> </li><li> <code>dynarray</code> </li> </ul><br><a name="habracut"></a><br><h3>  Changes in the language itself </h3><br><h4>  Automatic detection of return type for normal functions </h4><br>  Starting from C ++ 11, it became possible in the language to define lambda expressions, for which, if you have only one <code>return</code> statement, you can not specify the type of the return value - the compiler can output it independently.  Many were surprised that this feature is not available for normal functions.  The corresponding proposal was made before the release of C ++ 11, but it was postponed due to time constraints, and now, several years later, it has been added to the standard.  Also, this amendment says that if a function or lambda expression has several <code>return</code> that return the same type, in this case, the compiler must also output the type value automatically, including the case with a recursive call. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   - int { for (int i = 0; i &lt; len; ++i) if (search (i)) return i; return -1; } auto h() { return h(); } // ,      auto sum(int i) { if (i == 1) return i; //   - int else return sum(i-1)+i; //     } template &lt;class T&gt; auto f(T t) { return t; } //       []()-&gt;auto&amp; { return f(); } //  </span></span></span></span></code> </pre><br>  Although this opportunity has great potential, it has some limitations: <br>  If you place the function declaration in the header file, and the definition is in the corresponding file with the source code, then when you connect the header file to other files, the compiler will not be able to display the type: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// foo.h class Foo { public: auto getA() const; }; // foo.cpp #include "foo.h" auto Foo::getA() const { return something; } // main.cpp #include "foo.h" int main() { Foo bar; auto a = bar.getA(); // ,    }</span></span></code> </pre><br>  So it will be possible to use it only with local functions or with functions defined in header files.  The latter, as a rule, include template functions - the main, in my opinion, application for this novelty. <br>  Restrictions defined in the standard include: a ban on using with virtual functions and a ban on returning an object of type <code>std::initializer_list</code> . <br><br><h4>  Generalized initialization of captured lambda variables with support for capture-by-movement </h4><br>  In C ++, lambdas do not support capture-by-move.  For example, the following code will not compile: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; #include &lt;utility&gt; template &lt;class T&gt; void run(T&amp;&amp; runnable) { runnable(); }; int main() { std::unique_ptr&lt;int&gt; result(new int{42}); run([result](){std::cout &lt;&lt; *result &lt;&lt; std::endl;}); }</span></span></span></span></code> </pre><br>  To move an object inside a lambda function, it was necessary to write some kind of wrapper, like an outdated auto_ptr. <br>  Instead of adding the ability to explicitly capture-by-move, it was decided to add support for generalized initialization of the captured variables.  For example, <br><pre> <code class="cpp hljs">[ x { move(x) }, y = transform(y, z), foo, bar, baz ] { ... }</code> </pre><br>  In this case, <code>x</code> will be directly initialized by moving <code>x</code> , <code>y</code> will be initialized by the result of the call <code>transform</code> , and the rest will be captured by value.  Another example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = [&amp;r = x, x = x+<span class="hljs-number"><span class="hljs-number">1</span></span>]()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { r += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+<span class="hljs-number"><span class="hljs-number">2</span></span>; }(); <span class="hljs-comment"><span class="hljs-comment">//  ::x  6,   y 7-.</span></span></code> </pre><br>  Explicit indication of the type of initialized captured variables is not prohibited: <br><pre> <code class="cpp hljs">[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = get_x()] { ... } [Container y{get_container()}] { ... } [<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">5</span></span>] { ... }</code> </pre><br>  Many may wonder why they simply do not support the following method: <br><pre> <code class="cpp hljs">[&amp;&amp;x] { ... }</code> </pre><br>  The problem is that we do not capture by the rvalue link, we are trying to move.  If we went this way, the movement could have happened much later, when the real object may no longer exist.  We have to move the object during the capture of variables, and not during the call to the lambda. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Generalized (polymorphic) lambda expressions </h4><br>  In C ++ 11, lambda expressions create objects of a class that has a non-generic function call operator.  This amendment proposes: <br><ul><li>  Allow use of an <code>auto</code> type specifier meaning a generic (template) lambda parameter </li><li>  Allow conversion from a lambda function, not capturing values, to the corresponding pointer-to-function </li></ul><br>  Thus, the same lambda template can be used in different contexts: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// #1 void g(char (*)(char)) { } // #2 void h(int (*)(int)) { } // #3 void h(char (*)(int)) { } // #4 auto glambda = [](auto a) { return a; }; f1(glambda); // OK f2(glambda); // : ID   g(glambda); // :  h(glambda); // OK:  #3,       ID int&amp; (*fpi)(int*) = [](auto* a) -&gt; auto&amp; { return *a; }; // OK</span></span></code> </pre><br>  Do not forget about the possibility of using, together with <a href="http://habrahabr.ru/post/157961/">universal links</a> and <a href="http://habrahabr.ru/post/101430/">templates, variable number of arguments (variadic templates)</a> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> vglambda = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; ... ts) { <span class="hljs-comment"><span class="hljs-comment">// OK: ts -     printer(std::forward&lt;decltype(ts)&gt;(ts)...); }; }; auto p = vglambda( [](auto v1, auto v2, auto v3) { std::cout &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; v3; } ); p(1, 'a', 3.14); // OK:  1a3.14</span></span></code> </pre><br><br><h4>  Simplified restrictions on creating <code>constexpr</code> functions </h4><br>  Changes made allow using <code>constexpr</code> functions: <br><ul><li>  Variable declaration (except <code>static</code> , <code>thread_local</code> and uninitialized variables) </li><li>  <code>if</code> and <code>switch</code> (but not <code>goto</code> ) </li><li>  <code>for</code> (including range-based <code>for</code> ), <code>while</code> and <code>do-while</code> </li><li>  Changing the state of objects that are the result of <code>constexpr</code> calculations </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) x = -x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; <span class="hljs-comment"><span class="hljs-comment">// OK } constexpr int first(int n) { static int value = n; // :   return value; } constexpr int uninit() { int a; // :   return a; } constexpr int prev(int x) { return --x; } // OK constexpr int g(int x, int n) { // OK int r = 1; while (--n &gt; 0) r *= x; return r; }</span></span></code> </pre><br>  In addition, the rule by which <code>constexpr</code> non-static member functions implicitly obtained the <code>const</code> specifier was removed (for more details, <a href="http://habrahabr.ru/post/184250/">click here</a> ). <br><br><h4>  Variable patterns </h4><br>  This feature allows you to create and use <code>constexpr</code> variable templates for more convenient combination with template algorithms (it is possible to use not only with built-in types, but also with user-defined types): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> T pi = T(<span class="hljs-number"><span class="hljs-number">3.1415926535897932385</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circular_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pi&lt;T&gt; * r * r; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matrix_constants</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pauli = hermitian_matrix&lt;T, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> pauli&lt;T&gt; sigma1 = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> pauli&lt;T&gt; sigma2 = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>i }, { <span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> pauli&lt;T&gt; sigma3 = { { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; };</code> </pre><br><br><h3>  Changes in the standard library </h3><br><h4> <code>exchange</code> </h4> <br>  Atomic (atomic) objects provide the <code>atomic_exchange</code> function, which allows you to assign a new value to the object and return its old value.  This function can be useful for ordinary objects. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   template&lt;typename T, typename U=T&gt; T exchange(T&amp; obj, U&amp;&amp; new_val) { T old_val = std::move(obj); obj = std::forward&lt;U&gt;(new_val); return old_val; }</span></span></code> </pre><br>  For priative types, this function does the same thing as the regular implementation.  For complex types, this function allows you to: <br><ul><li>  Avoid copying an old object if a motion constructor is defined for this type. </li><li>  Accept any type as a new value, taking advantage of using any converting assignment operator. </li><li>  Avoid copying a new object if it is temporary or has been moved here. </li></ul><br>  For example, the implementation of <code>std::unique_ptr::reset</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::reset(pointer p = pointer()) { pointer old = ptr_; ptr_ = p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old) deleter_(old); }</code> </pre><br>  can be improved to: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::reset(pointer p = pointer()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pointer old = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exchange(ptr_, p)) deleter_(old); }</code> </pre><br><br><h4> <code>make_unique</code> </h4> <br>  In C ++ 11, along with smart pointers, a function such as <code>make_shared</code> .  It allows you to optimize the allocation of memory for <code>shared_ptr</code> , as well as to increase security regarding exceptions.  Although a similar optimization for <code>unique_ptr</code> not possible, increased security with respect to exceptions never <code>unique_ptr</code> .  For example, here, in both cases, we can get a memory leak if an exception is thrown during the creation of one object, and the second object has already been created but not yet placed in <code>unique_ptr</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;A&gt; a, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;B&gt; b)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B); foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;A&gt;{<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A}, foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;B&gt;{<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B}); }</code> </pre><br>  To solve this situation, it was decided to add the function <code>make_unique</code> .  Thus, C ++ 14 almost completely (with the exception of very rare cases) suggests that programmers abandon the <code>new</code> and <code>delete</code> operators. <br>  Usage example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;memory&gt; using namespace std; void foo(std::unique_ptr&lt;string&gt; a, std::unique_ptr&lt;string&gt; b) {} int main() { cout &lt;&lt; *make_unique&lt;int&gt;() &lt;&lt; endl; cout &lt;&lt; *make_unique&lt;int&gt;(1729) &lt;&lt; endl; cout &lt;&lt; "\"" &lt;&lt; *make_unique&lt;string&gt;() &lt;&lt; "\"" &lt;&lt; endl; cout &lt;&lt; "\"" &lt;&lt; *make_unique&lt;string&gt;("meow") &lt;&lt; "\"" &lt;&lt; endl; cout &lt;&lt; "\"" &lt;&lt; *make_unique&lt;string&gt;(6, 'z') &lt;&lt; "\"" &lt;&lt; endl; auto up = make_unique&lt;int[]&gt;(5); for (int i = 0; i &lt; 5; ++i) { cout &lt;&lt; up[i] &lt;&lt; " "; } cout &lt;&lt; endl; foo(make_unique&lt;string&gt;(), make_unique&lt;string&gt;()); //    auto up1 = make_unique&lt;string[]&gt;("error"); //  auto up2 = make_unique&lt;int[]&gt;(10, 20, 30, 40); //  auto up3 = make_unique&lt;int[5]&gt;(); //  auto up4 = make_unique&lt;int[5]&gt;(11, 22, 33, 44, 55); //  } /* Output: 0 1729 "" "meow" "zzzzzz" 0 0 0 0 0 */</span></span></span></span></code> </pre><br><br><h4>  Detached lines </h4><br>  When using strings that include a space, with input / output streams, it is not always possible to get the expected results.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> original = <span class="hljs-string"><span class="hljs-string">"foolish me"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> round_trip; ss &lt;&lt; original; ss &gt;&gt; round_trip; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; original; <span class="hljs-comment"><span class="hljs-comment">// : foolish me std::cout &lt;&lt; round_trip; // : foolish assert(original == round_trip); // assert </span></span></code> </pre><br>  This amendment introduces into the standard a function that allows to handle such situations correctly by adding double quotes at the beginning and at the end of a line when writing and deleting them when reading.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> original = <span class="hljs-string"><span class="hljs-string">"foolish me"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> round_trip; ss &lt;&lt; quoted(original); ss &gt;&gt; quoted(round_trip); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; original; <span class="hljs-comment"><span class="hljs-comment">// : foolish me std::cout &lt;&lt; round_trip; // : foolish me assert(original == round_trip); // assert  </span></span></code> </pre><br>  If the string already contains quotes in itself, they will also be separated: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"She said \"Hi!\""</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : She said "Hi!" std::cout &lt;&lt; quoted("She said \"Hi!\""); // : "She said \"Hi!\""</span></span></code> </pre><br>  This amendment is based on a <a href="http://www.boost.org/doc/libs/1_53_0/libs/io/doc/quoted_manip.html">boost analog</a> . <br><br><h4>  Custom literals for standard library types </h4><br>  C ++ 11 introduces the concept of custom literals (PL), but not a single PL was defined for the standard library, although according to the standard, PL names that do not begin with an underscore are reserved for STL. <br>  The corresponding amendment adds the following custom literals to the standard: <br><ul><li>  <code>s</code> operator for <code>basic_string</code> </li><li>  Operators <code>h</code> , <code>min</code> , <code>s</code> , <code>ms</code> , <code>us</code> , <code>ns</code> for types included in chrono :: duration </li></ul>  For example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mystring = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>s; <span class="hljs-comment"><span class="hljs-comment">//  std::string auto mytime = 42ns; //  chrono::nanoseconds</span></span></code> </pre><br>  User literals <code>s</code> do not conflict, since they accept different types of parameters. <br><br><h4> <code>optional</code> </h4> <br>  This amendment introduces a new type in the standard library, meaning an optional object.  Possible uses: <br><ul><li>  Ability to specify which function parameters are optional </li><li>  Ability to use a null state (without using raw (pointers) </li><li>  The ability to manually control the lifetime of RAII objects </li><li>  Ability to skip expensive (standard) object constructors </li></ul><br>  Approximate method of use: <br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; str2int(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     ,   int get_int_form_user() { string s; for (;;) { cin &gt;&gt; s; optional&lt;int&gt; o = str2int(s); // 'o'    ,     if (o) { //   'o'  ? return *o; //   } } }</span></span></code> </pre><br>  This amendment is based on a <a href="http://www.boost.org/doc/libs/1_53_0/libs/optional/doc/html/index.html">boost analog</a> . <br>  A translation of the article by the author of this amendment on this class can be found <a href="http://habrahabr.ru/company/infopulse/blog/164037/">here</a> . <br><br><h4>  <code>shared_mutex</code> and <code>shared_lock</code> </h4><br>  When developing multi-threaded programs, it sometimes becomes necessary to give multiple objects read access or unique write access to some object.  This amendment adds to the standard <code>shared_mutex</code> library designed for this purpose.  The <code>lock</code> function provides unique access, and can be used with <code>lock_guard</code> and <code>unique_lock</code> previously added.  To get shared access, you need to use the <code>lock_shared</code> function, and it‚Äôs better to do this through the <code>shared_lock</code> / RAII class <code>shared_lock</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; shared_mutex rwmutex; { shared_lock&lt;shared_mutex&gt; read_lock(rwmutex); <span class="hljs-comment"><span class="hljs-comment">//  } { unique_lock&lt;shared_mutex&gt; write_lock(rwmutex); //  lock_guard //  }</span></span></code> </pre><br>  It is worth noting that the cost of any lock, even for reading, is more expensive than using a regular mutex. <br>  This amendment is based on a <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/thread/synchronization.html">boost analog</a> . <br><br><h4> <code>dynarray</code> </h4> <br>  In the current standard C, there are dynamic arrays whose size can only be determined at run time.  Like ordinary arrays, their data is created on the stack.  C ++ 14 claims such arrays, but at the same time it also defines its own kind of dynamic array - <code>std::dynarray</code> , which also recognizes its size at run time and cannot change it further, however, it can either place objects on the stack, or place them in a heap, while having an interface in many ways similar to <code>std::array</code> and <code>std::vector</code> .  According to the amendment, this class can be explicitly optimized by the compiler, for use cases of the stack. <br><br><h3>  Conclusion </h3><br>  Basically, C ++ 14 is positioned as a minor bug-fix release, correcting C ++ 11 flaws, due to time constraints or for some other reason.  The current draft standard C ++ can be found <a href="http://isocpp.org/files/papers/N3690.pdf">here</a> . <br><br>  <b>UPDATE:</b> <br>  <code>dynarray</code> and <code>optional</code> have been moved to separate technical specifications. <br>  <a href="http://habrahabr.ru/post/198238/">Overview of the new features of C ++ 14: Part 2</a> </div><p>Source: <a href="https://habr.com/ru/post/184606/">https://habr.com/ru/post/184606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184594/index.html">Distribution of servers from the orange dude</a></li>
<li><a href="../184596/index.html">About the features of the location of controls in mobile applications</a></li>
<li><a href="../184598/index.html">We work with relational data using Backend-as-a-Service</a></li>
<li><a href="../184600/index.html">Mr. Big - Xperia Z Ultra Announcement</a></li>
<li><a href="../184602/index.html">SmartWatch 2 - even smarter!</a></li>
<li><a href="../184610/index.html">Computer vision allows you to see the pulse of a person, even if he wears a mask</a></li>
<li><a href="../184612/index.html">Portal under Linux came out</a></li>
<li><a href="../184614/index.html">The use of procedural generators in creating content for real-time 3D applications: Part 2. Valley Benchmark</a></li>
<li><a href="../184618/index.html">Armikrog - 50 hours to</a></li>
<li><a href="../184620/index.html">Game console Ouya went on sale for 99 dollars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>