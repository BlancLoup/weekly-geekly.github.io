<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>KTV. Rake on the way to marshaling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wrote about KTV , but one thing is to come up with something incomprehensible, another is to try using it. In addition to the S2 style system, I pla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>KTV. Rake on the way to marshaling</h1><div class="post__text post__text-html js-mediator-article">  I <a href="https://habrahabr.ru/post/278763/">wrote about KTV</a> , but one thing is to come up with something incomprehensible, another is to try using it.  In addition to <a href="https://habrahabr.ru/post/278787/">the S2 style system,</a> I plan to use KTV to work with the server instead of JSON.  I have no plans to conquer the world, but I want to figure out whether it was more convenient or not.  In order to communicate easily, you need to be able to parse objects from ktv-files, and serialize them back to them. <br><br>  Swift, for which I am writing this, at the moment (Swift 2.x), is not intended for dynamic parsing at all, not at all, in general.  So I had to think of something a bit strange and unusual.  After that, this strange and non-standard needed to be implemented. <br><br>  In the process, there was an incalculable number of rakes, about which I will tell.  Maybe someone will laugh at the insensible me, maybe they will help someone to avoid similar things - I don't know.  I was helpful to understand. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If anyone sees how easy or better to solve these problems, write.  I am pleased to learn more options, since all that are listed below, to one degree or another, are crutches.  Suddenly there is something more pleasant. <br><a name="habracut"></a><br><h2>  How to get the structure of the object? </h2><br>  The first task that arises if we want to convert what has come across the network into a native object (in my case of the Swift language) is to deal with the structure of the object.  Recalling the Java experience (where two hundred libraries have already been written for each sneeze), I went through several methods. <br><br><h4>  Introspection of language objects </h4><br>  Reflection, runtime or at least something similar.  In Swift, there are two directions that develop in this direction: <br><br><ul><li>  <a href="http://appventure.me/2015/10/24/swift-reflection-api-what-you-can-do/">Mirror class</a> .  This is the thing that the debugger or Playgrounds use to display information about objects.  Accordingly, the information that they need: type, field name, value, generic.  There are no access parameters (private / public), there are no annotations, and the method itself is not defined for all objects. </li><li>  <a href="http://nshipster.com/mirrortype/">The function reflect</a> , which returns exactly the same data in a slightly different format. </li></ul><br>  Most likely, both of these methods converge somewhere in one, and therefore the result is similar.  This method is the coolest if you can use it.  Alas, it now works only for reading, there is no record in any form.  We are waiting for the expansion of "mirrors", go to the next method. <br><br><h4>  Source code parsing  Sourcekit </h4><br>  The next way is to parse the source itself, in which, obviously, everything that is possible is indicated.  It would be extremely difficult if Apple did not provide SourceKit.  What is SourceKit?  This is a framework (sourcekitd.framework) that can perform queries like "proparsi, please, this file, and tell what you see there in the form of a syntax tree (Abstract Syntax Tree AST)."  It is extremely useful that SourceKit is also able to parse documentation to elements of a language, and not just identifiers and types. <br><br>  In addition to the framework itself, SourceKitten lives on <a href="https://github.com/jpsim/SourceKitten">Github</a> , which provides an interface on Swift to sourcekitd.framework.  Using it is very simple: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sourceKitFile = <span class="hljs-type"><span class="hljs-type">File</span></span>(path:classFileName) <span class="hljs-comment"><span class="hljs-comment">//   let structure = Structure(file:sourceKitFile!).dictionary //  AST</span></span></code> </pre> <br>  True, in order to connect both sourcekitd.framework and SourceKitten, I had to get involved.  It turned out something like this: <br><br><ul><li>  download, source SourceKitten source code </li><li>  Do not forget the dependency, SWXMLHash.swift </li><li>  connect sourcekitd.framework and libclang.dylyb </li><li>  Write a Bridging-Header in which to include the necessary headers: <br><pre> <code class="hljs scala">#<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"Index.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"Documentation.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"CXCompilationDatabase.h"</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"sourcekitd.h"</span></span></code> </pre> </li></ul><br>  After that, the lines above will work.  After receiving the AST, the job is only to interpret it correctly (for this I wrote a class and structure with different fields and ran it, checked what SourceKit would give me. I managed to pull out the object types (though only if they are spelled explicitly, inferrence is not supported), and access modifiers, and understand where constants are, where they are not, and take generics from ordinary and associative arrays. <br><br>  In addition, SourceKit also provides documentation for the code element.  Here, however, is also not without a rake: <br><br><ul><li>  for some reason, my <code>Structure(file:String)</code> does not show documentation (and there are not enough types inside the documentation structure), to see it, you need to execute another command: <br>  let structureWithDocs = SwiftDocs (file: sourceKitFile! arguments: [classFileName]) ?. docsDictionary </li><li>  behavior is not very deterministic.  For example, if you <code>@name</code> in the comment, it disappears from AST.  Maybe there are some other secret words, I don't know. </li></ul><br>  Well, got the structure, what to do next? <br><br><h2>  Work with structure </h2><br>  There are three ways to work with the structure: <br><br><ul><li>  generate code at the compilation stage, which will marshal objects. </li><li>  write a common code, which (usually again using reflex or other introspection method) directly in the process of execution puts the necessary values ‚Äã‚Äãinto the fields of the objects and takes them, producing a format for transmission. </li><li>  generate marshaling code right in the execution process. </li></ul><br>  The second method disappears because the mirrors in Swift do not know how to write anything to objects.  The third method is very cool, but with no chance at all (unlike Java, where you can generate bytecode on the fly), only the first remains.  That is, according to the structure, we need to create methods that will receive KTV or JSON as input, producing the necessary, filled object, or vice versa, receiving text in KTV or JSON formats from the object. <br><br>  It is not necessary to generate the code in any way (just took and assigned values ‚Äã‚Äãto the fields): <br><br><ul><li>  you need to work with all sorts of checks (including optional types, for example), </li><li>  be able to work with nested objects (class hierarchies) </li><li>  be able to customize (at least I'll fix it on a field with a different name) </li><li>  be able to use custom parsers / serializers (for example, if a date comes in a non-standard format) </li><li>  be able to generate code that is accessible from Objective-C, and not just from Swift. </li></ul><br>  There are many tasks, and in order to solve them all, I had to be seriously confused. <br><br><h4>  Stage 1. Just assignments </h4><br>  Before analyzing the code, let's see what we actually do.  We have a model class that should create a bunch of model objects using data from a KTV file.  The diagram represents the participants.  Scheme as work a little more complicated. <br><img src="https://habrastorage.org/files/c6a/6e4/380/c6a6e4380fbf480291082cb70d54232c.png" alt="image"><br><br>  How to do it in the simplest case?  Let's start by learning how to pull data from a KTV object.  Read the file - we have already read and saved to the KTV object, which in its structure is a bit like the associative array returned by <code>NSJSONSerialization</code> . <br><br>  So, you need to write a function (or functions) that would pull a value out of KTV by key, and then assign it to property.  The only difficulty was that the values ‚Äã‚Äãare Optional, and there are many different types.  We analyze the steps. <br><br>  First, we write a method that pulls a KTV value using an arbitrary key.  In this case, the links are resolved, mixins are taken into account.  I got something like that.  I also use this method to get the link text in S2, so we return a tuple. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueAndReferenceForKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key:String, resolveReferences:Bool = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; (value:<span class="hljs-type"><span class="hljs-type">KTVValue?</span></span>, reference:<span class="hljs-type"><span class="hljs-type">String?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result:<span class="hljs-type"><span class="hljs-type">KTVValue?</span></span> = properties[key] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference:<span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result_ = result { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result_ { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .reference(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> link): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> resolveReferences || link.hasPrefix(<span class="hljs-string"><span class="hljs-string">"~"</span></span>) { result = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> findObjectByReference(link) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> reference = link .stringByReplacingOccurrencesOfString(<span class="hljs-string"><span class="hljs-string">"@"</span></span>, withString:<span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result, reference) }</code> </pre> <br>  After that, I thought it was worth writing a generalized method that I can call to get values ‚Äã‚Äãof different types. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">specificValueForKey</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key:String, defaultValue:T?, resolveReferences:Bool, valueResolver:</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(value:KTVValue)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; (value:<span class="hljs-type"><span class="hljs-type">T?</span></span>, reference:<span class="hljs-type"><span class="hljs-type">String?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (resultValue, reference) = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> valueAndReferenceForKey(key, resolveReferences:resolveReferences) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = defaultValue <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result_ = resultValue { result = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> valueResolver(value:result_) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result, reference) }</code> </pre> <br>  Here the only interesting part is the resolver, which is able to get a value of a particular type from the KTV value.  When this method is written, you can either use it directly, or write a few wrappers for standard types, to make it easier to use. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key key:String, defaultValue:String? = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> specificValueForKey(key, defaultValue:defaultValue, resolveReferences:<span class="hljs-literal"><span class="hljs-literal">true</span></span>, valueResolver:<span class="hljs-type"><span class="hljs-type">KTVValue</span></span>.stringResolver).value }</code> </pre> <br>  I use another generalized method to work uniformly with optional types. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deoptionizeValue</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:T?, defaultValue:T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value_ = value { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value_ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultValue } }</code> </pre> <br>  As a result, the parser consists of very simple blocks, each of which is dedicated to one property. <br><br><pre> <code class="hljs lisp">stringProperty = deoptionizeValue(<span class="hljs-name"><span class="hljs-name">value</span></span><span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>(<span class="hljs-name"><span class="hljs-name">key</span></span>:<span class="hljs-string"><span class="hljs-string">"key"</span></span>), defaultValue:<span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br>  Objects have to be dealt with a little less conveniently, but from the point of view of tricks, it is quite obvious.  I did something like this: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let object_ = getGeneralObject(name:<span class="hljs-string"><span class="hljs-string">"object"</span></span>, ktv:ktv) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">ChildObject</span></span>(ktvLenient:object_) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span></span>= nil }</code> </pre> <br><h4>  Stage 2. Dates, study </h4><br>  The next task that required a solution was date formatters.  There may also be several solutions. <br><br>  Use special model class methods to format fields.  I used this option in Objective-C version of the same, and it worked well.  The problem is only in the separation of the declaration of the field and its parameters.  It is inconvenient, you constantly forget, or you forget to correct, if the name has been changed to peperti.  Plus, there is still a problem with structures. <br><br><blockquote>  The fact is that the structures have an automatically created initializer with the names of all the fields.  This is convenient, and, given the semantics of this type, it is economical.  If we want to use some methods of an object or class, then we need to use <code>self</code> , which requires initialization before the call.  Therefore, the structure needs the (empty) default <code>init()</code> .  This is an extra code that needs to be written in each model class / in each structure (it cannot be generated, it should be in the main class) and which will also always be forgotten. </blockquote><br>  Use special classes, or stupid, as the types of property model class.  That is, not String, but MappedString.  This allows them to be configured (right at creation), for example, like this: <code>var property:MappedDate = MappedDate(format:'dd-MM-yyyy')</code> , and you can use their methods for serializing / parsing values.  You can use tuples instead of a class, it looks absolutely monstrous, but it also works.  This solution has a lot of minuses, the main one - to access the perperty, you will need to somehow dodge ( <code>object.property.value</code> , for example).  Well, recording wildly. <br><br>  Use mappers.  Having tried the above options, I came to just that. <br><br><h4>  Stage 3. Custom mappers </h4><br>  Mapper, I call a class that knows how a certain type is converted from / to KTV.  You can send KTV-value to it so that it returns the real type ( <code>String</code> , <code>NSDate</code> , ...), and vice versa, you can return the type so that it returns KTV-value (for serialization). <br><br>  Normal mapper we have already implemented a couple of sections back, for the line.  In principle, you can wrap this code in a class, and then choose classes depending on the type of property.  At this point, it turns out an interesting feature of Swift. <br><br>  The fact is that in the end, we need some kind of <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory</a> , which by type (by line or by class) will produce the desired object.  It would be nice if this factory would issue a generalized object.  Then there will be no ghosts, and the call logic will be as simple as possible, somehow <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stringMapper:Mapper&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = mapper.getFor(<span class="hljs-string"><span class="hljs-string">"String"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value:<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = stringMapper.valueFromKTV(ktvValue)</code> </pre> <br>  The problem is how to make this method <code>func getFor&lt;T&gt;(className:String) -&gt; Mapper&lt;T&gt;</code> .  Due to the peculiarities of generics in the protocols (more precisely, their absence, associative types are used instead), for example, it is impossible to make an array of generalized objects.  That is, it cannot be this way (it doesn‚Äôt matter whether you specify the generic type or not) <code>var mappers:\[Mapper] = \[]</code> .  The array must already have specific types. <br><br>  As a result, I had to cheat a little.  The array of mappers inside the factory had to be made up of some kind of common non-generic protocol ‚Äî the parent of all mappers.  One could just make an <code>AnyObject</code> array, but somehow it does not work out well. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KTVModelAnyMapper</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KTVModelMapper</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MappingType</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KTVModelAnyMapper</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KTVModelMapperFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _mappersByType = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">KTVModelAnyMapper</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type:String, propertyName:String)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">KTVModelMapper</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapper = _mappersByType[propertyName] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">KTVModelMapper</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapper } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-type"><span class="hljs-type">KTVModelObjectParseableError</span></span>.<span class="hljs-type"><span class="hljs-type">CantFindTypeMapper</span></span> } } }</code> </pre> <br>  I did not invent a solution without a cast.  Maybe someone from the readers tell? <br><br>  As a result, the parser code was like this: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mappers = <span class="hljs-type"><span class="hljs-type">KTVModelMapperFactory</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { _stringOrNil = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> mappers .mapper(<span class="hljs-string"><span class="hljs-string">"String"</span></span>, propertyName:mappers.ktvNameFor(<span class="hljs-string"><span class="hljs-string">"stringOrNil"</span></span>)) .parseOptionalValue(ktv[<span class="hljs-string"><span class="hljs-string">"stringOrNil"</span></span>], defaultValue:_stringOrNil) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { errors[<span class="hljs-string"><span class="hljs-string">"stringOrNil"</span></span>] = error }</code> </pre> <br>  The beauty of this solution is that for each model class you can substitute your factory, and thus control how the ktv values ‚Äã‚Äãare mapped into the object. <br><img src="https://habrastorage.org/files/0d6/abd/a95/0d6abda95efb44789a325b9ae98fd1c2.png" alt="image"><br><br>  The question remains, how to set this custom factory for a model object?  I came up with two options: <br><br><ul><li>  Use the custom protocol.  In the name of the protocol, encode the name of the custom factory, and in the process of creating the parser extension, pull out the name by the SourceKit, from there the name of the factory, and connect when parsing.  The solution is working, I checked, but terribly crooked. </li><li>  No less crooked decision (I don‚Äôt know any good ones at all), but at least beautiful - the use of comments. </li></ul><br><h4>  Stage 4. Annotations in the comments </h4><br>  The fact is that, in addition to information about classes and structures, SourceKit also provides comments tied to elements.  The ones from which documentation is then obtained, starting with <code>///</code> or <code>/** */</code> .  Thus, there you can stuff anything, parse it anything as you like, and do what we want.  It is clear that no typing here and does not smell, writing - solely on the conscience of the developer, but, having tried all of the above methods (and a couple more very nightmarish), it turns out that this is the most adequate. <br><br>  It looks like a comment with a custom factory for a model class like this: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @mapper = RootObjectMapperFactory public struct <span class="hljs-symbol"><span class="hljs-symbol">RootObject:</span></span> KTVModelObject { ... }</code> </pre> <br>  And so, for example, you can control the name of the property in KTV: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @ktv = __date_<span class="hljs-number"><span class="hljs-number">_</span></span> var <span class="hljs-symbol"><span class="hljs-symbol">date:</span></span>NSDate</code> </pre> <br>  However, in this place the possibilities are endless, since we are moving away from Swift and starting to just parse arbitrary text.  You can set the date formats, you can - an arbitrary code that will then fit into the parser or serializer. <br><br><h2>  Result, conclusions </h2><br>  Swift is still a bad language for ‚Äúmagic‚Äù libraries.  That is, those in which you put something simple, it is brewed there and given another simple and beautiful.  At the same time, from the developer‚Äôs side, ‚Äúnothing needs to be done‚Äù (supposedly).  This type of library is always the most difficult, but it shows the power of the platform.  This is Hibernate, this is Rails, this is CoreData, and so on.  On Swift, writing this now is insanely difficult and only SourceKit reduces the complexity to acceptable, it would not exist, we would have to parse the classes with our hands, which, to put it mildly, is ungrateful. <br><br>  However, as charging for the mind, this code turned out to be great.  I did not find so many rakes in one place for a long time.  You can touch what happened here: <a href="https://github.com/bealex/KTV">https://github.com/bealex/KTV</a> This is a very live, non-production code where I learn how to work with Swift, so please treat it as well. <br><br>  I hope you will be interested.  If suddenly there are questions - ask! <br></div><p>Source: <a href="https://habr.com/ru/post/279109/">https://habr.com/ru/post/279109/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279099/index.html">Forecasts for the gaming market: figures from 7 analytical agencies</a></li>
<li><a href="../279101/index.html">Say a word about poor XWiki - 2</a></li>
<li><a href="../279103/index.html">Easy to deploy Meteor applications to your own server</a></li>
<li><a href="../279105/index.html">Containers: The quest for the "magic framework" and why it became Kubernetes</a></li>
<li><a href="../279107/index.html">1.3 SFML and Linux</a></li>
<li><a href="../279111/index.html">C ++ exception handling under the hood or how exceptions work in C ++</a></li>
<li><a href="../279113/index.html">Observation of internationalized domain names and the letter K</a></li>
<li><a href="../279117/index.html">Linear models: simple regression</a></li>
<li><a href="../279123/index.html">Superscalar stack processor: we continue to cross the grass and the hedgehog</a></li>
<li><a href="../279125/index.html">Dagger 2. Part One. Basics, creating a dependency graph, Scopes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>