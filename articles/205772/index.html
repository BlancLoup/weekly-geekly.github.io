<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SFINAE is just</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TLDR : how to determine if a type has a method with a given name and signature, as well as to recognize other properties of types, without going crazy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SFINAE is just</h1><div class="post__text post__text-html js-mediator-article">  <u>TLDR</u> : <i>how to determine if a type has a method with a given name and signature, as well as to recognize other properties of types, without going crazy.</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c5/33e/a40/4c533ea40b63346a50df2484ef60833b.jpg" alt="image"></div><br>  Hello colleagues. <br>  I want to talk about SFINAE, an interesting and very useful (unfortunately *) mechanism of the C ++ language, which, however, may seem to the unprepared person to be very brain-breaking.  In fact, the principle of its use is quite simple and clear, being formulated in the form of several clear provisions.  This article is intended for readers who have a basic knowledge of patterns in C ++ and are familiar, at least briefly, with C ++ 11. <br>  <b>*</b> <i>Why unfortunately?</i>  <i>Although the use of SFINAE is an interesting and beautiful technique that has grown into a widely used idiom of a language, it would be much better to have means explicitly describing work with types.</i> <a name="habracut"></a><br><br>  First, just in case, I will very briefly talk about metaprogramming in C ++.  Metaprogramming is the operations performed during the compilation of a program.  Just as ordinary functions allow you to get values, types and compile-time constants are obtained using meta-functions.  One of the most popular uses of metaprogramming, although far from the only thing, is recognizing type properties.  All this, of course, is used in the development of templates: it is sometimes useful to know, we are dealing with a complex user class with a non-trivial constructor or with a normal <b><code>int</code></b> , somewhere it is necessary to establish whether one type is inherited from another, or whether one can be converted type in another.  We will consider the mechanism of applying SFINAE in a classic example: checking whether a function member exists in a class with given types of arguments and a return value.  I will try in detail and in detail to go through all the stages of creating a verification metafunction and to trace where it comes from. <br><br>  The abbreviation SFINAE stands for <i>substitution failure is not an error</i> and means the following: when defining overloads of a function, erroneous instantiations of templates do not cause a compilation error, but are discarded from the list of candidates for the most appropriate overload.  Humanly, this means: <br><ul><li>  When it comes to SFINAE, this is necessarily due to overloading of functions. </li><li>  This works with automatic output of template types (type deduction) by function arguments. </li><li>  Some overloads can be discarded when they cannot be instantiated due to a syntax error that occurs;  the compilation continues as if nothing had happened, without errors. </li><li>  Discard can only template. </li><li>  SFINAE considers only the function header; errors in the function body will not be missed. </li></ul><br>  It turns out that we have the ability to manipulate the overloads of a function, hiding some of them, if necessary, by creating artificial errors.  In this case, the hidden candidate must be a template, and the fact of an error must depend on the parameter of this template.  Other types of errors can be detected by the compiler without substitution, barely seeing the definition of the template itself, and SFINAE will fail, and instead we will be hurt. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider a simple example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">difference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val1 - val2; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::<span class="hljs-function"><span class="hljs-function">difference_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">difference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; val1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; val2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val1 - val2; }</code> </pre> <br>  The <code>difference</code> function works great for integer arguments.  But with custom data types, subtleties begin.  The result of the subtraction is not always of the same type as the operands.  So, the difference of two dates is the time interval, which itself is not a date.  If the custom type <code>MyDate</code> has a <code>typedef MyInterval difference_type;</code> definition inside it <code>typedef MyInterval difference_type;</code>  and the subtraction <code>MyInterval operator - (const MyDate&amp; rhs) const;</code>  , the template overload is applicable to it.  Calling the <code>difference(date1, date2)</code> will be able to ‚Äúsee‚Äù both the template overload, and the version accepting an <b><code>int</code></b> , while the template overload will be considered more suitable. <br>  The <code>MyString</code> type, in which there is no <code>difference_type</code> , during substitution will cause an error: the function would return a non-existent type.  Calling the <code>difference</code> with arguments of type <code>MyString</code> can only ‚Äúsee‚Äù the <b><code>int</code></b> version of the function.  This single version will be sufficiently suitable only if the conversion operator to a number is defined in <code>MyString</code> .  The construction of <code>val1 - val2</code> requires a binary minus operator and can also generate a syntax error.  It turns out that the template function <code>difference</code> checks the type of the argument for the simultaneous fulfillment of three conditions at once: the presence of a <code>difference_type</code> , the presence of a subtraction operator and the possibility of reducing the result of a subtraction to the type <code>difference_type</code> (conversion is implied by the <b><code>return</code></b> operator).  But while for types that violate the first condition, this overload is not visible, violation of the second or third condition will cause a compilation error. <br><br>  Let us try to figure out how to make a metafunction that tells us if there is a <code>void foo(int)</code> method in some type.  Caring STL, especially starting with version C ++ 11, has already identified many useful <a href="http://en.cppreference.com/w/cpp/types"><code>type_traits</code></a> for us, which are mainly located in <a href="http://en.cppreference.com/w/cpp/types"><code>type_traits</code></a> and <a href="http://en.cppreference.com/w/cpp/header/limits"><code>limits</code></a> headers, but for some reason it is precisely what we boldly planned to do.  Metafunction usually looks like a template structure without data, within which the result of an operation is defined: a type specified through <b><code>typedef</code></b> with the name <code>type</code> or a static constant <code>value</code> .  This agreement adheres to the STL, and we don‚Äôt have any reasons to be original, therefore we will adhere to the established pattern. <br><br>  You can immediately write the "skeleton" of our future metafunction: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_foo</span></span></span><span class="hljs-class">{</span></span>};</code> </pre> <br>  It determines the <i>presence of a</i> method, from which it is immediately clear that the result should have a Boolean type: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_foo</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,   ,     "". };</span></span></code> </pre> <br>  And now we need to figure out how to make an overload, which determines the type properties we need, and how to get a boolean constant from it.  The beauty is that we don‚Äôt need to give bodies to overloads: since all the work is done in compilation mode due to type manipulations, just ads will suffice. <br>  Obviously, we want our metafunction to be applicable for any type.  After all, about any type, you can tell if there is a desired method in it.  This means that <code>has_foo</code> should not cause compilation errors, no matter what parameter we set up.  And an error will occur if it suddenly turns out that it turns out that we need two overloads of one test function.  One of them, the ‚Äúdetector‚Äù, should be syntactically correct only for types that contain the desired method.  The other, the ‚Äúsubstrate,‚Äù must be omnivorous, that is, be sufficiently suitable for any substituted types.  At the same time, the ‚Äúdetector‚Äù should have a distinct advantage in ‚Äúsuitability‚Äù over the ‚Äúsubstrate‚Äù.  The least priority and, at the same time, the most omnivorous in determining overloads is ellipsis (a three-dot designating a variable number of arguments): <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_foo</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ""  . static constexpr bool value = true; // -,   ! };</span></span></code> </pre> <br>  Now we need to declare a ‚Äúdetector‚Äù.  It must be a template: it is not enough that it is already inside a template structure!  Need a template inside the template [for a few seconds, enjoy the approving views from the characters of the film <a href="">Inception</a> ].  This does not apply to the ‚Äúsubstrate‚Äù, since we will never throw it out.  But for the ‚Äúdetector‚Äù we will use the magic word <a href="http://en.cppreference.com/w/cpp/language/decltype"><b><code>decltype</code></b></a> , which determines the type of expression, and the expression itself is not calculated and is not translated into code.  Let's substitute as an expression a call for that method, with arguments of the desired type.  Then the <b><code>decltype</code></b> answer is the return type of the method.  And if there is no method with the same name, or it accepts other types of arguments, then we will get the very controlled error that we wanted.  Let the ‚Äúdetector‚Äù return the same as <code>foo</code> : <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_foo</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(U().foo(<span class="hljs-number"><span class="hljs-number">42</span></span>)) detect(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> U&amp;); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ! };</span></span></code> </pre> <br><br>  If we pass a reference to <code>const T&amp;</code> to <code>detect</code> , it turns out that <code>U</code> is the same type as <code>T</code>  To check the conformity of the return type, we will later refine the detector or think of something else along the way. <br>  But wait!  We call the method on a newly constructed anonymous object, and it is constructed by default.  And what will happen if we <code>has_foo</code> type in <code>has_foo</code> that does not have a default constructor?  Of course, a compilation error.  It would be more correct to declare any function that returns a value of the desired type.  It will not be called anyway, and the desired effect will be achieved.  STL took care of this: in the header of the <code>utility</code> there is a <a href="http://en.cppreference.com/w/cpp/utility/declval"><code>declval</code></a> function: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_foo</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;U&gt;().foo(<span class="hljs-number"><span class="hljs-number">42</span></span>)) detect(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> U&amp;); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ! };</span></span></code> </pre> <br><br>  It remains only to learn to distinguish the "substrate" from the "detector".  Here all the same <b><code>decltype</code></b> will help us.  The ‚Äúsubstrate‚Äù type of the return value is always <b><code>void</code></b> , and the ‚Äúdetector‚Äù - the type returned by the method, that is, in the case when the method meets our requirements ... the same <b><code>void</code></b> .  Will not work.  Let's change the type for <b><code>int</code></b> to ‚Äúsubstrate‚Äù.  Then the check is simple: if the call to <code>detect</code> on the object <code>T</code> is of type <b><code>void</code></b> , then the ‚Äúdetector‚Äù worked and the method fully complies with our requirements.  If the type is different, then either the ‚Äúsubstrate‚Äù has worked, or the method exists, accepts those very arguments, but returns something wrong.  We check how carefree STL is, and right there we find the type checking <a href="http://en.cppreference.com/w/cpp/types/is_same"><code>is_same</code></a> for <a href="http://en.cppreference.com/w/cpp/types/is_same"><code>is_same</code></a> equality: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_foo</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//     . static int detect(...); //     . template&lt;typename U&gt; static decltype(std::declval&lt;U&gt;().foo(42)) detect(const U&amp;); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; //  , . };</span></span></code> </pre> <br>  Hooray, we have achieved the desired.  As you can see, everything is really quite simple.  We pay tribute to those programmers who managed to do this focus in the harsh conditions of the previous standard, much more verbose and clever because of the lack of such useful things as <b><code>declval</code></b> . <br><br>  SFINAE is used so widely that even in the caring STL, the special meta-function <a href="http://en.cppreference.com/w/cpp/types/enable_if"><code>enable_if</code></a> included.  Its parameters are a Boolean constant and a type ( <b><code>void</code></b> by default).  If <b><code>true</code></b> passed, then the type is present in metafunction: the one that is passed in the second parameter.  If <b><code>false</code></b> passed, then there is no <code>type</code> there, which creates that very controlled error.  In the light of the considerations listed above in a neat list, it must be remembered that <code>enable_if</code> can ‚Äúcross out‚Äù the function overload only if it is a template, and also take care that the list of uncrowded overloads never remains completely empty.  You can use <code>enable_if</code> in specializations of the template class, but in this case it is no longer SFINAE, but something like <a href="http://en.cppreference.com/w/cpp/language/static_assert"><b><code>static_assert</code></b></a> . <br><br>  In conclusion, I want to focus on the fact that the potential of using this mechanism is much broader than the verification of type properties.  You can use it directly for its intended purpose, creating optimized overloads of functions and methods: with random access iterators, for example, you can afford more liberties than with consecutive iterators.  And if you wish, you can come up with much more bizarre designs, <s>especially if your last name is Alexandrescu</s> .  Proceeding from the basic principles set forth in this note, you can create a powerful, flexible and reliable code that can adapt itself on the fly to the features of the types used. </div><p>Source: <a href="https://habr.com/ru/post/205772/">https://habr.com/ru/post/205772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205758/index.html">Dell VRTX is coming to us!</a></li>
<li><a href="../205762/index.html">Launch Ubuntu and watch Torrent and Torrent-TV straight on Samsung SmartTV</a></li>
<li><a href="../205764/index.html">How to deal with memory leaks in a virtual machine, correctly closing the browser</a></li>
<li><a href="../205766/index.html">SkyDrive in Windows 8.1: a stumbling block. Disable the SkyDrive service</a></li>
<li><a href="../205768/index.html">Video recording of Microsoft product training seminars (Office365, System Center 2012 and Windows Server 2012)</a></li>
<li><a href="../205774/index.html">BioPen's surgical 3D printer allows you to ‚Äúprint‚Äù tissue right during the operation.</a></li>
<li><a href="../205778/index.html">Share unprecedented generosity. 6 months subscription COLT for free. There are 2 days left</a></li>
<li><a href="../205780/index.html">Create your AppStore for distribution by iOS Enterprise Distribution</a></li>
<li><a href="../205786/index.html">The fifth issue of TsODY.RF magazine</a></li>
<li><a href="../205790/index.html">Finding the best position when comparing digitized images</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>