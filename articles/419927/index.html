<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[DotNetBook] Exceptions: type system architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this article, I continue to publish a series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole. Fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[DotNetBook] Exceptions: type system architecture</h1><div class="post__text post__text-html js-mediator-article"><p><img width="350" src="https://habrastorage.org/webt/34/ua/e6/34uae6usmglyw10vxga3sgfgh8c.jpeg" align="left">  With this article, I continue to publish a series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole.  For links - welcome under cat. </p><br><h2 id="arhitektura-isklyuchitelnoy-situacii">  Exception Architecture </h2><br><p> Probably one of the most important issues related to the topic of exceptions is the issue of building an exception architecture in your application.  This question is interesting for many reasons.  As for me, the main thing is the apparent simplicity with which it is not always obvious what to do.  This property is inherent in all basic constructs that are used everywhere: they are <code>IEnumerable</code> , <code>IDisposable</code> and <code>IObservable</code> and others-others.  On the one hand, with their simplicity they attract, involve themselves in using in a variety of situations.  On the other hand, they are full of whirlpools and fords, from which, without knowing how, sometimes, they will not get out at all.  And, perhaps, looking at the future volume, the question has matured: so what is this about in exceptional situations? </p><br><blockquote>  This article is the first of four in a series of articles about exceptions.  Full cycle: <br>  - <a href="https://habr.com/post/419927/">Type system architecture</a> (this article) <br>  - Events about exceptional situations <br>  - Types of exceptional situations <br>  - Serialization and processing units <br></blockquote><br><blockquote><h3>  Note </h3><br>  The chapter published on Habr√© is not updated and it is possible that it is already somewhat outdated.  So, please ask for a more recent text to the original: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub, table of contents</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="">GitHub, chapter</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 of the book, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><a name="habracut"></a><br><p>  But in order to come to some conclusions regarding the construction of the architecture of classes of exceptional situations, we need to save some experience with you regarding their classification.  After all, only by understanding what we will deal with, how and in what situations a programmer should choose the type of error, and in which - make a choice regarding interception or omission of exceptions, it can be understood how to build a type system so that it becomes obvious to your user. code.  Therefore, let us try to classify exceptional situations (not the types of exceptions themselves, but the situations themselves) according to various criteria. </p><br><h3 id="po-teoreticheskoy-vozmozhnosti-perehvata-proektiruemogo-isklyucheniya">  By the theoretical possibility of intercepting a projected exception </h3><br><p>  According to the theoretical interception, exceptions can be easily divided into two types: those that will intercept precisely and those that will not intercept with a high degree of probability.  Why <em>with a high degree of probability</em> ?  Because there is always someone who tries to intercept, although it did not have to do it at all. </p><br><p>  Let us first discuss the features of the first group: exceptions that should and will intercept. </p><br><p>  When we introduce an exception of this type, then on the one hand we inform the external subsystem that we have entered a situation where further actions within our data do not make sense.  And on the other hand, we mean that nothing global was broken and if we were removed, then nothing would change, and therefore this exception can be easily intercepted to remedy the situation.  This property is very important: it determines the criticality of the error and the belief that if you catch the exception and simply clear the resources, you can safely execute the code further. </p><br><p>  The second group, however strange it may sound, is responsible for exceptions that are not necessary to intercept.  They can only be used to write to the error log, but not to be able to somehow correct the situation.  The simplest example is the <code>ArgumentException</code> and <code>NullReferenceException</code> group exceptions.  After all, in a normal situation, you should not, for example, catch the <code>ArgumentNullException</code> exception because the source of the problem here will be you, and not anyone else.  If you intercept this exception, then you admit that you made a mistake and gave to the method what was impossible to give to it: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { AnotherMethod(argument); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ArgumentNullException exception) { <span class="hljs-comment"><span class="hljs-comment">// Log it } }</span></span></code> </pre> <br><p>  In this method we try to intercept an <code>ArgumentNullException</code> .  But in my opinion, his interception looks very strange: throwing the correct arguments to the method is completely our concern.  It would not be correct to react after the fact: in such a situation the most correct thing you can do is to check the transmitted data in advance, before calling the method, or better yet, to build the code so that it would not be possible to get the wrong parameters. </p><br><p>  Another group is the exclusion of fatal errors.  If a certain cache is broken and the subsystem will not work correctly anyway?  Then this is a fatal error and the code closest to the stack will not be guaranteed to intercept it: </p><br><pre> <code class="hljs kotlin">T GetFromCacheOrCalculate() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_cache.TryGetValue(Key, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { T res = Strategy(Key); _cache[Key] = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CacheCorreptedException exception) { RecreateCache(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  And let <code>CacheCorreptedException</code> be an exception, meaning "the cache on the hard disk is not consistent."  Then it turns out that if the cause of such an error is fatal for the caching subsystem (for example, there are no access rights to the cache file), then further code if it cannot recreate the cache with the <code>RecreateCache</code> command, and therefore the fact of interception of this exception is an error in itself. </p><br><h3 id="po-fakticheskomu-perehvatu-isklyuchitelnoy-situacii">  By actual interception of the exception </h3><br><p>  Another question that stops our flight of thought in programming algorithms is an understanding: should these or other exceptions be intercepted, or should someone who understands them pass through them.  Translating into the language of terms the question that we need to solve is to delineate the areas of responsibility.  Let's look at the following code: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">JetFinance.Strategies</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WildStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">StrategyBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayRussianRoulette</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DateTime.Now.Second == (random.Next() % <span class="hljs-number"><span class="hljs-number">60</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StrategyException(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StrategyException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* .. */</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">JetFinance.Investments</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WildInvestment</span></span> { WildStrategy _strategy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WildInvestment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WildStrategy strategy</span></span></span><span class="hljs-function">)</span></span> { _strategy = strategy; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomethingWild</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ?<span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? { _strategy.PlayRussianRoulette(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(StrategyException exception) { } } } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JetFinance.Strategies; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JetFinance.Investments; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WildStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WildInvestment(foo); ?<span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? { boo.DoSomethingWild(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(StrategyException exception) { } }</code> </pre><br><p>  Which of the two proposed strategies is more correct?  Area of ‚Äã‚Äãresponsibility is very important.  Initially, it may seem that since the work of <code>WildInvestment</code> and its consistency depends entirely on <code>WildStrategy</code> , if <code>WildInvestment</code> simply ignores this exception, it will go higher and do nothing more.  However, please note that there is a purely architectural problem: the <code>Main</code> method catches an exception from the architectural one layer, calling the architectural method the other.  How does it look in terms of use?  Yes, in general, it looks like this: </p><br><ul><li>  the concern for this exception was simply left over to us; </li><li>  the user of this class is not sure that this exception is passed through a number of methods before us specifically </li><li>  we begin to draw extra dependencies, which we have got rid of, causing the intermediate layer. </li></ul><br><p>  However, this conclusion should be different: we must put <code>catch</code> in the <code>DoSomethingWild</code> method.  And this is a bit strange for us: <code>WildInvestment</code> seems to be heavily dependent on someone.  Those.  if <code>PlayRussianRoulette</code> could not work, then <code>DoSomethingWild</code> too: he does not have return codes, but he is obliged to play roulette.  What to do in such a seemingly hopeless situation?  The answer is really simple: being in a different layer, <code>DoSomethingWild</code> should throw its own exception, which refers to this layer and wrap the original one as the original source of the problem - in <code>InnerException</code> : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">JetFinance.Strategies</span></span> { pubilc <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WildStrategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayRussianRoulette</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DateTime.Now.Second == (random.Next() % <span class="hljs-number"><span class="hljs-number">60</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StrategyException(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StrategyException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* .. */</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">JetFinance.Investments</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WildInvestment</span></span> { WildStrategy _strategy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WildInvestment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WildStrategy strategy</span></span></span><span class="hljs-function">)</span></span> { _strategy = strategy; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomethingWild</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { _strategy.PlayRussianRoulette(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(StrategyException exception) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FailedInvestmentException(<span class="hljs-string"><span class="hljs-string">"Oops"</span></span>, exception); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InvestmentException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* .. */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FailedInvestmentException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* .. */</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JetFinance.Investments; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WildStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WildInvestment(foo); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { boo.DoSomethingWild(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Wrapping the exception to others, we essentially transfer the problematic from one application layer to another, making its work more predictable from the point of view of a user of this class: the <code>Main</code> method. </p><br><h3 id="po-voprosam-pereispolzovaniya">  For reuse </h3><br><p>  Very often, we face a difficult task: on the one hand, we are too lazy to create a new type of exception, and when we do decide, it is not always clear what to start with: what type to take as a basis as a baseline.  But it is precisely these solutions that determine the entire architecture of exceptional situations.  Let's go over popular solutions and draw some conclusions. </p><br><p>  When choosing the type of exceptions, you can try to take an already existing solution: find an exception with a similar meaning in the name and use it.  For example, if we are given an entity through a parameter that for some reason does not suit us, we can throw an <code>InvalidArgumentException</code> , indicating the reason for the error - in the Message.  This script looks good, especially since <code>InvalidArgumentException</code> is in an exception group that is not subject to mandatory interception.  But a bad choice is <code>InvalidDataException</code> if you are working with any data.  Just because this type is in the <code>System.IO</code> zone, and this is hardly what you are doing.  Those.  it turns out that to find an existing type because it is lazy to make your own - almost always it will not be the right approach.  Exceptions that are created for the general range of tasks almost does not exist.  Virtually all of them are created for specific situations and their reuse will be a gross violation of the architecture of exceptional situations.  Moreover, having received an exception of a certain type (for example, the same <code>System.IO.InvalidDataException</code> ), the user will be confused: on the one hand, he will see the source of the problem in <code>System.IO</code> as an exception namespace, and on the other, a completely different namespace of the release point.  Plus, thinking about the rules for throwing this exception will go to <a href="https://referencesource.microsoft.com/">referencesource.microsoft.com</a> and find <a href="https://referencesource.microsoft.com/">all the places of its release</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  And understand that <del>  just someone has crooked hands </del>  the choice of the type of exception confused it, because the method that threw the exception did not deal with compression. </p><br><p>  Also, in order to simplify the reuse, you can simply take and create some one exception, by announcing the <code>ErrorCode</code> field with the error code and live happily ever after.  It would seem: a good solution.  Throwing the same exception everywhere, putting the code, catch only one <code>catch</code> thereby increasing the stability of the application: and nothing else to do.  However, please disagree with this position.  Acting in this way throughout the application, on the one hand, of course, you simplify your life.  But on the other hand, you drop the opportunity to catch a subgroup of exceptions united by some common feature.  As it is done, for example, with <code>ArgumentException</code> , which under itself combines a whole group of exceptions through inheritance.  The second serious drawback is excessively large and unreadable sheets of code that will organize filtering by error code.  But if we take a different situation: when specifying an error should not be important for an end user, the introduction of a generic type plus an error code already looks like a much more correct application: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ParserException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ParserError ErrorCode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParserException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ParserError errorCode</span></span></span><span class="hljs-function">)</span></span> { ErrorCode = errorCode; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Resources.GetResource(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(ParserException)}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Enum.GetName(</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(ParserError), ErrorCode)}</span></span></span><span class="hljs-string">"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ParserError { MissingModifier, MissingBracket, <span class="hljs-comment"><span class="hljs-comment">// ... } // Usage throw new ParserException(ParserError.MissingModifier);</span></span></code> </pre> <br><p>  The code that protects the call to the parser almost always makes no difference for what reason the parsing was overwhelmed: the fact of the error is important to it.  However, if it still becomes important, the user can always isolate the error code from the <code>ErrorCode</code> .  To do this, it is not necessary to search for the right words by substring in <code>Message</code> </p><br><p>  If you start from ignoring reuse issues, you can create an exception type for each situation.  On the one hand, it looks logical: one type of error - one type of exception.  However, here, as in everything, the main thing is not to overdo it: having the type of exceptional operations at each point of release causes you to intercept problems: the code of the calling method will be overloaded with <code>catch</code> blocks.  After all, he needs to handle all types of exceptions that you want to give him.  Another minus is purely architectural.  If you do not use inheritance, then you are disorienting the user of these exceptions: there may be a lot in common between them, and you have to intercept them separately. </p><br><p>  However, there are good scenarios for introducing individual types for specific situations.  For example, when a breakdown occurs not for the whole entity, but for a particular method.  Then this type should be in the hierarchy of inheritance to be in such a place so that there is no thought to intercept it along with something else: for example, selecting it through a separate branch of inheritance. </p><br><p>  Additionally, if you combine these two approaches, you can get a very powerful toolkit for working with a group of errors: you can enter a generalizing abstract type from which to inherit specific particular situations.  The base class (our generic type) needs to be supplied with an abstract property storing the error code, and the heirs redefining this property will specify this error code: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ParserException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> ParserError ErrorCode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Resources.GetResource(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(ParserException)}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Enum.GetName(</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(ParserError), ErrorCode)}</span></span></span><span class="hljs-string">"</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ParserError { MissingModifier, MissingBracket } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MissingModifierParserException</span></span> : <span class="hljs-title"><span class="hljs-title">ParserException</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> ParserError ErrorCode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } =&gt; ParserError.MissingModifier; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MissingBracketParserException</span></span> : <span class="hljs-title"><span class="hljs-title">ParserException</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> ParserError ErrorCode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } =&gt; ParserError.MissingBracket; } <span class="hljs-comment"><span class="hljs-comment">// Usage throw new MissingModifierParserException(ParserError.MissingModifier);</span></span></code> </pre> <br><p>  What wonderful properties will we get with this approach? </p><br><ul><li>  on the one hand, we kept catching the exception on the base type; </li><li>  on the other hand, intercepting the exception of the base type preserved the opportunity to learn a specific situation; </li><li>  and plus everything can be intercepted for a specific type, not for the base type, without using the flat structure of classes. </li></ul><br><p>  As for me, so very convenient option. </p><br><h3 id="po-otnosheniyu-k-edinoy-gruppe-povedencheskih-situaciy">  In relation to a single group of behavioral situations </h3><br><p>  What conclusions can be made, based on the previously described arguments?  Let's try to formulate them: </p><br><p>  First, let's define what is meant by situations.  When we talk about classes and objects, we are accustomed to first of all operate with entities with a certain internal state over which we can perform actions.  It turns out that by doing so we found the first type of behavioral situation: actions on a certain entity.  Further, if you look at the object graph, as if from the outside, you can see that it is logically combined into functional groups: the first is caching, the second is working with databases, and the third performs mathematical calculations.  Through all these functional groups can go layers: a layer of logging of various internal states, logging of processes, tracing of method calls.  Layers can be more encompassing: combining several functional groups.  For example, model layer, controller layer, view layer.  These groups can be located in one assembly, or in completely different ones, but each of them can create its own exceptional situations. </p><br><p>  It turns out that if you argue in this way, then you can build a certain hierarchy of types of exceptional situations, based on the type of belonging to one group or layer, thereby creating the possibility for code that intercepts exceptions to allow easy semantic navigation in this type hierarchy. </p><br><p>  Let's look at the code: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">JetFinance</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">FinancialPipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Services</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">XmlParserService</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">JsonCompilerService</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">TransactionalPostman</span></span> { } } } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Accounting</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre><br><p>  What does it look like?  As for me, namespaces are a great opportunity for the natural grouping of types of exceptions according to their behavioral situations: everything that belongs to certain groups should be there, including exceptions.  Moreover, when you get a certain exception, in addition to the name of its type, you will see its namespace, which clearly defines its identity.  Remember an example of a bad reuse of the type <code>InvalidDataException</code> , which is actually defined in the <code>System.IO</code> namespace?  Its belonging to this namespace means that, in essence, an exception of this type can be thrown out of classes that are in the <code>System.IO</code> namespace or in a more nested one.  But the exclusion itself was completely thrown out of another place, confusing the researcher of the problem.  By focusing exception types on the same namespaces as types, throwing these exceptions, on the one hand, you keep the type architecture consistent, and on the other, you make it easier for the end developer to understand the causes. </p><br><p>  What is the second way to group at the code level?  Inheritance: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LoggerExceptionBase</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoggerExceptionBase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">..</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IOLoggerException</span></span> : <span class="hljs-title"><span class="hljs-title">LoggerExceptionBase</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IOLoggerException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">..</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConfigLoggerException</span></span> : <span class="hljs-title"><span class="hljs-title">LoggerExceptionBase</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigLoggerException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">..</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><p>  Moreover, if in the case of ordinary application entities, inheritance means inheritance of behavior and data, combining types according to belonging to a <em>single entity group</em> , in case of exceptions, inheritance means belonging to a <em>single situation group</em> , since the essence of the exception is not the essence, but the problematic. </p><br><p>  Combining both methods of grouping, we can draw some conclusions: </p><br><ul><li>  Inside the assembly, there must be a basic type of exception that this assembly throws.  This type of exception must be in the root for the assembly namespace.  This will be the first layer of the grouping; </li><li>  there may be one or more different namespaces inside the assembly itself.  Each of them divides the assembly into some functional zones, thereby determining the groups of situations that arise in this assembly.  These can be zones of controllers, database entities, data processing algorithms and others.  For us, these namespaces are the grouping of types by functional affiliation, and from the point of view of exceptions, the grouping into problem zones of the same assembly; </li><li>  exceptions can be inherited only from types in the same namespace or in a more root one.           <em></em>      . :     <code>global::Finiki.Logistics.OhMyException</code> ,  <code>catch(global::Legacy.LoggerExeption exception)</code> ,      : </li></ul><br><pre> <code class="hljs pgsql">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> XmlParserServiceException : FinancialPipeExceptionBase { // .. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Parse(string <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) { // .. } } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FinancialPipeExceptionBase : <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JetFinance.FinancialPipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> JetFinance.FinancialPipe.Services.XmlParserService; var parser = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span>(); try { <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>.Parse(); } catch (XmlParserServiceException <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) { // Something wrong <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span> } catch (FinancialPipeExceptionBase <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) { // Something <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> wrong. Looks critical because we don<span class="hljs-string"><span class="hljs-string">'t know real reason }</span></span></code> </pre><br><p> ,   :        , ,   ,       <code>XmlParserServiceException</code> . ,   ,      ,  <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> ,       :    <code>XmlParserService</code>    ,       .          ,               <code>catch</code>      :          . </p><br><p>     ? </p><br><ul><li>        .     .     ‚Äî      ,       : , -, UI.  Those.     ; </li><li>        ,   :      ,      <code>catch</code> ; </li><li>       ‚Äì      .        ; </li><li>             ,       .      :       ,         , ,  . ,   -    :        ,   ‚Äî  ,  , ,        ; </li><li>         </li><li>       ,      :     ; </li><li>           ,  Mixed Mode c ErrorCode. </li></ul><br><h3 id="po-istochniku-oshibki">    </h3><br><p>             . ,     ,     : </p><br><ul><li>  unsafe ,    .      :         ,      (,   )     ; </li><li>     ,   ,      , ..       .        ,             ,     .  ,       ,       .            ‚Äî        ‚Äî  <code>InnerExcepton</code> .            ‚Äî          ; </li><li>   ,         .      .   ,   <code>unsafe</code> ,    . </li></ul><br><blockquote><h3>  Link to the whole book </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 books, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/419927/">https://habr.com/ru/post/419927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419917/index.html">Neural networks: implementation of the task about mushrooms on Tensor Flow and Python</a></li>
<li><a href="../419919/index.html">Version Control Inside SQL Server</a></li>
<li><a href="../419921/index.html">How to drop 10 million packets per second</a></li>
<li><a href="../419923/index.html">My time creativity, clock from motherboards</a></li>
<li><a href="../419925/index.html">Version control of individual files using GitHub Gist</a></li>
<li><a href="../419929/index.html">[DotNetBook] Exception events and how to get StackOverflow and ExecutionEngineException from scratch</a></li>
<li><a href="../419931/index.html">[DotNetBook] Time for entertaining stories: exceptionally exceptional situations</a></li>
<li><a href="../419933/index.html">How to do a search for users on Github using Angular</a></li>
<li><a href="../419935/index.html">Exactly once is NOT exactly the same: article analysis</a></li>
<li><a href="../419939/index.html">How I did navigation in React Native is not so terrible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>