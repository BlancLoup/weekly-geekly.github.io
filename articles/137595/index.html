<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The use of an inertial navigation system (INS) with several sensors on the example of the task of stabilizing the height of a quadrocopter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will try to talk about my experience in creating and implementing an algorithm for processing signals from several standard sensors ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The use of an inertial navigation system (INS) with several sensors on the example of the task of stabilizing the height of a quadrocopter</h1><div class="post__text post__text-html js-mediator-article">  In this article I will try to talk about my experience in creating and implementing an algorithm for processing signals from several standard sensors that are part of the INS (in the English version of the IMU) to solve the problem of stabilizing the height of a multi-rotor aircraft (in my case, a quadrocopter).  On Habr√© has already been a <a href="http://habrahabr.ru/blogs/DIY/120266/">series of articles</a> describing what kind of toy and how to make it yourself.  As a programmer by profession, it was interesting for me not only to assemble him, but also to dig deeper into the ‚Äúbrains‚Äù and do something useful for the community.  I chose Arduino and the wonderful <a href="http://www.multiwii.com/">MultiWii</a> project as ‚Äúbrains‚Äù.  It is completely open, dynamically developing, but so far there are ‚Äúwhite spots‚Äù in it.  For example, the stabilization of the position in height does not work satisfactorily.  And I decided to find out whether it is possible to improve this part of the system with the available equipment. <a name="habracut"></a><br><br>  First, some introductory information to clarify what is to be dealt with. <br>  Multi-rotor is a device with several (3, 4, 6, 8) motors with propellers, each of which creates a vertical adjustable thrust.  Unlike the helicopter, the stabilization here is completely electronic, and the microprocessor deals with it using the INS (flight controller). <br><br><h4>  What tasks need to be solved in flight? </h4><br><ul><li>  Determination of orientation (angles along three axes relative to the ground) and stabilization along them </li><li>  Height determination and stabilization </li><li>  Determination of coordinates and flight at given points </li><li>  Receiving commands from the control panel and issuing control signals to the motors </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What do we have available? </h4><br>  At the moment, in easy accessibility we have a standard set of sensors: <br><ul><li>  pretty good 3-axis gyros. </li><li>  medium-quality 3-axis accelerometers </li><li>  medium quality 3-axis magnetometer </li><li>  medium or bad barometer </li></ul><br><br>  Such a set complete with an Arduino-like processor or as a separate scarf can be found for a sum of $ 70-100 <br><br>  Each sensor has its own features and weaknesses.  Individually, none of them can solve any of the problems listed above, so the INS systems are always built from a combination of sensors, and the most interesting thing here is computational algorithms that allow you to combine the strengths of each of the sensors to eliminate their shortcomings. <br><br>  The first task, orientation stabilization, is quite successfully solved by gyroscopes.  Gyroscopes measure the angular velocity very accurately and, after integration, angles can be obtained.  But they have a problem - testimony floats with time.  To correct this drift, an accelerometer is used, which always (or almost always in the long term) knows where the earth is.  But the accelerometer will not feel anything if it is twisted around the Z axis, so we need a magnetometer, which always knows where the north is. <br>  The second task - finding the height - is partially solved by a barometer.  If we reset the readings on the ground, then when we climb every meter, we know how much his readings will change (naturally, if we don‚Äôt fly for 12 hours and the weather does not start changing).  But according to the condition of the problem, the barometer is bad, and it gives out a height of + -1m with a wild noise amplitude approximately in the same range.  In reality, my sensor shows the following (at the 10th second moved 1 meter): <br><br><img src="https://habrastorage.org/storage2/330/9c6/89b/3309c689b5afee44f32fea98f48f3e7d.png"><br><br>  Sonar can come to the aid of the barometer, which measures altitude with very high accuracy (even the one that I purchased for $ 5, gives an accuracy of ¬± 3mm according to the manufacturer).  But the sonar is able to work only low above the ground (2-10m), measures for a long time (up to 200ms), is sensitive to the quality of the surface, to the angle of inclination, and can lose a signal. <br>  The third task ‚Äî determination of coordinates ‚Äî is not solved by the sensors indicated above.  Accelerometer in combination with a gyroscope can produce linear horizontal accelerations, but there are two problems here: a permanently large (compared to what we measure) vector 1G, and the lack of bindings for correction.  So the determination of the coordinates remains the prerogative of the GPS-sensor, and one cannot count on high accuracy here. <br><br>  In all amateur flight controllers, the problem of finding orientation has been solved well and I will not dwell on it.  The task is quite simple and is written on the Internet ( <a href="http://www.starlino.com/imu_guide.html">one</a> , <a href="http://habrahabr.ru/blogs/augmented_reality/118192/">two</a> ).  In MultiWii, a beautiful solution is used without complications such as quaternions and DCM matrices (do not forget that all this will be considered a simple 16 MHz processor), based on simplifications for small angles and a complementary filter. <br><br>  So, we know the orientation of the apparatus in space with a high degree of accuracy.  Now you can go to the main topic of the article, that is, try to improve the results that the barometer (or sonar) produces so that you can feed them to the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%2598%25D0%2594-%25D1%2580%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580">PID controller</a> .  To do this, the readings must come without delay, be accurate in the short term, and not drift much over time.  <em>The topic of PID controllers deserves a separate close study, as it is widely used in process control systems.</em>  <em>I recommend that you first familiarize yourself with their definition in order to better understand the reasoning set forth below.</em> <br><br><h4>  Smoothing </h4><br>  What we do not fit the barometer readings in the current form?  Well, firstly, a strong noise signal will cause unnecessary control actions on the motors.  Applying a low pass filter, we reduce the noise, but lose the measurement speed.  This means that any short-term perturbations will be ignored, sharp perturbations will be worked out with a long delay, and most importantly, we will not receive the differential component (D) for the PID controller.  And as follows from the theory, a regulator without this component is prone to weakly damped oscillations around the target value, which is observed in practice. <br><br><h4>  We integrate </h4><br>  Well, let's leave the barometer and take the accelerometer.  It seems that everything is simple - from the value along the Z axis we subtract the constant 1G, we get linear vertical acceleration.  We will integrate it twice (in fact, sum it up in the measuring cycle) and obtain the speed and relative displacement.  For the PID controller, these are lacquered indicators, with them you can build a good dynamic model.  But here, not everything is as good as we would like.  The slope of the apparatus will cause a change in the projection of the acceleration vector A on the Z axis. Vibrations from the motor or temperature changes may cause a "shift" in sensitivity, and our constant 1G will no longer correspond to reality.  But even in the case of a perfectly fixed device and a precisely exposed 1G, any sensor emits noise.  But even a tiny mistake within a dozen seconds of double integration grows to the size of an elephant, and now we see a speed of 10m / s and a height of 20m (although they haven‚Äôt even come off the ground yet). <br><br><h4>  Complementary filter </h4><br>  Explained in a simple way, this filter is applied to two values ‚Äã‚Äãmeasured by different sensors and adjusts one of them so that it slowly approaches the second.  In the measuring cycle, the filter is implemented with a simple formula: <br><br><img src="https://habrastorage.org/storage2/d2e/476/28b/d2e47628be10399f5ef57aeca7932f4b.gif"><br><br>  In this case, the effect of A2 on A1 is proportional to the difference between them and is determined by the coefficient k (the larger, the weaker the effect). <br>  If you apply this filter to the height found by the accelerometer and the barometer readings, you get an interesting thing: the accelerometer drift will be constantly corrected by the barometer, and the barometer readings will be smoothed (since for A2 this filter works as a low-pass filter).  But only the second integral will be adjusted, and the first will still quietly ‚Äúdrift‚Äù to infinity, and as a result, due to the small coefficient k, the barometer simply cannot influence the situation. <br>  Why does this filter work fine for a pair of gyroscope + accelerometer?  Because there we correct the first integral, and in the end it ceases to ‚Äúfloat‚Äù when the correction value during one cycle equals the value of the gyroscope error added in the same cycle during integration. <br><br><h4>  PID controller comes to the rescue </h4><br>  But even from a pair of barometer + accelerometer, you can extract something useful if you apply a PID controller to them (yes, the area of ‚Äã‚Äãtheir application is extremely extensive). <br>  So what is the main weak point of our accelerator integrator?  In a micro-error, which can occur for various reasons, as described above, when subtracting the constant 1G.  If you write the desired acceleration in the form: <br><br><img src="https://habrastorage.org/storage2/ba1/f37/3d1/ba1f373d11d5645001d8a31f5fd36c67.gif"><br><br>  then, by adjusting the bias value, one can control both the first integral (velocity) and the second (offset).  So, the goal of our PID controller is found.  But you still need to know the error.  Let us make the assumption that bias will be fixed after the onset of some stabilization of the system parameters (temperature, vibration, etc.).  When bias is found, the accelerometer readings will be very close to the truth and you can apply a complementary filter, crossing them with a barometer.  The magnitude of the correction of this filter will be an error from which the PID controller will repel (it seeks to reduce the error to 0 by adjusting the target variable). <br>  Then we find all three components of the PID controller.  Proportional (P) is the error itself.  Integral (I) - just integrate it.  Differential (D) - according to the theory it is necessary to differentiate the error.  But there are terrible noises of the barometer and accelerometer.  It's scary to differentiate this, so apply the trick - let's take the speed found by the accelerometer with a negative sign as the D-component.  Since D is designed to introduce attenuation into the regulator, the speed here will fit perfectly - the more it is, the more it is necessary to ‚Äúpay it off‚Äù. <br><br>  Multiply each of the components by their coefficients, add and get bias.  But here we apply the second trick - we will not add bias directly to the acceleration, but add only the I-part.  It describes the magnitude of the permanent error, which corresponds to our assumption of a slow change in bias. <br>  We add the P and D parts to the speed by multiplying by dT (since we borrowed them from acceleration). <br>  Since the main task of the regulator is to find the constant component of the error, I decided to adjust it ‚Äúsoftly‚Äù enough to minimize the short-term changes.  But there remains a wide field for experiments, and everything will be determined by the behavior of real sensors. <br><br><h4>  But what about the gyroscope? </h4><br>  Above, I mentioned that to determine the height, we also need a gyroscope.  Indeed, the algorithm described above will work only if the vector A (in the local system) looks exactly along the Z axis. As soon as the device tilts, two unpleasant things will happen: the projection A on the Z axis will change and the PID controller will begin again slowly and painfully to search for bias .  And the second - any horizontal acceleration will begin to give a non-zero projection on the local Z axis. At 45 ¬∞ tilt angles, you won‚Äôt understand where the acceleration is. <br>  But since we know the exact orientation of the local system relative to the global, there is nothing difficult to restore justice - we simply design the local vector A onto the local vector G (originally found by the accelerometer and carefully rotated by the gyroscope), which always looks at the ground. <br>  This operation is simple and follows from the definition of a vector product: <br><br><img src="https://habrastorage.org/storage2/7d2/53e/505/7d253e5050771f54d0a73f9e5deb9d11.gif"><br><br>  This must be done before subtracting 1G. <br><br>  Now you can look at the code and the results. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ACC_BARO_CMPF 300.0f #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ACC_BARO_P 30.0f #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ACC_BARO_I (ACC_BARO_P * 0.001f) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ACC_BARO_D (ACC_BARO_P * 0.001f) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VEL_SCALE ((1.0f ‚Äî 1.0f/ACC_BARO_CMPF)/1000000.0f) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ACC_SCALE 9.80665f / acc_1G / 10000.0f err = (alt - BaroAlt)/ACC_BARO_CMPF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// P term of error errI+= err * ACC_BARO_I; // I term of error accZ = (accADC[0]*EstG.VX + accADC[1]*EstG.VY + accADC[2]*EstG.VZ) * InvSqrt(fsq(EstG.VX) + fsq(EstG.VY) + fsq(EstG.VZ)) - errI - acc_1G; // Integrator - velocity, cm/sec vel+= (accZ - err*ACC_BARO_P - vel*ACC_BARO_D) * cycleTime * ACC_SCALE; // Integrator - altitude, cm alt+= vel * cycleTime * VEL_SCALE; // Apply ACC-&gt;BARO complementary filter alt-= err; errPrev = err;</span></span></span></span></code> </pre> <br><br>  Sensor data comes in the following variables: <br>  EstG.V - vector G (it was obtained earlier while finding the orientation) <br>  accADC - clean data from accelerometer <br>  BaroAlt - data from the barometer, converted to cm <br>  At the output we get accZ, vel, alt. <br><br>  As you can see, the computational complexity of the algorithm is quite simple and Arduino will ‚Äúdigest‚Äù it easily (especially if translated into integer arithmetic, but then the code will become poorly readable). <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/tPO0muGySy8%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhhmb-CniQoVnWBjYepNd6Tusuc_dg" frameborder="0" allowfullscreen=""></iframe><br><br>  <em>PS: in the video there is a phrase about disabling the algorithm at a certain angle of inclination, and because of this, an error occurs.</em>  <em>In fact, this restriction is not necessary - the algorithm works stably at any angle from 0 ¬∞ to 360 ¬∞</em> <br><br>  If you connect a sonar to this algorithm (in addition to BaroAlt, take SonarAlt), then the height curve looks almost perfect.  Thus, at a low altitude we use sonar, when errors occur or close to the measurement limit, we switch to a barometer (having previously coordinated the altitudes in the period of receiving reliable data from the sonar). <br><br>  Unfortunately, the weather does not allow to conduct flight tests of the new algorithm.  As soon as the results appear, I'll post the sonar charts, the debugged source code of the entire project, and the flight video. </div><p>Source: <a href="https://habr.com/ru/post/137595/">https://habr.com/ru/post/137595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137588/index.html">Weigh CSS selectors</a></li>
<li><a href="../137589/index.html">fbi.gov also uses nginx</a></li>
<li><a href="../137590/index.html">How to protect against unexpected commenting by Ctrl + Enter?</a></li>
<li><a href="../137593/index.html">Another step to PyCon.RU - ekb.py</a></li>
<li><a href="../137594/index.html">One more video glasses from Nabes LLC</a></li>
<li><a href="../137596/index.html">How to make a controlled outlet from a Chinese router, or another project for a smart home and office</a></li>
<li><a href="../137597/index.html">Mint 4200 floor polisher is another smart mop. Now with gps</a></li>
<li><a href="../137598/index.html">RIM offers PlayBook 16 Gb to developers for BlackBerry apps (UPD)</a></li>
<li><a href="../137599/index.html">Problem with accuracy and overflow</a></li>
<li><a href="../137600/index.html">Native vs Web. Part 0: +1 argument in favor of developing native mobile apps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>