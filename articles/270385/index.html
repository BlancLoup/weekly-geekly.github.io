<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js in battle (cluster creation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When you use applications on node.js in production, you have to think about stability, performance, security, and ease of support. This article descri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js in battle (cluster creation)</h1><div class="post__text post__text-html js-mediator-article">  When you use applications on node.js in production, you have to think about stability, performance, security, and ease of support.  This article describes my thoughts on best practices for using node.js in combat. <br><br>  By the end of this guide, you will receive a system from 3 servers: a balancer (lb) and 2 application servers (app1 and app2).  The balancer will monitor the availability of servers and distribute traffic between them.  Application servers will use a combination of systemd and node.js clustering to balance traffic between multiple node processes on the server.  You can roll out the code with a single command from your machine, and there will be no interruptions in service or unprocessed requests. <br>  All this can be represented as a diagram: <br><br><img src="https://habrastorage.org/files/99b/e70/e11/99be70e113364934b8cd73241590adb7.png"><br><a name="habracut"></a><br>  Photo courtesy: <a href="https://www.digitalocean.com/community/articles/5-common-server-setups-for-your-web-application">Digital Ocean</a> <br><blockquote>  <i>From the translator: With the proliferation of an isomorphic approach to building web applications, more and more developers are faced with the need to use Node.js in production.</i>  <i>I liked this article by Jeff Dickey with a practical approach and a general view on this broad topic.</i> <i><br></i>  <i><b>UPD (2018):</b> Fixed links to the author‚Äôs github.</i> </blockquote><br><h2>  About this article </h2><br>  This article is addressed to those who are just beginning to deal with the issues of setting up servers for combat operation.  However, you should have a general understanding of this process, know what upstart, systemd or init is, and what process signals in unix are.  I suggest you try this manual on your servers (but still use my demo code).  In addition, I will provide several useful configuration settings and scripts that will serve as a good starting point when setting up your own environment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The final version of the application is here: <a href="https://github.com/jdxcode/node-sample">https://github.com/jdxcode/node-sample</a> . <br><br>  In this guide, I will use <a href="https://www.digitalocean.com/">Digital Ocean</a> and <a href="http://fedoraproject.org/">Fedora</a> .  However, the article is written as independent of the technology stack as possible. <br><br>  I‚Äôll use the Digital Ocean servers with Fedora 20 vanilla images. I tested the manual several times, so you should have no problems reproducing these actions. <br><br><h2>  Why Fedora? </h2><br>  All Linux distributions (except Gentoo) move from different init systems to systemd.  Since Ubuntu (perhaps the most popular distribution in the world) has not yet switched to it (but they have already announced it), I believe that it would be wrong to teach you how to use Upstart. <br><br>  systemd offers several significant advantages over Upstart, including advanced centralized logging, simplified configuration, performance, and many other features. <br><br><h2>  Installing Node.js </h2><br>  First you need to install node.js on a fresh server.  On Digital Ocean, I had only 4 teams. <br><br>  <a href="">bootstrap.sh</a> <br><pre><code class="bash hljs">yum update -y yum install -y git nodejs npm npm install -gn n stable</code> </pre> <br>  Here we install the node through yum (which can supply us with an outdated version), then we put an excellent package n, which can install and switch different versions of the node.  We will use them to update node.js. <br><br>  Now run <code># node --version</code> and you will see information about the latest version of the node. <br><br>  Later I will show how you can automate this step with <a href="http://www.ansible.com/">Ansible</a> . <br><br><h2>  Create a web user </h2><br>  Since it is not safe to run applications as root, we will create a separate web user. <br>  To do this, run: <code># useradd -mrU web</code> <br><br><h2>  Add an application </h2><br>  We have a node server, and we can proceed to adding our application: <br><br>  Create a directory: <code># mkdir /var/www</code> <br>  Set him web owner: <code># chown web /var/www</code> <br>  As well as the web group: <code># chgrp web /var/www</code> <br>  Enter it: <code># cd /var/www/</code> <br>  Switch to our user: <code>$ su web</code> <br>  Clone the repository with the Hello world app: <code>$ git clone https://github.com/jdxcode/node-hello-world</code> <br><br>  This is the simplest application for the node: <br>  <a href="">app.js</a> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">3000</span></span>; http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'%d request received'</span></span>, process.pid); res.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>}); res.end(<span class="hljs-string"><span class="hljs-string">'Hello world!\n'</span></span>); }).listen(PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'%d listening on %d'</span></span>, process.pid, PORT);</code> </pre><br>  Run it: <code>$ node app.js</code> <br><br>  You can log in to the server by IP using a browser, and you will see that the application is running: <br><br><img src="https://habrastorage.org/files/b51/bba/410/b51bba4105ec413db067c4c8c82f6bf5.png"><br><br>  Note: you may need to run <code># iptables -F <br></code> <code># iptables -F <br></code>  to clear iptables tables or open a port on the firewall <code>firewall-cmd --permanent --zone=public --add-port=3000/tcp. <br></code> <code>firewall-cmd --permanent --zone=public --add-port=3000/tcp. <br></code> <br><br>  Another note: By default, the application runs on port 3000. To start it on port 80, you need a proxy server (like nginx), but for our configuration you need to start the application server on port 3000, and the balancer (on another server) will work on port 80 <br><br><h2>  systemd </h2><br>  After we learned how to start the application server, we need to add it to systemd so that it will restart in the event of a crash. <br><br>  We will use the following systemd script: <br><br>  <a href="https://gist.github.com/jdxcode/91b15f8092b8cbdc8c9c/raw/eecf9efa74b301ffbc409c6d14721cf0f72d124f/node-sample.service">node-sample.service</a> <br><pre> <code class="nginx hljs">[Service] WorkingDirectory=/var/www/node-hello-<span class="hljs-attribute"><span class="hljs-attribute">world</span></span> ExecStart=/usr/bin/node app.js Restart=always StandardOutput=syslog StandardError=syslog SyslogIdentifier=node-hello-world User=web Group=web Environment=<span class="hljs-string"><span class="hljs-string">'NODE_ENV=production'</span></span> [Install] WantedBy=multi-user.target</code> </pre><br>  Copy this file (as root) into <code>/etc/systemd/system/node-sample.service <br></code> <code>/etc/systemd/system/node-sample.service <br></code> <br>  Activate it: <code># systemctl enable node-sample <br></code> <code># systemctl enable node-sample <br></code> <br>  Run it: <code># systemctl start node-sample <br></code> <code># systemctl start node-sample <br></code> <br>  Check status: <code># systemctl status node-sample <br></code> <code># systemctl status node-sample <br></code> <br>  Check out the logs: <code># journalctl -u node-sample <br></code> <code># journalctl -u node-sample <br></code> <br>  Try to kill the pid node process and see how it starts up again! <br><br><h2>  Process clustering </h2><br>  Now that we can run a single process with our application, we need to use the built-in <a href="http://nodejs.org/api/cluster.html">node clustering</a> methods, which will automatically distribute traffic across multiple processes. <br><br>  <a href="https://gist.github.com/jdxcode/0f535be1ada0ea964cae">Here is a script that you can use to launch the Node.js application.</a> <br><br>  Just put this file next to <code>app.js</code> and run: <code>$ node boot.js</code> <br>  This script will launch 2 instances of the application, and will restart them if necessary.  It also seamlessly restarts when it receives a SIGHUP signal. <br><br>  Let's try it.  To do this, make changes to what <code>app.js <br></code> returns <code>app.js <br></code> <code>app.js <br></code>  .  Run <code>$ kill -hup [pid] <br></code> <code>$ kill -hup [pid] <br></code>  and then in the browser you can see the new data.  The script restarts one process at a time, thereby ensuring a seamless restart. <br><br>  For a clustered version of the application to work, you must update the systemd configuration.  Also, you can add the setting <code>ExecReload=/bin/kill -HUP $MAINPID <br></code> <code>ExecReload=/bin/kill -HUP $MAINPID <br></code>  so systemd can seamlessly restart itself when it receives the <code># systemctl reload node-sample. <br></code> command <code># systemctl reload node-sample. <br></code> <code># systemctl reload node-sample. <br></code> <br><br>  Here is an example of a file for a clustered version: <br>  <a href="https://gist.github.com/jdxcode/97db8e5d14268102f916/raw/77b4d03c2b95837e8aa61b724b6155f7eb8b1e37/node-sample.service">node-sample.service</a> <br><pre> <code class="nginx hljs">[Service] WorkingDirectory=/var/www/node-hello-<span class="hljs-attribute"><span class="hljs-attribute">world</span></span> ExecStart=/usr/bin/node boot.js ExecReload=/bin/kill -HUP <span class="hljs-variable"><span class="hljs-variable">$MAINPID</span></span> Restart=always StandardOutput=syslog StandardError=syslog SyslogIdentifier=node-sample User=web Group=web Environment=<span class="hljs-string"><span class="hljs-string">'NODE_ENV=production'</span></span> [Install] WantedBy=multi-user.target</code> </pre><br><h2>  Balancing </h2><br>  In combat operation, you need at least 2 servers in case one of them falls.  I would not raise a real system with just one.  Keep in mind: the servers are turned off not only when they are broken, but also when it may be necessary to turn off one for maintenance.  The balancer checks the availability of servers and if it notices a problem, it excludes this server from rotation. <br><br>  First install the second application server, repeating the previous steps.  Then create a new server in the Digital Ocean (or somewhere else) and connect to it via ssh. <br><br>  Install HAProxy: <code># yum install haproxy</code> <br><br>  Replace the <code>/etc/haproxy/haproxy.cfg</code> file <code>/etc/haproxy/haproxy.cfg</code> the following (substitute the IP of your servers): <br><br>  <a href="">haproxy.cfg</a> <br><pre> <code class="python hljs">defaults log <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> mode http option httplog option dontlognull option http-server-close option forwardfor option redispatch retries <span class="hljs-number"><span class="hljs-number">3</span></span> timeout http-request <span class="hljs-number"><span class="hljs-number">10</span></span>s timeout queue <span class="hljs-number"><span class="hljs-number">1</span></span>m timeout connect <span class="hljs-number"><span class="hljs-number">10</span></span>s timeout client <span class="hljs-number"><span class="hljs-number">1</span></span>m timeout server <span class="hljs-number"><span class="hljs-number">1</span></span>m timeout http-keep-alive <span class="hljs-number"><span class="hljs-number">10</span></span>s timeout check <span class="hljs-number"><span class="hljs-number">10</span></span>s frontend main *:<span class="hljs-number"><span class="hljs-number">80</span></span> stats enable stats uri /haproxy?stats stats auth myusername:mypass default_backend app backend app balance roundrobin server app1 <span class="hljs-number"><span class="hljs-number">107.170</span></span><span class="hljs-number"><span class="hljs-number">.145</span></span><span class="hljs-number"><span class="hljs-number">.120</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> check server app2 <span class="hljs-number"><span class="hljs-number">192.241</span></span><span class="hljs-number"><span class="hljs-number">.205</span></span><span class="hljs-number"><span class="hljs-number">.146</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> check</code> </pre><br>  Now restart HAProxy: <code>systemctl restart haproxy</code> <br><br>  You should see a running application on port 80 on the balancer.  Can you go to <code>/haproxy?stats <br></code> <code>/haproxy?stats <br></code>  to view the HAProxy status page.  Log in using <code>myusername/mypass</code> . <br><br>  For additional information on setting up HAProxy, I suggest that you familiarize yourself with the manual that <a href="http-load-balancing-on-an-ubuntu-vps">I used</a> , or with the <a href="http://cbonte.github.io/haproxy-dconv/configuration-1.4.html">official documentation</a> . <br><br><h2>  Deploy code with Ansible </h2><br>  Most of the guidelines for setting up a server end there, but I think that the instruction will not be complete without organizing the deployment!  Without automation, the process does not look very scary: <br><ul><li>  Connect via SSH to app1 </li><li> <code>cd /var/www/node-hello-world</code> </li> <li>  Get the latest <code>git pull</code> code </li><li>  And reload the application <code>systemctl reload node-sample</code> </li></ul><br>  But the main disadvantage is that this will have to be done on each server, and this is laborious.  Using Ansible, we can roll out our code directly from our machine and properly restart the application. <br><br>  People are afraid of Ansible.  Many people think that it is similar to complex tools like Chef or Puppet, but in fact it is closer to Fabric or Capistrano.  In the simplest case, it simply connects via ssh to the server and executes commands.  Without clients, master servers, complicated cookbooks, they are just commands.  It has excellent opportunities for server deployment (provisioning), but you can not use them. <br><br>  Here is the Ansible file, which simply deploit the code: <br>  <a href="">deploy.yml</a> <br><pre> <code class="javascript hljs">--- - hosts: app tasks: - name: update repo git: repo=https:<span class="hljs-comment"><span class="hljs-comment">//github.com/jdxcode/node-hello-world version=master dest=/var/www/node-hello-world sudo: yes sudo_user: web notify: - reload node-sample handlers: - name: reload node-sample service: name=node-sample state=reloaded</span></span></code> </pre><br>  <a href="https://gist.github.com/jdxcode/ebca955586cb6fb03eaa/raw/9611c1473e8e25e20f88565bf2b84a772df6ba6c/production">production</a> <br><pre> <code class="nginx hljs">[app] 192.241.205.146 107.170.233.117</code> </pre><br>  Run it on your machine for development ( <a href="http://docs.ansible.com/intro_installation.html">make sure you install Ansible</a> ): <br> <code>ansible-playbook -i production deploy.yml <br></code> <br><br>  The production file in Ansible is called an <a href="http://docs.ansible.com/intro_inventory.html">inventory file</a> .  It simply lists the addresses of all servers and their roles. <br><br>  A file with the yml extension is called a script ( <a href="http://docs.ansible.com/playbooks.html">playbook</a> ).  It defines the tasks to run.  We get it with fresh code from github.  If there are changes, the ‚Äúnotify‚Äù task is started, which reboots the application server.  If there are no changes, the handler will not start.  If you say you want to install npm packages, you can do it here.  By the way, make sure you use <code>npm shrinkwrap</code> if you do not fix dependency files in the repository. <br><br>  Note: if you want to use your own git repository, you will need to install <a href="https://help.github.com/articles/using-ssh-agent-forwarding">SSH Authorization Agent Redirection</a> . <br><br><h2>  Ansible for deployment (provisioning) </h2><br>  Ideally, we should automate the assembly of the application server so that we do not have to manually repeat all the steps every time.  To do this, we can use the following Ansible script to deploy the application server: <br><br>  <a href="">app.yml</a> <br><pre> <code class="javascript hljs">--- - hosts: app tasks: - name: Install yum packages yum: name={{item}} state=latest with_items: - git - vim - nodejs - npm - name: install n (node version installer/switcher) npm: name=n state=present global=yes - name: install the latest stable version <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> node shell: n stable - name: Create web user user: name=web - name: Create project folder file: path=<span class="hljs-regexp"><span class="hljs-regexp">/var/</span></span>www group=web owner=web mode=<span class="hljs-number"><span class="hljs-number">755</span></span> state=directory - name: Add systemd conf template: src=systemd.service.j2 dest=<span class="hljs-regexp"><span class="hljs-regexp">/etc/</span></span>systemd/system/node-sample.service notify: - enable node-sample handlers: - name: enable node-sample shell: systemctl enable node-sample</code> </pre><br>  <a href="">systemd.service.j2</a> <br><pre> <code class="nginx hljs"> [Service] WorkingDirectory={{project_root}} ExecStart=/usr/bin/<span class="hljs-attribute"><span class="hljs-attribute">node</span></span> boot.js ExecReload=/bin/kill -HUP <span class="hljs-variable"><span class="hljs-variable">$MAINPID</span></span> Restart=always StandardOutput=syslog StandardError=syslog SyslogIdentifier={{project_name}} User=<span class="hljs-attribute"><span class="hljs-attribute">web</span></span> Group=web Environment=<span class="hljs-string"><span class="hljs-string">'NODE_ENV=production'</span></span> [Install] WantedBy=multi-user.target</code> </pre><br>  It <code>ansible-playbook -i [inventory file] app.yml <br></code> like this: <code>ansible-playbook -i [inventory file] app.yml <br></code> <code>ansible-playbook -i [inventory file] app.yml <br></code>  . <br><br>  <a href="">But the same for the balancer</a> . <br><br><h2>  Final application </h2><br>  <a href="https://github.com/jdxcode/node-sample">Here is the final result of all these steps</a> .  As it says, to run the application, you need to: update the inventory file, deploy our servers and run the application application. <br><br><h2>  Test environment? </h2><br>  Creating a new environment is easy.  Add another inventory file (ansible / production) for tests and can refer to it when you call the <code>ansible-playbook <br></code> <code>ansible-playbook <br></code>  . <br><br><h2>  Testing </h2><br>  <b>Test your system</b> .  Even discarding other reasons, it‚Äôs really fun to try and find a way to bring down your cluster.  Use <a href="http://blog.remarkablelabs.com/2012/11/benchmarking-and-load-testing-with-siege">Siege</a> to create a load.  Try sending kill -9 to different processes.  Shut down the server completely.  Send arbitrary signals to processes.  Drive a drive.  Just find things that can ruin your cluster and insure yourself from sinking% uptime. <br><br><h2>  What can be improved </h2><br>  There are no perfect clusters, and this is no exception.  I would calmly put it in production, but in the future something can be strengthened: <br><br><h2>  HAProxy Failover </h2><br>  At the moment, HAProxy is a single point of failure, although it is reliable.  We could remove it using a DNS failover.  It is not instantaneous and will give several seconds of idle time while the DNS record is being distributed.  I do not worry that HAProxy will fall by itself, but there is a high probability of human error when changing its configuration. <br><br><h2>  Rolling deploys </h2><br>  In case the next deployment breaks the cluster, I would set up a <a href="http://docs.ansible.com/guide_rolling_upgrade.html">consistent deployment</a> in Ansible to gradually roll out the changes, checking the availability of servers along the way. <br><br><h2>  Dynamic inventory files </h2><br>  I think some will be more important than me.  In this guide, we had to save server addresses in source code.  You can configure Ansible to <a href="http://docs.ansible.com/intro_dynamic_inventory.html">dynamically request a</a> list of hosts on Digital Ocean (or another provider).  You can even create new servers this way.  However, creating a server on the Digital Ocean is not the most difficult task. <br><br><h2>  Centralized logging </h2><br>  JSON logs are a great thing if you want to easily aggregate them and search them.  I would look at <a href="http://www.joyent.com/blog/node-js-in-production-runtime-log-snooping">Bunyan</a> for this. <br><br>  It would be great if the logs of all servers flow into one place.  You can use something like <a href="http://loggly.com/">Loggly</a> , but you can try other ways. <br><br><h2>  Error reporting and monitoring </h2><br>  There are many solutions for error collection and logging.  I didn‚Äôt like any of the ones I tried, so I‚Äôm not going to advise you anything.  If you know a good tool for this, please write about it in the comments. <br><br>  I recommend an excellent <a href="http://www.joyent.com/developers/node/deploy">guide to running Node.js in production</a> from Joyent - there are a lot of additional tips. <br><br><h4>  That's all!  We built a simple, stable Node.js cluster.  Let me know if you have any idea how to improve it! </h4><br><br><blockquote>  <i>From the translator: thanks for being here.</i>  <i>For the first time I try myself as a translator.</i>  <i>I am sure that not everything translated correctly, so please send error messages, as well as typos and design problems by internal mail.</i> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/270385/">https://habr.com/ru/post/270385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270377/index.html">Magento 2.0 Release Candidate Released</a></li>
<li><a href="../270379/index.html">Half a Century to "Universal Machine Languages" (1966‚Äì2016): Past, Present, Future</a></li>
<li><a href="../27038/index.html">Wiki implementation in the IT department</a></li>
<li><a href="../270381/index.html">TvOS application development</a></li>
<li><a href="../270383/index.html">Java Programmer Cheat Sheet 4. Java Stream API</a></li>
<li><a href="../270387/index.html">NSA recognized the possibility of using zero-day exploits for cyber attacks</a></li>
<li><a href="../270389/index.html">Font Lato: Sketch vs Android Studio</a></li>
<li><a href="../27039/index.html">Linux advertising from IBM 2003</a></li>
<li><a href="../270391/index.html">Increase system fault tolerance by nodejs</a></li>
<li><a href="../270393/index.html">ZeroNights HackQuest 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>