<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ cross-platform integral types</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my library I try to write cross-platform code, where possible, according to the C ++ standard, so for integral types I use only the standard ‚Äúten‚Äù ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ cross-platform integral types</h1><div class="post__text post__text-html js-mediator-article">  In my library I try to write cross-platform code, where possible, according to the C ++ standard, so for integral types I use only the standard ‚Äúten‚Äù (signed char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long) and no DWORD, __int64, etc.  However, sometimes you want to determine the type of 4 bytes to exactly 4, and not the "system word", "address size", etc.  The C ++ standard only speaks in vain: char can no longer be short, which cannot be greater than int, which cannot be longer than long, which cannot be greater than long long. <br><br>  Having embraced the magic of generic programming using patterns, I decided to implement a cross-platform class that generates an integral type of the required size at compile time.  The basic techniques that I use for this are recurrent type redefinition and partial specialization of templates. <br><a name="habracut"></a><br>  Let's start with the formalization of the definition.  For each standard type, it is necessary to determine the ‚Äúnext‚Äù type, which is necessary for the search algorithm of suitable variants.  Using partial specialization, we implement the type_traits template: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;unsigned char&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;unsigned short&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;unsigned int&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;unsigned long&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;unsigned long long int&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;signed char&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;short&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;int&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;long&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> current_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next_type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_traits</span></span></span><span class="hljs-class"> &lt;long long int&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current_type;};</code> </pre> <br>  The peculiarity of the types (unsigned) long long int is that next_type is not defined for them, since there is nothing more guaranteed for them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Next, you should determine the basic pattern of the selection algorithm, which contains two parameters: type is a standard numeric type and bool variable, which is true if this type is suitable in size or false if it is not.  In the default implementation, we take the type ‚Äúcurrent type‚Äù from the type - type_traits :: current_type, and if the type does not match, we take the ‚Äúnext type‚Äù - type_traits :: next_type: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    template&lt;typename type, bool&gt; struct type_choice { typedef typename type_traits&lt;type&gt;::current_type std_type; }; template&lt;typename type&gt; struct type_choice&lt;type, false&gt; { typedef typename type_traits&lt;type&gt;::next_type next_type; typedef typename type_choice&lt;next_type, sizeof(next_type) == capacity&gt;::std_type std_type; };</span></span></code> </pre><br>  The third service template is designed to select the initial version, which we have two, depending on whether we want to use the signed or unsigned type - char or unsigned char: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      template &lt;bool is_signed&gt; struct base_type_selector { typedef signed char base_type; }; template &lt;&gt; struct base_type_selector&lt;false&gt; { typedef unsigned char base_type; };</span></span></code> </pre><br>  Finally, you need to define the main class, which will contain the desired type.  I called this class fixed_int, it has two template parameters: the first parameter is of type size_t and indicates the desired capacity in bytes, the second parameter is boolean and is responsible for the type sign.  The class of open entities contains only one magic typedef: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type_choice&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type_selector&lt;is_signed&gt;::base_type, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(base_type_selector&lt;is_signed&gt;::base_type) == capacity &gt;::std_type type;</code> </pre><br>  You can arrange the main and service classes in different ways.  Wise MVS compiler compile local template classes without hesitation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_signed&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fixed_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//          template &lt;int x&gt; struct unsupported_capacity { int i[1/(xx)]; }; template &lt;&gt; struct unsupported_capacity&lt;1&gt; {}; template &lt;&gt; struct unsupported_capacity&lt;2&gt; {}; template &lt;&gt; struct unsupported_capacity&lt;4&gt; {}; template &lt;&gt; struct unsupported_capacity&lt;8&gt; {}; //   ,    template&lt;typename type&gt; struct type_traits; template&lt;&gt; struct type_traits &lt;unsigned char&gt; { typedef unsigned char current_type; typedef unsigned short next_type; }; template&lt;&gt; struct type_traits &lt;unsigned short&gt; { typedef unsigned short current_type; typedef unsigned int next_type; }; template&lt;&gt; struct type_traits &lt;unsigned int&gt; { typedef unsigned int current_type; typedef unsigned long next_type; }; template&lt;&gt; struct type_traits &lt;unsigned long&gt; { typedef unsigned long current_type; typedef unsigned long long next_type; }; template&lt;&gt; struct type_traits &lt;unsigned long long int&gt; { typedef unsigned long long int current_type; typedef unsupported_capacity&lt;capacity&gt; next_type; }; template&lt;&gt; struct type_traits &lt;signed char&gt; { typedef signed char current_type; typedef short next_type; }; template&lt;&gt; struct type_traits &lt;short&gt; { typedef short current_type; typedef int next_type; }; template&lt;&gt; struct type_traits &lt;int&gt; { typedef int current_type; typedef long next_type; }; template&lt;&gt; struct type_traits &lt;long&gt; { typedef long current_type; typedef long long next_type; }; template&lt;&gt; struct type_traits &lt;long long int&gt; { typedef long long int current_type; typedef unsupported_capacity&lt;capacity&gt; next_type;}; //    template&lt;typename type, bool&gt; struct type_choice { typedef typename type_traits&lt;type&gt;::current_type std_type; }; template&lt;typename type&gt; struct type_choice&lt;type, false&gt; { typedef typename type_traits&lt;type&gt;::next_type next_type; typedef typename type_choice&lt;next_type, sizeof(next_type) == capacity&gt;::std_type std_type; }; //      template &lt;bool is_signed&gt; struct base_type_selector { typedef signed char base_type; }; template &lt;&gt; struct base_type_selector&lt;false&gt; { typedef unsigned char base_type; }; public: typedef typename type_choice&lt; typename base_type_selector&lt;is_signed&gt;::base_type, sizeof(base_type_selector&lt;is_signed&gt;::base_type) == capacity &gt;::std_type type; };</span></span></code> </pre><br>  Less intelligent compilers may not understand this construction, for example, Qt complains about partial specialization of a template class inside another template class.  For such cases, internal service templates can be rendered separately in the namespace of __private, in order not to litter the common namespace, this method in such cases uses Alexandrescu in its Loki library (for example, for type lists). <br><br>  It remains to add convenient names for all types, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;::type uint8; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;::type uint16; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;::type uint32; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;::type uint64; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;::type int8; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;::type int16; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;::type int32; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fixed_int&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;::type int64;</code> </pre><br>  ... and check what came out of all this (launched under MVS2015 / intel 0x86): <br><br><pre> <code class="cpp hljs">... int32 x1; uint64 x2; fixed_int&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;::type x3; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wcout&lt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(x1).name()&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wcout&lt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(x2).name()&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wcout&lt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(x3).name()&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; ...</code> </pre><br>  Result: <br><br><pre> <code class="dos hljs">int unsigned __int64 short</code> </pre><br>  So we got cross-platform fixed types that do not use any third-party information for their definition.  As a fee, additional calculations are made at the compilation stage.  Incorrect template parameters or the inability to maintain this dimension on any platform will lead to a compilation error, which is also a plus. <br><br>  PS: Since the description of template instantiation errors suffers from some complexity, I used a non-controversial technique: defining a template helper class that compiles only partial specializations: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//          template &lt;int x&gt; struct unsupported_capacity { int i[1/(xx)]; }; template &lt;&gt; struct unsupported_capacity&lt;1&gt; {}; template &lt;&gt; struct unsupported_capacity&lt;2&gt; {}; template &lt;&gt; struct unsupported_capacity&lt;4&gt; {}; template &lt;&gt; struct unsupported_capacity&lt;8&gt; {};</span></span></code> </pre><br>  Not indisputable mainly because the description of errors in the standard is not defined, and then the benefits of this class are not guaranteed.  Microsoft's compiler when trying to instantiate this type of fixed_int &lt;3, true&gt; :: type gives an error: <br><br><pre> <code class="cpp hljs">exp4.cpp(<span class="hljs-number"><span class="hljs-number">127</span></span>): error C2057: expected constant expression exp4.cpp(<span class="hljs-number"><span class="hljs-number">156</span></span>) : see reference to <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">instantiation</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fixed_int</span></span></span><span class="hljs-class">&lt;3,true&gt;:</span></span>:unsupported_capacity&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;<span class="hljs-string"><span class="hljs-string">' being compiled ...</span></span></code> </pre><br><br>  PS: Replaced char types with signed char and (unsigned) long long with (unsigned) long long int </div><p>Source: <a href="https://habr.com/ru/post/280542/">https://habr.com/ru/post/280542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280532/index.html">5 tips from experts on how to build a career in IT</a></li>
<li><a href="../280534/index.html">#FailOverConf April 8th! We leave to the finish line ...</a></li>
<li><a href="../280536/index.html">MapFont, Using Fonts with Icons in Map Services</a></li>
<li><a href="../280538/index.html">Simple SQL Server Tool in C #</a></li>
<li><a href="../280540/index.html">Student applications for KolibriOS projects within the framework of Google Summer of Code</a></li>
<li><a href="../280544/index.html">Malefactors use Linux / Remaiten bot to compromise embedded devices, part 1</a></li>
<li><a href="../280546/index.html">NPM has forbidden to withdraw modules older than 24 hours without permission from open-source</a></li>
<li><a href="../280548/index.html">Report from Android Devs Meetup March 17</a></li>
<li><a href="../280550/index.html">To help DevOps: a firmware builder for network devices on Debian for 1008 hours</a></li>
<li><a href="../280552/index.html">Logeek Night meeting for Java specialists from Kazan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>