<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity3D 3.x Terrain Bump Specular Shader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Currently, Unity3D does not support overlaying the specular map with the built-in landscape. Googling about this has brought not very impressive resul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity3D 3.x Terrain Bump Specular Shader</h1><div class="post__text post__text-html js-mediator-article">  Currently, <a href="http://unity3d.com/">Unity3D</a> does not support overlaying the specular map with the built-in landscape.  Googling about this has brought not very impressive results in the form of <a href="http://sixtimesnothing.wordpress.com/2010/10/10/bump-mapping-for-built-in-unity-terrain/">this</a> shader and some of its modifications.  Inspired by the picture and downloading the archive, I was disappointed.  Firstly, for the operation of the shader on the landscape, it is necessary to hang a script that controls the shader (which is very inconvenient), and secondly, in this implementation, more than 4 normal maps can not be assigned. <br>  In this article I will describe the process of creating your own shader for the landscape, at the same time telling how the standard shader works. <br><a name="habracut"></a><br><h4>  Landscape rendering mechanism in standard unit shaders </h4><br>  To draw a landscape in a unit, two shaders are used: <br>  <u>Hidden / TerrainEngine / Splatmap / Lightmap-FirstPass</u> and <u>Hidden / TerrainEngine / Splatmap / Lightmap-AddPass</u> , you can download them <a href="http://unity3d.com/support/resources/assets/built-in-shaders">here</a> <br><br>  The first shader draws the first 4 textures of the landscape.  The second shader sequentially draws the rest of the textures 4 at a time until the textures run out. <br><br>  So what is transferred to the shader from the engine: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs swift">... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_Control : <span class="hljs-type"><span class="hljs-type">TEXCOORD0</span></span>; float2 uv_Splat0 : <span class="hljs-type"><span class="hljs-type">TEXCOORD1</span></span>; float2 uv_Splat1 : <span class="hljs-type"><span class="hljs-type">TEXCOORD2</span></span>; float2 uv_Splat2 : <span class="hljs-type"><span class="hljs-type">TEXCOORD3</span></span>; float2 uv_Splat3 : <span class="hljs-type"><span class="hljs-type">TEXCOORD4</span></span>; }; sampler2D _Control; sampler2D _Splat0,_Splat1,_Splat2,_Splat3; ...</code> </pre> <br><br>  <b>_SplatX</b> - texture with material <br>  <b>_Control</b> - control card.  This is a texture in which each of the channels sets the brightness of one of the materials at a certain point.  The control map is created on the basis of the landscape materials map (Alphamaps) for each of the four materials in the depths of the engine.  Just because the control texture has 4 channels, the shaders render no more than 4 materials at a time. <br><br><img src="https://habrastorage.org/storage2/824/43b/495/82443b4959591f687f68cc31fbb1fe93.png"><br><img src="https://habrastorage.org/storage2/e07/555/04e/e0755504e2627ce0d330a7d7ca5ecbc0.png"><br><br>  Let us see what happens next in the shader: <br><br>  It has a single procedure in which the color of the current point (o.Albedo) is considered, and it is equal to the sum of the brightness products of a point from the RGBA control card and its color from the material texture. <br><br><pre> <code class="hljs vbscript"> ... void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutput o) { half4 splat_control = tex2D (_Control, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Control); half3 col; col = splat_control.r * tex2D (_Splat0, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat0).<span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>; col += splat_control.g * tex2D (_Splat1, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat1).<span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>; col += splat_control.b * tex2D (_Splat2, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat2).<span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>; col += splat_control.a * tex2D (_Splat3, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat3).<span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>; o.Albedo = col; o.Alpha = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; } ...</code> </pre><br><br>  The result of his work can be seen below: <br><br><img src="https://habrastorage.org/storage2/61f/a9f/ba0/61fa9fba0b545b73cdede33c1be32a4e.png"><br><br>  The flare in this case occurred due to the imposition of several materials (channels) on the control card, in real conditions this should not be, because  usually one material on a landscape smoothly passes into another, and quite rarely you have to put one material on another. <br><br>  I will not consider the second shader, since  it is almost identical, only used for textures with an index above 3. <br><br><h5>  Creating your own shader </h5><br>  Since in one pass there can be only 4 materials and I don‚Äôt want to resort to using scripts to assign normals to the shader, we will thrust the normals through the landscape, as shown in the picture below. <br>  Now every second texture on the landscape is normal to the previous material.  <u>It is important that in the inspector of this texture the type is set - normal.</u>  In addition, we have an unused channel <b>A</b> in the texture of the material, in which the Specular map fits perfectly. <br><br><img src="https://habrastorage.org/storage2/f00/9ee/1c6/f009ee1c616473c924c2f8ad0ae6d9d3.png"><br><br>  New procedure surf: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutput o) { fixed4 splat_control = tex2D (_Control, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Control); fixed3 col; fixed spec; // RGBA     fixed4 d1 = tex2D (_Splat0, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat0); // RGBA     fixed4 d2 = tex2D (_Splat2, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat2); //      fixed3 n1 = UnpackNormal( tex2D (_Splat1, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat1) ); //      fixed3 n2 = UnpackNormal( tex2D (_Splat3, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_Splat3) ); //        col = splat_control.r * d1.rgb; //  (  ) o.Normal = normalize(lerp(fixed3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), n1, clamp(splat_control.r + <span class="hljs-number"><span class="hljs-number">0.3</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))); //        ,      . "0.1" -   ,    . spec = (<span class="hljs-number"><span class="hljs-number">1</span></span> - d1.a) * splat_control.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; //        col += splat_control.b * d2.rgb; o.Normal += normalize(lerp(fixed3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), n2, clamp(splat_control.b + <span class="hljs-number"><span class="hljs-number">0.3</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))); spec += (<span class="hljs-number"><span class="hljs-number">1</span></span> - d2.a) * splat_control.b * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; //  ,   basemap<span class="hljs-string"><span class="hljs-string">' o.Albedo = col * 0.5; //  o.Specular = spec; o.Gloss = spec; o.Alpha = 0.0; }</span></span></code> </pre><br><br>  Everything should be clear in the procedure, since apart from arithmetic operations there is almost nothing left.  The only thing I would like to make out is this line: <br> <code>o.Normal = lerp(fixed3(0.5,0.5,1), n1, clamp(splat_control.r + 0.3,0,1));</code> <br>  A normal is a unit vector perpendicular to the surface.  And since we need to smoothly reduce it, we cannot simply multiply it by some coefficient.  To solve this problem, I interpolate the current normal in the so-called.  "Zero normal", in which the texture will not be any relief. <br><br>  In order for the normal map to apply, the mech must have counted tangents (a vector perpendicular to the normal and parallel to the surface, pointing upward to the U coordinate on the scan).  Usually they are considered by the software in which the model is developed, but since the landscape is built in a unit on the fly, there are no tangents there. <br>  We'll have to calculate the tangents inside the shader themselves: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v) { fixed3 T1 = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dot(T1,v.normal) &gt; <span class="hljs-number"><span class="hljs-number">0.99</span></span>) { T1 = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); //workaround } fixed3 Bi = <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(T1, v.normal); fixed3 newTangent = normalize(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(v.normal, Bi)); v.tangent.xyz = newTangent.xyz; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dot(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(v.normal,newTangent),Bi) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) v.tangent.w = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> v.tangent.w = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; }</code> </pre> <br><br>  The shader for subsequent passes is almost identical. <br><br>  For those who create the landscape dynamically, do not forget to correct the indices of materials in the code.  They must be multiplied by two, because  the odd indices are normals. <br><br> <code>materials[x, z, material_number*2] = 1; <br></code> <br>  Cons of this method: <br><ul><li>  Draw Calls increase slightly due to more shader passes </li><li>  Care must be taken not to paint on the landscape with the wrong material (normal). </li><li>  Uses more than 8 registers, making it impossible to compile under Flash </li><li>  Uses Shader 3.0 model, which makes it impossible to work on the old hardware (due to 64+ operations) </li></ul><br>  Briefly, for those who are too lazy to read: <br><ul><li>  Shader draws terrain with normals and spec cards </li><li>  Textures on the landscape should alternate through one.  Diffuser / Normal / Diffuser / Normal etc. </li><li>  The specular map is stored in the alpha channel diffuse </li></ul><br>  Result with a standard texture, and maps removed from it (became / was): <br><img src="http://habrastorage.org/storage2/d7e/5ad/478/d7e5ad47867468dd8fc4fc45fc741338.png"><br><br>  <a href="">Download Shader</a> </div><p>Source: <a href="https://habr.com/ru/post/144016/">https://habr.com/ru/post/144016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144011/index.html">RESTful API for the server - doing it right (Part 1)</a></li>
<li><a href="../144012/index.html">9facts: debriefing</a></li>
<li><a href="../144013/index.html">Three small useful utilities</a></li>
<li><a href="../144014/index.html">Writing Linux security module</a></li>
<li><a href="../144015/index.html">HP Pavilion dv7-7006er laptop video review</a></li>
<li><a href="../144017/index.html">ACM-ICPC 2012 World Programming Championship</a></li>
<li><a href="../144018/index.html">API 2GIS: 8 new map API and directory features</a></li>
<li><a href="../144019/index.html">Import birthdays from AD to the SharePoint portal</a></li>
<li><a href="../144020/index.html">How to create a video player on jQuery, HTML5 and CSS3</a></li>
<li><a href="../144022/index.html">We invite you to the online broadcast of the conference Microsoft and Intel for developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>