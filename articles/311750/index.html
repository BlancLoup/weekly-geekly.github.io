<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming & Music: ADSR-signal envelope. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 You are reading the second part of the article about creating a VST synthesizer in C #. In the first part , the SDK and the library for creat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming & Music: ADSR-signal envelope. Part 2</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello! <br>  You are reading the second part of the article about creating a VST synthesizer in C #.  In the <a href="https://habrahabr.ru/post/311220/">first part</a> , the SDK and the library for creating <a href="https://ru.wikipedia.org/wiki/Virtual_Studio_Technology">VST</a> plug <a href="https://ru.wikipedia.org/wiki/Virtual_Studio_Technology">-</a> ins were considered, the programming of the oscillator was considered. <br>  In this part I will tell about the signal envelopes, their varieties, application in sound processing.  The article will consider programming an ADSR envelope to control the amplitude of a signal generated by an oscillator. <br>  Envelopes are in any synthesizer, are used not only in the synthesis, but throughout the processing of sound. </p><br><p>  The source code for the <a href="https://www.youtube.com/watch%3Fv%3D6zAVMEtIb2w">synthesizer I've written</a> is available on <a href="https://github.com/lis355/Syntage">GitHub</a> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d2b/dc5/9aa/d2bdc59aae7d4df587af2a1ca129cdcd.png"></div><br><a name="habracut"></a><br><h2 id="cikl-statey">  Cycle of articles </h2><br><ol><li>  <a href="https://habrahabr.ru/post/311220/">We understand and write VSTi synthesizer on C # WPF</a> </li><li>  ADSR signal envelope </li><li>  <a href="https://habrahabr.ru/post/313062/">Buttervo Frequency Filter</a> </li><li>  <a href="https://habrahabr.ru/post/313338/">Delay, Distortion and Parameter Modulation</a> </li></ol><br><h2 id="oglavlenie">  Table of contents </h2><br><ol><li>  <a href="https://habr.com/ru/post/311750/">Envelope</a> </li><li>  <a href="https://habr.com/ru/post/311750/">Different types of envelopes in existing plugins</a> </li><li>  <a href="https://habr.com/ru/post/311750/">MIDI keystrokes</a> </li><li>  <a href="https://habr.com/ru/post/311750/">A more object-oriented approach in the oscillator code</a> </li><li>  <a href="https://habr.com/ru/post/311750/">Click to switch notes</a> </li><li>  <a href="https://habr.com/ru/post/311750/">ADSR Envelope Programming</a> </li><li>  <a href="https://habr.com/ru/post/311750/">Examples of sounds using ADSR-envelope</a> </li><li>  <a href="https://habr.com/ru/post/311750/">Bibliography</a> </li></ol><br><a name="Part1"></a><br><h2 id="ogibayuschaya">  Envelope </h2><br><p>  From the point of view of mathematics, the <em>envelope curve</em> (or function) is such a curve (function), which at each point touches a certain set.  This may be a set of curves, points, shapes, elements.  It <em>goes around a</em> given set.  One can imagine that the envelope is a certain boundary that limits the elements of the set. </p><br><p>  Imagine a set of identical circles, the centers of which are located on the same line.  Their envelopes are two parallel straight lines.  These envelopes are, in fact, boundaries for sets of points of circles. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a9a/dc5/ea4/a9adc5ea44d846d3a6f964bb9ea563fb.gif"></div><br><p>  <em>Envelopes for circles.</em>  <em>Screenshot taken from dic.academic.ru</em> </p><br><p>  In terms of synthesizing and processing signals, the envelope is a function that describes changes in a parameter over time. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2fb/c36/274/2fbc362746694ec8bf62fc6f6ae63f5f.jpg"></div><br><p>  <em>The red curve is the wave amplitude envelope.</em>  <em>Screenshot taken from the site www.kit-e.ru</em> </p><br><p>  The envelopes are mainly used to describe changes in the amplitude of the signal.  But no one forbids you to use the envelope to describe changes in the cutoff frequency of the filter (cutoff), pitch (pitch), pan (pan) and some other existing parameters of the synthesizer. </p><br><p>  In the real world, the sound volume of a musical instrument changes over time.  Each instrument has its own specific volume changes.  For example, the organ with the pressed key of the corresponding note plays it at a constant volume, and the guitar reproduces the sound as loud as possible only at the moment of striking the string, after which it fades smoothly.  It is typical for wind and string instruments to achieve maximum sound volume not immediately, but some time after taking the note. </p><br><p>  The ADSR-envelope allows describing changes in sound volume as 4 consecutive phases with parameters: </p><br><ol><li>  <em>Attack</em> - The phase of increasing the signal from complete silence to the maximum volume level of the signal.  Attack time (they say simply ‚Äúattack‚Äù) is the time needed for the volume of the signal to reach its maximum level.  Any signal has an attack, since the amplitude (in real life) changes continuously, without jumps. </li><li>  <em>Decay</em> ‚Äî The phase of the falloff of the signal to the level specified in the Sustain phase.  Similarly, the parameter is the fall time. </li><li>  <em>Sustain (Hold)</em> - the phase of "stable sound" with a constant predetermined amplitude.  If you describe pressing a key on the piano, the Sustain phase lasts until the player holds the key pressed.  Of course, in a real piano, if you keep the key pressed for a long time, the sound will gradually subside.  If we look at the synthesizer, then it can continue to generate a note, and in this phase we will hear a constant signal, which does not vary in amplitude. </li><li>  <em>Release (Attenuation)</em> - the attenuation phase of the signal.  Determines the time (say "release") necessary for the final decline of the signal amplitude to zero.  On the piano, this phase begins as soon as the key is released. </li></ol><br><p>  Consider the graph at the beginning of the article, the notation: </p><br><ul><li>  <em>As</em> is the amplitude value of the signal in the Sustain state. </li><li>  <em>Ta</em> - Attack time </li><li>  <em>Td</em> - Decay status time </li><li>  <em>Tr</em> - release state time </li><li>  <em>Tkey</em> - key / note hold time (from start to release) </li></ul><br><p>  Imagine that we generate a certain harmonic with an oscillator with an amplitude of c maximum level <em>k</em> (the sine values ‚Äã‚Äãwill be from - <em>k</em> to <em>k</em> ). <br>  Consider the use of an ADSR envelope for this signal. <br>  Since at the moment of transition from the Attack phase to the Decay phase, the signal amplitude is maximal (in the graph it is 1), we can consider the application of the envelope as a multiplication of the current signal level by the current envelope value.  In this case, "maximum amplitude" means that the signal is not limited (does not change) to the envelope and its amplitude will be equal to <em>k</em> . </p><br><p>  At the time of the beginning of the signal generation, the attack phase begins.  During Ta, the signal increases to the level of 1 * <em>k</em> .  After the Decay phase begins, during Td the level value decreases to As * <em>k</em> . <br>  The envelope goes into the Sustain phase - it is not limited in time.  After the transition to the Release phase (pressed key), the signal amplitude decreases to zero during the time Tr. </p><br><p>  What if we release the note until the Decay or Sustain phase occurs?  In any case, we have to go into the Release phase, which will start at the current signal level. </p><br><p>  It is important to understand that the Sustain parameter is <strong>the</strong> signal <strong>level</strong> , as opposed to the Attack, Delay, Release parameters - which represent <strong>time</strong> (if you look at the ADSR charts on the Internet, you can catch some misunderstanding). </p><br><a name="Part2"></a><br><h2 id="razlichnye-vidy-ogibayuschih-v-suschestvuyuschih-plaginah">  Different types of envelopes in existing plugins </h2><br><p>  There are a lot of information, articles, video tutorials on envelopes on the Internet - they are widely used, and especially in synthesizers for modulating parameters. <br>  No text can convey a picture, much less a sound.  Therefore, I recommend that you watch a couple of videos on YouTube for the query "adsr envelope": <a href="https://www.youtube.com/watch%3Fv%3DA6pp6OMU5r8">at least this, on the first link, is a valid explanation with an interactive</a> . </p><br><p>  In VST synthesizers, envelopes are used as: </p><br><ol><li>  ADSR envelope to control the volume of the signal after the oscillator </li><li>  More complex envelopes for modulating parameters </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/702/34c/b43/70234cb43dc44e33b5ba2a68c29dc88c.png"></div><br><p>  <em>The ADSR envelope processes the amplitude of the sound from two oscillators.</em>  <em>Screenshot from Sylenth1 synthesizer</em> </p><br><p>  Often, a Hold phase is added to the ADSR envelope ‚Äî a phase with a finite time and maximum amplitude between the Attack and Decay phases. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/470/d7d/3e3/470d7d3e36f84321b138d8b213626b70.png"></div><br><p>  <em>AHDSR envelope (Hold phase added) in the Serum synthesizer, in the envelope block to modulate the parameters</em> </p><br><p>  There are more complex envelopes - <a href="http://ru.wikipedia.org/wiki/ADSR-%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25B1%25D0%25B0%25D1%258E%25D1%2589%25D0%25B0%25D1%258F">ADBSSR-envelope</a> . </p><br><a name="Part3"></a><br><h2 id="midi-soobscheniya-nazhatiya-klavish">  MIDI keystrokes </h2><br><p>  Moving on to programming and reviewing the code I wrote, the synth.  ( <a href="https://github.com/lis355/Syntage">GitHub Link</a> ) </p><br><p>  <a href="https://habrahabr.ru/post/311220/">In the last article</a> , a simple oscillator was considered that generates a wave according to a table of a certain frequency right from the start of the plug-in.  It also says how to build a project and consider the architecture of the code. </p><br><p>  Screw Midi messages to the oscillator so that the signal is generated only if the key is held down. </p><br><p>  To get Midi messages from the host, the plugin class (derived from SyntagePlugin) must overload the CreateMidiProcessor method, which returns an IVstMidiProcessor. <br>  Syntage.Framework has a ready-made MidiListener class that implements IVstMidiProcessor. <br>  MidiListener has OnNoteOn and OnNoteOff events, which we will use in the oscillator. </p><br><p>  Now the oscillator will not have a frequency parameter (Frequency), since the frequency will be determined by the key held down. <br>  We subscribe to the OnNoteOn and OnNoteOff events in the constructor and implement them. </p><br><pre><code class="hljs ruby">private int _note = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>      ... public Oscillator(AudioProcessor audioProcessor) : base(audioProcessor) { _stream = Processor.CreateAudioStream(); audioProcessor.PluginController.MidiListener.OnNoteOn += MidiListenerOnNoteOn; audioProcessor.PluginController.MidiListener.OnNoteOff += MidiListenerOnNoteOff; } private void MidiListenerOnNoteOn(object sender, MidiListener.NoteEventArgs e) { _time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   _note = e.NoteAbsolute; } private void MidiListenerOnNoteOff(object sender, MidiListener.NoteEventArgs e) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_note == e.NoteAbsolute) _note = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  The event handler comes with the NoteEventArgs argument, which has information about the note, octave, and velocity (note velocity). </p><br><p>  The minimum distance between the notes is semitone, respectively, the integer absolute value of the note (its number) we will measure as the number of semitones from a certain bass note (we will understand some later).  Why?  This is convenient for the formula for obtaining frequency by note number. </p><br><p>  A bit of theory - now <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2580%25D0%25BD%25D0%25BE_%25D1%2582%25D0%25B5%25D0%25BC%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B9">evenly tempered mode</a> rules in music. <br>  The octave is a range of 12 semitones, of 12 different notes (in the major and minor keys of the note 7, since there is a tone between some notes, and between some notes a semitone). <br>  The whole scale is divided into octaves.  Accordingly, the entire audible frequency spectrum is also divided into octave segments. <br>  A note an octave higher will have twice the frequency, but to be called the same. </p><br><p>  To calculate the frequency of the note, which is separated by i semitones from the reference note with the frequency f0, use the following formula: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9b2/347/434/9b2347434c7644ebb354eaf30c0ff836.latex"></div><br><p>  We write the corresponding static function in the auxiliary class DSPFunctions: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNoteFrequency</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> note</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">440</span></span> * Math.Pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, (note - <span class="hljs-number"><span class="hljs-number">69</span></span>) / <span class="hljs-number"><span class="hljs-number">12.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br><p>  Here, the note of the first octave (440 Hz) is taken as the standard.  From the formula, it is clear that the note with the ‚Äúnumber‚Äù 0 is lower than the first octave by 69 semitones, it is the note up with a frequency of 8.1758 Hz (even lower by an octave than in the subcontractacle), the first octave of the same number will be 69. Why this note?  Apparently, it was the way people agreed when they made keyboards for synthesizers, so that "with a margin." </p><br><p>  Now, you need to generate a signal while the _note! = -1 condition is met. </p><br><p>  Our mono oscillator - no matter how many keys you press on the keyboard, only the last key pressed will be perceived.  After reading the following chapters, you can program a polyphonic oscillator, I will not talk about it - I decided not to complicate it. </p><br><a name="Part4"></a><br><h2 id="bolee-obektno-orientirovannyy-podhod-v-kode-oscillyatora">  A more object-oriented approach in the oscillator code </h2><br><p>  The OnNoteOn and OnNoteOff handlers tell us that a specific key has been pressed or removed.  Inside the oscillator, we define the current key of the integer variable _note, and the absence of the pressed key is interpreted as the value -1. </p><br><p>  It's time to move to a higher level: I propose to write a class to represent the generated tone (especially in the future, it will simplify our life). </p><br><p>  The tone is characterized by the number and elapsed time from the start - so far nothing new, just added clarity to the code: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tone</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Note; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Time; }</code> </pre> <br><p>  Accordingly, now the oscillator has a Tone _tone field, which will be null in the absence of a clamped key. <br>  Moreover, with such a class it will be easier to program a polyphonic oscillator. </p><br><a name="Part5"></a><br><h2 id="schelchek-pri-pereklyuchenii-noty">  Click to switch notes </h2><br><p>  Imagine the following situation: you pressed a note on the keyboard, the oscillator started to generate a harmonic with a given frequency, then you press the next note and the oscillator immediately switches the frequency and the phase (time) is reset.  This means that there will be a gap in the wave, which by ear leads to artifacts and clicks. </p><br><p>  To generate a wave from a table, we found the ‚Äúrelative phase‚Äù as a value from 0 to 1, where 1 was understood as the full wave period.  If we change the frequency of the wave, but leave the same "relative phase", the wave values ‚Äã‚Äãwill coincide and there will be no click. </p><br><p>  It is necessary to determine the starting time for a new note, if a note with a different frequency is currently being generated. <br>  The formula from the previous article for the "relative phase": </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3aa/e1b/ebb/3aae1bebbf6a40a785cf8a6a0e0598d9.gif"></div><br><p>  Accordingly, knowing the new frequency, we get the right time: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e3b/38a/101/e3b38a1014d148078037091a39d51aac.gif"></div><br><p>  In code, it looks like this: </p><br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">void</span></span> MidiListenerOnNoteOn(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, MidiListener.NoteEventArgs e) { var newNote = e.NoteAbsolute; //     ,    ,     <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tone != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { //   <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> var tonePhase = DSPFunctions.Frac(_tone.Time * DSPFunctions.GetNoteFrequency(_tone.Note)); //       ,     <span class="hljs-type"><span class="hljs-type">time</span></span> = tonePhase / DSPFunctions.GetNoteFrequency(newNote); } _tone = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Tone { <span class="hljs-type"><span class="hljs-type">Time</span></span> = <span class="hljs-type"><span class="hljs-type">time</span></span>, Note = e.NoteAbsolute }; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Full code oscillator for lazy</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Oscillator : SyntageAudioProcessorComponentWithParameters&lt;AudioProcessor&gt;, IGenerator { private <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Tone { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Note; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">Time</span></span>; } private readonly IAudioStream _stream; private Tone _tone; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> VolumeParameter Volume { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> EnumParameter&lt;WaveGenerator.EOscillatorType&gt; OscillatorType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Fine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Panning { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Oscillator(AudioProcessor audioProcessor) : base(audioProcessor) { _stream = Processor.CreateAudioStream(); audioProcessor.PluginController.MidiListener.OnNoteOn += MidiListenerOnNoteOn; audioProcessor.PluginController.MidiListener.OnNoteOff += MidiListenerOnNoteOff; } private <span class="hljs-type"><span class="hljs-type">void</span></span> MidiListenerOnNoteOn(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, MidiListener.NoteEventArgs e) { var newNote = e.NoteAbsolute; //     ,    ,     <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tone != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { //   <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> var tonePhase = DSPFunctions.Frac(_tone.Time * DSPFunctions.GetNoteFrequency(_tone.Note)); //       ,     <span class="hljs-type"><span class="hljs-type">time</span></span> = tonePhase / DSPFunctions.GetNoteFrequency(newNote); } _tone = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Tone { <span class="hljs-type"><span class="hljs-type">Time</span></span> = <span class="hljs-type"><span class="hljs-type">time</span></span>, Note = e.NoteAbsolute }; } private <span class="hljs-type"><span class="hljs-type">void</span></span> MidiListenerOnNoteOff(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, MidiListener.NoteEventArgs e) { //  ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tone != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; _tone.Note == e.NoteAbsolute) _tone = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override IEnumerable&lt;Parameter&gt; CreateParameters(string parameterPrefix) { Volume = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> VolumeParameter(parameterPrefix + "Vol", "Oscillator Volume"); OscillatorType = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EnumParameter&lt;WaveGenerator.EOscillatorType&gt;(parameterPrefix + "Osc", "Oscillator Type", "Osc", <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); Fine = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Fine", "Oscillator pitch", "Fine", <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); Fine.SetDefaultValue(<span class="hljs-number"><span class="hljs-number">0</span></span>); Panning = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Pan", "Oscillator Panorama", "", <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); Panning.SetDefaultValue(<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;Parameter&gt; {Volume, OscillatorType, Fine, Panning}; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IAudioStream Generate() { _stream.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tone != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) GenerateToneToStream(_tone); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stream; } private <span class="hljs-type"><span class="hljs-type">void</span></span> GenerateToneToStream(Tone tone) { var leftChannel = _stream.Channels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; var rightChannel = _stream.Channels[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">double</span></span> timeDelta = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / Processor.SampleRate; var count = Processor.CurrentStreamLenght; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { var frequency = DSPFunctions.GetNoteFrequency(tone.Note); var sample = WaveGenerator.GenerateNextSample(OscillatorType.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>, frequency, tone.Time); sample *= Volume.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; var panR = Panning.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; var panL = <span class="hljs-number"><span class="hljs-number">1</span></span> - panR; leftChannel.Samples[i] += sample * panL; rightChannel.Samples[i] += sample * panR; tone.Time += timeDelta; } } }</code> </pre> </div></div><br><a name="Part6"></a><br><h2 id="programmirovanie-adsr-ogibayuschey">  ADSR Envelope Programming </h2><br><p>  After the oscillator, the signal goes to the ADSR-envelope processing, which will change its amplitude (volume). <br>  When you press a key, the envelope enters the Attack phase, while pressing the key, the envelope enters the Release phase.  In this phase, the signal should smoothly (meaning without clicks, and so quickly or slowly decide the user twisting the knobs of parameters) to subside. </p><br><p>  The oscillator stops generating a signal when pushing a key - the envelope will not be able to correctly process the Release phase.  In the Release phase, the signal must continue to be generated by an oscillator, and the envelope will do its job to attenuate the volume. <br>  To do this, remove the OnNoteOff handler from the code of the oscillator - now the envelope will do this. </p><br><p>  As described in the <a href="https://habr.com/ru/post/311750/">"</a> Envelope <a href="https://habr.com/ru/post/311750/">"</a> chapter, we use the envelope value as a multiplier for the signal sample.  The value of the envelope changes in time from 0 to 1, the value of 1 envelope takes only when switching between the Attack and Decay phases (when the value of the envelope is 1, the signal amplitude does not change). </p><br><p>  In order to program transitions from the ADSR phases, you need to code the state machine, so I will speak of <em>states</em> later, and not the envelope phases. </p><br><p>  The envelope has 4 parameters: Attack, Delay, Release, and Sustain amplitude multiplier.  Usually Attack, Delay is milliseconds, Release can already be comparable to the second. </p><br><p>  All 4 states replace each other always consistently: you can not jump from one state to another.  If the status of Attack, Delay or Release time will be zero - you can get a clip.  Therefore, the minimum of these parameters must be made non-zero.  I made the parameters Attack, Delay or Release from 0.01 to 1 second. </p><br><p>  The implementation will have the following hierarchy: the ADSR class is a framework for the envelope logic, which contains part of the synthesizer logic: the set of necessary parameters, keystroke event handlers, the Process function, which processes the sample stream. </p><br><p>  The envelope logic will be hidden in the NoteEnvelope class, which, in essence, requires only a method ‚Äî to get the current envelope value.  This method must be called sequentially for all stream samples and multiplied. </p><br><p>  It is important to agree on how to handle keystrokes.  For example, how to handle keystroke if another key is already pressed?  I studied it with the method of a close look, as it is done in the Sylenth1 synthesizer, if you do not use polyphony in it.  I decided to choose this strategy: </p><br><ul><li>  If the state of the keys has changed and the keys are now clamped, but not before - we register the press (go to the Attack state). </li><li>  If the state of the keys has changed and now there are no clamped keys, but there used to be - register the key removal (go to the Release state). </li></ul><br><p>  In simple words - we pay attention only to the change in the state of the keys "all released - at least one is clamped." </p><br><p>  Thus, when you press a new key and hold the current key, the frequency in the oscillator will simply switch, and the envelope will not respond to it.  When programming polyphony, everything becomes more complicated. </p><br><p>  Let us write all of the above in the ADSR framework class: parameters, keystroke handler, sample processing. </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ADSR : SyntageAudioProcessorComponentWithParameters&lt;AudioProcessor&gt;, IProcessor { private readonly NoteEnvelope _noteEnvelope; //     private <span class="hljs-type"><span class="hljs-type">int</span></span> _lastPressedNotesCount; // ,  ,     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Attack { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Decay { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Sustain { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ADSR(AudioProcessor audioProcessor) : base(audioProcessor) { _noteEnvelope = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> NoteEnvelope(this); Processor.<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.OnPressedNotesChanged += OnPressedNotesChanged; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override IEnumerable&lt;Parameter&gt; CreateParameters(string parameterPrefix) { Attack = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Atk", "Envelope Attack", "", <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); Decay = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Dec", "Envelope Decay", "", <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); Sustain = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Stn", "Envelope Sustain", "", <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Rel", "Envelope Release", "", <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;Parameter&gt; {Attack, Decay, Sustain, <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>}; } private <span class="hljs-type"><span class="hljs-type">void</span></span> OnPressedNotesChanged(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, EventArgs e) { //    - ,     -   //     ,     -    , //   var currentPressedNotesCount = Processor.<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.PressedNotesCount; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPressedNotesCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _lastPressedNotesCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _noteEnvelope.Press(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPressedNotesCount == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _lastPressedNotesCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { _noteEnvelope.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>(); } _lastPressedNotesCount = currentPressedNotesCount; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Process(IAudioStream stream) { var lc = stream.Channels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; var rc = stream.Channels[<span class="hljs-number"><span class="hljs-number">1</span></span>]; var count = Processor.CurrentStreamLenght; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { var multiplier = _noteEnvelope.GetNextMultiplier(); lc.Samples[i] *= multiplier; rc.Samples[i] *= multiplier; } } }</code> </pre> <br><p>  We start programming the logic of the envelope - the class NoteEnvelope.  As you can see from the above ADSR class code, the following public methods are needed from the NoteEnvelope class: </p><br><ol><li>  Press () - handle keystroke (go to Attack state) </li><li>  Release () - handle key press (go to the release state) </li><li>  GetNextMultiplier () - get the next envelope value </li></ol><br><p>  We define an enumeration for the states: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EState</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">None</span></span>, <span class="hljs-type"><span class="hljs-type">Attack</span></span>, <span class="hljs-type"><span class="hljs-type">Decay</span></span>, <span class="hljs-type"><span class="hljs-type">Sustain</span></span>, <span class="hljs-type"><span class="hljs-type">Release</span></span> }</code> </pre> <br><p>  We know the time between two samples, therefore we know the working time of the steits and the total working time of the envelope. <br>  In all states, the same logic is used to determine the current value: knowing the time from the start of the state, the state time (envelope parameters) interpolates the initial and final envelope values. <br>  For the Sustain state, the initial and final values ‚Äã‚Äãare the same, so the logic with interpolation here will also work correctly (although it is not useful here). </p><br><p>  The initial value and time for the state is determined at the moment of the state switching: </p><br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">void</span></span> SetState(EState newState) { //     -        _startMultiplier = (_time &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? _multiplier : GetCurrentStateFinishValue(); _state = newState; //     _time = GetCurrentStateMultiplier(); } private <span class="hljs-type"><span class="hljs-type">double</span></span> GetCurrentStateMultiplier() { switch (_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Attack: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Attack.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Decay: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Decay.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Sustain: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Sustain.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } }</code> </pre> <br><p>  Each call to the GetNextMultiplier () function needs to be reduced _time for the time between two samples.  If the time is less than or equal to zero, then you need to go to another state. <br>  The transition to the Release state is possible only from the Release () function. </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> GetNextMultiplier() { var startMultiplier = GetCurrentStateStartValue(); var finishMultiplier = GetCurrentStateFinishValue(); //  ,     var stateTime = <span class="hljs-number"><span class="hljs-number">1</span></span> - _time / GetCurrentStateMultiplier(); //    startMultiplier  finishMultiplier   CalculateLevel _multiplier = CalculateLevel(startMultiplier, finishMultiplier, stateTime); switch (_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Attack: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) SetState(EState.Decay); break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Decay: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) SetState(EState.Sustain); break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Sustain: //      break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) SetState(EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>); break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } //     var timeDelta = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / _ownerEnvelope.Processor.SampleRate; _time -= timeDelta; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _multiplier; }</code> </pre> <br><p>  The end time for states is obvious: for Attack - 1, for Decay and Sustain - the amplitude parameter Sustain, for Release - 0. </p><br><div class="spoiler">  <b class="spoiler_title">Full ADSR Envelope Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ADSR : SyntageAudioProcessorComponentWithParameters&lt;AudioProcessor&gt;, IProcessor { private <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> NoteEnvelope { private enum EState { <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, Attack, Decay, Sustain, <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span> } private readonly ADSR _ownerEnvelope; private <span class="hljs-type"><span class="hljs-type">double</span></span> _time; private <span class="hljs-type"><span class="hljs-type">double</span></span> _multiplier; private <span class="hljs-type"><span class="hljs-type">double</span></span> _startMultiplier; private EState _state; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> NoteEnvelope(ADSR <span class="hljs-keyword"><span class="hljs-keyword">owner</span></span>) { _ownerEnvelope = <span class="hljs-keyword"><span class="hljs-keyword">owner</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> GetNextMultiplier() { var startMultiplier = GetCurrentStateStartValue(); var finishMultiplier = GetCurrentStateFinishValue(); //  ,     var stateTime = <span class="hljs-number"><span class="hljs-number">1</span></span> - _time / GetCurrentStateMultiplier(); //    startMultiplier  finishMultiplier   CalculateLevel _multiplier = CalculateLevel(startMultiplier, finishMultiplier, stateTime); switch (_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Attack: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) SetState(EState.Decay); break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Decay: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) SetState(EState.Sustain); break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Sustain: //      break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) SetState(EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>); break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } //     var timeDelta = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / _ownerEnvelope.Processor.SampleRate; _time -= timeDelta; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _multiplier; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Press() { SetState(EState.Attack); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>() { SetState(EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>); } private <span class="hljs-type"><span class="hljs-type">double</span></span> CalculateLevel(<span class="hljs-type"><span class="hljs-type">double</span></span> a, <span class="hljs-type"><span class="hljs-type">double</span></span> b, <span class="hljs-type"><span class="hljs-type">double</span></span> t) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DSPFunctions.Lerp(a, b, t); } private <span class="hljs-type"><span class="hljs-type">void</span></span> SetState(EState newState) { //     -        _startMultiplier = (_time &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? _multiplier : GetCurrentStateFinishValue(); _state = newState; //     _time = GetCurrentStateMultiplier(); } private <span class="hljs-type"><span class="hljs-type">double</span></span> GetCurrentStateStartValue() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _startMultiplier; } private <span class="hljs-type"><span class="hljs-type">double</span></span> GetCurrentStateFinishValue() { switch (_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Attack: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Decay: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Sustain: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Sustain.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } } private <span class="hljs-type"><span class="hljs-type">double</span></span> GetCurrentStateMultiplier() { switch (_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Attack: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Attack.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Decay: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Decay.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Sustain: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.Sustain.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ownerEnvelope.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } } } private readonly NoteEnvelope _noteEnvelope; private <span class="hljs-type"><span class="hljs-type">int</span></span> _lastPressedNotesCount; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Attack { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Decay { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter Sustain { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> RealParameter <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ADSR(AudioProcessor audioProcessor) : base(audioProcessor) { _noteEnvelope = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> NoteEnvelope(this); Processor.<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.OnPressedNotesChanged += OnPressedNotesChanged; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override IEnumerable&lt;Parameter&gt; CreateParameters(string parameterPrefix) { Attack = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Atk", "Envelope Attack", "", <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); Decay = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Dec", "Envelope Decay", "", <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); Sustain = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Stn", "Envelope Sustain", "", <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RealParameter(parameterPrefix + "Rel", "Envelope Release", "", <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;Parameter&gt; {Attack, Decay, Sustain, <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>}; } private <span class="hljs-type"><span class="hljs-type">void</span></span> OnPressedNotesChanged(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, EventArgs e) { //    - ,     -   //     ,     -    , //   var currentPressedNotesCount = Processor.<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.PressedNotesCount; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPressedNotesCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _lastPressedNotesCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _noteEnvelope.Press(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPressedNotesCount == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _lastPressedNotesCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { _noteEnvelope.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>(); } _lastPressedNotesCount = currentPressedNotesCount; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Process(IAudioStream stream) { var lc = stream.Channels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; var rc = stream.Channels[<span class="hljs-number"><span class="hljs-number">1</span></span>]; var count = Processor.CurrentStreamLenght; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; ++i) { var multiplier = _noteEnvelope.GetNextMultiplier(); lc.Samples[i] *= multiplier; rc.Samples[i] *= multiplier; } } }</code> </pre> </div></div><br><p>  If we generate a simple sine using the written envelope, we get the next wave (the audio file was generated in FL Studio and then studied in the open source <a href="http://www.audacityteam.org/">Audacity</a> editor) </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/046/521/854/0465218547cb499f9236bd581b380c55.png"></div><br><p>  <em>In the Attack, Decay and Release phases, the envelope changes according to a linear law (Screenshot from Audacity)</em> </p><br><p>  It can be seen that in the Attack, Decay and Release phases the envelope changes according to a linear law. </p><br><p>  In the real world, oscillations cannot last forever, because of the energy expended on resistance forces, oscillations subside.  The amplitude of <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2582%25D1%2583%25D1%2585%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B5%25D0%25B1%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">damped oscillations</a> varies according to an exponential law. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/826/4c4/d9b/8264c4d9bbc944c6b900539867050fc5.png"></div><br><p>  <em>Using the envelope in the Sylenth1 synthesizer (Screenshot from Audacity)</em> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4fe/c62/6eb/4fec626ebd1c46e3ad4291f54a2a05ed.png"></div><br><p>  <em>Using envelope in 3x Osc synthesizer from FL Studio (Screenshot from Audacity)</em> </p><br><p>  Following the example of the envelopes in other synthesizers in decay and release, we use the exponential function, and in attack, we use the inverse function, the logarithm. </p><br><p>  For each state, we know the relative time (from 0 to 1) and the extreme values ‚Äã‚Äãof the envelope a and b. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/984/2cc/6a4/9842cc6a4f574add9174f5ef7fdaeb51.png"></div><br><p>  Take the function E ^ x on the interval [0, 1].  It has values ‚Äã‚Äãin the interval [1, E].  It is necessary to translate this segment into [a, b].  The logarithm is found as the inverse function for the exponent: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/210/a64/cdc/210a64cdc2f14956b361b582ac36a02f.gif"></div><br><p>  F1 - Function for Decay and Release status.  Since it is concave in the other direction, you need to display it symmetrically to the Y axis (replacing the argument with 1-x). <br>  Function F2 is the inverse of F1, you need to express x through y. </p><br><p>  Let's make in the code: </p><br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">double</span></span> CalculateLevel(<span class="hljs-type"><span class="hljs-type">double</span></span> a, <span class="hljs-type"><span class="hljs-type">double</span></span> b, <span class="hljs-type"><span class="hljs-type">double</span></span> t) { //<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DSPFunctions.Lerp(a, b, t); switch (_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Sustain: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Attack: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Log(<span class="hljs-number"><span class="hljs-number">1</span></span> + t * (Math.E - <span class="hljs-number"><span class="hljs-number">1</span></span>)) * Math.Abs(b - a) + a; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.Decay: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EState.<span class="hljs-keyword"><span class="hljs-keyword">Release</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Math.Exp(<span class="hljs-number"><span class="hljs-number">1</span></span> - t) - <span class="hljs-number"><span class="hljs-number">1</span></span>) / (Math.E - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (a - b) + b; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/424/474/c83/424474c835234b8d9e73734e33ade93b.png"></div><br><p>  <em>Result of Works (Screenshot from Audacity)</em> </p><br><p>  In advanced synthesizers, you can choose the curvature of the curve between phases: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/21b/0c5/7d3/21b0c57d352141fabd7d82947a1ab8bc.png"></div><br><p>  <em>Envelope in the synthesizer Serum</em> </p><br><a name="Part7"></a><br><h2 id="primery-zvuchaniy-s-ispolzovaniem-adsr-ogibayuschey">  Examples of sounds using ADSR-envelope </h2><br><p>  Consider a couple of sound ideas that can be obtained from a simple signal using an ADSR envelope. </p><br><ol><li>  A and S on zero, D and R ~ 1/4 knobs.  The signal will die out sharply, if you generate noise, then the sound will be similar to a hi-hat. </li><li>  A - great value (~ 1/2 knobs), D and R - 0, S - 1: effect, as if the notes sound "in the inverse form". </li><li>  A, D, R - small, S at zero.  If you generate a noise, the sound will be like a shaker shaking. </li><li>  D is small, the rest is at zero.  If you generate a square or ramp signal, the sound will resemble the click of a metronome. </li><li>  A, D - small, S and R at zero.  If you generate a noise, then the sound will be remotely similar to pressing the keys of a typewriter. </li></ol><br><p>  Again, on the Internet there are tons of material, training videos and examples on the subject of the signal envelope.  With the help of the volume envelope, various sounds and effects are well emulated, again, you can find a bunch of ready-made presets in synthesizers (there will definitely be imitations of drums). </p><br><p>  In the next article I will talk about the <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2591%25D0%25B0%25D1%2582%25D1%2582%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D1%2580%25D1%2582%25D0%25B0">frequency filter Buttervota</a> . </p><br><p>  <em>All good!</em> <em><br></em>  <em>Good luck in programming!</em> </p><br><a name="Part8"></a><br><h2 id="spisok-literatury">  Bibliography </h2><br><p>  The main articles and books on digital sound are listed in the <a href="https://habrahabr.ru/post/311220/">previous article</a> . </p><br><ol><li>  <a href="https://en.wikibooks.org/wiki/Engineering_Acoustics/The_Human_Ear_and_Sound_Perception">The Human Ear And Sound Perception</a> </li><li>  <a href="http://www.teachmeaudio.com/recording/sound-reproduction/sound-envelopes/">Sound Envelopes</a> small article with audio examples </li><li>  <a href="http://en.wikiaudio.org/ADSR_envelope">en.wikiaudio.org/ADSR_envelope</a> links to good videos </li><li>  <a href="http://www.sfu.ca/sonic-studio/handbook/Envelope.html">Envelope tool charts</a> </li><li>  <a href="http://filmsound.org/articles/ninecomponents/9components.htm">Nine Components of Sound</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/311750/">https://habr.com/ru/post/311750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311740/index.html">Opus about startaparstvom and competitions in one part</a></li>
<li><a href="../311742/index.html">IPv6 in Microsoft Azure</a></li>
<li><a href="../311744/index.html">Working with Big Data with the help of GPU: accelerating the work of databases dozens of times</a></li>
<li><a href="../311746/index.html">GUI for php, or we cross written extension with a screenshot</a></li>
<li><a href="../311748/index.html">How about putting each function in your file?</a></li>
<li><a href="../311752/index.html">How to choose the best RKO when opening a business</a></li>
<li><a href="../311754/index.html">‚ÄúAdmin: password‚Äù problem: standard passwords helped create a botnet from almost 400,000 IoT devices</a></li>
<li><a href="../311756/index.html">We launch a simple blog on Wagtail CMS (Django) - part 2</a></li>
<li><a href="../311758/index.html">EBU R128 / BS.1770-3: Batch Normalization of Audio / Video File Volume</a></li>
<li><a href="../311760/index.html">Network monitoring with FlapMyPort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>