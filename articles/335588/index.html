<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Planetary landscape</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is difficult to argue that the landscape is an integral part of most computer games in open spaces. The traditional method of implementing the chan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Planetary landscape</h1><div class="post__text post__text-html js-mediator-article">  It is difficult to argue that the landscape is an integral part of most computer games in open spaces.  The traditional method of implementing the change in the surface surrounding the player‚Äôs surface is the following: we take the mesh (Mesh), which is the plane, and for each primitive in this grid, we displace along the normal to this plane by a specific value for this primitive.  In simple terms, we have a 256-by-256-pixel single-channel texture and a plane grid.  For each primitive, by its coordinates on the plane, we take the value from the texture.  Now we simply shift the coordinates of the primitive along the normal to the plane by the obtained value (Fig. 1) <br><br><img src="https://habrastorage.org/web/9cd/50e/881/9cd50e8814784554b6f3d1c94837c5cd.png"><br>  <i><font color="#999999">Fig.1 elevation map + plane = landscape</font></i> <br><br>  Why does this work?  If we imagine that the player is on the surface of the sphere, and the radius of this sphere is extremely large relative to the size of the player, then the curvature of the surface can be neglected and the plane can be used.  But what if we do not neglect the fact that we are on a sphere?  I want to share my experience in building such landscapes with the reader in this article. <br><a name="habracut"></a><br><h3>  1. Sector </h3><br>  Obviously, it is not reasonable to build a landscape at once for the whole sphere - most of it will not be visible.  Therefore, we need to create a certain minimum area of ‚Äã‚Äãspace - a certain primitive, of which the relief of the visible part of the sphere will consist.  I will call it a sector.  How do we get it?  So look at fig.2a.  The green box is our sector.  Next, we construct six grids, each of which is a cube face (Fig. 2b).  Now let's normalize the coordinates of the primitives that form the grids (Fig. 2c). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/3f9/851/b6d/3f9851b6d469409a9ae100e5dee1f0b9.png"><br>  <i><font color="#999999">Pic2</font></i> <br><br>  As a result, we got a cube projected onto a sphere, where the sector is the area on one of its faces.  Why does this work?  Consider an arbitrary point on the grid as a vector from the origin.  What is vector normalization?  This is a transformation of a given vector into a vector in the same direction, but with a unit length.  The process is as follows: first we find the length of the vector in the Euclidean metric according to the Pythagorean theorem <br><br><img src="https://habrastorage.org/web/d9d/9f1/e37/d9d9f1e37ad549c7b8286fb6d13d5e86.PNG"><br><br>  Then we divide each of the vector components into this value. <br><br><img src="https://habrastorage.org/web/5e1/0f7/26d/5e10f726d74846a183739dc476fb0742.PNG"><br><br>  Now we ask ourselves what is a sphere?  A sphere is a set of points equidistant from a given point.  The parametric sphere equation looks like this. <br><br><img src="https://habrastorage.org/web/2ff/148/a29/2ff148a29b3c4aacb6e65e85817a5085.png"><br><br>  where x0, y0, z0 are the coordinates of the center of the sphere, and R is its radius.  In our case, the center of the sphere is the origin, and the radius is one.  Substitute the known values ‚Äã‚Äãand take the root of the two parts of the equation.  It turns out the following <br><br><img src="https://habrastorage.org/web/c32/a07/694/c32a07694fc44b589278660f9d753909.png"><br><br>  Literally, the last transformation tells us the following: ‚ÄúIn order to belong to a sphere, the vector length must be equal to one‚Äù.  This we have achieved normalization. <br><br>  What if the sphere has an arbitrary center and radius?  Find the point that belongs to her by using the following equation <br><br><img src="https://habrastorage.org/web/eb2/f93/b92/eb2f93b928b54e1fbbb5be6d9b89fd4c.png"><br><br>  where pS is a point on the sphere, C is the center of the sphere, pNorm is the previously normalized vector and R is the radius of the sphere.  In simple words, the following happens here: ‚Äúwe move from the center of the sphere towards the point on the grid at a distance R‚Äù.  Since each vector has a unit length, in the end, all points are equidistant from the center of the sphere at a distance of its radius, which makes the equation of the sphere true. <br><br><h3>  2. Management </h3><br>  We need to get a group of sectors that are potentially visible from the viewpoint.  But how to do that?  Suppose we have a sphere with center at some point.  We also have a sector that is located on a sphere and a point P located in the space near the sphere.  Now we construct two vectors - one directed from the center of the sphere to the center of the sector, the other from the center of the sphere to the point of view.  Look at Figure 3 - a sector can only be seen if the absolute value of the angle between these vectors is less than 90 degrees. <br><br><img src="https://habrastorage.org/web/2b5/f60/cb6/2b5f60cb6ebc4eec81dccdbe4ec1d7e4.png"><br>  <i><font color="#999999">Fig.3 a - angle less than 90 - the sector is potentially visible.</font></i>  <i><font color="#999999">b - angle greater than 90 - sector is not visible</font></i> <br><br>  How to get this angle?  To do this, use the scalar product of vectors.  For the three-dimensional case, it is calculated as: <br><br><img src="https://habrastorage.org/web/f7a/761/2a6/f7a7612a62c04165b9b836b281114bb3.png"><br><br>  Scalar product has a distribution property: <br><br><img src="https://habrastorage.org/web/278/7bd/b4e/2787bdb4ef7e496b801eef3fd0eb2535.png"><br><br>  Earlier, we defined the vector length equation - now we can say that the length of the vector is equal to the root of the scalar product of this vector itself.  Or vice versa - the scalar product of the vector itself is equal to the square of its length. <br><br>  Now let's turn to the law of cosines.  One of his two formulations looks like this (Fig. 4): <br><br><img src="https://habrastorage.org/web/a71/7d1/d58/a717d1d589c14079bcd90a8bee4dcd28.png"><br><br><img src="https://habrastorage.org/web/727/7d3/91d/7277d391d19c4819a55cf7baeab87715.png"><br>  <i><font color="#999999">Fig.4 cosine law</font></i> <br><br>  If we take the lengths of our vectors as a and b, then the angle alfa is what we are looking for.  But how do we get value with?  See: if we take a from b, then we get a vector directed from a to b, and since the vector is characterized only by direction and length, then we can graphically arrange its beginning at the end of vector a.  From this, we can say that c is equal to the length of the vector b - a.  So we did <br><br><img src="https://habrastorage.org/web/a85/30d/464/a8530d464fcf4eda833d5c8a3d859644.png"><br><br>  Express the squares of lengths as scalar products <br><br><img src="https://habrastorage.org/web/5eb/b76/078/5ebb7607819c4c3193d91f6aad50f8cd.png"><br><br>  open brackets using the distribution property <br><br><img src="https://habrastorage.org/web/5ee/655/60f/5ee65560f6874d0abf568139b143c9b0.png"><br><br>  a little shorten <br><br><img src="https://habrastorage.org/web/ce0/6b4/657/ce06b4657ad54caab069c09c6d35eb43.png"><br><br>  and finally, by dividing both equations of the equation by minus two, we get <br><br><img src="https://habrastorage.org/web/a2a/5b6/846/a2a5b68462064029956b358a847cd702.png"><br><br>  This is another property of the scalar product.  In our case, we need to normalize the vectors so that their lengths are equal to one.  We don‚Äôt need to calculate the angle - the cosine value is enough.  If it is less than zero, then we can safely say that we are not interested in this sector. <br><br><h3>  3. Grid </h3><br>  It's time to think about how to draw primitives.  As I said earlier, the sector is the main component in our scheme, so for each potentially visible sector we will draw a grid, the primitives of which will form the landscape.  Each of its cells can be displayed using two triangles.  Due to the fact that each cell has adjacent faces, the values ‚Äã‚Äãof most triangle vertices are repeated for two or more cells.  Not to duplicate the data in the vertex buffer, fill the index buffer.  If indices are used, then with their help the graphic pipeline determines which primitive in the vertex buffer to process.  (pic.5) The topology I chose is a triangle list (D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST) <br><br><img src="https://habrastorage.org/web/d1a/a91/90a/d1aa9190a2b641d285201e4feabd275b.png"><br>  <i><font color="#999999">Fig.5 Visual display of indexes and primitives</font></i> <br><br>  Creating a separate vertex buffer for each sector is too expensive.  It is much more efficient to use one buffer with coordinates in the grid space, that is, x is a column and y is a row.  But how to get a point on the sphere from them?  A sector is a square area with a beginning at a certain point S. All sectors have the same length of the face - let's call it SLen.  The grid covers the entire area of ‚Äã‚Äãthe sector and also has the same number of rows and columns, so we can build the following equation to find the length of the cell face. <br><br><img src="https://habrastorage.org/web/c36/aa2/bf4/c36aa2bf4c1e4dc183d79b6e02837a44.png"><br><br>  where CLen is the length of the cell face, MSize is the number of rows or columns of the grid.  We divide both parts by MSize and get CLen <br><br><img src="https://habrastorage.org/web/8a4/379/700/8a4379700f6b49419757d37a79c8dd66.png"><br><br>  We go further.  The space of the face of the cube to which the sector belongs can be expressed as a linear combination of two vectors of unit length ‚Äî we call them V1 and V2.  We have the following equation (see fig. 6) <br><br><img src="https://habrastorage.org/web/a02/0d7/cd5/a020d7cd54e647c1929c42fd60a3b974.png"><br><br><img src="https://habrastorage.org/web/381/621/729/3816217292f142928a9bc7fc00904278.png"><br>  <i><font color="#999999">Fig.6 A visual representation of the formation of a point on the grid</font></i> <br><br>  to get a point on a sphere, we use the equation derived earlier <br><br><img src="https://habrastorage.org/web/7e9/2ca/4a7/7e92ca4a79f343048344177c5e547344.png"><br><br><h3>  4. Height </h3><br>  All that we have achieved by this moment is not very similar to the landscape.  It's time to add what will make it so - the difference in height.  Let's imagine that we have a sphere of unit radius with center at the origin of coordinates, as well as a set of points {P0, P1, P2 ... PN}, which are located on this sphere.  Each of these points can be represented as a unit vector from the origin.  Now imagine that we have a set of values, each of which is the length of a particular vector (Fig. 7). <br><br><img src="https://habrastorage.org/web/1b5/338/149/1b5338149dd84eb7aae5695675f17c83.png"><br><br>  I will store these values ‚Äã‚Äãin a two-dimensional texture.  We need to find the relationship between the coordinates of the pixel texture and the vector-point on the sphere.  Let's get started <br><br>  In addition to Cartesian, a point on a sphere can also be described using a spherical coordinate system.  In this case, its coordinates will consist of three elements: the azimuth angle, the polar angle, and the value of the shortest distance from the origin to the point.  The azimuth angle is the angle between the X axis and the projection of the ray from the origin to a point on the XZ plane.  It can take values ‚Äã‚Äãfrom zero to 360 degrees.  Polar angle - the angle between the Y axis and the ray from the origin to the point.  It can also be called zenith or normal.  Accepts values ‚Äã‚Äãfrom zero to 180 degrees.  (see figure 8) <br><br><img src="https://habrastorage.org/web/988/e05/ad0/988e05ad08bd4d879cb20772a88d1837.png"><br>  <i><font color="#999999">Fig.8 Spherical coordinates</font></i> <br><br>  To go from a Cartesian system to a spherical, I use the following equations (I believe that the Y axis is pointing up): <br><br><img src="https://habrastorage.org/web/1f0/574/f74/1f0574f744b44c7aa212675117b68470.png"><br><br>  where d is the distance to the point, a is the polar angle, b is the azimuth angle.  The parameter d can also be described as ‚Äúthe length of the vector from the origin to the point‚Äù (as can be seen from the equation).  If we use normalized coordinates, we can avoid division when finding the polar angle.  Actually, why do we need these corners?  Dividing each of them into its maximum range, we obtain coefficients from zero to one and with their help we will select the texture from the shader.  When obtaining the coefficient for the polar angle, it is necessary to take into account the quarter in which the angle is located.  "But the value of the expression z / x is not defined when x is equal to zero" - you say.  I will say more: when z equals zero, the angle will be zero regardless of the value of x. <br><br>  Let's add some special cases for these values.  We have normalized coordinates (normal) - we add several conditions: if the X value of the normal is zero and the Z value is greater than zero, then the coefficient is 0.25, if X is zero and Z is less than zero, then it will be 0.75.  If the value of Z is zero and X is less than zero, then in this case the coefficient will be equal to 0.5.  All this is easy to check on the circumference.  But what to do if Z is zero and X is greater than zero - in this case, both 0 and 1 will be correct?  Imagine that we chose 1 ‚Äî well, let's take a sector with a minimum azimuth angle of 0 and a maximum angle of 90 degrees.  Now consider the first three vertices in the first row of the grid that displays this sector.  For the first vertex, we met the condition and set the textural coordinate of X to 1. It is obvious that for the next two vertices this condition will not be fulfilled - the angles for them are in the first quarter and as a result we get something like this - (1.0, 0.05, 0.1).  But for a sector with angles from 270 to 360 for the last three vertices in the same line, everything will be correct - the condition for the last vertex will work, and we will get a set (0.9, 0.95, 1.0).  If we choose zero as the result, we get sets (0.0, 0.05, 0.1) and (0.9, 0.95, 0.0) - in any case, this will lead to quite noticeable distortions of the surface.  So let's apply the following.  Take the center of the sector, then normalize its center, thereby moving it onto the sphere.  Now we calculate the scalar product of the normalized center by the vector (0, 0, 1).  Formally speaking, this vector is normal to the XY plane, and by calculating its scalar product with the normalized vector of the center of the sector, we can understand which side of the plane the center is from.  If it is less than zero, then the sector is behind the plane and we need the value 1. If the scalar product is greater than zero, then the sector is in front of the plane and therefore the boundary value is 0. (see Fig.9) <br><br><img src="https://habrastorage.org/web/f43/d2c/d47/f43d2cd47f0847258feb14022bff1ea9.png"><br>  <i><font color="#999999">Fig.9 The problem of choosing between 0 and 1 for texture coordinates</font></i> <br><br>  Here is the code for obtaining texture coordinates from spherical.  Please note that because of the error in the calculations, we cannot check the values ‚Äã‚Äãof the normal for equality to zero, instead we must compare their absolute values ‚Äã‚Äãwith a certain threshold value (for example, 0.001) <br><br><pre><code class="hljs pgsql">//norm -   ,       //<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -    ,   norm //zeroTreshold -   (<span class="hljs-number"><span class="hljs-number">0.001</span></span>) float2 GetTexCoords(float3 norm, float3 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) { <span class="hljs-type"><span class="hljs-type">float</span></span> tX = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, tY = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; <span class="hljs-type"><span class="hljs-type">bool</span></span> normXIsZero = abs(norm.x) &lt; zeroTreshold; <span class="hljs-type"><span class="hljs-type">bool</span></span> normZIsZero = abs(norm.z) &lt; zeroTreshold; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(normXIsZero || normZIsZero){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(normXIsZero &amp;&amp; norm.z &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) tX = <span class="hljs-number"><span class="hljs-number">0.25</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(norm.x &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f &amp;&amp; normZIsZero) tX = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(normXIsZero &amp;&amp; norm.z &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) tX = <span class="hljs-number"><span class="hljs-number">0.75</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(norm.x &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f &amp;&amp; normZIsZero){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dot(float3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f), <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) tX = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tX = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ tX = atan(norm.z / norm.x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(norm.x &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f &amp;&amp; norm.z &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) tX += <span class="hljs-number"><span class="hljs-number">3.141592</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(norm.x &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f &amp;&amp; norm.z &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) tX += <span class="hljs-number"><span class="hljs-number">3.141592</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(norm.x &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f &amp;&amp; norm.z &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>f) tX = <span class="hljs-number"><span class="hljs-number">3.141592</span></span> * <span class="hljs-number"><span class="hljs-number">2.0</span></span>f + tX; tX = tX / (<span class="hljs-number"><span class="hljs-number">3.141592</span></span> * <span class="hljs-number"><span class="hljs-number">2.0</span></span>f); } tY = acos(norm.y) / <span class="hljs-number"><span class="hljs-number">3.141592</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float2(tX, tY); }</code> </pre> <br>  I will give an intermediate version of the vertex shader <br><br><pre> <code class="hljs lua">//startPos -    //vec1, vec2 -     //gridStep -   //sideSize -    //GetTexCoords() -      VOut ProcessVertex(VIn <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>) { float3 planePos = startPos + vec1 * <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.netPos.x * gridStep.x + vec2 * <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.netPos.y * gridStep.y; float3 sphPos = normalize(planePos); float3 normOffset = normalize(startPos + (vec1 + vec2) * sideSize * <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); float2 tc = GetTexCoords(sphPos, normOffset); float height = mainHeightTex.SampleLevel(mainHeightTexSampler, tc, <span class="hljs-number"><span class="hljs-number">0</span></span>).x; posL = sphPos * (sphereRadius + height); VOut <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.posH = mul(float4(posL, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f), worldViewProj); <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.texCoords = tc; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; }</code> </pre><br><h3>  5. Lighting </h3><br>  In order to realize the dependence of the landscape color on lighting, we will use the following equation: <br><br><img src="https://habrastorage.org/web/a12/c1a/d54/a12c1ad54a2d447e8fc1bba33135b0a9.png"><br><br>  Where I is the color of the point, Ld is the color of the light source, Kd is the color of the material of the illuminated surface, a is the angle between the vector of the source and the normal to the illuminated surface.  This is a special case of the Lambert cosine law.  Let's see what is here and why.  By multiplying Ld by Kd is meant componentwise color multiplication, that is (Ld.r * Kd.r, Ld.g * Kd.g, Ld.b * Kd.b).  It may be easier to understand the meaning if we imagine the following situation: suppose we want to illuminate an object with a green light source, so we expect the color of the object to be in gradations of green.  The result (0 * Kd.r, 1 * Kd.g, 0 * Kd.b) gives (0, Kd.g, 0) - exactly what we need.  We go further.  As stated earlier, the cosine of the angle between normalized vectors is their scalar product.  Let's look at its maximum and minimum value from our point of view.  If the cosine of the angle between the vectors is 1, then this angle is 0 - therefore, both vectors are collinear (lie on the same line). <br><br>  The same is true for the cosine value of -1, only in this case the vectors point in opposite directions.  It turns out, the closer the normal vector and the vector to the light source to the state of collinearity - the higher the luminance factor of the surface to which the normal belongs.  It is also assumed that the surface cannot be illuminated if its normal points in the direction opposite to the direction to the source ‚Äî that is why I use only positive cosine values. <br><br>  I use a parallel source, so its position can be neglected.  The only thing that needs to be taken into account is that we use a vector to the light source.  That is, if the direction of the rays is (1.0, -1.0, 0) - we need to use the vector (-1.0, 1.0, 0).  The only thing that is difficult for us is the normal vector.  It is easy to calculate the normal to the plane - we need to produce the vector product of two vectors that describe it.  It is important to remember that the vector product is anticommutative - you need to take into account the order of the factors.  In our case, we can obtain the normal to the triangle, knowing the coordinates of its vertices in the space of the grid, as follows (Note that I do not take into account the boundary cases for px and py) <br><br><pre> <code class="cpp hljs">float3 p1 = GetPosOnSphere(p); float3 p2 = GetPosOnSphere(float2(px + <span class="hljs-number"><span class="hljs-number">1</span></span>, py)); float3 p3 = GetPosOnSphere(float2(px, py + <span class="hljs-number"><span class="hljs-number">1</span></span>)); float3 v1 = p2 - p1; float3 v2 = p3 - p1; float3 n = normalzie(cross(v1, v2));</code> </pre><br>  But that is not all.  Most vertices of the grid belong immediately to four planes.  To get an acceptable result, you need to calculate the average normal as follows: <br><br><pre> <code class="cpp hljs">Na = normalize(n0 + n1 + n2 + n3)</code> </pre><br>  Implementing this method on a GPU is quite expensive - we need two steps to calculate the normals and average them.  In addition, the efficiency leaves much to be desired.  Based on this, I chose another way - to use the normal map. (Fig.10) <br><br><img src="https://habrastorage.org/web/5b3/474/d26/5b3474d26e9e43a4828d1c933fd5675e.png"><br>  <i><font color="#999999">Pic.10 Normal map</font></i> <br><br>  The principle of working with it is the same as with the height map - we transform the spherical coordinates of the grid vertex into textural coordinates and make a selection.  Only we will not be able to use this data directly - after all, we work with the sphere, and the vertex has its own normal, which must be taken into account.  Therefore, we will use the data of the normal map as the coordinates of the TBN basis.  What is a basis?  Here is an example.  Imagine that you are an astronaut and are sitting on a beacon somewhere in space.  You receive a message from the MCC: ‚ÄúYou need to move from the beacon 1 meter to the left, 2 meters up and 3 meters ahead.‚Äù  How can this be mathematically expressed?  (1, 0, 0) * 1 + (0, 1, 0) * 2 + (0, 0, 1) * 3 = (1,2,3).  In matrix form, this equation can be expressed as: <br><br><img src="https://habrastorage.org/web/ef5/609/e20/ef5609e20b2846e1ab9b0b09191046f3.png"><br><br>  Now imagine that you are also sitting on the beacon, only now they write to you from the MCC: ‚Äúwe sent you direction vectors there - you have to move 1 meter along the first vector, 2 meters along the second and 3 along the third‚Äù.  The equation for the new coordinates will be: <br><br><img src="https://habrastorage.org/web/52a/456/00c/52a45600cb7e4980b18376a260677971.png"><br><br>  component entry is as follows: <br><br><img src="https://habrastorage.org/web/962/d23/419/962d234195f34a978187a65391b137c9.png"><br><br>  Or in matrix form: <br><br><img src="https://habrastorage.org/web/56b/47c/cb8/56b47ccb88484cf8b36f5f512347e0ed.png"><br><br>  so, the matrix with the vectors V1, V2 and V3 is the basis, and the vector (1,2,3) is the coordinates in the space of this basis. <br><br>  Imagine now that you have a set of vectors (basis M) and you know where you are relative to the beacon (point P).  You need to know your coordinates in the space of this base - how much you need to move along these vectors to be in the same place.  Imagine the required coordinates (X) <br><br><img src="https://habrastorage.org/web/22c/901/087/22c901087bb946518d596ae45cf98f93.png"><br><br>  If P, M and X were numbers, we would simply divide both sides of the equation into M, but alas ... Let's go the other way - according to the property of the inverse matrix <br><br><img src="https://habrastorage.org/web/5b5/2df/571/5b52df57194d44519cc4796b9d1f1439.png"><br><br>  where I is the identity matrix.  In our case, it looks like this. <br><br><img src="https://habrastorage.org/web/b96/d34/701/b96d347017bb44a58c7b9fdc775b3154.png"><br><br>  What does this give us?  Try multiplying this matrix by X and you will get <br><br><img src="https://habrastorage.org/web/3a3/f6a/a5f/3a3f6aa5feec4ed489d9bddecc3a98e1.png"><br><br>  It is also necessary to clarify that the multiplication of matrices has the property of associativity <br><br><img src="https://habrastorage.org/web/ef7/d30/32c/ef7d3032c3ea403d9fa6f703741ea201.png"><br><br>  We can legitimately consider the vector as a 3 on 1 matrix. <br><br>  Considering the above, we can conclude that in order to get X in the right side of the equation, we need to multiply both sides in the correct order by the inverse M matrix <br><br><img src="https://habrastorage.org/web/02c/ab3/826/02cab38267b543d9ad5e3948dc958ae0.png"><br><br>  We will need this result in the future. <br><br>  Now back to our problem.  I will use an orthonormal basis, which means that V1, V2 and V3 are orthogonal with respect to each other (form an angle of 90 degrees) and have a unit length.  The tangent vector will act as V1, V2 - bitangent vector, V3 - normal.  In the traditional DirectX transposed form, the matrix looks like this: <br><br><img src="https://habrastorage.org/web/768/51c/f43/76851cf43fae49af87cfd4a4cc3f4fff.png"><br><br>  where T is the tangent vector, B is the bitangent vector and N is the normal.  Let's find them.  With the normal, the easiest thing to do is essentially the normalized coordinates of a point.  Bitangent vector is equal to the vector product of the normal and tangent vector.  The hardest thing to do is with the tangent vector.  It is equal to the direction of the tangent to the circle at the point.  Let's break this down.  First we find the coordinates of a point on the unit circle in the XZ plane for some angle a <br><br><img src="https://habrastorage.org/web/9d4/f6a/fed/9d4f6afed1fc4ac2ad4340c55d13cc0b.png"><br><br>  The direction of the tangent to the circle at this point can be found in two ways.  The vector to the point on the circle and the tangent vector are orthogonal ‚Äî therefore, since the sin and cos functions are periodic, we can simply add pi / 2 to the angle a and obtain the desired direction.  According to the bias property on pi / 2: <br><br><img src="https://habrastorage.org/web/c71/ac0/1aa/c71ac01aa6ee4d74b35a5189a95bf407.png"><br><br>  we have the following vector: <br><br><img src="https://habrastorage.org/web/131/ca3/564/131ca3564d8e47fbb96cd12a3e7ab20d.png"><br><br>  We can also use differentiation - see Appendix 3 for more details. Thus, in Figure 11 you can see a sphere, for each vertex of which a basis is built.  Blue vectors are normals, red tangent vectors, green bitangent vectors. <br><br><img src="https://habrastorage.org/web/e3c/d8c/247/e3cd8c2478bb4a9aa92f5ab538e70259.png"><br>  <i><font color="#999999">Fig.11 Sphere with TBN bases at each vertex.</font></i>  <i><font color="#999999">Red - tangent vectors, green - bitangent vectors, blue vectors - normals</font></i> <br><br>  With the base figured out - now let's get the normal map.  To do this, use the Sobel filter.  The Sobel filter computes the gradient of the brightness of the image at each point (roughly speaking, the vector of brightness change).  The principle of the filter is that you need to apply a certain matrix of values, which is called the "Core", to each pixel and its neighbors within the dimension of this matrix.  Suppose that we process pixel P with the K kernel. If it is not on the border of the image, then it has eight neighbors ‚Äî the left top, top, right top, and so on.  We call them tl, t, tb, l, r, bl, b, br.  So, the application of the K kernel to this pixel is as follows: <br><br>  Pn = tl * K (0, 0) + t * K (0,1) + tb * K (0,2) + <br>  &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbspl * K (1, 0) + P * K (1,1) + r * K (1,2) + <br>  &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbsp &amp; nbspbl * K (2, 0) + b * K (2.1) + br * K (2.2) <br><br>  This process is called "convolution."  The Sobel filter uses two cores to compute the gradient vertically and horizontally.  Denote them as Kx and K: <br><br><img src="https://habrastorage.org/web/71e/abd/6e9/71eabd6e9495428abbdb17dcd6980b5b.png"><br><br>  The basis is - you can begin to implement.  First we need to calculate the pixel brightness.  I use the conversion from the RGB color model to the YUV model for the PAL system: <br><br><img src="https://habrastorage.org/web/b01/a14/013/b01a14013def4950b67882fb74670a44.png"><br><br>  But since our image is originally in grayscale, this stage can be skipped.  Now we need to ‚Äúcollapse‚Äù the original image with the Kx and Ky cores.  So we get the X and Y components of the gradient.  The value of the normal of this vector may also be very useful - we will not use it, but images containing normalized values ‚Äã‚Äãof the normal of the gradient have several useful applications.  By normalization, I mean the following equation <br><br><img src="https://habrastorage.org/web/f4a/f0b/97e/f4af0b97e9ef4f23a82f327baa48e198.png"><br><br>  where V is the value that we normalize, Vmin and Vmax are the range of these values.  In our case, the minimum and maximum values ‚Äã‚Äãare tracked during the generation process.  Here is an example of the implementation of the Sobel filter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SobelFilter::GetGrayscaleData(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point2 &amp;Coords) { Point2 coords; coords.x = Math::Saturate(Coords.x, RangeI(<span class="hljs-number"><span class="hljs-number">0</span></span>, image.size.width - <span class="hljs-number"><span class="hljs-number">1</span></span>)); coords.y = Math::Saturate(Coords.y, RangeI(<span class="hljs-number"><span class="hljs-number">0</span></span>, image.size.height - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> offset = (coords.y * image.size.width + coords.x) * image.pixelSize; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pixel = &amp;image.pixels[offset]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (image.pixelFormat == PXL_FMT_R8) ? pixel[<span class="hljs-number"><span class="hljs-number">0</span></span>] : (<span class="hljs-number"><span class="hljs-number">0.30f</span></span> * pixel[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-comment"><span class="hljs-comment">//R 0.59f * pixel[1] + //G 0.11f * pixel[2]); //B } void SobelFilter::Process() { RangeF dirXVr, dirYVr, magNormVr; for(int32_t y = 0; y &lt; image.size.height; y++) for(int32_t x = 0; x &lt; image.size.width; x++){ float tl = GetGrayscaleData({x - 1, y - 1}); float t = GetGrayscaleData({x , y - 1}); float tr = GetGrayscaleData({x + 1, y - 1}); float l = GetGrayscaleData({x - 1, y }); float r = GetGrayscaleData({x + 1, y }); float bl = GetGrayscaleData({x - 1, y + 1}); float b = GetGrayscaleData({x , y + 1}); float br = GetGrayscaleData({x + 1, y + 1}); float dirX = -1.0f * tl + 0.0f + 1.0f * tr + -2.0f * l + 0.0f + 2.0f * r + -1.0f * bl + 0.0f + 1.0f * br; float dirY = -1.0f * tl + -2.0f * t + -1.0f * tr + 0.0f + 0.0f + 0.0f + 1.0f * bl + 2.0f * b + 1.0f * br; float magNorm = sqrtf(dirX * dirX + dirY * dirY); int32_t ind = y * image.size.width + x; dirXData[ind] = dirX; dirYData[ind] = dirY; magNData[ind] = magNorm; dirXVr.Update(dirX); dirYVr.Update(dirY); magNormVr.Update(magNorm); } if(normaliseDirections){ for(float &amp;dirX : dirXData) dirX = (dirX - dirXVr.minVal) / (dirXVr.maxVal - dirXVr.minVal); for(float &amp;dirY : dirYData) dirY = (dirY - dirYVr.minVal) / (dirYVr.maxVal - dirYVr.minVal); } for(float &amp;magNorm : magNData) magNorm = (magNorm - magNormVr.minVal) / (magNormVr.maxVal - magNormVr.minVal); }</span></span></code> </pre><br>  I must say that the Sobel filter has the property of linear separability, so this method can be optimized. <br><br>  The difficult part is over - it remains to record the X and Y coordinates of the gradient direction in the R and G channels of the pixels of the normal map. For the Z coordinates, I use a unit.  I also use a three-dimensional vector of coefficients to adjust these values.  The following is an example of generating a normal map with comments: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//ImageProcessing::ImageData Image -  .        ImageProcessing::SobelFilter sobelFilter; sobelFilter.Init(Image); sobelFilter.NormaliseDirections() = false; sobelFilter.Process(); const auto &amp;resX =sobelFilter.GetFilteredData(ImageProcessing::SobelFilter::SOBEL_DIR_X); const auto &amp;resY =sobelFilter.GetFilteredData(ImageProcessing::SobelFilter::SOBEL_DIR_Y); ImageProcessing::ImageData destImage = {DXGI_FORMAT_R8G8B8A8_UNORM, Image.size}; size_t dstImageSize = Image.size.width * Image.size.height * destImage.pixelSize; std::vector&lt;uint8_t&gt; dstImgPixels(dstImageSize); for(int32_t d = 0 ; d &lt; resX.size(); d++){ //   .     (0.03, 0.03, 1.0) Vector3 norm = Vector3::Normalize({resX[d] * NormalScalling.x, resY[d] * NormalScalling.y, 1.0f * NormalScalling.z}); Point2 coords(d % Image.size.width, d / Image.size.width); int32_t offset = (coords.y * Image.size.width + coords.x) * destImage.pixelSize; uint8_t *pixel = &amp;dstImgPixels[offset]; //    [-1.0, 1.0]  [0.0, 1.0]     [0, 256] pixel[0] = (0.5f + norm.x * 0.5f) * 255.999f; pixel[1] = (0.5f + norm.y * 0.5f) * 255.999f; pixel[2] = (0.5f + norm.z * 0.5f) * 255.999f; } destImage.pixels = &amp;dstImgPixels[0]; SaveImage(destImage, OutFilePath);</span></span></code> </pre><br>  Now I will give an example of using the normal map in the shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//texCoords -      ,   .4 //normalL -   //lightDir -     //Ld -    //Kd -     float4 normColor = mainNormalTex.SampleLevel(mainNormalTexSampler, texCoords, 0); //    [0.0, 1.0]  [-1.0, 1.0]    float3 normalT = normalize(2.0f * mainNormColor.rgb - 1.0f); //      [0.0, 1.0]  [0.0, Pi*2.0] float ang = texCoords.x * 3.141592f * 2.0f; float3 tangent; tangent.x = -sin(ang); tangent.y = 0.0f; tangent.z = cos(ang); float3 bitangent = normalize(cross(normalL, tangent)); float3x3 tbn = float3x3(tangent, bitangent, normalL); float3 resNormal = mul(normalT, tbn); float diff = saturate(dot(resNormal, lightDir.xyz)); float4 resColor = Ld * Kd * diff;</span></span></code> </pre><br><h3>  6. Level Of Detail </h3><br>  Well, now our landscape is lit!  You can fly to the moon - we zaguraem height map, set the color of the material, load the sectors, set the grid size to {16, 16} and ... Yes, something is not enough - put it on {256, 256} - oh, something slows down , and why high detail on distant sectors?  Moreover, the closer the observer to the planet, the smaller sectors he can see.  Yes ... we still have a lot of work to do!  Let's first figure out how to cut off the extra sectors.  The determining value here will be the height of the observer from the surface of the planet - the higher it is, the more sectors it can see (Figure 12) <br><br><img src="https://habrastorage.org/web/3cd/ad4/0cb/3cdad40cb9be43d5b227df7fa7de6488.png"><br>  <i><font color="#999999">Fig.12. Dependence of the height of the observer on the number of sectors being processed.</font></i> <br><br>  We find the height as follows: we construct the vector from the observer‚Äôs position to the center of the sphere, calculate its length and subtract the value of the radius of the sphere from it.  Earlier, I said that if the scalar product of the vector on the observer and the vector on the center of the sector is less than zero, then this sector does not interest us - now instead of zero we will use a value linearly dependent on height.  First let's define the variables - so we will have the minimum and maximum values ‚Äã‚Äãof the scalar product and the minimum and maximum values ‚Äã‚Äãof the height.  Construct the following system of equations <br><br><img src="https://habrastorage.org/web/279/7bc/99e/2797bc99efb8416b891b4d09000e5814.png"><br><br>  Now we express A in the second equation <br><br><img src="https://habrastorage.org/web/123/1d6/ed1/1231d6ed1227499e8774cd40f2368e2a.png"><br><br>  substitute A from the second equation into the first <br><br><img src="https://habrastorage.org/web/d07/01d/ced/d0701dced3734e83bf96af6731f19f06.png"><br><br>  express B from the first equation <br><br><img src="https://habrastorage.org/web/faa/363/8d5/faa3638d53914c628bc2d60945fb2f45.png"><br><br>  we substitute B from the first equation into the second <br><br><img src="https://habrastorage.org/web/f49/470/879/f4947087991b4d30b64aa254c7365463.png"><br><br>  Now we will substitute variables in function <br><br><img src="https://habrastorage.org/web/4d6/025/df0/4d6025df02674d088bfcbf883e0f200d.png"><br><br>  and get <br><br><img src="https://habrastorage.org/web/e55/942/92c/e5594292c2684192ba48cc9e9867b2fb.png"><br><br>  Where Hmin and Hmax are the minimum and maximum heights, Dmin and Dmax are the minimum and maximum values ‚Äã‚Äãof the scalar product.  This problem can be solved differently - see Appendix 4. <br><br>  Now you need to understand the levels of detail.  Each of them will determine the region of the value of the scalar product.  In pseudocode, the process of determining whether a sector belongs to a certain level looks like this: <br><br><pre> <code class="hljs 1c"><span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span>              <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     ,       <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>       <span class="hljs-keyword"><span class="hljs-keyword"></span></span>          <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  </code> </pre><br>  We need to calculate the range for each level.  First, we construct a system of two equations <br><br><img src="https://habrastorage.org/web/16a/096/266/16a09626650343b19a16961756462778.png"><br><br>  deciding it, we get <br><br><img src="https://habrastorage.org/web/cc2/4bd/ac8/cc24bdac8b454b69aaf6c3981db07030.png"><br><br>  Using these coefficients, we define the function <br><br><img src="https://habrastorage.org/web/928/de9/4cb/928de94cbde44aa2aa29c13bd194e67e.png"><br><br>  where Rmax is the domain of the scalar product (D (H) - Dmin), Rmin is the minimum domain defined by the level.  I use the value of 0.01.  Now we need to subtract the result from Dmax <br><br><img src="https://habrastorage.org/web/36d/262/b26/36d262b264bd4388bc79db3b7bd70a61.png"><br><br>  C using this function, we obtain areas for all levels.  Here is an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dotArea = dotRange.maxVal - dotRange.minVal; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Rmax = dotArea, Rmin = <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lodsCnt = lods.size(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> A = Rmax; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> B = powf(Rmin / Rmax, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / (lodsCnt - <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; lods.size(); g++){ lods[g].dotRange.minVal = dotRange.maxVal - A * powf(B, g); lods[g].dotRange.maxVal = dotRange.maxVal - A * powf(B, g + <span class="hljs-number"><span class="hljs-number">1</span></span>); } lods[lods.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>].dotRange.maxVal = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre><br>  Now we can determine to which level of detail the sector belongs (Fig. 13). <br><br><img src="https://habrastorage.org/web/686/449/c26/686449c26cf4409290a9f757114b09a5.png"><br>  <i><font color="#999999">Fig.13 Color differentiation of sectors according to levels of detail</font></i> <br><br>  Next you need to deal with the size of the grid.  It will be very expensive to store your grid for each level - it is much more efficient to change the detail of one grid on the fly using tessellation.  To do this, in addition to the above-vertex and pixel ones, we also need to implement hull and domain shaders.  In the Hull shader, the main task is to prepare control points.  It consists of two parts - the main function and the function that calculates the parameters of the control point.  Be sure to specify values ‚Äã‚Äãfor the following attributes: <br><blockquote>  domain <br>  partitioning <br>  outputtopology <br>  outputcontrolpoints <br>  patchconstantfunc </blockquote>  Here is an example of a hull shader for splitting triangles: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PatchData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> edges[<span class="hljs-number"><span class="hljs-number">3</span></span>] : SV_TessFactor; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> inside : SV_InsideTessFactor; }; <span class="hljs-function"><span class="hljs-function">PatchData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPatchData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputPatch&lt;VIn, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; Patch, uint PatchId : SV_PrimitiveID)</span></span></span><span class="hljs-function"> </span></span>{ PatchData output; flloat tessFactor = <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; output.edges[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tessFactor; output.edges[<span class="hljs-number"><span class="hljs-number">1</span></span>] = tessFactor; output.edges[<span class="hljs-number"><span class="hljs-number">2</span></span>] = tessFactor; output.inside = tessFactor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; } [domain(<span class="hljs-string"><span class="hljs-string">"tri"</span></span>)] [partitioning(<span class="hljs-string"><span class="hljs-string">"integer"</span></span>)] [outputtopology(<span class="hljs-string"><span class="hljs-string">"triangle_cw"</span></span>)] [outputcontrolpoints(<span class="hljs-number"><span class="hljs-number">3</span></span>)] [patchconstantfunc(<span class="hljs-string"><span class="hljs-string">"GetPatchData"</span></span>)] <span class="hljs-function"><span class="hljs-function">VIn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputPatch&lt;VIn, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; Patch, uint PointId : SV_OutputControlPointID, uint PatchId : SV_PrimitiveID)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Patch[PointId]; }</code> </pre><br>  See, the main work is done in GetPatchData ().  Her task is to establish the tessellation factor.  We will talk about it later, now we will pass to the Domain shader.  It receives control points from the Hull shader and coordinates from the tesselator.  The new value of the position or texture coordinates in the case of splitting triangles must be calculated by the following formula <br><br>  N = C1 * Fx + C2 * Fy + C3 * Fz <br><br>  where C1, C2 and C3 are the values ‚Äã‚Äãof the control points, F are the tesselator coordinates.  Also in the Domain shader, you need to set the domain attribute, the value of which corresponds to that specified in the Hull shader.  Here is an example of the Domain shader: <br><br><pre> <code class="cpp hljs">cbuffer buff0 : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(b0) { matrix worldViewProj; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PatchData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> edges[<span class="hljs-number"><span class="hljs-number">3</span></span>] : SV_TessFactor; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> inside : SV_InsideTessFactor; }; [domain(<span class="hljs-string"><span class="hljs-string">"quad"</span></span>)] <span class="hljs-function"><span class="hljs-function">PIn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessDomain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PatchData Patch, float3 Coord : SV_DomainLocation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OutputPatch&lt;VIn, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; Tri)</span></span></span><span class="hljs-function"> </span></span>{ float3 posL = Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].posL * Coord.x + Tri[<span class="hljs-number"><span class="hljs-number">1</span></span>].posL * Coord.y + Tri[<span class="hljs-number"><span class="hljs-number">2</span></span>].posL * Coord.z; float2 texCoords = Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].texCoords * Coord.x + Tri[<span class="hljs-number"><span class="hljs-number">1</span></span>].texCoords * Coord.y + Tri[<span class="hljs-number"><span class="hljs-number">2</span></span>].texCoords * Coord.z; PIn output; output.posH = mul(float4(posL, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>), worldViewProj); output.normalW = Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].normalW; output.texCoords = texCoords; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre><br>  The role of the vertex shader in this case is minimized - for me it simply ‚Äúdrives‚Äù the data to the next stage. <br><br>  Now you need to implement something similar.  Our primary task is to calculate the tessellation factor, or more precisely, to build its dependence on the height of the observer.  Again, build a system of equations <br><br><img src="https://habrastorage.org/web/565/85a/7fc/56585a7fcd0e415ea0826b4861bd6abe.png"><br><br>  deciding it in the same way as before, we get <br><br><img src="https://habrastorage.org/web/ec4/ae4/004/ec4ae40045194013b521920588b15281.png"><br><br>  where Tmin and Tmax are the minimum and maximum tessellation coefficients, Hmin and Hmax are the minimum and maximum values ‚Äã‚Äãof the observer height.  My minimum tessellation coefficient is one.  maximum is set separately for each level <br>  (for example 1, 2, 4, 16). <br><br>  In the future we will need to growth factor was limited to the nearest degree of two.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is, for values ‚Äã‚Äãfrom two to three we set the value to two, for values ‚Äã‚Äãfrom 4 to 7 we set 4, with values ‚Äã‚Äãfrom 8 to 15, the factor will be equal to 8, etc. </font><font style="vertical-align: inherit;">Let's solve this problem for factor 6. First, </font></font><br><br><img src="https://habrastorage.org/web/5ae/cd9/b77/5aecd9b77dc54bb19c15c85f1f6b8455.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let's </font><font style="vertical-align: inherit;">solve the following equation. </font><font style="vertical-align: inherit;">Let's take the decimal logarithm of the two parts of the equation </font></font><br><br><img src="https://habrastorage.org/web/f2d/8a9/e9b/f2d8a9e9bed14e9e81f294b8ce637810.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">according to the property of logarithms, we can rewrite the equation as follows. </font></font><br><br><img src="https://habrastorage.org/web/1bc/72d/06f/1bc72d06f5f7437b81f53fe597ede5d1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we only have to divide both parts by log (2)</font></font><br><br><img src="https://habrastorage.org/web/d1e/0f6/07a/d1e0f607aae34fd3af83471844d71cfe.png"><br><br>  But that is not all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X is approximately 2.58. </font><font style="vertical-align: inherit;">Next, you need to reset the fractional part and build a two to the power of the resulting number. </font><font style="vertical-align: inherit;">Here is the tessellation factor calculation code for detail levels.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = camera-&gt;GetHeight(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RangeF &amp;hR = heightRange; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LodsStorage::Lod &amp;lod : lods){ <span class="hljs-comment"><span class="hljs-comment">//derived from system //A + B * Hmax = Lmin //A + B * Hmin = Lmax //and getting A then substitution B in second equality float mTf = (float)lod.GetMaxTessFactor(); float tessFactor = 1.0f + (mTf - 1.0f) * ((h - hR.maxVal) / (hR.minVal - hR.maxVal)); tessFactor = Math::Saturate(tessFactor, RangeF(1.0f, mTf)); float nearPowOfTwo = pow(2.0f, floor(log(tessFactor) / log(2))); lod.SetTessFactor(nearPowOfTwo); }</span></span></code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Noise </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a look at how you can increase your landscape detail without changing the height map size. The following comes to my mind - change the height value to the value obtained from the gradient noise texture. The coordinates by which we will sample will be N times the major. When sampling, the mirror type of addressing will be used (D3D11_TEXTURE_ADDRESS_MIRROR) (see Figure 14). </font></font><br><br><img src="https://habrastorage.org/web/247/2ac/98e/2472ac98ea2f46ccaa8038f03b486c22.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.14 Sphere with height map + sphere with noise map = sphere with final height</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case the height will be calculated as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//float2 tc1 -  ,    ,   //  //texCoordsScale -   .      300 //mainHeightTex, mainHeightTexSampler -    //distHeightTex, distHeightTexSampler -    //maxTerrainHeight -   .    0.03 float2 tc2 = tc1 * texCoordsScale; float4 mainHeighTexColor = mainHeightTex.SampleLevel(mainHeightTexSampler, tc1, 0); float4 distHeighTexColor = distHeightTex.SampleLevel(distHeightTexSampler, tc2, 0); float height = (mainHeighTexColor.x + distHeighTexColor.x) * maxTerrainHeight;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far, the periodic nature is expressed significantly, but with the addition of lighting and texturing, the situation will change for the better. What is the texture of gradient noise? Roughly speaking, this is a grid of random values. Let's see how to match the size of the lattice to the size of the texture. Suppose we want to create a 256-by-256-pixel noise texture. It's simple, if the dimensions of the lattice coincide with the size of the texture - we get something like white noise on the TV. And what if our lattice has dimensions of, say, 2 by 2? The answer is simple - use interpolation. One of the formulations of linear interpolation is as follows: </font></font><br><br><img src="https://habrastorage.org/web/61c/49a/c68/61c49ac68ab84a6c89c64c1267d26233.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the fastest, but at the same time the least suitable option. It is better to use cosine-based interpolation:</font></font><br><br><img src="https://habrastorage.org/web/c57/e96/f99/c57e96f998474dd3b82cfe22cc36b7fb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we cannot just interpolate between the values ‚Äã‚Äãalong the edges of the diagonal (the lower left and upper right corner of the cell). In our case, the interpolation will need to be applied twice. Let's introduce one of the grid cells. She has four corners - let's call them V1, V2, V3, V4. Also inside this cell there will be its own two-dimensional coordinate system, where the point (0, 0) corresponds to V1 and the point (1, 1) to V3 (see Fig. 15a). In order to get a value with coordinates (0.5, 0.5), we first need to get two values ‚Äã‚Äãinterpolated in X between V1 and V4 and between V2 and V3, and finally interpolate in Y between these values ‚Äã‚Äã(Fig.15b).</font></font><br><br>  Here is an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">coords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> float4 P1 </span></span>= lerp(V1, V4, coords.x); float4 P2 = lerp(V2, V3, coords.x); float4 P = lerp(P1, P2, coords.y)</code> </pre><br><img src="https://habrastorage.org/web/547/65b/152/54765b152c0f45f1ad9bdef6e7e08c3d.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.15 a - Image of a lattice cell with coordinates V1, V2, V3 and V4. </font><font style="vertical-align: inherit;">b - Sequence of two interpolations on the example of a cell</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> now let's do the following - for each pixel of the noise texture we take the interpolated value for the 2x2 grid, then add to it the interpolated value for the 4x4 grid multiplied by 0.5, then for the 8x8 grid multiplied by 0.25 and so on. d to a certain limit - this is called the addition of the octaves (Fig. 16). </font><font style="vertical-align: inherit;">The formula looks like this:</font></font><br><br><img src="https://habrastorage.org/web/f3b/94d/1d2/f3b94d1d23084bacba9ca431169589b9.png"><br><br><img src="https://habrastorage.org/web/77b/2f2/718/77b2f2718d1d43acbdcb8fae0ad4a5c4.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fig.16 Example of the addition of octaves</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is an example of the implementation:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.width; x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.height; y++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> val = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; Vector2 normPos = {(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)x / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(sideSize - <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)y / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(sideSize - <span class="hljs-number"><span class="hljs-number">1</span></span>)}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> o = <span class="hljs-number"><span class="hljs-number">0</span></span>; o &lt; octavesCnt; o++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> frequency = powf(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(startFrequency + o)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intencity = powf(intencityFactor, (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)o); Vector2 freqPos = normPos * frequency; Point2 topLeftFreqPos = Cast&lt;Point2&gt;(freqPos); Point2 btmRightFreqPos = topLeftFreqPos + Point2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xFrac = freqPos.x - (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)topLeftFreqPos.x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yFrac = freqPos.y - (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)topLeftFreqPos.y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> iVal = GetInterpolatedValue(topLeftFreqPos, btmRightFreqPos, xFrac, yFrac); val += iVal * intencity; } noiseValues[y * size.width + x] = val; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also for V1, V2, V3 and V4 you can get the sum of the value itself and its neighbors as follows: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSmoothValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point2 &amp;Coords)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> corners = (GetValue({Coords.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, Coords.y - <span class="hljs-number"><span class="hljs-number">1</span></span>}) + GetValue({Coords.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, Coords.y - <span class="hljs-number"><span class="hljs-number">1</span></span>}) + GetValue({Coords.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, Coords.y + <span class="hljs-number"><span class="hljs-number">1</span></span>}) + GetValue({Coords.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, Coords.y + <span class="hljs-number"><span class="hljs-number">1</span></span>})) / <span class="hljs-number"><span class="hljs-number">16.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sides = (GetValue({Coords.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, Coords.y}) + GetValue({Coords.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, Coords.y}) + GetValue({Coords.x, Coords.y - <span class="hljs-number"><span class="hljs-number">1</span></span>}) + GetValue({Coords.x, Coords.y + <span class="hljs-number"><span class="hljs-number">1</span></span>})) / <span class="hljs-number"><span class="hljs-number">8.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> center = GetValue(Coords) / <span class="hljs-number"><span class="hljs-number">4.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> center + sides + corners; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use these values ‚Äã‚Äãin interpolation. </font><font style="vertical-align: inherit;">Here is the rest of the code:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInterpolatedValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point2 &amp;TopLeftCoord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point2 &amp;BottomRightCoord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> XFactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> YFactor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Point2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tlCoords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopLeftCoord.x, TopLeftCoord.y)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Point2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trCoords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BottomRightCoord.x, TopLeftCoord.y)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Point2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brCoords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BottomRightCoord.x, BottomRightCoord.y)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Point2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blCoords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopLeftCoord.x, BottomRightCoord.y)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tl = (useSmoothValues) ? GetSmoothValue(tlCoords) : GetValue(tlCoords); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tr = (useSmoothValues) ? GetSmoothValue(trCoords) : GetValue(trCoords); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> br = (useSmoothValues) ? GetSmoothValue(brCoords) : GetValue(brCoords); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bl = (useSmoothValues) ? GetSmoothValue(blCoords) : GetValue(blCoords); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomVal = Math::CosInterpolation(bl, br, XFactor); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topVal = Math::CosInterpolation(tl, tr, XFactor); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math::CosInterpolation(topVal, bottomVal, YFactor); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the conclusion of the subsection, I want to say that everything I have described up to this point is a slightly different implementation of the Perlin noise. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deal with the height - now let's see how to deal with the normals. </font><font style="vertical-align: inherit;">As in the case of the main height map, we need to generate a normal map from the noise text. </font><font style="vertical-align: inherit;">Then in the shader we simply add the normal from the main card to the normal of the noise texture. </font><font style="vertical-align: inherit;">I must say that this is not entirely correct, but it gives an acceptable result.</font></font> Here is an example: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//float2 texCoords1 -  ,    ,     //mainNormalTex, mainNormalTexSampler -    //distNormalTex, distNormalTexSampler -     float2 texCoords2 = texCoords1 * texCoordsScale; float4 mainNormColor = mainNormalTex.SampleLevel(mainNormalTexSampler, TexCoords1, 0); float4 distNormColor = distNormalTex.SampleLevel(distNormalTexSampler, TexCoords2, 0); float3 mainNormal = 2.0f * mainNormColor.rgb - 1.0f; float3 distNormal = 2.0f * distNormColor.rgb - 1.0f; float3 normal = normalize(mainNormal + distNormal);</span></span></code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Hardware Instancing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's do the optimization. </font><font style="vertical-align: inherit;">Now the cycle of drawing sectors in pseudocode looks like this</font></font><br><br><pre> <code class="cpp hljs">                     S      V1      V2            </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The performance of this approach is extremely small. There are several optimization options - you can build a quad tree for each plane of the cube, so as not to calculate the scalar product for each sector. You can also update the values ‚Äã‚Äãof V1 and V2 not for each sector, but for the six planes of the cube, which they belong to. I chose the third option - Instancing. Briefly about what it is. Let's say you want to draw a forest. You have a tree model, there is also a set of transformation matrices - tree positions, possible scaling or rotation. You can create one buffer, which will contain the vertices of all trees converted into world space - a good option, the forest does not run on the map. And what if you need to implement transformations - say, swaying trees in the wind.You can do this by copying the data of the model vertices N times into one buffer, adding the tree index to the data of the vertex (from 0 to N). Next, we update the array of transformation matrices and pass it as a variable to the shader. In the shader, we select the desired matrix by the tree index. How can data duplication be avoided? First I want to draw your attention to the fact that these vertices can be collected from several buffers. For when describing a vertex, you need to specify the source index in the InputSlot field of the D3D11_INPUT_ELEMENT_DESC structure. This can be used when implementing morphing facial animation ‚Äî let's say you have two vertex buffers containing two face states, and you want to interpolate these values ‚Äã‚Äãlinearly. Here's how to describe the top:Next, we update the array of transformation matrices and pass it as a variable to the shader. In the shader, we select the desired matrix by the tree index. How can data duplication be avoided? First I want to draw your attention to the fact that these vertices can be collected from several buffers. For when describing a vertex, you need to specify the source index in the InputSlot field of the D3D11_INPUT_ELEMENT_DESC structure. This can be used when implementing morphing facial animation ‚Äî let's say you have two vertex buffers containing two face states, and you want to interpolate these values ‚Äã‚Äãlinearly. Here's how to describe the top:Next, we update the array of transformation matrices and pass it as a variable to the shader. In the shader, we select the desired matrix by the tree index. How can data duplication be avoided? First I want to draw your attention to the fact that these vertices can be collected from several buffers. For when describing a vertex, you need to specify the source index in the InputSlot field of the D3D11_INPUT_ELEMENT_DESC structure. This can be used when implementing morphing facial animation ‚Äî let's say you have two vertex buffers containing two face states, and you want to interpolate these values ‚Äã‚Äãlinearly. Here's how to describe the top:For when describing a vertex, you need to specify the source index in the InputSlot field of the D3D11_INPUT_ELEMENT_DESC structure. This can be used when implementing morphing facial animation ‚Äî let's say you have two vertex buffers containing two face states, and you want to interpolate these values ‚Äã‚Äãlinearly. Here's how to describe the top:For when describing a vertex, you need to specify the source index in the InputSlot field of the D3D11_INPUT_ELEMENT_DESC structure. This can be used when implementing morphing facial animation ‚Äî let's say you have two vertex buffers containing two face states, and you want to interpolate these values ‚Äã‚Äãlinearly. Here's how to describe the top:</font></font><br><br><pre> <code class="cpp hljs">D3D11_INPUT_ELEMENT_DESC desc[] = { <span class="hljs-comment"><span class="hljs-comment">/*part1*/</span></span> {<span class="hljs-string"><span class="hljs-string">"POSITION"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"NORMAL"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"TEXCOORD"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-comment"><span class="hljs-comment">/*part2*/</span></span> {<span class="hljs-string"><span class="hljs-string">"POSITION"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"NORMAL"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"TEXCOORD"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>} }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the shader, the vertex must be described as follows: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIn</span></span></span><span class="hljs-class"> {</span></span> float3 position1 : POSITION0; float3 normal1 : NORMAL0; float2 tex1 : TEXCOORD0; float3 position2 : POSITION1; float3 normal2 : NORMAL1; float2 tex2 : TEXCOORD1; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then you just interpolate the values </font></font><br><br><pre> <code class="cpp hljs">float3 res = lerp(input.position1, input.position2, factor);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why am I doing this? </font><font style="vertical-align: inherit;">Let's go back to the trees example. </font><font style="vertical-align: inherit;">The top will be collected from two sources - the first will contain the position in the local space, the texture coordinates and the normal, the second - the transformation matrix in the form of four four-dimensional vectors. </font><font style="vertical-align: inherit;">The vertex description looks like this:</font></font><br><br><pre> <code class="cpp hljs">D3D11_INPUT_ELEMENT_DESC desc[] = { <span class="hljs-comment"><span class="hljs-comment">/*part1*/</span></span> {<span class="hljs-string"><span class="hljs-string">"POSITION"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"NORMAL"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"TEXCOORD"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-comment"><span class="hljs-comment">/*part2*/</span></span> {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that in the second part, the InputSlotClass field is D3D11_INPUT_PER_INSTANCE_DATA and the InstanceDataStepRate field is one (For a brief description of the InstanceDataStepRate field, see Appendix 1). </font><font style="vertical-align: inherit;">In this case, the collector will use the entire buffer from a source with type D3D11_INPUT_PER_VERTEX_DATA for each element from a source with type D3D11_INPUT_PER_INSTANCE_DATA. </font><font style="vertical-align: inherit;">In the shader, these vertices can be described as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIn</span></span></span><span class="hljs-class"> {</span></span> float3 posL : POSITION; float3 normalL : NORMAL; float2 tex : TEXCOORD; row_major float4x4 world : WORLD; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By creating a second buffer with the attributes D3D11_USAGE_DYNAMIC and D3D11_CPU_ACCESS_WRITE, we will be able to update it from the CPU. </font><font style="vertical-align: inherit;">You need to draw this kind of geometry using the calls DrawInstanced () or DrawIndexedInstanced (). </font><font style="vertical-align: inherit;">There are also calls DrawInstancedIndirect () and DrawIndexedInstancedIndirect () - see Appendix 2 for them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me give an example of setting up buffers and using the DrawIndexedInstanced () function:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//vb -   //tb - ""  //ib -   //vertexSize -      //instanceSize -    ""  //indicesCnt -   //instancesCnt -  "" std::vector&lt;ID3D11Buffer*&gt; buffers = {vb, tb}; std::vector&lt;UINT&gt; strides = {vertexSize, instanceSize}; std::vector&lt;UINT&gt; offsets = {0, 0}; deviceContext-&gt;IASetVertexBuffers(0,buffers.size(),&amp;buffers[0],&amp;strides[0],&amp;offsets[0]); deviceContext-&gt;IASetIndexBuffer(ib, DXGI_FORMAT_R32_UINT, 0); deviceContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); deviceContext-&gt;DrawIndexedInstanced(indicesCnt, instancesCnt, 0, 0, 0);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's finally get back to our topic. </font><font style="vertical-align: inherit;">Sector is described by a point on the plane to which it belongs and by two vectors which describe this plane. </font><font style="vertical-align: inherit;">Therefore, the top will consist of two sources. </font><font style="vertical-align: inherit;">The first is the coordinates in the grid space, the second is the sector data. </font><font style="vertical-align: inherit;">The vertex description looks like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;D3D11_INPUT_ELEMENT_DESC&gt; meta = { <span class="hljs-comment"><span class="hljs-comment">//    {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0} //   {"TEXCOORD", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, 0, D3D11_INPUT_PER_INSTANCE_DATA, 1}, //   {"TEXCOORD", 1, DXGI_FORMAT_R32G32B32_FLOAT, 1, 12, D3D11_INPUT_PER_INSTANCE_DATA, 1}, //  {"TEXCOORD", 2, DXGI_FORMAT_R32G32B32_FLOAT, 1, 24, D3D11_INPUT_PER_INSTANCE_DATA, 1} }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Please note that I use a three-dimensional vector to store coordinates in the grid space (the z coordinate is not used) </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Frustum culling </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important component of optimization is clipping by the pyramid of visibility (Frustum culling). </font><font style="vertical-align: inherit;">The visibility pyramid is the area of ‚Äã‚Äãthe scene that the camera ‚Äúsees‚Äù. </font><font style="vertical-align: inherit;">How to build it? </font><font style="vertical-align: inherit;">First, we recall that a point can be in four coordinate systems ‚Äî local, world, species, and the projection coordinate system. </font><font style="vertical-align: inherit;">The transition between them is carried out by means of matrices - world, species and matrix projections, and the transformation must take place sequentially - from the local to the world, from the world to the species and finally from the viewport to the space projection. </font><font style="vertical-align: inherit;">All these transformations can be combined into one by multiplying these matrices.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use the perspective projection, which implies the so-called ‚Äúhomogeneous division‚Äù - after multiplying the vector (Px, Py, Pz, 1) by the projection matrix, its components should be divided into the W component of this vector. </font><font style="vertical-align: inherit;">After the transition to the projection space and homogeneous division, the point is in the NDC space. </font><font style="vertical-align: inherit;">NDC space is a set of three coordinates x, y, z, where x and y belong to [-1, 1], and z - [0,1] (I must say that in OpenGL the parameters are somewhat different).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's get down to solving our problem. </font><font style="vertical-align: inherit;">In my case, the pyramid is located in the species space. </font><font style="vertical-align: inherit;">We need six planes that describe it (Fig. 17a). </font><font style="vertical-align: inherit;">The plane can be described using the normal and the point that belongs to this plane. </font><font style="vertical-align: inherit;">First, let's get the points - for this we take the following set of coordinates in the NDC space:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point4F&gt; pointsN = { {<span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, {<span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, { <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, {<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, {<span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, {<span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, { <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}, {<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>} };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look, at the first four points the value of z is 0 - this means that they belong to the near cut-off plane, at the last four z it is equal to 1 - they belong to the far cut-off plane. </font><font style="vertical-align: inherit;">Now these points need to be converted into view space.</font></font> But how? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember the example of an astronaut - so here is the same. </font><font style="vertical-align: inherit;">We need to multiply the points by the inverse projection matrix. </font><font style="vertical-align: inherit;">True, after that, we still need to divide each of them into its W coordinate. As a result, we will get the necessary coordinates (Fig. 17b). </font><font style="vertical-align: inherit;">Let's now deal with the normals - they must be directed inside the pyramid, so we need to choose the necessary order of calculation of the vector product.</font></font><br><br><pre> <code class="cpp hljs">Matrix4x4 invProj = Matrix4x4::Inverse(camera-&gt;GetProjMatrix()); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point3F&gt; pointsV; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point4F &amp;pN : pointsN){ Point4F pV = invProj.Transform(pN); pV /= pV.w; pointsV.push_back(Cast&lt;Point3F&gt;(pV)); } planes[<span class="hljs-number"><span class="hljs-number">0</span></span>] = {pointsV[<span class="hljs-number"><span class="hljs-number">0</span></span>], pointsV[<span class="hljs-number"><span class="hljs-number">1</span></span>], pointsV[<span class="hljs-number"><span class="hljs-number">2</span></span>]}; <span class="hljs-comment"><span class="hljs-comment">//near plane planes[1] = {pointsV[4], pointsV[5], pointsV[6]}; //far plane planes[2] = {pointsV[0], pointsV[1], pointsV[4]}; //left plane planes[3] = {pointsV[2], pointsV[3], pointsV[6]}; //right plane planes[4] = {pointsV[1], pointsV[2], pointsV[6]}; //top plane planes[5] = {pointsV[0], pointsV[3], pointsV[7]}; //bottom plane planes[0].normal *= -1.0f; planes[5].normal *= -1.0f;</span></span></code> </pre><br><img src="https://habrastorage.org/web/be5/1e3/132/be51e313213d437a8221a761c7cc79c5.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.17 Pyramid of visibility The</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pyramid is built - it's time to use it. Those sectors that do not fall inside the pyramid, we do not draw. In order to determine whether a sector is inside the visibility pyramid, we will check the bounding sphere located in the center of this sector. This does not give accurate results, but in this case I do not see anything terrible in the fact that several unnecessary sectors will be drawn. The radius of the sphere is calculated as follows:</font></font><br><br><img src="https://habrastorage.org/web/262/201/aee/262201aee5dd47d996b9d8e957cb4624.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where TR is the upper right corner of the sector, BL is the lower left corner. Since all sectors have the same area, it is sufficient to calculate the radius once.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How do we determine if a sphere describing a sector is inside the visibility pyramid? First, we need to determine whether the sphere intersects with the plane and, if not, from which side of it it is located. Let's get a vector on the center of the sphere</font></font><br><br><img src="https://habrastorage.org/web/1fe/999/6d6/1fe9996d6dcf434ea7ad396b452306cb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where P is a point on the plane and S is the center of the sphere. Now we calculate the scalar product of this vector by the normal to the plane. The orientation can be determined using the mark of the dot product - as mentioned earlier, if it is positive, then the sphere is in front of the plane, if negative, then the sphere is behind. It remains to determine whether the sphere intersects the plane. Let's take two vectors - N (normal vector) and V. Now we construct a vector from N to V - we call it K. Now, we need to find a length N so that it forms a 90 degree angle with K (formally speaking, N and K were orthogonal). Okie doki, look at fig.18a - we know from the properties of a right-angled triangle that we </font></font><br><br><img src="https://habrastorage.org/web/232/8e8/cfa/2328e8cfa8e24e62adc9ca3a3b99711d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need to find the cosine. Using the previously mentioned scalar product property we </font></font><br><br><img src="https://habrastorage.org/web/6ca/05c/c6c/6ca05cc6c3594c91b7f133cd8dbb7eb5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">divide both sides by | V | * | N | and get</font></font><br><br><img src="https://habrastorage.org/web/677/04c/cba/67704ccba4e848089bc60522deaa8b8f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use this result: </font></font><br><br><img src="https://habrastorage.org/web/9d5/be1/1dc/9d5be11dc5af473eb69baea650ef5de5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">since | V | is just a number, then we can shorten by | V |, and then we get </font></font><br><br><img src="https://habrastorage.org/web/3be/87d/a89/3be87da894e84e1e9c3b3427489af577.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the vector N is normalized, then the last step we simply multiply it by the resulting value, otherwise the vector should be normalized - in this case, the final equation looks like this: </font></font><br><br><img src="https://habrastorage.org/web/903/4ac/0e0/9034ac0e072247e3a704eeeb1ec3e66f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where D this is our new vector. This process is called "Vector projection" (Fig.18b). But why do we need it? We know that the vector is determined by the length and direction, and does not change from its position - this means that if we place the D so that it pointed to S, its length is equal to the minimum distance from S to the plane (ris.18s) </font></font><br><br><img src="https://habrastorage.org/web/434/d98/751/434d987518d44e0e8f635285102c34c5.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure .18 a Projection of N to V, b Visual display of the length of the projected N as applied to a point, s Visual display</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the lengths of the projected N as applied to a sphere centered at S</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since we do not need a projected vector, it suffices to calculate its length. Considering that N is a unit vector, we only need to calculate the scalar product V by N. Putting it all together, we can finally conclude that the sphere intersects the plane if the scalar product of the vector and the center of the sphere and the normal to the plane is greater than zero and less than the radius this sphere.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to assert that the sphere is inside the pyramid of visibility, we need to make sure that it either intersects one of the planes, or is in front of each of them. </font><font style="vertical-align: inherit;">You can put the question to another - if the sphere does not intersect and is behind at least one of the planes - it is definitely out of the pyramid of visibility. </font><font style="vertical-align: inherit;">So we will do. </font><font style="vertical-align: inherit;">Note that I translate the center of the sphere into the same space in which the pyramid is located - into the space of the view.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Frustum::TestSphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point3F &amp;Pos, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Radius, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix4x4 &amp;WorldViewMatrix) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Point3F posV = WorldViewMatrix.Transform(Pos); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Plane &amp;pl : planes){ Vector3 toSphPos = posV - pl.pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Vector3::Dot(toSphPos, pl.normal) &lt; -Radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Cracks </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another problem that we have to solve is cracks at the boundaries of the detail levels (Figure 19). </font></font><br><br><img src="https://habrastorage.org/web/f63/08c/313/f6308c313e87417f98f02abe2ae397a4.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.19 demonstration of landscape cracks.</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First of all, we need to identify those sectors that lie on the border of detail levels. At first glance it seems that this is a resource-intensive task - the number of sectors at each level is constantly changing. But if you use the data adjacency, the solution is greatly simplified. What is adjacency data? See, each sector has four neighbors. A set of references to them ‚Äî be it pointers or indexes ‚Äî is adjacency data. With their help, we can easily determine which sector lies on the border - it is enough to check which level its neighbors belong to.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, let's find the neighbors of each sector. </font><font style="vertical-align: inherit;">Again, we don‚Äôt need to cycle through all sectors. </font><font style="vertical-align: inherit;">Imagine that we are working with a sector with X and Y coordinates in grid space. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it does not touch the cube edge, then the coordinates of its neighbors will be as follows: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neighbor top - (X, Y - 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neighbor bottom - (X, Y + 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neighbor left - (X - 1, Y) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neighbor right - (X + 1, Y) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the sector touches the edge, then we place its special container. </font><font style="vertical-align: inherit;">After processing all six faces, it will contain all the boundary sectors of the cube. </font><font style="vertical-align: inherit;">It is in this container that we will have to bust. </font><font style="vertical-align: inherit;">Calculate the edges for each sector in advance:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectorEdges</span></span></span><span class="hljs-class"> {</span></span> CubeSectors::Sector *owner; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;Point3F, Point3F&gt; Edge; Edge edges[<span class="hljs-number"><span class="hljs-number">4</span></span>]; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;SectorEdges&gt; sectorsEdges; <span class="hljs-comment"><span class="hljs-comment">//borderSectors -     for(CubeSectors::Sector &amp;sec : borderSectors){ //     ,    , //    Vector3 v1 = sec.vec1 * sec.sideSize; Vector3 v2 = sec.vec2 * sec.sideSize; //sec.startPos -      SectorEdges secEdges; secEdges.owner = &amp;sec; secEdges.edges[ADJ_BOTTOM] = {sec.startPos, sec.startPos + v1}; secEdges.edges[ADJ_LEFT] = {sec.startPos, sec.startPos + v2}; secEdges.edges[ADJ_TOP] = {sec.startPos + v2, sec.startPos + v2 + v1}; secEdges.edges[ADJ_RIGHT] = {sec.startPos + v1, sec.startPos + v2 + v1}; sectorsEdges.push_back(secEdges); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next comes the search </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(SectorEdges &amp;edgs : sectorsEdges) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> e = <span class="hljs-number"><span class="hljs-number">0</span></span>; e &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; e++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(edgs.owner-&gt;adjacency[e] == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) FindSectorEdgeAdjacency(edgs, (AdjacencySide)e, sectorsEdges);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The FindSectorEdgeAdjacency () function looks like this </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CubeSectors::FindSectorEdgeAdjacency(SectorEdges &amp;Sector, CubeSectors::AdjacencySide Side, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;SectorEdges&gt; &amp;Neibs) { SectorEdges::Edge &amp;e = Sector.edges[Side]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(SectorEdges &amp;edgs2 : Neibs){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(edgs2.owner == Sector.owner) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> e = <span class="hljs-number"><span class="hljs-number">0</span></span>; e &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; e++){ SectorEdges::Edge &amp;e2 = edgs2.edges[e]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((Math::Equals(e.first, e2.first) &amp;&amp; Math::Equals(e.second, e2.second)) || (Math::Equals(e.second, e2.first) &amp;&amp; Math::Equals(e.first, e2.second))) { Sector.owner-&gt;adjacency[Side] = edgs2.owner; edgs2.owner-&gt;adjacency[e] = Sector.owner; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that we update the adjacency data for two sectors - the desired one (Sector) and the found neighbor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, using our adjacency data, we have to find those sector edges that belong to the boundary of detail levels. </font><font style="vertical-align: inherit;">There is such a plan - before drawing we will find the boundary sectors. </font><font style="vertical-align: inherit;">Then, for each sector, in addition to the basic </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">information </font><font style="vertical-align: inherit;">in the Instance buffer, </font><font style="vertical-align: inherit;">we write the tessellation coefficient and the four-dimensional vector of tessellation coefficients for the neighboring sectors. </font><font style="vertical-align: inherit;">The vertex description will now look like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;D3D11_INPUT_ELEMENT_DESC&gt; meta = { <span class="hljs-comment"><span class="hljs-comment">//    {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0} //   {"TEXCOORD", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, 0,D3D11_INPUT_PER_INSTANCE_DATA, 1}, //   {"TEXCOORD", 1, DXGI_FORMAT_R32G32B32_FLOAT, 1, 12, D3D11_INPUT_PER_INSTANCE_DATA, 1}, //  {"TEXCOORD", 2, DXGI_FORMAT_R32G32B32_FLOAT, 1, 24, D3D11_INPUT_PER_INSTANCE_DATA, 1}, //    {"TEXCOORD", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 36, D3D11_INPUT_PER_INSTANCE_DATA, 1}, //   {"TEXCOORD", 4, DXGI_FORMAT_R32_FLOAT, 1, 52, D3D11_INPUT_PER_INSTANCE_DATA, 1} }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After we have divided the sectors by levels of detail, we determine the neighboring tessellation coefficients for each sector: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LodsStorage::Lod &amp;lod : lods){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Sector*&gt; &amp;sectors = lod.GetSectors(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> lastLod = lod.GetInd() == lods.GetCount() - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Sector *s : sectors){ <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> tessFacor = s-&gt;GetTessFactor(); s-&gt;GetBorderTessFactor() = { GetNeibTessFactor(s, Sector::ADJ_BOTTOM, tessFacor, lastLod), GetNeibTessFactor(s, Sector::ADJ_LEFT, tessFacor, lastLod), GetNeibTessFactor(s, Sector::ADJ_TOP, tessFacor, lastLod), GetNeibTessFactor(s, Sector::ADJ_RIGHT, tessFacor, lastLod) }; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The function that looks for the next tessellation factor: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Terrain::GetNeibTessFactor(Sector *Sec, Sector::AdjacencySide Side, <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> TessFactor, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsLastLod) { Sector *neib = Sec-&gt;GetAdjacency()[Side]; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> neibTessFactor = neib-&gt;GetTessFactor(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (neibTessFactor &lt; TessFactor) ? (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)neibTessFactor : <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we return zero, then the neighbor on the Side side is of no interest to us. </font><font style="vertical-align: inherit;">Looking ahead and saying that we need to fix the cracks from the level with a large tessellation coefficient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we go to the shader. </font><font style="vertical-align: inherit;">Let me remind you that first we need to get the coordinates of the grid, using the coordinates of the tesselator. </font><font style="vertical-align: inherit;">Then these coordinates are converted to a point on the face of a cube, this point is normalized - and here we have a point on the sphere:</font></font><br><br><pre> <code class="cpp hljs">float3 p = Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].netPos * Coord.x + Tri[<span class="hljs-number"><span class="hljs-number">1</span></span>].netPos * Coord.y + Tri[<span class="hljs-number"><span class="hljs-number">2</span></span>].netPos * Coord.z; float3 planePos = Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].startPos + Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].vec1 * px * gridStep.x + Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].vec2 * py * gridStep.y; float3 sphPos = normalize(planePos);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we need to find out whether the vertex belongs to either the first or last row of the grid, or the first or last column ‚Äî in this case, the vertex belongs to the edge of the sector. </font><font style="vertical-align: inherit;">But this is not enough - we need to determine whether the vertex belongs to the level of detail. </font><font style="vertical-align: inherit;">To do this, we use information about neighboring sectors, or rather their tessellation levels:</font></font><br><br><pre> <code class="cpp hljs">float4 bTf = Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].borderTessFactor; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isEdge = (bTf.x != <span class="hljs-number"><span class="hljs-number">0.0f</span></span> &amp;&amp; py == <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) || <span class="hljs-comment"><span class="hljs-comment">//bottom (bTf.y != 0.0f &amp;&amp; px == 0.0f) || //left (bTf.z != 0.0f &amp;&amp; py == gridSize.y) || //top (bTf.w != 0.0f &amp;&amp; px == gridSize.x) //right</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the main stage - in fact, the elimination of cracks. Look at fig.20. The red line is the vertex of the vertex belonging to the second level of detail. Two blue lines - the faces of the third level of detail. We need to V3 belonged to the red line - that is, lay on the verge of the second level. As both the heights of V1 and V2 are equal for both levels, V3 can be found using linear interpolation between them. </font></font><br><br><img src="https://habrastorage.org/web/645/c2e/288/645c2e28813a4a888a7a755622415153.png"><br><br><img src="https://habrastorage.org/web/743/c1c/316/743c1c3168a34a96822e120d9311ce97.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.20 Demonstrating the faces that form a crack in the form of lines</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far we have neither V1 and V2, nor the coefficient F. First we need to find the index of the point V3. Ie, if the grid has a size of 32 by 32 and the tessellation coefficient is four, then this index will be from zero to 128 (32 * 4). We already have coordinates in the grid space p - in the framework of this example, they can be for example (15.5, 16). To obtain the index, multiply one of the coordinates p by the tessellation coefficient. We will also need the beginning of the face and the direction to its end - one of the corners of the sector.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> edgeVertInd = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; float3 edgeVec = float3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); float3 startPos = float3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); uint neibTessFactor = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bTf.x != <span class="hljs-number"><span class="hljs-number">0.0f</span></span> &amp;&amp; py == <span class="hljs-number"><span class="hljs-number">0.0f</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// bottom edgeVertInd = px * Tri[0].tessFactor; edgeVec = Tri[0].vec1; startPos = Tri[0].startPos; neibTessFactor = (uint)Tri[0].borderTessFactor.x; }else if(bTf.y != 0.0f &amp;&amp; px == 0.0f){ // left edgeVertInd = py * Tri[0].tessFactor; edgeVec = Tri[0].vec2; startPos = Tri[0].startPos; neibTessFactor = (uint)Tri[0].borderTessFactor.y; }else if(bTf.z != 0.0f &amp;&amp; py == gridSize.y){ // top edgeVertInd = px * Tri[0].tessFactor; edgeVec = Tri[0].vec1; startPos = Tri[0].startPos + Tri[0].vec2 * (gridStep.x * gridSize.x); neibTessFactor = (uint)Tri[0].borderTessFactor.z; }else if(bTf.w != 0.0f &amp;&amp; px == gridSize.x){ // right edgeVertInd = py * Tri[0].tessFactor; edgeVec = Tri[0].vec2; startPos = Tri[0].startPos + Tri[0].vec1 * (gridStep.x * gridSize.x); neibTessFactor = (uint)Tri[0].borderTessFactor.w; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we need to find the indices for V1 and V2. Imagine that you have a number of 3. You need to find the two nearest multiples of two. To do this, you calculate the remainder of dividing three by two - it is equal to one unit. Then you subtract or add this remainder to three and get the desired result. Also with indices, only instead of two we will have a ratio of tessellation coefficients of detail levels. If the third level has a coefficient equal to 16, and the second has 2, then the ratio will be 8. Now, to get the heights, you first need to get the corresponding points on the sphere, normalizing the points on the face. We have already prepared the beginning and direction of the edge - it remains to calculate the length of the vector from V1 to V2. Since the edge length of the cell of the original grid is equal to gridStep.x, then the length we need is equal to gridStep.x / Tri [0] .tessFactor.Then, by points on the sphere, we will get the height, as described earlier.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNeibHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 EdgeStartPos, float3 EdgeVec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VecLen, float3 NormOffset)</span></span></span><span class="hljs-function"> </span></span>{ float3 neibPos = EdgeStartPos + EdgeVec * VecLen; neibPos = normalize(neibPos); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetHeight(neibPos, NormOffset); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertOffset = gridStep.x / Tri[<span class="hljs-number"><span class="hljs-number">0</span></span>].tessFactor; uint tessRatio = (uint)tessFactor / (uint)neibTessFactor; uint ind = (uint)edgeVertInd % tessRatio; uint leftNeibInd = (uint)edgeVertInd - ind; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftNeibHeight = GetNeibHeight(startPos, edgeVec, vertOffset * leftNeibInd, normOffset); uint rightNeibInd = (uint)edgeVertInd + ind; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightNeibHeight = GetNeibHeight(startPos, edgeVec, vertOffset * rightNeibInd, normOffset);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, the last component is the factor F. We get it by dividing the remainder of the division by the ratio of the coefficients (ind) by the ratio of the coefficients (tessRatio) </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> factor = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)ind / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)tessRatio;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The final stage is linear interpolation of heights and getting a new vertex. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avgHeight = lerp(leftNeibHeight, rightNeibHeight, factor); posL = sphPos * (sphereRadius + avgHeight);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There may also be a crack in the place where the sectors border on the texture coordinates of the edges equal to 1 or 0. In this case, I take the average value between the heights for the two coordinates: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 TexCoords)</span></span></span><span class="hljs-function"> </span></span>{ float2 texCoords2 = TexCoords * texCoordsScale; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mHeight = mainHeightTex.SampleLevel(mainHeightTexSampler, TexCoords, <span class="hljs-number"><span class="hljs-number">0</span></span>).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dHeight = distHeightTex.SampleLevel(distHeightTexSampler, texCoords2, <span class="hljs-number"><span class="hljs-number">0</span></span>).x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (mHeight + dHeight) * maxTerrainHeight; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 SphPos, float3 NormOffset)</span></span></span><span class="hljs-function"> </span></span>{ float2 texCoords1 = GetTexCoords(SphPos, NormOffset); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height = GetHeight(texCoords1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(texCoords1.x == <span class="hljs-number"><span class="hljs-number">1.0f</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height2 = GetHeight(float2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, texCoords1.y)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(height, height2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(texCoords1.x == <span class="hljs-number"><span class="hljs-number">0.0f</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height2 = GetHeight(float2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, texCoords1.y)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(height, height2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height; }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. GPU processing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's transfer the processing of sectors to the GPU. We will have two Compute shaders - the first one performs clipping on the visibility pyramid and determines the level of detail, the second one will get the boundary tessellation coefficients to eliminate the cracks. The division into two stages is necessary because, as in the case of the CPU, we cannot correctly determine the neighbors for the sectors until we cut off. Since both shaders will use these levels of detail and work with sectors, I introduced two common structures: Sector and Lod</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sector</span></span></span><span class="hljs-class"> {</span></span> float3 vec1, vec2; float3 startPos; float3 normCenter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> adjacency[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> borderTessFactor[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lod; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lod</span></span></span><span class="hljs-class"> {</span></span> RangeF dotRange; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tessFactor; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> padding; float4 color; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will use three main buffers - input (contains the initial information about the sectors), intermediate (it contains data of the sectors obtained as a result of the first stage) and final (Will be transferred to the drawing). The input buffer data will not change, so in the Usage field of the D3D11_BUFFER_DESC structure, it is reasonable to use the value of D3D11_USAGE_IMMUTABLE We simply write data from all sectors with the only difference that we will use sector indices instead of pointers to these adjacency data. For the index of the level of detail and the boundary coefficients of tessellation set zero values:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sectorSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vector3) + <span class="hljs-comment"><span class="hljs-comment">//vec1 sizeof(Vector3) + //vec2 sizeof(Point3F) + //normCenter sizeof(Point3F) + //startPos sizeof(Point4) + //adjacency sizeof(Vector4) + //borderTessFactor sizeof(int32_t);//lod size_t sectorsDataSize = sectors.GetSectors().size() * sectorSize; std::vector&lt;char&gt; sectorsData(sectorsDataSize); char* ptr = &amp;sectorsData[0]; const Sector* firstPtr = &amp;sectors.GetSectors()[0]; for(const Sector &amp;sec : sectors){ Utils::AddToStream&lt;Vector3&gt;(ptr, sec.GetVec1()); Utils::AddToStream&lt;Vector3&gt;(ptr, sec.GetVec2()); Utils::AddToStream&lt;Point3F&gt;(ptr, sec.GetStartPos()); Utils::AddToStream&lt;Point3F&gt;(ptr, sec.GetNormCenter()); Utils::AddToStream&lt;int32_t&gt;(ptr, sec.GetAdjacency()[0] - firstPtr); Utils::AddToStream&lt;int32_t&gt;(ptr, sec.GetAdjacency()[1] - firstPtr); Utils::AddToStream&lt;int32_t&gt;(ptr, sec.GetAdjacency()[2] - firstPtr); Utils::AddToStream&lt;int32_t&gt;(ptr, sec.GetAdjacency()[3] - firstPtr); Utils::AddToStream&lt;Vector4&gt;(ptr, Vector4()); Utils::AddToStream&lt;int32_t&gt;(ptr, 0); } inputData = Utils::DirectX::CreateBuffer(&amp;sectorsData[0],//Raw data sectorsDataSize,//Buffer size D3D11_BIND_SHADER_RESOURCE,//bind flags D3D11_USAGE_IMMUTABLE,//usage 0,//CPU access flags D3D11_RESOURCE_MISC_BUFFER_STRUCTURED,//misc flags sectorSize);//structure byte stride</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now a couple of words about the intermediate buffer. </font><font style="vertical-align: inherit;">It will play two roles - output for the first shader and input for the second, so we will indicate in the BindFlags field the value D3D11_BIND_UNORDERED_ACCESS | </font><font style="vertical-align: inherit;">D3D11_BIND_SHADER_RESOURCE. </font><font style="vertical-align: inherit;">We will also create for it two mappings - UnorderedAccessView, which will allow the shader to write to it the result of the work and the ShaderResourceView, with which we will use the buffer as input. </font><font style="vertical-align: inherit;">Its size will be the same as the previously created input buffer.</font></font><br><br><pre> <code class="cpp hljs">UINT miscFlags = D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_SHADER_RESOURCE; intermediateData = Utils::DirectX::CreateBuffer( sectors.GetSectors().size() * sectorSize,<span class="hljs-comment"><span class="hljs-comment">//Buffer size miscFlags, D3D11_USAGE_DEFAULT,//usage 0,//CPU access flags D3D11_RESOURCE_MISC_BUFFER_STRUCTURED,//misc flags sectorSize);//structure byte stride intermediateUAW = Utils::DirectX::CreateUnorderedAccessView( intermediateData, D3D11_BUFFER_UAV{0, sectors.GetSectors().size(), 0}); intermediateSRV = Utils::DirectX::CreateShaderResourceView( intermediateData, D3D11_BUFFEREX_SRV{0, sectors.GetSectors().size(), 0});</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, I will give the main function of the first shader: </font></font><br><br><pre> <code class="cpp hljs">StructuredBuffer&lt;Sector&gt; inputData : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(t0); RWStructuredBuffer&lt;Sector&gt; outputData : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(u0); [numthreads(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int3 TId : SV_DispatchThreadID )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = TId.x; Sector sector = inputData[ind]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dotVal = dot(toWorldPos, sector.normCenter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dotVal &lt; dotRange.minVal || dotVal &gt; dotRange.maxVal){ outputData[ind] = sector; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IsVisible(sector.normCenter)){ outputData[ind] = sector; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; l++){ Lod lod = lods[l]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dotVal &gt;= lod.dotRange.minVal &amp;&amp; dotVal &lt;= lod.dotRange.maxVal) sector.lod = l + <span class="hljs-number"><span class="hljs-number">1</span></span>; } outputData[ind] = sector; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After calculating the dot product, we check if the sector is in a potentially visible area. Next, we clarify the fact of its visibility using the IsVisible () call, which is identical to the Frustum :: TestSphere () call shown earlier. The function depends on the worldView, sphereRadius, frustumPlanesPosV and frustumPlanesNormalsV variables, the values ‚Äã‚Äãfor which need to be passed to the shader in advance. Next, we determine the level of detail. Please note that we specify the level index from a unit - this is necessary in order to discard those sectors whose level of detail is zero at the second stage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to prepare buffers for the second stage. We want to use the buffer as output for the Compute shader and input for the tesselitator - for this we need to specify the value D3D11_BIND_UNORDERED_ACCESS | in the BindFlags field. D3D11_BIND_VERTEX_BUFFER. We will have to work with the buffer data directly, so we specify the value D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS in the MiscFlags field. To display this buffer, we will use the value DXGI_FORMAT_R32_TYPELESS in the Flags field, and in the NumElements field we specify the entire buffer, in the Flags field, in the Flags field, in the Flags field, in the Flags field, in the Flags field, in the Flags field, in the Flags field, in the Flags field, in the Flags field, we specify the entire buffer, in the Flags field, and in the Flags field, we will use the entire buffer, in the Flags field, we will use the entire buffer, in the Flags field, we will use the buffer in the Flags field;</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> instancesByteSize = instanceByteSize * sectors.GetSectors().size(); outputData = Utils::DirectX::CreateBuffer(instancesByteSize, D3D11_BIND_UNORDERED_ACCESS | D3D11_BIND_VERTEX_BUFFER, D3D11_USAGE_DEFAULT, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS, <span class="hljs-number"><span class="hljs-number">0</span></span>); D3D11_BUFFER_UAV uavParams = {<span class="hljs-number"><span class="hljs-number">0</span></span>, instancesByteSize / <span class="hljs-number"><span class="hljs-number">4</span></span>, D3D11_BUFFER_UAV_FLAG_RAW}; outputUAW = Utils::DirectX::CreateUnorderedAccessView(outputData, uavParams, DXGI_FORMAT_R32_TYPELESS);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also need a counter. </font><font style="vertical-align: inherit;">With it, we will address the memory in the shader and use its final value in the instanceCount argument of the drawIndexedInstanced () call. </font><font style="vertical-align: inherit;">The counter I implemented in the form of a buffer of 16 bytes. </font><font style="vertical-align: inherit;">Also, when creating the display in the Flags field of the D3D11_BUFFER_UAV field, I used the value D3D11_BUFFER_UAV_FLAG_COUNTER</font></font><br><br><pre> <code class="cpp hljs">counter = Utils::DirectX::CreateBuffer(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(UINT), D3D11_BIND_UNORDERED_ACCESS, D3D11_USAGE_DEFAULT, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_RESOURCE_MISC_BUFFER_STRUCTURED, <span class="hljs-number"><span class="hljs-number">4</span></span>); D3D11_BUFFER_UAV uavParams = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, D3D11_BUFFER_UAV_FLAG_COUNTER}; counterUAW = Utils::DirectX::CreateUnorderedAccessView(counter, uavParams);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is time to bring the code of the second shader </font></font><br><br><pre> <code class="cpp hljs">StructuredBuffer&lt;Sector&gt; inputData : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(t0); RWByteAddressBuffer outputData : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(u0); RWStructuredBuffer&lt;uint&gt; counter : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(u1); [numthreads(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( int3 TId : SV_DispatchThreadID )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = TId.x; Sector sector = inputData[ind]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sector.lod != <span class="hljs-number"><span class="hljs-number">0</span></span>){ sector.borderTessFactor[<span class="hljs-number"><span class="hljs-number">0</span></span>] = GetNeibTessFactor(sector, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bottom sector.borderTessFactor[1] = GetNeibTessFactor(sector, 1); //Left sector.borderTessFactor[2] = GetNeibTessFactor(sector, 2); //Top sector.borderTessFactor[3] = GetNeibTessFactor(sector, 3); //Right int c = counter.IncrementCounter(); int dataSize = 56; outputData.Store(c * dataSize + 0, asuint(sector.startPos.x)); outputData.Store(c * dataSize + 4, asuint(sector.startPos.y)); outputData.Store(c * dataSize + 8, asuint(sector.startPos.z)); outputData.Store(c * dataSize + 12, asuint(sector.vec1.x)); outputData.Store(c * dataSize + 16, asuint(sector.vec1.y)); outputData.Store(c * dataSize + 20, asuint(sector.vec1.z)); outputData.Store(c * dataSize + 24, asuint(sector.vec2.x)); outputData.Store(c * dataSize + 28, asuint(sector.vec2.y)); outputData.Store(c * dataSize + 32, asuint(sector.vec2.z)); outputData.Store(c * dataSize + 36, asuint(sector.borderTessFactor[0])); outputData.Store(c * dataSize + 40, asuint(sector.borderTessFactor[1])); outputData.Store(c * dataSize + 44, asuint(sector.borderTessFactor[2])); outputData.Store(c * dataSize + 48, asuint(sector.borderTessFactor[3])); outputData.Store(c * dataSize + 52, asuint(sector.lod)); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function code GetNeibTessFactor () is almost identical to its CPU counterpart. </font><font style="vertical-align: inherit;">The only difference is that we use neighbor indices and not pointers to them. </font><font style="vertical-align: inherit;">The outputData buffer is of type RWByteAddressBuffer, so we use the Store method (in uint address, in uint value) to work with it. </font><font style="vertical-align: inherit;">The value of the variable dataSize is equal to the size of the vertex data with the class D3D11_INPUT_PER_INSTANCE_DATA, the description of the vertex can be viewed in section 10. In general, this is traditional for C / C ++ working with pointers. </font><font style="vertical-align: inherit;">After executing the two shaders, we can use outputData as an InstanceBuffer. </font><font style="vertical-align: inherit;">The rendering process looks like this.</font></font><br><br><pre> <code class="cpp hljs">Utils::DirectX::SetPrimitiveStream({vb, outputData}, ib, {vertexSize, instanceByteSize}, D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST); DeviceKeeper::GetDeviceContext()-&gt;CopyStructureCount(indirectArgs, <span class="hljs-number"><span class="hljs-number">4</span></span>, counterUAW); Shaders::Apply(terrainShaders, [&amp;]() { DeviceKeeper::GetDeviceContext()-&gt;DrawIndexedInstancedIndirect(indirectArgs, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); Utils::DirectX::SetPrimitiveStream({<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>});</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For more information about the DrawIndexedInstancedIndirect () and CopyStructureCount () methods, see Appendix 2. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Camera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surely you know how to model a simple FPS (First Person Shooter) camera model. </font><font style="vertical-align: inherit;">I act according to this scenario:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From two angles I get a direction vector</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the direction vector and the vector (0, 1, 0), I get the basis</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> according to the direction vector and the right vector, obtained in step 2, I change the camera position</font></font></li></ul><br><img src="https://habrastorage.org/web/dd9/35b/248/dd935b24824041f9a1b0050d937aae17.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our case, the situation is somewhat complicated - firstly we must move relative to the center of the planet, secondly, when constructing the basis, instead of the vector (0, 1, 0), we must use the normal of the sphere at the point we are in now. To achieve the desired results, I will use two bases. According to the first, the position will change, the second will describe the orientation of the camera. The bases are interdependent, but I first calculate the basis of the position, so I'll start with it. Suppose we have an initial position basis (pDir, pUp, pRight) and a direction vector vDir, in which we want to move some distance. First of all, we need to calculate the projections of vDir on pDir and pRight. Having added them, we will receive the updated direction vector (Fig. 21). </font></font><br><br><img src="https://habrastorage.org/web/67c/122/9a8/67c1229a8cc342c3b299b5db053a20bb.png"><br><br><img src="https://habrastorage.org/web/618/d12/00c/618d1200cc7341cfa64e30a0c38d2890.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.21 The visual process of getting projDir</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next we move along this vector </font></font><br><br><img src="https://habrastorage.org/web/006/db0/f1a/006db0f1a8a24df5a31be389c192f2f9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where P is the camera position, mF and mS are the coefficients, which means how much we need to move forward or sideways. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We cannot use PN as a new camera position, because PN does not belong to a sphere. Instead, we find the normal of the sphere at the point PN, and this normal will be the new value of the vector up. Now we can form an updated basis</font></font><br><br><pre> <code class="cpp hljs">Vector3 nUp = Vector3::Normalize(PN - spherePos); Vector3 nDir = projDir Vector3 nRight = Vector3::Normalize(Vector3::Cross(pUp, pDir))</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where spherePos is the center of the sphere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to make sure that each of its vectors is orthogonal to the other two. According to the property of the vector product, nRight satisfies this condition. It remains to achieve the same for nUp and nDir. To do this, project nDir onto nUp and subtract the resulting vector from nDir (Fig.22) Fig.22 </font></font><br><br><img src="https://habrastorage.org/web/873/246/9e5/8732469e5c2845248de850800f0a799c.png"><br><br><img src="https://habrastorage.org/web/efe/685/3dd/efe6853dd7014eedb8ecb5eb17552dd3.png"><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orthogonalizing nDir with respect to nUp</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We could do the same with nUp, but then it would change its direction, which in our case is unacceptable. Now we normalize nDir and obtain an updated orthonormal direction basis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second key step is to build the basis of orientation. The main difficulty is getting the direction vector. the most suitable solution is to convert a point with a polar angle a, an azimuth angle b and a distance from the origin of coordinates equal to one from spherical coordinates to Cartesian. Only if we make such a transition for a point with a polar angle equal to zero, then we get a vector looking up. This does not quite suit us, since we will increment the angles and assume that such a vector will look ahead. A banal angle shift of 90 degrees will solve the problem, but it will be more elegant to use the angle shift rule, which says that </font></font><br><br><img src="https://habrastorage.org/web/c71/ac0/1aa/c71ac01aa6ee4d74b35a5189a95bf407.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will do so. As a result, we have the following: </font></font><br><br><img src="https://habrastorage.org/web/223/3e5/2ce/2233e52ce011461fa9e69c2a9f79a90c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where a is the polar angle, b is the azimuth angle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This result does not quite suit us - we need to build a direction vector relative to the basis of the position. Let's rewrite the equation for vDir: </font></font><br><br><img src="https://habrastorage.org/web/c02/f54/e73/c02f54e73c0d4cc2b9790a2021b7188a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything, like astronauts - in this direction so much, so much so. Now it should be obvious that if we replace the vectors of the standard basis with pDir, pUp and pRight, then we get the direction we need. So you </font></font><br><br><img src="https://habrastorage.org/web/5da/041/084/5da0410843e24faaace7bbc1876de04e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can imagine the same thing in the form of matrix multiplication. The </font></font><br><br><img src="https://habrastorage.org/web/79a/2e5/a22/79a2e5a222994bbcb4f956c546de1064.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector vUp will initially be equal to pUp. Having calculated the vector product vUp and vDir, we get vRight. </font></font><br><br><img src="https://habrastorage.org/web/ce3/509/91f/ce350991f4c74bc1a16450e737ef0ab4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will make it so that vUp is orthogonal with respect to the other vectors of the basis. The principle is the same as when working with nDir. </font></font><br><br><img src="https://habrastorage.org/web/c45/90d/8f1/c4590d8f13534757bea86368667000b3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bases were sorted out - it remains to calculate the camera position. This is done like this.</font></font><br><br><img src="https://habrastorage.org/web/071/c2f/ad1/071c2fad1b5242139704a9b14405fca5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where spherePos is the center of the sphere, sphereRadius is the radius of the sphere and height is the height above the surface of the sphere. </font><font style="vertical-align: inherit;">I will give the code of operation of the camera described:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveFactor = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, sideFactor = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, heightFactor = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; DirectInput::GetInsance()-&gt;ProcessKeyboardDown({ {DIK_W, [&amp;](){moveFactor = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;}}, {DIK_S, [&amp;](){moveFactor = <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>;}}, {DIK_D, [&amp;](){sideFactor = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;}}, {DIK_A, [&amp;](){sideFactor = <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>;}}, {DIK_Q, [&amp;](){heightFactor = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;}}, {DIK_E, [&amp;](){heightFactor = <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>;}} }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(moveFactor != <span class="hljs-number"><span class="hljs-number">0.0f</span></span> || sideFactor != <span class="hljs-number"><span class="hljs-number">0.0f</span></span>){ Vector3 newDir = Vector3::Normalize(pDir * Vector3::Dot(pDir, vDir) + pRight * Vector3::Dot(pRight, vDir)); Point3F newPos = pos + (newDir * moveFactor + pRight * sideFactor) * Tf * speed; pDir = newDir; pUp = Vector3::Normalize(newPos - spherePos); pRight = Vector3::Normalize(Vector3::Cross(pUp, pDir)); pDir = Vector3::Normalize(pDir - pUp * Vector3::Dot(pUp, pDir)); pos = spherePos + pUp * (sphereRadius + height); angles.x = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(heightFactor != <span class="hljs-number"><span class="hljs-number">0.0f</span></span>){ height = Math::Saturate(height + heightFactor * Tf * speed, heightRange); pos = spherePos + pUp * (sphereRadius + height); } DirectInput::MouseState mState = DirectInput::GetInsance()-&gt;GetMouseDelta(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mState.x != <span class="hljs-number"><span class="hljs-number">0</span></span> || mState.y != <span class="hljs-number"><span class="hljs-number">0</span></span> || moveFactor != <span class="hljs-number"><span class="hljs-number">0.0f</span></span> || sideFactor != <span class="hljs-number"><span class="hljs-number">0.0f</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mState.x != <span class="hljs-number"><span class="hljs-number">0</span></span>) angles.x = angles.x + mState.x / <span class="hljs-number"><span class="hljs-number">80.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mState.y != <span class="hljs-number"><span class="hljs-number">0</span></span>) angles.y = Math::Saturate(angles.y + mState.y / <span class="hljs-number"><span class="hljs-number">80.0f</span></span>, RangeF(-Pi * <span class="hljs-number"><span class="hljs-number">0.499f</span></span>, Pi * <span class="hljs-number"><span class="hljs-number">0.499f</span></span>)); vDir = Vector3::Normalize(pRight * sinf(angles.x) * cosf(angles.y) + pUp * -sinf(angles.y) + pDir * cosf(angles.x) * cosf(angles.y)); vUp = pUp; vRight = Vector3::Normalize(Vector3::Cross(vUp, vDir)); vUp = Vector3::Normalize(vUp - vDir * Vector3::Dot(vDir, vUp)); } viewMatrix = Matrix4x4::Inverse({{vRight, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>}, {vUp, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>}, {vDir, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>}, {pos, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}});</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that we reset angles.x after we have updated the basis of the position. </font><font style="vertical-align: inherit;">This is critically important. </font><font style="vertical-align: inherit;">Let's imagine that we simultaneously change the angle of view and move around the sphere. </font><font style="vertical-align: inherit;">First, we project the direction vector onto pDir and pRight, get the offset (newPos) and, based on it, update the position basis. </font><font style="vertical-align: inherit;">The second condition will also work, and we will begin to update the orientation basis. </font><font style="vertical-align: inherit;">But since pDir and pRight have already been changed depending on vDir, then without resetting the azimuth angle (angles.x), the rotation will be more ‚Äústeep‚Äù</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I thank the reader for showing interest in the article. </font><font style="vertical-align: inherit;">I hope that the information contained therein was accessible, interesting and useful. </font><font style="vertical-align: inherit;">Suggestions and comments can be sent to me by mail alexwin32@mail.ru or leave as comments.</font></font><br><br>  I wish you success! <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annex 1</font></font></b> <div class="spoiler_text">   InstanceDataStepRate    ,     D3D11_INPUT_PER_VERTEX_DATA    D3D11_INPUT_PER_INSTANCE_DATA.      ‚Äî   . ¬´         ?¬ª ‚Äî  .  .    ‚Äî ,    99    .      : <br><br><pre> <code class="cpp hljs">UINT colorsRate = <span class="hljs-number"><span class="hljs-number">99</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;D3D11_INPUT_ELEMENT_DESC&gt; meta = { {<span class="hljs-string"><span class="hljs-string">"POSITION"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"NORMAL"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"TEXCOORD"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"WORLD"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"COLOR"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, DXGI_FORMAT_R32G32B32A32_FLOAT, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, D3D11_INPUT_PER_INSTANCE_DATA, colorsRate}, };</code> </pre><br>  ,      ,       33 ¬´¬ª.     33   ,  33 ‚Äî   ..   . ,      ,      c  D3D11_USAGE_IMMUTABLE.  ,       ,  GPU      ,     .    : <br><br><pre> <code class="cpp hljs">matricesTb = Utils::DirectX::CreateBuffer(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Matrix4x4) * <span class="hljs-number"><span class="hljs-number">99</span></span>, D3D11_BIND_VERTEX_BUFFER, D3D11_USAGE_DYNAMIC, D3D11_CPU_ACCESS_WRITE); colorsTb = Utils::DirectX::CreateBuffer(colors, D3D11_BIND_VERTEX_BUFFER, D3D11_USAGE_IMMUTABLE, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>       (     ‚Äî ,    ) <br><br><pre> <code class="cpp hljs">Utils::DirectX::Map&lt;Matrix4x4&gt;(matricesTb, [&amp;](Matrix4x4 *Data) { <span class="hljs-comment"><span class="hljs-comment">//         //    ..  ,    //         });</span></span></code> </pre><br>        ,     <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix 2</font></font></b> <div class="spoiler_text">    DrawIndexedInstanced()  DrawIndexedInstancedIndirect()     ,    ,      DrawIndexedInstanced().        D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS.    : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//indicesCnt - - ,     //instancesCnt - - "",     std::vector&lt;UINT&gt; args = { indicesCnt, //IndexCountPerInstance instancesCnt,//InstanceCount 0,//StartIndexLocation 0,//BaseVertexLocation 0//StartInstanceLocation }; D3D11_BUFFER_DESC bd = {}; bd.Usage = D3D11_USAGE_DEFAULT; bd.ByteWidth = sizeof(UINT) * args.size(); bd.BindFlags = 0; bd.CPUAccessFlags = 0; bd.MiscFlags = D3D11_RESOURCE_MISC_DRAWINDIRECT_ARGS; bd.StructureByteStride = 0; ID3D11Buffer* buffer; D3D11_SUBRESOURCE_DATA initData = {}; initData.pSysMem = &amp;args[0]; HR(DeviceKeeper::GetDevice()-&gt;CreateBuffer(&amp;bd, &amp;initData, &amp;buffer));   DrawIndexedInstancedIndirect(): DeviceKeeper::GetDeviceContext()-&gt;DrawIndexedInstancedIndirect(indirectArgs, 0);</span></span></code> </pre><br>          ,      .    ? ,       GPU.     ‚Äî   Compute    AppendStructuredBuffer,     .    CopyStructureCount()     ¬´¬ª,            DrawIndexedInstancedIndirect() <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix 3</font></font></b> <div class="spoiler_text">  ,        X   a,    z ‚Äî   Z    : <br><br><img src="https://habrastorage.org/web/361/63f/87d/36163f87d17345dd88b794550d75c0bd.png"><br><br>        .  ,              .     : <br><br><img src="https://habrastorage.org/web/2bb/47b/6a1/2bb47b6a14e142549dc0e08614710bc7.png"><br><br>        : <br><br><img src="https://habrastorage.org/web/b7b/15e/e73/b7b15ee7336944f3a66174dbfd1691ab.png"><br><br>          ?    . ,       ( t &gt;= 0): <br><br><img src="https://habrastorage.org/web/5d2/7a1/be8/5d27a1be8dbd4bcbb8b60d869015e23b.png"><br><br>     X <br><br><img src="https://habrastorage.org/web/213/9f5/e0b/2139f5e0ba914d97bdd9c5623078a4a5.png"><br><br>   Y <br><br><img src="https://habrastorage.org/web/b37/f37/d5f/b37f37d5f2bc45dc9ef760b7112bec55.png"><br><br>   ,     (2, 3),     <br><br><img src="https://habrastorage.org/web/25f/1a7/e29/25f1a7e29f6c4afba206569d6332f4d1.png"><br><br>    P(t)    : <br><br><img src="https://habrastorage.org/web/984/c44/7f7/984c447f7a7642d092f709950dc8de83.png"><br><br>       ¬´      (3, 2)  t   (2, 3)¬ª.    : <br><br><img src="https://habrastorage.org/web/265/e07/efe/265e07efe9af4a6ca7e7cb6d85616db5.png"><br><br>      X <br><br><img src="https://habrastorage.org/web/848/bb7/de1/848bb7de16d442818cb8c993a30a1cc0.png"><br><br>    Y <br><br><img src="https://habrastorage.org/web/b86/496/25b/b8649625b23c4d8cb999564ba7d7297d.png"><br><br>        .         : ¬´      (3, 2),      ¬ª. <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix 4</font></font></b> <div class="spoiler_text">    F(H),       [Hmin, Hmax]     0  1,  F(Hmin) = 0  F(Hmax) = 1.    <br><br><img src="https://habrastorage.org/web/c51/bcb/f82/c51bcbf8240c43c99b3b008a145bdd1e.png"><br><br>   <br><br><img src="https://habrastorage.org/web/569/dc0/d30/569dc0d303eb4c528959b257208dac21.png"><br><br>     F   <br><br><img src="https://habrastorage.org/web/487/7ea/153/4877ea15348a47449d085b6e2b0fafe5.png"><br><br>    ,      0  1       .   ,       ‚Äî   .   : <br><br><img src="https://habrastorage.org/web/d51/00e/e19/d5100ee196f24af69199025a6ceebbda.png"><br><br>   <br><br><img src="https://habrastorage.org/web/4bc/f74/33d/4bcf7433d2ba4b56ad685a039c7b6a33.png"><br><br>    <br><br><img src="https://habrastorage.org/web/d85/edf/7b1/d85edf7b1c624f0195a9cd069d1035eb.png"><br><br>   D(F(H))   <br><br><img src="https://habrastorage.org/web/fc6/241/e66/fc6241e666314f1198b6438581167584.png"><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/335588/">https://habr.com/ru/post/335588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335576/index.html">Digital economy and ecosystem R</a></li>
<li><a href="../335578/index.html">DLP and the Law: how to properly arrange the introduction of a system to protect against leaks</a></li>
<li><a href="../335580/index.html">Automation of fishing for World of Warcraft</a></li>
<li><a href="../335584/index.html">What's new in PHP 7.2?</a></li>
<li><a href="../335586/index.html">Visualization of Moscow Exchange data using InterSystems DeepSee</a></li>
<li><a href="../335590/index.html">Social Organism - as a form of effective team interaction. Part 2</a></li>
<li><a href="../335592/index.html">Cisco Digital Network Architecture: Key Features of the New Platform</a></li>
<li><a href="../335600/index.html">Internet bicycles - how IT helps to lead a healthy lifestyle and reduce harmful emissions</a></li>
<li><a href="../335602/index.html">The hunt for malicious npm-packages</a></li>
<li><a href="../335606/index.html">Useful books on the development of mobile games on Android and iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>