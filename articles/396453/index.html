<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mate horse and elephant. Solution Base</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Want to puzzle the novice chess player? 
 Ask him to checkmate with a horse and an elephant. 

 Want to puzzle a novice programmer? 
 Ask him to calcu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mate horse and elephant. Solution Base</h1><div class="post__text post__text-html js-mediator-article">  Want to puzzle the novice chess player? <br>  Ask him to checkmate with a horse and an elephant. <br><br>  Want to puzzle a novice programmer? <br>  Ask him to calculate the mat horse and elephant. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/552/4b2/6d8/5524b26d81625b9ae809054ed010ee1d.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Chess problems excite the programmer's imagination, <br>  that is why for practical demonstration of combinatorics <br>  I chose the most difficult chess problem from the ‚Äúcheckmate to the lonely king‚Äù cycle. <br><a name="habracut"></a><br><h2>  Goal setting </h2><br>  The goal of the project is to create a decision base, that is, a list of correct moves for all possible arrangements of the white king, bishop, and black king on the chessboard. <br><br>  In this publication, I will tell you how I solved this problem, what difficulties I had to face, and also to demonstrate what eventually happened.  Technologies used: C #, JavaScript, PHP, HTML, CSS. <br><br>  Being a very mediocre chess player, I never learned how to quickly checkmate with a knight and an elephant.  Therefore, I decided to compensate for this lack with my programming skills, go through all possible positions and find the right move for each. <br><br>  Before writing at least a line of code, I had a ‚ÄúNapoleon‚Äù plan for several weeks, as I would do.  I really wanted to start to solve this problem from the end, with the search of all matte combinations.  And then make one move backward until all possible options have been exhausted. <br><br><h2>  How many options are there? </h2><br>  On the chessboard 64 cells.  We have four figures. <br>  The number of possible combinations is 64 * 64 * 64 * 64 = 16,777,216. <br><br>  You can leave only the light-squared elephant. <br>  The number of options will be halved: 64 * 32 * 64 * 64 = 8,388,608. <br>  So many positions will be in our database of solutions. <br><br>  In fact, there are even fewer combinations: two figures cannot stand on one square, kings cannot stand on neighboring squares, the black king cannot be under check, and so on.  Looking ahead, I will say that in the database of solutions there were 5,609,790 combinations, the array will be 67% full. <br><br>  However, in order to simplify the algorithm and speed up access to the database data, I decided to ‚Äúnot waste time on trifles‚Äù and create a four-dimensional array for all combinations. <br><br>  For the storage of each combination, the following structure is defined: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Combo { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKing; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteBishop; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKnight; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord blackKing; }</code> </pre> <br>  Inside, another Coord structure is used to record the coordinates of the figure, with the possibility of calculating the index from 0 to 63, as well as with the overloaded comparison operator. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coord { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//    0  7 ( a  h) public byte y; //    0  7 public int index { get { return x + y * 8; } set { x = (byte) (value % 8); y = (byte) (value / 8); } } public static bool operator == (Coord a, Coord b) { return ax == bx &amp;&amp; ay == by; } }</span></span></code> </pre><br>  This structure turned out to be very convenient for passing as an argument to various auxiliary functions, for example: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheck</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     bool isCheckmate (Combo combo); //   bool isCheckByBishop (Combo combo); //     </span></span></code> </pre><br>  However, it‚Äôs not enough to record the result of the decision base of this structure; <br><br><h2>  White box </h2><br>  The goal of our program will be the creation of a ‚Äúwhite box‚Äù, into which all positions will be formed, in which the ‚Äúwhite move‚Äù, and for which it is known, what kind of move needs to be made and how many moves will be mated with guarantee. <br><br>  An integral part of the ‚Äúwhite box‚Äù is the following structure: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WhitesMove { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves; <span class="hljs-comment"><span class="hljs-comment">//     public Coord moveFrom; //   -  public Coord moveTo; //  }</span></span></code> </pre><br>  For the organization of the "white box" the easiest way to open a four-dimensional matrix.  Each dimension of this matrix corresponds to the possible position of each figure: <br><br><pre> <code class="cs hljs"> WhitesMove [ , , , ] box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WhitesMove [<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>];</code> </pre><br>  The first dimension is the coordinate of the white king. <br>  the second dimension is the coordinate of the white elephant / 2. <br>  the third dimension is the coordinate of the white horse. <br>  the fourth dimension is the coordinate of the black king. <br><br>  The main thing is not to confuse their order :) The array will turn out to be 33% discharged, but very convenient for processing.  It is in this array that 8,388,608 records will be stored for solving combinations. <br><br>  By the way, before starting to write all the brute force algorithms, I created an empty project and initialized this four-dimensional matrix in order to make sure that there is enough memory and no need to reinvent something else.  Apparently, the experience of participation in Olympiads in computer science of the past millennium, where the size of the structure could not exceed 64 kilobytes, has affected, because Turbo Pascal 7.0. <br><br><h2>  The idea of ‚Äã‚Äãthe algorithm </h2><br>  I will briefly describe the main idea of ‚Äã‚Äãsolving this problem.  It is based on the search algorithm in breadth, which had to be slightly modified, since two people play chess and the moves are made in turn.  Therefore, instead of one queue, we will need two - ‚Äúblack‚Äù and ‚Äúwhite‚Äù. <br><br><pre> <code class="cs hljs"> Queue&lt;BlacksMove&gt; blackQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;BlacksMove&gt;(); Queue&lt;WhitesMove&gt; whiteQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;WhitesMove&gt;();</code> </pre><br>  With the structure of WhitesMove, we have already met.  The structure of BlacksMove is a bit simpler, since there is no need to keep Black‚Äôs last move in it. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlacksMove { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves; }</code> </pre><br>  First, in the ‚Äúblack line‚Äù we will place all the dull positions in which the black moves.  Then from each such position we will make a reverse move for White and form a ‚Äúwhite line‚Äù - a list of positions in which White‚Äôs move. <br><br>  These actions will need to be repeated until all possible combinations have been fully exhausted. <br><br>  The main algorithm in the form of pseudocode: <br><br><pre> <code class="cs hljs">  <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>        <span class="hljs-string"><span class="hljs-string">" "</span></span>  {  <span class="hljs-string"><span class="hljs-string">" "</span></span>      <span class="hljs-string"><span class="hljs-string">" "</span></span>                  <span class="hljs-string"><span class="hljs-string">" "</span></span>    <span class="hljs-string"><span class="hljs-string">" "</span></span>    <span class="hljs-string"><span class="hljs-string">" "</span></span>  <span class="hljs-string"><span class="hljs-string">" "</span></span>      <span class="hljs-string"><span class="hljs-string">" "</span></span>                     <span class="hljs-string"><span class="hljs-string">" "</span></span>    <span class="hljs-string"><span class="hljs-string">" "</span></span> }  <span class="hljs-string"><span class="hljs-string">" "</span></span>    <span class="hljs-string"><span class="hljs-string">" "</span></span>   </code> </pre><br><br><h2>  Matt Positions </h2><br>  Creating the base of the correct moves begins with a search for all matte combinations.  The use of enumerators made it possible to quite effectively describe this process. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Combo combo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllCheckmates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span> { BlacksMove checkmate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlacksMove { combo = combo, moves = <span class="hljs-number"><span class="hljs-number">0</span></span> }; blackQueue.Enqueue(checkmate); }</code> </pre><br>  Total found 232 matte positions.  Let me remind you that we have limited ourselves to the light-squared elephant. <br><br>  Some of them are quite exotic, non-existent and ‚Äúcooperative‚Äù, this is when the black king himself crawled under the mat. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/cb8/72f/c4e/cb872fc4e552449343b0bb9ad2e80303.png" alt="Mat.  What was the white move?"><br><br>  Chess players are well aware that the horse knight and the squared elephant must be placed in the white corner.  In the black corner, checkmate is possible only if black plays along.  I specifically posted a photo with just such a pseudomat at the beginning of the article to provoke the attention of real chess players :) <br><br><h2>  Checkmate one move </h2><br>  The next stage is to make White's return.  That is, for each matte position found, make <b>all possible White's reverse moves</b> . <br><br>  How to make a return stroke?  Considering that the taking in our positions is not provided for, the algorithm is quite simple - to make any white move, after which there will be no check to the black king. <br><br>  All positions found in this way can already be put in a ‚Äúwhite box‚Äù, indicating that there is one move to the mat and which move is needed to do this.  Along the way, we put the found combinations into a ‚Äúblack queue‚Äù. <br><br>  This is what this part of the algorithm looks like: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  " "   while (blackQueue.Count &gt; 0) { //    " " BlacksMove black = blackQueue.Dequeue(); //        foreach (WhitesMove white in AllWhiteBackMoves(black)) //      if (!isCheck(white.combo)) //      " " if (!whiteBox.Exists(white.combo)) { //    " " whiteBox.Put (white); //    " " whiteQueue.Enqueue(white); } }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">By the way, about yield</b> <div class="spoiler_text">  The use of enumerators with the yield mechanism allows for very nice implementation of various iterations, for example, this is how the function looks through all possible moves with white pieces: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;WhitesMove&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlacksMove black</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">)) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBishopMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">)) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKnightMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">)) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>; }</code> </pre><br></div></div><br>  A total of 920 such positions were found, here are the most interesting: <br><br>  The knight's move: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/a3c/5e9/e2a/a3c5e9e2a6de27f57d40720cf3caa044.png" alt="knight's move 1"><img src="https://habrastorage.org/getpro/geektimes/post_images/b30/477/955/b3047795519e369386b6d4c98582310f.png" alt="knight's move 2"><img src="https://habrastorage.org/getpro/geektimes/post_images/8aa/d2b/728/8aad2b72884640ec4fe9469efa89088d.png" alt="knight 3"><br><br>  Elephant move: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/af8/447/b26/af8447b26f2c45bd93595887f84f4a65.png" alt="elephant stroke 1"><img src="https://habrastorage.org/getpro/geektimes/post_images/cdf/b7b/735/cdfb7b7359a3e69f93aa8b8b67651206.png" alt="elephant stroke 2"><br><br>  King move: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/689/946/f2e/689946f2eb8e8d5eac9d0cc8d2a3834b.png" alt="move king"><br><br><h2>  Mate in one and a half turn </h2><br>  The next stage is to reverse the move of black.  With this algorithm, I was carrying the longest, a lot of mistakes were made before everything worked correctly. <br><br>  At first glance, everything is similar to the previous version: for each position from the ‚Äúwhite line‚Äù, it is necessary to sort through all possible moves of the black king.  And adding all the found combinations to the ‚Äúblack line‚Äù - this is a mate in one and a half moves, from which it will be possible to do the reverse move for White again - there will be mate in two moves - and so continue until all options are reviewed. <br><br>  That was the mistake.  With any possible move by black, a ‚Äúcooperative‚Äù mate is obtained in one and a half moves, and in fact the king will not necessarily go under the mate.  Dmitry Grin, who attended all of my webinars to create this program, pointed me to this error, for which we thank him separately. <br><br>  The correct algorithm is as follows: for each position N, after the black king has reversed, one must go through all his possible direct moves to make sure that all of them lead to familiar positions from the ‚Äúwhite box‚Äù, that is, lead to the mat.  And only after this, the N position can be added to the ‚Äúblack queue‚Äù.  And if from position N the black king can ‚Äúslip away‚Äù, then this option is skipped.  She will meet on subsequent iterations, when there will be more familiar positions. <br><br>  This is what this part of the algorithm looks like: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  " "   while (whiteQueue.Count &gt; 0) { //   N  " " WhitesMove white = whiteQueue.Dequeue(); Combo whiteFigures = white.combo; //   N       foreach (BlacksMove black in AllBlackBackMoves(white)) { bool solved = true; //       foreach (Coord blackKing in AllKingMoves(black.combo.blackKing)) { whiteFigures.blackKing = blackKing; //    if (isCheck(whiteFigures)) //     continue; if (box.Exists(whiteFigures)) //    continue; solved = false; //    "" break; } //        //     " " if (solved) //    " " blackQueue.Enqueue(black); } }</span></span></code> </pre><br>  A total of 156 ‚ÄúOne and a Half Turn Mat‚Äù combinations were found. <br><br><h2>  Iteration of semi-moves </h2><br>  The described algorithms for creating semi-moves must be looped.  From the ‚Äúblack line‚Äù we form a ‚Äúwhite line‚Äù, and then vice versa - from the ‚Äúwhite‚Äù line we form a ‚Äúblack‚Äù.  And so on until all new positions are exhausted.  The ‚Äúwhite box‚Äù is filled at the stage of the formation of the ‚Äúwhite line‚Äù, since it places the positions in which the white move. <br><br>  The finished algorithm went through all the options for about 12 minutes and stopped at 33 moves.  That is the maximum number of moves needed to mate the black king with a knight and an elephant from any position. <br><br>  By the way, there were not so many such ‚Äúmost difficult‚Äù positions, only 156, here‚Äôs one of them: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/af4/481/e7c/af4481e7cfe9f5d9e5787d4f287238f6.png" alt="Mate in 33 moves"><br><br><h2>  Mata will not be! </h2><br>  There are quite a few positions in which even after White‚Äôs move, the black king can eat a horse or an elephant and get a draw.  There are also stalemate options.  Here are some of the most interesting positions. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b87/90d/11f/b8790d11ff993e53cb6620167448e7fb.png" alt="No mata"><img src="https://habrastorage.org/getpro/geektimes/post_images/885/786/cad/885786cad2d99e49c3d176a83217bda4.png" alt="No mata"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/09c/f2c/cf2/09cf2ccf2d1855e834a1e2e38e0205e2.png" alt="No mata"><img src="https://habrastorage.org/getpro/geektimes/post_images/6ef/659/f74/6ef659f744134d6e4c993c56dd71a213.png" alt="No mata"><br><br><h2>  How to store the solution database </h2><br>  How to store the found solution database? <br>  The easiest and wrong way is to use serialization.  The serialized four-dimensional array of the structure took 1.7 gigabytes (!) On the disk.  The serialization process lasted about six minutes, it took about the same for deserialization. <br><br>  This option, of course, does not fit.  In addition, in practice there is no need to use the entire four-dimensional array.  For a specific position, only one entry is needed. <br><br>  Eureka!  To save space, you can still get rid of storing the coordinates of the figures for each combination.  When we have a four-dimensional array, the position of each piece on the board is uniquely determined by its index in the array. <br><br>  It was decided to store the entire database of solutions in a single file - as a linear scan of a four-dimensional array.  For any possible position, an address is calculated at which the correct answer is recorded. <br><br>  How to compactly write down the answer we need?  The position of the figures is not necessary to store, so there are only three numbers left - how many moves to the mat, what to go and where to go.  That is exactly what determines the correct move for White. <br><br>  6 bits  How many moves to the mat is an integer from 0 to 33. <br>  2 bits.  Which figure walks - three possible options, a king, an elephant or a horse. <br>  6 bits  Where the figure goes - the field index on the board is from 0 to 63. <br><br>  This means that two bytes are enough for each solution record: <br>  1 byte - how many moves to the mat, or 0 if the position is unfamiliar. <br>  2 bytes - FFNNNNNN <br>  FF - the number of the figure to walk (1 is the king, 2 is the elephant, 3 is the horse) <br>  NNNNNN - cell coordinate - where to go (from 0 to 63). <br><br>  So, the solution database file is 64 * 32 * 64 * 64 words = exactly 16 megabytes.  The placement of the figures is given by the coordinates of each word, in the first byte - the number of moves to the mat (or 0 if there is no solution), the correct move is stored in the second byte. <br><br>  It would be possible to further reduce the file size by half, if you do not store the number of moves to the mat, but it will not be interesting to play. <br><br><h2>  Coordinates of the black white elephant </h2><br>  It's time to pay for optimization.  It is necessary to implement the coordinate recalculation algorithm for combinations with the ‚Äúblack and white‚Äù elephant. <br><br>  This was done as follows.  If the elephant's coordinate falls on a black field, then the coordinates of all the pieces on the board must be "turned over."  In this case, the Y coordinate remains unchanged, and X changes to 7-X.  A visual demonstration of the flipping of coordinates, see the figure. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/1cb/019/1f7/1cb0191f7642a5b963437278ed9ca783.png" alt="Coordinate flip"><br><br>  If the elephant is on a white cage, then first you need to "flip" the coordinates of all the figures.  Then search for a position in the database of decisions.  And once again ‚Äúturn‚Äù the coordinate of the correct move read from there. <br><br><h2>  Solution Base Visualization </h2><br>  So, the Problem is solved! <br>  Solution database is created. <br>  But how to demonstrate it? <br><br>  The most obvious way is to use web technologies so that you can simply give a link to a working example.  The ‚Äú <a href="http://www.videosharp.info/video/chess">Nano-chess</a> ‚Äù photo course was already created on my ‚Äúprogrammer‚Äôs formula‚Äù, where an interactive chess board was created for the game together with no rules using the HTML, CSS, JavaScript and PHP technologies.  This script was taken as a basis. <br><br>  I left only four figures, removed the possibility of taking, added PHP functions for reading the correct moves from the decision base and ‚Äúbreathed life‚Äù through JavaScript. <br><br>  On <a href="http://www.videosharp.info/chess/">www.videosharp.info/chess,</a> you can experiment with the decision base. <br> <a href="http://www.videosharp.info/chess/"><img src="https://habrastorage.org/getpro/geektimes/post_images/9fb/3ce/7bc/9fb3ce7bc6645d2c96536c2a19c663a2.png" alt="Interactive mat horse and elephant"></a> <br>  For each position, the moves are calculated for both white and black. <br>  For whites - the best move that leads to the mate. <br>  For blacks - how many moves to mate on any possible move. <br><br>  With the mouse you can make any movements of the figures, not necessarily according to the rules. <br>  The script will calculate the option for any position, or write that there are no options. <br><br>  It is interesting to play, performing the proposed moves or moving the pieces at their discretion. <br><br><h2>  Conclusion </h2><br>  A great, interesting work was done on solving a chess problem. <br>  If you want to repeat this path - you can <a href="http://www.videosharp.info/video/biknight">watch videos</a> on the creation of this program from scratch to the result with detailed explanations and independent tasks. <br><br>  Good luck! </div><p>Source: <a href="https://habr.com/ru/post/396453/">https://habr.com/ru/post/396453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../396441/index.html">Because of the lack of confidence in scientists, Italy may lose its olive trees.</a></li>
<li><a href="../396443/index.html">"The Elders of Zion" became another reason for blocking Wikipedia</a></li>
<li><a href="../396445/index.html">Dolly lamb clones help prove the safety of SCNT-cloning</a></li>
<li><a href="../396447/index.html">Prices for popular electronics of the past in today's money: 1970s</a></li>
<li><a href="../396451/index.html">Crimes and penalties of the past month</a></li>
<li><a href="../396455/index.html">Computer facilities of the CMEA countries. Part Two: Czechoslovakia</a></li>
<li><a href="../396457/index.html">APEIGAMING IN NUMBERS. Month after launch (video)</a></li>
<li><a href="../396459/index.html">Review of the gaming system unit ASUS ROG GT51CA</a></li>
<li><a href="../396461/index.html">Blockchain Security Technologies</a></li>
<li><a href="../396463/index.html">Construction of the communication line Kamchatka - Sakhalin - Magadan. Cable Innovator Excursion - Ship Layer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>