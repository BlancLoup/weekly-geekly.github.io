<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Jet manifest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In recent years, application requirements have changed significantly. Dozens of servers, a response time of a few seconds, offline service that could ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Jet manifest</h1><div class="post__text post__text-html js-mediator-article">  In recent years, application requirements have changed significantly.  Dozens of servers, a response time of a few seconds, offline service that could last for hours, gigabytes of data ‚Äî such were large applications just a few years ago.  Today, applications work on absolutely everything, from simple mobile phones to clusters of thousands of processors.  Users expect millisecond response time and one hundred percent uptime, while data has grown to petabytes. <br><br>  Initially, this niche was occupied by large innovative Internet companies like Google or Twitter, but such application requirements began to emerge in many areas of the industry.  Financial and telecommunications companies were the first to introduce new practices to meet new requirements, and now the rest are catching up. <br><br>  New requirements require new technologies.  Previous decisions focused on managed servers and containers.  Scaling is achieved through the purchase of steeper servers and the use of multithreading.  To add new servers we had to use complex, inefficient and expensive proprietary solutions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, progress does not stand still.  The application architecture has evolved according to changing requirements.  Applications developed on the basis of this architecture are called <i>Reactive Applications</i> .  This architecture allows programmers to create <i>event-oriented, scalable, fault-tolerant and responsive</i> applications ‚Äî applications that run in real time and provide a good response time based on a scalable and fault-tolerant stack that can easily be deployed on multicore and cloud architectures.  These features are critical to reactivity. <br><br><a name="habracut"></a><br><br><h2>  Reactive applications </h2><br>  The Merriam Webster dictionary defines reactive as <i>‚Äúready to respond to external events,‚Äù</i> which means that components are always active and always ready to receive messages.  This definition reveals the essence of reactive applications, focusing on systems that: <br><br><ul><li>  <em><font color="#445DE9">react to events</font></em> <br>  Focusing on events means having the following qualities </li><li>  <em><font color="#445DE9">react to increasing load</font></em> <br>  Focus on scalability, competitive access to shared resources is minimized </li><li>  <em><font color="#445DE9">react to failures</font></em> <br>  Fault-tolerant systems are built with the ability to recover at all levels. </li><li>  <em><font color="#445DE9">react to users</font></em> <br>  Guaranteed response time independent of load </li></ul><br><br>  Each of these characteristics is essential for a reactive application.  They all depend on each other, but not as tiers of standard multi-tier architecture.  On the contrary, they describe the properties applicable to the whole technology stack: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb4/8f5/ff5/bb48f5ff51683dc6bae66eae41c714ca.png" alt="4 whales reactivity"><br><br>  Next, we take a closer look at each of these four characteristics and see how they relate to each other. <br><br><h2>  Event oriented </h2><br><h3>  Why is it important </h3><br>  Applications that use the asynchronous model provide much better <i>connectivity</i> than applications based on purely synchronous calls.  The sender and receiver can be implemented without looking at the details of how events propagate in the system, which allows interfaces to focus on the content of the transmission.  This leads to an implementation that is easier to expand, change and maintain, provides greater flexibility and reduces the cost of support. <br><br>  Since recipients of asynchronous interaction are inactive until they receive a message, this approach can allow efficient use of resources, making it possible for a large number of recipients to work in the same hardware stream.  Thus, a non-blocking application may have <i>lower latency</i> and <i>greater throughput</i> compared to a traditional application based on blocking synchronization and communication primitives.  This leads to a decrease in the cost of operations, an increase in utilization of processor resources and makes the end users happier. <br><br><h3>  Key building blocks </h3><br>  In an event-oriented application, components interact with each other by sending and receiving <i>messages</i> ‚Äî discrete pieces of information that describe the facts.  These messages are sent and received in asynchronous and non-blocking mode.  Event-oriented systems are more prone to <i>push-</i> models, rather than <i>pull</i> or <i>poll</i> .  Those.  they push data to their customers when data becomes available, instead of wasting resources, constantly querying or waiting for data. <br><br><ul><li>  Asynchronous messaging means that an application, by its nature, has a high degree of competition and can work without changes on a multi-core architecture.  Any CPU core can process any message, which provides greater parallelization capabilities. </li><li>  Non-blocking means the ability to continue to work so that the application is <i>responsive</i> all the time, even in conditions of failure or peak load.  To do this, all the resources needed to ensure responsiveness, such as CPU, memory and network, should not be monopolized.  This will lead to lower latency, greater bandwidth and better <i>scalability</i> . </li></ul><br><br>  Traditional server architectures use a shared state of change and blocking operations on a single thread.  This makes it difficult to scale the system.  The public changeable state requires synchronization, which introduces complexity and non-determinism, making the code difficult to understand and maintain.  Switching the stream to sleep mode consumes limited resources, and waking up is expensive. <br><br>  By separating the generation of events and their processing, we allow the platform to take care of the details of synchronization and dispatching events between threads, while we ourselves concentrate on higher-level abstractions and business logic.  We think about where and where events are sent from, and how the components interact with each other, instead of digging with low-level primitives like threads or locks. <br><br>  Event-oriented systems provide weak connectivity between components and subsystems.  Such connectivity, as we will see later, is one of the necessary conditions for scalability and fault tolerance.  Without complex and strong dependencies between components, system expansion requires minimal effort. <br><br>  When an application requires high performance and good scalability, it is difficult to foresee where bottlenecks can occur.  Therefore, it is very important that the entire solution be asynchronous and non-blocking.  For a typical application, this means that the architecture must be fully event-oriented, starting with user requests via a graphical interface (browser, REST, etc.) and processing requests in the web layer and ending with services, a cache, and a database.  If at least one of these layers does not meet this requirement ‚Äî it will make blocking requests to the database, use a public changeable state, cause expensive synchronous operations ‚Äî then the entire stack will stall and users will suffer due to increased delays and dropped scalability. <br><br>  The application must be <i>reactive from top to bottom</i> . <br><br>  The need to eliminate the weak link in the chain is well illustrated <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2590%25D0%25BC%25D0%25B4%25D0%25B0%25D0%25BB%25D0%25B0">by the law of Amdal</a> , which according to Wikipedia says: <br><br>  <em><font color="#445DE9">Acceleration of the program due to its parallelization is limited to the sequential part of the program.</font></em>  <em><font color="#445DE9">For example, if 95% of the volume of calculations can be parallelized, then the theoretical maximum acceleration cannot exceed 20, regardless of the number of processors used.</font></em> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6d/f8e/ce5/b6df8ece5a772f02cc978a3f8993cc7a.png" alt="Illustration of Amdal's Law"><br><br><h2>  Scalability </h2><br><h3>  Why is it important </h3><br>  The word scalable is defined by the Merriam Webster dictionary as <i>‚Äúable to easily expand or upgrade</i> . <i>‚Äù</i>  Scalable application can be expanded to the required scale.  This is achieved by giving the application elasticity, a property that allows the system to stretch or shrink (add or remove knots) on demand.  In addition, this architecture makes it possible to expand or contract (deploy on more or fewer processors) without the need to redesign or rewrite the application.  Elasticity minimizes the cost of operating in the cloud, while we only pay for what we really use. <br><br>  Scalability also helps to manage risk: too little equipment can lead to dissatisfaction and loss of customers, and too much will simply be inactive (together with the staff) and lead to unnecessary costs.  A more scalable application reduces the risk of a situation when equipment is available, but an application cannot use it: in the next 10 years we will have processors with hundreds, if not thousands of hardware threads, and using their potential requires scalability at the microscopic level. <br><br><h3>  Key building blocks </h3><br>  An event-based system based on asynchronous messaging is the foundation of scalability.  The weak connectivity and location-independent independence of components and subsystems allow the system to be deployed on multiple nodes, remaining within the same software model with the same semantics.  When adding new nodes, the system capacity increases.  In terms of implementation, there should be no difference between deploying a system to more cores or more nodes in a cluster or data center.  Application topology becomes a problem with configuration and / or adaptive runtime algorithms that monitor system load.  This is what we call <a href="http://en.wikipedia.org/wiki/Location_transparency">location transparency</a> . <br><br>  It is important to understand that the goal ‚Äî not to invent transparent distributed computing, distributed objects, or RPC communications ‚Äî was already attempted before and this idea failed.  Instead, we should <i>cover the network</i> , presenting it directly in the program model through the mechanism of asynchronous messages.  True scalability naturally relies on distributed computing and their inter-node interaction, which means network traversal, which is inherently <a href="http://aphyr.com/posts/288-the-network-is-reliable">unreliable</a> .  Therefore, it is important to take into account the limitations, compromises and scenarios of exceptional situations clearly in the program model instead of hiding them behind a screen of leaky abstractions that they are supposedly trying to "simplify" things.  As a result, it is equally important to provide yourself with software tools that contain building blocks for solving typical problems that may arise in a distributed environment - such as mechanisms for achieving consensus or messaging interfaces that have a high level of reliability. <br><br><h2>  fault tolerance </h2><br><h3>  Why is it important </h3><br>  Application failure is one of the most destructive things that can happen to a business.  Usually this leads to the fact that the work of the service simply stops, leaving a gap in the flow of profits.  In the long run, this can lead to customer dissatisfaction and bad reputation, which will harm the business even more seriously.  Surprisingly, application resiliency requirements are universally ignored or solved by ad-hoc technicians.  This often means that the problem is considered at the wrong level of detail, using too inaccurate and coarse tools.  A common solution is to use application server clustering with disaster recovery during operation.  Unfortunately, such ready-made solutions are extremely expensive and, moreover, dangerous - they can potentially ‚Äúdrop‚Äù the entire cluster in a cascading manner.  The reason is that the problem of managing failures is solved on a map of too small scale, although it should be worked out in detail at the level of interaction of smaller components. <br><br>  In a reactive application, fault tolerance is not left ‚Äúfor later‚Äù, but is part of the architecture from the very beginning.  Attitude to failures as first-class objects in the program model will facilitate the task of responding to and managing them, which will make the application tolerant to failures and allow the system to ‚Äúheal‚Äù and ‚Äúrepair‚Äù itself in the process.  Traditional methods of handling exceptional situations cannot achieve this, because problems are not solved at those levels ‚Äî we either handle exceptions right where they occur, or we initiate the recovery procedure for the entire application. <br><br><h3>  Key building blocks </h3><br>  To manage failures, we need a way to isolate them so that they do not extend to other workable components, and to monitor them from a safe place outside the context in which the failures can occur.  One way that comes to mind is the bulkheads that divide the system into compartments in such a way that if one of the compartments is flooded (fails), it does not affect the other compartments.  This prevents the classic cascading glitch problem and allows you to solve problems in isolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33b/c10/364/33bc1036482430ecda8c369638a991f4.png" alt="Compartments and bulkheads"><br><br>  An event-oriented model that provides scalability also provides the necessary primitives to solve the fault tolerance problem.  Weak coherence in the event-oriented model provides us with completely isolated components, in which failures are encapsulated into messages along with the necessary details and forwarded to other components, which in turn analyze the errors and decide how to react to them. <br><br>  This approach creates a system in which: <br><ul><li>  business logic remains clean, separate from error handling; </li><li>  failures are modeled explicitly so that partitioning, observation, control, and configuration are set declaratively; </li><li>  the system can ‚Äúheal‚Äù itself and recover automatically. </li></ul><br>  It is best if the compartments are organized in a hierarchical manner, like a large corporation, where problems are raised to a level that has enough power to take action. <br><br>  The power of this model is that it is purely event-oriented - it is based on reactive components and asynchronous events, and therefore has <i>location-based transparency</i> .  In practice, this means that its semantics does not depend on whether it works on a local server or in a distributed environment. <br><br><h2>  Responsiveness </h2><br><h3>  Why is it important </h3><br>  Responsive is defined by the Merriam-Webster dictionary as <i>‚Äúresponding quickly or responding appropriately.‚Äù</i>  Note that in the following we will use this word in its general sense and will not be confused with <a href="http://en.wikipedia.org/wiki/Responsive_Web_Design">responsive web design</a> with its CSS <a href="http://en.wikipedia.org/wiki/Media_queries">media queries</a> and <a href="http://en.wikipedia.org/wiki/Progressive_enhancement">progressive improvements</a> . <br><br>  Responsive applications are real-time applications, they are attractive, rich in functionality and provide shared access.  An open and continuous dialogue is maintained with clients through responsiveness and interactivity.  This makes the work of clients more productive, creates a sense of constancy and readiness to solve problems and complete tasks at any time.  One such example is Google Docs, which supports co-editing in real time, which allows users to directly see each other's edits. <br><br>  Applications must respond to events in a timely manner, even in the event of a failure.  If an application does not respond within a reasonable period of time (also called latency), then in fact it is not available and therefore cannot be considered <i>fault tolerant</i> . <br><br>  The inability to remain in a rigid real-time framework for some applications, such as those related to weapons or medicine, is tantamount to a complete system failure.  Not all applications have such strict requirements.  Many applications quickly become useless if they stop meeting temporary requirements, for example, an application performing trading operations may lose the current transaction if it does not have time to respond in time. <br><br>  More common applications, such as online shopping retailers, lose profit if response time increases.  Users interact more intensively with <i>responsive</i> applications, which leads to large volumes of purchases. <br><br><h3>  Key building blocks </h3><br>  Reactive applications use observable models, event flows, and stateful clients. <br><br>  Observed models allow other systems to receive events when their state changes.  This provides real-time communication between users and systems.  For example, when several users work simultaneously on the same model, changes can reactively synchronize between them, eliminating the need to lock the model. <br><br>  Flows of events form the basic abstraction on which such connections are built.  By keeping them reactive, we avoid blocking and allow transformations and communications to be asynchronous and non-blocking. <br><br>  Reactive applications must have knowledge of the <a href="http://ru.wikipedia.org/wiki/%25C2%25ABO%25C2%25BB_%25D0%25B1%25D0%25BE%25D0%25BB%25D1%258C%25D1%2588%25D0%25BE%25D0%25B5_%25D0%25B8_%25C2%25ABo%25C2%25BB_%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B5">order of the algorithms</a> to be sure that the response time to events does not exceed O (1) or, at a minimum, O (log n) regardless of the load.  A scaling factor may be included, but it should not depend on the number of customers, sessions, products or transactions. <br><br>  Here are some strategies that will help keep latency independent of the load profile: <br><ul><li>  In the case of explosive traffic, reactive applications must absorb the costs of expensive operations, such as I / O or concurrent data exchange, applying batching with understanding and taking into account the specifics of the underlying resources. </li><li>  Queues should be limited taking into account the flow rate, the length of the queues for these requirements at the response time should be determined according to the <a href="http://en.wikipedia.org/wiki/Little%2527s_law">law of Little</a> . </li><li>  Systems must be in a state of constant monitoring and have an adequate margin of safety. </li><li>  In the event of failures, <a href="http://en.wikipedia.org/wiki/Circuit_breaker_design_pattern">circuit breakers</a> are activated and replacement processing strategies are triggered. </li></ul><br><br>  As an example, consider a responsive web application with ‚Äúrich‚Äù clients (browser, mobile application) to provide the user with a high-quality interaction experience.  This application executes the logic and stores the state on the client side, in which the observed models provide a mechanism for updating the user interface when data changes in real time.  Technologies like WebSockets or Server-Sent Events allow the user interface to connect directly to the event stream, so that the entire system becomes event-oriented, starting with the back-end layer and ending with the client.  This allows reactive applications to push events to the browser and mobile applications through asynchronous and non-blocking data transmission, while maintaining scalability and fault tolerance. <br><br>  Now it becomes clear how the four ‚Äúwhales‚Äù of reactivity: <i>focus on events</i> , <i>scalability</i> , <i>fault tolerance</i> and <i>responsiveness</i> - are connected with each other and form a single whole: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f01/9d0/d8b/f019d0d8b3858d471df05b1986666166.png" alt="4 whales reactivity"><br><br><h2>  Conclusion </h2><br>  Reactive applications are a balanced approach to solving current problems in the development of software systems.  They are built on an <i>event-driven</i> and messaging framework and provide tools for <i>scalability</i> and <i>fault tolerance</i> .  On top of this, they support rich and <i>responsive</i> user interaction interfaces.  We expect that systems, the number of which is growing rapidly, will follow this manifesto in the near future. <br><br><h2>  <a href="http://www.reactivemanifesto.org/">Subscribe under manifest</a> </h2><br><br></div><p>Source: <a href="https://habr.com/ru/post/195562/">https://habr.com/ru/post/195562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195542/index.html">Erlang for the little ones. Chapter 1: Data Types, Variables, Lists, and Tuples</a></li>
<li><a href="../195548/index.html">The impact of the Web application architecture on investment volumes, product life cycle and user positive emotions</a></li>
<li><a href="../195550/index.html">Facebook added the ability to edit posts in the feed</a></li>
<li><a href="../195552/index.html">8+ in 1: how I wanted to attract attention</a></li>
<li><a href="../195558/index.html">Getting ready for CCNA Security (IINS 554)</a></li>
<li><a href="../195564/index.html">The third version of the typograph Muravyov</a></li>
<li><a href="../195566/index.html">Valve's latest announcement for the week - new game controllers</a></li>
<li><a href="../195568/index.html">Make the world better (karma policy)</a></li>
<li><a href="../195572/index.html">Usability: Value swapping error or worse than the built-in Android dialer</a></li>
<li><a href="../195574/index.html">Go: multithreading and parallelism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>