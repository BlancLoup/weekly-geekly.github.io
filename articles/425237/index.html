<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Time measurement with nanosecond precision</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of months ago a historical moment came for me. I no longer have enough standard operating system tools for measuring time. It took time to me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Time measurement with nanosecond precision</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="image"><br><br>  A couple of months ago a historical moment came for me.  I no longer have enough standard operating system tools for measuring time.  It took time to measure with nanosecond accuracy and with nanosecond overhead. <br><br>  I decided to write a library that would solve this problem.  At first glance it seemed that there was nothing much to do.  But upon closer examination, as always, it turned out that there were many interesting problems that had to be dealt with.  In this article, I will talk about the problems and how they were solved. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since you can measure a lot of different types of time on a computer, I‚Äôll just clarify that here we‚Äôll talk about "stopwatch time."  Or wall-clock time.  It is real time, elapsed time, etc.  That is, a simple ‚Äúhuman‚Äù time, which we mark at the beginning of the task and stop at the end. <br><a name="habracut"></a><br><h3>  Microsecond - almost eternity </h3><br>  Developers of high-performance systems over the past few years have become accustomed to the microsecond time scale.  For microseconds, you can read data from the NVMe disk.  For microseconds, data can be sent over the network.  Not for everyone, of course, but for the InifiniBand-network - easily. <br><br>  At the same time, the microsecond also has a structure.  A complete I / O stack consists of several software and hardware components.  The delays introduced by some of them lie at the sub-microsecond level. <br><br>  Microsecond accuracy is no longer sufficient to measure delays of this magnitude.  However, not only accuracy is important, but also the overhead of measuring time.  Linux system call clock_gettime () returns time with nanosecond precision.  On a machine that is right here at my fingertips (Intel¬Æ Xeon¬Æ CPU E5-2630 v2 @ 2.60GHz), this call fulfills in about 120 ns.  Very good figure.  In addition, clock_gettime () works quite predictably.  This allows you to take into account the overhead of his call and in fact to make measurements with an accuracy of the order of tens of nanoseconds.  However, we now turn our attention to this.  To measure the time interval, you need to make two such calls: at the beginning and at the end.  Those.  spend 240 ns.  If densely spaced intervals of the order of 1‚Äì10 Œºs are measured, in some such cases the measurement process itself will significantly distort the observed process. <br><br>  I started this section with how IO-stack accelerated in recent years.  This is new, but not the only reason to want to measure time quickly and accurately.  Such a need has always been.  For example, there was always a code that I wanted to speed up at least 1 microprocessor clock.  Or another example from the original Specter's acclaimed vulnerability: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="image"><br><br>  Here, in lines 72-74, the execution time of a single memory access operation is measured.  True, Specter is not interested in nanoseconds.  Time can be measured in "parrots".  To parrots and seconds we will return. <br><br><h3>  Time-stamp counter </h3><br>  The key to fast and accurate time measurement is a special microprocessor counter.  The value of this counter is usually stored in a separate register and is usually ‚Äî but not always ‚Äî accessible from user space.  On different architectures, the counter is called differently: <br><br><ol><li>  time-stamp counter on x86 </li><li>  time base register on PowerPC </li><li>  interval time counter on Itanium </li><li>  etc. </li></ol><br>  Below, I will use the name ‚Äútime-stamp counter‚Äù or TSC everywhere, although in reality I will mean any such counter, regardless of architecture. <br><br>  Reading the value of a TSC is usually ‚Äî but again not always ‚Äî possible with a single instruction.  Here is an example for x86.  Strictly speaking, this is not a pure assembler instruction, but a GNU inline assembler: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  The "rdtsc" instruction places two 32-bit halves of the TSC register in the eax and edx registers.  Of these, you can "glue" a single 64-bit value. <br><br>  Once again, this (and similar) instructions in most cases can be called directly from user space.  No system calls.  Minimum overhead. <br><br>  What needs to be done now to measure time? <br><br><ol><li>  Execute one such instruction at the beginning of the period of interest.  Remember counter value </li><li>  Execute one such instruction at the end.  We believe that the value of the counter from the first instruction to the second will increase.  Otherwise, why is it needed?  Remember the second value </li><li>  We consider the difference between the two saved values.  This is our time. </li></ol><br>  It looks simple, but ... <br><br>  The time measured by the described procedure is expressed in "parrots".  It is not in seconds.  But sometimes parrots are exactly what you need.  There are situations when it is not the absolute values ‚Äã‚Äãof time intervals that are important, but how the various intervals correlate with each other.  The above Specter example demonstrates exactly this situation.  The duration of each individual memory access does not matter.  It is only important that calls to one address will be executed much faster than to others (depending on whether the data is stored in the cache or main memory). <br><br>  What if no parrots are needed, but seconds / microseconds / nanoseconds, etc.?  There are two fundamentally different cases: <br><br><ol><li>  Nanoseconds are needed, but then.  That is, it is permissible to make all the measurements in parrots first and save them somewhere for further processing (for example, in memory).  And only after the measurements have been completed, slowly converting the collected parrots into seconds. </li><li>  Nanoseconds are needed on the fly.  For example, your measurement process has some kind of ‚Äúconsumer‚Äù that you do not control and who expects time in the ‚Äúhuman‚Äù format </li></ol><br>  The first case is simple, the second one requires resourcefulness.  Conversion should be as efficient as possible.  If it consumes a lot of resources, it can greatly distort the measurement process.  We'll talk about effective conversion below.  Here we have identified this problem so far and turn to another. <br><br>  Time-stamp counter-s are not as simple as we would like.  On some architectures: <br><br><ol><li>  It is not guaranteed that the TSC is updated with high frequency.  If a TSC is updated, say, once a microsecond, then it will not be possible to fix nanoseconds with its help </li><li>  the frequency with which the TSC is updated may vary over time </li><li>  on different CPUs present in the system, the TSC can be updated with different frequency </li><li>  there may be a shift between TSC ticking on different CPUs. </li></ol><br>  Here is an example illustrating the last problem.  Suppose we have a system with two CPUs: CPU1 and CPU2.  Suppose that the TSC on the first CPU lags behind the second by the number of ticks, which is equivalent to 5 seconds.  Suppose further that the system runs a thread that measures the computation time, which he himself does.  To do this, the thread first reads the TSC value, then does the calculation, and then reads the second TSC value.  If during all its life the thread remains on only one CPU - on any - then there are no problems.  But what if the thread started on CPU1, measured the first TSC value there, and then in the middle of the calculations was moved by the operating system to CPU2, where it read the second TSC value?  In this case, the calculations will seem 5 seconds longer than they actually are. <br><br>  Due to the above problems, TSC cannot serve as a reliable source of time on some systems.  However, on other systems ‚Äúsuffering‚Äù from the same problems, TSC can still be used.  This is possible thanks to special architectural features: <br><br><ol><li>  hardware can generate a special interrupt each time the frequency at which the TSC is updated is changed.  In this case, the equipment also provides the ability to find out the current frequency.  Alternatively, the TSC update rate can be brought under the control of the operating system (see ‚ÄúPower ISA Version 2.06 Revision B, Book II, Chapter 5‚Äù) </li><li>  hardware along with the TSC value can also provide the ID of the CPU on which this value is read (see Intel's RDTSCP instruction, "Intel 64 and IA-32 Architects Software Developer's Manual," Volume 2) </li><li>  on some systems, you can programmatically adjust the TSC value for each CPU (see the Intel WRMSR instruction and the register IA32_TIME_STAMP_COUNTER, "Intel 64 and IA-32 Architectures Software Developer's Manual, Volume 3) </li></ol><br>  In general, the topic of how time counters are implemented on different architectures is fascinating and extensive.  If you have time and interest, I recommend to dive.  Among other things, you will find out, for example, that some systems allow you to programmatically find out if a TSC can serve as a reliable source of time. <br><br>  So, there are many architectural implementations of TSC, each with its own characteristics.  But it is interesting that a general trend has been established throughout this zoo.  <b>Modern hardware and operating systems strive to ensure that</b> : <br><br><ol><li>  TSC ticks at the same frequency on every CPU in the system </li><li>  this frequency does not change in time </li><li>  between TSC ticking on different CPUs, there is no shift </li></ol><br>  When designing my library, I decided to proceed from this premise, and not from the vinaigrette of hardware implementations. <br><br><h3>  Library </h3><br>  I did not begin to lay on the hardware chips heaps of different architectures.  Instead, I decided that my library would be focused on the modern trend.  She has a purely empirical focus: <br><br><ol><li>  it allows you to experimentally test the reliability of TSC as a source of time </li><li>  also allows you to experimentally calculate the parameters necessary for the rapid conversion of "ticks" in nanoseconds </li><li>  in a natural way, the library provides convenient interfaces for reading TSC and converting ticks to nanoseconds on the fly </li></ol><br>  <a href="https://github.com/AndreyNevolin/wtmlib">Library code is available here.</a>  It will be compiled and executed only on Linux. <br><br>  In the code you can see the details of the implementation of all methods, which will be discussed further. <br><br><h3>  TSC reliability rating </h3><br>  The library provides an interface that returns two evaluations: <br><br><ol><li>  maximum offset between counters belonging to different CPUs.  Only CPUs available to the process are considered.  For example, if there are three CPUs available to the process, and at the same time TSC on these CPUs are 50, 150, 20, then the maximum shift will be 150-20 = 130.  Naturally, experimentally, the library will not be able to get a real maximum shift, but it will give an estimate in which this shift will fit.  What to do with the assessment next?  How to use?  This is already solved by client code.  But the meaning is about the following.  The maximum shift is the maximum value by which the measurement that the client code makes may be distorted.  For example, in our example with three CPUs, the client code began to measure time on CPU3 (where TSC was 20), and finished on CPU2 (where TSC was 150).  It turns out that in the measured interval, extra 130 ticks will creep in.  And never again.  The difference between CPU1 and CPU2 would be only 100 ticks.  Having a rating of 130 ticks (in fact, it will be much more conservative), the client can decide whether he is satisfied with this magnitude of distortion or not. </li><li>  Do TSC values ‚Äã‚Äãincrease in series on the same or different CPUs?  Here the idea is as follows.  Suppose we have several CPUs.  Suppose their watches are synchronized and ticking with the same frequency.  Then, if you first measure the time on one CPU, and then measure it again ‚Äî already on any of the available CPUs ‚Äî then the second digit must be greater than the first. <br><br>  I will call this estimate below the TSC monotony estimate. <br></li></ol><br>  Now let's see how to get the first grade: <br><br><ol><li>  one of the available process CPU is declared "basic" </li><li>  then all the other CPUs are sorted out, and for each of them a shift is calculated: <code>TSC___CPU ‚Äì TSC___CPU</code> .  This is done as follows: <br><ul><li>  a) take three successively (one after the other!) measured values: <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Here, current indicates that the value was measured on the current CPU, and base on the base </li><li>  b) <code>TSC___CPU ‚Äì TSC___CPU</code> must lie in the interval <code>[TSC_current ‚Äì TSC_base_2, TSC_current ‚Äì TSC_base_1]</code> .  This is on the assumption that TSC ticks with the same frequency on both CPUs. </li><li>  c) steps a) -b) are repeated several times.  Calculates the intersection of all intervals obtained in step b).  The resulting interval is taken as the estimate of the shift <code>TSC___CPU ‚Äì TSC___CPU</code> </li></ul><br></li><li>  After the estimated shift for each CPU relative to the base is obtained, it is easy to get an estimate of the maximum shift between all available CPUs: <br><ul><li>  a) calculate the minimum interval, which includes all the resulting intervals, obtained in step 2 </li><li>  b) the width of this interval is taken as an estimate of the maximum shift between TSC ticking on different CPUs. </li></ul><br></li></ol><br>  To assess the monotony in the library, the following algorithm is implemented: <br><br><ol><li>  Suppose a process is available N CPU </li><li>  Measure TSC on CPU1 </li><li>  Measure TSC on CPU2 </li><li>  ... </li><li>  Measure TSC on CPUN </li><li>  Measure TSC on CPU1 again </li><li>  Check that the measured values ‚Äã‚Äãmonotonously increase from the first to the last. </li></ol><br>  It is important here that the first and last values ‚Äã‚Äãare measured on the same CPU.  And that's why.  Suppose we have 3 CPUs.  Suppose that the TSC on CPU2 is shifted by +100 ticks relative to the TSC on CPU1.  Also assume that TSC on CPU3 is shifted by +100 ticks relative to TSC on CPU2.  Consider the following chain of events: <br><br><ul><li>  Read TSC on CPU1.  Let the value 10 be obtained </li><li>  2 ticks passed </li><li>  Read TSC on CPU2.  Must be 112 </li><li>  2 ticks passed </li><li>  Read TSC on CPU3.  Must be 214 </li></ul><br>  So far, the clock looks synchronized.  But let's again measure TSC on CPU1: <br><br><ul><li>  2 ticks passed </li><li>  Read TSC on CPU1.  Must be 16 </li></ul><br>  Oops!  Monotony is broken.  It turns out that measuring the first and last values ‚Äã‚Äãon the same CPU allows you to detect more or less large shifts between hours.  The next question, of course: ‚ÄúHow big is the shift?‚Äù The amount of shift that can be detected depends on the time that passes between successive TSC measurements.  In the example above, this is just 2 ticks.  Shifts between clocks greater than 2 ticks will be detected.  Generally speaking, shifts that are less than the time that passes between successive measurements will not be detected.  This means that the tighter the measurements in time are, the better.  The accuracy of both estimates depends on this.  The tighter the measurements are made: <br><br><ul><li>  the lower the maximum shift estimate </li><li>  the more confidence in the monotony evaluation </li></ul><br>  In the next section we will talk about how to make dense measurements.  Here I‚Äôll add that while calculating the TSC reliability ratings, the library does many more simple checks for lice, for example: <br><br><ul><li>  limited verification that TSC on different CPUs is ticking at the same speed </li><li>  check that the counters do change in time, and not just show the same value </li></ul><br><h3>  Two methods for collecting meter values </h3><br>  In the library, I implemented two methods for collecting TSC values: <br><br><ol><li>  <b>Switch between CPUs</b> .  In this method, all the data necessary for assessing the reliability of a TSC is collected by a single stream that ‚Äújumps‚Äù from one CPU to another.  Both algorithms described in the previous section are suitable for this method and are not suitable for the other. <br>  There is no practical use for switching between CPUs.  The method was implemented just for the sake of "play."  The problem of the method is that the time required to drag the thread from one CPU to another is very long.  Accordingly, a lot of time passes between successive measurements of TSC, and the accuracy of the estimates is very low.  For example, a typical estimate for the maximum shift between TSC is obtained in the region of 23,000 ticks. <br><br>  Nevertheless, the method has a couple of advantages: <br><ul><li>  he is absolutely deterministic.  If you need to consistently measure TSC on CPU1, CPU2, CPU3, then we just take and do it: switch to CPU1, read TSC, switch to CPU2, read TSC, and finally, switch to CPU3, read TSC </li><li>  presumably, if the number of CPUs in the system grows very quickly, then the time to switch between them should grow much slower.  Therefore, in theory, apparently, there can be a system - a very large system!  - in which the use of the method will be justified.  But nevertheless it is improbable </li></ul><br></li><li>  <b>Measurements ordered by CAS</b> .  In this method, data is collected in parallel by multiple threads.  On each available CPU, one thread is started.  Measurements made by different threads are ordered in a single sequence using the ‚Äúcompare-and-swap‚Äù operation.  Below is a piece of code that shows how this is done. <br>  The idea of ‚Äã‚Äãthe method is borrowed from <a href="https://github.com/axboe/fio">fio</a> , a popular tool for generating I / O loads. <br><br>  The reliability estimates obtained with the power of this method already look very good.  For example, the estimate of the maximum shift is obtained at the level of several hundred ticks.  A monotony check allows you to catch the desynchronization of clocks within hundreds of ticks. <br><br>  However, the algorithms given in the previous section are not suitable for this method.  For them, it is important that the TSC values ‚Äã‚Äãare measured in a predetermined order.  The method of "measurements ordered by CAS" does not allow this.  Instead, a long sequence of random measurements is first collected, and then the algorithms (already others) attempt to find in this sequence the values ‚Äã‚Äãread on the "suitable" CPUs. <br><br>  I will not give these algorithms here, so as not to abuse your attention.  They can be seen in the code.  There are many comments.  Ideally, these algorithms are the same.  A fundamentally new moment is a test of how statistically typed TSC sequences are statistically ‚Äúqualitative‚Äù.  It is also possible to set the minimum acceptable level of statistical significance for TSC reliability ratings. <br><br>  Theoretically, for VERY large systems, the method of ‚Äúmeasurements ordered by CAS‚Äù can give poor results.  The method requires that processors compete for access to a common memory cell.  If there are a lot of processors, the match can be very tense.  As a result, it will be difficult to create a measurement sequence with good statistical properties.  However, at the moment such a situation seems unlikely. <br></li></ol><br>  I promised some code.  Here is how building the measurements in a single chain with the help of CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  This code is executed on every available CPU.  All threads have access to the shared variable <code>seq_counter</code> .  Before reading the TSC, the stream reads the value of this variable and stores it in the variable <code>seq_num</code> .  Then reads TSC.  Then it tries to atomically increase seq_counter by one, but only if the value of the variable has not changed since it was read.  If the operation is successful, it means that the thread managed to ‚Äústake out‚Äù the sequence number stored in <code>seq_num</code> after the measured TSC value.  The next sequence number that can be staked out (perhaps already in another thread) will be one more.  For this number is taken from the variable <code>seq_counter</code> , and each successful call <code>__atomic_compare_exchange_n()</code> increases this variable by one. <br><br><div class="spoiler">  <b class="spoiler_title">__atomic with __sync ???</b> <div class="spoiler_text">  For the sake of <code>__atomic</code> , it should be noted that the use of built-in functions of the <code>__atomic</code> family together with the function from the obsolete <code>__sync</code> family looks ugly.  <code>__sync_synchronize()</code> used in the code in order to avoid re-ordering the TSC read operation with the overlying operations.  For this you need a complete barrier in memory.  In the <code>__atomic</code> family <code>__atomic</code> formally there is no function with corresponding properties.  Although in fact there is: <code>__atomic_signal_fence()</code> .  This function streamlines the computation of a stream with signal handlers running in the same stream.  In fact, this is a complete barrier.  However, this is not stated directly.  And I prefer the code in which there is no hidden semantics.  From here <code>__sync_synchronize()</code> is a full stop memory barrier. <br></div></div><br>  Another point worth mentioning here is the concern that all measurement flows start more or less at the same time.  We are interested in the fact that the TSC values ‚Äã‚Äãread on different CPUs are mixed together as best as possible.  We are not satisfied with the situation when, for example, one thread will start first, finish its work, and only then all the others will start.  The resulting TSC sequence will have useless properties.  From it will not work to extract any estimates.  The simultaneous start of all threads is important - and for this the library has taken action. <br><br><h3>  Tick ‚Äã‚Äãconversion to nanoseconds on the fly </h3><br>  After checking the reliability of TSC, the second big library assignment is to convert ticks to nanoseconds on the fly.  The idea of ‚Äã‚Äãthis conversion, I borrowed from the already mentioned fio.  However, I had to make several significant improvements, because, as shown by my analysis, in fio itself, the conversion procedure does not work well enough.  It turns out low accuracy. <br><br>  Immediately begin with an example. <br><br>  Ideally, I would like to convert tics to nanoseconds like this: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  We want the time spent on conversion to be minimal.  Therefore, we aim to use only integer arithmetic.  Let's see what it may threaten us. <br><br>  If <code>tsc_per_ns = 3</code> , then simple integer division, from the point of view of accuracy, works fine: <code>ns_time = tsc_ticks / 3</code> . <br><br>  But what if <code>tsc_per_ns = 3.333</code> ?  If this number is rounded to 3, the conversion accuracy will be very low.      : <br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code> . <br><br>   <code>factor</code>  ,     .  -  .  ,    .   ‚Äì    . ,  x86   10+ .   ,      . <br><br>      : <br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code> . <br><br>   ‚Äì  .    <code>(factor / 3.333)</code> .     ‚Äì - .    ,   <code>factor</code>   .           ‚Äì    . <br><br>     <code>factor</code> ?  , <code>factor</code>      .    ,  ,   ,      64- . ,     ¬´¬ª .  ,         . <br><br>  ,     <code>factor</code>    . ,          .   TSC    : <code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code> .    64-    : <code>18446744073709551615 / 105109488000000000 ~ 175.5</code> .  ,  <code>(factor / 3.333)</code>    ,   .  : <code>factor &lt;= 175.5 * 3.333 ~ 584.9</code> .    ,     ,  512. ,     : <br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br> : <br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br> .   ,      .     <code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code> .    : <code>105109488000000000 * 153 / 512 = 31409671218750000</code> .      126328781250000 ,  <code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code> . <br><br>   .    .          ?   .      .   : <br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code> (1) <br><br>     119305   1  (  0.2 ).    .        ,  ,      .     ?       ? <br><br>     : <br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br>    <code>tsc_ticks_per_1_hour</code> ,    <code>number_of_hours</code>  <code>tsc_ticks</code> . ,  ,      .           <code>tsc_ticks</code> ,     .   ,      <code>tsc_ticks_remainder</code> .   ,      ,   .  ,     ,     (1). <br><br>  Is done.     .      . <br><br>  ,        .           1 .      : <br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br>   ,     : <br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br>    ( ,  <code>tsc_ticks_remainder &lt; modulus</code> ): <br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br>  ,  ,          .        .  ,     ,  ,     . <br><br>  ,      <code>shift</code> ,  : <br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br>          : <br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br> ,    .  ,    ‚Äì   <code>tsc_ticks_remainder</code>  <code>number_of_moduli_periods</code>  <code>tsc_ticks</code> .  ,     .  ,     .    <code>modulus</code>   : <br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br>  Then: <br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Fine.   ,    <code>tsc_ticks</code> <code>number_of_moduli_periods</code>  <code>tsc_ticks_remainder</code> .  ,   <code>tsc_ticks_remainder</code>  .  ,       ,   <code>modulus</code> .    : <br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code>   .     ,     .       ,   ,  <code>modulus</code> .  <code>modulus</code> , ,  ,  <code>modulus</code> . <br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br>  Everything!     ,       ¬´ ¬ª.     : <br><br><ol><li>  <code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br>     <code>remainder_bit_length</code> , <code>modulus, ns_per_modulus</code> , <code>mult</code>  <code>shift</code>  . <br><br>       ,      .  ,   performance-    . <br><br>  So here. ,     :) <br><br> ,     <code>mult</code> ?    : <br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br> :   <code>tsc_per_nsec</code> ? <br>      ‚Äì    .       <code>tsc_per_nsec</code>  <code>(tsc_per_sec / 1000000000)</code> .  Those.: <br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br>      : <br><br><ol><li>  <code>tsc_per_sec</code> ,   <code>tsc_per_msec</code> , ? </li><li>    <code>tsc_per_sec</code> ? </li></ol><br>   .  fio       .     .  ,     , <code>tsc_per_msec = 2599998</code> .     <code>tsc_per_sec = 2599998971</code> .       ,        : 0.999999626.      ,   ,         374 .  ‚Äì <code>tsc_per_sec</code> . <br><br> ‚Ä¶   <code>tsc_per_sec</code> ? <br><br>      : <br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br> ¬´- ¬ª ‚Äî   .    ,     . ,  .  ,     <code>end_system_time</code>  <code>start_system_time</code>   0,6 .  <code>tsc_per_sec = (end_tsc ‚Äì start_tsc) / 0,6</code> . <br><br>       <code>tsc_per_sec</code> .     ¬´¬ª       -  <code>tsc_per_sec</code> ,   . <br><br>    ,  ,    <code>clock_gettime()</code>  <code>WTMLIB_GET_TSC()</code> . ,     <code>WTMLIB_GET_TSC()</code>     ,      <code>clock_gettime()</code> .          TSC.     <code>tsc_per_sec</code>     .      <code>tsc_per_sec</code>           .         . <br><br><h3>  Conclusion </h3><br> , . <br><br>         .   .      : <br><br><ul><li>       ‚Äì   ‚Äì   </li><li>      <code>modulus</code> (    )? </li><li>   ,       <code>modulus</code> ,      ,     ( <code>tsc_per_msec</code>  <code>tsc_per_sec</code> ).     ? </li><li> TSC   .   ? </li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br>                .   ,        . <br><br> ,  fio,      ,        700-900  (     ).      -      .     fio.    <a href="https://github.com/axboe/fio/issues/695">    ,  </a> .   ,  . <br><br>     ! </div><p>Source: <a href="https://habr.com/ru/post/425237/">https://habr.com/ru/post/425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425227/index.html">Researchers have found a way to detect and circumvent Honeytoken keys in a number of Amazon services.</a></li>
<li><a href="../425229/index.html">How we helped CDN MegaFon.TV not to fall on the 2018 World Cup</a></li>
<li><a href="../425231/index.html">FAQ about the work of the stewardess</a></li>
<li><a href="../425233/index.html">Python 3 to facebook</a></li>
<li><a href="../425235/index.html">A little more about graphs, or how to detect dependencies between your applications.</a></li>
<li><a href="../425241/index.html">Developer 20 years later: Vasily Lebedev about ICRE, education, his book and programming</a></li>
<li><a href="../425243/index.html">The john willis handbook</a></li>
<li><a href="../425245/index.html">Preview RamblerFront & # 6</a></li>
<li><a href="../425247/index.html">Crowdsourcing Testing</a></li>
<li><a href="../425249/index.html">How is familiarity with the LLP at ITMO University: the course "Low-level programming"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>