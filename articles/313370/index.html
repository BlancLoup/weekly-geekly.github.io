<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elements of functional programming in C ++: partial application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I will not go deep into the theory. What is a partial application is easy to find on the Internet. Including on Wikipedia . 


 In short, this is a me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elements of functional programming in C ++: partial application</h1><div class="post__text post__text-html js-mediator-article"><p>  I will not go deep into the theory.  What is a partial application is easy to find on the Internet.  Including <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">on Wikipedia</a> . </p><br><p> In short, this is a mechanism for fixing <code>k</code> arguments of a function from <code>n</code> arguments, making it a function of <code>(n - k)</code> arguments. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    f   : int f (int a, int b, int c, int d) { return a + b + c + d; } //    : auto g = part(f, 1, 2); // 1 + 2 + ... //   : assert(g(3, 4) == 10); // ... + 3 + 4 = 10</span></span></code> </pre> <br><p>  On this topic there are already a lot of publications, including on Habr√©: </p><br><ol><li>  <a href="https://habrahabr.ru/post/133084">C ++ Variadic templates.</a>  <a href="https://habrahabr.ru/post/133084">Currying and partial application</a> </li><li>  <a href="https://habrahabr.ru/post/149056">Partial application and currying in C ++</a> </li><li>  <a href="https://habrahabr.ru/post/238879">Curry on C ++</a> </li></ol><br><p>  And the ‚Äú <a href="http://stackoverflow.com/questions/26655685/how-should-i-make-function-curry">How should I make function curry?</a> ‚Äù Branch on stackoverflow is just a storehouse for those who first come across this topic. </p><br><p>  Unfortunately, the quantity has not yet turned into quality, and I never saw a good, usable variant.  In this case, that's curious. </p><br><p>  <strong>Remarkable fact number one</strong> .  In the mentioned articles there are all the techniques that are needed to implement the correct (in my opinion) partial application. </p><br><p>  It is only necessary to carefully analyze everything and put the cubes in the correct order.  This is what I am going to do in this article. </p><a name="habracut"></a><br><a name="contents"></a><br><h2>  Content </h2><br><ol><li>  <a href="https://habr.com/ru/post/313370/">Goals</a> </li><li>  <a href="https://habr.com/ru/post/313370/">Existing solutions</a> </li><li>  <a href="https://habr.com/ru/post/313370/">Philosophizing</a> </li><li>  <a href="https://habr.com/ru/post/313370/">New solution</a> </li><li>  <a href="https://habr.com/ru/post/313370/">Implementation</a> </li><li>  <a href="https://habr.com/ru/post/313370/">Conclusion</a> </li></ol><br><a name="goals"></a><br><h2 id="celicontents">  <a href="https://habr.com/ru/post/313370/">Goals</a> </h2><br><p>  So, what goals are set before us: </p><br><ol><li><p>  Actually implementation of the required functionality </p><br><p>  That is, the implementation of some kind of partial application of the function. </p><br></li><li><p>  Highest possible efficiency </p><br><p>  We must not forget that we write in C ++, one of the basic principles of which is the principle of "Abstraction without overhead" (see <a href="http://www.stroustrup.com/ETAPS-corrected-draft.pdf">Stroustrup, Foundations of C ++</a> ). </p><br><p>  In particular, there should not be any extra copying and no extra transfer. </p><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  I will add that this is not only one of the most important places in programming with pluses, but at the same time one of the most interesting. </div></div><br></li><li><p>  Ease of use </p><br><p>  It should be easy <em>for an</em> application programmer to <em>create</em> partially applied functions. </p><br><p>  It should also be easy for him to <em>use</em> partially applied functions in conjunction with existing solutions.  For example, transfer a partially applied function to some standard algorithm. </p><br></li></ol><br><a name="bad-solutions"></a><br><h2 id="suschestvuyuschie-resheniyacontents">  <a href="https://habr.com/ru/post/313370/">Existing solutions</a> </h2><br><p>  The authors of the existing solutions offer two main options.  Let us name their <em>application</em> whenever <em>possible</em> and <em>explicit application</em> . </p><br><h4 id="primenenie-po-vozmozhnosti">  Application whenever possible </h4><br><p>  This technique is that the result of a partial application is a function that can be partially applied again.  And the call to the original function occurs when the received arguments are already enough to make the call. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   : int f (int a, int b, int c, int d); //   : auto g = part(f); //   : auto h = g(1); //       `f`,     . //    : auto i = h(2, 3); //   -     `f`. //   ,    , , //    . assert(i(4) == 10);</span></span></code> </pre> <br><p>  Pretty ingenious idea.  But, unfortunately, in practice does not work. </p><br><p>  Why?  Suppose we want to partially apply a function that calculates the sum of an arbitrary number of variables: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ... xs)</span></span></span></span>;</code> </pre> <br><p>  In this case, we do not know when to stop in the process of partial application. <br>  This sum is calculated both from one, and from two, and from three, and in general from any number of variables. </p><br><p>  Therefore, the previous example breaks at the second step, if instead of <code>f</code> substitute <code>sum</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> g = part(sum); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ??? = g(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ?</span></span></code> </pre> <br><p>  The same will happen if the function has multiple overloads with different numbers of arguments.  It will be unclear which one should be called. </p><br><p>  There is another problem when you can "slip" the correct number of arguments.  In our example, it can be represented as: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> g = part(f, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> h = g(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Then the function will be partially applied to infinity, and will never be called. </p><br><h4 id="yavnoe-primenenie">  Explicit application </h4><br><p>  So, the authors say, since we don‚Äôt know when to stop a partial application, let's do it explicitly. </p><br><p>  Namely, we will create an overload of the "parenthesis" operator with no arguments, the call of which will mean that we need to call an internal function with those parameters that have already been partially applied: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> g = part(sum); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> h = g(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ?  ! auto i = h(2, 3, 4, 5, 6); //      . assert(i() == 21); //    .</span></span></code> </pre> <br><p>  The old problem is solved.  But there was a new one. </p><br><p>  Now every use of a partially applied function implies the knowledge that this is a partially applied function.  This means that it cannot be used in standard algorithms.  They simply do not know that after throwing arguments, you need to call empty "parentheses". </p><br><a name="philosophy"></a><br><h2 id="filosofstvovaniyacontents">  <a href="https://habr.com/ru/post/313370/">Philosophizing</a> </h2><br><p>  To advance further, we will slightly philosophize and express a couple of important thoughts. </p><br><h4 id="mysl-pervaya">  First thought </h4><br><p>  Partial application is a <em>deferred</em> call.  In other words, partial application does not produce any "partial calculations".  It simply remembers several arguments and waits for the rest to come. </p><br><p>  If for the sum, product, and other associative functions, it is still possible to come up with a crutch that will be able to return the partially calculated result (the sum or the product of the numbers obtained earlier), and continue the partial application, then for an arbitrary function such solution will not work. </p><br><h4 id="mysl-vtoraya">  Second thought </h4><br><p>  In C ++, there is no built-in partial application mechanism.  This means that the programmer, generally speaking, does not expect that only some of the arguments can be given to any arbitrary function, and the others can "throw away" sometime later. </p><br><p>  Consequently, when working with partial applications, the programmer knows that he is using it. <br>  Hence, <strong>partial application in the C ++ language will always be explicit</strong> . </p><br><h4 id="rezultat-razmyshleniya">  Result of reflection </h4><br><p>  It turns out that these options are not suitable.  Due to seemingly small shortcomings, these ‚Äúcool‚Äù solutions have to be recognized as extremely impractical, and therefore unsuitable for everyday use. </p><br><p>  Still, don't forget that C ++ is not a functional language.  It is not so easy to take and transfer the design and ideology of one language to another.  Here, as with the translation of poetry from a foreign language: the translation should be not literal, but poetic, that is, rhyme in the language of translation. </p><br><a name="good-solution"></a><br><h2 id="novoe-resheniecontents">  <a href="https://habr.com/ru/post/313370/">New solution</a> </h2><br><p>  Based on all the above, I came to the following conclusion.  Since the programmer always knows where he has a partial application, and where the function call, we can both simplify and make our model more universal. </p><br><p>  It will consist of two stages: </p><br><ol><li>  Capture the original arguments. </li><li>  Unconditional challenge with remaining arguments. </li></ol><br><p>  I will illustrate with an example. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   : auto sum (auto ... xs); //      . auto f = part(sum, 1, 2, 3); //      `f`. //   : assert(f(4) == 10); assert(f(4, 5) == 15); assert(f(4, 5, 6) == 21);</span></span></code> </pre> <br><p>  If you need to partially apply a few more arguments, they are "added" using the same explicit function call of a partial application: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> g = part(f, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  part(sum, 1, 2, 3, 4, 5).</span></span></code> </pre> <br><h4 id="eto-zhe-stdbind">  This is <code>std::bind</code> ! </h4><br><p>  It seems, but no.  On the one hand, <code>std::bind</code> allows you to handle arguments more flexibly.  Put them in arbitrary places, mix, etc. </p><br><p>  On the other hand, <code>std::bind</code> requires explicit placement of placeholders and does not work with an arbitrary number of arguments.  That is, the user is obliged to indicate in advance how many arguments will be ‚Äúbled out‚Äù in the future, and on what specific places in the call they will stand. </p><br><p>  Therefore, I believe that the resulting solution is quite independent and is not a special case of any other existing mechanisms. </p><br><a name="implementation"></a><br><h2 id="realizaciyacontents">  <a href="https://habr.com/ru/post/313370/">Implementation</a> </h2><br><p>  Perhaps the most interesting part.  Code.  At the beginning of the article I already mentioned one remarkable fact.  So, there is another one. </p><br><p>  <strong>Wonderful fact number 2</strong> .  In the standard library (C ++ 17) there is almost everything necessary for the implementation of partial application for this model. </p><br><p>  We need only to define one operation, which, however, is also expressed through the same standard tools. </p><br><p>  So, we need (complete and exhaustive list): </p><br><ol><li>  <a href="http://en.cppreference.com/w/cpp/utility/forward">std :: forward</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/utility/move">std :: move</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple">std :: forward_as_tuple</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/utility/apply">std :: apply</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke">std :: invoke</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat">std :: tuple_cat</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/utility/tuple/make_tuple">std :: make_tuple</a> </li></ol><br><p>  When I said that there is <em>almost</em> everything necessary, I meant that you need to define one function: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward_tuple</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(forward_as_tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(t)); }</code> </pre> <br><p>  This function takes an arbitrary tuple and returns a new tuple consisting of references to the elements of the input tuple.  If the input tuple contains links to <code>lvalue</code> , then they remain so.  The same objects that were stored in the tuple are passed by reference to the <code>rvalue</code> . </p><br><p>  Now we can say with confidence that we already have everything we need.  You can write code. </p><br><ol><li><p>  <code>part</code> function </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... As&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">part</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As &amp;&amp; ... as)</span></span></span><span class="hljs-function"> -&gt; part_fn&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::make_tuple(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;As&gt;(as)...))</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;As&gt;(as)...)}; }</code> </pre> <br><p>  Accepts an arbitrary number of arguments, the first of which is a certain function or functional object.  Stores them all into one tuple using the <code>make_tuple</code> function and returns this tuple wrapped in the <code>part_fn</code> structure. </p><br></li><li><p>  <code>part_fn</code> structure </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part_fn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... As&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As &amp;&amp; ... as)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(invoke, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat(forward_tuple(t), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_as_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;As&gt;(as)...))); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... As&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As &amp;&amp; ... as)</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(invoke, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat(forward_tuple(t), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_as_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;As&gt;(as)...))); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... As&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As &amp;&amp; ... as)</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(invoke, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat(forward_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(t)), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_as_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;As&gt;(as)...))); } Tuple t; };</code> </pre> <br><ol><li><p>  Stores partially applied objects: a function and its first <code>k</code> arguments. </p><br></li><li><p>  It has a bracket operator that takes an arbitrary number of arguments. </p><br><ol><li>  When called, a tuple of links to the input arguments is formed using the function <code>forward_as_tuple</code> . </li><li>  A tuple with previously saved objects is also converted to a link tuple using the function defined by us <code>forward_tuple</code> . </li><li>  Both tuples of links are glued into one using the function <code>tuple_cat</code> .  It turns out one big tuple of links. </li><li>  The glued-up tuple is expanded and passed to the <code>invoke</code> function using the <code>apply</code> function. </li><li>  The <code>invoke</code> function call on the received arguments. </li></ol><br></li></ol><br></li></ol><br><p>  Everything. </p><br><p>  In this place, lovers of cunning template code (like me, for example) should be slightly disappointed. </p><br><p>  On the other hand, the simplicity, the elegance of the solution and the fact that it is assembled from only a few standard "cubes" indirectly indicates that it is quite viable and can be easily integrated into the application code. </p><br><h4 id="ispolzovanie">  Using </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modulo_less</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> modulo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a % modulo) &lt; (b % modulo); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;{...}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(), v.end(), part(modulo_less, <span class="hljs-number"><span class="hljs-number">7</span></span>));</code> </pre> <br><p>  Thanks to the <code>make_tuple</code> call, <code>std::ref/cref</code> supported: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s += <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(x); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> g = part(append, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(s)); g(<span class="hljs-number"><span class="hljs-number">5</span></span>); g(<span class="hljs-number"><span class="hljs-number">6</span></span>); assert(s == <span class="hljs-string"><span class="hljs-string">"qwerty56"</span></span>);</code> </pre> <br><p>  And by using the <code>invoke</code> function, various complex cases will be supported, such as calling a class method (see <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke">std :: invoke</a> ), etc. </p><br><p>  And all this is "out of the box" and without any special gestures from our side. </p><br><a name="conclusion"></a><br><h2 id="zaklyucheniecontents">  <a href="https://habr.com/ru/post/313370/">Conclusion</a> </h2><br><p>  Why I think my decision is right. </p><br><ol><li>  It is simple and transparent.  It is assembled from "elementary" components that <abbr title="While unofficially.">already exist</abbr> in the language. </li><li>  It is effective.  Abstraction without overhead. </li><li>  Reliably like a hammer.  No "magic". </li><li>  It is well integrated into the existing programming paradigm in C ++. </li><li>  Compatible with tools that are used in the standard library.  For example, with <code>reference_wrapper</code> for signaling about passing parameters by reference (as in <code>std::make_tuple</code> , <code>std::bind</code> , <code>std::thread</code> ), and also, very importantly, with algorithms. </li></ol><br><p>  ¬ªFull source code <a href="">here</a> . </p><br><p>  <a href="https://habr.com/ru/post/313370/">To the content</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313370/">https://habr.com/ru/post/313370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313346/index.html">Diary of a bug: how I repaired pictures in e-mail</a></li>
<li><a href="../313350/index.html">Lambda and anonymous classes: who eats more</a></li>
<li><a href="../313356/index.html">Add disk space for a Linux ‚Äì server in the Azure Pack Infrastructure cloud, and at the same time, we are working with LVM</a></li>
<li><a href="../313364/index.html">Experience in building and operating large file storage</a></li>
<li><a href="../313366/index.html">Sharding - patterns and antipatterns</a></li>
<li><a href="../313372/index.html">Elections 2016. Part 2 is amazing nearby and it is allowed</a></li>
<li><a href="../313374/index.html">JavaScript: includes vs indexOf</a></li>
<li><a href="../313376/index.html">Soviet "Elbrus" - an overview of the architecture</a></li>
<li><a href="../313380/index.html">learnopengl. Lesson 1.5 - Shaders</a></li>
<li><a href="../313382/index.html">Virtual server with video card</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>