<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lab "Learning to set up networks in GNU / Linux"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No one likes long introductions, so immediately to the point. 
 In this improvised laboratory, I would like to highlight the work with networks in GNU...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lab "Learning to set up networks in GNU / Linux"</h1><div class="post__text post__text-html js-mediator-article">  No one likes long introductions, so immediately to the point. <br>  In this improvised laboratory, I would like to highlight the work with networks in GNU / Linux <br>  and consider the following topics: <br><br><ol><li>  We study vlan.  We build a network between vm1, vm2 in one vlan.  We ping, catch packages, study headings. </li><li>  We break vm1 vm2 into different vlan.  Configure intervlan routing with R1. </li><li>  Iptables  Customize the masquerade.  Simulate access to external networks. </li><li>  Iptables  We configure port forwarding for services on vm1 and v2, which are behind NAT. </li><li>  Iptables  Configure security zones.  We study tcp sessions. </li></ol><br><br>  ZY  all people are wrong, I am open to your comments, if I wrote some nonsense, I am ready to correct it! <br><a name="habracut"></a><br>  Given: local network consisting of VM1, VM2.  Router R1 (also a virtual machine), web server S1. <br>  You can download a ready virtual machine for this lab from the <a href="https://yadi.sk/d/MR_jT2-f3AWJxu">Yandex disk.</a> <br>  Since  I tried to submit this article as a lesson, for the most part I do not write commands with text, but I make a screenshot so that they can be driven in with their own hands.  It helps to better understand and quickly remember.  I fully understand that this is inconvenient, but I decided to choose this approach. <br><div class="spoiler">  <b class="spoiler_title">Network layout</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/418/2e4/718/4182e471833f4f1bb2b2c4fd9aae725d.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">An example of virtual machines in my vbox</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c3a/11d/174/c3a11d1741fb460aad998ba578a1bd15.jpg"><br></div></div><br>  Setup for VM1 - connect as a bridge to the interface.  You can choose any interface and begin to browse everything on it.  For completeness, I made a bridge adapter (br0, br1) in system 2 and connected vm1, vm2, r1 (adapter 1) to br0, and s1, r1 (adapter 2) to br2. <br><div class="spoiler">  <b class="spoiler_title">adapter setup example</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/dba/02d/c48/dba02dc4839e43648967743e57ba7c70.jpg"><br></div></div><br>  For the other 3 settings are similar. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  I. We study vlan.  We build a network between vm1, vm2 in one vlan.  We ping, catch packages, study headings. </h2><br><br>  Run vm1 and vm2 and look at the interfaces in our system with the command <pre><code class="bash hljs">ip addr</code> </pre>  (abbreviated ip a) <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/99e/3c7/cab/99e3c7cab72a46b384a7a108aa516f5d.jpg"><br></div></div><br>  Add a new device, which will be called eth0.100 and represent a tagged interface with id = 100. <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/7d1/bbb/c35/7d1bbbc35c0344299b82bb56dabc2ae5.jpg"><br></div></div><br> <code>ip link add -   <br> link eth0 -     eth0 <br> name eth0.100 -    .     ,            vlan.      <br> type vlan -   .    8021q -  vlan <br> id 100 -   id vlan <br></code> <br><br>  Now assign an ip address to this interface: <br><pre> <code class="bash hljs">ip addr add 10.10.10.10/24 dev eth0.100</code> </pre> <br>  short entry view: <br><pre> <code class="bash hljs">ip aa 10.10.10.10/24 dev eth0.100</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/02f/044/ec8/02f044ec878d4facb1951c80511f6794.jpg"><br></div></div><br>  We draw attention to the following things: no-carrier and DOWN <br>  This means that we do not have a network cable connected to the interface, and the interface itself is in DOWN. <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/126/114/8d4/1261148d4b5049759b6998bdfcdd8b1d.jpg"><br></div></div><br>  Connect the cable and get the following picture: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/367/def/50c/367def50c4ad41d69d8c3a95fd5a983c.jpg"><br></div></div><br>  And let's turn on the interface using the command: <br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev eth0.100 up</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f01/8f1/a1c/f018f1a1c5f34c3db7023c60748e1a28.png"><br></div></div><br>  Thus, we have created an interface that will receive tagged packets with vlan id = 100 and, accordingly, hang tag 100 on packets when releasing the packet to the network through this interface.  and assigned him an ip address 10.10.10.10/24 <br>  do the same thing on VM2, assign the address 10.10.10.20/24 <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c29/218/a3d/c29218a3d97942c78479377aa7af81bf.jpg"><br></div></div><br>  Checking connectivity between VM1 and VM2: ping 10.10.10.10 with VM2 <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f85/a38/249/f85a38249e2d48c39b52db89e4da0006.jpg"><br></div></div><br><img src="https://habrastorage.org/files/90c/992/33c/90c99233c42846569eb923162eb5cc28.jpg">  To summarize: we created 2 tagged interfaces on a 100-volume vlan-e on 2 machines in 1 LAN and checked the connectivity between them. <br><br>  We check that all this is not a lie and a provocation!  We start on VM1 the listener and we will knock on it with VM2 and we wake up traffic. <br>  1. on VM1 we will start <br> <code>nohup nc -lvp 3000 &amp; <br> tcpdump -n host 10.10.10.20 -i eth0 -e <br></code> <br>  2. on VM2 we will start <br> <code>nc 10.10.10.10 3000</code> <br> <div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/77e/a47/557/77ea4755734c442592bb2cd3e5ca54fe.jpg"><br></div></div><br>  We see in the headings of the channel level vlan 100. So the packets on the network really go with the tags and these are not the inventions of the mother goose. <br><br><h2>  Ii.  We break vm1 vm2 into different vlan.  Configure intervlan routing with R1. </h2><br><br>  Now let's move on to item 2 - we split these 2 virtuals into different vlans and configure the router. <br>  On VM1: <br>  add interface eth0.200 with tag 200 and assign it the address 192.168.0.2 <br>  on VM2: <br>  add interface eth0.300 with tag 300 and assign address 172.16.0.2 to it <br>  (By myself) <br><div class="spoiler">  <b class="spoiler_title">Result (VM1)</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/23a/33c/0cb/23a33c0cbc9b4341855ffb4d0caa8226.jpg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Result (VM2)</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/135/325/fca/135325fca5644d2cb74325f4dc2805cb.jpg"><br></div></div><br>  Turn on and configure the router R1.  On the router, unlike VM1, VM2, you need to create an interface both in vlan 200 and in vlan 300 ‚Äî this interface will be the gateway in these networks.  Assign them the addresses 192.168.0.1, 172.16.0.1. <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/76e/5de/40b/76e5de40bcd148558af62d8f33a50d59.jpg"><br></div></div><br><br>  We check connectivity.  Ping from the router 192.168.0.2 and 172.16.0.2.  (Incidentally, there was a small problem here, since I was mistaken in setting up eth0.300 on VM2. <br><div class="spoiler">  <b class="spoiler_title">I did not find an error</b> <div class="spoiler_text">  instead of id = 300 I registered id = 200 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a22/55e/786/a2255e7869454dd7a07f49b6a394d45e.jpg"><br></div></div><br><br>  So, we have a connection between VM1, R1 and VM2, R1.  Let's try to connect VM1, VM2 through R1. <br>  In order for our Router to be able to forward packets between interfaces, it needs to be allowed to it.  You need to uncomment the <b>net.ipv4.ip_forward = 1</b> directive in the <b>/etc/sysctl.conf</b> file and apply the changes with the <b>sysctl -p</b> command. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># nano /etc/sysctl.conf # sysctl -p net.ipv4.ip_forward = 1</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0c1/09a/83a/0c109a83a12d4ab1aac1b28139935e9e.jpg"><br></div></div><br>  And now the most important thing.  Need to configure routing.  There are 3 common ways to do this: <br>  1. specify the default route.  those.  we do not know where we have the destination ip, so all the packets that do not belong to the local network are sent to the router. <br>  2. specify the gateway for a specific subnet.  This should be done if the network is available for different routers. <br>  3. specify the interface for which the one who will accept the package is located  This situation occurred to me, for example, if necessary, in the data center to route the subnet.  Those.  There was a virtual router to the external address of which the data center statically routed the subnet allocated to me.  Then I just pointed out that the ip address of this subnet is on one of the router interfaces sticking up inside.  Packages were sent to this interface and received on the other side by the virtual users who were assigned these white addresses.  those.  in this situation, specifying the gateway was completely optional. <br>  Let's see the list of routes on VM1: <br><pre> <code class="bash hljs">ip ro</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/01b/131/340/01b131340948495588ddefcf1946dc7d.jpg"><br></div></div><br>  Our virtual machine knows only about 2 subnets: 10.10.10.0/24 &amp; 192.168.0.0/24.  About the host 172.16.0.2 does not say anything!  because if you try to ping nothing happens: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/539/d0d/94b/539d0d94bb994bbf836572084278da57.jpg"><br></div></div><br>  add the route to the subnet 172.16.0.0/24: <br><pre> <code class="bash hljs">ip ro add 172.16.0.0/24 via 192.168.0.1</code> </pre> <br>  <b>via</b> - means through whom.  those.  we send packets to host 192.168.0.1, it will figure it out. <br>  Looking through the routing table the following decision is made: <br>  1. Who is this package for?  host 172.16.0.2 <br>  2. To send the package 172.16.0.2?  host 192.168.0.1 <br>  3. What do we know about host 192.168.0.1?  he is directly connected.  This subnet is ours.  at the data link level, we create the source mac address, the source mac address is 192.168.0.1, the source ip is 192.168.0.2, the destination ip address is 172.16.0.2, and is sent via the eth0.200 interface.  As the author of the podcast ‚Äúnetworks for the smallest‚Äù said, the subsequent fate of the package does not bother us. <br>  Let's try to ping the gateway of the neighboring vlan: <pre> <code class="bash hljs">ping 172.16.0.1</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/78b/5e6/49d/78b5e649d6414f2aa208a3296c6e4f7b.jpg"><br></div></div><br>  Works!  But what will happen if you ping 172.16.0.2?  It will not work, because there is no return route.  The packet reaches the VM2 host, but VM2 cannot send it back, because  does not know where.  Let's try to add a route back to VM2. <br>  Add a default route for VM2.  You can do this by specifying the subnet and mask (0.0.0.0/0 - that is, absolutely all addresses fall under it) or using the default keyword <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ed7/bb5/859/ed7bb585996c4cebb59ab6d8358d4d69.jpg"><br></div></div><br>  We get the same result.  And in the end, now VM1 freely pings VM2.  Hooray! <br><br><img src="https://habrastorage.org/files/90c/992/33c/90c99233c42846569eb923162eb5cc28.jpg">  To summarize: We learned how to route between 2 vlan using a linux router. <br><br><h2>  Iii.  Iptables  Customize the masquerade.  Simulate access to external networks. </h2><br><br>  Add some public server S1.  on it, I put apache2 (apt install apache2) and will simulate a web server on the Internet.  Whereas our VM1, VM2 are private machines behind the router.  The second interface of the router is looking at the improvised Internet. <br>  Add the 2nd interface for R1 - eth1 and already without a VLAN we will configure it with the ip address 8.8.8.100, and on S1 - 8.8.8.8 <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/226/7ec/72a/2267ec72a2a745afb6a10533c73b58ad.jpg"><br></div></div><br>  It is important to remember that all the commands that we entered in the console only work until the reboot.  When I added the 2 interface and turned off the virtual machine, after rebooting I received an unconfigured machine, as a result of which all the commands had to be applied again. <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a22/55e/786/a2255e7869454dd7a07f49b6a394d45e.jpg"><br></div></div><br>  If you repeat after me including the VBOX setting, do not forget to add in br1 both network cards on both S1 and R1.  Bridge interface in the system can be created with the command <br><pre> <code class="bash hljs">ip link add br1 <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> bridge</code> </pre>  . <br>  But in general, the whole lab can be done on one any interface without creating anything. <br>  I accentuate the separation in order to imitate the bridge = a sort of switch. <br><br>  After setting S1, R1, we check connectivity - perform ping 8.8.8.8 - it should work with R1.  Moreover, if we ping with VM2, then there will be no ping. <br><div class="spoiler">  <b class="spoiler_title">Why?</b> <div class="spoiler_text">  Because S1 does not know about the network 172.16.0.0.  Add our R1 as the default gateway for S1: <br><pre> <code class="bash hljs">ip ro add default via 8.8.8.100</code> </pre> <br></div></div><br><br>  In addition, if we ping a server with VM1, then it will generally say that the network is unavailable. <br><div class="spoiler">  <b class="spoiler_title">Why?</b> <div class="spoiler_text">  Because we did not register default gw at all, but indicated where the network is located 172.16.0.0/24. <br></div></div><br><br>  Fix it by writing gateway: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/443/694/8c8/4436948c8c2e47ffb3ed3047e20751c7.jpg"><br></div></div><br><br>  Now all 4 cars perfectly ping each other.  But it should not be so.  Gray addresses should not go online!  And that network, where it looks by the second interface R1, should not know where the addresses 172.16. *. *, 192.168. *. * Are located. <br>  Remove the deafult gw from S1: <br><pre> <code class="bash hljs">ip ro del default</code> </pre> <br><br><img src="https://habrastorage.org/files/90c/992/33c/90c99233c42846569eb923162eb5cc28.jpg">  To summarize: we learned how to prescribe routes to the networks we need, and also learned how to ‚Äúhide‚Äù gray addresses behind the router, releasing all the traffic out through only one white address. <br><br>  It's time to talk about NAT.  NAT (from the English. Network Address Translation - "Network Address Translation") is a mechanism in TCP / IP networks that allows you to convert the IP addresses of transit packets.  Also known as IP Masquerading, Network Masquerading and Native Address Translation.  We will consider masquerading.  this is SourceNAT (SNAT) &amp;&amp; DestinationNAT (DNAT). <br>  What do we really need from NAT?  But we need the outgoing packet towards S1 to receive the address of the router as the source ip, and when it comes back to get the destination address again the address of the virtual machine. <br><br>  Set up a masquerade for the subnet 17.16.0.0/24 - execute the following command on the router: <br><pre> <code class="bash hljs">iptables -t nat -A POSTROUTING -p tcp -m tcp -s 172.16.0.0/24 ! -d 172.16.0.0/24 -j MASQUERADE</code> </pre> <br>  I will not describe in detail how iptables works, because  these are many and many beeches and this article is clearly not for that.  Here is a very good <a href="https://www.opennet.ru/docs/RUS/iptables/">article</a> to study. <br>  I will pay only attention to <code>! -d 172.16.0.0/24</code>  <code>! -d 172.16.0.0/24</code> : why it is needed.  This is necessary to ensure that hosts from the 172.16.0.0/24 subnet that could potentially be located behind the router (for example, remote vpn clients) would not fall under this rule. <br>  You can see the result with the command <code>iptables-save</code> <br><br>  So what have we accomplished?  We set up a masquerade for VM2.  This means that when it will knock on S1, then S1 will see the address is not VM2, but the address of the router!  A couple of proofs: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d42/7de/e60/d427dee6015f40e49deb47ec5180abce.jpg"><br></div></div><br>  and what does S1 see at this moment? <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/afd/fb0/c59/afdfb0c5925b47b9ac5c3e476c30d856.jpg"><br></div></div><br>  8.8.8.8 communicates perfectly with 8.8.8.100, no 172.16.0.2 and did not smell! <br>  And what happens at this moment on the router?  How does this kitchen work?  We will listen to the "gray" interface eth0.300 <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/797/a81/a38/797a81a381bc4a219a13971bf127ab13.jpg"><br></div></div><br>  And this is how it looks at the output to the "external" network: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/284/8b0/e93/2848b0e93adc4215b7691d721aa75c11.jpg"><br></div></div><br><br>  The kernel, depending on the direction of the packet, processes it and substitutes the correct ip addresses.  But if we do the same with VM1, then S1 will see gray addresses.  and simply will not respond to this request.  Look at it yourself.  Let me remind you that the GW on S1 must be removed. <br><br><img src="https://habrastorage.org/files/90c/992/33c/90c99233c42846569eb923162eb5cc28.jpg">  To summarize: We hid our gray networks and released hosts for the router, replacing the source address ip with the address of the router.  And in the other direction - we learned to forward a certain port of a particular virtual machine ‚Äúoutside‚Äù and were able to connect to the gray address of VM1 virtualka from the ‚Äúpublic‚Äù network from the S1 server. <br><br><h2>  Iv.  Iptables  We configure port forwarding for services on vm1 and v2, which are behind NAT </h2><br><br>  Let us simulate that S1 is a certain client from the Internet and he wants to connect to VM1 (that client, to which there is neither a route, nor a masquerade).  Let it be an attempt to connect via ssh.  SSH defaults to port 22, but if we have more than 1 such servers, then how to be?  In general, in a good way to get rid of the most simple network scanners, ssh should always be removed from port 22.  We use port 30022, for example, to access ssh to VM1. <br><br>  How it works? <br>  S1 sends a packet (s.ip = S1.ip, d.ip = R1.ip; s.port = N, d.port = 30022) which arrives at R1. <br>  R1 Looks through iptables and applies the DNAT rule, and forms a packet (by our rule): (s.ip = S1.ip, d.ip = VM1.ip; s.port = N, d.port = 22) <br>  Looks through the routing table and sends the vm1 packet through the interface eth0.200. <br><br>  VM1 in turn receives the packet, receives data, and generates a response: (s.ip = VM1.ip, d.ip = S1.ip; s.port = 22, d.port = N). <br>  R1 accepts the packet and restores the original s.ip to which s1 originally addressed: <br>  (s.ip = R1.ip, d.ip = S1.ip; s.port = 22, d.port = N) <br><br>  This can be achieved as follows: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/658/c59/0cf/658c590cfa4d4888818ac45ebc22d5cc.jpg"><br></div></div><br>  try to connect: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/086/558/745/08655874543449ff88a2a88afe7c82d3.png"><br></div></div><br><br><img src="https://habrastorage.org/files/90c/992/33c/90c99233c42846569eb923162eb5cc28.jpg">  To summarize: we have learned how to provide access to services located on virtual machines behind a certain router (otherwise you can say - to virtuals behind NAT'om - which is exactly what is most needed) <br><br><h2>  V. iptables.  Configure security zones.  We study tcp sessions. </h2><br><br>  And the last thing I would like to consider in this lesson is the tcp session and the direction of installation of these sessions.  So, for example, we will consider 2 segments: server and client.  The client, for example, should be able to "go" to the server segment to the domain controller.  But the domain controller to do on the client machine is nothing.  There are many examples of such examples and why situations can go from one network segment to another and not the other way around.  Why might this be necessary?  For example, we have a web server that ‚Äúlooks‚Äù on the Internet and was ‚Äútaken over‚Äù by an attacker.  From this server, he may well try to knock on the corporate network.  However, if you prohibit setting sessions from this segment, this will not happen.  Those.  we at least make life difficult for an intruder.  Let's add a rule that will prevent VM2 from going to VM1, and VM1 to VM2 - you can. <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b3e/0e9/624/b3e0e9624757483e891b326c25d0d282.jpg"><br></div></div><br>  We try to go from VM1 to VM2: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ce3/a76/399/ce3a7639964640bc8e8455a6ffc5db92.jpg"><br></div></div><br>  and in the opposite direction: <br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/851/508/1f5/8515081f52684ef9a7074b962ebdeaa9.jpg"><br></div></div><br>  Why it happens?  At the moment of establishing a TCP session, a TCP SYN packet arrives (a SYN ACK is answered to it, and then an ACK and the session is considered to be established).  The first rule that we wrote down (c NEW) allows forwarding TCP SYN packets from the 192.168.0.0 network to 172.16.0.0. <br>  When the second participant answers this and any subsequent packet, 2 rules on the established sessions fall under the effect and such packets from the 172.16.0.0 network pass.  But if he tries to establish a session (or just ping), then the rule 1.2 will not fall, but will fall under the 3rd, which will drop this package.  Voila! <br><br><img src="https://habrastorage.org/files/90c/992/33c/90c99233c42846569eb923162eb5cc28.jpg">  To summarize: We have learned how to manage the directions for setting up tcp sessions to control the direction of traffic between security zones. <br><br>  Thanks for attention! <br><br>  I post my draft lectures in the telegram channel: <a href="https://t.me/bykvaadm">t.me/bykvaadm</a> </div><p>Source: <a href="https://habr.com/ru/post/320428/">https://habr.com/ru/post/320428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320418/index.html">How to become a product manager? Part 5: Get things done</a></li>
<li><a href="../320420/index.html">Open data transfer</a></li>
<li><a href="../320422/index.html">Closed beta testing of hot storage in Mail.Ru Cloud</a></li>
<li><a href="../320424/index.html">3 main trends in the world of AI in 2017</a></li>
<li><a href="../320426/index.html">An attempt to teach students to program how to automate this process</a></li>
<li><a href="../320430/index.html">Understanding the critical rendering path</a></li>
<li><a href="../320432/index.html">Video recordings of the MBLTdev 16 mobile developers conference reports</a></li>
<li><a href="../320434/index.html">Cerebro is a free alternative to Alfred and Spotlight</a></li>
<li><a href="../320436/index.html">10 questions for the informed choice of the SIEM system</a></li>
<li><a href="../320438/index.html">5 of the ‚Äúhottest‚Äù new books in January</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>