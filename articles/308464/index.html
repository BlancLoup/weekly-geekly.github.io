<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Initial rakes in working with Service Bus for Windows Server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microsoft has such a not very well-known thing, as the Service Bus for Windows Server . And it so happened that in several projects we had a chance to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Initial rakes in working with Service Bus for Windows Server</h1><div class="post__text post__text-html js-mediator-article">  Microsoft has such a not very well-known thing, as the <a href="https://msdn.microsoft.com/en-us/library/dn282144.aspx">Service Bus for Windows Server</a> .  And it so happened that in several projects we had a chance to work with it.  As a result, it turned out to collect a small set of pitfalls that were encountered in projects more often than others.  What and share. <a name="habracut"></a><br><br><div class="spoiler">  <b class="spoiler_title">A brief description of what Service Bus for Windows Server is.</b> <div class="spoiler_text">  This is a Microsoft implementation of the Service Bus, which is very close to the Windows Azure Service Bus on Windows, but does not require Azure itself.  That is a sort of quite comfortable and advanced tire.  It can provide both standard queues and their advanced version of topic (topic), which is able to give the same message to several different subscriptions (subscription).  Since in practice I only managed to collide with topics / subscriptions, then we will only discuss them later. <br><img src="https://habrastorage.org/files/3db/aa5/188/3dbaa5188ba64106aa2dbdce7d494f46.png" alt="image"><br>  That is, consumers publish their posts in the topic.  The topic transmits them to all its subscriptions.  Subscriptions, in turn, check messages for whether they need them or not by matching them with their list of rules (filter).  All suitable messages are then transmitted to those customers who subscribe to these same subscriptions.  And if several clients are subscribed to the same subscription, then only one of them will receive the message.  Everything is pretty standard. <br></div></div><br><h3>  The first steps and the very first rake </h3><br>  How to start using this thing?  From trying to send and receive a message, of course. <br><blockquote>  <i><u>Attention</u> , hereafter the non-production code is given, the attached code is only intended to serve as a functioning illustration of the text.</i> </blockquote><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageFactory = MessagingFactory.CreateFromConnectionString(connectionString); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publisher = messageFactory.CreateTopicClient(topicName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener = messageFactory.CreateSubscriptionClient(topicName, subscriptionName); listener.OnMessage(message =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brokeredMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrokeredMessage(<span class="hljs-string"><span class="hljs-string">"some test message"</span></span>); publisher.Send(brokeredMessage);</code> </pre> <br>  It's simple, a message appears in the console.  Let's try to post a lot of messages and very roughly estimate how much time it will take to send and receive: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stopwatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesToSent = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesProccessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; listener.OnMessage(message =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (messagesProccessed == messagesToSent) { stopwatch.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time passed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stopwatch.Elapsed}</span></span></span><span class="hljs-string">"</span></span>); } }); stopwatch.Start(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; messagesToSent; i ++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brokeredMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrokeredMessage(<span class="hljs-string"><span class="hljs-string">$"Message ‚Ññ</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i}</span></span></span><span class="hljs-string">"</span></span>); publisher.Send(brokeredMessage); }</code> </pre><br>  If you run this code, it turns out that on my old veteran computer the process takes about six seconds. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But the next step often leads to the first rake.  The fact is that the subscriber can receive messages in one of two modes: <br><br><ul><li>  <b>PeekLock</b> - the message is received, but not deleted from the subscription, but only receives the lock.  In order for it to be deleted, the client must explicitly confirm its successful processing by calling <i>Commit ()</i> .  Otherwise, after the expiration of a lock or by calling <i>Abandon ()</i> from the client itself, an attempt will be made to deliver this message again. <br><br></li><li>  <b>ReceiveAndDelete</b> - the message is received and immediately deleted from the subscription.  If the processing went wrong, then re-receive this message.  But it works a little faster than <i>PeekLock</i> , because it does not hang loki. </li></ul><br>  By default, <i>messageFactory.CreateSubscriptionClient</i> creates a <i>PeekLock</i> option.  But due to non-obviousness, I almost did not see the client being created without explicit indication of the mode of operation.  And, if you believe the documentation, at the specified <i>PeekLock,</i> you must call <i>.Complete ()</i> for each message.  Let's try to do it: <br><br><pre> <code class="cs hljs">listener.OnMessage(message =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (messagesProccessed == messagesToSent) { stopwatch.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time passed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stopwatch.Elapsed}</span></span></span><span class="hljs-string">"</span></span>); } message.Complete(); <span class="hljs-comment"><span class="hljs-comment">//  ,        });</span></span></code> </pre><br>  And here the unexpected happens.  In spite of the fact that no exceptions are being thrown, the lines with Message No. X run, everything happens VERY slowly.  These 200 messages instead of six seconds required as much as four minutes and nine seconds!  This does not justify the old iron.  But after all, I once found this problem in the code of a live project; just for a small number of messages, the performance drawdown was not noticeable. <br><br>  Why it happens?  After all, if something would be wrong, one would expect an exception?  In fact, there is an exception.  Just for some not entirely clear reason, Microsoft made an extremely non-obvious way of obtaining information about these very exceptions. <br><br>  The <i>OnMessage</i> message subscription method accepts the optional <i>OnMessageOptions</i> parameter, which allows you to subscribe to the <i>ExceptionReceived</i> event.  That is, those "hidden exceptions". <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onMessageOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMessageOptions(); onMessageOptions.ExceptionReceived += (sender, args) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Exception received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{args.Exception}</span></span></span><span class="hljs-string">"</span></span>); listener.OnMessage(message =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (messagesProccessed == messagesToSent) { stopwatch.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time passed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stopwatch.Elapsed}</span></span></span><span class="hljs-string">"</span></span>); } message.Complete(); }, onMessageOptions); <span class="hljs-comment"><span class="hljs-comment">//    onMessageOptions</span></span></code> </pre><br>  By running this code, we will see that for each message, a <i>Microsoft.ServiceBus.Messaging.MessageLockLostException is</i> thrown: <br><blockquote>  The lock provided is invalid.  She has expired, or the message has already been removed from the queue. TrackingId: 54630ae4-6e4f-4979-8fc8-b66e5314079c_GAPC_BAPC, TimeStamp: 08/24/2016 9:20:08 PM <br></blockquote><br>  Why it happens?  Because onMessageOptions has one more parameter: <i>AutoCommit</i> .  And it defaults to true.  Thus, in order to work correctly in case you want to independently manage the life cycle of a message, this field must be set to false.  Let's try this way: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stopwatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesToSent = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesProccessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onMessageOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMessageOptions { AutoComplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">//   }; onMessageOptions.ExceptionReceived += (sender, args) =&gt; Console.WriteLine($"Exception received: {args.Exception}"); listener.OnMessage(message =&gt; { Console.WriteLine($"Message received: {message.GetBody&lt;string&gt;()}"); messagesProccessed++; if (messagesProccessed == messagesToSent) { stopwatch.Stop(); Console.WriteLine($"Time passed: {stopwatch.Elapsed}"); } message.Complete(); }, onMessageOptions); stopwatch.Start(); for (var i = 0; i &lt; messagesToSent; i ++) { var brokeredMessage = new BrokeredMessage($"Message ‚Ññ{i}"); publisher.Send(brokeredMessage); }</span></span></code> </pre><br>  And voila: no exceptions, message processing takes only two and a half seconds.  It looks like a normal operation. <br><br>  <b>Summarizing</b> : <br><br><ul><li>  Almost always you need to subscribe to <i>onMessageOptions.ExceptionReceived</i> , otherwise you may not notice a number of problems in the work of the code </li><li>  Remember that by default servicebase is trying to commit messages for you.  Most often this behavior should be disabled. </li></ul><br><h3>  Abstraction and rake two </h3><br>  The second, not less frequently encountered moment, also seen in the production code, is the improper creation of a wrapper for the subscriber.  Creating a class that would hide the work with service bass within itself is generally a good thing.  But there are nuances.  Here is an illustration of how not to do it, but such code has been repeatedly noticed in reality. <br><br>  This class is created like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Listener</span></span> : <span class="hljs-title"><span class="hljs-title">IListener</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MessagingFactory _messageFactory; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SubscriptionClient _client; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Task&gt; OnReceivedAsync; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Listener</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topicName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subscriptionName, ReceiveMode receiveMode</span></span></span><span class="hljs-function">)</span></span> { _messageFactory = MessagingFactory.CreateFromConnectionString(connectionString); _client = _messageFactory.CreateSubscriptionClient(topicName, subscriptionName, receiveMode); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onMessageOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMessageOptions { AutoComplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; onMessageOptions.ExceptionReceived += (sender, args) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Exception received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{args.Exception}</span></span></span><span class="hljs-string">"</span></span>); _client.OnMessageAsync(bm =&gt; OnReceivedAsync?.Invoke(bm.GetBody&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;()), onMessageOptions); } }</code> </pre><br>  Which is further used like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageFactory = MessagingFactory.CreateFromConnectionString(connectionString); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publisher = messageFactory.CreateTopicClient(topicName); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesToSent = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; messagesToSent; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brokeredMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrokeredMessage(<span class="hljs-string"><span class="hljs-string">$"Message ‚Ññ</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i}</span></span></span><span class="hljs-string">"</span></span>); publisher.Send(brokeredMessage); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Listener(connectionString, topicName, subscriptionName, ReceiveMode.ReceiveAndDelete); listener.OnReceivedAsync += x =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); };</code> </pre><br>  If you run this code, everything seems to work, but instead of the first message there will be an error " <i>NullReferenceException: Object reference not set to an instance of an object.</i> " <br><br>  Moreover, the error will be caught only in the case of a subscription to onMessageOptions.ExceptionReceived, if this is not done (and not for some reason, they do not do this for some reason), then the problem can only be found by indirect and sometimes very subtle bugs in the code behavior. <br><br>  What is wrong here?  Well, the answer is pretty obvious, and if I hadn‚Äôt met so often, I probably wouldn‚Äôt have mentioned it.  When the <i>_client.OnMessageAsync</i> is called in the Listener abstraction constructor, the subscriber is already starting to receive messages.  Therefore, a number of them (depending on how far the designer and the subscription to the <i>listener.OnReceivedAsync</i> are spaced out will be skipped and go to the empty <i>OnReceivedAsync? .Invoke</i> , logically returning null. Hence, <i>NullReferenceException</i> . <br><br>  What to do with it?  The simplest thing is to postpone instance creation and subscription, like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Listener</span></span> : <span class="hljs-title"><span class="hljs-title">IListener</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MessagingFactory _messageFactory; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SubscriptionClient _client; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Listener</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topicName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subscriptionName, ReceiveMode receiveMode</span></span></span><span class="hljs-function">)</span></span> { _messageFactory = MessagingFactory.CreateFromConnectionString(connectionString); _client = _messageFactory.CreateSubscriptionClient(topicName, subscriptionName, receiveMode); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Task&gt; handleMessage</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onMessageOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMessageOptions { AutoComplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; onMessageOptions.ExceptionReceived += (sender, args) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Exception received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{args.Exception}</span></span></span><span class="hljs-string">"</span></span>); _client.OnMessageAsync(bm =&gt; handleMessage(bm.GetBody&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;()), onMessageOptions); } }</code> </pre><br>  And subscribe like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Listener(connectionString, topicName, subscriptionName, ReceiveMode.ReceiveAndDelete); listener.Subscribe(x =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); });</code> </pre><br><br>  Now the loss of messages when creating a class does not occur. <br><br>  <b>Summarizing</b> : <br><br><ul><li>  Subscribe to <i>onMessageOptions.ExceptionReceived more</i> relevant to current </li><li>  Remember that receiving messages begins immediately after calling <i>client.OnMessageAsync</i> and take this into account when designing abstractions </li></ul><br><h3>  Rake number three </h3><br>  Subscriber has a wonderful method <i>Close ()</i> .  But his behavior is not entirely predictable speculative.  Let's try to execute the following code here, which, after sending the first half of messages, calls this very <i>Close ()</i> and receives the second half of the messages through another copy of the subscriber. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageFactory = MessagingFactory.CreateFromConnectionString(connectionString); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publisher = messageFactory.CreateTopicClient(topicName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener1 = messageFactory.CreateSubscriptionClient(topicName, subscriptionName, ReceiveMode.ReceiveAndDelete); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener2 = messageFactory.CreateSubscriptionClient(topicName, subscriptionName, ReceiveMode.ReceiveAndDelete); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesToSent = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesProccessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onMessageOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMessageOptions { AutoComplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; onMessageOptions.ExceptionReceived += (sender, args) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Exception received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{args.Exception}</span></span></span><span class="hljs-string">"</span></span>); listener1.OnMessage(message =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"listener1: message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">, listener1 is closed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listener1.IsClosed}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; }, onMessageOptions); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; messagesToSent; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brokeredMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrokeredMessage(<span class="hljs-string"><span class="hljs-string">$"Message ‚Ññ</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i}</span></span></span><span class="hljs-string">"</span></span>); publisher.Send(brokeredMessage); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">4</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Closing listener1"</span></span>); listener1.Close(); } } listener2.OnMessage(message =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"listener2: message received : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">, listener2 is closed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listener2.IsClosed}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; }, onMessageOptions);</code> </pre><br>  But the result in the console will be like this: <br><blockquote>  listener1: message received: Message # 0, listener1 is closed: False <br>  listener1: message received: Message # 1, listener1 is closed: False <br>  listener1: message received: Message # 2, listener1 is closed: False <br>  listener1: message received: Message # 3, listener1 is closed: False <br>  listener1: message received: Message # 4, listener1 is closed: False <br>  Closing listener1 <br>  <b>listener1: message received: Message # 5, listener1 is closed: True</b> <br>  listener2: message received: Message # 6, listener2 is closed: False <br>  listener2: message received: Message # 7, listener2 is closed: False <br>  listener2: message received: Message # 8, listener2 is closed: False <br>  listener2: message received: Message # 9, listener2 is closed: False </blockquote><br>  Not obvious, right?  If you do the same, but for the <i>PeekLock mode</i> instead of <i>ReceiveAndDelete</i> , the result will be similar, except that .Complete () will throw out the <i>System.OperationCanceledException: This messaging entity has already been closed, aborted, or disposed</i> .  And if you catch errors in the message handler in order to make <i>Abandon ()</i> with your hands, then <i>Abandon () itself will</i> throw out the error.  And both of these are ordinary, not hiding inside <i>OnMessageOptions</i> . <br><br>  And the missed message itself, unlike <i>ReceiveAndDelete</i> , will still be processed later, when a re-send occurs. <br><br><div class="spoiler">  <b class="spoiler_title">Code with Complete and output to console</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageFactory = MessagingFactory.CreateFromConnectionString(connectionString); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageFactory1 = MessagingFactory.CreateFromConnectionString(connectionString); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> messageFactory2 = MessagingFactory.CreateFromConnectionString(connectionString); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publisher = messageFactory.CreateTopicClient(topicName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener1 = messageFactory1.CreateSubscriptionClient(topicName, subscriptionName, ReceiveMode.PeekLock); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener2 = messageFactory2.CreateSubscriptionClient(topicName, subscriptionName, ReceiveMode.PeekLock); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesToSent = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messagesProccessed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onMessageOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMessageOptions { AutoComplete = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; onMessageOptions.ExceptionReceived += (sender, args) =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Exception received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{args.Exception}</span></span></span><span class="hljs-string">"</span></span>); listener1.OnMessage(message =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"listener1: message received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">, listener1 is closed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listener1.IsClosed}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; message.Complete(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex1) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"listener1 Complete() exception: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ex1.Message}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { message.Abandon(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex2) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"listener1 Abandon() exception: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ex2.Message}</span></span></span><span class="hljs-string">"</span></span>); } } }, onMessageOptions); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; messagesToSent; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brokeredMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrokeredMessage(<span class="hljs-string"><span class="hljs-string">$"Message ‚Ññ</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{i}</span></span></span><span class="hljs-string">"</span></span>); publisher.Send(brokeredMessage); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">4</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Closing listener1"</span></span>); listener1.Close(); } } listener2.OnMessage(message =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"listener2: message received : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{message.GetBody&lt;</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-string"><span class="hljs-subst">&gt;()}</span></span></span><span class="hljs-string">, listener2 is closed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listener2.IsClosed}</span></span></span><span class="hljs-string">"</span></span>); messagesProccessed++; message.Complete(); }, onMessageOptions);</code> </pre><br><br><blockquote>  listener1: message received: Message # 0, listener1 is closed: False <br>  listener1: message received: Message # 1, listener1 is closed: False <br>  listener1: message received: Message # 2, listener1 is closed: False <br>  listener1: message received: Message # 3, listener1 is closed: False <br>  listener1: message received: Message # 4, listener1 is closed: False <br>  Closing listener1 <br>  <b>listener1: message received: Message # 5, listener1 is closed: True</b> <b><br></b>  <b>listener1 Complete () exception: This messaging entity has already been closed, aborted, or disposed.</b> <b><br></b>  <b>Abandon listener exception: This message has been closed, aborted, or disposed.</b> <br>  listener2: message received: Message # 6, listener2 is closed: False <br>  listener2: message received: Message # 7, listener2 is closed: False <br>  listener2: message received: Message # 8, listener2 is closed: False <br>  listener2: message received: Message # 9, listener2 is closed: False <br>  listener2: message received: Message # 5, listener2 is closed: False </blockquote><br></div></div><br>  What to do with it and how to live with it?  Well, you just need to remember about it and take it into account in the code.  The all-knowing stackoverflow offers enough options to deal with this behavior.  For example, where appropriate, you can call <i>messageFactory.Close ()</i> together with the closure of the subscriber.  Or check in the handler if the subscriber is not closed with something like <i>if (listener.IsClosed) {/ *** /}</i> , etc. <br><br>  <b>Summarizing</b> : <br><br><ul><li>  Not all experts from the servicebase arrive only in <i>onMessageOptions.ExceptionReceived</i> </li><li>  When completing work with a subscriber, you must take into account the specifics of the <i>Close ()</i> method </li></ul><br><h3>  Conclusion </h3><br>  In general, Service Bus for Windows Server is a pretty good thing and copes with its tasks, but some little things at the start can drink a little blood.  I hope the points outlined in the article will be useful to someone and save them from stuffing their own cones. </div><p>Source: <a href="https://habr.com/ru/post/308464/">https://habr.com/ru/post/308464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308452/index.html">7 days left to buy Early Bird tickets for MBLTdev 16</a></li>
<li><a href="../308454/index.html">From Babylon to Europe</a></li>
<li><a href="../308458/index.html">How the media survive in a crisis: the experience of world media</a></li>
<li><a href="../308460/index.html">Distributed cluster of two Fortigate</a></li>
<li><a href="../308462/index.html">Heisenbag, or how the Moon spoils the code</a></li>
<li><a href="../308466/index.html">More than 25 million accounts of mail.ru gaming forums have been stolen by intruders</a></li>
<li><a href="../308468/index.html">Keyboard switch according to OS X</a></li>
<li><a href="../308470/index.html">Linux is 25 years old</a></li>
<li><a href="../308472/index.html">How is network access control implemented within Cisco?</a></li>
<li><a href="../308474/index.html">Fujitsu World Tour 2016: Moving to Digital Transformation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>