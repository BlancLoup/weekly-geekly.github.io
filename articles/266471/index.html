<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote a guitar tuner under iOs on Swift. And also a little about DSP, standing waves and how to achieve an accuracy of ¬± 0.1 Hz</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about how I had the idea to write my tuner and what it led to. I will also share my modest knowledge in the field of DSP (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote a guitar tuner under iOs on Swift. And also a little about DSP, standing waves and how to achieve an accuracy of ¬± 0.1 Hz</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/320/3fb/daa/3203fbdaa2f143e1a4b7368b1a15569f.png">  In this article I will talk about how I had the idea to write my tuner and what it led to.  I will also share my modest knowledge in the field of DSP (digital signal processing) obtained in the university, and how they helped me solve some problems.  And of course, I‚Äôll share the source code and programming experience on Swift that I received during the implementation of this project. <br><a name="habracut"></a><br><h1>  Prehistory </h1><br>  I had an idea to write my own tuner for a guitar a long time ago, about 10 years ago when I was at university.  There are several reasons for this: <br><br><ul><li>  Firstly, there are not so many really high-quality tuner programs - some simply incorrectly determine the frequency, or work extremely unstable on the upper strings.  In addition, all the tuners that I came across are <i>√† priori</i> tuned to A440 (when the <i>first octave is</i> tuned to 440 Hz).  But there is also a setting on the C256 ( <i>before the first octave it is</i> tuned to 256 Hz).  Many tuners do not allow tuning in frets, although if you need to play for 5-7 frets, it is better to tune the instrument in the same frets. </li><li>  Secondly, the visualization of the settings in the form of a slider, spectrum or frequency waveform, in my opinion, is not a bit physical.  I wanted to show how the wave generated by the instrument itself looks like - how clean it is, or vice versa distorted.  Make the visualization clear and responsive. </li><li>  Thirdly, I wanted to apply my knowledge in the field of DSP, obtained in the university, for the benefit of mankind. </li></ul><br>  In general, the idea has been sitting in my head for a long time, but it only came true this year, as I finally had free time, an iOs device and some experience in mobile development. <br><br><h1>  Some theory </h1><br>  Anyone who is somewhat familiar with European stringed instruments knows that each string is tuned to a certain note, and a certain frequency corresponds to this note.  The difference between a note and a frequency is that each note carries a certain musical function.  And this function is determined by the position of the note relative to other notes, for example, the note <i>up</i> in <i>the C major</i> sequence plays the role of a <i>tonic</i> , i.e.  the main and most sustainable sound.  If this note moves a little, it will lose its function.  In order for the extracted sounds to correspond to the notes, it is necessary to observe a strict correspondence between the intervals of notes and the ratio of frequencies.  From the accuracy and stability of the frequency generated by the string will depend on the correspondence of the extracted sound to the function that was laid in the note. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is the sound generated by the string?  If we use the ADSR model proposed by the American researcher and composer Vladimir Usachevsky for the first synthesizers, the string sound is a harmonic oscillation modulated by some envelope.  This envelope is called ADSR, because  it has four characteristic points: attack ( <i>eng. attack</i> ), decline ( <i>eng. decay</i> ), sustain ( <i>eng. sustain</i> ) and attenuation ( <i>eng. release</i> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e01/f12/969/e01f1296970042f9848df418eae342a7.png"></div><br><br>  The sustain interval most clearly conveys the frequency, because  fluctuations occur with little or no amplitude change.  If the guitar produced a perfect monoharmonic sound, then, taking into account the ADSR-envelope, the spectrum of such oscillations would look like a narrow strip.  The shape of this strip would correspond to the spectrum of the envelope: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4b1/d8a/16a/4b1d8a16af404a91bafb814b2452aeab.png"></div><br><br>  But the real instrument generates non-linear oscillatory processes, as a result of which additional harmonics appear, which are called overtones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/437/f05/359/437f053599ee449a9f13ed663697c6d2.png"></div><br><br>  These overtones are quite treacherous companions, because  they can prevail over the main tone and interfere with the frequency determination.  But all the same, usually the basic tone is well defined without additional manipulations. <br><br>  So, on the basis of these views, you can outline the path by which the program should work: <br><br><ol><li>  Calculate the Fourier transform of the sound wave </li><li>  Find the main tone on the spectrum </li><li>  Calculate the pitch frequency </li></ol><br><h2>  About standing waves </h2><br>  Typically, the sound on the graph is represented as a sweep in time.  At the zero point on the abscissa axis is the value at the initial moment of observation, then, respectively, the values ‚Äã‚Äãthat will be observed after 1 s, 2 s, etc.  The measurement process in this case can be represented by an imaginary frame that moves uniformly left to right.  This frame can be called differently: observation window ( <i>English observation window</i> ), observation interval ( <i>English observation interval</i> ), time window ( <i>English time window</i> ) - all these terms mean about the same thing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c1d/cca/e1f/c1dccae1fb8745c79d04cbf89c291f84.gif"></div><br><br>  So, the frame allows us to understand how the measurement process takes place and which moments are at the beginning of the frame, and which are at the end.  Based on this, we can imagine what will happen if we compare the coordinate system with the frame - we will have a feeling that the sound wave appears in the right part of the graph and disappears in the left.  Such a wave is called traveling: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ed1/ab4/f5d/ed1ab4f5ddd04a99a6fa08c7bd955ce7.gif"></div><br><br>  But such a representation of the sound wave is not informative, because  the wave can move very, very fast.  Our task is to somehow stop the wave.  In order for the wave to stop, it is necessary that its speed be equal to 0. And since  Since the wave has two speeds: phase and group, then you can get two types of standing waves: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/71f/1d9/6b3/71f1d96b323b496d994134a3e21a98a4.gif"></div><br><br>  A standing wave whose group velocity is equal to zero is characterized by the fact that its envelope always remains in one place.  But at the same time the oscillations do not stop - the zeros and humps continue to move along the abscissa axis.  Obviously, such a wave does not suit us, since  Of interest is what happens inside the ADSR envelope, namely at the moment when we observe oscillations in the sustain mode. <br><br>  For this, there is another type of standing wave whose phase velocity is zero: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3a8/9f5/c94/3a89f5c9414443488420ad14e2c50192.gif"></div><br><br>  The zero phase velocity ensures that the knots and humps always stay in one place, so we can easily make out the shape of the harmonic oscillation and assess how close it is to the ideal sinusoidal shape.  The algorithm for obtaining such a wave is obvious: <br><ol><li>  Find Phase Phase </li><li>  Shift the displayed wave by the magnitude of the phase </li></ol><br><h1>  Implementation </h1><br><h2>  Microphone recording </h2><br>  In fact, Apple provides many high-level capabilities for working with multimedia from Objective-C / Swift.  But in essence, now work with sound revolves around Audio Queue Services: <br><br><blockquote>  Audio Queue Services provides you with features such as synchronization.  The Sound Manager is deprecated in OS X v10.5 and does not work with 64-bit applications.  Audio apps in existing Mac apps. <br>  <a href="https://developer.apple.com/library/mac/documentation/MusicAudio/Reference/AudioQueueReference/index.html">a source</a> <br></blockquote><br>  But unlike SoundManager, which was a fairly high-level solution, Audio Queue Services are clumsy wrappers that simply repeat the Swift C code: <br><br><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AudioQueueNewInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inFormat: UnsafePointer&lt;AudioStreamBasicDescription&gt;, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inCallbackProc: AudioQueueInputCallback, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inUserData: UnsafeMutablePointer&lt;Void&gt;, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inCallbackRunLoop: CFRunLoop!, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inCallbackRunLoopMode: CFString!, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inFlags: UInt32, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outAQ: UnsafeMutablePointer&lt;AudioQueueRef&gt;)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">OSStatus</span></span></code> </pre> <br>  There is no profit from the low-level code in Swift, so I left the capture of the sound to the auxiliary C-code.  If you omit the secondary code to manage the buffers, then the recording setup consists in initializing the AQRecorderState structure using the AudioQueueNewInput function: <br><br><pre> <code class="hljs erlang-repl"> void AQRecorderState_init(struct AQRecorderState* aq, double sampleRate, size_t count){ aq-&gt;mDataFormat.mFormatID = kAudioFormatLinearPCM; aq-&gt;mDataFormat.mFormatFlags = kLinearPCMFormatFlagIsPacked | kLinearPCMFormatFlagIsSignedInteger; aq-&gt;mDataFormat.mSampleRate = sampleRate; aq-&gt;mDataFormat.mChannelsPerFrame = <span class="hljs-number"><span class="hljs-number">1</span></span>; aq-&gt;mDataFormat.mBitsPerChannel = <span class="hljs-number"><span class="hljs-number">16</span></span>; aq-&gt;mDataFormat.mFramesPerPacket = <span class="hljs-number"><span class="hljs-number">1</span></span>; aq-&gt;mDataFormat.mBytesPerPacket = <span class="hljs-number"><span class="hljs-number">2</span></span>;// for linear pcm aq-&gt;mDataFormat.mBytesPerFrame = <span class="hljs-number"><span class="hljs-number">2</span></span>; AudioQueueNewInput(&amp;aq-&gt;mDataFormat, HandleInputBuffer, aq, NULL, kCFRunLoopCommonModes, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;aq-&gt;mQueue); DeriveBufferSize(aq-&gt;mQueue, &amp;aq-&gt;mDataFormat, (double)count / sampleRate, // seconds &amp;aq-&gt;bufferByteSize); for (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; kNumberBuffers; ++i) { AudioQueueAllocateBuffer(aq-&gt;mQueue, aq-&gt;bufferByteSize, &amp;aq-&gt;mBuffers[i]); AudioQueueEnqueueBuffer(aq-&gt;mQueue, aq-&gt;mBuffers[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, NULL); } aq-&gt;mCurrentPacket = <span class="hljs-number"><span class="hljs-number">0</span></span>; aq-&gt;mIsRunning = true; aq-&gt;buffer = Buffer_new(<span class="hljs-number"><span class="hljs-number">32768</span></span>); aq-&gt;preview_buffer = Buffer_new(<span class="hljs-number"><span class="hljs-number">5000</span></span>); AudioQueueStart(aq-&gt;mQueue, NULL); }</code> </pre><br>  Data writing occurs through the function HandleInputBuffer.  Calls Buffer_write_ints converts data from int to float and stores it in a buffer for further processing. <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void HandleInputBuffer ( void *aqData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AudioTimeStamp *inStartTime, UInt32 inNumPackets, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AudioStreamPacketDescription *inPacketDesc ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AQRecorderState</span></span></span></span>* pAqData = (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AQRecorderState</span></span></span></span>*)aqData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(inNumPackets == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pAqData-&gt;mDataFormat.mBytesPerPacket != <span class="hljs-number"><span class="hljs-number">0</span></span>) inNumPackets = inBuffer-&gt;mAudioDataByteSize / pAqData-&gt;mDataFormat.mBytesPerPacket; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SInt16* data = inBuffer-&gt;mAudioData; Buffer_write_ints(pAqData-&gt;buffer, data, inNumPackets); Buffer_write_ints(pAqData-&gt;preview_buffer, data, inNumPackets); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAqData-&gt;mIsRunning == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AudioQueueEnqueueBuffer(pAqData-&gt;mQueue, inBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, NULL); }</code> </pre><br><h2>  Performance and Swift problems </h2><br>  Initially, the idea was to use 100% Swift language.  In general, I did this, rewrote all the code in Swift, with the exception of FFT, for which the implementation from the Accelerate library was used.  But oddly enough, the version on Swift produced a huge load in the region of 95% of processor time and a delay in signal processing which led to horribly slow rendering. <br><br>  In this form, of course, the application was not suitable for use, so I had to completely transfer all signal processing to the Accelerate library.  But even after that, the load still remained high.  I had to transfer to C and those operations with arrays that required only one pass, i.e.  linear execution time.  For illustration, I will give an identical code on Swift and C: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processing</span></span></span></span>{ ... func getFrequency() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peak: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peakFrequency: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..&lt;spectrum.count/<span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spectrumValue: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> = p-&gt;spectrum[i] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> = fd * i / spectrum.count <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spectrumValue &gt; peak) { peak = spectrum[i] peakFrequency = f } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> peakFrequency } }</code> </pre><br><pre> <code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_frequency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p* processing)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> peak = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> peakFrequency = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; p.spectrumLength / <span class="hljs-number"><span class="hljs-number">2</span></span>; i ++){ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> spectrumValue = p-&gt;spectrum[i]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = p-&gt;fd * i / p-&gt;spectrumLength; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spectrumValue &gt; peak) { peak = spectrum; peakFrequency = f; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> peakFrequency; }</code> </pre><br>  In general, even a trivial pass through the array, if it is done in a loop with a frequency of 20 calls per second, could load the device quite heavily. <br><br>  Perhaps it was the problem of the first version of Swift, but in the end I had to completely eliminate everything from Swift that produced element-wise operations.  So in Swift there was only responsible for creating arrays, transfer to auxiliary libraries written in C, as well as the rendering code on OpenGL ES 2. <br><br>  But was Swift good?  Of course, with regard to high-level tasks, Swift copes with this perfectly.  Writing code is much more pleasant, modern syntax does not require constant semicolons, a lot of intuitive and useful syntax sugar.  So, despite the fact that the use of Swift has created some problems, in general, the language seemed quite pleasant. <br><br><h2>  Microphone sensitivity problem </h2><br>  So, rewriting part of the code in C, it seemed that the moment when I could tune my guitar was about to come.  But then another trouble arose about which I had not thought at all.  The microphone on the iPhone horribly cut the low-frequency part of the spectrum.  Of course, I assumed that the microphones in smartphones are not perfect, but everything turned out to be much worse.  the dam began at 200 Hz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c1c/168/a2a/c1c168a2a97c49c58d56189dc4410d9d.png"></div><br><br>  As for the tuning of the guitar, such a block of frequency response makes it impossible to tune the sixth string, since  It has a frequency of approximately 80 Hz.  With this attenuation, the fundamental tone begins to sink in harmonics with a frequency of 160 Hz, 240 Hz, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/74b/70f/0c7/74b70f0c7f3e48059262abe81824b3ae.png"></div><br><br>  I immediately identified two possible ways to solve this problem: <br><ul><li>  if the base frequency has a twin with a frequency of 0.5, then this should indicate that the base tone is muffled and the resulting frequency should be adjusted to be 1 / 2f </li><li>  enable the user to suppress the overtones of the low-pass filter, which will cut off the frequency slightly larger than the tone of the string </li></ul><br>  The first option seemed more interesting, because  did not require additional effort from the user.  However, he turned out to be not completely wealthy, since  led to many bad situations.  For example, the fundamental frequency is sometimes cut with a microphone so strongly that it was at the level of 1-2% of its first harmonic.  In addition, because  Because the guitar resonator is a very non-linear device, the situation often arose when the second and third, and even fourth harmonics began to compete with each other in amplitude.  This led to the fact that the tone was captured four times higher than the main one. <br><br>  In principle, these problems could be solved programmatically.  The main disappointment was due to the fact that the harmonics in the guitar are very much walking, so tuning them will not provide an accuracy of ¬± 0.1 Hz.  This is probably due to the fact that the main tone is set by the string with a fairly stable frequency, on the contrary, the harmonics are supported mainly due to oscillations in the guitar body and may deviate by several Hertz during the string's sound. <br><br>  Therefore, the first solution had to be abandoned for the sake of a more predictable and less convenient one.  So, the low-pass filter has approximately the following frequency response: <br><br><img src="https://habrastorage.org/files/c5c/305/fc8/c5c305fc8f1d48d28714969dc62feb55.png"><br><br>  The blockage to the right of the cutoff frequency suppresses overtones, so that the main tone again becomes prevalent.  The price paid for this is a general decrease in the signal-to-noise ratio and, as a consequence, a slight decrease in accuracy, but within the limits of the permissible. <br><br><img src="https://habrastorage.org/files/e2e/850/1e2/e2e8501e22a54501803b81fd71936aef.png"><br><br><h2>  Accuracy vs speed </h2><br>  In digital signal processing, the task of selecting the size of the observation window always emerges.  A large observation window allows you to collect more information, make an accurate and stable assessment of signal parameters.  On the other hand, this creates a number of problems due to the fact that it is necessary to store and process a larger number of samples at a time, plus it causes a proportional delay in signal processing. <br><br>  In turn, Accelerate allows you to calculate the spectrum of sequences not exceeding 32768 samples.  But such a number of readings means that the frequency grid step in the spectrum is approximately equal to 1.35 Hz.  On the one hand, this is a permissible value when it comes to for example <i>the first octave</i> with a frequency of 440 Hz, i.e.  notes which is obtained on the open first string (the thinnest).  But on the sixth string, such an error is fatal, since  between <i>mi big octaves</i> and, for example, <i>re big octaves of</i> only 3 Hz.  Those.  An error of 1.35 Hz is a half-tone error. <br><br><img src="https://habrastorage.org/files/772/958/785/77295878540044328dbfefed48094a40.png"><br><br>  Nevertheless, the solution to this problem is quite simple, but it also demonstrates the full power of time-frequency analysis.  Since  there is no possibility to accumulate a few seconds of the signal, then we can accumulate the value of the spectrum at the frequency of the fundamental tone with repeated Fourier transform.  Mathematically, the result will be equivalent to processing a 1.35 Hz filter at the pitch frequency.  Having only 16 complex samples, we can increase the accuracy of the result by 16 times, i.e.  up to about 0.08 Hz, which is slightly more accurate ¬± 0.1 Hz. <br><br><img src="https://habrastorage.org/files/edb/343/a2b/edb343a2bf40476c9cac9e1ef2b29eaf.png"><br><br>  In other words, having no information about the pitch value, we would have to increase the time window to 5 s and get 163840 samples to get an accuracy of ¬± 0.1 Hz.  But since  with a time window of 0.743 s, we can already make a frequency estimate with an accuracy of 1.35 Hz, then for a more accurate estimate, it is enough to accumulate samples from an extremely narrow band with a sampling rate of 2.7 Hz.  For this purpose, 2.7 Hz * 5 s = 13.75 complex counts are enough (or 16 if rounded and taken with a margin). <br><br><h2>  Comparison of notes and frequencies </h2><br>  This task is quite easily solved on Swift.  I created a special Tuner class in which I brought all the information about the supported tools and matching rules.  All these calculations are based on the two formulas "baseFrequency * pow (2.0, (n - b) / 12.0)" and "12.0 * log (f / baseFrequency) / log (2) + b", <br>  where baseFrequency is the base frequency of 440 Hz or 256 Hz, b is the note number in integers, ranging from <i>to subcontracted</i> . <br><br>  The code turned out quite Chinese: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuner</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(){ addInstrument(<span class="hljs-string"><span class="hljs-string">"guitar"</span></span>, [ (<span class="hljs-string"><span class="hljs-string">"Standard"</span></span>, <span class="hljs-string"><span class="hljs-string">"e2 a2 d3 g3 b3 e4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"New Standard"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2 g2 d3 a3 e4 g4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Russian"</span></span>, <span class="hljs-string"><span class="hljs-string">"d2 g2 b2 d3 g3 b3 d4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Drop D"</span></span>, <span class="hljs-string"><span class="hljs-string">"d2 a2 d3 g3 b3 e4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Drop C"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2 g2 c3 f3 a3 d4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Drop G"</span></span>, <span class="hljs-string"><span class="hljs-string">"g2 d2 g3 c4 e4 a4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Open D"</span></span>, <span class="hljs-string"><span class="hljs-string">"d2 a2 d3 f#3 a3 d4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Open C"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2 g2 c3 g3 c4 e4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Open G"</span></span>, <span class="hljs-string"><span class="hljs-string">"g2 g3 d3 g3 b3 d4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Lute"</span></span>, <span class="hljs-string"><span class="hljs-string">"e2 a2 d3 f#3 b3 e4"</span></span>), (<span class="hljs-string"><span class="hljs-string">"Irish"</span></span>, <span class="hljs-string"><span class="hljs-string">"d2 a2 d3 g3 a3 d4"</span></span>) ]) ... } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noteNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(noteString: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> note = noteString.lowercaseString <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> octave = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> note.hasPrefix(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) { number = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> note.hasPrefix(<span class="hljs-string"><span class="hljs-string">"c#"</span></span>) { number = <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> note.hasPrefix(<span class="hljs-string"><span class="hljs-string">"b"</span></span>) { number = <span class="hljs-number"><span class="hljs-number">11</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> note.hasSuffix(<span class="hljs-string"><span class="hljs-string">"0"</span></span>) { octave = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> note.hasSuffix(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) { octave = <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> note.hasPrefix(<span class="hljs-string"><span class="hljs-string">"8"</span></span>) { octave = <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> * octave + number } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noteString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num: Double)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noteOctave: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span>(num / <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> noteShift: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-type"><span class="hljs-type">Int</span></span>(num % <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> noteShift { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result += <span class="hljs-string"><span class="hljs-string">"c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result += <span class="hljs-string"><span class="hljs-string">"c#"</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: result += <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-type"><span class="hljs-type">String</span></span>(noteOctave) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noteFrequency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(noteString: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = noteNumber(noteString) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = noteNumber(baseNote) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> baseFrequency * pow(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>(n - b) / <span class="hljs-number"><span class="hljs-number">12.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frequencyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: Double)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = noteNumber(baseNote); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">12.0</span></span> * log(f / baseFrequency) / log(<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-type"><span class="hljs-type">Double</span></span>(b); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frequencyDistanceNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f0: Double, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f1: Double)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n0 = frequencyNumber(f0) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n1 = frequencyNumber(f1) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n1 - n0; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetFrequency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noteFrequency(string) * fretScale() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actualFrequency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frequency * fretScale() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frequencyDeviation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100.0</span></span> * frequencyDistanceNumber(noteFrequency(string), frequency) } }</code> </pre><br><h2>  Standing wave visualization </h2><br>  As for the standing wave, which allows you to see the shape of the sound wave of the instrument, then, as I already wrote, the algorithm is absolutely trivial - the found wave frequency is calculated and the phase is estimated, and then the shift is made by the found value.  Data is taken from the auxiliary preview buffer, which, unlike the main one, does not accumulate.  Those.  works according to the ‚Äú <i>tumbling window</i> ‚Äù algorithm: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">double</span></span> waveLength = p-&gt;fd / f; size_t <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = p-&gt;previewLength - waveLength * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-type"><span class="hljs-type">double</span></span>* src = &amp;p-&gt;preview[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; //            <span class="hljs-type"><span class="hljs-type">double</span></span> re = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">double</span></span> im = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; waveLength*<span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-type"><span class="hljs-type">double</span></span> t = (<span class="hljs-type"><span class="hljs-type">double</span></span>)<span class="hljs-number"><span class="hljs-number">2.0</span></span> * M_PI * i / waveLength; re += src[i] * cos(t); im += src[i] * sin(t); } <span class="hljs-type"><span class="hljs-type">double</span></span> phase = get_phase(re, im); //     <span class="hljs-type"><span class="hljs-type">double</span></span> shift = waveLength * phase / (<span class="hljs-number"><span class="hljs-number">2.0</span></span> * M_PI); //   //     <span class="hljs-type"><span class="hljs-type">double</span></span>* shiftedSrc = &amp;p-&gt;preview[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> - (size_t)(waveLength - shift) - (size_t)waveLength];</code> </pre><br><h2>  Appearance </h2><br>  I made the appearance and navigation based on the built-in player, but instead of switching on the tracks, switching on the strings takes place: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/faf/8c6/17b/faf8c617bcb1427ca514ac0138987b24.png"></div><br><br><h1>  Conclusion </h1><br>  All the way to develop an application on Swift / C took about two months.  The application was quite difficult to implement.  Firstly, the performance of smartphones still leaves much to be desired and solutions "in the forehead" in the high-level language are absolutely unsuitable for domestic use by users.  Secondly, the topic of sound processing is terribly unpopular with developers for iOs, so information has to be collected bit by bit.  Although this concerns, probably, any topic not related to UI when developing for mobile applications.  Thirdly, although Swift is not badly connected with C-data, but still this way of development is terribly inconvenient and terribly laborious. <br><br>  Despite the fact that the article turned out to be quite substantial, many subtleties and nuances remained unlit.  I hope the source code of the application will help clarify incomprehensible moments: <br><br><img src="https://habrastorage.org/files/f62/214/bb9/f62214bb9e0c425aba041f6f32926bf4.png">  <a href="https://github.com/kreshikhin/scituner">github.com/kreshikhin/scituner</a> <br><br>  The source code is accompanied by a MIT license.  Therefore, you can safely use the code sections you are interested in or the entire project code for your own purposes. </div><p>Source: <a href="https://habr.com/ru/post/266471/">https://habr.com/ru/post/266471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266459/index.html">Old new pywinauto: automate Windows GUI in Python with install / uninstall example</a></li>
<li><a href="../266461/index.html">Adaptive scaling: design of online stores for large screens</a></li>
<li><a href="../266463/index.html">Sophos UTM Web Access Organization</a></li>
<li><a href="../266465/index.html">The history of one facs Yandex. Navigator. In six acts with prologue and remorse</a></li>
<li><a href="../266469/index.html">Intellectual lighting - we get used to this term. Plus a remark from Redwood: lighting should be comfortable, economical and safe</a></li>
<li><a href="../266473/index.html">Thoughts on deploying web applications on a test server</a></li>
<li><a href="../266475/index.html">Flour choice or "Big Three" vs Supermicro</a></li>
<li><a href="../266477/index.html">Install JBoss BPM Suite</a></li>
<li><a href="../266479/index.html">Happy tickets up to 300 digits</a></li>
<li><a href="../266481/index.html">Work with Ansible - tasks with several unknowns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>