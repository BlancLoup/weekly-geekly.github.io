<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Results of the Russian Code Cup 2014 and analysis of tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On October 4, the final round of the Russian Code Cup, the largest annual sports programming competition in Russia, was held. The winner of the Russia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Results of the Russian Code Cup 2014 and analysis of tasks</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/5b2/fb9/77c/5b2fb977cb1b446eb4fa3999f001a245.jpg"></div><br>  On October 4, the final round of the <a href="https://www.russiancodecup.ru/">Russian Code Cup, the</a> largest annual sports programming competition in Russia, was held.  The winner of the Russian Code Cup 2014 and the owner of the main prize - $ 10,000 - was Gennady Korotkevich.  The second place was taken by Peter Mitrichev - he received $ 5000.  Egor Kulikov finished third, his cash prize was $ 3000.  Also this year, for the first time, all participants included in the top ten were awarded: owners of 4-10 places received $ 1,000 each. <br><a name="habracut"></a><br>  The final was held in a new online format for the championship.  Unlike the offline final of last year, the participants now did not have to come to Moscow, and the finalists solved all the proposed problems online, in a comfortable atmosphere for them.  Fifty finalists who overcame their qualifications and qualifying round fought for the title of the best programmer.  23 people from the finalists of this year participated in the final of the 2013 RCC. <br><br><h1>  Interesting Facts Finals </h1>  The simplest task is A, it was decided by 45 finalists.  The most difficult - F, for it was not a single attempt.  If we consider only solved problems, then E was the most difficult, only 3 finalists decided it, and Yevgeny Kapun did it first.  And Alexey Shlyunkin solved only this task. <br><br>  The finalists used to solve problems only 2 programming languages! <br>  C ++ - 254 decisions, 91 of them made <br>  Java - 52 decisions, 24 of them are made. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first correct decision - Peter Mitrichev at 23 minutes, this is the most difficult final for this indicator. <br><br>  The winner - Gennady Korotkevich - passed the fifth task in 1 minute 51 seconds before the end of the contest and came out on top.  Having passed the fifth task, Peter Mitrichev, Egor Kulikov or Dmitry Dzhulgakov could have outstripped him. <br><br>  Jacob Dlugach passed 3 tasks in the last hour, two in the last 16 minutes and burst into the top ten at the 7th place. <br><br><h1>  Analysis of tasks </h1>  <b><a href="https://www.russiancodecup.ru/championship/round/10/problem/A/">Task A.</a></b>  <b>A game</b> <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Time limit: 2 seconds <br>  Memory limit: 256 megabytes <br><br>  King Bytelandia holds an annual intellectual game.  According to the rules of the game, all participants are divided into two teams, and a set of hints is communicated to each of the players.  During the game, participants can exchange tips by the following rules: Each player of the first team can approach one player of the second and ask him for a hint, which he does not yet know.  If there are several such tips, a member of the second team will tell him any of his choice.  Each member of the first team can ask a hint only for one player of the second team, while several players can contact the player of the second team.  The first team wins if it manages to collect all the clues.  Help her captain find out whether his team will be able to collect all the clues, regardless of the answers of the second team. <br><br>  <b>Input format.</b>  The first line of the input file contains three integers n, m (1 ‚â§ <i>n</i> , <i>m</i> ‚â§ 500) and k (1 ‚â§ <i>k</i> ‚â§ 5000) - the sizes of the commands and the number of hints, respectively.  The following <i>n</i> + <i>m</i> lines contain information about prompts available to players at the beginning of the game in the following format.  The first number in the line corresponds to the number of prompts for the player, and the following numbers contain the numbers of the prompts - natural numbers not exceeding <i>k</i> . <br><br>  <b>The format of the output.</b>  If the first team can collect all the hints, output 1. In the first line of the output file n numbers, for each member of the first team, specify which of the players of the second team to ask for a hint.  If there are several answers, output any.  If the first team cannot collect all the hints in the first and only line, output 2. </div></div><br>  <b>Idea:</b> Anna Malova <br>  <b>Realization:</b> Anna Malova <br>  <b>Analysis:</b> Anna Malova <br><br>  Consider the bichromatic graph - the first team, the second team.  It is written on the edge, what prompts the participant of the second team owns, which the participant of the first team does not yet know, that is, the difference between the sets of participants' prompts.  We leave only those edges on which one number is written.  Among such edges we leave only those on which only one number is written. <br><br>  Using the constructed graph, we will make another bipartite graph: the vertices of the first beat are the participants of the first team, the tops of the second beat are those tips that are still unknown to the first team.  There is an edge between two vertices, if there was an edge in the previous bichrophic graph, coming from the same vertex on which this information was recorded.  If the resulting match contains the maximum matching, then the first team can win.  Otherwise, the first team cannot win. <br><br>  To meet the specified time limits, to find the difference of sets you need to use a bitset.  In addition, before launching Kuhn‚Äôs algorithm to search for the maximum matching, you need to compare the sizes of the shares, if the size of the share with the prompts exceeds the size of the share of participants, then the answer 2 is immediately given. <br><br>  <b>Video:</b> <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/uIolzdSy2-4%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhg5faYCVC3kfzrDOEdskZ3J995hcA" frameborder="0" allowfullscreen=""></iframe><br><br>  <b><a href="https://www.russiancodecup.ru/championship/round/10/problem/B/">Task B.</a></b>  <b>Painting the building</b> <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Time limit: 2 seconds <br>  Memory limit: 256 megabytes <br><br>  In one company, they decided to repaint the gray wall of their office with a length of n meters in corporate colors: blue and orange.  To do this, they bought an innovative robot painter. <br><br>  The robot can paint the walls in accordance with the program recorded in it.  The program is a sequence of commands.  Each command is given in two integers and a color and tells the robot what segment of the wall c is in which color to paint.  For example, a wall with a <i>BBOOO</i> coloring <i>plan</i> can be obtained using a program consisting of two teams: paint in blue from first meter to fifth, and then in orange from third to fifth. <br><br>  One of the programmers of the company was instructed to write a program that, having executed it, the robot would paint the walls in accordance with the given scheme.  He easily coped with the task and even wrote a program containing the minimum possible number of commands.  After that, he asked himself: how many programs exist of the same length that will paint the wall according to the coloring plan? <br><br>  <b>Input format.</b>  The first line contains the number <i>T</i> - the number of tests.  The following are descriptions of <i>T</i> tests. <br><br>  In the only line of the test, a line is given consisting of the letters <i>B</i> and <i>O</i> , where the letter in the <i>i</i> -th position is responsible for whether the i-meter of the wall is to be painted in blue or orange. <br><br>  The total length of the lines does not exceed 500,000. <br><br>  <b>The format of the output.</b>  For each of the <i>T</i> test cases, print a single number ‚Äî the number of programs of programs of minimal length leading to painting the fence accordingly.  Since the answer can be large, output the answer modulo 10 <sup>9</sup> + 7. </div></div><br>  <b>Idea:</b> Vitaly Aksyonov <br>  <b>Realization:</b> Nikolay Vedernikov <br>  <b>Analysis:</b> Nikolay Vedernikov <br><br>  The task required to paint the strip in two colors.  We are able to paint any subdivision in some color.  It was necessary to count the number of ways to paint a strip in the minimum number of colors. <br><br>  In this problem there are two cases: the ends of the strips are painted in one color or different.  Consider the first case. <br><br>  The ends are painted in one color, which means that the total segments are 2 <i>k</i> + 1. Let us show how many minimum colors are necessary.  Consider the final coloring of the strip, if the last segment we painted a segment in the middle, then the total number of segments increased by two (we broke a segment into two and added a new one).  In this way, we can extract <i>k</i> segments, and in the end remain 1. Total, we spent <i>k</i> + 1 moves.  If at some point we took a segment not from the middle, but from the edge, we will spend more moves than necessary. <br><br>  Now count the number of ways.  Consider the final coloring and the last move we painted a segment in the middle, then the number of ways to choose this segment is equal to the total number of segments minus extreme, total 2 <i>k</i> - 1. Thus, we reduced the task to a smaller task.  Continuing in this way, we get the final answer (2 <i>k</i> - 1) ¬∑ (2 <i>k</i> - 3) ¬∑ ... ¬∑ 3 ¬∑ 1, which is equal to (2 <i>k</i> - 1) !! .. <br><br>  Consider the case in which the ends are painted in different colors, then the entire segment 2 <i>k</i> .  Consider the final strip colorings.  Suppose that at the beginning we extracted segments from the middle <i>l</i> , and then extracted a segment with an edge.  Then we spent <i>l</i> + 1 and we had 2 <i>k</i> -2 <i>l</i> -1 segments, and the ends turned out to be the same color.  According to previous arguments, we can not color it faster than <i>k</i> - <i>l</i> .  Total: <i>k</i> +1 moves.  In addition, from this follow the fact that we paint the first move, a segment from one of the ends. <br><br>  Now count the number of ways.  Let's call the first segment black.  Let the first move we painted a segment from the left edge.  We will sort out how far he will paint, and everything that is to his right will have to be painted white, according to our reasoning.  Note that now we have two previous tasks, in which the ends are painted in one color.  Let in the left segment <i>l</i> black segments, then the answer on this segment will be ((2 <i>l</i> - 1) - 2) !!, and on the right ((2 <i>k</i> - (2 <i>l</i> - 1)) - 2) !! .. Except In addition, we can paint segments from the left half and from the right in any order.  That is, the product of the segments must also be multiplied by choose ( <i>l</i> - 1, <i>k</i> ), since we have already painted one segment, it means that we need to do more <i>k</i> colors, and on the left we have to make <i>l</i> - 1 colors.  In addition, the first segment, we could paint on, because we still paint on top of the right segment.  And such options are equal to the length of the right side.  So for a fixed number <i>l the</i> answer will be (( <i>l</i> - 3) !!) ¬∑ ((2 <i>k</i> - 2 <i>l</i> -1) !!) ¬∑ choose ( <i>l</i> - 1, <i>k</i> ) ¬∑ (suff_lenl).  Thus, let's iterate <i>l</i> and sum it up.  Similarly, we count for the other end. <br><br>  If we interpret factorials and inverse factorials by module, then for one <i>l</i> we will be able to answer for O (1).  The total running time is O ( <i>n</i> ). <br><br>  <b>Video:</b> <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/EjgDg034cf0%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhgPE-h7wnMZ-QSKVXXJgKHpBzEhYQ" frameborder="0" allowfullscreen=""></iframe><br><br>  <b><a href="https://www.russiancodecup.ru/championship/round/10/problem/C/">Task C.</a></b>  <b>Backpack problem</b> <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Time limit: 2 seconds <br>  Memory limit: 256 megabytes <br><br>  As a homework in computer science, Petya and Vasya were asked to write a program that would solve a backpack problem.  The task is formulated as follows: given <i>N</i> things with weights <i>a</i> <sub>i</sub> , is it possible to choose a subset of things with a total weight equal to exactly <i>W</i> ? <br><br>  Petya and Vasya successfully coped with the task, having received Accepted in the testing system.  But when discussing the problem, it turned out that Petya and Vasya used different approaches to the solution. <br><br>  It turned out that Vasya actually counted the number of ways to select a subset of things weighing <i>W</i> , and when printing the answer he compared this number with zero.  To simplify the implementation, Vasya did not count the number of methods, but his remainder from dividing by some number <i>m</i> .  Petya immediately declared that Vasya‚Äôs decision was wrong, but he could not come up with a test, on which it gives the wrong answer.  Can you find such a test? <br><br>  For a given <i>m,</i> create a test for a backpack problem in which the number of ways to gain weight <i>W</i> is divided by <i>m</i> without remainder. <br><br>  <b>Input format.</b>  The only line of the input file contains an integer <i>m</i> (1 ‚â§ <i>m</i> ‚â§ 10 <sup>18</sup> ) - the module for which calculations were made in the Vasya program. <br><br>  <b>The format of the output.</b>  If there is no such test, output a single number -1.  Otherwise, in the first line print two integers <i>N</i> and <i>W</i> separated with a space (1 ‚â§ <i>N</i> ‚â§ 200, 1 ‚â§ <i>W</i> ‚â§ 500).  In the next line print <i>N</i> integers <i>a</i> <sub>i</sub> (1 ‚â§ <i>a</i> <sub>i</sub> ‚â§ <i>W</i> ). </div></div><br>  <b>Idea:</b> Boris Minaev <br>  <b>Realization:</b> Artem Vasilyev <br>  <b>Analysis:</b> Artem Vasilyev <br><br>  In this problem, you need to find such a test for a backpack problem, that the number of ways to gain weight <i>W</i> is divided by the number <i>M.</i> <br><br>  Further we will consider <i>W</i> equal to 500. The main construction of the author's solution is based on generating such a set of <i>n</i> things of small weight so that their sum is less than <i>W / 2</i> .  Calculate for this set the number of ways to type a subset of things with a total weight <i>k</i> for all <i>k</i> from 0 to <i>W / 2</i> and denote this number by <i>ck</i> .  We require that for our dialing any number from 1 to 10 <sup>18 be</sup> represented as a sum of not more than 200 - <i>n</i> <i>ck</i> numbers. <br><br>  Suppose that there is such a set of things that for each <i>x</i> there is <i>k</i> such that <i>ck</i> = <i>2</i> x, then such a property would be obvious: for each <i>x</i> , if the binary record <i>M</i> contains a unit at position <i>x</i> , we add a thing with weight <i>W - x</i> in our set.  Since the sum of things added before this step was less than <i>W / 2</i> , it is easy to see that the number of ways to get weight <i>W</i> is equal to <i>M.</i>  Note that this process can be described by the following greedy algorithm: while <i>M is</i> greater than zero, we find the maximum <i>ck ‚â§ M</i> , add a thing with weight <i>W - k</i> and subtract the number <i>ck</i> from <i>M.</i> <br><br>  Unfortunately, it‚Äôs difficult to get such a set of things, so you need to come up with some other set of things that has the property that the above greedy algorithm finds a solution for any <i>M.</i>  To do this, take a set of things with a random low weight and the amount is less than <i>W / 2</i> .  You can check and make sure that if we choose our set in this way and count the numbers <i>ck</i> for it, the greedy algorithm will most likely return the correct partitioning of any number <i>M</i> into the terms <i>ck</i> .  Thus, it is possible to construct a set of things that satisfies this property, and using the greedy algorithm, add things in such a way that the number of ways to collect <i>W</i> becomes equal to 0 modulo <i>M.</i> <br><br>  <b>Video:</b> <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ZqHFSoPYWNg%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhj7zDsG__MXk50fgcZ_IHIonB_ZWQ" frameborder="0" allowfullscreen=""></iframe><br><br>  <b><a href="https://www.russiancodecup.ru/championship/round/10/problem/D/">Task D.</a></b>  <b>Networking</b> <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Time limit: 2 seconds <br>  Memory limit: 256 megabytes <br><br>  In one progressive country, the development of information technologies is in full swing!  High speeds were laid to be used for data transmission.  For ease of control over data flows and cost savings on laying, highways were laid out in such a way that data can reach from any city to any other in a unique way. <br><br>  However, it is not enough to lay the wires; you also need to develop routing algorithms.  During the discussions, the following data routing model was used: <i>k</i> cities are announced as key points and each of them is renamed ‚ÄúServergrad- <i>i</i> ‚Äù.  After that, each city gets a network address.  The network address of the city <i>v</i> will be an array of <i>k</i> elements, in which the <i>i-</i> th element is equal to the number of cities through which traffic must pass in order to get from city <i>v</i> to Servergrad- <i>i</i> . <br><br>  To avoid problems with routing, each city must have a unique address.  Also, the government wants Servergrads to be as small as possible.  Help the government decide which cities to use as Servergrades. <br><br>  <b>Input format.</b>  The first line contains the number n (2 ‚â§ <i>n</i> ‚â§ 100 000) - the number of cities in the country.  Further, in <i>n</i> - 1 line there are pairs of cities between which the highway is laid. <br><br>  <b>The format of the output.</b>  Print the number <i>k</i> - the minimum number of Servergrads, which is enough to ensure the correct routing of all cities.  Next, output <i>k</i> different integers from 1 to n, where the <i>i</i> -th number is responsible for which city will be chosen as Servergrad- <i>i-</i> th. </div></div><br>  <b>Idea:</b> Boris Minaev <br>  <b>Realization:</b> Andrey Komarov <br>  <b>Analysis:</b> Andrey Komarov <br><br>  In the problem, a tree was given and it was necessary to mark the minimum possible number of vertices so that the distance vectors from each vertex to the selected ones were different. <br><br>  Consider separately the case when a given tree is a <i>chain</i> : the vertices can be ordered in such a way that the first is associated only with the second, the last with only the last but one, and the rest with only two neighbors.  If a tree is a chain, then, obviously, as an answer, you can take one of the ends of this chain: all vertices will be removed from it at different distances. <br><br>  Otherwise, there is a peak of a degree greater than two in the tree.  Suspend a tree for this top.  We calculate the following dynamics for each subtree: the minimum number of labels that must be placed in this subtree so that the distance vectors for each pair of vertices of this subtree are different, provided that somewhere above the root of the subtree there is at least one marked vertex.  We call the value of this dynamics <i>min</i> ‚Üë.  Note that this is not exactly what needs to be calculated in the task, but this will coincide with the task if you remove the restriction on the existence above the root of the labeled vertex.  We call this dynamics <i>min</i> .  Note that <i>min ‚Üë ‚â§ min</i> .  So, if we can produce an answer of exactly <i>min</i> ‚Üë in size, this will be the answer to the problem.  We solve the problem in two stages - first we calculate the values ‚Äã‚Äãof <i>min</i> , and then we get an answer of this size. <br><br>  Suppose we want to calculate <i>min</i> ‚Üë for some vertex <i>v</i> .  We calculate these values ‚Äã‚Äãfor its subtrees.  We got that in some of them there is at least one tag, and in the other tags there is no.  Let the number of subtrees in which there are no labels be equal to <i>k</i> .  Then, in response to <i>v,</i> you need to add at least <i>k</i> - 1 labeled vertices (one for each unmarked subtree, except for one).  Suppose we have added less.  Then there are at least two unlabeled subtrees.  Then the roots of these subtrees will be indistinguishable: there are no marked vertices in their subtrees, and all other distances are the same.  Now we will show that these additions are enough.  Consider any two vertices from different subtrees.  They can be either at the same or at different depths.  Let them at different depths.  Then the distances from them to the intended labeled vertex above the root are different (the lengths of the paths to the root are different).  Let them at the same depth.  Then, by construction, at least in one of the subtrees in which these vertices lie, there is a labeled vertex.  Then the distances to it from these two selected vertices will be different: from the one from whose subtree the marked vertex is selected, the distance will be less. <br><br>  We now construct a <i>min</i>  answer.  The root we have chosen has at least three children.  Hence, by the construction of <i>min</i> ‚Üë, at least in two subtrees of the root there is a labeled vertex.  Therefore, for each subtree there is a labeled vertex outside this subtree.  Take it as the required <i>min</i> ‚Üë of the labeled vertex above.  Then the answer will be the union of the <i>min</i> ‚Üë answers for all children of the root. <br><br>  All considered operations can be done with one detour in depth.  Hence, the total running time is O ( <i>n</i> ). <br><br>  <b>Video:</b> <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/YIfCXgYEYwc%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhhDRAyvpG3cCio3ukACeEeBG_3ZSQ" frameborder="0" allowfullscreen=""></iframe><br><br>  <b><a href="https://www.russiancodecup.ru/championship/round/10/problem/E/">Task E.</a></b>  <b>Boolean tree</b> <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Time limit: 2 seconds <br>  Memory limit: 256 megabytes <br><br>  Acne very long thought how to solve a simple little problem, and in the process of coming up with a solution I drew a graph on the board.  This graph, by coincidence, turned out to be a root tree.  At this moment Borya came up to the blackboard, and began to write expressions in some vertices of the tree, in which different values ‚Äã‚Äãwere assigned to Boolean variables. <br><br>  After that, they introduced a rule according to which for each vertex of the tree, you can determine the value of the variable in this vertex.  Namely, if the assignment of this variable to a value was recorded at this vertex, then the last such value is used.  If thus the value could not be determined, then the value of this variable is taken in the nearest ancestor of this vertex, in which the assignment of the value of this variable is recorded.  If the vertex has no such ancestor, then the value is undefined. <br><br>  After several operations, they wanted to calculate for a given variable in how many leaves of the tree the value of this variable is true, in how many false, and in how many is not defined.  And then they realized that it was difficult, and that they could not do it.  Therefore, they ask you to help them, and after each addition of the entry on assigning a value to a variable, determine for how many leaves the value of this variable is true, for how many false, and for how many is not defined. <br><br>  <b>Input format.</b>  The first line contains the number <i>T</i> - the number of tests.  The following is a description of <i>T</i> tests. <br><br>  The first line of the test gives two natural numbers <i>n</i> and <i>m</i> (1 ‚â§ <i>n</i> , <i>m</i> ‚â§ 10 <sup>5</sup> ), where n is the number of vertices of a given tree, and <i>m</i> is the number of additions of new entries about assigning a value to a variable.  The second line contains <i>n</i> numbers, where the <i>i</i> -th number is the ancestor number of the <i>i</i> -th vertex.  For the root, this number is zero.  It is guaranteed that you are given exactly the tree.  Next come <i>m</i> lines - record descriptions.  Each of these lines contains three numbers: <i>v</i> is the number of the vertex, <i>x</i> is the number of the variable, and <i>b</i> is zero or one if the value of the variable is false or true, respectively.  The variable number is a positive integer not exceeding 10 <sup>5</sup> . <br><br>  In each set of input data, the sum of all <i>n</i> and the sum of all <i>m</i> does not exceed 10 <sup>5</sup> . <br><br>  <b>The format of the output.</b>  For each of the test examples, output m lines containing three numbers ‚Äî the number of leaves of the tree for which the value of the variable just written is true, false, and not defined, respectively. </div></div><br>  <b>Idea:</b> Boris Minaev <br>  <b>Implementation:</b> Demid Kucherenko <br>  <b>Analysis:</b> Vitalik Aksenov <br><br>  To begin with, we will reduce our task to the one variable problem.  Let's create a tree for each variable, in which the initial tree will contain the root of the original tree and a link to it.  The link in the tree will always point to the top, in whose subtree we are now.  Let's go around our tree bypassing in depth.  If we go to the top in which some variable is set, then we create a new child at the top in the corresponding tree and rearrange the link to it.  If we exit the vertex, then we rearrange the link in its corresponding tree to its ancestor.  We squeezed the trees.  It is necessary to remember to keep in each vertex the number of leaves in its subtree. <br><br>  We will now solve the problem on the tree for one variable.  We will process all requests for this variable sequentially.  We need to be able to do two things: <br><ul><li>  how many leaves only this vertex affects; </li><li>  find the closest ancestor, in which some value is set for this variable. </li></ul><br>  If we implement this, processing the request is not very difficult: <br><ul><li>  find the number of leaves affected by this vertex - <i>x</i> ; </li><li>  we find the closest ancestor, in which some value is set for this variable - <i>p</i> ; </li><li>  if in <i>p</i> the same value as at our vertex, then the number does not change; </li><li>  if <i>p is a</i> different value than at our vertex, then the number changes to <i>x</i> ; </li><li>  if <i>p</i> does not exist, the number changes to <i>x *</i> then the number of ‚Äúunknown‚Äù leaves decreases by <i>x</i> ; </li><li>  <i>p</i> must reduce the number of leaves affected by <i>x</i> </li></ul><br>  To implement queries, you need to expand the tree into a segment tree, where you can make a query on a subtree.  Then requests of the first kind are very easy to handle using the sum in the subtree.  To find the correct ancestor, we will do the following: when we make a request to a vertex, we add one to all the vertices in the subtree, that is, we say that they are covered by another vertex.  Then, in order to find the ancestor, we will look for the binary rise of the first position, in which the value differs by one - it will be the desired ancestor. <br><br>  <i>Total</i> running time: O ( <i>mlog</i> <sup>2</sup> <i>n</i> ), where <i>n</i> is the size of the tree, <i>m</i> is the number of requests. <br><br>  <b>Video:</b> <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/BbkGkKtBfXk%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhiUHoG_Mz74IUX-py2ZASUUy1mi4g" frameborder="0" allowfullscreen=""></iframe><br><br>  <b><a href="https://www.russiancodecup.ru/championship/round/10/problem/F/">Task F.</a></b>  <b>Robot</b> <br><br><div class="spoiler">  <b class="spoiler_title">The task</b> <div class="spoiler_text">  Time limit: 8 seconds <br>  Memory limit: 256 megabytes <br><br>  A robot travels through a rectangular cell field consisting of <i>n</i> columns and <i>m</i> rows.  He can begin his journey in any cell of the first row.  Then he can make some (possibly zero) number of moves.  Let the robot stand in the column <i>x</i> and row <i>y</i> , then in one move it can go either into the cell ( <i>x</i> + 1, <i>y</i> + 1) or into the cell ( <i>x</i> - 1, <i>y</i> + 1).  Of course, the robot can not go beyond the field. <br><br>  The journey of the robot is complicated by the fact that there are rectangular obstacles on the field, the sides of which are parallel to the sides of the field.  The robot can not go into the cage, which is covered by an obstacle.  No two obstacles intersect, but they can touch. <br><br>  You need to count the number of cells that can get a robot. <br><br><img src="https://habrastorage.org/files/fb2/c0b/509/fb2c0b509a7541b088df6acb82a21fcb.png"><br><br>  <b>Input format.</b>  The first line contains the number <i>T</i> - the number of tests.  The following is a description of <i>T</i> tests. <br><br>  The first line of the test contains two integers n and m (1 ‚â§ <i>n</i> , <i>m</i> ‚â§ 10 <sup>9</sup> ) - the number of columns and rows per field.  The next line contains one integer <i>k</i> (1 ‚â§ <i>k</i> ‚â§ 10 <sup>5</sup> ) - the number of barriers on the field.  The following <i>k</i> lines contain a description of the obstacles.  Each such line consists of four integers <i>x</i> <sub>1</sub> , <i>y</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , <i>y</i> <sub>2</sub> , denoting the coordinates of the opposite obstacle angles (1 ‚â§ <i>x</i> <sub>1</sub> ‚â§ <i>x</i> <sub>2</sub> ‚â§ n, 2 ‚â§ <i>y</i> <sub>1</sub> ‚â§ <i>y</i> <sub>2</sub> ‚â§ <i>m</i> ).  It is guaranteed that the obstacles do not intersect. <br><br>  The total number of obstacles in the input file does not exceed 10 <sup>5</sup> . <br><br>  <b>The format of the output.</b>  For each of the <i>T</i> test examples, print one number - the number of cells that the robot can visit. </div></div><br>  <b>Idea:</b> Boris Minaev <br>  <b>Realization:</b> Boris Minaev <br>  <b>Analysis:</b> Boris Minaev <br><br>  In the task it was necessary to count the number of cells that are reachable from the first line of the field.  The main difficulty lies in the fact that the size of each side of the field can reach 10 <sup>9</sup> cells. <br><br>  Firstly, due to the fact that the robot performs moves diagonally, it is convenient to separately consider cells of different parity.  The robot can reach all the cells of the first line of the field.  We will increase <i>y</i> and recalculate reachable cells.  It is most convenient to store a set of reachable cells for a string in the form of a union of disjoint segments.  Then you can easily recalculate the set when moving to the next line.  Namely, one cell will be added to each segment on each side.  Some segments may merge into one, and some will intersect with field boundaries or barriers. <br><br>  Learn to effectively change this set of segments.  It is best to store it in a data structure that allows you to find a segment that crosses a given coordinate in O (log <i>n</i> ).  Additionally, for each segment we will keep information on whether the segment can increase to the left and to the right.  Let's carefully consider all the events that can occur: <br><ul><li>  Two segments joined together.  This is the easiest case.  You just need to combine them in the data structure. </li><li>  The segment has expanded to such an extent that it crossed with the edge of the field or an obstacle.  Then you need to put a mark in the description of the segment that it can no longer grow in some direction. </li><li>  The barrier has begun.  It is necessary to consider all segments that intersect with the barrier.  Some of them need to be completely removed, some trimmed, and some divided into two parts.  It is also necessary to create events that will occur when neighboring segments grow so large that they cross the current barrier. </li><li>  The barrier is over.  It is necessary to find two adjacent segments and mark them that they can grow in the direction of the rectangle.  You also need to add an event that should occur between neighbors.  For example, if two neighbors are segments, then they may merge at some point.  If one of them is a segment, and the other is an obstacle, then they may intersect.  In other cases, do not add anything. </li></ul><br>  Also note that all segments need to be stored lazily.  That is, changing their size, as well as recalculating the total number of accessible cells, is necessary only when a certain event occurs that affects a given segment. <br><br>  Solution time is O ( <i>n</i> log ( <i>n</i> )), where <i>n</i> is the total number of barriers. <br><br>  <b>Video:</b> <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/WOJy0TA9cc4%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhgMaoAaXaGwVRwTyC1Y_ZaQivdxnw" frameborder="0" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/239681/">https://habr.com/ru/post/239681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239669/index.html">LTE Direct: communication without base stations</a></li>
<li><a href="../239671/index.html">We invite you to a lecture and a seminar by Vitaly Friedman</a></li>
<li><a href="../239673/index.html">DataTalks: Data Analysis for Solving Business Problems</a></li>
<li><a href="../239675/index.html">New features of IT services in the release of the program Alloy Navigator 7</a></li>
<li><a href="../239679/index.html">Charming marketing</a></li>
<li><a href="../239685/index.html">Successful and unsuccessful expeditions to Mars and the orbit of Mars: infographics</a></li>
<li><a href="../239689/index.html">Windows Phone Store Games - 5% conversion without marketing</a></li>
<li><a href="../239693/index.html">Clouds through the eyes of IT professionals: vision and expectations</a></li>
<li><a href="../239697/index.html">Share and update! Save space, time and server resources 1C</a></li>
<li><a href="../239699/index.html">How to automatically back up MySQL database and Web server to FTP repository</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>