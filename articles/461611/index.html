<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Verilog Cache Implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article discusses the simplest RAM implementation in Verilog. 

 Before proceeding with code parsing, it is recommended that you learn the basic ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Verilog Cache Implementation</h1><div class="post__text post__text-html js-mediator-article">  This article discusses the simplest RAM implementation in Verilog. <br><br>  Before proceeding with code parsing, it is recommended that you learn the basic syntax of Verilog. <br><br>  <a href="http://www.asic-world.com/verilog/veritut.html">Here you can find training materials</a> . <br><a name="habracut"></a><br><h3>  RAM </h3><br><h4>  Step 1: declaring the module with the corresponding input / output signals </h4><br><pre><code class="plaintext hljs">module ram ( input [word_size - 1:0] data, input [word_size - 1:0] addr, input wr, input clk, output response, output [word_size - 1:0] out ); parameter word_size = 32;</code> </pre> <br><ul><li>  <b>data</b> - data to write. </li><li>  <b>addr</b> - address to the memory in RAM. </li><li>  <b>wr</b> - status (read / write). </li><li>  <b>clk</b> - clock cycle system. </li><li>  <b>response</b> - RAM readiness (1 - if RAM processed the read / write request, 0 - otherwise). </li><li>  <b>out</b> - data read from RAM. </li></ul><br>  This implementation was integrated into Altera Max 10 FPGA, which has a 32-bit architecture, and therefore the size for data and address (word_size) is 32 bits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Step 2: declaring the registers inside the module </h4><br>  An array declaration for storing data: <br><br><pre> <code class="plaintext hljs">parameter size = 1&lt;&lt;32; reg [word_size-1:0] ram [size-1:0];</code> </pre><br>  We will also need to store the previous input parameters in order to track their changes in the always block: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_reg; reg [word_size-1:0] addr_reg; reg wr_reg;</code> </pre><br>  And the last two registers for updating the output signals after calculations in the always block: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] out_reg; reg response_reg;</code> </pre><br>  We initialize the registers: <br><br><pre> <code class="plaintext hljs">initial begin response_reg = 1; data_reg = 0; addr_reg = 0; wr_reg = 0; end</code> </pre><br><h4>  Step 3: implementing the always logic of the block </h4><br><pre> <code class="plaintext hljs">always @(negedge clk) begin if ((data != data_reg) || (addr%size != addr_reg)|| (wr != wr_reg)) begin response_reg = 0; data_reg = data; addr_reg = addr%size; wr_reg = wr; end else begin if (response_reg == 0) begin if (wr) ram[addr] = data; else out_reg = ram[addr]; response_reg = 1; end end end</code> </pre><br>  Always block is triggered by negedje, i.e.  at the moment the clock moves from 1 to 0. This is done to correctly synchronize the RAM with the cache.  Otherwise, there may be cases when the RAM does not have time to reset the ready status from 1 to 0 and at the next clock, the cache decides that the RAM has successfully processed its request, which is fundamentally wrong. <br><br>  The logic of the always block algorithm is as follows: if the data is updated, reset the readiness status to 0 and write / read data, if the write / read is completed, we update the readiness status to 1. <br><br>  At the end, add the following code section: <br><br><pre> <code class="plaintext hljs">assign out = out_reg; assign response = response_reg;</code> </pre><br>  The type of output signals of our module is wire.  The only way to change signals of this type is long-term assignment, which is forbidden inside the always block.  For this reason, the always block uses registers, which are subsequently assigned to the output signals. <br><br><h3>  Direct mapping cache </h3><br>  Direct mapping cache is one of the simplest types of cache.  In this implementation, the cache consists of n elements, and RAM is conditionally divided into blocks by n, then the i-th element in the cache corresponds to all such k-th elements in RAM that satisfy the condition i = k% n. <br><br>  The image below shows a cache of size 4 and RAM size of 16. <br><br><img src="https://habrastorage.org/webt/k9/a-/_4/k9a-_4tdp2uqa6jmzqtcx7p5tfm.png"><br><br>  Each cache element contains the following information: <br><br><ul><li>  <b>validity bit</b> - whether the information in the cache is relevant. </li><li>  <b>tag</b> is the block number in RAM where this element is located. </li><li>  <b>data</b> - information that we write / read. </li></ul><br>  When requested to read, the cache divides the input address into two parts - a tag and an index.  The size of the index is log (n), where n is the size of the cache. <br><br><h4>  Step 1: declaring the module with the corresponding input / output signals </h4><br><pre> <code class="plaintext hljs">module direct_mapping_cache ( input [word_size-1:0] data, input [word_size-1:0] addr, input wr, input clk, output response, output is_missrate, output [word_size-1:0] out ); parameter word_size = 32;</code> </pre><br>  The declaration of the cache module is identical to RAM, with the exception of the new output signal is_missrate.  This output stores information about whether the last read request was missrate. <br><br><h4>  Step 2: declaring the registers and RAM </h4><br>  Before declaring the registers, we determine the size of the cache and index: <br><br><pre> <code class="plaintext hljs">parameter size = 64; parameter index_size = 6;</code> </pre><br>  Next, we declare an array in which the data that we write and read will be stored: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_array [size-1:0];</code> </pre><br>  We also need to store validity bits and tags for each item in the cache: <br><br><pre> <code class="plaintext hljs">reg validity_array [size-1:0]; reg [word_size-index_size-1:0] tag_array [size-1:0]; reg [index_size-1:0] index_array [size-1:0];</code> </pre><br>  Registers into which the input address will be split: <br><br><pre> <code class="plaintext hljs">reg [word_size-index_size-1:0] tag; reg [index_size-1:0] index;</code> </pre><br>  Registers that store the input values ‚Äã‚Äãon the previous clock (for tracking changes in input data): <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] data_reg; reg [word_size-1:0] addr_reg; reg wr_reg;</code> </pre><br>  Registers for updating the output signals after calculations in the always block: <br><br><pre> <code class="plaintext hljs">reg response_reg; reg is_missrate_reg; reg [word_size-1:0] out_reg;</code> </pre><br>  Input Values ‚Äã‚Äãfor RAM: <br><br><pre> <code class="plaintext hljs">reg [word_size-1:0] ram_data; reg [word_size-1:0] ram_addr; reg ram_wr;</code> </pre><br>  Output values ‚Äã‚Äãfor RAM: <br><br><pre> <code class="plaintext hljs">wire ram_response; wire [word_size-1:0] ram_out;</code> </pre><br>  Declaring a RAM module and connecting input and output signals: <br><br><pre> <code class="plaintext hljs">ram ram( .data(ram_data), .addr(ram_addr), .wr(ram_wr), .clk(clk), .response(ram_response), .out(ram_out));</code> </pre><br>  Register initialization: <br><br><pre> <code class="plaintext hljs">initial integer i initial begin data_reg = 0; addr_reg = 0; wr_reg = 0; for (i = 0; i &lt; size; i=i+1) begin data_array[i] = 0; tag_array[i] = 0; validity_array[i] = 0; end end</code> </pre><br><h4>  Step 3: implementing the always logic of the block </h4><br>  To begin with, for each clock we have two states - the input data is changed or not changed.  Based on this, we have the following condition: <br><br><pre> <code class="plaintext hljs">always @(posedge clk) begin if (data_reg != data || addr_reg != addr || wr_reg != wr) begin end // 1:    else begin // 2:     end end</code> </pre><br>  <b>Block 1.</b> In case the input data is changed, the first thing we do is reset the readiness status to 0: <br><br><pre> <code class="plaintext hljs">response_reg = 0;</code> </pre><br>  Next, we update the registers that stored the input values ‚Äã‚Äãof the previous clock: <br><br><pre> <code class="plaintext hljs">data_reg = data; addr_reg = addr; wr_reg = wr;</code> </pre><br>  We break the input address into a tag and index: <br><br><pre> <code class="plaintext hljs">tag = addr &gt;&gt; index_size; index = addr;</code> </pre><br>  To calculate the tag, a bitwise shift to the right is used, for the index, it is enough to simply assign, because  Extra bits of the address are not taken into account. <br><br>  The next step is to choose between writing and reading: <br><br><pre> <code class="plaintext hljs">if (wr) begin //  data_array[index] = data; tag_array[index] = tag; validity_array[index] = 1; ram_data = data; ram_addr = addr; ram_wr = wr; end else begin //  if ((validity_array[index]) &amp;&amp; (tag == tag_array[index])) begin //    is_missrate_reg = 0; out_reg = data_array[index]; response_reg = 1; end else begin //     is_missrate_reg = 1; ram_data = data; ram_addr = addr; ram_wr = wr; end end</code> </pre><br>  In the case of recording, we initially modify the data in the cache, then update the input data for RAM.  In the case of reading, we check for the presence of this element in the cache and, if it exists, write it to out_reg, otherwise we access RAM. <br><br>  <b>Block 2.</b> If the data has not been changed since the previous clock was executed, then we have the following code: <br><br><pre> <code class="plaintext hljs">if ((ram_response) &amp;&amp; (!response_reg)) begin if (wr == 0) begin validity_array [index] = 1; data_array [index] = ram_out; tag_array[index] = tag; out_reg = ram_out; end response_reg = 1; end</code> </pre><br>  Here we are waiting for the completion of the access to RAM (if there was no access, ram_response is 1), we update the data if there was a read command and set the cache readiness to 1. <br><br>  And last, update the output values: <br><br><pre> <code class="plaintext hljs">assign out = out_reg; assign is_missrate = is_missrate_reg; assign response = response_reg;</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/461611/">https://habr.com/ru/post/461611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46160/index.html">Google turns off experiments</a></li>
<li><a href="../461601/index.html">What a non-technical founder should know about software development</a></li>
<li><a href="../461605/index.html">Creating Tower Defense in Unity: Ballistics</a></li>
<li><a href="../461607/index.html">How Apple Lightning Video Adapter Works</a></li>
<li><a href="../46161/index.html">Debian stuff - apt-rdepends</a></li>
<li><a href="../461613/index.html">Battery self-study</a></li>
<li><a href="../461615/index.html">4 deadly sins of TWS headphones: why is True Wireless still not a mess?</a></li>
<li><a href="../461617/index.html">Theory of a Successful Startup</a></li>
<li><a href="../46162/index.html">iQue Grill - grill with computer and built-in stereo system</a></li>
<li><a href="../461621/index.html">Is it hard to write your first VHDL program?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>