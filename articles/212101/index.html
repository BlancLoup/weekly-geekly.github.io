<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cross-platform https server with non-blocking sockets. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I continue to improve single-threaded https server on non-blocking sockets. Previous articles with links to source code can be found ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cross-platform https server with non-blocking sockets. Part 3</h1><div class="post__text post__text-html js-mediator-article">  In this article, I continue to improve single-threaded https server on non-blocking sockets.  Previous articles with links to source code can be found here: <br>  <a href="http://habrahabr.ru/post/211474/">The easiest cross-platform server with ssl support</a> <br>  <a href="http://habrahabr.ru/post/211661/">Cross-platform https server with non-blocking sockets</a> <br>  <a href="http://habrahabr.ru/post/211853/">Cross-platform https server with non-blocking sockets.</a>  <a href="http://habrahabr.ru/post/211853/">Part 2</a> <br><br>  At the end of this article there will be a link to the source code of the server, which I tested in Visual Studio 2012 (Windows 8 64bit), g ++ 4.4 (Linux 32bit), g ++ 4.6 (Linux 64bit).  The server accepts connections from any number of clients and sends request headers in response. <br>  But I begin the article perhaps with answers to some of the comments to the previous ones. <br><a name="habracut"></a><br><br>  Firstly, having received a lot of negative feedback about the unusualness of my code, from now on I decided to place my articles in the ‚ÄúAbnormal Programming‚Äù hub. <br>  Secondly, I decided not to tick the ‚Äútutorial‚Äù anymore: someone will find something new in my articles, and to someone they seem amateurish.  I'm not against‚Ä¶ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Now about my programming style:</b> <br>  1. I will continue to write code in the header files for a number of reasons: <br>  a) I want to know the full number of lines of code without additional gestures and therefore it is more convenient for me. <br>  b) At any moment I may want to screw the template to the client or server, and I would not like to rewrite all the code for this. <br>  Those who are sure that since I can‚Äôt do it, you can teach the creators of stl and boost programming first, and then rename the server.h file to server.cpp and it will be good for everyone ... <br><br>  2. I will leave an infinite loop in the constructor for one reason: I think this approach is correct.  If a class does nothing more than changing its internal variables, then the most correct thing is to leave this class a single public function: its constructor. <br>  You can of course in this case without a class at all, but I‚Äôm somehow more familiar with the class, and I don‚Äôt need global functions from scratch either. <br><br>  3. I will not use std :: copy instead of memcpy for one reason: std :: copy - a brake! <br><br>  Finally I want to thank everyone who was not too lazy to compile the source and point out some errors.  I tried to take them into account and correct. <br><br>  <b>Now about the main thing.</b> <br>  In order for the server from the previous article to finally prepare to parse the request headers and distribute files, it remains to make one small addition: to start instead of an endless loop, use functions specially designed for passively waiting for network events. <br>  There are several such functions in Windows and Linux, I suggest using select on Windows and epoll on Linux. <br><br>  There is a problem that the epoll function in Windows does not exist.  To make the code look consistent on all systems, let's write the server code as if there is an epoll in Windows! <br><br>  <b>A simple implementation of epoll for Windows with select</b> <br>  1. Add to the Visual Studio project two empty files from the same directory as ‚Äúserver.h‚Äù.  Files: ‚Äúepoll.h‚Äù and ‚Äúepoll.cpp‚Äù. <br>  2. Transfer the definitions of constants, structures and functions from the epoll documentation to the epoll.h file: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __linux__ enum EPOLL_EVENTS { EPOLLIN = 0x001, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLIN EPOLLIN EPOLLPRI = 0x002, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLPRI EPOLLPRI EPOLLOUT = 0x004, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLOUT EPOLLOUT EPOLLRDNORM = 0x040, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLRDNORM EPOLLRDNORM EPOLLRDBAND = 0x080, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLRDBAND EPOLLRDBAND EPOLLWRNORM = 0x100, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLWRNORM EPOLLWRNORM EPOLLWRBAND = 0x200, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLWRBAND EPOLLWRBAND EPOLLMSG = 0x400, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLMSG EPOLLMSG EPOLLERR = 0x008, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLERR EPOLLERR EPOLLHUP = 0x010, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLHUP EPOLLHUP EPOLLRDHUP = 0x2000, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLRDHUP EPOLLRDHUP EPOLLONESHOT = (1 &lt;&lt; 30), #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLONESHOT EPOLLONESHOT EPOLLET = (1 &lt;&lt; 31) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLLET EPOLLET }; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl(). */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLL_CTL_ADD 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add a file descriptor to the interface. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLL_CTL_DEL 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Remove a file descriptor from the interface. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPOLL_CTL_MOD 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Change file descriptor epoll_event structure. */</span></span></span><span class="hljs-meta"> typedef union epoll_data { void *ptr; int fd; unsigned int u32; unsigned __int64 u64; } epoll_data_t; struct epoll_event { unsigned __int64 events; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Epoll events */</span></span></span><span class="hljs-meta"> epoll_data_t data; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* User data variable */</span></span></span><span class="hljs-meta"> }; int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><br>  3. In the epoll.cpp file we add headers, as well as a global variable in which sockets and their states will be stored: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"epoll.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;map&gt; #ifndef WIN32 #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;netdb.h&gt; #else #include &lt;io.h&gt; #include &lt;Winsock2.h&gt; #pragma comment(lib, "ws2_32.lib") #endif std::map&lt;int, epoll_event&gt; g_mapSockets;</span></span></span></span></code> </pre><br><br>  4. Add the code for the first function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">epoll_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  What's going on here? <br>  As far as I can tell from the documentation: the original Linux code on every call to epoll_create creates a file that stores the states of the sockets.  Apparently this is necessary in multi-threaded processes. <br>  We have a single-threaded process and we do not need more than one structure for storing sockets.  Therefore, epoll_create is a stub. <br><br>  5. Using stl, adding and removing sockets in memory is as simple as: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">epoll_ctl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> epfd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> op, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, struct epoll_event *event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EPOLL_CTL_ADD: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EPOLL_CTL_MOD: g_mapSockets[fd] = *event; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EPOLL_CTL_DEL: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g_mapSockets.find(fd) == g_mapSockets.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; g_mapSockets.erase(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  6. Finally, the main thing: we implement the waiting function through select <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">epoll_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> epfd, struct epoll_event *events, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxevents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!events) || (!maxevents)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      select fd_set readfds, writefds, exceptfds; FD_ZERO(&amp;readfds); FD_ZERO(&amp;writefds); FD_ZERO(&amp;exceptfds); //   int nFDS = 0; for (auto it=g_mapSockets.begin(); it != g_mapSockets.end(); ++it) { if (it-&gt;first == -1) continue; if (it-&gt;first &gt; nFDS) nFDS = it-&gt;first; FD_SET(it-&gt;first, &amp;readfds); FD_SET(it-&gt;first, &amp;writefds); FD_SET(it-&gt;first, &amp;exceptfds); } //   struct timeval tv; tv.tv_sec = timeout/1000; tv.tv_usec = timeout - tv.tv_sec*1000; //  nFDS++; select(nFDS, &amp;readfds, &amp;writefds, &amp;exceptfds, &amp;tv); //     ,     epoll int nRetEvents = 0; for (auto it=g_mapSockets.begin(); (it != g_mapSockets.end() &amp;&amp; nRetEvents &lt; maxevents); ++it) { if (it-&gt;first == -1) continue; if (!FD_ISSET(it-&gt;first, &amp;readfds) &amp;&amp; !FD_ISSET(it-&gt;first, &amp;writefds) &amp;&amp; !FD_ISSET(it-&gt;first, &amp;exceptfds)) continue; memcpy(&amp;events[nRetEvents].data, &amp;it-&gt;second.data, sizeof(epoll_data)); if (FD_ISSET(it-&gt;first, &amp;readfds)) events[nRetEvents].events |= EPOLLIN; if (FD_ISSET(it-&gt;first, &amp;writefds)) events[nRetEvents].events |= EPOLLOUT; if (FD_ISSET(it-&gt;first, &amp;exceptfds)) events[nRetEvents].events |= EPOLLERR; nRetEvents++; } return nRetEvents; }</span></span></code> </pre><br><br>  That's all.  The epoll feature for Windows is implemented! <br><br>  <b>Adding epoll to the server</b> <br><br>  1. Add to headers: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __linux__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/epoll.h&gt; #else #include "epoll.h" #endif</span></span></span></span></code> </pre><br><br>  2. Add the following lines to the CServer class: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   struct epoll_event m_ListenEvent; //   vector&lt;struct epoll_event&gt; m_events; int m_epoll;</span></span></code> </pre><br><br>  3. In the CServer constructor, all that after calling the listen function is changed to: <br><pre> <code class="cpp hljs"> m_epoll = epoll_create (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_epoll == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"error: epoll_create\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_ListenEvent.data.fd = listen_sd; m_ListenEvent.events = EPOLLIN | EPOLLET; epoll_ctl (m_epoll, EPOLL_CTL_ADD, listen_sd, &amp;m_ListenEvent); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m_events.resize(m_mapClients.size()+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = epoll_wait (m_epoll, &amp;m_events[<span class="hljs-number"><span class="hljs-number">0</span></span>], m_events.size(), <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; Callback(n); }</code> </pre><br><br>  4. We change the old CServer :: Callback function to a new one: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nCount; i++) { SOCKET hSocketIn = m_events[i].data.fd; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_ListenEvent.data.fd == (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)hSocketIn) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_events[i].events == EPOLLIN) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sa_cli</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> client_len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sa_cli); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 const SOCKET sd = accept (hSocketIn, (struct sockaddr*) &amp;sa_cli, (int *)&amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> const SOCKET sd = accept (hSocketIn, (struct sockaddr*) &amp;sa_cli, (socklen_t *)&amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sd != INVALID_SOCKET) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      m_mapClients[sd] = shared_ptr&lt;CClient&gt;(new CClient(sd)); auto it = m_mapClients.find(sd); if (it == m_mapClients.end()) continue; //    epoll struct epoll_event ev = it-&gt;second-&gt;GetEvent(); epoll_ctl (m_epoll, EPOLL_CTL_ADD, it-&gt;first, &amp;ev); } continue; } auto it = m_mapClients.find(hSocketIn); //    if (it == m_mapClients.end()) continue; if (!it-&gt;second-&gt;Continue()) // -   { //   false,     epoll     epoll_ctl (m_epoll, EPOLL_CTL_DEL, it-&gt;first, NULL); m_mapClients.erase(it); } } }</span></span></span></span></code> </pre><br><br>  With the server class finished, it remains to deal with the CClient class. <br>  Add the following code to it: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   struct epoll_event m_ClientEvent; public: const struct epoll_event GetEvent() const {return m_ClientEvent;}</span></span></code> </pre><br><br>  And with this the addition of the epoll support code is complete! <br><br>  Here is a project for Visual Studio: <a href="http://l0.3s3s.org/">l0.3s3s.org</a> <br>  To compile to Linux, the epoll.h and epoll.cpp files are not needed, that is, everything is as usual: ‚Äúcopy the following files into one directory: serv.cpp, server.h, ca-cert.pem and type in the command line:‚Äú g ++ -std = c ++ 0x -L / usr / lib -lssl -lcrypto serv.cpp ¬ª‚Äû <br><br>  <a href="http://habrahabr.ru/post/213301/">Continuation</a> </div><p>Source: <a href="https://habr.com/ru/post/212101/">https://habr.com/ru/post/212101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212091/index.html">Installing VLC Player violates the warranty of the speakers in a Dell laptop</a></li>
<li><a href="../212093/index.html">Automatic light and music ASIM-AU-2-6</a></li>
<li><a href="../212095/index.html">Galois field arithmetic for encoding information by Reed-Solomon codes</a></li>
<li><a href="../212097/index.html">Electronics manufacturing in China - what to expect?</a></li>
<li><a href="../212099/index.html">Player from Playboy magazine (continuation of the epic)</a></li>
<li><a href="../212103/index.html">Web Analytics Popularity</a></li>
<li><a href="../212105/index.html">Tim Berners-Lee: we need to decentralize the Internet again</a></li>
<li><a href="../212107/index.html">Creating a simple Chrome application</a></li>
<li><a href="../212109/index.html">Godot game engine put into public use</a></li>
<li><a href="../212111/index.html">How to write your component for iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>