<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real-time OS AQUA RTOS for AVR MK in BASCOM AVR environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When writing code for an MK, it is more complicated than ‚Äúblinking a light bulb‚Äù, the developer is faced with the limitations inherent in linear progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real-time OS AQUA RTOS for AVR MK in BASCOM AVR environment</h1><div class="post__text post__text-html js-mediator-article">  When writing code for an MK, it is more complicated than ‚Äúblinking a light bulb‚Äù, the developer is faced with the limitations inherent in linear programming in the ‚Äúsuper cycle plus interrupt‚Äù style.  Interrupt handling requires quickness and brevity, which leads to the addition of flags to the code and bringing the project to the style ‚Äúsuper cycle with interrupts and flags‚Äù. <br><br>  If the complexity of the system increases, the number of interdependent flags grows exponentially, and the project quickly turns into a poorly readable and manageable macaroni code. <br><br>  The use of real-time operating systems helps to get rid of the ‚Äúmacaroni code‚Äù and return the complex project on the MC to flexibility and control. <br>  Several real-time cooperative operating systems have been developed and quite popular for AVR microcontrollers.  However, all of them are written in C or Assembler and are not suitable for those who program MK in the BASCOM AVR environment, depriving them of such a useful tool for writing serious applications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To remedy this shortcoming, I developed a simple RTOS for the BASCOM AVR programming environment, which I bring to the court of readers. <br><br><img src="https://i.pinimg.com/originals/76/c8/d2/76c8d296a4940f32279d2e90a53d5162.jpg" alt="image"><br><a name="habracut"></a><br>  For many, the familiar MK programming style is the so-called.  <i>super cycle</i>  The code consists of a set of functions, procedures and descriptors (constants, variables), possibly library ones, generally referred to as ‚Äúbackground code‚Äù, as well as a large infinite loop enclosed in a <b>do-loop</b> type structure.  At start-up, the equipment of the MK itself and external devices are first initialized, constants and initial values ‚Äã‚Äãof variables are set, and then control is transferred to this infinite supercycle. <br>  The simplicity of the supercycle is obvious.  Most of the tasks performed by the MC, because somehow cyclical.  There are also disadvantages: if some device or signal requires an immediate response, the MC will provide it no sooner than the cycle turns around.  If the duration of the signal is shorter than the cycle period, such a signal will be skipped. <br><br>  In the example below, we want to check whether the button is <b>pressed</b> : <br><br><pre><code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">' -  if button = 1 then '     '  -  loop</span></span></code> </pre> <br>  Obviously, if ‚Äúsome code‚Äù works long enough, the MC may not notice a short press of a button. <br><br>  Fortunately, the MC is equipped with an interrupt system that solves this problem: all critical signals can be ‚Äúhung up‚Äù on interrupts and write for each handler.  So the next level appears: <i>supercycle with interrupts</i> . <br>  The example below shows the structure of a program with a super-cycle and an interrupt that handles a button press: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  loop end '   button_isr: '  -    return</span></span></code> </pre> <br>  However, the use of interrupts creates a new problem: the interrupt handler code must be as fast and short as possible;  inside the interrupt functional MK is limited.  Since AVR MCs do not have a hierarchical interrupt system, another interrupt cannot occur inside the interrupt - they are hardware prohibited at this time.  So the interrupt should be executed as quickly as possible, otherwise other interrupts (and possibly more important ones) will be skipped and not processed. <br><br><div class="spoiler">  <b class="spoiler_title">Interrupt Memorization</b> <div class="spoiler_text">  In fact, being inside an interrupt, the MC is able to note the fact of another interruption in a special register, which allows it to be processed later.  However, this interrupt cannot be processed immediately anyway. <br></div></div><br>  Therefore, we cannot write something complicated in the interrupt handler, especially if this code should have delays - as long as the delay does not work, the MC will not return to the main program (super cycle) and will be deaf to other interrupts. <br><br>  Because of this, inside the interrupt handler, you often only have to mark the fact of an event with a flag ‚Äî your own for each event ‚Äî and then check and process flags inside the super-cycle.  This, of course, lengthens the time of reaction to an event, but at least we do not miss anything important. <br><br>  Thus, the next level of complexity arises - a <i>supercycle with interrupts and flags</i> . <br><br>  The following code is similar: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  if button_flag = 1 then '     button_flag = 0 '     end if '  -  loop end ' ***    *** button_isr: button_flag = 1 return</span></span></code> </pre> <br>  A considerable number of programs for MK and this is limited.  However, such programs are usually still more or less simple.  If you write something more complicated, the number of flags begins to grow like a snowball, and the code becomes more and more confused and unreadable.  In addition, the example above does not solve the problem with delays.  Of course, you can "hang up" a separate interrupt on the timer, and in it ... also control various flags.  But this makes the program completely ugly, the number of interdependent flags grows exponentially, and even the developer himself can hardly figure out such a macaroni code.  Attempting to find an error or modify the code often becomes equal in efforts to develop a new project. <br><br>  How to solve the problem of "macaroni code" and make it more readable and manageable?  The <i>operating system</i> (OS) comes to the rescue.  In it, the functional that should be implemented by the MC is divided into tasks that the OS manages. <br><br><h2>  Types of operating systems for MK </h2><br>  Operating systems for MCs can be divided into two large classes: OS with crowding out and cooperative OS.  In any of these operating systems, tasks are managed by a special procedure called the <i>dispatcher</i> .  In an OS with <i>displacement, the</i> dispatcher independently at any moment switches the execution from one task to another, allocating to each some number of machine time ticks (possibly different, depending on the priority of the task).  Such an approach as a whole works remarkably, allowing you not to look at the content of the tasks at all: in the problem code you can write at least <br><br><pre> <code class="vbscript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  - and still the remaining tasks (including this one) will be carried out.  However, preemptive OSs require a lot of resources (memory and processor cycles), since each switch must completely preserve the context of the task being disconnected and load the renewable context.  The context here refers to the contents of the machine registers and the stack (BASCOM uses two stacks - hardware for return addresses of subroutines and software for passing arguments).  Not only does such a load require multiple processor cycles, so the context of each task needs to be stored somewhere for as long as it does not work.  In the "large" processors, originally focused on multitasking, these functions are often supported by hardware, and they have much more resources.  In AVR MK there is no hardware support for multitasking (all you need to do "manually"), and the available memory is small.  Therefore, the preemptive OS, although they exist, is not very suitable for simple MCs. <br><br>  Another thing - <i>cooperative OS</i> .  Here the task itself controls the moment at which control is transferred to the dispatcher, allowing him to start other tasks for execution.  Moreover, the tasks here are obliged to do it - otherwise the execution of the code is stalled.  On the one hand, it seems that such an approach reduces the overall reliability: after all, if a task ‚Äúhangs‚Äù, it will never call the dispatcher, and the whole system will stop responding.  On the other hand, a linear code or a supercycle in this plan is no better than that, because they can hang exactly with the same risk. <br><br>  However, the cooperative OS has an important advantage.  Since here the programmer himself sets the switching moment, it cannot happen suddenly, for example, while a task is working with some resource or in the middle of calculating an arithmetic expression.  Therefore, in a cooperative OS in most cases you can do without saving the context.  This significantly saves processor time and memory, and therefore looks much more suitable for implementation on AVR MC. <br><br><h2>  Task switching in BASCOM AVR </h2><br>  To implement task switching in the BASCOM AVR environment, a task code, each of which is implemented as a normal procedure, must call the dispatcher in some place ‚Äî also implemented as a normal procedure. <br>  Imagine that we have two tasks, each of which, at some point in its code, calls the dispatcher. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> task1() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">'  1 '  loop end sub ' ---------------------------------- sub task2() do '  2 '  loop end sub</span></span></code> </pre> <br>  Suppose Task 1 was executed. Let's see what happens on the stack when it performs a ‚Äúdispatcher call‚Äù: <br><br><blockquote>  return address to the main code (2 bytes) <br>  top of the stack -&gt; return address to Task 1 that called the dispatcher (2 bytes) </blockquote><br>  The top of the stack will point to the instruction address in Task 1, which follows the dispatcher's call (the <b>loop</b> instruction in our example). <br><br>  In the simplest case, the dispatcher's goal is to transfer control to Task 2. The question is how to do this?  (suppose the dispatcher already knows the address of Task 2). <br><br>  To do this, the dispatcher must pull out the return address to Task 1 from the stack (and somewhere to remember), and place the address of Task 2 on this stack, and then give the return command.  The processor will retrieve the address placed there from the stack and, instead of returning to Task 1, will proceed to Task 2. <br><br>  In turn, when Task 2 calls the dispatcher, we will also pull out the stack and save the address at which we can return to Task 2, and load the previously saved Task address 1 onto the stack. Give the <b>return</b> command - and find ourselves at the continuation point of Task 1 . <br><br>  As a result, we will have such a leapfrog: <br><br><blockquote>  Task 1 -&gt; Dispatcher -&gt; Task 2 -&gt; Dispatcher -&gt; Task 1 .... </blockquote><br>  Not bad!  And it works.  But, of course, for any OS that is suitable for practical use, this is not enough.  After all, not always and not all tasks should work - for example, they can <i>expect</i> something (the expiration of the delay time, the appearance of some signal, etc.).  This means that tasks should have <i>status</i> (WORKS, READY, EXPECT, and so on).  In addition, it would be nice to assign tasks <i>priority</i> .  Then, if more than one task is ready for execution, the dispatcher will continue the task that has the highest priority. <br><br><h2>  AQUA RTOS </h2><br>  To implement the described idea, the cooperative OS AQUA RTOS was developed, providing the tasks with the necessary services and allowing to implement cooperative multitasking in the BASCOM AVR environment. <br><br><div class="spoiler">  <b class="spoiler_title">Important note regarding the procedure mode in BASCOM AVR</b> <div class="spoiler_text">  Before you begin the description of AUQA RTOS, it should be noted that the BASCOM AVR environment supports two types of addressing procedures.  This is governed by the config option submode = new |  old. <br>  In the case of specifying the old option, the compiler, first, will compile all the code linearly, regardless of whether it is used somewhere or not, secondly, procedures without arguments, decorated in the sub name / end style will be perceived as procedures designed in the style of name: / return.  This allows us to pass the address of the procedure as a label as an argument to another procedure by using the bylabel modifier.  This also applies to procedures designed in the style in the sub name / end sub style (the name of the procedure must be passed as a label). <br>  At the same time, the mode submode = old imposes some restrictions: task procedures should not contain arguments;  the code of the files connected via $ include is included in the overall project linearly, therefore the bypass should be provided in the connected files - transition from beginning to end using a goto and a label. <br>  Thus, in AQUA RTOS, the user must either use only the old task_name: / return procedure notation for tasks, or use the more common sub name / end sub, adding the modifier config submode = old to the beginning of his code, and the bypass to the included files goto label / include file code / label :. <br></div></div><br><h3>  Task Status AQUA RTOS </h3><br>  The following statuses are defined for tasks in AQUA RTOS: <br><br><pre> <code class="vbscript hljs">OSTS_UNDEFINE OSTS_READY OSTS_RUN OSTS_DELAY OSTS_STOP OSTS_WAIT OSTS_PAUSE OSTS_RESTART</code> </pre> <br>  If the task is not yet initialized, it is assigned the status <b>OSTS_UNDEFINE</b> . <br>  After initialization, the task has the status <b>OSTS_STOP</b> . <br>  If the task <i>is ready for execution</i> , it is assigned the status <b>OSTS_READY</b> . <br>  The currently running task has the status <b>OSTS_RUN</b> . <br>  From it it can go to the statuses <b>OSTS_STOP, OSTS_READY, OSTS_DELAY, OSTS_WAIT, OSTS_PAUSE</b> . <br>  The <b>OSTS_DELAY</b> status has a task that performs the <i>delay</i> . <br>  The status of <b>OSTS_WAIT is</b> assigned to tasks that are <i>waiting for a semaphore, event or message</i> (more about them below). <br><br>  What is the difference between <b>OSTS_STOP</b> and <b>OSTS_PAUSED statuses</b> ? <br>  If for some reason the task receives the status <b>OSTS_STOP</b> , then the subsequent resumption of the task (upon receipt of the status <b>OSTS_READY</b> ) will be carried out from the point of its entry, i.e.  from the very beginning.  From the status of <b>OSTS_PAUSE, the</b> task will continue to work in the place where it was suspended. <br><br><h3>  Task Status Management </h3><br>  Both the OS itself can manage tasks - automatically, and the user, by calling the OS services.  There are several task management services (the names of all OS services start with the prefix <b>OS_</b> ): <br><br><pre> <code class="vbscript hljs">OS_InitTask(task_label, task_prio) OS_Stop() OS_StopTask(task_label) OS_Pause() OS_PauseTask(task_label) OS_Resume() OS_ResumeTask(task_label) OS_Restart()</code> </pre> <br>  Each of them has two options: <b>OS_service</b> and <b>OS_serviceTask</b> (except for the <b>OS_InitTask</b> service, which has only one option; the <b>OS_Init</b> service initializes the OS itself). <br><br>  What is the difference between <b>OS_service</b> and <b>OS_serviceTask</b> ?  The first method acts on the task that caused it;  the second allows you to specify a pointer to another task as an argument and, thus, to control another from one task. <br><br><div class="spoiler">  <b class="spoiler_title">About OS_Resume</b> <div class="spoiler_text">  All task management services, except for OS_Resume and OS_ResumeTask, automatically call the task manager after processing.  In contrast, OS_Resume * services only set the task status OSTS_READY.  This status will be processed only when the dispatcher is explicitly called. <br></div></div><br><h3>  Priority and queue of tasks </h3><br>  As mentioned above, in a real system, some tasks may turn out to be more important, while others may be minor.  Therefore, a useful feature of the OS is the ability to assign tasks priority.  In this case, if there are several simultaneously <i>completed</i> tasks, the OS will first select the task with the highest priority.  If <b>all</b> finished tasks have equal priority, the OS will put them on execution in a circle, in the order called ‚Äúcarousel‚Äù or round-robin. <br><br>  In AQUA RTOS, priority is assigned to a task when it is <i>initialized</i> through a call to the <b>OS_InitTask</b> service, to which the address of the task is passed as the first argument, and the number from 1 to 15 is sent as the second argument. <i>A lower number means a higher priority</i> .  In the course of the OS, the change in the assigned task priority is not provided. <br><br><h3>  Delays </h3><br>  In each task, the delay is processed independently of other tasks. <br>  Thus, while the OS fulfills the delay of one task, others can be executed. <br>  For the organization of delays provided services <b>OS_Delay |</b>  <b>OS_DelayTask</b> .  The argument is the number of milliseconds to which the execution of the task is <i>postponed</i> .  Since the dimension of the argument is <b>dword</b> , the maximum delay is 4294967295 ms - or about 120 hours, which seems to be quite sufficient for most applications.  After calling the delay service, the dispatcher is automatically called, who, while the delay is being processed, transfers control to other tasks. <br><br><h3>  Semaphores </h3><br>  Semaphores in AQUA RTOS are something like flags and variables accessible to tasks.  They are of two types - binary and countable.  The first have only two states: free and closed.  The second ones are a byte counter (the counting semaphore service in the current version of AQUA RTOS is not implemented (I'm a lazy ass), so everything below applies only to binary semaphores). <br><br>  The difference between a semaphore and a simple flag is that the task can be made to <i>wait for the release of the</i> specified semaphore.  In some ways, the use of semaphores really resembles a railroad: before reaching the semaphore, the composition (task) will check the semaphore, and if it is not open, it will wait for the enabling signal to go on.  At this time, other trains (tasks) can continue to move (run). <br><br>  In this case, all the black work is assigned to the dispatcher.  As soon as the task is ordered to wait for the semaphore, control is automatically transferred to the dispatcher, and it can run other tasks ‚Äî just until the specified semaphore is released.  As soon as the state of the semaphore changes to <i>free</i> , the dispatcher will assign the status to all waiting for this semaphore task ( <b>OSTS_READY</b> ), and they will be executed in turn and priority. <br>  In total, AQUA RTOS provides 16 binary semaphores (this number can in principle be increased by changing the dimension of the variable in the task control block, since inside they are implemented as bit flags). <br>  Binary semaphores work through the following services: <br><br><pre> <code class="vbscript hljs">hBSem OS_CreateBSemaphore() OS_WaitBSemaphore(hBSem) OS_WaitBSemaphoreTask(task_label, hBSem) OS_BusyBSemaphore(hBSem) OS_FreeBSemaphore(hBSem)</code> </pre> <br>  Before using the semaphore you need <i>to create</i> .  This is done by calling the <b>OS_CreateBSemaphore</b> service, which returns a unique byte identifier (handle) of the created <b>hBSem</b> semaphore, or through a custom handler issues an <b>OSERR_BSEM_MAX_REACHED</b> error, indicating that the maximum possible number of binary semaphores has been reached. <br><br>  You can work with the received identifier by passing it as an argument to other semaphore services. <br><br>  <b>OS_WaitBSemaphore</b> Service <b>|</b>  <b>OS_WaitBSemaphoreTask</b> puts the (current | specified) task to <i>wait for the</i> <b>hBSem</b> <i>semaphore to be released</i> if the semaphore is busy, and then transfers control to the dispatcher so that it can run other tasks.  If the semaphore is free, control transfer does not occur, and the task will simply continue execution. <br><br>  The <b>OS_BusyBSemaphore</b> and <b>OS_FreeBSemaphore services</b> set the <b>hBSem</b> semaphore to <i>busy</i> or <i>free,</i> respectively. <br><br>  Destruction of semaphores in order to simplify the OS and reduce the amount of code is not provided.  Thus, all created semaphores are static. <br><br><h3>  Developments </h3><br>  In addition to semaphores, tasks can be event driven.  One task can be specified to <i>expect an event</i> , and another task (as well as a background code) can <i>signal</i> this event.  At the same time, all tasks that were waiting for this event will receive the status <i>ready for execution</i> ( <b>OSTS_READY</b> ) and will be delivered by the dispatcher for execution in turn and priority order. <br><br>  What events can the task respond to?  Well, for example: <br><ul><li>  interrupt; </li><li>  the occurrence of an error; </li><li>  release of a resource (sometimes it is more convenient to use a semaphore for this); </li><li>  changing the state of the I / O line or pressing a key on the keyboard; </li><li>  receive or send a symbol via RS-232; </li><li>  transfer of information from one part of the application to another (see also messages). </li></ul><br>  The event system is implemented through the following services: <br><br><pre> <code class="vbscript hljs">hEvent OS_CreateEvent() OS_WaitEvent(hEvent) OS_WaitEventTask(task_label, hEvent) OS_WaitEventTO(hEvent, dwTimeout) OS_SignalEvent(hEvent)</code> </pre> <br>  Before using the event you need <i>to create it</i> .  This is done by calling the <b>OS_CreateEvent</b> function, which returns the unique byte identifier (handle) of the <b>hEvent</b> event, or, via a custom handler, issues an <b>OSERR_EVENT_MAX_REACHED</b> error, indicating that the number of events that can be created in the OS has been reached (maximum 255 different events). <br><br>  To make a task wait for an <b>hEvent</b> event, in its code you should call <b>OS_WaitEvent</b> , passing the event handle as an argument.  After calling this service, the control will be automatically transferred to the dispatcher. <br><br>  Unlike the semaphore service, the event service has a waiting option with a <i>timeout</i> .  For this is the service <b>OS_WaitEventTO</b> .  The second argument here is the number of milliseconds that the task can wait for an event.  If the specified time has elapsed, the task will receive the status <i>ready for execution</i> as if the event has occurred, and will be supplied by the dispatcher to continue execution in the order of priority and priority.  You can learn about what happened not an event, but a timeout, by checking the global flag <b>OS_TIMEOUT</b> . <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task or background code can </font><i><font style="vertical-align: inherit;">signal</font></i><font style="vertical-align: inherit;"> the occurrence of a specified event by calling the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SignalEvent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">, to which the event handle is passed as an argument. </font><font style="vertical-align: inherit;">In this case, all tasks waiting for this event, the OS will set the status </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ready for execution</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so that they can continue execution in the order of priority and queue.</font></font><br><br><h3>  Messages </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The message system works as a whole similarly to the event system, however, it provides tasks with more opportunities and flexibility: it provides not only waiting for a message on a specified topic, but a way to transfer a message from one task to another - a number or a string. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is implemented through the following services:</font></font><br><br><pre> <code class="vbscript hljs">hTopic OS_CreateMessage() OS_WaitMessage(hTopic) OS_WaitMessageTask(task_label, hTopic) OS_WaitMessageTO(hTopic, dwTimeout) OS_SendMessage(hTopic, wMessage) word_ptr OS_GetMessage(hTopic) word_ptr OS_PeekMessage(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_GetMessageString(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_PeekMessageString(hTopic)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To use the messaging service, you must first create </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a message subject</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is done through the service </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_CreateMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which returns a handle to a byte threads </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , either through a custom handler throws an error </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSERR_TOPIC_MAX_REACHED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , talking about what has been achieved the maximum possible number of the messages, and no longer able to create. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To tell the task to wait for a message on the topic of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in its code you should call </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_WaitMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , passing the handle of the topic as an argument. After calling this service, the control will be automatically transferred to the task manager. Thus, this service puts the current task in the state</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait for posts on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idle timeout </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">service OS_WaitMessageTO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> works in the same way as the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_WaitEventTO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service of the </font><b><font style="vertical-align: inherit;">event</font></b><font style="vertical-align: inherit;"> system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For sending messages, the service </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SendMessage is provided</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The first argument is the topic handle to which the message will be transmitted, and the second argument is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dimension argument </font><font style="vertical-align: inherit;">. This can be either a standalone number or a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointer to a string</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which, in turn, is already a message. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get a string pointer, it suffices to use the varptr function built into </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BASCOM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for example, like this:</font></font><br><br><pre> <code class="vbscript hljs">strMessage = <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span> OS_SendMessage hTopic, varptr (strMessage)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After resuming work after calling </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_WaitMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , that is, when an expected message is received, the task can either receive a message with its subsequent automatic deletion, or just view the message - in this case it will not be deleted. For this are the last four services in the list. The first two return the number of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dimension </font><font style="vertical-align: inherit;">, which can be either an independent message, or serve as a pointer to the string that contains the message. At the same time </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_GetMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatically deletes the message, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_PeekMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leaves it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the task immediately needs a string, not a pointer, you can use the services </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_GetMessageString</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_PeekMessageString</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which work similarly to the previous two, but return a string, not a pointer to it. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Internal timer service </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To work with the delays and timing AQUA RTOS uses a built-in IC hardware timer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Thus, the external code (background and tasks) should not use this timer. </font><font style="vertical-align: inherit;">But usually it is not required, because </font><font style="vertical-align: inherit;">The OS supplies tasks with all necessary means of working with time intervals. </font><font style="vertical-align: inherit;">Timer resolution is 1 ms.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Examples of working with AQUA RTOS </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initial settings </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the very beginning of the user code, you need to determine whether the code will be executed in the embedded simulator or on real hardware. </font><font style="vertical-align: inherit;">Define the constant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SIM = TRUE | </font><font style="vertical-align: inherit;">FALSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which sets the simulation mode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, in the OS code, edit the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_MAX_TASK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constant </font><font style="vertical-align: inherit;">, which defines the maximum number of tasks supported by the OS. </font><font style="vertical-align: inherit;">Than this number is less, the OS works faster (less overhead), and the less memory it consumes. </font><font style="vertical-align: inherit;">Therefore, there is no need to specify there more tasks than you need. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to change this constant if the number of tasks has changed.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OS Initialization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before you start AQUA RTOS must be initialized. To do this, call the service </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This service adjusts the initial parameters of the OS. More importantly, it has an argument ‚Äî the address of a custom error-handling procedure. She, in turn, also has an argument - an error code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This handler must be in the user code (at least in the form of a stub) - the OS sends error codes to it, and the user has no other way to catch them and process them accordingly. I strongly recommend that, at least during the development phase, not to stub out, but to include in this procedure any output of information about errors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the first step in working with AQUA RTOS is to add the OS initialization code and the error handler procedure to the user program:</font></font><br><br><pre> <code class="vbscript hljs">OS_Init my_err_trap <span class="hljs-comment"><span class="hljs-comment">'... '... '... sub my_err_trap(err_code as byte) print err_code end sub</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task initialization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The second step is to initialize the tasks, specifying their names and priority: </font></font><br><br><pre> <code class="vbscript hljs">OS_InitTask task_1, <span class="hljs-number"><span class="hljs-number">1</span></span> OS_InitTask task_2 , <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">'... OS_InitTask task_N , 1</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test tasks </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We blink LEDs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So let's create a test application that can be loaded into a standard Arduino Nano V3 board. </font><font style="vertical-align: inherit;">Create a folder in the folder with the OS file (for example, test), and create the following bas file there:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() '       led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output ' ***    *** '   OS_Init my_err_trap '   OS_InitTask task_1, 1 OS_InitTask task_2 , 1 '      ¬´¬ª (OSTS_STOP) '    ,     ' ¬´  ¬ª (OSTS_READY)   OS_ResumeTask OS_ResumeTask task_1 OS_ResumeTask task_2 '      OS_Sheduler end ' ***  *** sub task_1 () do toogle led_1 '   1 OS_delay 1000 '   1000  loop end sub sub task_2 () do toogle led_2 '   2 OS_delay 333 '   333  loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect the anodes of the LEDs to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pins </font><font style="vertical-align: inherit;">of the Arduino board (or to other pins by changing the corresponding definition lines in the code). Cathodes through limiting resistors 100 ... 500 Ohms connect to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bus </font><font style="vertical-align: inherit;">. Compile and fill the firmware into the board. The LEDs will start switching asynchronously with a period of 2 and 0.66 s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the code. So, first we initialize the hardware (we set the compiler options, the port mode and assign aliases), then the OS itself, and finally the tasks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the newly created tasks are in the ‚Äústopped‚Äù state, you need to give them the status ‚Äúready to be executed‚Äù (perhaps not all tasks in a real application ‚Äî after all, some of them may, according to the developer‚Äôs plan, initially be in a stopped state, and run on performing only from other tasks, and not immediately at the start of the system; however, in this example, both tasks should immediately start working). Therefore, for each task, we call the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_ResumeTask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the tasks are ready for execution, but not yet executed. Who will launch them? Of course, the dispatcher! To do this, we must call it when you first start the system. Now, if everything is written correctly, the dispatcher will perform our tasks in turn, and we can finish the main part of the program with the </font><b><font style="vertical-align: inherit;">end</font></b><font style="vertical-align: inherit;"> operator</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the tasks. It immediately catches the eye that each of them is framed as an endless </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-loop loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The second important property is that within such a cycle there must be at least one call to either the dispatcher or the OS service that automatically calls the dispatcher after itself ‚Äî otherwise such a task will never give up control and other tasks will not be able to be performed. In our case, this is the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_Delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> delay </font><b><font style="vertical-align: inherit;">service</font></b><font style="vertical-align: inherit;"> . As an argument, we gave him the number of milliseconds to which each task should be suspended. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you set the constant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SIM = TRUE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the beginning of the code </font><font style="vertical-align: inherit;">and run the code not on a real chip, but in the simulator, you can see how the OS works.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The dispatcher we called will see if the tasks are ‚Äúready for execution‚Äù, and arrange them in a queue according to priority. If the priority is the same, the dispatcher will ‚Äúroll tasks on the carousel‚Äù, moving the task that has just been worked out to the very end of the queue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By selecting the task that should be executed (say, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), the dispatcher replaces the return address on the stack (initially it shows the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">in the main code) with the entry point address of the task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which the system recognizes during the task initialization, and executes the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">, which causes MK pull the return address from the stack and go to it - that is, start the execution of the task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (operator</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code </font><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , switching its LED, causes the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">, which, having performed the necessary actions, goes to the dispatcher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The dispatcher saves the address that was on the stack to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task control block </font><font style="vertical-align: inherit;">(points to the instruction following the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> call </font><font style="vertical-align: inherit;">, i.e., the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">), and then, ‚Äúturning the carousel‚Äù detects that it is now necessary to execute the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task </font><font style="vertical-align: inherit;">. He pushes the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task address </font><b><font style="vertical-align: inherit;">onto the stack</font></b><font style="vertical-align: inherit;"> (currently indicates the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> statement </font><font style="vertical-align: inherit;">in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task </font><b><font style="vertical-align: inherit;">code</font></b><font style="vertical-align: inherit;"> ) and executes the command</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which forces MK to pull out the return address from the stack and go to it - that is, start the execution of the task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , switching its LED, causes the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">, which, having performed the necessary actions, goes to the dispatcher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The dispatcher saves the address that was on the stack to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task control block </font><font style="vertical-align: inherit;">(points to the instruction following the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> call </font><font style="vertical-align: inherit;">, i.e., the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">), and then, ‚Äúturning the carousel‚Äù detects that it is now necessary to execute the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task </font><font style="vertical-align: inherit;">. The difference from the initial state will be that now in the task control block </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not the starting address of the task is stored, but the address of the point from which the transition to the dispatcher occurred. </font><font style="vertical-align: inherit;">There (on the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task </font><b><font style="vertical-align: inherit;">code</font></b><font style="vertical-align: inherit;"> ), and control will be transferred. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will execute the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">, and then the whole cycle ‚ÄúTask 1 - Manager - Task 2 - Manager‚Äù will repeat endlessly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We send messages </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's try sending messages from one task to another. </font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() const OS_SIM = TURE '       '   dim hTopic as byte '     dim task_1_cnt as byte '    1 dim strMessage as string * 16 '  ' ***    *** OS_CreateMessage hTopic OS_Init my_err_trap OS_InitTask task_1 , 1 OS_InitTask task_2 , 1 OS_ResumeTask task_1 OS_ResumeTask task_2 OS_Sheduler end ' ***  *** sub task_1() do print "task 1" OS_Sheduler incr task_1_cnt '    1 if task_1_cnt &gt; 3 then print "task 1 is sending message to task 2" strMessage = "Hello, task 2!" '    2 OS_SendMessage hTopic , varptr(strMessage) task_1_cnt = 0 end if loop end sub sub task_2() do print "task 2 is waiting messages..." '      1 OS_WaitMessage hTopic print "message recieved: " ; OS_GetMessageString (hTopic) loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The result of running the program in the simulator will be the following output to the terminal window: </font></font><br><br><blockquote> task 1 <br> task 2 is waiting messages‚Ä¶ <br> task 1 <br> task 1 <br> task 1 <br> task 1 is sending message to task 2 <br> task 1 <br> message recieved: Hello, task 2! <br> task 2 is waiting messages‚Ä¶ <br> task 1 <br> task 1 <br>  ... <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice the order in which the work and task switching takes place. As soon as Task 1 types </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , control is transferred to the dispatcher so that he can start the second task. Task 2 prints </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task 2 is waiting messages ...</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then calls the service to wait for messages on the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> theme </font><font style="vertical-align: inherit;">, and control is automatically transferred to the dispatcher, which again calls </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Ta prints </font><b><font style="vertical-align: inherit;">task 1</font></b><font style="vertical-align: inherit;"> again </font><font style="vertical-align: inherit;">and gives control to the dispatcher. However, since the dispatcher detects that Task 2 is now waiting for messages, it returns control of Task 1 to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">following the dispatcher's call. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the </font><b><font style="vertical-align: inherit;">task_1_cnt</font></b><font style="vertical-align: inherit;"> counter</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Task 1 will exceed the specified value, the task sends a message, but continues to be executed - executes the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">and again prints </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">After that, she calls the dispatcher, who now detects that there is a message for Task 2, and transfers control to it. </font><font style="vertical-align: inherit;">Further process is carried out cyclically.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Event handling </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following code polls two buttons and switches the LEDs when the corresponding button is pressed: </font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_scankeys() declare sub task_led_1() declare sub task_led_2() '        led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output button_1 alias pind.6 button_2 alias pind.7 config portd.6 = input config portd.7 = input '   dim eventButton_1 as byte dim eventButton_2 as byte ' ***    *** eventButton_1 = OS_CreateEvent '       eventButton_2 = OS_CreateEvent OS_Init my_err_trap OS_InitTask task_scankeys , 1 OS_InitTask task_led_1 , 1 OS_InitTask task_led_2 , 1 OS_ResumeTask task_scankeys OS_ResumeTask task_led_1 OS_ResumeTask task_led_2 OS_Sheduler end ' ***  *** sub task_scankeys() do debounce button_1 , 0 , btn_1_click , sub debounce button_2 , 0 , btn_2_click , sub OS_Sheduler loop btn_1_click: OS_SignalEvent eventButton_1 return btn_2_click: OS_SignalEvent eventButton_2 return end sub sub task_led_1() do OS_WaitEvent eventButton_1 toggle led_1 loop end sub sub task_led_2() do OS_WaitEvent eventButton_2 toggle led_2 loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An example of a real application under AQUA RTOS </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to imagine what the program of a coffee vending machine could look like. </font><font style="vertical-align: inherit;">The machine should show the presence of coffee options and selection in LEDs in the buttons; </font><font style="vertical-align: inherit;">receive signals from the receiver of coins, prepare the ordered drink, issue change. </font><font style="vertical-align: inherit;">In addition, the machine must control the internal equipment: for example, maintain the temperature of the water heater at 95 ... 97 ¬∞ C; </font><font style="vertical-align: inherit;">transmit information about equipment malfunction and stock of ingredients and receive commands via remote access (for example, via a GSM modem), and also signal vandalism.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Event driven approach </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first, it is not easy for a developer to switch from a familiar ‚Äúsuper-cycle + flags + interrupt‚Äù scheme to an approach based on tasks and events. </font><font style="vertical-align: inherit;">This requires highlighting the main tasks that the device must perform. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to outline such tasks for our machine:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">control and heater control - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ControlHeater ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indication of the presence and selection of drinks - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShowGoods ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceptance of coins / bills and their summation - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptMoney ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poll buttons - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScanKeys ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make change - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MakeChange ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beverage Vacation - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vandalism protection - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alarm ()</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us estimate the importance of tasks and the frequency of their call. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ControlHeater () is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obviously important because we always need boiling water to make coffee. But it should not be done too often, because the heater is very inert and the water cools slowly. Enough to check the temperature once a minute. We give this task a priority of 5. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShowGoods () is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not too important. The offer can change only after the release of the goods, if the stock of some ingredients is exhausted. Therefore, we give this task a priority of 8, and let it be executed when the machine starts and every time the goods are released. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScanKeys ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should have a high enough priority for the machine to respond quickly to pressing the buttons. We give this task a priority of 3, and we will execute it every 40 milliseconds. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptMoney () is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also part of the user interface. We will give it the same priority as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScanKeys (),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and we will execute it every 20 milliseconds. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MakeChange ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is executed only after the goods are released. We will associate it with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and give priority 10. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee () is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> needed only when the appropriate amount of money has been received and the drink selection button is pressed. For quick response, we give it priority 2. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since anti-vandal resistance is a rather important function of the automaton, the </font><b><font style="vertical-align: inherit;">Alarm ()</font></b><font style="vertical-align: inherit;"> task</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can set the highest priority to 1, and activate it once a second to check tilt or tamper sensors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we will need seven tasks with different priorities. </font><font style="vertical-align: inherit;">After the start, when the program reads the settings from the EEPROM and initializes the hardware, it is time to initialize the OS and start the tasks.</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    declare sub ControlHeater() declare sub ShowGoods() declare sub AcceptMoney() declare sub ScanKeys() declare sub MakeChange () declare sub ReleaseCoffee() declare sub Alarm()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To work as part of an RTOS, each task must have a specific structure: it must have at least one dispatcher call (or an OS service that automatically transfers control to the dispatcher) - this is the only way to ensure cooperative multitasking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> might look something like this:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> ReleaseCoffee() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> OS_WaitMessage bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) Release wItem <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task </font><font style="vertical-align: inherit;">in the infinite loop waits for a message on the topic </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCoffeeSelection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and does not do anything until it arrives (control is automatically returned to the dispatcher so that he can run other tasks). As soon as the message is sent, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is ready for execution, and when this happens, the task receives the contents of the message (selected beverage code) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wItem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_GetMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">and releases the goods to the customer. Since </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uses a message subsystem, a message must be created before running multitasking:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShowGoods ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> must be executed once during start-up and every time the goods are released. </font><font style="vertical-align: inherit;">To associate it with the release procedure of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we use the event service. </font><font style="vertical-align: inherit;">To do this, create an event before running multitasking:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bGoodsReliased as byte bGoodsReliased = OS_CreateEvent()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedure, </font><font style="vertical-align: inherit;">after the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Release wItem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> line, </font><font style="vertical-align: inherit;">add the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bGoodsReliased</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event </font><b><font style="vertical-align: inherit;">alarm</font></b><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="vbscript hljs">OS_SignalEvent bGoodsReliased</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OS Initialization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to prepare the OS for work, we must initialize it, specifying the address of the error handler, which is in the user code. </font><font style="vertical-align: inherit;">We do this using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="vbscript hljs">OS_Init Mailfuncion</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the user code, you need to add a handler - a procedure whose byte argument will be the error code: </font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> Mailfuncion (bCoffeeErr) print <span class="hljs-string"><span class="hljs-string">"Mailfunction! Error #: "</span></span>; bCoffeeErr <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isErrCritical (bCoffeeErr) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallService(bCoffeeErr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This procedure prints the error code (or may display it in some other way: on the screen, via a GSM modem, etc.), and in case the error is critical, call the service department. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Running tasks </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We already remember that events, semaphores, etc. </font><font style="vertical-align: inherit;">must be initialized before being used. </font><font style="vertical-align: inherit;">In addition, the tasks themselves must be initialized using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_InitTask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><b><font style="vertical-align: inherit;">before starting</font></b><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="vbscript hljs">OS_InitTask ControlHeater , <span class="hljs-number"><span class="hljs-number">5</span></span> OS_InitTask ShowGoods , <span class="hljs-number"><span class="hljs-number">8</span></span> OS_InitTask AcceptMoney , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask ScanKeys , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask MakeChange, <span class="hljs-number"><span class="hljs-number">10</span></span> OS_InitTask ReleaseCoffee , <span class="hljs-number"><span class="hljs-number">2</span></span> OS_InitTask Alarm , <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the multitasking mode has not yet begun, the order in which tasks are started is irrelevant, and in any case does not depend on their priorities. </font><font style="vertical-align: inherit;">At this point, all tasks are still in a stopped state. </font><font style="vertical-align: inherit;">To prepare them for execution, we must use the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_ResumeTask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><b><font style="vertical-align: inherit;">to</font></b><font style="vertical-align: inherit;"> give them the ‚Äúready for execution‚Äù status:</font></font><br><br><pre> <code class="vbscript hljs">OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As already mentioned, not all tasks must start when multitasking starts; </font><font style="vertical-align: inherit;">some of them can be arbitrarily ‚Äústopped‚Äù at any time and receive readiness only under certain conditions. </font><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_ResumeTask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">can be called at any time from anywhere in the code (background or task) when multitasking is already running. </font><font style="vertical-align: inherit;">The main thing is that the task to which it refers, has been previously initialized.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start multitasking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now everything is ready to start multitasking. </font><font style="vertical-align: inherit;">We do this by calling the dispatcher:</font></font><br><br><pre> <code class="vbscript hljs">OS_Sheduler</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, we can safely put </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the program code </font><font style="vertical-align: inherit;">‚Äî the OS now takes control of the further execution of the code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the whole code:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $include "coffee_hardware.bas" '      '       Coffee_ $regfile = "m328pdef.dat" ' Arduino Nano v3 $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 Coffee_InitHardware '    '   declare sub Mailfuncion (byval bCoffeeErr as byte) '   declare sub ControlHeater () '   declare sub ShowGoods () '    declare sub AcceptMoney () '   declare sub ScanKeys () '   declare sub MakeChange () '      declare sub ReleaseCoffee () '   declare sub Alarm () '    '     Coffee_InitHardware () '   dim wMoney as long '    dim wGoods as long '   ' ***    *** '   OS_Init Mailfuncion '       dim bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage() '     dim bGoodsReliased as byte bGoodsReliased = OS_CreateEvent() '   OS_InitTask ControlHeater , 5 OS_InitTask ShowGoods , 8 OS_InitTask AcceptMoney , 3 OS_InitTask ScanKeys , 3 OS_InitTask MakeChange, 10 OS_InitTask ReleaseCoffee , 2 OS_InitTask Alarm , 1 '     OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm '   OS_Sheduler end ' ***   *** ' ----------------------------------- sub ControlHeater() do select case GetWaterTemp() case is &gt; 97 Coffee_HeaterOff '   case is &lt; 95 Coffee_HeaterOn '   case is &lt; 5 CallServce (WARNING_WATER_FROZEN) '   end select OS_Delay 60000 '  1  loop end sub ' ----------------------------------- sub ShowGoods() do LEDS = Coffee_GetDrinkSupplies() '    D, '         '   LEDS OS_WaitEvent bGoodsReliased '   " " loop end sub ' ----------------------------------- sub AcceptMoney() do wMoney = wMoney + ReadMoneyAcceptor() OS_Delay 20 loop end sub ' ----------------------------------- sub ScanKeys() do wGoods = ButtonPressed() if wMoney &gt;= GostOf(wGoods) then OS_SendMessage bCoffeeSelection, wGoods '     bCoffeeSelection,  '     end if OS_Delay 40 loop end sub ' ----------------------------------- sub MakeChange() do OS_WaitEvent bGoodsReliased '   " " Refund wMoney loop end sub ' ----------------------------------- sub ReleaseCoffee() do OS_WaitMessage bCoffeeSelection '  bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) '   Release wItem '    wMoney = wMoney ‚Äì CostOf (wItem) '     OS_SignalEvent bGoodsReliased '     '  ,       : ' MakeChange  ShowGoods '  ,  ,     loop end sub ' ----------------------------------- sub Alarm() do OS_Delay 1000 if Hijack() = 1 then CallPolice() end if loop end sub ' ----------------------------------- ' ***    *** sub Mailfuncion (bCoffeeErr) print "Mailfunction! Error #: "; bCoffeeErr if isErrCritical (bCoffeeErr) = 1 then CallService() end if end sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, it would be more correct to approach not with periodic polling of buttons and cash sensor, but using interrupts. </font><font style="vertical-align: inherit;">In the handlers of these interrupts, we could use the sending of messages using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SendMessage () service</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the content equal to the number of the key pressed or the denomination of the entered coin / bill. </font><font style="vertical-align: inherit;">I suggest the reader to modify the program independently. </font><font style="vertical-align: inherit;">Thanks to the task-oriented approach and the service provided by the OS, this will require minimal code changes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AQUA RTOS source code </font></font></h2><br> <a href=""><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source code version 1.05 is available for download at the link.</font></font></b></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> P.S </font></font></h2><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q: Why AQUA?</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A: Well, I did the controller of the aquarium, it is like a ‚Äúsmart home‚Äù, but not for people, but for fish. Full of all kinds of sensors, a real-time clock, relay and analogue power outputs, an on-screen menu, a flexible ‚Äúevent program‚Äù, and even a WiFi module. Intervals should be counted, buttons should be polled, sensors should be processed, an event program should be read from the EEPROM and executed, the screen should be updated, Wi-Fi should respond. Moreover, the controller should go to a multi-level menu for settings and programming. To do it on flags and interrupts is to get the very ‚Äúmacaroni code‚Äù, which cannot be sorted out or modified. That's why I decided that I needed an OS. Here it is AQUA. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q: Surely the code is full of logical errors and glitches?</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A: Surely. </font><font style="vertical-align: inherit;">I, as I could, invented various tests and drove the OS on a variety of tasks, and even slapped a noticeable number of bugs, but this does not mean that all of them are complete. </font><font style="vertical-align: inherit;">More than confident that they are still a lot hidden in the back streets of the code. </font><font style="vertical-align: inherit;">Therefore, I will be very grateful if, instead of poking me in the bugs with a muzzle, you politely and tactfully point them out, and better tell me how you think they are best corrected. </font><font style="vertical-align: inherit;">It will also be great if the project is further developed as a product of collective creativity. </font><font style="vertical-align: inherit;">For example, someone will add a counting semaphore service (not forgotten? I'm a lazy ass) and suggest other improvements. </font><font style="vertical-align: inherit;">In any case, I will be very grateful for the constructive contribution.</font></font></div><p>Source: <a href="https://habr.com/ru/post/453708/">https://habr.com/ru/post/453708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453698/index.html">Quantum Information in Quantum Consciousness</a></li>
<li><a href="../4537/index.html">Podcasting is changing traditional media.</a></li>
<li><a href="../45370/index.html">HolyWar: ‚Äã‚ÄãTemplate engines. Do they need? Are they wealthy? Forum.</a></li>
<li><a href="../453700/index.html">SDL 2 Tutorials: Lesson 1 - Hello, SDL 2</a></li>
<li><a href="../453706/index.html">How I passed the Google Cloud Professional Data Engineer certification exam</a></li>
<li><a href="../453712/index.html">How eBay did a barcode scanner on WebAssembly</a></li>
<li><a href="../453714/index.html">Test client TON (Telegram Open Network) and new language Fift for smart contracts</a></li>
<li><a href="../45372/index.html">Our VoIP startup Octopus</a></li>
<li><a href="../453720/index.html">Subtleties of Lambda Expressions in C #</a></li>
<li><a href="../453722/index.html">On the study of non-stationary processes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>