<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>4 ways to write to a secure page</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This refers to writing to a memory-protected memory address in the x86 architecture. And the way it is done in the Linux operating system. And, of cou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>4 ways to write to a secure page</h1><div class="post__text post__text-html js-mediator-article">  This refers to writing to a memory-protected memory address in the x86 architecture.  And the way it is done in the Linux operating system.  And, of course, in the Linux kernel mode, because in user space, such tricks are prohibited.  It happens, you know, an overwhelming desire to write to a protected area ... when you sit down to write a virus or a trojan ... <br><br><h1>  Description of the problem </h1><br>  ... and seriously, the problem of writing to write-protected pages of RAM occurs from time to time when programming kernel modules under Linux.  For example, when modifying the selector table of sys_call_table system calls for modifying, embedding, implementing, spoofing, intercepting a system call, this action is called differently in different publications.  But not only for these purposes ... In a very brief summary, the situation is as follows: <br><br><ul><li>  In the x86 architecture, there is a protection mechanism that, when attempting to write to write-protected memory pages, leads to an excitation exception. </li><li>  The access rights to the page (enable or disable writing) are described by the _PAGE_BIT_RW bit (1st) in the pte_t type structure corresponding to this page.  Resetting this bit disables writing to the page. </li><li>  On the processor side, the X86_CR0_WP bit (16th) of the CR0 system control register controls the write protection; when this bit is set, an attempt to write to the write-protected page triggers the processor to exclude. </li></ul><br><a name="habracut"></a><br>  The relevance of the task of writing to a hardware-protected area of ‚Äã‚Äãmemory is indicated by a significant number of publications on this topic, and the number of proposed ways to solve the problem.  The remaining part of the review is devoted to a consecutive review of the methods ... For each of the methods there will be given: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Sample code, tested and usable; </li><li>  The links to the authorship of such a code known to me (although this is very relative, because there are quite a few independent sources in the methods that solve this problem); </li></ul><br><cut><br><h1>  Disable paging, assembler </h1><br>  The simplest solution to this problem is to temporarily disable page protection by resetting the X86_CR0_WP bit in the CR0 register.  I use this method for a dozen years, and it has been mentioned in several publications of different years, for example, <a href="http://vulnfactory.org/blog/2011/08/12/wp-safe-or-not/">WP: Safe or Not?</a>  (Dan Rosenberg, 2011).  One of the ways of such an implementation is inline assembly inserts (macros, GCC compiler extension).  In my version and in the demo test this version looks like this (rw_cr0.c file): <br><pre><code class="hljs perl">static inline void rw_enable( void ) { asm( <span class="hljs-string"><span class="hljs-string">"cli \n"</span></span> <span class="hljs-string"><span class="hljs-string">"pushl %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"movl %cr0, %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"andl $0xfffeffff, %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"movl %eax, %cr0 \n"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %eax"</span></span> ); } static inline void rw_disable( void ) { asm( <span class="hljs-string"><span class="hljs-string">"pushl %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"movl %cr0, %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"orl $0x00010000, %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"movl %eax, %cr0 \n"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %eax \n"</span></span> <span class="hljs-string"><span class="hljs-string">"sti "</span></span> ); }</code> </pre> <br>  (The saving and restoring of the eax register can be eliminated, here it is shown ... solely for the purity of the experiment.) <br><br>  The first thing that is always objected to such a method at first glance is that, since it is based on controlling a specific processor, in SMP systems between setting the CR0 register and writing to the protected area, the execution of the module can be rescheduled to another processor for which page protection not disabled.  The likelihood of such a confluence of circumstances is no more than if a serpent escaped from the zoo had bitten you in the center of Moscow.  But the probability of such a thing exists, and it is finite, albeit vanishingly small.  In order to prevent this situation from arising from the assembler code, we prohibit local interruptions of the processor with the cli operation before recording, and release the interrupts only after the recording is completed with the sti operation (similarly does Dan Rosenberg in the mentioned publication). <br><br>  What is much more unpleasant in the code shown is that it is written for 32-bit architecture (i386), and in 64-bit architecture it will not only be executed, but even compiled.  This can be resolved by having different codes depending on the architecture: <br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> __i386__ // ... ,     <span class="hljs-symbol"><span class="hljs-symbol">#else</span></span> static inline void rw_enable( void ) { asm( <span class="hljs-comment"><span class="hljs-comment">"cli \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"pushq %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"movq %cr0, %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"andq $0xfffffffffffeffff, %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"movq %rax, %cr0 \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"popq %rax "</span></span> ); } static inline void rw_disable( void ) { asm( <span class="hljs-comment"><span class="hljs-comment">"pushq %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"movq %cr0, %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"xorq $0x0000000000001000, %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"movq %rax, %cr0 \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"popq %rax \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">"sti "</span></span> ); } <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre><br><br><h1>  Disable paging, kernel API </h1><br>  You can do the same thing as before, but relying not on the assembler code, but on the kernel API (file rw_pax.c).  Here is a fragment of such a code in almost the same unchanged form as it is given by Dan Rosenberg: <br><pre> <code class="hljs kotlin">#include &lt;linux/preempt.h&gt; #include &lt;asm/paravirt.h&gt; #include &lt;asm-generic/bug.h&gt; #include &lt;linux/version.h&gt; static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> unsigned long native_pax_open_kernel( void ) { unsigned long cr0; preempt_disable(); barrier(); cr0 = read_cr0() ^ X86_CR0_WP; BUG_ON( unlikely( cr0 &amp; X86_CR0_WP ) ); write_cr0( cr0 ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cr0 ^ X86_CR0_WP; } static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> unsigned long native_pax_close_kernel( void ) { unsigned long cr0; cr0 = read_cr0() ^ X86_CR0_WP; BUG_ON( unlikely( !( cr0 &amp; X86_CR0_WP ) ) ); write_cr0( cr0 ); barrier(); #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) preempt_enable_no_resched(); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> preempt_count_dec(); #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cr0 ^ X86_CR0_WP; }</code> </pre><br>  The ‚Äúalmost‚Äù note refers to the fact that the preempt_enable_no_resched () call was available before the 3.13 kernel (in 2011 when the article was written).  Starting from the kernel 3.14 and further this call is closed by this conditional preprocessor definition: <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> MODULE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Modules have no business playing preemption tricks. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> sched_preempt_enable_no_resched #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> preempt_enable_no_resched</span></span></code> </pre><br>  But the macros preempt_enable_no_resched () and preempt_count_dec () defined in later kernels are almost identical. <br><br>  Much more unpleasant is the fact that the shown code is safely executed in later versions (older than 3.14) of the kernel, but soon <b>after</b> it is executed, warning messages from the kernel appear in other applications, like: <br><pre> <code class="dos hljs">[ <span class="hljs-number"><span class="hljs-number">337</span></span>.<span class="hljs-number"><span class="hljs-number">230937</span></span>] ------------[ cut here ]------------ [ <span class="hljs-number"><span class="hljs-number">337</span></span>.<span class="hljs-number"><span class="hljs-number">230949</span></span>] WARNING: CPU: <span class="hljs-number"><span class="hljs-number">1</span></span> PID: <span class="hljs-number"><span class="hljs-number">3410</span></span> <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> /build/buildd/linux-lts-utopic-<span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">16</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>/init/main.c:<span class="hljs-number"><span class="hljs-number">802</span></span> do_one_initcall+<span class="hljs-number"><span class="hljs-number">0</span></span>x1cb/<span class="hljs-number"><span class="hljs-number">0</span></span>x1f0() [ <span class="hljs-number"><span class="hljs-number">337</span></span>.<span class="hljs-number"><span class="hljs-number">230955</span></span>] initcall rw_init+<span class="hljs-number"><span class="hljs-number">0</span></span>x0/<span class="hljs-number"><span class="hljs-number">0</span></span>x1000 [srw] returned with preemption imbalance</code> </pre><br>  (I didn‚Äôt go into details of what was happening ... I didn‚Äôt consider it necessary, but this is somehow related to the imbalance of work between SMP processors, or the assessment of such balancing.) <br><br>  Even warnings that appear in the core are serious enough, I would like to get rid of them.  This can be achieved by repeating the trick with local interrupts from the previously discussed assembly code (rw_pai.c file): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">native_pai_open_kernel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cr0; local_irq_disable(); barrier(); cr0 = read_cr0() ^ X86_CR0_WP; BUG_ON( unlikely( cr0 &amp; X86_CR0_WP ) ); write_cr0( cr0 ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cr0 ^ X86_CR0_WP; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">native_pai_close_kernel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cr0; cr0 = read_cr0() ^ X86_CR0_WP; BUG_ON( unlikely( !( cr0 &amp; X86_CR0_WP ) ) ); write_cr0( cr0 ); barrier(); local_irq_enable(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cr0 ^ X86_CR0_WP; }</code> </pre><br>  This code is successfully compiled and works in both 32 and 64 bit architectures and this is its advantage over the previous one. <br><br><h1>  Removing protection from memory page </h1><br>  The next proposed method is to set the _PAGE_BIT_RW bit in a PTE record that describes the memory page of interest (rw_pte.c file): <br><pre> <code class="hljs lua">#include &lt;asm/pgtable_types.h&gt; #include &lt;asm/tlbflush.h&gt; static inline void mem_setrw( void **<span class="hljs-built_in"><span class="hljs-built_in">table</span></span> ) { unsigned int l; pte_t *pte = lookup_address( (long unsigned int)<span class="hljs-built_in"><span class="hljs-built_in">table</span></span>, &amp;l ); pte-&gt;pte |= _PAGE_RW; __flush_tlb_one( (unsigned long)<span class="hljs-built_in"><span class="hljs-built_in">table</span></span> ); } static inline void mem_setro( void **<span class="hljs-built_in"><span class="hljs-built_in">table</span></span> ) { unsigned int l; pte_t *pte = lookup_address( (long unsigned int)<span class="hljs-built_in"><span class="hljs-built_in">table</span></span>, &amp;l ); pte-&gt;pte &amp;= ~_PAGE_RW; __flush_tlb_one( (unsigned long)<span class="hljs-built_in"><span class="hljs-built_in">table</span></span> ); }</code> </pre><br>  Logically, the code is absolutely clear.  The code itself in the form of how it is shown here, I first met in the <a href="http://habrahabr.ru/post/207122/">discussion</a> on Habrahabr (Alexey Derlaft, Vladimir, 2013), and later, much more thoroughly, in the discussion on the forum <a href="http://rus-linux.net/forum/viewtopic.php%3Ff%3D18%26t%3D4346%26start%3D10">modification of system calls</a> (Max Filippov, St. Petersburg, 2015.). <br>  This code is verified in both 32 and 64 bit architecture. <br><br><h1>  Overlay mapping </h1><br>  Another method (the last one considered today) is proposed in the article <a href="http://habrahabr.ru/post/207122/">‚ÄúThe kosher method of modifying write-protected areas of the Linux kernel‚Äù</a> (Ilya V. Matveychikov, Moscow, late 2013).  I don‚Äôt say anything good or bad about the author‚Äôs culinary tastes of his national cuisine ... I don‚Äôt know, but with regard to the proposed technique, I should note that he is original and beautiful (rw_map.c file): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_writable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *vaddr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nr_pages = DIV_ROUND_UP( offset_in_page( addr ) + len, PAGE_SIZE ); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class"> **</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pages</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kmalloc</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr_pages</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pages</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GFP_KERNEL</span></span></span><span class="hljs-class"> );</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *page_addr = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)addr &amp; PAGE_MASK ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pages == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nr_pages; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( __module_address( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)page_addr ) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) { pages[ i ] = virt_to_page( page_addr ); WARN_ON( !PageReserved( pages[ i ] ) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pages[i] = vmalloc_to_page(page_addr); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pages[ i ] == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) { kfree( pages ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } page_addr += PAGE_SIZE; } vaddr = vmap( pages, nr_pages, VM_MAP, PAGE_KERNEL ); kfree( pages ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( vaddr == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vaddr + offset_in_page( addr ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmap_writable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *page_addr = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)addr &amp; PAGE_MASK ); vfree( page_addr ); }</code> </pre><br>  This method works in both 32 and 64 bit architecture.  It can be attributed to some minus some cumbersomeness for solving a rather simple task (‚Äúfrom a cannon on sparrows‚Äù), despite the fact that, at first glance, it does not show significant advantages over previous methods.  But this technique (and practically unchanged this code) can be successfully used for a wider range of tasks than the one discussed. <br><br><h1>  Test run </h1><br>  And now, in order not to be unfounded, it is time to check all the above-said by a full-scale experiment.  To check, we will create a kernel module (file srw.c): <br><pre> <code class="hljs lua">#include <span class="hljs-string"><span class="hljs-string">"rw_cr0.c"</span></span> #include <span class="hljs-string"><span class="hljs-string">"rw_pte.c"</span></span> #include <span class="hljs-string"><span class="hljs-string">"rw_pax.c"</span></span> #include <span class="hljs-string"><span class="hljs-string">"rw_map.c"</span></span> #include <span class="hljs-string"><span class="hljs-string">"rw_pai.c"</span></span> #define PREFIX <span class="hljs-string"><span class="hljs-string">"! "</span></span> #define LOG(...) printk( KERN_INFO PREFIX __VA_ARGS__ ) #define ERR(...) printk( KERN_ERR PREFIX __VA_ARGS__ ) #define __NR_rw_test <span class="hljs-number"><span class="hljs-number">31</span></span> //   sys_call_table static int mode = <span class="hljs-number"><span class="hljs-number">0</span></span>; module_param( mode, uint, <span class="hljs-number"><span class="hljs-number">0</span></span> ); #define do_write( addr, val ) { \ LOG( <span class="hljs-string"><span class="hljs-string">"writing address %p\n"</span></span>, addr ); \ *addr = val; \ } static bool <span class="hljs-built_in"><span class="hljs-built_in">write</span></span>( void** addr, void* val ) { switch( mode ) { case <span class="hljs-number"><span class="hljs-number">0</span></span>: rw_enable(); do_write( addr, val ); rw_disable(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; case <span class="hljs-number"><span class="hljs-number">1</span></span>: native_pax_open_kernel(); do_write( addr, val ); native_pax_close_kernel(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; case <span class="hljs-number"><span class="hljs-number">2</span></span>: mem_setrw( addr ); do_write( addr, val ); mem_setro( addr ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; case <span class="hljs-number"><span class="hljs-number">3</span></span>: addr = map_writable( (void*)addr, sizeof( val ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == addr ) { ERR( <span class="hljs-string"><span class="hljs-string">"wrong mapping\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } do_write( addr, val ); unmap_writable( addr ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; case <span class="hljs-number"><span class="hljs-number">4</span></span>: native_pai_open_kernel(); do_write( addr, val ); native_pai_close_kernel(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; default: ERR( <span class="hljs-string"><span class="hljs-string">"illegal mode %d\n"</span></span>, mode ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } static int __init rw_init( void ) { void **taddr; //  sys_call_table asmlinkage long (*sys_ni_syscall) ( void ); //   __NR_rw_test <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == ( taddr = (void**)kallsyms_lookup_name( <span class="hljs-string"><span class="hljs-string">"sys_call_table"</span></span> ) ) ) { ERR( <span class="hljs-string"><span class="hljs-string">"sys_call_table not found\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EFAULT; } LOG( <span class="hljs-string"><span class="hljs-string">"sys_call_table address = %p\n"</span></span>, taddr ); sys_ni_syscall = (void*)taddr[ __NR_rw_test ]; //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>( taddr + __NR_rw_test, (void*)<span class="hljs-number"><span class="hljs-number">0x12345</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; LOG( <span class="hljs-string"><span class="hljs-string">"modified sys_call_table[%d] = %p\n"</span></span>, __NR_rw_test, taddr[ __NR_rw_test ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>( taddr + __NR_rw_test, (void*)sys_ni_syscall ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; LOG( <span class="hljs-string"><span class="hljs-string">"restored sys_call_table[%d] = %p\n"</span></span>, __NR_rw_test, taddr[ __NR_rw_test ] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPERM; } module_init( rw_init );</code> </pre><br>  Some heaviness, the bulkiness of the code is due only to the fact that: <br><ul><li>  In a single code, it was necessary to agree on various prototypes of functions that allow writing, belonging to different methods (they are the same in action, but called differently). </li><li>  The implementation for different methods was kept as close as possible to how it was written by different authors (changes were made only to match the syntax with more recent versions of the kernels).  This explains the variety of prototype functions. </li></ul><br><br>  And this is how it looks in only one of the tested architectures (at least 5 different architectures and kernel versions were actually tested) using all the methods one after the other: <br><pre> <code class="dos hljs">$ uname -r <span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">16</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">48</span></span>-generic $ uname -m x86_64 $ sudo insmod srw.ko <span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span> insmod: ERROR: could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> insert module srw.ko: Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted $ dmesg | tail -n6 [ <span class="hljs-number"><span class="hljs-number">7258</span></span>.<span class="hljs-number"><span class="hljs-number">575977</span></span>] ! detected <span class="hljs-number"><span class="hljs-number">64</span></span>-bit platform [ <span class="hljs-number"><span class="hljs-number">7258</span></span>.<span class="hljs-number"><span class="hljs-number">584504</span></span>] ! sys_call_table address = ffffffff81801460 [ <span class="hljs-number"><span class="hljs-number">7258</span></span>.<span class="hljs-number"><span class="hljs-number">584579</span></span>] ! writing address ffffffff81801558 [ <span class="hljs-number"><span class="hljs-number">7258</span></span>.<span class="hljs-number"><span class="hljs-number">584653</span></span>] ! modified sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = <span class="hljs-number"><span class="hljs-number">0000000000012345</span></span> [ <span class="hljs-number"><span class="hljs-number">7258</span></span>.<span class="hljs-number"><span class="hljs-number">584654</span></span>] ! writing address ffffffff81801558 [ <span class="hljs-number"><span class="hljs-number">7258</span></span>.<span class="hljs-number"><span class="hljs-number">584666</span></span>] ! restored sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = ffffffff812db550 $ sudo insmod srw.ko <span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>=<span class="hljs-number"><span class="hljs-number">2</span></span> insmod: ERROR: could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> insert module srw.ko: Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted $ dmesg | tail -n6 [ <span class="hljs-number"><span class="hljs-number">7282</span></span>.<span class="hljs-number"><span class="hljs-number">625539</span></span>] ! detected <span class="hljs-number"><span class="hljs-number">64</span></span>-bit platform [ <span class="hljs-number"><span class="hljs-number">7282</span></span>.<span class="hljs-number"><span class="hljs-number">633020</span></span>] ! sys_call_table address = ffffffff81801460 [ <span class="hljs-number"><span class="hljs-number">7282</span></span>.<span class="hljs-number"><span class="hljs-number">633129</span></span>] ! writing address ffffffff81801558 [ <span class="hljs-number"><span class="hljs-number">7282</span></span>.<span class="hljs-number"><span class="hljs-number">633178</span></span>] ! modified sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = <span class="hljs-number"><span class="hljs-number">0000000000012345</span></span> [ <span class="hljs-number"><span class="hljs-number">7282</span></span>.<span class="hljs-number"><span class="hljs-number">633228</span></span>] ! writing address ffffffff81801558 [ <span class="hljs-number"><span class="hljs-number">7282</span></span>.<span class="hljs-number"><span class="hljs-number">633291</span></span>] ! restored sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = ffffffff812db550 $ sudo insmod srw.ko <span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> insmod: ERROR: could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> insert module srw.ko: Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted $ dmesg | tail -n6 [ <span class="hljs-number"><span class="hljs-number">7297</span></span>.<span class="hljs-number"><span class="hljs-number">040272</span></span>] ! detected <span class="hljs-number"><span class="hljs-number">64</span></span>-bit platform [ <span class="hljs-number"><span class="hljs-number">7297</span></span>.<span class="hljs-number"><span class="hljs-number">059764</span></span>] ! sys_call_table address = ffffffff81801460 [ <span class="hljs-number"><span class="hljs-number">7297</span></span>.<span class="hljs-number"><span class="hljs-number">065930</span></span>] ! writing address ffffc900001e6558 [ <span class="hljs-number"><span class="hljs-number">7297</span></span>.<span class="hljs-number"><span class="hljs-number">066000</span></span>] ! modified sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = <span class="hljs-number"><span class="hljs-number">0000000000012345</span></span> [ <span class="hljs-number"><span class="hljs-number">7297</span></span>.<span class="hljs-number"><span class="hljs-number">066035</span></span>] ! writing address ffffc9000033d558 [ <span class="hljs-number"><span class="hljs-number">7297</span></span>.<span class="hljs-number"><span class="hljs-number">066073</span></span>] ! restored sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = ffffffff812db550 $ sudo insmod srw.ko <span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>=<span class="hljs-number"><span class="hljs-number">4</span></span> insmod: ERROR: could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> insert module srw.ko: Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted $ dmesg | tail -n6 [ <span class="hljs-number"><span class="hljs-number">7309</span></span>.<span class="hljs-number"><span class="hljs-number">831119</span></span>] ! detected <span class="hljs-number"><span class="hljs-number">64</span></span>-bit platform [ <span class="hljs-number"><span class="hljs-number">7309</span></span>.<span class="hljs-number"><span class="hljs-number">836299</span></span>] ! sys_call_table address = ffffffff81801460 [ <span class="hljs-number"><span class="hljs-number">7309</span></span>.<span class="hljs-number"><span class="hljs-number">836311</span></span>] ! writing address ffffffff81801558 [ <span class="hljs-number"><span class="hljs-number">7309</span></span>.<span class="hljs-number"><span class="hljs-number">836359</span></span>] ! modified sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = <span class="hljs-number"><span class="hljs-number">0000000000012345</span></span> [ <span class="hljs-number"><span class="hljs-number">7309</span></span>.<span class="hljs-number"><span class="hljs-number">836368</span></span>] ! writing address ffffffff81801558 [ <span class="hljs-number"><span class="hljs-number">7309</span></span>.<span class="hljs-number"><span class="hljs-number">836424</span></span>] ! restored sys_call_table[<span class="hljs-number"><span class="hljs-number">31</span></span>] = ffffffff812db550</code> </pre><br><br><h1>  Discussion </h1><br>  This review is not intended as a textbook or guide to action.  Here, only systematically collected various techniques with equivalent, essentially, the actions used by different authors. <br><br>  It would be interesting to continue the discussion regarding the advantages and disadvantages of each of these methods. <br><br>  Or supplement the listed ways to perform an action with new variants ... 5th, 6th, etc. <br><br>  All the codes discussed (for testing, or using, or further improving) can be taken <a href="https://yadi.sk/d/stzgH1xEjsaLq">here</a> or <a href="https://drive.google.com/file/d/0B__cqmYoRw_6ejN0b0E3dWFkX0U/view%3Fusp%3Dsharing">here</a> . </cut></div><p>Source: <a href="https://habr.com/ru/post/269193/">https://habr.com/ru/post/269193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269181/index.html">How to organize a paid support for a complex product: the experience of "Hydra"</a></li>
<li><a href="../269183/index.html">Part 2. Publishing apps in the Office Store</a></li>
<li><a href="../269187/index.html">Wrinkle Cards in The Blacksmith Video</a></li>
<li><a href="../269189/index.html">Testing mobile apps: tips & tricks</a></li>
<li><a href="../269191/index.html">Algorithm for extracting information in ABBYY Compreno. Part 1</a></li>
<li><a href="../269195/index.html">Indoor Navigation: Great iBeacon Hardware Review</a></li>
<li><a href="../269201/index.html">Billing a new generation. Part 1</a></li>
<li><a href="../269203/index.html">MultiCAD.NET API: insert block with attributes</a></li>
<li><a href="../269205/index.html">RAD Studio 10 World Tour in St. Petersburg</a></li>
<li><a href="../269207/index.html">Angular2 close</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>