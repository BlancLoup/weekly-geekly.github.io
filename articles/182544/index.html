<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to evaluate firmware testing tools</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction from the author of the post 
 Having experience in software development for critical systems for more than 8 years, I want to acquaint th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to evaluate firmware testing tools</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction from the author of the post </h4><br>  Having experience in software development for critical systems for more than 8 years, I want to acquaint the community with some materials related to software development and verification for critical systems (aerospace, medicine, transport, and industry).  Having consented to the translation and adaptation of a number of interesting articles from foreign colleagues, I decided to use this resource.  I would be glad if the article will interest our community.  The article uses materials from the company Vector Software, Inc. <br>  I will answer questions in comments or in lichku <br><br><h4>  What is your testing tool? </h4><br>  Over the past few years, the market for automated testing tools has been filled with tools claiming to perform the same function ‚Äî automated testing.  Wikipedia lists 38 test environment assessment tools for C / C ++ programming languages ‚Äã‚Äãonly.  Unfortunately, potential users, studying the description of these products, as well as their simplified demos, can conclude that most of the tools are almost the same. <br><br>  The purpose of this document is to provide engineers with information that needs to be taken into account when evaluating automated software testing tools, especially in terms of automated dynamic testing tools. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  You cannot evaluate the testing tool by reading its specification. </h4><br>  All specifications look quite the same.  The keywords are the same: ‚Äúindustry leader‚Äù, ‚Äúunique technology‚Äù, ‚Äúautomated testing‚Äù, ‚Äúbest practices‚Äù.  Screenshots are alike: histograms, structural diagrams, HTML reports and percentages.  All this casts boredom. <br><br><a name="habracut"></a><br><br><h4>  What is software testing? </h4><br>  Everyone who has ever been involved in software testing knows that it consists of many components.  For simplicity, we will use three terms: <br><ul><li>  System Testing - Testing a fully integrated software application </li><li>  Integration Testing - Testing Integrated Groups of Software Modules </li><li>  Unit Testing - Testing individual modules of the application‚Äôs source code </li></ul><br>  Each one conducts system testing to varying degrees, during which it performs some of the actions that the end user will perform.  Notice, we are talking about some actions, not about "all possible."  One of the most common causes of errors in an application is the appearance of unforeseen and, therefore, unexplored combinations of input data. <br><br>  Not many people do integration testing, and very few do unit testing.  If you performed integration or unit testing, you know how many test codes you need to create in order to isolate a single file or group of files from everyone else in the application.  At the most demanding levels of testing, there is a situation where the amount of written code for testing exceeds the amount of code being tested.  As a result, such testing levels are applied, as a rule, to applications that are critical for functionality and safety in such areas as aviation, medical devices, and the railway industry. <br><br><h4>  What does automated testing mean? </h4><br>  It is well known that the process of integration and unit testing by hand is extremely expensive and time consuming;  as a result, every instrument appearing on the market is ‚Äútrumped‚Äù as if using automated testing.  But what does this mean - ‚Äúautomated testing‚Äù?  Different people understand the word ‚Äúautomation‚Äù in their own way.  For many developers, automated testing means the ability to click a button and get a result - a ‚Äúgreen tick‚Äù, meaning that the code is correct or a ‚Äúred cross‚Äù, meaning an error. <br><br>  Unfortunately, this tool does not exist.  And if it existed, would you want to use it?  Think about it.  What would it mean if the tool showed that your code is ‚Äúin order‚Äù?  Would it mean that the code is flawlessly formatted?  Maybe.  Would it mean that the code conforms to your coding standards?  Maybe.  Would it mean that the code is correct?  Definitely not! <br><br>  Fully automated testing is unattainable and, in principle, undesirable.  Automation should be focused on the algorithmic and time-consuming parts of the testing process.  This will free software developers from constantly creating increasingly sophisticated and complex tests. <br><br>  When evaluating testing tools, a logical question arises: what degree of automation does this testing tool provide?  This is the main area of ‚Äã‚Äãuncertainty when an organization attempts to calculate the return on investment in testing tools. <br><br><h4>  Analysis of testing tools </h4><br>  Testing tools generally provide a variety of functionality.  Since different tools are provided by different companies, the functionality may differ when using another tool.  In accordance with the common criteria system, we chose the following names for components that may exist in the evaluated testing tools: <br><ul><li>  <i>Analyzer</i> - This component allows the testing tool to understand your code.  It reads the code and creates an intermediate representation of the code (usually in a hierarchical structure).  Essentially the compiler does the same thing.  Its output data or ‚Äúanalyzer data‚Äù is usually stored in a file in an intermediate language. </li><li>  <i>Code Generator</i> - The code generator uses ‚Äúparser data‚Äù to construct the source code of a test program. </li><li>  <i>Test program</i> - Although the test program, strictly speaking, is not part of the test tool, the decisions made during the test program build process affect the rest of the test tool.  Therefore, the architecture of such a program is of great importance in evaluating the testing tool. </li><li>  <i>Compiler</i> - Allows the test tool to initiate the compilation and linking of test program components. </li><li>  <i>Target Component</i> ‚Äî Allows test scripts to run in a variety of environments, including support for emulator programs, simulators, embedded debugger programs, and real-time commercial operating systems. </li><li>  <i>Test editor</i> - The test editor allows the user to use both a scripting language and a sophisticated graphical user interface to set preconditions and expected values ‚Äã‚Äã(pass / fail criteria) for a test script. </li><li>  <i>Coverage</i> - Allows the user to get a report on which parts of the code are checked by the test. </li><li>  <i>Report Component</i> - Allows you to combine the data collected during the passage of the tests into a single project documentation. </li><li>  <i>Command Line Interpreter</i> - Provides additional automation when using the testing tool by activating the tool using scripts, make utility, etc. </li><li>  <i>Regression component</i> - Allows tests created for one software version to be restarted for new versions. </li><li>  <i>Integration Component</i> - Integration with third-party tools can be a significant factor in deciding whether to invest in testing tools.  As a rule, integration with configuration management systems, requirements management tools and static analysis tools is common. </li></ul><br>  The following sections will describe in more detail how the above components should be evaluated in the testing tool in question. <br><br><h4>  Types of test tools / automation levels </h4><br>  Due to the fact that none of the testing tools includes all the functionality of the testing components described above, and due to significant differences between the tools according to the degree of automation, we have created the following broad classification of testing tools.  The estimated instrument can be attributed to one of the following groups: <br><ul><li>  <i>Manual</i> - ‚ÄúManual‚Äù tools create an empty framework for the test program and require you to manually write the test data code and the logical part to execute the test script.  As a rule, they provide a scripting language and / or a set of library functions that can be used for such common processes as test confirmations or the creation of tabular reports for test documentation. </li><li>  <i>Semi-Automated</i> - Semi-automated tools may have a graphical interface and some automated functionality, but still require manual code writing and / or script development for testing more complex designs.  Also, semi-automated tools may lack some components of automated tools, for example, built-in support for deploying software on a target platform. </li><li> <i>Automated</i> - Automated tools have a link to each functional area or component listed in the previous section.  Tools of this group do not require manual coding and support all language constructs as well as software deployment on different target platforms. </li></ul><br><br><h4>  Implicit testing tool differences </h4><br>  In addition to comparing tool features and automation levels, it is important to evaluate and compare the testing approaches used.  For example, when you create a test project, the tool simply loads the files into its integrated development environment, but does not create a test program or test script until you take certain actions. <br><br>  As a result, there may be hidden flaws in the testing tool.  Therefore, it is important not only to load your code into the testing tool, but also to try to build some simple test scripts for each method in the class that you are testing.  Does the tool build a complete test program?  Are stubs created automatically?  Can you use a graphical user interface to define parameters and general data for test scripts, or do you have to write code manually, as if you were testing manually? <br><br>  Similarly, support for the target platform differs in the tools used.  Be careful if the provider says: "We support all compilers and targets."  This means only one thing: ‚ÄúYou have to do all the work so that our tool works in your work environment.‚Äù <br><br><h4>  How to evaluate testing tools </h4><br>  The next few sections will describe in detail what information you should carefully consider when evaluating a software testing tool.  Ideally, you should confirm the information obtained in practice by testing each of the proposed tools. <br><br>  Due to the fact that the subsequent material in this documentation will be of a technical nature, we would like to introduce some symbols.  Each section has a title that describes the question to be considered, a further explanation of why this issue is important, and, finally, ‚Äúkey points‚Äù as a summary of the material reviewed. <br><br>  Also, speaking of the conventions, we must pay attention to the terminology.  The term ‚Äúfunction‚Äù refers to both the function of the programming language C and the class method of the programming language C ++, the term ‚Äúmodule‚Äù refers to both the file of the programming language C and the class of the programming language C ++.  Finally, it must be remembered that almost all testing tools in some way support the points mentioned in the ‚Äúkey points‚Äù, your task is to evaluate the level of automation, ease of use and degree of support. <br><br><h4>  Analyzer and code generator </h4><br>  It is relatively simple to build an analyzer for the C programming language;  much harder to build a full-featured analyzer for the programming language C ++.  One of the questions that needs to be answered in the assessment process is how reliable and well thought out analyzer technology.  Some suppliers of testing tools acquire and resell licensed analyzer technology, others have own-made analyzers.  The reliability of the analyzer and the code generator can be checked with the help of complex code constructions - typical code samples that you will use in your project. <br><br><h4>  Test driver </h4><br>  The test driver is the main testing control program.  Let's give a simple example of a driver that will test the sine mathematical function from the standard library of the C programming language: <br><br><pre><code class="hljs lua">#include &lt;<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.h&gt; #include &lt;stdio.h&gt; int main () { float <span class="hljs-keyword"><span class="hljs-keyword">local</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> (<span class="hljs-number"><span class="hljs-number">90.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">local</span></span> == <span class="hljs-number"><span class="hljs-number">1.0</span></span>) printf (<span class="hljs-string"><span class="hljs-string">"My Test Passed!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> printf (<span class="hljs-string"><span class="hljs-string">"My Test Failed!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Although this is a fairly simple example, a ‚Äúmanual‚Äù testing tool may require you to type (and debug) this small piece of code manually, a semi-automated tool will produce some type of scripting language or a simple GUI to enter the sine argument.  The automated tool will contain a full-fledged GUI for building test scenarios, an integrated code coverage analysis, an integrated debugger program and an integrated software deployment capability on the target platform. <br><br>  I wonder if you noticed that there is an error in this driver.  It lies in the fact that the function of calculating the sine actually uses the angle as the input of the radians, not degrees. <br><br><h4>  Using stubs for dependent functions </h4><br>  Building substitutions for dependent functions is necessary when you want to control the values ‚Äã‚Äãreturned by the dependent function during the test.  The use of stubs is an important part of integration and unit testing, as it allows you to isolate the code being tested from other parts of the application and it is easier to test the subsystem of interest. <br><br>  Many tools require manual creation of a test code for stub to perform something more complicated except for returning a static scalar value (return0;) <br><br><h4>  Test data </h4><br>  There are two main approaches used by semi-automated and automated tools in the implementation of the test scenario.  The first is the data-driven architecture, the second is the architecture of the unit test. <br><br>  For a data-driven architecture, a test program is created for all modules under test and supports all the functions defined in these modules.  When a test is run, the tool supplies data to the information flow, such as a file descriptor or a physical interface, such as a UART. <br><br>  For a single test architecture, each time a test is run, the tool creates a test driver and compiles it into an executable program.  It is important to note a couple of points;  first, the creation of additional code required for a single test, as well as subsequent compilation will take more time during the test;  secondly, as a result, you create separate test programs for each test case. <br><br>  This means that the evaluated tool can work normally for certain nominal scenarios and does not work correctly for more complex tests. <br><br><h4>  Automated test data generation </h4><br>  Various automated tools provide a degree of automation in the creation of a test script.  Different approaches are used for this, some of them are shown in the table below: <br><ul><li>  <i>(MMM) Min-wednesday-max test scripts</i> - MMM tests check functions for boundary values ‚Äã‚Äãof input data types.  Code in C and C ++ programming languages ‚Äã‚Äãoften does not protect itself from input data outside the allowable range. </li><li>  <i>(EC) Equivalence classes</i> - EC tests are as follows: the data is divided into equivalence classes, according to the principle that the program behaves in the same way with each representative of a particular class.  Thus, not all possible data are checked, but individual members of the class. </li><li>  <i>(RV) Random Variables</i> - RV tests specify combinations of random values ‚Äã‚Äãfor each parameter of a function. </li><li>  <i>(BP) Tests on conditional operator branches</i> - BP tests can automatically create high-level coverage on conditional operator branches. </li></ul><br>  When thinking about the automated creation of test scripts, it is important to remember what purpose they serve.  Automated tests are good for assessing the robustness (reliability) of an application code, but not for correctness (even if they provide a high level of code coverage).  For correctness, you must create tests based on what is expected of the application (requirements), and not what it does (code). <br><br><h4>  Compiler integration </h4><br>  Compiler integration has a double meaning.  On the one hand, integration allows you to automatically build test program components without the need for the user to enter compiler parameters.  On the other hand, integration allows the test tool to accept for processing any language extensions specific to the compiler used.  A common practice is that cross-compilers support extensions that are not part of the C / C ++ programming language standards.  Some tools define such extensions as the empty string.  This is a very rough approach and its main disadvantage is that it changes the object code generated by the compiler.  For example, consider the following global external variable with the GCC attribute: <br><pre> <code class="hljs lisp">extern int MyGlobal __attribute__ ((<span class="hljs-name"><span class="hljs-name">aligned</span></span> (<span class="hljs-number"><span class="hljs-number">16</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  If the tool in question does not support the attribute when defining a global MyGlobal object, then the code will behave differently in the testing process and in working condition, since the alignment will not be the same. <br><br><h4>  Support for testing on the target platform </h4><br>  In this section, we will use the term ‚Äútoolkit‚Äù as applied to the development environment, including cross-compiler, debugging interface (emulator), target platform, and real-time operating system (RTOS).  It is important to find out if the tool in question has excellent integration with your toolbox and understand what needs to be changed in the tool for migration to another toolbox. <br><br>  It is also important to find out the level of automation and reliability of integration with the target platform.  As mentioned earlier, if the provider says: ‚ÄúWe support all compilers and target platforms,‚Äù this means only one thing: ‚ÄúYou have to do all the work for our tool to work in your production environment.‚Äù <br><br>  Ideally, the tool you have chosen should perform ‚Äúone button click‚Äù testing, and all the difficulties of downloading software to the target platform and collecting test results on the working machine are hidden behind the message ‚ÄúRunning test‚Äù, so that the user does not need any special actions . <br><br>  An additional challenge to testing on a target platform is the issue of hardware availability.  Often, the hardware is developed in parallel with the software or there is a limitation of access to the hardware.  An important point is the ability to start testing in your own environment and later make the transition to a real target platform.  Ideally, the test tool artifacts should be hardware independent. <br><br><h4>  Test Script Editor </h4><br>  Obviously, it is in the test script editor that you will spend most of your time when using the testing tool.  If the tool truly supports the automation of the listed items mentioned above, then the amount of time spent on setting up the test environment and communication from the target platform will be minimal.  Remember what we said at the beginning ‚Äî our goal is for engineers to use their time to create more sophisticated and more complete tests. <br><br>  An important question that needs to be answered when evaluating is how difficult it is to set test input data and expected values ‚Äã‚Äãfor non-trivial constructions.  The existing tools on the market provide a fairly simple way to set scalar values.  For example, is the evaluated tool equipped with a simple and intuitive way to construct classes?  What about setting up an STL container like vector or map.  Such nuances should be evaluated in the test script editor. <br><br><h4>  Code coverage </h4><br>  Most semi-automated and all automated testing tools contain an embedded code coverage tool that allows you to see metrics that show the amount of software code that is executed when you run your test scripts.  Some tools provide this information in tabular form.  Others give a flow graph, and some give a commentary listing of the source code.  Although the table is a good representation of a summary, but if you are trying to achieve 100% code coverage, a listing with comments is the best way.  This listing shows the source file with staining for the coated, partially coated and uncoated structures.  This makes it easy to see which additional test scenarios are needed for 100% coverage. <br><br>  It is also important to evaluate the impact of the toolkit, since additional source code is added to your software.  There are two points that need to be taken into account: one is an increase in the size of the object code, the second is additional costs during program execution.  It is important to understand whether your software has limitations in terms of memory or program runtime (or both).  This will help focus attention on what is more important for your software. <br><br><h4>  Regression testing </h4><br>  When choosing a testing tool, we must remember two main goals.  The first goal is to save testing time.  If you have read these words, then you agree with us.  The second goal is to ensure the effective use of the tests created during the software life cycle.  This means that time and money invested in the creation of tests should result in the possibility of multiple use of tests (when software changes over time) and should ensure the ease of configuration management of these tests.  The main thing is to evaluate in the instrument you are interested in, which individual entities should be saved for passing the same tests in the future, and how the restart is controlled. <br><br><h4>  Making report </h4><br>  Most tools provide a reporting function in a similar way.  At a minimum, they should produce an easy-to-understand report showing input data, expected output, actual output, and a comparison of expected and actual values. <br><br><h4>  Integration with other tools </h4><br>  Regardless of the quality or practical use of any individual instrument, all instruments must operate in an environment that unites systems from different manufacturers.  Large companies have spent a huge amount of time and money buying small companies that have developed a tool that performs ‚Äúeverything for everyone‚Äù.  For these mega tool sets, it is characteristic that "the total amount is less than the sum of the parts."  Companies often take 4-5 small but efficient tools and integrate them into one bulky and unusable tool. <br><br>  In addition to integration with the toolkit, which we have already considered, the most useful types of integration for testing tools are integration with static analysis, configuration management, and requirements management tools.  Everyone wants to keep the testing tool artifacts in the configuration management system (to reuse them), and most people would like to trace the requirements to the test scripts. <br><br><h4>  Additional desirable characteristics of the testing tool </h4><br>  We have completed the review of the ‚ÄúAnalysis of Testing Tools‚Äù section.  The previous sections described the functional content that is found in any tool considered automated.  In the following sections, we will list some desired (and less common) characteristics, while at the same time arguing the importance of these characteristics.  These characteristics may have different levels of applicability to your project. <br><br><h4>  True Integration Testing / Multi-Module Testing </h4><br>  Integration testing is a continuation of unit testing.  It is used to test the interfaces between modules and requires you to combine modules that perform a specific functional process.  Many tools are declared as supporting integration testing by linking object code for real modules using a test program.  This method constructs many files within the test program being executed, but does not provide the ability to activate functions within these additional modules.  Ideally, you should be able to activate any function in any module in any order within a single test scenario.  Testing interfaces between modules as a whole will reveal many hidden assumptions and bugs in software.  In fact, integration testing can be the first step for projects that do not have a unit testing history. <br><br><h4>  Using dynamic stubs </h4><br>  Creating dynamic stubs means the ability to dynamically enable and disable their own stub functions.  This allows you to create a test for an individual function, silencing all other functions (even if they exist in the same module as the function being tested).  For very complex code, this is the most important feature that greatly simplifies the execution of testing. <br><br><h4>  Testing at the library and application level </h4><br>  One of the difficult problems with system testing is that test impact directed to fully integrated software may require the user to press buttons and switches or print on the console.  If the application is embedded, the input will be even harder to control.  Suppose you can submit external influences on a functional level, similar to the integration testing way.  This will allow you to build a set of test scenarios, based only on the software API. <br><br>  Some of the most advanced tools allow you to test this way.  An additional advantage of this test mode is the absence of the need for source code to test the application.  You just need an API definition (usually header files).  This methodology provides the tester with an automated and scripted way of performing system testing. <br><br><h4>  Agile testing and development through testing (TDD) </h4><br>  Development through testing implies the following: instead of first writing the application code and, secondly, testing the module, you first create the tests before writing the application code.  This is a new popular approach to development - to develop a test first.  Your automated tool should support this testing method if you plan on using a flexible development methodology. <br><br><h4>  Bidirectional integration with requirements management tools </h4><br>  If you are concerned with linking requirements with test scenarios, then integrating a testing tool with a requirements management tool is desirable.  If you are interested in this feature, it is important to note the bi-directionality of the interface;  when requirements are marked in test scenarios, test scenario information, such as the test name and the pass / fail status, is transferred to the requirements database.  This allows you to get a sense of completeness testing requirements. <br><br><h4>  Tool qualification </h4><br>  If you work in a regulated environment, such as civil aviation or the manufacture of class III medical devices, then you must qualify the development tools used to build and test your application. <br><br>  Qualification involves documenting the purpose of the instrument (its operational requirements) and the results of tests proving that the instrument works in accordance with these requirements.  Ideally, the supplier should have these materials in finished form, as well as the history of customers who used the qualification data in their industry. <br><br><h4>  Conclusion </h4><br>  Remember that virtually every firmware testing tool supports the points mentioned at key points in one way or another.  It is important to understand how automated it is, easy to use, and evaluate the usefulness of support. </div><p>Source: <a href="https://habr.com/ru/post/182544/">https://habr.com/ru/post/182544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182520/index.html">Indexing nonatomic attributes</a></li>
<li><a href="../182522/index.html">Yandex's position on the new draft law on Internet regulation</a></li>
<li><a href="../182526/index.html">Bitbucket released a limited edition of branded T-shirts</a></li>
<li><a href="../182528/index.html">Ubuntu Phone already supports internet connection, social apps, calls and more</a></li>
<li><a href="../182540/index.html">Intel has introduced the fastest "Thunderbolt flash drive" in the world</a></li>
<li><a href="../182548/index.html">Reading the official data on the number of municipalities with text formatting options using the xlrd library</a></li>
<li><a href="../182554/index.html">Larry Page about the PRISM program: "What the ...?"</a></li>
<li><a href="../182556/index.html">Create Awesome Apps on AngularJS</a></li>
<li><a href="../182558/index.html">IFXmanager - infrastructure management system</a></li>
<li><a href="../182560/index.html">IPv6 - one year later</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>