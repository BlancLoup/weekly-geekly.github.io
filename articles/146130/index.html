<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protect gitlab and gitolite from password and key picking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most recently, an attack began on my server with a git repository on the selection of passwords to gitlab and keys to ssh. The intentions of the intru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protect gitlab and gitolite from password and key picking</h1><div class="post__text post__text-html js-mediator-article">  Most recently, an attack began on my server with a git repository on the selection of passwords to gitlab and keys to ssh.  The intentions of the intruders are clear - pull out the source code of the proprietary application stored in git. <br><br>  I do not quite understand the attempts to select ssh-keys, because  It‚Äôs problematic to choose an RSA key (it will take dozens of years), but I did make some restrictions so that the logs would not be so ‚Äúdirty‚Äù. <br><br>  Who cares how to protect gitolite and gitlab (works for nginx) from selecting passwords - welcome under cat. <br><a name="habracut"></a><br><h4>  Ssh protection </h4><br>  Many people know that Linux sshd by itself does not know how to limit the number of connections.  For us, this was not a problem, we limited them to the firewall level. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the standard iptables distribution under CentOS there is a hashlimit module.  We will use it.  I wrote the following rules for iptables: <br><pre><code class="bash hljs">iptables -N ssh_input iptables -A ssh_input \ -m hashlimit \ --hashlimit 5/m \ --hashlimit-burst 5 \ --hashlimit-mode srcip,dstport \ --hashlimit-name ssh \ --hashlimit-htable-expire 3600000 \ -j ACCEPT iptables -A ssh_input -p tcp -j REJECT --reject-with tcp-reset iptables -A INPUT -m state -m tcp -p tcp --dport 22 --state NEW -j ssh_input</code> </pre> <br>  What did we do?  First we added the ssh_input chain.  Then we add a rule that limits the number of connections to 5 per minute (--hashlimit 5 / m --hashlimit-burst 5).  In it we specify the parameters for which it is worthwhile to group connections (--hashlimit-mode srcip, dstport).  After we add the rule that denies access (-j REJECT).  And we add a chain to input with the conditions that the connections should be new and arrive at port 22. <br><br>  How do these rules work?  All packets with a new connection flag on port 22 are sent to the ssh_input chain for processing.  There, under the condition that the number of such connections from this ip does not exceed 5 per minute, the transmission of a packet occurs (-j ACCEPT).  If the conditions are not met go to the following rule: -j REJECT. <br><br>  Now our attacker can for years (tens, hundreds of years?) Pick up the ssh key.  And "zagazhivaniya" log will be smaller. <br><br><h4>  Gitlab protection </h4><br>  Also, attackers are trying to find a password to the gitlab web interface.  As front-end we use Nginx.  It is there rather old version 0.8.55 and it is not the time and desire to update it now. <br><br>  First of all, we add basic authorization and limit the number of connections per minute (so that it would not be so easy to pick up this password).  The problem of restriction in our case is such that loading a web page causes about 15 more calls to the server for statics.  This will force us to allow more than 15 connections per second.  This does not eliminate us.  having 15 connections per second on each ip, an attacker will be able to pick up a password and we do the following with ‚Äúears‚Äù: <br><br>  The login and password of the basic-authorization is <b>common to all users</b> and serves only as a hindrance to the selection of a password from the web application itself.  If so, then we can do the following check: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$http_authorization</span></span> != <span class="hljs-string"><span class="hljs-string">"Basic secretdsddsaadsdsasad=="</span></span>){ <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span>; break; }</code> </pre><br><br>  for all urls other than /.  In fact, we do basic authorization and a limit of 5 attempts per minute for 1 ip: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">limit_req_zone</span></span> <span class="hljs-variable"><span class="hljs-variable">$binary_remote_addr</span></span> zone=one:<span class="hljs-number"><span class="hljs-number">10m</span></span> rate=5r/m; ... <span class="hljs-section"><span class="hljs-section">server</span></span> { .... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> = / { <span class="hljs-attribute"><span class="hljs-attribute">auth_basic</span></span> <span class="hljs-string"><span class="hljs-string">"Top secret"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">auth_basic_user_file</span></span> /etc/nginx/conf.d/ssl/.htpasswd; <span class="hljs-attribute"><span class="hljs-attribute">limit_req</span></span> zone=one burst=<span class="hljs-number"><span class="hljs-number">5</span></span> nodelay; ..... } .... }</code> </pre><br><br>  And now let's imagine that our basic password was still picked up or stolen.  We also protect the application entry form: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">limit_req_zone</span></span> <span class="hljs-variable"><span class="hljs-variable">$binary_remote_addr</span></span> zone=two:<span class="hljs-number"><span class="hljs-number">10m</span></span> rate=5r/m; ... <span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> = /users/sign_in { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$http_authorization</span></span> != <span class="hljs-string"><span class="hljs-string">"Basic secretdsddsaadsdsasad=="</span></span>){ //       <span class="hljs-attribute"><span class="hljs-attribute">basic</span></span>  return <span class="hljs-number"><span class="hljs-number">403</span></span>; break; } <span class="hljs-attribute"><span class="hljs-attribute">limit_req</span></span> zone=two burst=<span class="hljs-number"><span class="hljs-number">5</span></span> nodelay; .... } .... }</code> </pre><br><br>  And finally, the main lockishin for other addresses: <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$http_authorization</span></span> != <span class="hljs-string"><span class="hljs-string">"Basic secretdsddsaadsdsasad=="</span></span>){ //       <span class="hljs-attribute"><span class="hljs-attribute">basic</span></span>  return <span class="hljs-number"><span class="hljs-number">403</span></span>; break; } ... } }</code> </pre><br><br>  Thus, when requesting without basic-authorization on any url except the root, we get 403. Basic-authorization is possible only at the root and is limited to 5 requests per minute.  Even if you select basic-authorization, the authorization form in the web application is limited to 5 requests per minute.  I allocated restrictions on entry to the basic and web applications to different zones so that input errors of different passwords in different places would not accumulate and real users would not get "Service unavailable". </div><p>Source: <a href="https://habr.com/ru/post/146130/">https://habr.com/ru/post/146130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146123/index.html">ASUS 1025CE review: the living of all living</a></li>
<li><a href="../146125/index.html">Gartner Magic Quadrant for Wireless LAN Access Infrastructure 2012-06</a></li>
<li><a href="../146126/index.html">NVIDIA commented on Linus Torvalds' critical remarks</a></li>
<li><a href="../146127/index.html">Samsung Galaxy Note: There is little or testing the battery at 4700 mAh</a></li>
<li><a href="../146128/index.html">Dolphin Browser acquires its own engine</a></li>
<li><a href="../146133/index.html">iRobot has equipped its robots with a remote control</a></li>
<li><a href="../146135/index.html">Gooseberry is an interesting alternative to the Raspberry Pi</a></li>
<li><a href="../146136/index.html">Depth of field in computer graphics</a></li>
<li><a href="../146137/index.html">My bike Entity FrameWork, Auto Migration, With Save Data</a></li>
<li><a href="../146139/index.html">Smart Case: update your smart cover?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>