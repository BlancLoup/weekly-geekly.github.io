<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python memory management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the main problems when writing large (relatively) Python programs is minimizing memory consumption. However, it is easy to manage memory here -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python memory management</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/d61/005/8cf/d610058cf6094336ba3f4de1d1829f5a.jpg"></p><br><p>  One of the main problems when writing large (relatively) Python programs is minimizing memory consumption.  However, it is easy to manage memory here - if you care at all.  Python memory is allocated transparently, objects are managed using a reference count system, and memory is released when the counter drops to zero.  In theory, everything is fine.  But in practice, you need to know a few things about memory management in Python in order for your programs to use it effectively.  First thing, you need to understand it well: the size of the main objects in Python.  And the second thing: how is the control "under the hood" of the language. </p><br><p>  Let's start with the size of the objects.  In Python, there are many primitive data types: integers (int), long (int version with unlimited precision), floating point numbers (they are doubles, double), tuples (tuple), string values, lists, dictionaries and classes. </p><a name="habracut"></a><br><h2 id="osnovnye-obekty">  Main objects </h2><br><p> What is the size of an <code>int</code> ?  A programmer who writes in C or C ++ is likely to say that the size of a machine-dependent <code>int</code> is about 32 bits, possibly 64;  and therefore, takes no more than 8 bytes.  But is it in Python? </p><br><p>  Let's write a function showing the size of the objects (recursively, if needed): </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys def show_sizeof(x, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>): print "\t" * <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, x.__class__, sys.getsizeof(x), x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasattr(x, <span class="hljs-string"><span class="hljs-string">'__iter__'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasattr(x, <span class="hljs-string"><span class="hljs-string">'items'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> xx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x.items(): show_sizeof(xx, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> xx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: show_sizeof(xx, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Now, using this function, you can explore the sizes of the main data types: </p><br><pre> <code class="hljs lisp">show_sizeof(<span class="hljs-name"><span class="hljs-name">None</span></span>) show_sizeof(<span class="hljs-number"><span class="hljs-number">3</span></span>) show_sizeof(<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">63</span></span>) show_sizeof(<span class="hljs-number"><span class="hljs-number">102947298469128649161972364837164</span></span>) show_sizeof(<span class="hljs-number"><span class="hljs-number">918659326943756134897561304875610348756384756193485761304875613948576297485698417</span></span>)</code> </pre> <br><p>  If you have 32-bit Python 2.7x, then you will see: </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">9223372036854775808</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span> <span class="hljs-number"><span class="hljs-number">102947298469128649161972364837164</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">918659326943756134897561304875610348756384756193485761304875613948576297485698417</span></span></code> </pre> <br><p>  And if 64-bit Python 2.7x, you will see: </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">9223372036854775808</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">102947298469128649161972364837164</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">918659326943756134897561304875610348756384756193485761304875613948576297485698417</span></span></code> </pre> <br><p>  Let's focus on the 64-bit version (mainly because in our case it is more in demand).  <code>None</code> takes 16 bytes.  <code>int</code> is 24 bytes, <em>three times more</em> than <code>int64_t</code> in C, although this is to some extent a machine-friendly integer.  The minimum size of long values ‚Äã‚Äã(with unlimited precision) used to represent numbers greater than 2 <sup>63</sup> - 1 is 36 bytes.  Then they increase linearly, as the logarithm of the number being represented. </p><br><p>  Python floating-point numbers are implementation-dependent, but are similar to double-precision numbers in C. However, they do not occupy only 8 bytes: </p><br><pre> <code class="hljs lisp">show_sizeof(<span class="hljs-number"><span class="hljs-number">3.14159265358979323846264338327950288</span></span>)</code> </pre> <br><p>  On a 32-bit platform it produces: </p><br><pre> <code class="hljs css">16 3<span class="hljs-selector-class"><span class="hljs-selector-class">.14159265359</span></span></code> </pre> <br><p>  And on 64-bit: </p><br><pre> <code class="hljs css">24 3<span class="hljs-selector-class"><span class="hljs-selector-class">.14159265359</span></span></code> </pre> <br><p>  This is again three times more than a C programmer would have thought. What about string values? </p><br><pre> <code class="hljs lisp">show_sizeof(<span class="hljs-string"><span class="hljs-string">""</span></span>) show_sizeof(<span class="hljs-string"><span class="hljs-string">"My hovercraft is full of eels"</span></span>)</code> </pre> <br><p>  On a 32-bit platform: </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> My hovercraft <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> eels</code> </pre> <br><p>  And on 64-bit: </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">37</span></span> <span class="hljs-number"><span class="hljs-number">66</span></span> My hovercraft <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> eels</code> </pre> <br><p>  <em>An empty</em> string value is 37 bytes in a 64-bit environment!  Then the memory consumption increases in accordance with the size of the (useful) value. </p><br><hr><br><p>  Let's take a look at other frequently sought-after structures: tuples, lists, and dictionaries.  Lists (implemented as <a href="http://en.wikipedia.org/wiki/Dynamic_array">lists of arrays</a> , and not as <a href="http://en.wikipedia.org/wiki/Linked_list">linked lists</a> , with <a href="http://en.wikipedia.org/wiki/Dynamic_array">all the consequences</a> ) are arrays of references to Python objects, which allows them to be heterogeneous.  Their sizes: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">show_sizeof</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">show_sizeof</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[4, "toaster", 230.1]</span></span>)  32<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>  : 32 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> 44 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[4, 'toaster', 230.1]</span></span>   64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>: 72 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> 96 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[4, 'toaster', 230.1]</span></span></code> </pre> <br><p>  An empty list is 72 bytes.  The size of the empty <code>std::list()</code> in 64-bit C is only 16 bytes, 4-5 times smaller.  What about tuples?  And dictionaries? </p><br><pre> <code class="hljs lisp">show_sizeof({}) show_sizeof({'a':<span class="hljs-number"><span class="hljs-number">213</span></span>, 'b':<span class="hljs-number"><span class="hljs-number">2131</span></span>})</code> </pre> <br><p>  On a 32-bit platform it produces: </p><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">136</span></span> {} <span class="hljs-number"><span class="hljs-number">136</span></span> {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">213</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2131</span></span>} <span class="hljs-number"><span class="hljs-number">32</span></span> (<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">213</span></span>) <span class="hljs-number"><span class="hljs-number">22</span></span> a <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">213</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> (<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">2131</span></span>) <span class="hljs-number"><span class="hljs-number">22</span></span> b <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">2131</span></span></code> </pre> <br><p>  And on 64-bit: </p><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">280</span></span> {} <span class="hljs-number"><span class="hljs-number">280</span></span> {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">213</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2131</span></span>} <span class="hljs-number"><span class="hljs-number">72</span></span> (<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">213</span></span>) <span class="hljs-number"><span class="hljs-number">38</span></span> a <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">213</span></span> <span class="hljs-number"><span class="hljs-number">72</span></span> (<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">2131</span></span>) <span class="hljs-number"><span class="hljs-number">38</span></span> b <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">2131</span></span></code> </pre> <br><p>  The last example is especially interesting because it ‚Äúdoes not add up‚Äù.  Key / value pairs occupy 72 bytes (their components occupy 38 + 24 = 62 bytes, and another 10 are spent on the pair itself), but the entire dictionary weighs 280 bytes (and not the minimum required 144 = 72 √ó 2 bytes).  A dictionary is considered an effective search data structure, and two likely implementations will consume more memory than the required minimum.  If this is some kind of tree, then you have to pay for internal nodes that contain a key and two pointers to child nodes.  If this is a hash table, then for good performance you need to have a place for free entries. </p><br><p>  The equivalent (relatively) structure of <code>std::map</code> from C ++ at creation takes 48 bytes (it is still empty).  And an empty string value in C ++ requires 8 bytes (then the size grows linearly with the size of the string).  The integer value is 4 bytes (32 bits). </p><br><hr><br><p>  And what gives us all this?  The fact that an empty string value takes 8 or 37 bytes does not make much difference.  Really.  But only until your project starts to grow.  Then you will have to very carefully monitor the number of objects created to limit the amount of memory consumed by the application.  For real applications, this is a problem.  To develop a really good memory management strategy, we need to monitor not only the size of new objects, but also the number and order of their creation.  For Python programs, this is very important.  Let's now deal with the following key point: with the internal organization of memory allocation in Python. </p><br><h2 id="vnutrennee-upravlenie-pamyatyu">  Internal Memory Management </h2><br><p>  To speed memory allocation (and reuse), Python uses a series of lists for small objects.  Each list contains objects of the same size: there can be one list for objects from 1 to 8 bytes, another for objects of 9‚Äì16 bytes, etc. When you need to create a small object, we again use a free block in the list or select a new one. <br>  There are several nuances how Python distributes these lists into blocks, pools and "arenas": several blocks form a pool, pools gather into an arena, etc. But we will not go deep into it (if you wish, you can read about <a href="http://www.evanjones.ca/memoryallocator/">how to improve memory allocation in Python</a> ).  It is important for us to know that these lists are <em>undiminished</em> . </p><br><p>  Indeed, if an element (of size <em>x</em> ) is removed from memory (the link to it is erased), then the volume that occupied it will not be returned to the Python global memory pool (including the system), but will be marked free and added to the list of free elements of size <em>x</em> .  The volume occupied by a dead object can be used again if another object of a suitable size is needed.  And if there is no suitable dead object, then a new one is created. </p><br><p>  If memory with small objects is never released, then we come to the inevitable conclusion that these lists with small objects can only grow, they never decrease, which means that numerous small objects located in it at any given moment in the memory of your application. </p><br><hr><br><p>  Therefore, try to place in memory only the number of small objects that are needed for any one task, preferring the cycles in which a small number of elements are created / processed, rather than patterns, where lists are first created using the generate syntax, and then processed . </p><br><p>  Although the second option is more consistent with the spirit of Python, it is less successful: in the end there will be a large number of small objects that fill the corresponding lists, and even if some list becomes dead, then the objects in it (now all in the list of free objects) will still take up a lot of memory. </p><br><hr><br><p>  Increasing the list of free elements is not a special problem, because this memory is still available for the Python program.  But from the point of view of the OS, the size of your program is equal to the total size of the memory allocated for Python.  And only under Windows, memory is returned to the OS heap (and is used to host other objects besides small ones), and under Linux, the total amount of memory used by your application will only grow. </p><br><hr><br><p>  Let us prove this statement using <a href="http://pypi.python.org/pypi/memory_profiler">memory_profiler</a> , a module for Python (dependent on the <code>python-psutil</code> ) (page on <a href="https://github.com/fabianp/memory_profiler">Github</a> ).  It adds the <code>@profile</code> decorator to track some specific memory usage.  To use it is extremely simple.  Consider the following program: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memory_profiler @profile def <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(): x = list(range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>)) # allocate a big list y = <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>.deepcopy(x) del x <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == "__main__": <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() invoking python -m memory_profiler memory-profile-me.py</code> </pre> <br><p>  On a 64-bit computer, it displays: </p><br><pre> <code class="hljs pgsql">Filename: memory-profile-me.py <span class="hljs-type"><span class="hljs-type">Line</span></span> # Mem <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> Line Contents ================================================ <span class="hljs-number"><span class="hljs-number">4</span></span> @profile <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">9.11</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB def <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(): <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">40.05</span></span> MB <span class="hljs-number"><span class="hljs-number">30.94</span></span> MB x = list(range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>)) # allocate a big list <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">89.73</span></span> MB <span class="hljs-number"><span class="hljs-number">49.68</span></span> MB y = <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>.deepcopy(x) <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">82.10</span></span> MB <span class="hljs-number"><span class="hljs-number">-7.63</span></span> MB del x <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">82.10</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y</code> </pre> <br><p>  The program creates n = 1,000,000 integers (n √ó 24 bytes = ~ 23 MB) and an additional list of links (n √ó 8 bytes = ~ 7.6 MB), and in total we get ~ 31 MB.  <code>copy.deepcopy</code> copies both lists, and copies take ~ 50 MB (I don‚Äôt know where the extra 50 - 31 = 19 MB come from).  Curiously, <code>del x</code> removes <code>x</code> , but memory consumption is reduced by only 7.63 MB!  The reason is that <code>del</code> only removes the list of links, but real integer values ‚Äã‚Äãremain on the heap and lead to excessive consumption of ~ 23 MB. </p><br><p>  In this example, the amount of busy is ~ 73 MB, which is more than twice the amount needed to store a list weighing ~ 31 MB.  As you can see, with the loss of vigilance, sometimes there are very unpleasant surprises in terms of memory consumption! </p><br><p>  You can get different results on other platforms and other versions of Python. </p><br><h2 id="pickle">  Pickle </h2><br><p>  By the way, what about <code>pickle</code> ? </p><br><p>  <a href="http://docs.python.org/library/pickle.html">Pickle</a> is the standard way to (de) serialize Python objects to a file.  What is its memory consumption?  Does it make extra copies of the data or is it smarter?  Consider a short example: </p><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memory_profiler <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join([chr(<span class="hljs-number"><span class="hljs-number">64</span></span> + random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">20</span></span>)]) @profile <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> x = [(random.random(), random_string(), random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">64</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000000</span></span>)] pickle.dump(x, open(<span class="hljs-string"><span class="hljs-string">'machin.pkl'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>)) @profile <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> y = pickle.load(open(<span class="hljs-string"><span class="hljs-string">'machin.pkl'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__==<span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: create_file() <span class="hljs-comment"><span class="hljs-comment">#load_file()</span></span></code> </pre> <br><p>  On the first call, we profile the creation of the pickled data, and on the second call, we re-read them (you can comment out the function so that it is not called).  When using <code>memory_profiler</code> lot of memory is consumed during data creation: </p><br><pre> <code class="hljs pgsql">Filename: test-pickle.py <span class="hljs-type"><span class="hljs-type">Line</span></span> # Mem <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> Line Contents ================================================ <span class="hljs-number"><span class="hljs-number">8</span></span> @profile <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">9.18</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB def create_file(): <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">9.33</span></span> MB <span class="hljs-number"><span class="hljs-number">0.15</span></span> MB x=[ (random.random(), <span class="hljs-number"><span class="hljs-number">11</span></span> random_string(), <span class="hljs-number"><span class="hljs-number">12</span></span> random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">64</span></span>)) <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">246.11</span></span> MB <span class="hljs-number"><span class="hljs-number">236.77</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000000</span></span>) ] <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">481.64</span></span> MB <span class="hljs-number"><span class="hljs-number">235.54</span></span> MB pickle.dump(x,<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'machin.pkl'</span></span>,<span class="hljs-string"><span class="hljs-string">'w'</span></span>))</code> </pre> <br><p>  And when reading - a little less: </p><br><pre> <code class="hljs pgsql">Filename: test-pickle.py <span class="hljs-type"><span class="hljs-type">Line</span></span> # Mem <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> Line Contents ================================================ <span class="hljs-number"><span class="hljs-number">18</span></span> @profile <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-number"><span class="hljs-number">9.18</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB def load_file(): <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">311.02</span></span> MB <span class="hljs-number"><span class="hljs-number">301.83</span></span> MB y=pickle.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'machin.pkl'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>)) <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">311.02</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y</code> </pre> <br><p>  So <code>pickl</code> very bad for memory consumption.  The initial list takes about 230 MB, and during serialization it consumes about the same amount. </p><br><p>  On the other hand, deserialization looks more efficient.  More memory is consumed than the original list (300 MB instead of 230), but this is at least not twice as much. </p><br><p>  In general, it is better to avoid (de) serialization in memory-sensitive applications.  What are the alternatives?  Serialization preserves the entire data structure, so that later you can completely restore it from the resulting file.  But it is not always necessary.  If the file contains a list, as in the previous example, then it may be advisable to use a simple, text format.  Let's see what it gives. </p><br><p>  The simplest (na√Øve) implementation: </p><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memory_profiler <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join([chr(<span class="hljs-number"><span class="hljs-number">64</span></span> + random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">20</span></span>)]) @profile <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> x = [(random.random(), random_string(), random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">64</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000000</span></span>) ] f = open(<span class="hljs-string"><span class="hljs-string">'machin.flat'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> xx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> &gt;&gt;f, xx f.close() @profile <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> y = [] f = open(<span class="hljs-string"><span class="hljs-string">'machin.flat'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f: y.append(eval(line)) f.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__== <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: create_file() <span class="hljs-comment"><span class="hljs-comment">#load_file()</span></span></code> </pre> <br><p>  Create a file: </p><br><pre> <code class="hljs pgsql">Filename: test-flat.py <span class="hljs-type"><span class="hljs-type">Line</span></span> # Mem <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> Line Contents ================================================ <span class="hljs-number"><span class="hljs-number">8</span></span> @profile <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">9.19</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB def create_file(): <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">9.34</span></span> MB <span class="hljs-number"><span class="hljs-number">0.15</span></span> MB x=[ (random.random(), <span class="hljs-number"><span class="hljs-number">11</span></span> random_string(), <span class="hljs-number"><span class="hljs-number">12</span></span> random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">64</span></span>)) <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">246.09</span></span> MB <span class="hljs-number"><span class="hljs-number">236.75</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1000000</span></span>) ] <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">246.09</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB f=<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'machin.flat'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">308.27</span></span> MB <span class="hljs-number"><span class="hljs-number">62.18</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> xx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: <span class="hljs-number"><span class="hljs-number">17</span></span> print &gt;&gt;f, xx</code> </pre> <br><p>  Read the file: </p><br><pre> <code class="hljs pgsql">Filename: test-flat.py <span class="hljs-type"><span class="hljs-type">Line</span></span> # Mem <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> Line Contents ================================================ <span class="hljs-number"><span class="hljs-number">20</span></span> @profile <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">9.19</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB def load_file(): <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">9.34</span></span> MB <span class="hljs-number"><span class="hljs-number">0.15</span></span> MB y=[] <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">9.34</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB f=<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'machin.flat'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">300.99</span></span> MB <span class="hljs-number"><span class="hljs-number">291.66</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f: <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">300.99</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB y.append(eval(<span class="hljs-type"><span class="hljs-type">line</span></span>)) <span class="hljs-number"><span class="hljs-number">26</span></span> <span class="hljs-number"><span class="hljs-number">301.00</span></span> MB <span class="hljs-number"><span class="hljs-number">0.00</span></span> MB <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y</code> </pre> <br><p>  When recording consumes much less memory.  Many temporary small objects are still being created (about 60 MB), but this cannot be compared with double consumption.  Reading is comparable in cost (slightly less memory is used). </p><br><p>  This example is trivial, but it summarizes strategies in which you do not first load the entire data with subsequent processing, but read several items, process them, and reuse the allocated memory.  Loading data into the Numpy array, for example, you can first create an Numpy array, then read the file line by line, gradually filling the array.  This will allow only one copy of all data to be stored in memory.  And when using <code>pickle</code> data will be placed in memory (at least) twice: once <code>pickle</code> , the second time when working with Numpy. </p><br><p>  Or better yet, use Numpy (or PyTables) arrays.  But that's another story.  At the same time, in the Theano / doc / tutorial directory you can read another <a href="http://deeplearning.net/software/theano/tutorial/loading_and_saving.html">loading and saving</a> guide. </p><br><hr><br><p>  The goals of the Python architecture do not coincide in any way, say, with the objectives of the C architecture. The latter is designed to give you good control over what you are doing at the expense of more complex and explicit programming.  And the first one is designed so that you can write code faster, but at the same time the language hides most of the implementation details (if not all).  Although this sounds nice, but ignoring the inefficient implementations of the language in the production-environment sometimes leads to unpleasant consequences, sometimes unrecoverable.  I hope that knowing these Python features when working with memory (architectural features!) Will help you write code that will better meet the requirements of production, scale well, or, on the contrary, will be a burning memory hell. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336156/">https://habr.com/ru/post/336156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336140/index.html">Auto-optimization of virtual reality or what is the difference between reproducing, timewarp and spacewarp</a></li>
<li><a href="../336142/index.html">Unscientific revolution: how not to go broke on fake innovations</a></li>
<li><a href="../336144/index.html">We measure the dynamics of mentioning entities in the information field</a></li>
<li><a href="../336152/index.html">Parallels Desktop for Mac 13: Ready for macOS High Sierra</a></li>
<li><a href="../336154/index.html">Log storage for a cloud platform. ELK implementation experience</a></li>
<li><a href="../336158/index.html">How to remove ads from Android apps</a></li>
<li><a href="../336160/index.html">Some functional programming techniques in Python</a></li>
<li><a href="../336162/index.html">Nginx in the work of DevOps / Administrator. Dark side of power</a></li>
<li><a href="../336164/index.html">Pentestit Corporate Laboratories: Practical Information Security Skills</a></li>
<li><a href="../336166/index.html">Learn OpenGL. Part 2.3. - Materials</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>