<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET API in web development: past and future</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people think that creating an API is a specific process, and it should be understood only by those who are professionally engaged in the developm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET API in web development: past and future</h1><div class="post__text post__text-html js-mediator-article"> Many people think that creating an API is a specific process, and it should be understood only by those who are professionally engaged in the development of API projects.  But in reality, we all write APIs one way or another: for new classes, services, for colleagues or customers. <br><br>  Under the cut, we tried to find some practical tips for you on how to create a web API design, plan changes, manage versioning and interact with API users.  We tried to find out what difficulties may arise and what typical mistakes are usually made.  And also read about various interesting facts from history and about expected changes in the future. <br><br>  Our current companion, Dylan Beattie, has a high reputation at <a href="http://stackoverflow.com/users/5017/dylan-beattie">StackOverflow</a> , which means that he is well, interesting and, correctly, answer the questions correctly.  Great experience allows him to tell something from the past through his own examples, and the profession of the architect keeps in shape and brings new knowledge about trends and advanced technologies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/ad1/99f/29c/ad199f29c59f44b4bf39909c16ae935d.jpg"><br><a name="habracut"></a><br>  <b>- What API are you developing?</b>  <b>At what exact moment did the API design suddenly go into software development?</b> <br><br>  <b>Dylan Beatty:</b> This is a very interesting question, because I think that one of the biggest misconceptions in software development is that the API design is something that happens separately from everything else.  Of course, there are certain types of API projects, such as HTTP APIs, which will be opened publicly - and here it makes sense to consider design as a separate part of the work.  But the truth is that most developers, in fact, create APIs all the time - they simply do not realize that they are doing this.  Every time you write the public method in one of your classes or choose a name for a database table, you create an interface ‚Äî in the usual daily English meaning of the word ‚Äî that will eventually be used by other developers at a certain point in time in the future. .  Other people on your team will use your classes and methods.  Other commands will use your data scheme or message format. <br><br>  What is interesting is that if developers understand that the code they are working on is likely to become part of the API, then they are too much in the same direction.  They begin to implement edge cases and any other things that they don‚Äôt really need, just because they may be needed afterwards.  I think that here you need to feel the edge, and it seems to me that the key to understanding this edge is that you need to be extremely specific in creating the set of functions that you need right now.  But it is important to make this set as far as possible reusable and self-describing.  Pieter Hintjens has a good essay called <a href="http://hintjens.com/blog:94">Ten Rules for Good API Design</a> , which gives a more detailed idea of ‚Äã‚Äãideas of this type. <br><br>  The biggest API project I'm working on at the moment is the one I'm doing at the English company Spotlight.  This is a hypermedia API that reveals various information about professional actors.  Job offers in acting projects, in movies and on television and various other data used in the casting industry.  We build this API on an architectural style known as REST - and if you are not quite aware of what REST is, then you simply must come to <a href="https://dotnext-piter.ru/talks/real-world-rest-and-hands-on-hypermedia/">my address</a> at the DotNext conference in St. Petersburg and find out about it. <br><br>  There are various patterns for creating the HTTP API - there is REST, there is GraphQL, there are such things as SOAP and RPC.  But for me, the biggest attraction of REST is that the limitations of a RESTful style lead to a natural weakening of the connections in the concepts and operations that your API needs to support, which makes it easier to make changes and develop the design for a long time. <br><br>  <b>- One of the most famous programs, "killed" by backward compatibility, is IE.</b>  <b>This browser had too many applications for which it was necessary to maintain compatibility with previous versions.</b>  <b>The problem was solved by simply adding a new application called Edge, which is updated and supports all new standards.</b>  <b>How not to fall into the trap of backward compatibility?</b>  <b>Maybe you should use modularity, which in turn does not use layers?</b>  <b>Or maybe replacing the API with a RESTful API, Service Oriented Architecture or something else?</b> <br><br>  <b>Dylan Beatty:</b> I started building web applications a long time ago.  He wrote his first page a couple of years before the advent of Internet Explorer.  Then, when the only browsers were NCSA Mosaic and Erwise.  It is fascinating to look back into the history of the web and realize that the web that exists now has been modeled and influenced by things like Internet Explorer.  And you are absolutely right;  One of the reasons why Microsoft introduced the all-new Edge browser in recent versions of Windows is that Internet Explorer's commitment to backward compatibility has made the work of implementing new web standards on the existing IE code base very difficult. <br><br>  Part of the reason why this backward compatibility exists in IE is that around 2000 there has been a slight shift in the way that corporate IT systems are developed. <br><br>  There are countless companies that have their own applications for various types of business operations: equity control, product accounting, HR, project management and others.  In the 1980s and early 1990s, most of them used a central mainframe system, and employees used something like a terminal emulator to connect to a central server.  But after the first wave of dotcoms in the late 1990s, companies realized that most of their computers now have a web browser and a network connection, and can replace the old terminal applications of the mainframe with new web applications. <br><br>  Windows at that time had a huge market share, and Internet Explorer was the default browser on most Windows PCs, so many organizations built intranets that only worked with a certain version of Internet Explorer.  Sometimes they did this in order to take advantage of specific features, such as ActiveX support;  but more often, I think they did it, just to save money by not having to do cross-browser testing.  It happened with some fairly large commercial applications;  even in 2011, Microsoft Dynamics CRM still did not support any other browsers except Internet Explorer. <br><br>  In this way, we also have a large number of companies that have invested time and money in creating applications that work with Internet Explorer.  These applications were not created using web standards or progressive improvements, or with any attempt to create compatibility with subsequent versions ‚Äî they were explicitly designed for one particular browser version running on an operating system.  And every time Microsoft released the new version of Internet Explorer, these applications ‚Äúcrashed‚Äù - and companies did not want to invest in updating their outdated intranet applications and blamed the browser.  But the story is not over: now in 2017, Microsoft still supplies IE11, which has a compatibility mode, where it switches to the IE9 engine, but sends the user agent string that it is IE7.  Now everyone I know is using Google Chrome or Safari to surf the net, but at the same time, many people still have an IE label on their desktop that allows you to access one of the legacy systems. <br><br>  So ... going back to the question of how Microsoft could have avoided this trap.  I think there were many opportunities.  As an option, initially create IE using a modular rendering engine, so that subsequent versions can selectively launch the corresponding engine to draw a specific website or application.  They could put more effort into supporting web standards that existed at the time, instead of implementing ad hoc support for things like MARQUEE tag and ActiveX plugins - this would help to avoid a headache later on by supporting these esoteric features in new versions.  But then it all meant nothing.  When developing the first versions of Internet Explorer, it was important not to create a great application with first-class support for web standards, but to kill Netscape Navigator and win in the market section.  And it worked. <br><br>  <b>- Suppose someone is going to submit a new API.</b>  <b>He collects some requirements, offers a version and gets feedback.</b>  <b>The process looks simple and simple.</b>  <b>But are there any pitfalls on the way?</b> <br><br>  <b>Dylan Beatty:</b> Always!  Requirements will be changed - it is a fact.  One of the biggest mistakes you can make is to try to anticipate these changes and make your future-proof design.  Theoretically, this may pay off, but more often you end up with an even more complex design on your hands, because you were trying to put some future changes into it.  Often, pitfalls are something that is beyond your control.  For example, the law will change, and you will need to provide data differently.  Or there will be changes in other systems of your organization.  Or one of your cloud hosting providers will declare that they have transferred some function you need to obsolete. <br><br>  It is best to choose from the possible options for the interface something simple and usable, do it and hand it over.  To get to the stage as quickly as possible when your API is stable, there is no external technical debt, and the team can move on to the next task.  So if you suddenly encounter any unforeseen problem after that, then you will have a stable code base ready for use in your solution, and a team that will have time and desire to work in order to solve everything.  And if by some coincidence you don‚Äôt fall into any pitfall, you can simply move to the next item in your backlog. <br><br>  <b>- Here we have released version v1.0 of our API and on the way to v1.1.</b>  <b>Probably many of us will create both <a href="http://example.com/v1/test">http://example.com/v1/test</a> , and <a href="http://example.com/v1.1/test">http://example.com/v1.1/test</a> or something like that.</b>  <b>What practices, in your opinion, can help a developer to make a v1.1 API design better than v1.0?</b> <br><br>  <b>Dylan Beatty:</b> It would be nice to read about the concepts of semantic versioning (SemVer) and take the time to really understand the differences between the major, minor and patch versions.  SemVer says that you should not have any critical changes between versions 0.x and 0.1, so the most important part is to understand what will be the critical change for your particular API. <br><br>  If you are working with HTTP APIs that return JSON, for example, then a typical non-critical change will be to add a new data field to one of your resources.  It is expected that customers who use version 1.1 will see an additional field and be able to take full advantage of this, while customers who still use version 1.0 will not be able to take into account an unrecognized property.  This is another pretty close question about how you should manage the versioning of your APIs.  One of the most popular solutions is to submit a URL through routing - api.example.com/v1/ instead of api.example.com/v1.1 <br><br>  But if you comply with the limitations of RESTful systems, then you need to understand whether a change in a version will represent a change in the underlying resource or presentation.  Remember that a URI is a Uniform Resource Identifier, and we really should not change the URI that we use to direct to the same resource. <br><br>  For example, we have a resource api.example.com/images/monalisa.  We can request this resource as JPEG (Accept: image / jpeg) or as PNG (Accept: image / png), or ask the server if it has a plain-text representation of this resource (Accept: application / json) - but that‚Äôs all only different representations of the same underlying resource, and they should all have the same URI. <br><br>  Or, say, you completely replaced the CRM system used in your organization, in which case the ‚Äúversion 1‚Äù client represents the record that is used in the old CRM system, and the ‚Äúversion 2‚Äù represents the same client, but after migrating to completely new platform.  In this case, it probably makes sense to treat them as different resources and give them different URIs. <br><br>  Versioning is a tricky thing.  The easiest way is never to change anything. <br><br>  <b>- .NET Core - what do you think of its API?</b> <br>  <b>Dylan Beatty:</b> .NET Core was first announced in 2015 and was originally called .NET Core 5.0.  It was expected that this would be a simplified alternative to the .NET Framework and the Common Language Runtime.  It was a terrific idea - to create all the conditions to facilitate porting. NET Core to other platforms.  The truth is that there is still a considerable difference between the API open in .NET Core and the ‚Äústandard‚Äù .NET / CLR API on which most applications are built. <br><br>  I think ‚Äî and this is only my interpretation, based on what I read, and on conversations with various people ‚Äî the idea is that .NET Core will provide the fundamental blocks and things like threading, access to the file system, network access, and platform vendors, along with the open source community, will begin to develop modules and packages that ultimately reach the level of functionality provided by solutions like the Java Class Library or the .NET Framework.  In principle, this is a great idea, but it also creates something like a vicious circle: no one wants to create libraries for a platform without users, and no one wants to use a platform without libraries. <br><br>  So it was decided that cross-platform .NET requires a standard API specification that will provide the libraries expected by users and developers on various supported platforms.  This is .NET Standard 2.0, which is already fully supported by the .NET Framework 4.6.1 and will be fully supported in future versions of .NET Core and Xamarin.  Of course, .NET Core 1.1 is already out and running well, and you can use it now to create C # web applications, even if you are using Windows or Linux or macOS, which is very cool.  But I think that the next release of .NET Core will make many creators of frameworks and packages willing to migrate projects to .NET Core, which in turn will make it easier for developers and organizations to migrate their own applications. <br><br>  <b>- API flexibility vs API accuracy.</b>  <b>You can create an API method design with the ability to get many different types of values.</b>  <b>But you can create a method with some rules in the parameters.</b>  <b>Both ways are true.</b>  <b>Where is the boundary between these two possibilities?</b>  <b>When should we make a strict API, and when should we create a flexible API design?</b> <br><br>  <b>Dylan Beatty:</b> When implementing an API in which method signatures are flexible, all you do is send complexity somewhere else in your stack.  Let's say we create an API for finding ski passes, and we have a choice between the DoSearch (SearchCriteria criteria) and the DoSearch (string resortName, string countryCode, int minAltitude, int maxDistanceToSkiList). <br>  The first of these methods is fairly easy to expand.  We can expand the definition of a SearchCriteria object without changing the method signature.  But in this case we do not just change the specific method - we also change the behavior of the system. <br><br>  In contrast, we can add new arguments to the signature of our second DoSearch method.  If we work with a language like C #, then we can provide arguments with default values.  And we will not break anything in the project, adding new arguments to the method, if at the same time we set reasonable default values ‚Äã‚Äãwith these very arguments. <br><br>  At some point, you will need to communicate with users of the API and let them know which search options are supported by your API.  And here there are several ways to do it.  If you create a .NET API that installs as a NuGet package and is used from code, using XML comments on your methods and parameters is a great way to tell your users what they need to specify when they make requests to your API.  If your API is an HTTP service, then pay attention to such hypermedia formats as <a href="https://github.com/kevinswiber/siren">SIREN</a> , with which you can designate which parameters and ranges are supported. <br><br>  I think in the next decade we will see a completely different API category driven by machine learning systems, where many commonly accepted API design rules will not apply.  It won't surprise me at all if we suddenly get the ski voucher search API, where you just need to specify what you need in a normal language.  And there won't even be a method signature - you just call something like DoSearch ("ski chalet, in France or Italy, 1400m or higher, that sleeps 12 people in 8 bedrooms, available from 18-25 January 2018") - and lying Basically, the system will do everything for you.  These ways of developing using machine learning are an exciting thing.  But their creators want to make some more interesting changes for developers and designers in order to attract additional attention. <br><br>  <i>This year, Dylan Beattie will visit Russia again and speak at the DotNext conference in St. Petersburg in May, so you have a chance not only to listen to <a href="https://dotnext-piter.ru/talks/real-world-rest-and-hands-on-hypermedia/">his new report</a> , but also to ask him your questions or say hello to the London .NET User Group.</i> </div><p>Source: <a href="https://habr.com/ru/post/328090/">https://habr.com/ru/post/328090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328080/index.html">‚ÄúRunn Me!‚Äù - tells us another PHP framework *. And heard "Throw Me!". Part 2</a></li>
<li><a href="../328082/index.html">Stress test teams: how to make a GPU benchmark and do not overheat</a></li>
<li><a href="../328084/index.html">On the issue of restrictions</a></li>
<li><a href="../328086/index.html">Distributed data structures [part 1, overview]</a></li>
<li><a href="../328088/index.html">Using the KOMPAS-3D API ‚Üí Lesson 1 ‚Üí Basics</a></li>
<li><a href="../328092/index.html">CI & CD Fengshun Automation with Jenkins and Jira</a></li>
<li><a href="../328094/index.html">Learn and love Xdebug</a></li>
<li><a href="../328096/index.html">Why is your email list ineffective?</a></li>
<li><a href="../328098/index.html">Headquarters Touch Instinct. Tour of the St. Petersburg office</a></li>
<li><a href="../328100/index.html">Security Week 18: A hole in all systems with Intel Core, Apple took away a certificate from a Trojan, ran the wizard flooded the planet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>