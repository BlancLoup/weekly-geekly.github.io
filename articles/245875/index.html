<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Advanced PowerShell vol. 1: code reuse</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! As a big fan and active practitioner of PowerShell, I often encounter the fact that I need to reuse previously written pieces of code. 
 Actual...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Advanced PowerShell vol. 1: code reuse</h1><div class="post__text post__text-html js-mediator-article">  Hello!  As a big fan and active practitioner of <b>PowerShell,</b> I often encounter the fact that I need to reuse previously written pieces of code. <br>  Actually, for modern programming languages, code reuse is a common thing. <br>  <b>PowerShell</b> is not lagging behind in this issue, and offers developers (script writers) several mechanisms for accessing previously written code. <br>  Here they are in order of increasing complexity: use of functions, dot-sourcing and writing your own modules. <br><br>  Consider them all in order. <br><br>  As a solution to a laboratory task, we will write a script that expands the <b>C: \</b> partition to the maximum possible size on the remote Windows server <b>LAB-FS1</b> . <br>  Such a script will consist of one line and look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs 1c">Invoke-Command -ComputerName LAB-FS1 -ScriptBlock { <span class="hljs-string"><span class="hljs-string">"rescan"</span></span>, <span class="hljs-string"><span class="hljs-string">"select volume=c"</span></span>, <span class="hljs-string"><span class="hljs-string">"extend"</span></span> <span class="hljs-string"><span class="hljs-string">| diskpart }</span></span></code> </pre> <br>  It works like this.  First, <b>PowerShell</b> establishes a remote connection with the <b>LAB-FS1</b> server and runs locally on it a set of commands enclosed in braces of the <i>-ScriptBlock</i> parameter.  This set in turn sequentially passes three text parameters to the <b>diskpart</b> command, and <b>diskpart</b> performs (in turn) rescan partitions, select the <b>C: \</b> partition and expand it to the maximum possible size. <br><br><img src="https://habrastorage.org/files/cf3/3b1/fb2/cf33b1fb23d6465ba8791764862f3dc7.png"><br><br>  As you can see, the script is extremely simple, but at the same time extremely useful. <br>  Consider how to properly pack it for reuse. <br><a name="habracut"></a><br><h1>  1. Using functions </h1><br>  The easiest option. <br><br>  Suppose we are writing a large script in which, for various reasons, we need to run partition expansion on different servers many times.  It is most logical to select the entire script as a separate function in the same .ps1 file and then simply call it as necessary.  In addition, we will extend the functionality of the script, allowing the administrator to explicitly specify the name of the remote server and the letter of the expanding section.  The name and the letter will be passed using the parameters. <br>  The function and its call will look like this: <br><br><pre> <code class="hljs mel">function ExtendDisk-Remotely { param ( [Parameter (Mandatory = $true)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] $ComputerName, [Parameter (Mandatory = $false)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] $DiskDrive = <span class="hljs-string"><span class="hljs-string">"c"</span></span> ) Invoke-Command -ComputerName $ComputerName -ScriptBlock {<span class="hljs-string"><span class="hljs-string">"rescan"</span></span>, <span class="hljs-string"><span class="hljs-string">"select volume=$using:DiskDrive"</span></span>, <span class="hljs-string"><span class="hljs-string">"extend"</span></span> | diskpart} } ExtendDisk-Remotely -ComputerName LAB-FS1</code> </pre><br>  Here, two parameters are set for the <i>ExtendDisk-Remotely</i> function: <br><br><ul><li>  Required <i>ComputerName</i> ; </li><li>  Optional <i>DiskDrive</i> .  There is no explicitly specifying the drive name; the script will work with the <b>C: \</b> drive <b>.</b> </li></ul><br>  It can also be noted that passing a local variable to a remote session is done using the using keyword. <br><br>  Save the script as <i>Example-01-Functions.ps1</i> and run: <br><br><img src="https://habrastorage.org/files/8ef/fbb/415/8effbb415f3648788edff6eba17188a9.png"><br><br>  We see that our function was successfully invoked and expanded the section <b>C: \</b> on the server <b>LAB-FS1</b> . <br><br><h1>  2. Dot-sourcing </h1><br>  Complicate the situation.  Our function to expand the sections was so good that we want to use it in other scripts.  How to be? <br><br>  Copy the text of the function from the source .ps1 file and paste it into all the necessary ones?  And if the function code is updated regularly?  And if this function is needed hundreds of scripts?  Obviously, you need to put it in a separate file and connect as needed. <br><br>  Create a separate file for all our functions and name it <i>Example-02-DotSourcing.ps1</i> . <br>  Its contents will be as follows: <br><br><pre> <code class="hljs mel">function ExtendDisk-Remotely { param ( [Parameter (Mandatory = $true)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] $ComputerName, [Parameter (Mandatory = $false)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] $DiskDrive = <span class="hljs-string"><span class="hljs-string">"c"</span></span> ) Invoke-Command -ComputerName $ComputerName -ScriptBlock {<span class="hljs-string"><span class="hljs-string">"rescan"</span></span>, <span class="hljs-string"><span class="hljs-string">"select volume=$using:DiskDrive"</span></span>, <span class="hljs-string"><span class="hljs-string">"extend"</span></span> | diskpart} }</code> </pre><br>  This function declaration (without a call), which is now stored in a separate file and can be called at any time using a technique called dot-sourcing.  The syntax is: <br><br><pre> <code class="hljs tex">. C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Scripts</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Example</span></span></span></span>-02-DotSourcing.ps1 ExtendDisk-Remotely LAB-FS1</code> </pre><br>  Carefully look at the first line of code and analyze its contents: <b>full stop</b> , <b>space</b> , <b>file path with the description of the function</b> . <br><br>  This syntax allows us to connect the contents of the <i>Example-02-DotSourcing.ps1</i> file to the current script.  This is the same as using the <b>#include</b> directive in <b>C ++</b> or the <b>using</b> command in <b>C #</b> - connecting pieces of code from external sources. <br>  After connecting an external file, we can call the functions included in it in the second line, which we successfully do.  At the same time, the external file can be accessed not only in the body of the script, but also in the ‚Äúbare‚Äù PowerShell console: <br><br><img src="https://habrastorage.org/files/4eb/89a/b27/4eb89ab278af45e8b67a20bdc77c7982.png"><br><br>  The technology of dossourcing can be used, and it will work for you, but it is much more convenient to use a more modern method, which we will consider in the next section. <br><br><h1>  3. Writing Your Own PowerShell Module </h1><br><blockquote>  <b>Warning:</b> I am using <b>PowerShell</b> version 4. <br>  One of its features is that it automatically loads modules into RAM as they are accessed without using the <i>Import-Module</i> cmdlet. <br><br>  In older versions of <b>PowerShell</b> (starting from 2), written below will work, but may require additional manipulations associated with the preliminary import of modules before using them. <br>  We will consider modern environments. </blockquote><br>  Complicate the situation again. <br><br>  We have become very good <b>PowerShell</b> programmers, have written hundreds of useful functions, divided them into dozens of .ps1 files for usability, and we will distribute the necessary files to the necessary scripts.  And if we have dozens of files for dossorsing and they must be specified in a hundred scripts?  And if we renamed several of them?  Obviously, you have to change the path to all files in all scripts - this is terribly inconvenient. <br><br>  Therefore. <br><br>  Regardless of how many functions you have written for reuse, even if one, immediately draw it into a separate module.  Writing your own modules is the easiest, best, modern, and competent method to reuse code in <b>PowerShell</b> . <br><br><h2>  What is the Windows PowerShell module? </h2><br>  The <b>Windows PowerShell</b> module is a set of functionality that is located in one form or another in separate files of the operating system.  For example, all native Microsoft modules are binary and are compiled .dll.  We will write a scripting module - we will copy the code from the <i>Example-02-DotSourcing.ps1</i> file into it and save it as a file with the .psm1 extension. <br><br>  To understand where to save, look at the contents of the <b>PSModulePath</b> environment <b>variable</b> . <br><br><img src="https://habrastorage.org/files/599/071/704/5990717045274c59971a98bc5e7807fc.png"><br><br>  We see that by default we have three folders in which <b>PowerShell</b> will look for modules. <br>  The value of the <b>PSModulePath</b> variable can be edited using group policies, thus specifying the paths to modules for the entire network, but this is another story, and we will not consider it now.  But we will work with the folder <i>C: \ Users \ Administrator \ Documents \ WindowsPowerShell \ Modules</i> and save our module to it. <br>  The code remains unchanged: <br><br><pre> <code class="hljs mel">function ExtendDisk-Remotely { param ( [Parameter (Mandatory = $true)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] $ComputerName, [Parameter (Mandatory = $false)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>] $DiskDrive = <span class="hljs-string"><span class="hljs-string">"c"</span></span> ) Invoke-Command -ComputerName $ComputerName -ScriptBlock {<span class="hljs-string"><span class="hljs-string">"rescan"</span></span>, <span class="hljs-string"><span class="hljs-string">"select volume=$using:DiskDrive"</span></span>, <span class="hljs-string"><span class="hljs-string">"extend"</span></span> | diskpart} }</code> </pre><br>  Only the folder in which the file is saved, and its extension is changed. <br><blockquote>  <b>Very important!</b> <br>  Inside the <i>Modules</i> folder you need to create a subfolder with the name of our module.  Let that name be <i>RemoteDiskManagement</i> .  We save our file inside this subfolder and give it the <b>exact same</b> name and extension .psm1 - we get the file <i>C: \ Users \ Administrator \ Documents \ WindowsPowerShell \ Modules \ <b>RemoteDiskManagement \ RemoteDiskManagement.psm1</b></i> . <br></blockquote><br>  Our module is ready, and we can check that it is visible in the system: <br><br><img src="https://habrastorage.org/files/c7f/bf3/4a6/c7fbf34a6d9d498b9895cef4acfa36ec.png"><br><br>  The module is visible, and in the future we can call its functions without first declaring them in the body of the script or dossorsing. <br>  <b>PowerShell</b> will perceive our <i>ExtendDisk-Remotely function</i> as ‚Äúbuilt-in‚Äù and connect it as needed: <br><br><img src="https://habrastorage.org/files/595/13e/f79/59513ef79570424f82892a80bcc99f4a.png"><br><br>  That's all: we can write dozens of our own modules, edit the code of the functions included in them and use them at any time, without thinking about in which script you need to change the name of the function or the path to the dossor file. <br><br><h1>  4. Other advanced capabilities </h1><br>  As I already wrote, I love <b>PowerShell</b> , and if the community is interested, I can write a dozen more articles about its advanced functionality.  Here are examples of topics for discussion: adding help to written functions and modules;  how to make your function take values ‚Äã‚Äãfrom the pipeline and what features it imposes on script writing;  what a conveyor is and what it is eaten with;  how to use <b>PowerShell</b> to work with databases;  how advanced functions are arranged and what properties their parameters can have, etc. <br><br>  Interesting? <br>  Then I will try to issue one article per week. </div><p>Source: <a href="https://habr.com/ru/post/245875/">https://habr.com/ru/post/245875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245861/index.html">We simulate the prestress of the concrete shell of the nuclear power plant</a></li>
<li><a href="../245863/index.html">New office Synesis: how we created the space for the birth of ideas</a></li>
<li><a href="../245867/index.html">Textolite 1.04: you can create templates and edit scripts</a></li>
<li><a href="../245869/index.html">The course from Yandex about what every developer who wants to make large systems should know. Buzz word DevOps and more</a></li>
<li><a href="../245871/index.html">How to live if you have a laptop, and the screens are not enough</a></li>
<li><a href="../245879/index.html">iOS / Cloudatlas - new malware for iOS</a></li>
<li><a href="../245883/index.html">Does Big Brother keep a close eye on you?</a></li>
<li><a href="../245885/index.html">How to show the most dangerous vulnerabilities</a></li>
<li><a href="../245887/index.html">Garland on Raspberry Pi</a></li>
<li><a href="../245889/index.html">Simple lock-free objects for two threads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>