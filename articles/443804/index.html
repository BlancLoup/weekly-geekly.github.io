<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C # is a low level language?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am a big fan of everything that Fabien Sanglard does, I like his blog, and I read both of his books from cover to cover (they were told about in a r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C # is a low level language?</h1><div class="post__text post__text-html js-mediator-article">  I am a big fan of everything that <a href="http://fabiensanglard.net/">Fabien Sanglard</a> does, I like his blog, and I read <a href="http://fabiensanglard.net/gebbdoom/index.html">both of</a> his <a href="http://fabiensanglard.net/gebbwolf3d/index.html">books</a> from cover to cover (they were told about in a recent <a href="https://hanselminutes.com/666/episode-666-game-engine-black-book-doom-with-fabien-sanglard">podcast by Hansleminutes</a> ). <br><br>  Recently, Fabien wrote a great post, where he <a href="http://fabiensanglard.net/postcard_pathtracer/index.html">deciphered a tiny raytracer</a> , deobfusing the code and explaining mathematics in a fantastically beautiful way.  I really recommend taking the time to read this! <br><br>  But it made me think, is <i><b>it possible to transfer this C ++ code to C #</b></i> ?  Since I have been writing quite a lot in C ++ in my <a href="https://raygun.com/platform/apm">main job</a> lately, I thought that I could try. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But more importantly, I wanted to get a better idea of <b>whether C # is a low-level language</b> ? <br><a name="habracut"></a><br>  A slightly different, but related question: how suitable is C # for ‚Äúsystem programming‚Äù?  On this topic, I really recommend <a href="http://joeduffyblog.com/2013/12/27/csharp-for-systems-programming/">Joe Duffy's excellent post from 2013</a> . <br><br><h1>  Line by line </h1><br>  I started with a simple transfer of <a href="http://fabiensanglard.net/postcard_pathtracer/formatted_full.html">deobfuscated C ++ code</a> line by line in C #.  It was quite simple: it seems that the truth is that C # is C ++++ !!! <br><br>  The example shows the basic data structure - 'vector', here‚Äôs a comparison, C ++ on the left, C # on the right: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  So, there are a few syntactic differences, but since .NET allows you to define <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types">your own value types</a> , I was able to get the same functionality.  This is important because processing 'vector' as structures means that we can get better ‚Äúdata locality‚Äù, and there is no need to involve the .NET garbage collector, since the data will go to the stack (yes, I know this is an implementation detail). <br><br>  For more information about <code>structs</code> or ‚Äúvalue types‚Äù in .NET, see here: <br><br><ul><li>  <a href="http://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/">Heap vs. Stack, Value Type vs. Reference Type</a> </li><li>  <a href="https://adamsitnik.com/Value-Types-vs-Reference-Types/">Value Types vs. Reference Types</a> </li><li>  <a href="http://jonskeet.uk/csharp/memory.html">Memory in .NET: what's where</a> </li><li>  <a href="https://blogs.msdn.microsoft.com/ericlippert/2010/09/30/the-truth-about-value-types/">The truth about value types</a> </li><li>  <a href="https://blogs.msdn.microsoft.com/ericlippert/2009/04/27/the-stack-is-an-implementation-detail-part-one/">The stack is an implementation detail, part one</a> </li></ul><br>  In particular, in the last post of Eric Lippert we find such a useful quotation, which makes it clear what the ‚Äútypes of values‚Äù really are: <br><br><blockquote>  Of course, the most important fact about the types of values ‚Äã‚Äãis <b>not the implementation details, <i>as they stand out</i></b> , but rather the <i>original semantic meaning of the</i> ‚Äú <i>value</i> type‚Äù, <b>but that it is <i>always copied ‚Äúby value‚Äù</i></b> .  If the allocation information were important, we would call them "heap types" and "stack types."  But in most cases it does not matter.  Most of the time, the semantics of copying and identification is relevant. </blockquote><br>  Now let's see how some other methods look like in comparison (again C ++ on the left, C # on the right), first <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Then <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (see <a href="http://fabiensanglard.net/postcard_pathtracer/">Fabian‚Äôs post</a> for an explanation of what these two functions do) <br><br>  But again, the fact is that C # makes it very easy to write C ++ code!  In this case, the <code>ref</code> keyword helps us the most. It allows you to pass a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref">value by reference</a> .  We have been using <code>ref</code> for quite some time in method calls, but recently efforts have been made to allow <code>ref</code> in other places: <br><br><ul><li>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns">Ref return and ref local</a> </li><li>  <a href="https://blogs.msdn.microsoft.com/mazhou/2018/03/02/c-7-series-part-9-ref-structs/">C # 7 Series, Part 9: ref struct</a> </li></ul><br>  Now <i>sometimes</i> using <code>ref</code> will improve performance, because then the structure does not need to be copied, see benchmarks in the <a href="https://adamsitnik.com/ref-returns-and-ref-locals/">post of Adam Stinix</a> and <a href="https://blogs.msdn.microsoft.com/seteplia/2018/04/11/performance-traps-of-ref-locals-and-ref-returns-in-c/">‚ÄúPerformance traps ref locals and ref returns to C #‚Äù</a> for more information. <br><br>  But the most important thing is that such a script provides our C # port with the same behavior as the C ++ source code.  Although I want to note that the so-called "managed links" are not quite the same as "pointers", in particular, you cannot do arithmetic on them, for more details, see here: <br><br><ul><li>  <a href="http://mustoverride.com/refs-not-ptrs/">ref return is not a pointer</a> </li><li>  <a href="http://mustoverride.com/managed-refs-CLR/">Managed Pointers</a> </li><li>  <a href="https://blogs.msdn.microsoft.com/ericlippert/2009/02/17/references-are-not-addresses/">Links are not addresses</a> </li></ul><br><h2>  Performance </h2><br>  Thus, the code is well ported, but performance also matters.  Especially in the raytracer, which can cheat a frame a few minutes.  The C ++ code contains the <code>sampleCount</code> variable, which controls the final image quality, while <code>sampleCount = 2</code> looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Clearly not very realistic! <br><br>  But when you get to <code>sampleCount = 2048</code> , everything looks <i>much</i> better: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  But running with <code>sampleCount = 2048</code> takes <b>a</b> lot of time, so all the other runs are performed with a value of <code>2</code> in order to keep at least a minute.  Changing <code>sampleCount</code> affects only the number of iterations of the outermost loop of the code, see <a href="https://gist.github.com/mattwarren/1580572d9d641147c61caf65c383c3a4">this gist</a> for an explanation. <br><br><h3>  Results after the ‚Äúnaive‚Äù progressive port </h3><br>  To meaningfully compare C ++ and C #, I used the <a href="https://code.google.com/archive/p/time-windows/source/default/source">time-windows</a> tool, this is the port of the unix command <code>time</code> .  Initial results looked like this: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Time (sec) </td><td>  47.40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td>  In the core (s) </td><td>  0.14 (0.3%) </td><td>  0.72 (0.9%) </td><td>  0.63 (0.8%) </td></tr><tr><td>  In user space (sec) </td><td>  43.86 (92.5%) </td><td>  73.06 (91.2%) </td><td>  70.66 (90.6%) </td></tr><tr><td>  Number of page fault errors </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Work Set (KB) </td><td>  4232 </td><td>  13,624 </td><td>  17,052 </td></tr><tr><td>  Memory preemptive (KB) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Non-preemptive memory </td><td>  7 </td><td>  14 </td><td>  sixteen </td></tr><tr><td>  Page File (KB) </td><td>  1460 </td><td>  10,936 </td><td>  11,024 </td></tr></tbody></table><br>  Initially, we see that the C # code is a bit slower than the C ++ version, but it gets better (see below). <br><br>  But let's first see what the .NET JIT is doing to us, even with this ‚Äúnaive‚Äù line-by-line port.  First, it does a good job of embedding smaller ‚Äúhelper methods‚Äù.  This is evident in the output of the magnificent tool <a href="https://marketplace.visualstudio.com/items%3FitemName%3DStephanZehetner.InliningAnalyzer">Inlining Analyzer</a> (green = embedded): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  However, it does not embed all methods, for example, because of the complexity, <code>QueryDatabase(..)</code> skipped: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Another function of the .NET Just-In-Time (JIT) compiler is to convert certain method calls to the corresponding CPU instructions.  We can see this in action with the <code>sqrt</code> shell function, here is the C # source code (notice the <code>Math.Sqrt</code> call): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  And here is the assembler code that generates the .NET JIT: there is no call to <code>Math.Sqrt</code> and the <code>Math.Sqrt</code> processor instruction is <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">used</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (To get this issue, follow <a href="">these instructions</a> , use <a href="https://github.com/EgorBo/Disasmo">the Disasmo VS2019 add-in</a> or look at <a href="https://sharplab.io/">SharpLab.io</a> ) <br><br>  These replacements are also known as <a href="https://en.wikipedia.org/wiki/Intrinsic_function">intrinsics</a> , and in the code below we can see how JIT generates them.  This snippet shows mapping for <code>AMD64</code> only, but JIT also targets <code>X86</code> , <code>ARM</code> and <code>ARM64</code> , the full method <a href="">here</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  As you can see, some methods are implemented as, for example, <code>Sqrt</code> and <code>Abs</code> , while for others, functions of the C ++ runtime are used, for example, <a href="https://en.cppreference.com/w/c/numeric/math/pow">powf</a> . <br><br>  This whole process is very well explained in the article <a href="https://stackoverflow.com/a/8870593">‚ÄúHow is Math.Pow () implemented in the .NET Framework?‚Äù</a> , It can also be seen in the CoreCLR source code: <br><br><ul><li>  The implementation of <code><a href="">COMSingle::Pow</a></code> , that is, the method that is executed if you call <code>MathF.Pow(..)</code> from C # code <br></li><li>  Mapping in <a href="">runtime method implementation C</a> <br></li><li>  Cross-platform version of the <a href="">implementation of powf</a> , which provides the same behavior in different operating systems </li></ul><br><h3>  Results after simple performance improvements. </h3><br>  I wonder whether it is possible to improve on the go naive line-by-line port.  After some profiling, I made two major changes: <br><br><ul><li>  Remove initialization of embedded array </li><li>  Replacing <code>Math.XXX(..)</code> functions with analogs of <code>MathF.()</code> </li></ul><br>  These changes are explained in more detail below. <br><br><h4>  Remove initialization of embedded array </h4><br>  For more information on why this is necessary, see <a href="https://stackoverflow.com/a/39106675">this excellent answer to Stack Overflow</a> from <a href="https://twitter.com/andrey_akinshin">Andrei Akinshin</a> , along with benchmarks and assembler code.  He comes to the following conclusion: <br><br><blockquote>  <b>Conclusion</b> <br><br><ul><li>  <i><b>Is .NET caching hard-coded local arrays?</b></i>  Like those that put the Roslyn compiler in the metadata. </li><li>  <i><b>In this case there will be overhead costs?</b></i>  Unfortunately, yes: for each JIT call, it will copy the contents of the array from the metadata, which takes extra time compared to a static array.  The runtime also allocates objects and creates traffic in memory. </li><li>  <i><b>Should I worry about it?</b></i>  Maybe.  If this is a hot method and you want to achieve a good level of performance, you need to use a static array.  If this is a cold method that does not affect the performance of the application, you probably need to write ‚Äúgood‚Äù source code and place the array in the method area. </li></ul></blockquote><br>  Changes can be seen in <a href="https://gist.github.com/mattwarren/d17a0c356bd6fdb9f596bee6b9a5e63c/revisions">this diff</a> . <br><br><h4>  Using MathF Functions Instead of Math </h4><br>  Secondly, and most importantly, I have significantly improved performance by making the following changes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  Beginning with .NET Standard 2.1, there are specific implementations of <code>float</code> common math functions.  They are located in the <a href="https://apisof.net/catalog/System.MathF">System.MathF</a> class.  For more information about this API and its implementation, see here: <br><br><ul><li>  <a href="https://github.com/dotnet/corefx/issues/1151">New API for mathematics with single precision</a> <br></li><li>  <a href="https://github.com/dotnet/coreclr/pull/5492/files">Adding math functions with single precision</a> <br></li><li>  <a href="https://github.com/dotnet/coreclr/issues/7690">Providing a suite of unit tests for new single-precision math APIs</a> <br></li><li>  <a href="https://github.com/dotnet/coreclr/issues/14155">System.Math and System.MathF should be implemented in managed code, not FCALL for C runtime.</a> <br></li><li>  <a href="https://github.com/dotnet/coreclr/pull/14156">Move Math.Abs ‚Äã‚Äã(double) and Math.Abs ‚Äã‚Äã(float) for implementation in managed code</a> <br></li><li>  <a href="https://github.com/dotnet/designs/issues/13">Design and process for adding platform-specific embedded tools in .NET</a> </li></ul><br>  After these changes, the difference in performance of C # and C ++ code was reduced to about 10%: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Time (sec) </td><td>  41.38 </td><td>  58,89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  In the core (s) </td><td>  0.05 (0.1%) </td><td>  0.06 (0.1%) </td><td>  0.14 (0.3%) </td><td>  0.13 (0.3%) </td></tr><tr><td>  In user space (sec) </td><td>  41.19 (99.5%) </td><td>  58.34 (99.1%) </td><td>  44.72 (97.1%) </td><td>  44.03 (99.3%) </td></tr><tr><td>  Number of page fault errors </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Work Set (KB) </td><td>  4136 </td><td>  13,440 </td><td>  16 788 </td><td>  16 652 </td></tr><tr><td>  Memory preemptive (KB) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Non-preemptive memory </td><td>  7 </td><td>  13 </td><td>  sixteen </td><td>  sixteen </td></tr><tr><td>  Page File (KB) </td><td>  1428 </td><td>  10 904 </td><td>  10,960 </td><td>  11,044 </td></tr></tbody></table><br>  TC - layered compilation, <a href="https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/">Tiered Compilation</a> ( <i>I suppose</i> it will be enabled by default in .NET Core 3.0) <br><br>  For completeness, here are the results of several runs: <br><br><table><thead><tr><th>  Run </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41.38 </td><td>  58,89 </td><td>  46.04 </td><td>  44.33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57.65 </td><td>  46.23 </td><td>  45.96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62.64 </td><td>  46.22 </td><td>  48.73 </td></tr></tbody></table><br>  <b>Note</b> : the difference between the .NET Core and the .NET Framework is due to the absence of the MathF API in the .NET Framework 4.7.2, for more information, see the <a href="https://github.com/dotnet/standard/issues/859">.Net Framework Support Ticket (4.8?) For netstandard 2.1</a> . <br><br><h1>  Further increase in productivity </h1><br>  I am sure that the code can still be improved! <br><br>  If you are interested in eliminating the performance difference, <a href="https://gist.github.com/mattwarren/d17a0c356bd6fdb9f596bee6b9a5e63c">here is the C # code</a> .  For comparison, you can watch the C ++ assembler code from the excellent <a href="https://godbolt.org/z/l2QZLY">Compiler Explorer</a> service. <br><br>  Finally, if it helps, here‚Äôs the output of the Visual Studio profiler with the ‚Äúhot path‚Äù display (after the performance improvements described above): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  Is C # a low level language? </h1><br>  Or more specifically: <br><br><blockquote>  <b><b>What language features of C # / F # / VB.NET or BCL / Runtime functionality mean ‚Äúlow level‚Äù * programming?</b></b> </blockquote><br>  * Yes, I understand that ‚Äúlow level‚Äù is a subjective term. <br><br>  <b>Note:</b> each C # developer has his own idea of ‚Äã‚Äãwhat ‚Äúlow level‚Äù is, these functions will be taken for granted by C ++ or Rust programmers. <br><br>  Here is the list I made: <br><br><ul><li>  <a href="https://adamsitnik.com/ref-returns-and-ref-locals/">ref returns and ref locals</a> <br><ul><li>  ‚ÄúTransfer and return by reference to avoid copying large structures.  Safe types and memory can be even <b>faster</b> than insecure ones! ‚Äù </li></ul><br></li><li>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code">Unsafe code in .NET</a> <br><ul><li>  ‚ÄúThe main language of C #, as defined in previous chapters, is very different from C and C ++ in that it lacks pointers as a data type.  Instead, C # provides links and the ability to create objects that are regulated by the garbage collector.  This design in combination with other functions makes C # a much more secure language than C or C ++. ‚Äù </li></ul><br></li><li>  <a href="http://tooslowexception.com/managed-pointers-in-net/">Managed Pointers in .NET</a> <br><ul><li>  ‚ÄúThere is another type of pointer in the CLR ‚Äî a managed pointer.  It can be defined as a more general type of link, which may indicate other locations, and not just the beginning of the object. ‚Äù </li></ul><br></li><li>  <a href="https://blogs.msdn.microsoft.com/mazhou/2018/03/25/c-7-series-part-10-spant-and-universal-memory-management/">C # 7 Series, Part 10: Span &lt;T&gt; and Universal Memory Management</a> <br><ul><li>  ‚ÄúSystem.Span &lt;T&gt; is only a stack type ( <code>ref struct</code> ) that wraps all memory access patterns; it is a type for universal continuous memory access.  You can imagine a Span implementation with a dummy reference and a length that accepts all three types of memory access. ‚Äù </li></ul><br></li><li>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interop/">Compatibility ("C # Programming Guide")</a> <br><ul><li>  "The .NET Framework provides interoperability with unmanaged code through platform call services, the <code>System.Runtime.InteropServices</code> , C ++ compatibility, and COM compatibility (COM interoperability)." </li></ul></li></ul><br>  I also threw a cry on Twitter and got a lot more options for inclusion in the list: <br><br><ul><li>  <a href="https://twitter.com/ben_a_adams/status/1097876408775442432">Ben Adams</a> : ‚ÄúEmbedded Platform Tools (CPU Instructions)‚Äù <br></li><li>  <a href="https://twitter.com/marcgravell/status/1097877192745336837">Mark Graywell</a> : ‚ÄúSIMD via Vector (which goes well with Span) is * pretty * low;  .NET Core should (soon?) Offer direct embedded CPUs for more explicit use of specific CPU instructions. ‚Äù <br></li><li>  <a href="https://twitter.com/marcgravell/status/1097878317875761153">Mark Graywell</a> : ‚ÄúPowerful JIT: things like range skipping (range elision) on arrays / intervals, and using per-struct-T rules to remove large pieces of code that the JIT knows for certain that they are not available for this T or on your particular CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated, etc.) ¬ª <br></li><li>  <a href="https://twitter.com/vcsjones/status/1097877294864056320">Kevin Jones</a> : ‚ÄúI would especially mention the <code>MemoryMarshal</code> and <code>Unsafe</code> classes, and maybe a few other things in the <code>System.Runtime.CompilerServices</code> ‚Äù <br></li><li>  <a href="https://twitter.com/Pessimizations/status/1097877381296066560">Theodoros Chatsigiannakis</a> : "You can also include <code>__makeref</code> and the rest" <br></li><li>  <a href="https://twitter.com/damageboy/status/1097877247120326658">damageboy</a> : ‚ÄúThe ability to dynamically generate a code that exactly matches the expected input, given that the latter will be known only at run time and can change periodically?‚Äù <br></li><li>  <a href="https://twitter.com/RobertHaken/status/1097880613988851712">Robert Hacken</a> : ‚ÄúDynamic IL Emission‚Äù <br></li><li>  <a href="https://twitter.com/buybackoff/status/1097885830364966914">Victor Baibekov</a> : ‚ÄúStackalloc was not mentioned.  It is also possible to write pure IL (not dynamic, therefore it is saved on a function call), for example, use cached <code>ldftn</code> and call them via <code>calli</code> .  VS2017 has a proj template that makes it trivial by rewriting the extern + MethodImplOptions.ForwardRef + ilasm.exe methods. <br></li><li>  <a href="https://twitter.com/buybackoff/status/1097887318806093824">Viktor Baibekov</a> : ‚ÄúMethodImplOptions.AggressiveInlining also‚Äú activates low-level programming ‚Äùin the sense that it allows you to write high-level code with many small methods and still control the behavior of JIT to get an optimized result.  Otherwise, copy-paste hundreds of LOC-methods ... " <br></li><li>  <a href="https://twitter.com/ben_a_adams/status/1097885533508980738">Ben Adams</a> : ‚ÄúUsing the same calling conventions (ABI) as the base platform, and p / invokes to interact?‚Äù <br></li><li>  <a href="https://twitter.com/buybackoff/status/1097893756672581632">Viktor Baibekov</a> : ‚ÄúAlso, since you mentioned #fsharp - it has the keyword <code>inline</code> , which performs work at the IL level to JIT, therefore, it was considered important at the language level.  C # lacks this (still) for lambdas, which are always virtual calls, and workarounds are often strange (limited generics). ‚Äù <br></li><li>  <a href="https://twitter.com/xoofx/status/1097895771142320128">Alexandre Mutel</a> : ‚ÄúNew built-in SIMD, post-processing Unsafe Utility class / IL (for example, custom, Fody, etc.).  For C # 8.0, upcoming function pointers ... " <br></li><li>  <a href="https://twitter.com/xoofx/status/1097896059236466689">Alexandre Mutel</a> : ‚ÄúWith regard to IL, F # directly supports IL in a language, for example‚Äù <br></li><li>  <a href="https://twitter.com/0omari0/status/1097916897952235520">OmariO</a> : ‚Äú <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.binary.binaryprimitives%3Fview%3Dnetcore-3.0">BinaryPrimitives</a> .  Low level but safe <br></li><li>  <a href="https://twitter.com/kozy_kekyo/status/1097982126190878720">Kozy (Kozy) Matsui</a> : ‚ÄúWhat about your own inline assembler?  This is difficult for both the toolkit and the runtime, but it can replace the current p / invoke solution and implement embedded code, if one is available. ‚Äù <br></li><li>  <a href="https://twitter.com/praeclarum/status/1098002275891642368">Frank A. Kruger</a> : ‚ÄúLdobj, stobj, initobj, initblk, cpyblk‚Äù <br></li><li>  <a href="https://twitter.com/konradkokosa/status/1098155819340828672">Konrad Kokosa</a> : ‚ÄúMaybe streaming local storage?  Fixed size buffers?  You should probably mention uncontrollable constraints and blittable types :) ‚Äù <br></li><li>  <a href="https://twitter.com/sebify/status/1098161110476312582">Sebastiano Mandala</a> : ‚ÄúJust a small addition to everything said: how about something simple, such as layout of structures and how filling and aligning memory and the order of fields can affect cache performance?  This is something that I myself must explore. ‚Äù <br></li><li>  <a href="https://twitter.com/NinoFloris/status/1098433286899146753">Nino Floris</a> : ‚ÄúConstants embedded via readonlyspan, stackalloc, finalizers, WeakReference, open delegates, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef, can set the structure types in exact match to the layout (used for TaskAwaiter and its version)‚Äù </li></ul><br>  <b>So in the end, I would say that C # certainly allows you to write code that looks like C ++ and, in combination with the runtime and base class libraries, provides many low-level functions.</b> <br><br><h1>  Further reading </h1><br><ul><li>  <a href="https://www.youtube.com/watch%3Fv%3D7GTpwgsmHgU">Templates for high performance C #.</a>  <a href="https://www.youtube.com/watch%3Fv%3D7GTpwgsmHgU">Federico Andres Lois</a> <br></li><li>  <a href="https://blogs.msdn.microsoft.com/ricom/2005/05/10/performance-quiz-6-chineseenglish-dictionary-reader/">Performance Quiz # 6 - Chinese-English Dictionary</a> (since 2005, two Microsoft bloggers are leading the battle of C ++ performance against C #) <br></li><li>  <a href="https://blogs.msdn.microsoft.com/ricom/2005/05/20/performance-quiz-6-conclusion-studying-the-space/">Performance Quiz # 6 - Conclusion, Exploring Space</a> <br></li><li>  <a href="https://stackoverflow.com/a/138406">How much C ++ is faster than C #?</a> <br></li><li>  <a href="https://blogs.msdn.microsoft.com/jonathanh/2005/05/20/optimizing-managed-c-vs-native-c-code/">Optimized Managed C # and Native C ++ Code</a> (2005) </li></ul><br>  Unity Burst Compiler: <br><br><ul><li>  <a href="https://blogs.unity3d.com/2019/02/26/on-dots-c-c/">How Unity made (subset) C # as fast as C ++</a> <br></li><li>  <a href="http://infalliblecode.com/unity-burst-compiler/">Unity Burst Compiler: Simple Performance Optimization</a> <br></li><li>  <a href="http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/">Daily Pathtracer, part 3: C # and Unity Burst</a> <br></li><li>  <a href="https://lucasmeijer.com/posts/cpp_unity/">C ++, C # and Unity</a> <br></li><li>  <a href="https://www.youtube.com/watch%3Fv%3DQkM6zEGFhDY">Deep Immersion in the Burst Compiler - Unite LA</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/443804/">https://habr.com/ru/post/443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443782/index.html">Developers can now use Valve's Network API for their games on Steam</a></li>
<li><a href="../443790/index.html">Survivor error</a></li>
<li><a href="../443792/index.html">Common mistakes when working with PostgreSQL. Part 2</a></li>
<li><a href="../443794/index.html">The main directions for IT startups in real estate sales</a></li>
<li><a href="../443800/index.html">Smart speakers with "Alice" on a low start</a></li>
<li><a href="../443806/index.html">All Boeing 737 MAX flights are discontinued until aircraft software updates.</a></li>
<li><a href="../443808/index.html">Analytics of girls with low social responsibility (Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../443810/index.html">How much do developers of different qualifications earn</a></li>
<li><a href="../443814/index.html">The prison is my "former business"</a></li>
<li><a href="../443816/index.html">Ministry of Communications insists on a single operator 5G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>