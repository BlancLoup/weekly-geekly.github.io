<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deep into the core: familiarity with LTTng</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the previous publications, we have already touched upon the issue of tracing and profiling the Linux kernel. 

 Today we would like to retur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deep into the core: familiarity with LTTng</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/52c/27c/608/52c27c6084d082d38e03bf059620135d.png" alt="LTTng" width="100%" height="100%"><br><br>  In <a href="https://habrahabr.ru/company/selectel/blog/280322//">one of the previous publications,</a> we have already touched upon the issue of tracing and profiling the Linux kernel. <br><br>  Today we would like to return to this issue again and talk in detail about one interesting tool - the <a href="http://lttng.org/" rel="nofollow">LTTng</a> kernel <a href="http://lttng.org/" rel="nofollow">tracer</a> , developed by Canadian programmer and researcher Mathieu Denoyer.  With it, you can receive information about events both in kernel space and in user space. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      LTTng can be used, for example, to solve the following tasks (the list is far from complete): <br><br><ul><li>  analysis of interprocess communication in the system; </li><li>  analysis of the interaction of applications in user space with the kernel; </li><li>  measuring the time spent by the kernel on servicing application requests; </li><li>  analysis of the features of the system under high loads. </li></ul><br><br>  LTTng has long been included in the official repositories of modern Linux distributions.  It is used in practice by companies such as Google, Siemens, Boeing and others.  There are practically no publications about it in Russian. <br>  In this article we will look at how LTTng works and show how kernel tracing is done with it. <br><br><h2>  A bit of history </h2><br><br>  In the <a href="https://habrahabr.ru/company/selectel/blog/280322/">last article,</a> we detailed the mechanism of trace points (tracepoints) and even gave examples of code.  But we did not say that the mechanism of tracepoints was created in the process of working on LTTng. <br><br>  Back in 1999, IBM employee Karim Yaghmour began work on the <a href="https://en.wikipedia.org/wiki/Linux_Trace_Toolkit" rel="nofollow">LTT</a> project <a href="https://en.wikipedia.org/wiki/Linux_Trace_Toolkit" rel="nofollow">(Linux Trace Toolkit)</a> .  LTT was based on the following idea: to statically instrument the most important fragments in the kernel code and thereby obtain information about the system‚Äôs operation.  A few years later, this idea was picked up and developed by Mathieu Denoye as part of the LTTng project (Linux Tracing Tool New Generation).  The first LTTng release took place in 2005. <br><br>  The words New Generation are used in the name of the tool for a reason: Denoye made a great contribution to the development of Linux trace and profiling mechanisms.  He added static instrumentation for the most important nuclear functions: this is how the <a href="https://lwn.net/Articles/245671/" rel="nofollow">kernel markers</a> mechanism came about, the improvement of which resulted in the well-known tracepoints.  Tracepoints are actively used in LTTng.  It is thanks to this mechanism that it became possible to perform tracing without creating additional load on the system‚Äôs work. <br>  Based on the material of the work done, Denoyer prepared a <a href="https://lttng.org/files/thesis/desnoyers-dissertation-2009-12-v27.pdf" rel="nofollow">dissertation</a> , which was defended in 2009. <br><br>  Mathieu Denuaye is constantly working to improve LTTng.  The latest stable version 2.7 was released in October 2015.  Version 2.8 is about to be released, which is currently in the status of a release candidate and is available for download <a href="http://lttng.org/download/" rel="nofollow">here</a> . <br><br><h2>  Installation </h2> <br><br>  LTTng is included in the repositories of most modern Linux distributions, and you can install it in a standard way.  In the new versions of popular distributions (for example, in the recently released Ubuntu 16.04), the latest version, 2.7, is available for installation by default: <br><br> <code>$ sudo apt-get install lttng-tools lttng-modules-dkms <br></code> <br><br>  If you are using an older version of Linux, to install LTTng 2.7 you will need to add a PPA repository: <br><br><pre> <code class="bash hljs">$ sudo apt-add-repository ppa:lttng/ppa $ sudo apt-get update $ sudo apt-get install lttng-tools lttng-modules-dkms</code> </pre><br><br>  The lttng-tools package contains the following utilities: <br><br><ul><li>  babeltrace - utility for viewing trace findings in <a href="https://www.efficios.com/ctf" rel="nofollow">CTF (Common Trace Format)</a> ; </li><li>  lttng-sessiond - daemon to control tracing; </li><li>  lttng-consumerd - a daemon that collects data and writes it to the ring buffer; </li><li>  lttng-relayd is a daemon that transmits data over the network. </li></ul><br><br>  The lttng-modules-dkms package includes numerous kernel modules that allow you to interact with the built-in tracing and profiling mechanisms ... You can view a complete list with the command <br><br><pre> <code class="bash hljs">$ lsmod | grep lttng</code> </pre><br><br>  All these modules can be divided into three groups: <br><br><ul><li>  modules for working with trace points (tracepoints); </li><li>  modules for working with the ring buffer; </li><li>  probe modules for dynamic kernel tracing. </li></ul><br><br>  LTTng-UST is also available from the official repositories for installation, which is used to trace events in user space.  In this article we will not consider it.  Interested readers refer to the <a href="https://suchakra.files.wordpress.com/2014/08/osfy_lttng_april_2014.pdf" rel="nofollow">article</a> , which can serve as a quite good introduction to the topic. <br>  All LTTng commands should be executed either on behalf of the root user, or on behalf of the user included in the special tracing group (it is created automatically during installation). <br><br><h2>  Basic Concepts: Sessions, Events, and Channels </h2><br><br>  The process of interaction of all LTTng components can be represented as the following diagram: <br><br><img src="https://blog.selectel.ru/wp-content/uploads/2016/05/scheme01.png" alt="LTTng" width="550" height="550"><br><br>  To better understand how it all works, let us make a small theoretical excursion and analyze the content of the basic concepts. <br><br>  As mentioned above, tracing in LTTng is based on both static and dynamic code instrumentation. <br><br>  During the execution of the instrumented code, a special test function is called (English probe, which can also be translated as ‚Äúsensor‚Äù or ‚Äúprobe‚Äù), which reads the <i>session</i> status and records event information in the <i>channels</i> . <br><br>  Let us clarify the content of the concepts ‚Äúsession‚Äù and ‚Äúchannel‚Äù.  Session is a tracing procedure with user-defined parameters.  The figure above shows only one session, but in LTTng you can start several sessions at the same time. You can stop a session at any time, change its settings and then start it again. <br><br>  Each session uses channels to transfer debug information.  A channel is a set of events with specific characteristics and additional contextual information.  The number of characteristics (in more detail we will tell about them below) of the channel include: buffer size, trace mode, buffer cleaning period. <br><br>  Why do we need channels?  First of all, in order to maintain a common ring buffer in which events are recorded during tracing and from where they are then collected by a consumer daemon.  The ring buffer in turn is divided into numerous sections (sub-buffers) of the same size.  Event data is recorded in the section until it is filled.  After this, the data recording will continue, but in another section.  Data from the overflowed sections is locked by the daemon receiver and stored on disk (or transmitted over the network). <br><br>  Ideally, there shouldn't be any situations when the section is filled and there is no data to write to.  In actual practice, however, such cases sometimes occur.  The <a href="http://lttng.org/docs/" rel="nofollow">official documentation</a> explicitly states that in LTTng performance is paramount: it is better to lose some of the events than to slow down the system.  When creating a channel, you can choose one of two modes of operation for buffer overflows: <br><br><ul><li>  discard mode - all new events will not be recorded until one of the sections is released; </li><li>  overwrite mode - the oldest events will be deleted, and new ones will be recorded in their place. </li></ul><br><br>  More information about setting up channels can be found <a href="http://lttng.org/docs/">here</a> . <br><br><h2>  Event tracing </h2><br><br>  Let's start studying LTTng in practice and launch the first trace session. <br>  You can view the list of events available for tracing as follows (here is a small fragment, in fact this list is much longer): <br><br><pre> <code class="bash hljs">$ lttng list --kernel Kernel events: ------------- writeback_nothread (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) writeback_queue (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) writeback_exec (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) writeback_start (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) writeback_written (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) writeback_wait (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) writeback_pages_written (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) ‚Ä¶‚Ä¶. snd_soc_jack_irq (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) snd_soc_jack_report (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) snd_soc_jack_notify (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint) snd_soc_cache_sync (loglevel: TRACE_EMERG (0)) (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: tracepoint)</code> </pre><br><br>  Let's try to track some event - for example, sched_switch.  First, create a session: <br><br><pre> <code class="bash hljs">$ lttng create test_session Session test_session created. Traces will be written <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /user/lttng-traces/test_session-20151119-134747</code> </pre><br><br>  So, the session is created.  All data collected during this session will be recorded in the file / user / lttng-traces / test_session-20151119-134747.  Then we activate the event that interests us: <br><br><pre> <code class="bash hljs">$ lttng <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-event -k sched_switch Kernel event sched_switch created <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel channel0</code> </pre><br><br>  Next, run: <br><br><pre> <code class="bash hljs">$ lttng start Tracing started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> session test_session $ sleep 1 $ lttng stop</code> </pre><br><br>  Information about all sched_switch events will be saved in a separate file.  You can view the data of its contents as follows: <br><br><pre> <code class="bash hljs">$ lttng view</code> </pre><br><br>  The list of events will be too large.  Moreover, it will include too much information.  Let's try to specify the request and get information only about events that occurred during the execution of the sleep command: <br><br><pre> <code class="bash hljs">$ babeltrace /user/lttng-traces/test_session-20151119-134747 | grep sleep [13:53:23.278672041] (+0.001249216) luna sched_switch: { cpu_id = 0 }, { prev_comm = <span class="hljs-string"><span class="hljs-string">"sleep"</span></span>, prev_tid = 10935, prev_prio = 20, prev_state = 1, next_comm = <span class="hljs-string"><span class="hljs-string">"swapper/0"</span></span>, next_tid = 0, next_prio = 20 } [13:53:24.278777924] (+0.005448925) luna sched_switch: { cpu_id = 0 }, { prev_comm = <span class="hljs-string"><span class="hljs-string">"swapper/0"</span></span>, prev_tid = 0, prev_prio = 20, prev_state = 0, next_comm = <span class="hljs-string"><span class="hljs-string">"sleep"</span></span>, next_tid = 10935, next_prio = 20 } [13:53:24.278912164] (+0.000134240) luna sched_switch: { cpu_id = 0 }, { prev_comm = <span class="hljs-string"><span class="hljs-string">"sleep"</span></span>, prev_tid = 10935, prev_prio = 20, prev_state = 0, next_comm = <span class="hljs-string"><span class="hljs-string">"rcuos/0"</span></span>, next_tid = 8, next_prio = 20 }</code> </pre><br><br>  The output contains information about all sched_switch events registered in the system core during the session.  It consists of several fields.  The first field is the time stamp, the second is the so-called delta (the amount of time between the previous and the current event).  The cpu_id field indicates the CPU number for which the event was registered.  This is followed by additional contextual information. <br><br>  Upon completion of the trace, the session needs to be deleted: <br><br><pre> <code class="bash hljs">$ lttng destroy</code> </pre><br><br><h2>  System call tracing </h2><br><br>  To track system calls, the lttng enable-event command has a special option - syscall.  In the article on ftrace, we analyzed the example of tracing the chroot system call.  Let's do the same thing with LTTng: <br><br><pre> <code class="bash hljs">$ lttng create $ lttng <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-event -k --syscall chroot $ lttng start</code> </pre><br><br>  Create an isolated environment using the chroot command, and then run: <br><br><pre> <code class="bash hljs">$ lttng stop $ lttng view [12:05:51.993970181] (+?.?????????) andrei syscall_entry_chroot: { cpu_id = 0 }, { filename = <span class="hljs-string"><span class="hljs-string">"test"</span></span> } [12:05:51.993974601] (+0.000004420) andrei syscall_exit_chroot: { cpu_id = 0 }, { ret = 0 } [12:06:53.373062654] (+61.379088053) andrei syscall_entry_chroot: { cpu_id = 0 }, { filename = <span class="hljs-string"><span class="hljs-string">"test"</span></span> } [12:06:53.373066648] (+0.000003994) andrei syscall_exit_chroot: { cpu_id = 0 }, { ret = 0 } [12:07:36.701313906] (+43.328247258) andrei syscall_entry_chroot: { cpu_id = 1 }, { filename = <span class="hljs-string"><span class="hljs-string">"test"</span></span> } [12:07:36.701325202] (+0.000011296) andrei syscall_exit_chroot: { cpu_id = 1 }, { ret = 0 }</code> </pre><br><br>  As you can see, the output contains information on all inputs to the syscall system call and exits from it.  Compared to ftrace, it looks somewhat more structured and human-readable. <br><br><h2>  Dynamic tracing </h2><br><br>  Above, we looked at examples of static tracing using the tracepoints mechanism. <br><br>  To track events in Linux, you can also use the kprobes dynamic tracing mechanism (short for kernel probes, as it is not hard to guess).  It allows you to add new trace points (samples) to the core on the fly.  It is on kprobes that the famous SystemTap tool is based.  It works like this: to add a sample to the core, you need to write a script in a special C-like language;  then this script is translated into C code, which is compiled into a separate kernel module.  To use such a tool in practice is very difficult. <br><br>  Starting with kernel version 3.10, kprobes support has <a href="https://www.kernel.org/doc/Documentation/trace/kprobetrace.txt" rel="nofollow">been added to ftrace</a> .  Due to this, dynamic tracing became possible without writing scripts and adding new modules. <br><br>  Implemented kprobes support in LTTng.  Two types of samples are supported: the actual kprobes (‚Äúbasic‚Äù samples that can be inserted anywhere in the kernel) and kretprobes (placed before exiting the function and giving access to its result).  Consider some practical examples. <br><br>  In LTTng, to install the ‚Äúbase‚Äù samples, an option is used which is called - probe: <br><br><pre> <code class="bash hljs">$ lttng create $ lttng <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-event --kernel sys_open --probe sys_open+0x0 $ lttng <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-event --kernel sys_close --probe sys_close+0x0 $ lttng start $ sleep 1 $ lttng stop</code> </pre><br><br>  The output obtained as a result of the trace will look like this (here‚Äôs a small fragment): <br><br><pre> <code class="bash hljs">‚Ä¶.. [12:45:26.842026294] (+0.000028311) andrei sys_close: { cpu_id = 1 }, { ip = 0xFFFFFFFF81209830 } [12:45:26.842036177] (+0.000009883) andrei sys_open: { cpu_id = 1 }, { ip = 0xFFFFFFFF8120B940 } [12:45:26.842064681] (+0.000028504) andrei sys_close: { cpu_id = 1 }, { ip = 0xFFFFFFFF81209830 } [12:45:26.842097484] (+0.000032803) andrei sys_open: { cpu_id = 1 }, { ip = 0xFFFFFFFF8120B940 } [12:45:26.842126464] (+0.000028980) andrei sys_close: { cpu_id = 1 }, { ip = 0xFFFFFFFF81209830 } [12:45:26.842141670] (+0.000015206) andrei sys_open: { cpu_id = 1 }, { ip = 0xFFFFFFFF8120B940 } [12:45:26.842179482] (+0.000037812) andrei sys_close: { cpu_id = 1 }, { ip = 0xFFFFFFFF81209830 }</code> </pre><br><br>  The above output contains the ip-address field of the monitored function in the kernel. <br><br>  Using the ‚Äì‚àífunction option, you can set dynamic samples to enter and exit a function, for example: <br><br><pre> <code class="bash hljs">$ lttng <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-event call_rcu_sched -k --<span class="hljs-keyword"><span class="hljs-keyword">function</span></span> call_rcu_sched ..... [15:31:39.092335027] (+0.000000742) cs31401 call_rcu_sched_return: { cpu_id = 0 }, { }, { ip = 0xFFFFFFFF810E7B10, parent_ip = 0xFFFFFFFF810A206D } [15:31:39.092398089] (+0.000063062) cs31401 call_rcu_sched_entry: { cpu_id = 0 }, { }, { ip = 0xFFFFFFFF810E7B10, parent_ip = 0xFFFFFFFF810A206D } [15:31:39.092398883] (+0.000000794) cs31401 call_rcu_sched_return: { cpu_id = 0 }, { }, { ip = 0xFFFFFFFF810E7B10, parent_ip = 0xFFFFFFFF810A206D }</code> </pre><br><br>  In the above output, there is one more field: parent_ip - the address of the function that called the monitored function. <br><br>  In this section, we have given only the most simple examples.  However, the possibilities of LTTng are much wider: by combining various methods of instrumentation, it can be used to obtain such information about the operation of the system, which is difficult or impossible to obtain with other tools.  Read more about this and get acquainted with interesting examples, for example, <a href="https://lwn.net/Articles/492296/" rel="nofollow">in this article on LWN.net</a> . <br><br><h2>  Conclusion </h2><br><br>  LTTng is an interesting and promising tool. To tell about all its possibilities, one article is clearly not enough.  Therefore, we would be grateful for any comments and additions. <br>  And if you use LTTng in practice, we invite you to share your experience in the comments. <br><br>  For anyone who wants to get acquainted with LTTng closer, here is a selection of links to interesting and useful materials: <br><br><ul><li>  <a href="https://lttng.org/docs/" rel="nofollow">https://lttng.org/docs/</a> - official LTTng documentation; </li><li>  <a href="http://mdh.diva-portal.org/smash/get/diva2:325301/FULLTEXT01" rel="nofollow">http://mdh.diva-portal.org/smash/get/diva2:325301/FULLTEXT01</a> - a study of the effectiveness of LTTng in a multi-core environment, many interesting technical details; </li><li>  <a href="https://sourceware.org/ml/systemtap/2011-q1/msg00244.html" rel="nofollow">https://sourceware.org/ml/systemtap/2011-q1/msg00244.html</a> - comparing the performance of LTTng and SystemTap; </li><li>  <a href="https://events.linuxfoundation.org/slides/2011/lfcs/lfcs2011_tracing_goulet.pdf" rel="nofollow">https://events.linuxfoundation.org/slides/2011/lfcs/lfcs2011_tracing_goulet.pdf</a> - A presentation about tracing events in user space. </li></ul><br><br>  If for one reason or another you cannot leave comments here, welcome to our <a href="https://blog.selectel.ru/vglub-yadra-znakomstvo-s-lttng/">corporate blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/300966/">https://habr.com/ru/post/300966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../300948/index.html">‚ÄúI don‚Äôt remember those moments, I don‚Äôt even remember!‚Äù</a></li>
<li><a href="../300952/index.html">Multithreading in PHP: pthreads</a></li>
<li><a href="../300954/index.html">Writing a forum from scratch on Ruby on Rails and AngularJS</a></li>
<li><a href="../300956/index.html">Lazy event sourcing or how to live for today</a></li>
<li><a href="../300960/index.html">Snake fruit or fruit python?</a></li>
<li><a href="../300968/index.html">RS232 3-in-1 device for a home Linux server: Part 2 (Server)</a></li>
<li><a href="../300972/index.html">Record of the webinar "Light cloud protection of corporate networks with low total cost of ownership"</a></li>
<li><a href="../300974/index.html">"Astronauts" in Chile: how we did the entire IT infrastructure for four telescopes in the Andes</a></li>
<li><a href="../300976/index.html">8 tips for every day for those who want to be happy (part 1)</a></li>
<li><a href="../300978/index.html">Design differences for b2b and b2c spheres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>