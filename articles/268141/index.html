<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Non-constant constant expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="// <some code> 

 int main ( ) 
 { 
 constexpr int a = f ( ) ; 
 constexpr int b = f ( ) ; 

 static_assert ( a ! = b , "fail" ) ; 
 } 

 Is it possib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Non-constant constant expressions</h1><div class="post__text post__text-html js-mediator-article"><a name="Introduction"></a><img align="left" width="400" src="https://habrastorage.org/getpro/habr/post_images/bc2/939/d7c/bc2939d7c696f4212fd26badbc951306.png">  <font color="#888888">// &lt;some code&gt;</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  constexpr <font color="#0057AE">int</font> a <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  constexpr <font color="#0057AE">int</font> b <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  static_assert <font color="#006E28">(</font> a <font color="#006E28">! =</font> b <font color="#006E28">,</font> <font color="#BF0303">"fail"</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Is it possible to insert <i>such a</i> definition of <font color="#800000">f ()</font> in the above fragment, instead of a comment, so that <font color="#800000">a</font> gets a value other than <font color="#800000">b</font> ? <br><br>  ‚ÄúOf course not!‚Äù - you will say, having thought a little.  Indeed, both variables are declared with the <font color="#800000">constexpr qualifier</font> , which means that <font color="#800000">f ()</font> must also be a <i>constexpr</i> -function.  Everyone knows that <i>constexpr</i> functions can be executed at compile time, and, as a result, should not depend on the global state of the program or change it (in other words, <a href="https://goo.gl/Qxl5mY">they should be clean</a> ).  Purity means that the function must return the same value for each call with the same arguments.  <font color="#800000">f ()</font> is called both times without arguments, so it must return the same value both times, which will be assigned to variables <font color="#800000">a</font> and <font color="#800000">b</font> ... correctly? <br><br>  A week ago, I knew that this was true, and I really thought that it was impossible to pass <font color="#800000">static_assert</font> in the above fragment, avoiding unspecified behavior. <br><br>  I was wrong. <br><a name="habracut"></a><br><h3>  Content </h3><br><ul><li>  <a href="https://habr.com/ru/post/268141/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/268141/">Why would you ever need this?</a> </li><li>  <a href="https://habr.com/ru/post/268141/">Preliminary Information</a> <br><ul><li>  <a href="https://habr.com/ru/post/268141/">Keyword <font color="#800000">friend</font></a> </li><li>  <a href="https://habr.com/ru/post/268141/">Rules for constant expressions</a> </li><li>  <a href="https://habr.com/ru/post/268141/">Pattern Instance Semantics</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/268141/">Decision</a> <br><ul><li>  <a href="https://habr.com/ru/post/268141/">Implementation</a> </li><li>  <a href="https://habr.com/ru/post/268141/">Clarification</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/268141/">Conclusion</a> </li><li>  <a href="https://habr.com/ru/post/268141/">application</a> </li><li>  <a href="https://habr.com/ru/post/268141/">From translator</a> </li></ul><br><blockquote>  <b><font color="#FF0000">Disclaimer: The</font></b> technique described in this article is positioned as ‚Äúanother cunning hack with immersion in the dark depths of C ++.‚Äù  I do not recommend anyone to use it in production without first examining all the pitfalls (which will be described in detail in the following articles). <br><br>  The disclaimer was added after I read on other sites comments on this article, in which I discovered a misunderstanding of its purpose.  I do not approve the use of the described technology outside of your bedroom (without taking into account the consequences of such use). </blockquote><br><br><a name="Why_is_this_an_interesting_problem"></a><h2>  Why would you ever need this? </h2><br>  By solving the problem posed at the beginning of the article, we can successfully add a variable state to the compilation process (in other words, write imperative metaprograms). <br><br><blockquote>  <b>Note</b>  <b>lane:</b> A reader may argue that imperativeness in a metaprogram can be easily added using variable macro constants as ‚Äúvariables‚Äù.  So, to solve our problem, you can use <font color="#800000">#define f () __COUNTER__</font> or something like that. <br><br>  Unfortunately, this only works in the simplest cases, since the preprocessor opens macros as soon as it encounters them in the program text, while ignoring the syntactic constructs of the language itself.  Therefore, as soon as the order of instantiation of metafunctions becomes nontrivial, or something other than reading and a one-time change of a variable is required, macros are no longer useful in this capacity. </blockquote><br>  At first glance, this may seem like a small and innocent concept, but the technique described in the article will allow us to solve a number of problems that previously required very complex code or were completely insoluble. <br><br>  For example: <br><br><h4>  Compile-time counter </h4><br><blockquote>  <font color="#0057AE">using</font> C1 <font color="#006E28">=</font> ... <font color="#006E28">;</font> <br><br>  <font color="#0057AE">int</font> constexpr a <font color="#006E28">=</font> C1 <font color="#006E28">::</font> <font color="#2B74C7">next</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// = 1</font> <br>  <font color="#0057AE">int</font> constexpr b <font color="#006E28">=</font> C1 <font color="#006E28">::</font> <font color="#2B74C7">next</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// = 2</font> <br>  <font color="#0057AE">int</font> constexpr c <font color="#006E28">=</font> C1 <font color="#006E28">::</font> <font color="#2B74C7">next</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// = 3</font> </blockquote><br><h4>  Compile-time container meta-types </h4><br><blockquote>  <font color="#0057AE">using</font> LX <font color="#006E28">=</font> ... <font color="#006E28">;</font> <br><br>  LX <font color="#006E28">::</font> <font color="#2B74C7">push</font> <font color="#006E28">&lt;</font> <font color="#0057AE">void</font> <font color="#006E28">,</font> <font color="#0057AE">void</font> <font color="#006E28">,</font> <font color="#0057AE">void</font> <font color="#006E28">,</font> <font color="#0057AE">void</font> <font color="#006E28">&gt;</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  LX <font color="#006E28">::</font> <font color="#2B74C7">set</font> <font color="#006E28">&lt;</font> <font color="#B08000">0</font> <font color="#006E28">,</font> <font color="#0057AE">class</font> Hello <font color="#006E28">&gt;</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  LX <font color="#006E28">::</font> <font color="#2B74C7">set</font> <font color="#006E28">&lt;</font> <font color="#B08000">2</font> <font color="#006E28">,</font> <font color="#0057AE">class</font> World <font color="#006E28">&gt;</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  LX <font color="#006E28">::</font> <font color="#2B74C7">pop</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  LX <font color="#006E28">::</font> <font color="#2B74C7">value</font> <font color="#006E28">&lt;&gt;</font> x <font color="#006E28">;</font>  <font color="#888888">// type_list &lt;class Hello, void, class World&gt;</font> </blockquote><br><h4>  Other ideas </h4><br><ul><li>  <a href="http://stackoverflow.com/q/28179835/1090079">How do I know if a template has already been instantiated with certain parameters?</a> </li><li>  <a href="http://stackoverflow.com/questions/29522800/is-it-possible-to-obtain-the-address-of-a-implicit-instantiation-of-a-function-t">How to get the address of exactly the function that will be called after overload resolution?</a> </li><li>  <a href="http://stackoverflow.com/q/41453/1090079">How to add a reflection in C ++?</a> </li></ul><br><br><a name="Prerequisites"></a><h2>  Preliminary Information </h2><br><blockquote>  <b>Note:</b> This part describes in detail the technical aspects related to the solution of the problem.  So the most experienced (or impatient) readers can skip it.  If you are only here for snacks, go straight to the <a href="https://habr.com/ru/post/268141/">solution</a> . </blockquote><blockquote>  <b>Note:</b> It is recommended to skim through this part at least if you are wondering exactly how and why the solution code works (and is legal from the point of view of the standard). </blockquote><br><a name="The_friend_keyword"></a><h3>  Keyword <font color="#800000">friend</font> </h3><br>  Friendship in C ++ can be used not only to simply provide another entity with access to its <font color="#800000">private</font> and <font color="#800000">protected</font> members.  Consider the following (very simple) example: <br><br><blockquote>  <font color="#0057AE">class</font> A <font color="#006E28">;</font> <br>  <font color="#0057AE">void</font> touch <font color="#006E28">(</font> A <font color="#006E28">&amp;</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">class</font> A <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> <font color="#0057AE">void</font> touch <font color="#006E28">(</font> A <font color="#006E28">&amp;</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#0057AE">int</font> member <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">void</font> touch <font color="#006E28">(</font> A <font color="#006E28">&amp;</font> ref <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  ref.  <font color="#2B74C7">member</font> <font color="#006E28">=</font> <font color="#B08000">123</font> <font color="#006E28">;</font>  <font color="#888888">// OK, `void touch (A &amp;)` is another class A</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  A a <font color="#006E28">;</font>  a.  <font color="#2B74C7">member</font> <font color="#006E28">=</font> <font color="#B08000">123</font> <font color="#006E28">;</font>  <font color="#888888">// Incorrectly, the member `A :: member` is private</font> <br>  A b <font color="#006E28">;</font>  touch <font color="#006E28">(</font> b <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> </blockquote><br>  First, we <i>declare</i> the <font color="#800000">void touch (A &amp;)</font> function in the global scope, then we declare it <i>to be</i> class <font color="#800000">A-</font> <i>friendly</i> , and finally, we <i>define</i> it in the global scope. <br><br>  With the same success, we can place the combined declaration and definition of <font color="#800000">void touch (A &amp;)</font> directly inside class <font color="#800000">A</font> , without changing anything else - as in the following example: <br><br><blockquote>  <font color="#0057AE">class</font> A <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> <font color="#0057AE">void</font> touch <font color="#006E28">(</font> A <font color="#006E28">&amp;</font> ref <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  ref.  <font color="#2B74C7">member</font> <font color="#006E28">=</font> <font color="#B08000">123</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">int</font> member <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  A b <font color="#006E28">;</font>  touch <font color="#006E28">(</font> b <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// OK</font> <br>  <font color="#006E28">}</font> </blockquote><br>  It is very important that these two approaches to using a <font color="#800000">friend</font> are not completely equivalent (although in this particular case it may seem like this). <br><br>  In the last example, <font color="#800000">void touch (A &amp;)</font> will be implicitly placed in the scope of the next enclosing namespace for class <font color="#800000">A</font> , but access to it will be possible only through a <a href="http://en.cppreference.com/w/cpp/language/adl"><i>Koenig search</i></a> (ADL). <br><br><blockquote>  <font color="#0057AE">class</font> A <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">public</font> <font color="#006E28">:</font> <br>  A <font color="#006E28">(</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">friend</font> <font color="#0057AE">void</font> touch <font color="#006E28">(</font> A <font color="#006E28">)</font> <font color="#006E28">{</font> ... <font color="#006E28">}</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  A b <font color="#006E28">=</font> <font color="#B08000">0</font> <font color="#006E28">;</font>  touch <font color="#006E28">(</font> b <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// OK, `void touch (A)` will be found via ADL</font> <br>  touch <font color="#006E28">(</font> <font color="#B08000">0</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// Incorrect, the argument type is `int`, and ADL will not look at the class` A`</font> <br>  <font color="#006E28">}</font> </blockquote><br>  The following excerpt from the standard repeats the above, but I want you to concentrate on what is written between the lines (because it is equally important): <br><br><blockquote>  <font color="#800000">7.3.1.2/3</font> <b>Definitions of members of namespaces</b> <font color="#800000">[namespace.memdef] p3</font> <blockquote>  Each name first declared within a namespace is a member of that namespace.  If a <i>friend-</i> declaration inside a non-local class declares a class, function, class template, or function template for the first time, they become members of the nearest enclosing namespace.  <i>The friend</i> itself does not make the name visible for unqualified (3.4.1) or qualified (3.4.3) name searching. </blockquote></blockquote><br>  Please note that it is not stated anywhere that the name entered by a <i>friend</i> ad must have something to do with the name of the class in which the ad is located, and indeed any relation to that class, for that matter. <br><br><blockquote>  <font color="#006E28">#include &lt;iostream&gt;</font> <br><br>  <font color="#0057AE">class</font> A <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">public</font> <font color="#006E28">:</font> <br>  A <font color="#006E28">(</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <br>  <font color="#0057AE">friend</font> <font color="#0057AE">void</font> f <font color="#006E28">(</font> A <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">void</font> g <font color="#006E28">(</font> A <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">class</font> B <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> <font color="#0057AE">void</font> f <font color="#006E28">(</font> A <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  std <font color="#006E28">::</font> <font color="#2B74C7">cout</font> <font color="#006E28">&lt;&lt;</font> <font color="#BF0303">"hello world!"</font>  <font color="#006E28">&lt;&lt;</font> std <font color="#006E28">::</font> <font color="#2B74C7">endl</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">class</font> C <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> <font color="#0057AE">void</font> g <font color="#006E28">(</font> A <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  std <font color="#006E28">::</font> <font color="#2B74C7">cout</font> <font color="#006E28">&lt;&lt;</font> <font color="#BF0303">"! dlrow olleh"</font> <font color="#006E28">&lt;&lt;</font> std <font color="#006E28">::</font> <font color="#2B74C7">endl</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  A a <font color="#006E28">(</font> <font color="#B08000">0</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  f <font color="#006E28">(</font> a <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  g <font color="#006E28">(</font> <font color="#B08000">1</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> </blockquote><br>  So, <font color="#800000">f () has</font> nothing to do with class <font color="#800000">B</font> , except for the fact that it is defined as a <font color="#800000">friend</font> right inside it, and such code is absolutely correct. <br><br><blockquote>  <b>Note:</b> This reasoning may seem rather trivial, but if you have doubts about what is happening, I urge you to uncover some compiler and play around with the following snippets. </blockquote><br><a name="The_rules_of_constant-expressions"></a><h3>  Rules for constant expressions </h3><br>  There are a large number of rules related to <font color="#800000">constexpr</font> , and this introduction could be made more rigorous and detailed, but I will be brief: <br><br><ul><li>  <a href="http://en.cppreference.com/w/cpp/concept/LiteralType"><i>A literal</i></a> is a type that can have <i>constexpr</i> -variables and values ‚Äã‚Äãreturned by <i>constexpr</i> -functions.  These types are: scalar types (arithmetic types, pointers and enumerations), reference types and some others.  In addition, classes that satisfy certain constraints ( <i>constexpr -constructor</i> , trivial destructor, types of all data members, and base classes are literal) are also literal types; </li><li>  A variable declared with the <font color="#800000">constexpr qualifier</font> must be of a literal type and immediately be initialized with a <i>constant expression</i> ; </li><li>  A function declared with the <font color="#800000">constexpr qualifier</font> must take as parameters and return only literal types, and also must not contain constructs that are not allowed in <i>constant expressions</i> (for example, calls to non- <i>constexpr</i> functions). </li><li>  <i>A constant</i> is an expression in which they do not occur: <ul><li>  Calls are not <i>constexpr</i> -functions; <br></li><li>  Calls to functions that are not yet defined; <br></li><li>  Calls to functions with arguments that are not constant expressions; <br></li><li>  Calls to variables that were not initialized by constant expressions and began to exist before the start of the calculation of the current constant expression; <br></li><li>  Constructs causing undefined behavior; <br></li><li>  Lambda expressions, excitation exceptions and some other constructions. <br></li></ul></li></ul><br><blockquote>  <b>Note:</b> This list is incomplete and lax, but it gives an idea of ‚Äã‚Äãhow <i>constexpr-</i> entities and constant expressions behave in most cases. </blockquote><br>  Instead of a deep study of all aspects of working with constant expressions, we will focus on a rule that requires that constant expressions do not contain calls to functions that are not yet defined at the time of the call. <br><br><blockquote>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#0057AE">void</font> indirection <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  constexpr <font color="#0057AE">int</font> n <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// Incorrect, `int f ()` not yet defined</font> <br>  indirection <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> <font color="#B08000">0</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">void</font> indirection <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  constexpr <font color="#0057AE">int</font> n <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// OK</font> <br>  <font color="#006E28">}</font> </blockquote><br>  Here the <i>constexpr</i> <font color="#800000">int f ()</font> function is <i>declared</i> but not <i>defined</i> in <font color="#800000">main</font> , but it has a definition inside <font color="#800000">indirection</font> (since by the time the body started, the definition of <font color="#800000">indirection</font> has already been provided).  Therefore, inside <font color="#800000">indirection,</font> the <i>constexpr</i> call to the <font color="#800000">f ()</font> function is a constant expression, and the initialization <font color="#800000">n</font> is correct. <br><br><h4>  How to check that the expression is constant </h4><br>  There are several ways to check if a given expression is <i>constant</i> , but some of them are more difficult to implement than others. <br><br>  An experienced C ++ developer will immediately see here the opportunity to successfully apply the <a href="http://habrahabr.ru/post/205772/"><i>SFINAE</i></a> (Substitution Failure Is Not An Error) concept and will be right;  but the power that SFINAE provides is accompanied by the need to write fairly complex code. <br><br><blockquote>  <b>Note</b>  <b>lane:</b> <div class="spoiler">  <b class="spoiler_title">For example, such</b> <div class="spoiler_text"><blockquote>  constexpr <font color="#0057AE">int</font> x <font color="#006E28">=</font> <font color="#B08000">7</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> <font color="#006E28">&gt;</font> <br>  std <font color="#006E28">::</font> <font color="#2B74C7">false_type</font> isConstexpr <font color="#006E28">(</font> ... <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> T <font color="#006E28">,</font> T test <font color="#006E28">=</font> <font color="#006E28">(</font> <font color="#B08000">15</font> <font color="#006E28">*</font> <font color="#B08000">25</font> <font color="#006E28">-</font> x <font color="#006E28">)</font> <font color="#006E28">&gt;</font> <font color="#888888">// Test expression</font> <br>  std <font color="#006E28">::</font> <font color="#2B74C7">true_type</font> isConstexpr <font color="#006E28">(</font> T <font color="#006E28">*</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  constexpr <font color="#0057AE">bool</font> value <font color="#006E28">=</font> std <font color="#006E28">::</font> <font color="#2B74C7">is_same</font> <font color="#006E28">&lt;</font> decltype <font color="#006E28">(</font> isConstexpr <font color="#006E28">&lt;</font> <font color="#0057AE">int</font> <font color="#006E28">&gt;</font> <font color="#006E28">(</font> nullptr <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">,</font> std <font color="#006E28">::</font> <font color="#2B74C7">true_type</font> <font color="#006E28">&gt; ::</font> <font color="#2B74C7">value</font> <font color="#006E28">;</font>  <font color="#888888">// true</font> </blockquote></div></div></blockquote><br>  It is much easier to use the <font color="#800000">noexcept</font> operator to solve our problem.  This statement returns <font color="#800000">true</font> for expressions that cannot raise exceptions, and <font color="#800000">false</font> otherwise.  In particular, all constant expressions are considered not throwing exceptions.  On this we will play. <br><br><blockquote>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#0057AE">void</font> indirection <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#888888">// `f ()` is not a constant expression,</font> <br>  <font color="#888888">// no definition yet</font> <br><br>  constexpr <font color="#0057AE">bool</font> b <font color="#006E28">=</font> noexcept <font color="#006E28">(</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// false</font> <br>  <font color="#006E28">}</font> <br><br>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> <font color="#B08000">0</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">void</font> indirection <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#888888">// Now is</font> <br><br>  constexpr <font color="#0057AE">bool</font> b <font color="#006E28">=</font> noexcept <font color="#006E28">(</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// true</font> <br>  <font color="#006E28">}</font> </blockquote><br><blockquote>  <b>Note:</b> currently <b>clang</b> contains a <a href="https://llvm.org/bugs/show_bug.cgi%3Fid%3D15481">bug</a> , due to which <font color="#800000">noexcept</font> does not return <font color="#800000">true</font> , even if the expression being tested is constant.  A workaround can be found in the <a href="https://habr.com/ru/post/268141/">appendix</a> to this article. </blockquote><br><a name="The_semantics_of_template_instantiation"></a><h3>  Pattern Instance Semantics </h3><br>  If there is a part in the C ++ standard that challenges most programmers to a real challenge, it is undoubtedly related to templates.  If I decided to consider every aspect of instantiating templates here, the article would have grown enormously and you would be stuck reading it for at least a few hours. <br><br>  Since this is not what we are striving for, I will instead try to talk only about the fundamental principles of instantiation that will be needed to understand how the solution of our problem will work. <br><br><blockquote>  <b>Note:</b> Note that the contents of this section are not a complete reference for instantiating templates.  There are exceptions to the rules mentioned in it, besides, I deliberately omitted some facts that go too far beyond the scope of the article. </blockquote><br><h4>  Basic principles </h4><br><div class="spoiler">  <b class="spoiler_title">Dictionary for the little ones</b> <div class="spoiler_text"><ul><li>  <b>Template specialization</b> is an implementation derived from a template by replacing template parameters with specific arguments.  <font color="#800000">template &lt;typename T&gt; class Foo</font> - template.  <font color="#800000">Foo &lt;int&gt;</font> is its specialization.  The programmer can independently provide a <b>full</b> or <b>partial</b> template specialization for certain sets of arguments, if necessary, so that its behavior is different from the generalized one.  Partial specialization is not available for feature templates. </li><li>  <b>Instantiating a template specialization</b> ‚Äî the compiler receives the code for the specialization from the generalized template code.  For brevity, they often talk about instantiating a template with certain arguments, omitting the word ‚Äúspecialization‚Äù. </li><li>  Instantiation may be <b>explicit</b> or <b>implicit</b> .  When explicitly instantiating, the programmer independently informs the compiler about the need to instantiate the template with certain arguments, for example: <font color="#800000">template class Foo &lt;int&gt;</font> .  In addition, the compiler can independently implicitly instantiate a specialization if it needs it. </li></ul></div></div><br>  The following is a brief list of principles that are directly related to our task: <br><br><ul><li>  A template specialization (both a class and a function) <i>can be</i> implicitly instantiated only if it has not previously been explicitly instantiated, and the user has not provided the corresponding full specialization. </li><li>  The specialization of the function template <i>will be</i> implicitly instantiated if it is mentioned in a context that requires its <i>definition</i> , and the first item is fulfilled. </li><li>  The specialization of a class template <i>will be</i> implicitly instantiated if it is mentioned in a context that requires a <i>completely defined</i> (complete) type, or in the case when this completeness affects the semantics of the program, and (in both cases) the first item is executed. </li><li>  Instantiating a class template causes an implicit instantiation of the <i>declarations of</i> all its members, but not their <i>definitions</i> , unless the member is: <ul><li>  A static variable member, in which case the declaration is also not instantiated, or; </li><li>  By enumeration with no scope or anonymous union, in which case both the declaration and the definition will be instantiated. </li></ul></li><li>  Member <i>definitions</i> will be implicitly instantiated when requested, but not before. </li><li>  If the class template specialization contains <i>friend</i> declarations, the names of these friends are considered further as if their explicit specializations were placed at the point of instantiation. </li></ul><br><h4>  Instantiation points </h4><br>  Whenever the context in which the specialization of a template of a class or function is mentioned requires its instantiation, a so-called  <i>point of instantiation</i> (which actually defines one of the places where the compiler may be located at the moment of specialization code generation from the generalized template code). <br><br>  In the case of nested templates, when the specialization <font color="#800000">X of an</font> internal template is referred to in a context depending on the parameters of the external template <font color="#800000">Y</font> , the instantiation point of this specialization will depend on the corresponding point for the external template: <br><br><ul><li>  If <font color="#800000">X</font> is a specialization of a function template, the point of instantiation will be the same as the point of instantiation <font color="#800000">Y.</font> </li><li>  If <font color="#800000">X</font> is a class template specialization, the instantiation point will be immediately before the <font color="#800000">Y</font> instantiation point. </li></ul><br>  If there are no nested templates, or the context does not depend on the parameters of the external template, the instantiation point will be tied to the <font color="#800000">D</font> point of the declaration / definition of the ‚Äúmost global‚Äù entity, within which the <font color="#800000">X</font> specialization was mentioned: <br><br><ul><li>  If <font color="#800000">X</font> is a specialization of the function template, the instantiation point will be immediately after <font color="#800000">D.</font> </li><li>  If <font color="#800000">X</font> is a class template specialization, the instantiation point will be immediately before <font color="#800000">D.</font> </li></ul><br><h4>  Generating function template specialization </h4><br>  A function template specialization can have any number of instantiation points, but the expressions inside it should have the same meaning regardless of which instantiation point the compiler chooses to generate code (otherwise the program is considered incorrect). <br><br>  For simplicity, the C ++ standard prescribes that any instantiated specialization of a function template has an additional instantiation point at the end of a <a href="https://goo.gl/zHTZo1"><i>translation unit</i></a> : <br><br><blockquote>  <font color="#0057AE">namespace</font> N <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">struct</font> X <font color="#006E28">{</font> <font color="#888888">/ * Specially left blank * /</font> <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">void</font> func <font color="#006E28">(</font> X <font color="#006E28">,</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> T <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">void</font> call_func <font color="#006E28">(</font> T val <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  func <font color="#006E28">(</font> val <font color="#006E28">,</font> <font>3.14f</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  call_func <font color="#006E28">(</font> N <font color="#006E28">::</font> <font color="#2B74C7">X</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#888888">// First instantiation point</font> <br><br>  <font color="#0057AE">namespace</font> N <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">float</font> func <font color="#006E28">(</font> x <font color="#006E28">,</font> <font color="#0057AE">float</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#888888">// Second instantiation point</font> </blockquote><br>  In this example, we have two instantiation points for the <font color="#800000">void call_func &lt;N :: X&gt;</font> function <font color="#800000">(N :: X)</font> .  The first is immediately after the definition of <font color="#800000">main</font> (because <font color="#800000">call_func</font> is called inside it), and the second is at the end of the file. <br><br>  The given example is incorrect due to the fact that the behavior of <font color="#800000">call_func &lt;N :: X&gt;</font> changes depending on which of them the compiler generates specialization code: <br><br><ul><li>  At the first point, <font color="#800000">call_func</font> will call <font color="#800000">func (X, int)</font> , because there are no other overloads at this moment. </li><li>  At the second point, <font color="#800000">call_func</font> will call <font color="#800000">func (X, float)</font> already declared by this moment, as the most suitable of all available overloads. </li></ul><br><h4>  Generating class template specialization </h4><br>  For the specialization of a class template, all instances of instantiation, except the first, are ignored.  This actually means that the compiler must generate the specialization code at the time of its first mention in the context that requires instantiation. <br><br><blockquote>  <font color="#0057AE">namespace</font> N <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">struct</font> X <font color="#006E28">{</font> <font color="#888888">/ * Specially left blank * /</font> <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">void</font> func <font color="#006E28">(</font> X <font color="#006E28">,</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> T <font color="#006E28">&gt;</font> <font color="#0057AE">struct</font> A <font color="#006E28">{</font> <font color="#0057AE">using</font> type <font color="#006E28">=</font> decltype <font color="#006E28">(</font> func <font color="#006E28">(</font> T <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">,</font> <font>3.14f</font> <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> T <font color="#006E28">&gt;</font> <font color="#0057AE">struct</font> B <font color="#006E28">{</font> <font color="#0057AE">using</font> type <font color="#006E28">=</font> decltype <font color="#006E28">(</font> func <font color="#006E28">(</font> T <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">,</font> <font>3.14f</font> <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#888888">// Instantiation Point A</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  A <font color="#006E28">&lt;</font> N <font color="#006E28">::</font> <font color="#2B74C7">X</font> <font color="#006E28">&gt;</font> a <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">namespace</font> N <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">float</font> func <font color="#006E28">(</font> x <font color="#006E28">,</font> <font color="#0057AE">float</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#888888">// Instantiation Point B</font> <br><br>  <font color="#0057AE">void</font> g <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  A <font color="#006E28">&lt;</font> N <font color="#006E28">::</font> <font color="#2B74C7">X</font> <font color="#006E28">&gt; ::</font> <font color="#2B74C7">type</font> a <font color="#006E28">;</font>  <font color="#888888">// Incorrect, type will be `void`</font> <br>  B <font color="#006E28">&lt;</font> N <font color="#006E28">::</font> <font color="#2B74C7">X</font> <font color="#006E28">&gt; ::</font> <font color="#2B74C7">type</font> b <font color="#006E28">;</font>  <font color="#888888">// OK, type will be `float`</font> <br>  <font color="#006E28">}</font> </blockquote><br>  Here the instantiation point <font color="#800000">A &lt;N :: X&gt;</font> will be immediately before <font color="#800000">main</font> , while the instantiation point <font color="#800000">B &lt;N :: X&gt; will</font> be just before <font color="#800000">g</font> . <br><br><h4>  Putting it all together </h4><br>  The rules associated with <i>friend</i> declarations within class templates state that in the following example, the definitions of <font color="#800000">func (short)</font> and <font color="#800000">func (float) are</font> generated and placed at the instantiation points, respectively, of the specializations <font color="#800000">A &lt;short&gt;</font> and <font color="#800000">A &lt;float&gt;</font> . <br><br><blockquote>  constexpr <font color="#0057AE">int</font> func <font color="#006E28">(</font> <font color="#0057AE">short</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  constexpr <font color="#0057AE">int</font> func <font color="#006E28">(</font> <font color="#0057AE">float</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> T <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> A <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> constexpr <font color="#0057AE">int</font> func <font color="#006E28">(</font> T <font color="#006E28">)</font> <font color="#006E28">{</font> <font color="#000000">return</font> <font color="#B08000">0</font> <font color="#006E28">;</font>  <font color="#006E28">}</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> T <font color="#006E28">&gt;</font> <br>  A <font color="#006E28">&lt;</font> T <font color="#006E28">&gt;</font> indirection <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#888888">// (one)</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  indirection <font color="#006E28">&lt;</font> <font color="#0057AE">short</font> <font color="#006E28">&gt;</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// (2)</font> <br>  indirection <font color="#006E28">&lt;</font> <font color="#0057AE">float</font> <font color="#006E28">&gt;</font> <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font>  <font color="#888888">// (3)</font> <br>  <font color="#006E28">}</font> </blockquote><br>  When a calculated expression contains a call to the specialization of a function template, the return type of this specialization must be fully defined.  Therefore, calls in lines (2) and (3) entail implicit instantiation of specializations <font color="#800000">A,</font> along with specializations of <font color="#800000">indirection</font> in front of their instantiation points (which, in turn, are in front of the <font color="#800000">main</font> ). <br><br>  It is important that before reaching lines (2) and (3) the functions <font color="#800000">func (short)</font> and <font color="#800000">func (float) are</font> <i>declared</i> but not <i>defined</i> .  When the achievement of these lines causes the <font color="#800000">A</font> specializations to be instantiated, the definitions of these functions will appear, but will not be located next to these lines, but at (1). <br><br><br><a name="Solution"></a><h2>  Decision </h2><br>  I hope that the <a href="https://habr.com/ru/post/268141/">preliminary information</a> sufficiently discloses all aspects of the language that are used in the solution given in this section. <br><br>  Just in case, let me remind you that in order to fully understand how and why the solution works, you should be aware of the following aspects: <br><br><ul><li>  Keyword <font color="#800000">friend</font> , and; </li><li>  Rules for constant expressions, and; </li><li>  The semantics of instantiating templates. </li></ul><br><a name="The_Implementation"></a><h3>  Implementation </h3><br><blockquote>  constexpr <font color="#0057AE">int</font> flag <font color="#006E28">(</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> writer <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> constexpr <font color="#0057AE">int</font> flag <font color="#006E28">(</font> Tag <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> <font color="#B08000">0</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">bool</font> B <font color="#006E28">,</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">=</font> <font color="#0057AE">int</font> <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> dependent_writer <font color="#006E28">:</font> writer <font color="#006E28">&lt;</font> Tag <font color="#006E28">&gt;</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <br>  <font color="#0057AE">bool</font> B <font color="#006E28">=</font> noexcept <font color="#006E28">(</font> flag <font color="#006E28">(</font> <font color="#B08000">0</font> <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">,</font> <br>  <font color="#0057AE">int</font> <font color="#006E28">=</font> <font color="#2B74C7">sizeof</font> <font color="#006E28">(</font> dependent_writer <font color="#006E28">&lt;</font> B <font color="#006E28">&gt;</font> <font color="#006E28">)</font> <br>  <font color="#006E28">&gt;</font> <br>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> B <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  constexpr <font color="#0057AE">int</font> a <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  constexpr <font color="#0057AE">int</font> b <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  static_assert <font color="#006E28">(</font> a <font color="#006E28">! =</font> b <font color="#006E28">,</font> <font color="#BF0303">"fail"</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> </blockquote><br><blockquote>  <b>Note:</b> <b>clang</b> demonstrates incorrect behavior with this code, a workaround is available in the <a href="https://habr.com/ru/post/268141/">application</a> . </blockquote><blockquote>  <b>Note</b>  <b>Trans:</b> Visual cues in <b>Visual Studio 2015</b> also ‚Äúdo not notice‚Äù the changes in <font color="#800000">f ()</font> .  However, after compilation, the values ‚Äã‚Äãof <font color="#800000">a</font> and <font color="#800000">b</font> are different. </blockquote><br><a name="The_Explanation"></a><h3>  But how does this work? </h3><br>  If you have read the <a href="https://habr.com/ru/post/268141/">preliminary information</a> , an understanding of the above solution should not cause you any difficulties, but even in this case, a detailed explanation of the principles of operation of its various parts may be of interest. <br><br>  In this section, the source code is analyzed step by step and a brief description and justification is given for each of its fragments. <br><br><h4>  "Variable" </h4><br>  At each point of the program, the <i>constexpr</i> function can be in one of two states: either it is already defined and can be called from constant expressions, or not.  Only one of these two situations is possible (unless unspecified behavior is allowed). <br><br>  Usually, <i>constexpr</i> functions are considered and used exactly as functions, but thanks to the above, we can think of them as ‚Äúvariables‚Äù that have a type similar to <font color="#800000">bool</font> .  Each such ‚Äúvariable‚Äù is in one of two states: ‚Äúdefined‚Äù or ‚Äúundefined‚Äù. <br><br><blockquote>  constexpr <font color="#0057AE">int</font> flag <font color="#006E28">(</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <font color="#006E28">;</font> </blockquote><br>  In our program, the <font color="#800000">flag</font> function is just a similar trigger.  We will not call it as a function anywhere, being interested only in its current state as a ‚Äúvariable‚Äù. <br><br><h4>  Modifier </h4><br>  <font color="#800000">writer</font> is a class template that, when instantiated, creates a definition for a function in its enclosing namespace (in our case, global).  The <font color="#800000">Tag</font> template parameter defines a specific function signature, whose definition will be created: <br><br><blockquote>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> writer <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> constexpr <font color="#0057AE">int</font> flag <font color="#006E28">(</font> Tag <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> <font color="#B08000">0</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> </blockquote><br>  If we, as we were going to, consider <i>constexpr</i> functions as ‚Äúvariables,‚Äù instantiating a <font color="#800000">writer</font> with a template argument <font color="#800000">T</font> will cause the unconditional translation of the ‚Äúvariable‚Äù with the signature <font color="#800000">int func (T)</font> to the ‚Äúdefined‚Äù position. <br><br><h4>  Proxy </h4><br><blockquote>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">bool</font> B <font color="#006E28">,</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">=</font> <font color="#0057AE">int</font> <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> dependent_writer <font color="#006E28">:</font> writer <font color="#006E28">&lt;</font> Tag <font color="#006E28">&gt;</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">;</font> </blockquote><br>  I'm not surprised if you decided that <font color="#800000">dependent_writer</font> looks like a meaningless layer adding indirectness.  Why not directly instantiate <font color="#800000">writer &lt;Tag&gt;</font> where we want to change the value of a ‚Äúvariable‚Äù instead of accessing it via <font color="#800000">dependent_writer</font> ? <br><br>  The fact is that a direct reference to <font color="#800000">writer &lt;int&gt;</font> does not guarantee that the first argument of the function template <font color="#800000">f</font> will be calculated before the second (and the function on the first call will have time to ‚Äúremember‚Äù that you need to return <font color="#800000">false</font> , and only then change the value of ‚Äúvariable‚Äù) . <br><br>  To set the order we need for calculating template arguments, we can add an additional dependency using <font color="#800000">dependent_writer</font> .  The first template argument, <font color="#800000">dependent_writer,</font> must be evaluated before it is instantiated, and therefore, before the <font color="#800000">writer</font> itself is instantiated.  Therefore, by passing <font color="#800000">B</font> to <font color="#800000">dependent_writer</font> as an argument, we can be sure that by the time instantiation of the <font color="#800000">writer</font> , the value returned by the <font color="#800000">f</font> function will already be calculated. <br><br><blockquote>  <b>Note:</b> When writing the implementation, I considered many alternatives, trying to find the most simple to understand.  I sincerely hope that this fragment has turned out not too confusing. </blockquote><br><h4>  Magic </h4><br><blockquote>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <br>  <font color="#0057AE">bool</font> B <font color="#006E28">=</font> noexcept <font color="#006E28">(</font> flag <font color="#006E28">(</font> <font color="#B08000">0</font> <font color="#006E28">)</font> <font color="#006E28">)</font> <font color="#006E28">,</font> <font color="#888888">// (1)</font> <br>  <font color="#0057AE">int</font> <font color="#006E28">=</font> <font color="#2B74C7">sizeof</font> <font color="#006E28">(</font> dependent_writer <font color="#006E28">&lt;</font> B <font color="#006E28">&gt;</font> <font color="#006E28">)</font> <font color="#888888">// (2)</font> <br>  <font color="#006E28">&gt;</font> <br>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> B <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> </blockquote><br>  This fragment may seem a bit strange, but in fact it is very simple: <br><br><ul><li>  (1) sets <font color="#800000">B</font> to <font color="#800000">true</font> if <font color="#800000">flag (0)</font> is a constant expression, and <font color="#800000">false</font> to <font color="#800000">false</font> if not; </li><li>  (2) implicitly instantiate <font color="#800000">dependent_writer &lt;B&gt;</font> ( <font color="#800000">sizeof</font> operator requires a completely specific type).  At the same time, <font color="#800000">writer &lt;B&gt;</font> is instantiated, which, in turn, causes the generation of the definition of <font color="#800000">int flag (int)</font> and a change in the state of our ‚Äúvariable‚Äù. </li></ul><br>  Behavior can be expressed by the following pseudocode: <br><br><pre><code class="hljs markdown"> [ <span class="hljs-code"><span class="hljs-code">`int flag (int)`</span></span>    ]:  <span class="hljs-code"><span class="hljs-code">`B`</span></span> = <span class="hljs-code"><span class="hljs-code">`false`</span></span>  <span class="hljs-code"><span class="hljs-code">`dependent_writer &lt;false&gt;`</span></span>  <span class="hljs-code"><span class="hljs-code">`B`</span></span> :  <span class="hljs-code"><span class="hljs-code">`B`</span></span> = <span class="hljs-code"><span class="hljs-code">`true`</span></span>  <span class="hljs-code"><span class="hljs-code">`dependent_writer &lt;true&gt;`</span></span>  <span class="hljs-code"><span class="hljs-code">`B`</span></span></code> </pre> <br>  Thus, the first time <font color="#800000">f is</font> called, the template argument <font color="#800000">B</font> will be <font color="#800000">false</font> , but a side effect of calling <font color="#800000">f</font> will be changing the state of the ‚Äúvariable‚Äù <font color="#800000">flag</font> (generating and placing its definition in front of the <font color="#800000">main</font> body).  With further calls to <font color="#800000">f, the</font> ‚Äúvariable‚Äù <font color="#800000">flag</font> will already be in the ‚Äúdetermined‚Äù state, so <font color="#800000">B</font> will be equal to <font color="#800000">true</font> . <br><br><br><a name="Conclusion"></a><h2>  Conclusion </h2><br><blockquote>  The fact that people continue to discover crazy ways to do new things with C ++ (which were previously considered impossible) is both amazing and terrible.  - <i>Maurice Bos</i> </blockquote><br>  This article explains the basic idea that allows you to add a state to constant expressions.  In other words, the generally accepted theory (to which I myself often referred) that constant expressions are ‚Äúconstant‚Äù has now been destroyed. <br><br><blockquote>  <b>Note</b>  <b>Per:</b> In my opinion, ‚Äúdestroyed‚Äù is an excessively strong word.  All the same, despite the identity of the names, the solution invokes two different specializations of the template function <font color="#800000">f ()</font> , each of which is fully ‚Äúconstant‚Äù.  Of course, this does not detract from the overall usefulness of the idea. </blockquote><br>  While writing this article, I could not help but think about the <a href="http://goo.gl/iEXMsf"><i>history of template metaprogramming</i></a> and how strange it is that the language allows you to do more than you ever intended to do with it. <br>  What's next? <br><br>  I wrote a library for <i>imperative template metaprogramming</i> called <b>smeta</b> , which will be published, explained and discussed in upcoming articles.  Among the topics that will be covered: <br><br><ul><li>  How to implement a compile-time counter </li><li>  How to implement compile-time meta-type container </li><li>  How to check and manage overload permissions </li><li>  How to add reflection in C ++ </li></ul><br><blockquote>  <b>Note</b>  <b>Lane:</b> The author reports that he decided to cancel the release of <b>smeta</b> , since  This and the following articles contain (or will contain) almost all of its features, and, therefore, the reader‚Äôs self-realization of its functionality will be almost trivial for yourself.  For example, I have already (contrary to Philip's warning, aha) introduced some ideas and are going to gather them into something like a library in perspective. </blockquote><br><br><a name="Appendix"></a><h2>  application </h2><br>  Because of <a href="https://llvm.org/bugs/show_bug.cgi%3Fid%3D15481">this</a> (and its associated) bug in a <b>clang</b> , the above solution causes the program to behave incorrectly when properly implemented.  Below is an alternative implementation of the solution, written specifically for <b>clang</b> (which is still the correct C ++ code and can be used with any compilers, although it is somewhat complicated). <br><br><blockquote>  <font color="#0057AE">namespace</font> detail <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">struct</font> A <br>  <font color="#006E28">{</font> <br>  constexpr A <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <br>  <font color="#0057AE">friend</font> constexpr <font color="#0057AE">int</font> adl_flag <font color="#006E28">(</font> A <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> writer <br>  <font color="#006E28">{</font> <br>  <font color="#0057AE">friend</font> constexpr <font color="#0057AE">int</font> adl_flag <font color="#006E28">(</font> Tag <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> <font color="#B08000">0</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br>  <font color="#006E28">}</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">,</font> <font color="#0057AE">int</font> <font color="#006E28">=</font> adl_flag <font color="#006E28">(</font> Tag <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">)</font> <font color="#006E28">&gt;</font> <br>  constexpr <font color="#0057AE">bool</font> is_flag_usable <font color="#006E28">(</font> <font color="#0057AE">int</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> true <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">typename</font> Tag <font color="#006E28">&gt;</font> <br>  constexpr <font color="#0057AE">bool</font> is_flag_usable <font color="#006E28">(</font> ... <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> false <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <font color="#0057AE">bool</font> B <font color="#006E28">,</font> <font color="#0057AE">class</font> Tag <font color="#006E28">=</font> detail <font color="#006E28">::</font> <font color="#2B74C7">A</font> <font color="#006E28">&gt;</font> <br>  <font color="#0057AE">struct</font> dependent_writer <font color="#006E28">:</font> detail <font color="#006E28">::</font> <font color="#2B74C7">writer</font> <font color="#006E28">&lt;</font> Tag <font color="#006E28">&gt;</font> <font color="#006E28">{</font> <font color="#006E28">}</font> <font color="#006E28">;</font> <br><br>  <font color="#0057AE">template</font> <font color="#006E28">&lt;</font> <br>  <font color="#0057AE">class</font> Tag <font color="#006E28">=</font> detail <font color="#006E28">::</font> <font color="#2B74C7">A</font> <font color="#006E28">,</font> <br>  <font color="#0057AE">bool</font> B <font color="#006E28">=</font> is_flag_usable <font color="#006E28">&lt;</font> Tag <font color="#006E28">&gt;</font> <font color="#006E28">(</font> <font color="#B08000">0</font> <font color="#006E28">)</font> <font color="#006E28">,</font> <br>  <font color="#0057AE">int</font> <font color="#006E28">=</font> <font color="#2B74C7">sizeof</font> <font color="#006E28">(</font> dependent_writer <font color="#006E28">&lt;</font> B <font color="#006E28">&gt;</font> <font color="#006E28">)</font> <br>  <font color="#006E28">&gt;</font> <br>  constexpr <font color="#0057AE">int</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  <font color="#000000">return</font> B <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> <br><br>  <font color="#0057AE">int</font> main <font color="#006E28">(</font> <font color="#006E28">)</font> <br>  <font color="#006E28">{</font> <br>  constexpr <font color="#0057AE">int</font> a <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  constexpr <font color="#0057AE">int</font> b <font color="#006E28">=</font> f <font color="#006E28">(</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br><br>  static_assert <font color="#006E28">(</font> a <font color="#006E28">! =</font> b <font color="#006E28">,</font> <font color="#BF0303">"fail"</font> <font color="#006E28">)</font> <font color="#006E28">;</font> <br>  <font color="#006E28">}</font> </blockquote><br><blockquote>  <b>Note:</b> I am currently writing relevant bug reports that will show why this workaround solution works in <b>clang</b> .  Links to them will be added as soon as the reports are submitted (so far everything is dull - <i>approx. Lane</i> ). </blockquote><br><div class="spoiler">  <b class="spoiler_title">Thanks section of the original article</b> <div class="spoiler_text"><h2>  Thanks </h2><br>  There are many people without whom this article would not have been written, but I am especially grateful: <br><br><ul><li>  <b><font color="#800000">Maurice Bosu</font> , for:</b> <ul><li>  Help with the formulation of ideas. </li><li>  Giving me the means to buy contact lenses, which saved me from having to (literally) write blindly. </li><li>  Tolerance of my harassment about his opinion on the article. </li></ul></li><li>  <b><font color="#800000">Michael Kilpelainen</font> , for:</b> <ul><li>  Proofreading, as well as interesting thoughts on how to make this article more understandable. </li></ul></li><li>  <b><font color="#800000">Columbo</font> , for:</b> <ul><li>  Unsuccessful attempts to prove that the described technique gives rise to incorrect programs (by throwing paragraphs of the C ++ standard in my face).  If anything, I would have done the same for him. </li></ul></li></ul></div></div><br><br><a name="From_the_translator"></a><h2>  From translator </h2><br>  I came across this article about a month ago and was impressed by the <s>terrible indecencies by the</s> grace of the idea of ‚Äã‚Äãadding to the metaprogramming on templates, by its nature, a functional dependence on the global state.  The author of the article, <a href="https://www.facebook.com/filip.roseen">Philip Roseen</a> - a developer, musician, model and just a good person - kindly allowed me to translate it into Russian. <br><br>  This article is the first in a <a href="http://b.atch.se/">series of articles</a> on imperative metaprogramming, which develop the idea of ‚Äã‚Äãnon-constant <i>constexpr</i> 's (whose immediate applicability is very limited in practice) before implementing constructs that can make real metaprogramming much more convenient. <br><br>  I am going to soon translate the two remaining articles (on the compile-time counter and on the meta-type container).  In addition, Philip said that in the foreseeable future, he will continue the series and develop ideas further (then, of course, there will be new translations). <br><br>  Corrections, additions, suggestions are welcome.  You can also <a href="">write</a> to Philip himself, I think he will be happy for any comments. <br><br></div><p>Source: <a href="https://habr.com/ru/post/268141/">https://habr.com/ru/post/268141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268127/index.html">How does the radio interface work in GSM networks</a></li>
<li><a href="../268129/index.html">File System and Hadoop: The Twitter Experience (Part 2)</a></li>
<li><a href="../268131/index.html">Mono and OS MSVS</a></li>
<li><a href="../268135/index.html">About safety UEFI, part six</a></li>
<li><a href="../268137/index.html">Good luck in the digital age! Or turn on the paranoid and check the protection of their data</a></li>
<li><a href="../268143/index.html">Android Studio 1.4 available</a></li>
<li><a href="../268145/index.html">Network system calls. Part 3</a></li>
<li><a href="../268151/index.html">Aero Framework - WPF new breath. Rise above MVVM</a></li>
<li><a href="../268153/index.html">Development and publication of asset in the Unity Asset Store</a></li>
<li><a href="../268155/index.html">About Garbage Collector, Unity and weak links</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>