<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Superscalar stack processor: we continue to cross the grass and the hedgehog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A continuation of the article , where it was possible to demonstrate that the frontend of a stack machine completely allows to hide behind it a supers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Superscalar stack processor: we continue to cross the grass and the hedgehog</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/acb/653/0c8/acb6530c810f428785100c32cc6843cc.jpg"><br>  A continuation of the <a href="https://habrahabr.ru/post/278575/">article</a> , where it was possible to demonstrate that the <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">frontend of a</a> stack machine completely allows to hide behind it a <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">superscalar</a> processor with <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">OoO</a> . <br>  The topic of this article is function invocation. <br><a name="habracut"></a><br><h3>  Stack (s) and function calls </h3><br>  From general considerations, the architecture being described has problems calling functions.  In fact, after returning from a function, we expect a return of the state of the registers in the context of the current function.  In modern register architectures for this, registers <a href="https://habrahabr.ru/post/267771/">are divided</a> into two categories ‚Äî the caller is responsible for the safety of some, the callee for others. <br><br>  But in our front-end stack architecture, therefore, the compiler may not be aware of the existence of any kind of registers.  And the processor itself should take care of saving / restoring the context, which seems to be a non-trivial task. <br><br>  But before we do a lyrical digression on the theme of the stack itself. <br>  The very concept of a stack is misleading. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here in <a href="http://everything2.com/title/System%25252F370%2BS-type%2Blinkage%2Bconvention">IBM / 360</a> there is no hardware stack.  But functions (including recursively) can be called, for this the parameters are stored in the memory area, which must be solicited from the OS before the call. <br><br>  In x86 there is a hardware stack, but no one classifies this architecture as a stack one.  This stack is an excellent mechanism for storing local variables and function parameters. <br><br>  AMD29K, SPARC and Itanium belong to the so-called <a href="https://en.wikipedia.org/wiki/Berkeley_RISC">Berkeley Risc</a> family of architectures, and their stack performs another important function: the register pool is the top of the stack (register windows), which is supposed to speed up the transfer of parameters when calling functions. <br>  SPARC V7 appeared a couple of years earlier than AMD29K, but it seems (author) less architecturally slim. <br>  Itanium's <a href="http://people.cs.pitt.edu/~mock/cs2210/handouts/itanium-register-convention.pdf">RSE</a> block is generally similar to that of AMD29K, but appeared much later. <br><br><h4>  <a href="http://datasheets.chipdb.org/AMD/29K/29kprog.pdf">AMD29K</a> deserves some kind words </h4><br>  It has two hardware stacks.  A few stacks in the architecture are not new, it was still on <a href="http://www.cs.virginia.edu/brochure/images/manuals/b5000/descrip/descrip.html">Burroughs B5000</a> , the Soviet (and <a href="http://www.mcst.ru/doc/book_121130.pdf">present</a> ) Elbrus.  But there the second stack is designed to store the return addresses from the procedures.  Here they are both used to store data: <br><ul><li>  memory stack - used to store large local variables (structures and arrays) as well as the tail of parameters, if there are more than 16. Register gr125 (msp) is a pointer to the top of this stack. </li><li>  register stack - there are 128 local registers that form the top of the stack <br><ul><li>  register stack serves for quick access to the top of the stack in memory (different from the above described memory stack, of course) </li><li>  global registers gr126 (rab) and gr127 (rfb) determine the top and bottom of the stack, gr1 (rsp) stores a pointer to its top <br><img src="https://habrastorage.org/files/aef/e15/7d6/aefe157d679149559ffe34627b6654a7.PNG"></li><li>  can do two reads and one write in one cycle </li><li>  there are no explicit stack operations such as push &amp; pop, instead of them, when the function is called for it, the number of registers defined by the compiler is released (activation record, so called call frame) <br></li><li>  access to data from the activation record goes through registers, which <b>for each function are numbered from lr0</b> </li><li>  lr0 and lr1 are reserved in the first return address, in the second - the activation record of the calling function </li><li>  register windows of the calling and called functions intersect with parameters similar to <a href="http://people.cs.clemson.edu/~mark/subroutines/sparc.html">SPARC</a> </li><li>  if there is not enough free registers to call a function, <a href="https://en.wikipedia.org/wiki/Trap_(computing)">trap</a> SPILL occurs, the handler of which pushes some of the register values ‚Äã‚Äãinto memory, freeing them </li><li>  on the contrary, when there are too many free registers, FILL works. </li><li>  to make this happen, the compiler inserts instructions <br><blockquote><pre>         sub gr1, gr1,16; function prologue, lr0 + lr1 + 2 local variables 
         asgeu SPILL, gr1, rab; compare with top of window 
 .  .  .  ; function body
         jmpi lr0; return 
         asleu FILL, lr1, rfb; compare with bottom of window gr127
</pre></blockquote></li></ul><br></li></ul>  What interesting ideas should be noted here? <br><ol><li>  The numbering of registers for each function is its own, this is a feature of Berkeley RISC </li><li>  But stack splitting is a feature of this particular architecture.  In SPARC, register windows <a href="http://ieng9.ucsd.edu/~cs30x/sparcstack.html">are saved</a> to the same stack, where the normal (not fast) variables lie.  And fill / spill are made with gaps - each window from its frame. </li></ol><br>  This division of the stack into ‚Äúbig but slow‚Äù and ‚Äúsmall but fast‚Äù is very important.  We will understand with the motives. <br><br><h4>  Parameter passing, function call </h4><br>  The idea of ‚Äã‚Äãa stack as a repository of local variables (and parameters) is beautiful in its logic and completeness.  Weak spot - system performance is limited by delays and memory performance.  At the time of the <a href="https://en.wikipedia.org/wiki/PDP-11">PDP-11</a> , nothing could be done about it, but since then the situation has changed. <br><br>  First, access to registers has become significantly faster than access to memory, which has caused the need for data caching.  Secondly, it became possible to have a much larger number of registers. <br><br>  The possession of a large number of registers creates a temptation to use them to speed up the transfer of arguments when calling functions.  In fact, there are usually few parameters (less than local data), their values ‚Äã‚Äãare almost always needed by someone.  And what of the local data deserves to get into the registers, let the optimization decide.  This, of course, is a very crude simplification, intended only to demonstrate a general motivation. <br><br>  Currently, there are two common methods for passing parameters through registers: <br><ol><li>  Assignment to specific registers of a special role.  For example, in <a href="https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx">MSVC (x86-64),</a> it is customary to pass the first four integer arguments through the registers RCX, RDX, R8, R9.  This implies a single register numbering for all functions.  The architectures using this technique can also be attributed to MIPS, PPC, ARM, DEC Alpha ... It is clear that in the call chain there is still no other way to save parameters except on the stack.  Here all hope for a cache.  Or the optimizer, which can decide that a specific parameter in this function is no longer used and does not need to be saved at all. </li><li>  Register windows technique.  This branch of architecture is growing from the Berkeley Risc project.  This includes the AMD29K already parsed by us, as well as i960, Itanium, SPARC.  The bottom line is that the limited number of parameters and local data of the called function are located in the register window; when you call the next function, the window is shifted, so this data forms a stack.  Each function has its own register numbering.  All that does not fit into the window, falls into a normal stack, global registers for temporary data can also be used.  So in the case of <a href="http://download.intel.com/design/i960/MANUALS/27248302.pdf">i960</a> and SPARC, the register stack is interspersed with a regular one, and for AMD29K &amp; Itanium these are different stacks.  In fact, AMD29K &amp; Itanium suggests the compiler to choose which data it considers worthy of being in the ‚Äúfast stack‚Äù, everything else will happen by itself.  This is reminiscent of the now obsolete ‚Äúregister‚Äù keyword in C, only the compiler decides, the high-level language, though. </li></ol><br>  In terms of potential performance, both approaches are roughly equivalent.  In the first approach, the entire burden of optimization falls on the compiler, and not on the processor, which (probably) facilitates and reduces the cost of development of the final system. <br><br>  But we got a little carried away, it's time to return to preserving the context of the current function in the designed architecture. <br><br><h4>  Saving function context </h4><br>  And what is included in this context?  The registers used at the moment of calling the child procedure. <br>  At the same time, the registers of non-calculated expressions are interconnected through topological sorting, but this does not matter for the called function.  At the time of the capture of the output registers by the mops, it does not matter in what order they were captured. <br><br>  There is a nuance that is worth noting - before the start of the function call, all the mops with which its arguments were calculated must work.  Therefore, from the point of view of the processor, a function call is a generalized instruction with an arbitrary number of arguments. <br><br>  Now it is necessary to determine the numbering of registers. <br>  Let the numbering be common, i.e.  we took the path of MIPS, not SPARC. <br><ul><li>  If the call chain is long enough, it is obvious that <b>all registers are busy</b> .  And we are talking about which ones we will load into memory (SPILL).  Those.  capture order is still important. </li><li>  order of capture depends on the history of calls </li><li>  inside the function it is determined dynamically </li><li>  there are no guarantees that by returning the result of the function in some register, we will not get (during the reverse execution of FILL) a conflict with this register </li><li> the author does not see ways to avoid such conflicts, which, of course, does not mean that there really are no ways for them </li></ul><br>  Let's try register windows. <br><ul><li>  The numbering of the registers in each function starts anew, and this is simply wonderful.  saves us from taking into account the history </li><li>  common technique - ring buffer registers, FILL &amp; SPILL </li><li>  we will use two physical stacks - for register windows and everything else </li><li>  you need to remember which registers are used at the time of calling the child function.  And we have such information.  Suppose that the registers r0, r5 and r11 are occupied.  In fact, only a quarter of the used range of registers is used and there is a temptation to somehow ‚Äúpack‚Äù them.  But then when returning from the child function, you will have to ‚Äúunpack‚Äù them back.  So the pool of registers of the current function (in this case) will remain the size of 12 registers (+ service information: return address, previous frame).  Moreover, the number of registers in itself is not so critical, the number of simultaneous read / write operations is much more expensive, and it will not change </li><li>  but with the preservation of registers in memory, perhaps something can be done, try not to save in memory obviously unnecessary data from unused registers </li><li>  for this, after writing the occupied function registers, save the mask of their employment </li><li>  for this, in turn, FILL &amp; SPILL will have to be done not by the number of registers needed, but by frame: everything that concerns one call at a time </li><li>  then in the current beginning of the register ring buffer there will always be a frame descriptor (the next candidate for SPILL) </li><li>  and the first register that we retrieve with FILL will contain a mask (or part of it) of the used registers, with which we will extract from the memory and the required number of registers, which was required </li></ul><br>  However, by focusing on the outside of the function call, we lost sight of how it would all be executed inside.  The author does not consider himself a specialist in hardware, but he still foresees problems. <br>  Fortunately, we will deal with them in the <a href="https://habrahabr.ru/post/280087/">next article</a> . </div><p>Source: <a href="https://habr.com/ru/post/279123/">https://habr.com/ru/post/279123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279107/index.html">1.3 SFML and Linux</a></li>
<li><a href="../279109/index.html">KTV. Rake on the way to marshaling</a></li>
<li><a href="../279111/index.html">C ++ exception handling under the hood or how exceptions work in C ++</a></li>
<li><a href="../279113/index.html">Observation of internationalized domain names and the letter K</a></li>
<li><a href="../279117/index.html">Linear models: simple regression</a></li>
<li><a href="../279125/index.html">Dagger 2. Part One. Basics, creating a dependency graph, Scopes</a></li>
<li><a href="../279127/index.html">Nutanix Big Update: NutanixOS 4.6</a></li>
<li><a href="../279129/index.html">On the issue of errors</a></li>
<li><a href="../279133/index.html">The digest of interesting materials for the mobile developer # 144 (on March 9-13)</a></li>
<li><a href="../279139/index.html">We invite everyone to the first hackathon in the history of the Stavropol Territory</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>