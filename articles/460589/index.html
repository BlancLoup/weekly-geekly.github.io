<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a simple neural network using mathematics and numpy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why another article about how to write neural networks from scratch? Alas, I could not find an article where theory and code would be described from s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a simple neural network using mathematics and numpy</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5_/h5/0t/5_h50teeaqngyx0ccp8cqjqfumm.jpeg" width="350"></div><br>  Why another article about how to write neural networks from scratch?  Alas, I could not find an article where theory and code would be described from scratch to a fully working model.  Immediately I warn you that there will be a lot of mathematics.  I assume that the reader is familiar with the basics of linear algebra, partial derivatives and at least partially, with probability theory, as well as Python and Numpy.  We will deal with a fully connected neural network and MNIST. <br><a name="habracut"></a><br><h2>  Maths.  Part 1 (simple) </h2><br>  What is a fully connected layer (FC layer)?  Usually they say something in the spirit of "A fully connected layer is a layer, each neuron of which is connected to all the neurons of the previous layer."  That's just not clear what neurons are, how they are connected, especially in the code.  Now I will try to make out this example.  So let there be a layer of 100 neurons.  I know that I have not yet explained what it is, but let's just imagine that there are 100 neurons and they have an input, where the data are being fed, and an output, from where they give out data.  And at the input they are given a black and white picture of 28x28 pixels - only 784 values, if you stretch it into a vector.  The picture can be called the input layer.  Then each of the 100 neurons connects with each ‚Äúneuron‚Äù or, if you like, the value of the previous layer (that is, the picture), each of the 100 neurons needs to accept 784 values ‚Äã‚Äãof the original picture.  For example, for each of the 100 neurons it will be enough to multiply 784 values ‚Äã‚Äãof the image by some 784 numbers and add them together, as a result one number comes out.  That is, this is the neuron: <br><p><math> </math> $$ display $$ \ text {Neuron output} = \ text {some number} _ {1} \ cdot \ text {picture value} _1 ~ + \\ + ~ ... ~ + ~ \ text {some then number} _ {784} \ cdot \ text {picture value} _ {784} $$ display $$ </p><br>  Then it turns out that each neuron has 784 numbers, and all of these numbers: (number of neurons on this layer) x (number of neurons on the previous layer) = <math> </math> $ inline $ 100 \ times784 $ inline $   = 78 400 digits.  These numbers are usually called layer weights.  Each neuron will produce its own number and as a result we will get a 100-dimensional vector, and in fact we can write that this 100-dimensional vector is obtained by multiplying a 784-dimensional vector (our original image) by a matrix of weights <math> </math> $ inline $ 100 \ times784 $ inline $   : <br><p><math> </math> $$ display $$ \ boldsymbol {x} ^ {100} = W_ {100 \ times784} \ cdot \ boldsymbol {x} ^ {784} $$ display $$ </p><br><br>  Next, the resulting 100 numbers are passed on to the activation function ‚Äî some non-linear function ‚Äî that affects each number of series.  For example, sigmoid, hyperbolic tangent, ReLU and others.  The activation function is necessarily non-linear, otherwise the neural network will learn only simple transformations. <br><br><img src="https://habrastorage.org/webt/0j/rl/ba/0jrlbaqv0486mryhqj32u8et0cw.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Then the resulting data is again fed to the fully connected layer, but with a different number of neurons, and again to the activation function.  This happens several times.  The last layer of the network is the layer that gives the answer.  In this case, the answer is information about the number in the picture. <br><br><img src="https://habrastorage.org/webt/9f/73/q-/9f73q-feve3kb5k9u5fxvmz4kxk.png"><br><br>  During the training of the network, it is necessary that we know what figure is shown in the picture.  That is, to be marked up.  Then you can use another element - the error function.  She looks at the neural network's response and compares with the real answer.  Thanks to this neural network and learns. <br><br><h2>  General formulation of the problem </h2><br>  The whole dataset is a large tensor (we will call a multidimensional data array as a tensor) <math> </math> $ inline $ \ boldsymbol {X} = \ left [\ boldsymbol {x} _1, \ boldsymbol {x} _2, \ ldots, \ boldsymbol {x} _n \ right] $ inline $   where <math> </math> $ inline $ \ boldsymbol {x} _i $ inline $   - i-th object, for example, a picture, which is also a tensor.  For each object there is <math> </math> $ inline $ y_i $ inline $   - the correct answer on the i-th object.  In this case, the neural network can be represented as a certain function that accepts an object as input and outputs some answer on it: <br><p><math> </math> $$ display $$ F (\ boldsymbol {x} _i) = \ hat {y} _i $$ display $$ </p><br>  Now let's take a closer look at the function <math> </math> $ inline $ F (\ boldsymbol {x} _i) $ inline $   .  Since the neural network consists of layers, each individual layer is a function.  Which means <br><p><math> </math> $$ display $$ F (\ boldsymbol {x} _i) = f_k (f_ {k-1} (\ ldots (f_1 (\ boldsymbol {x} _i)))) = \ hat {y} _i $$ display $ $ </p><br>  That is, in the very first function - the first layer - a picture is fed in the form of a certain tensor.  Function <math> </math> $ inline $ f_1 $ inline $   gives some answer - also a tensor, but of a different dimension.  This tensor will be called an internal representation.  Now this internal representation is input to the function. <math> </math> $ inline $ f_2 $ inline $   , which gives its internal presentation.  And so on, while the function <math> </math> $ inline $ f_k $ inline $   - the last layer - will not give an answer <math> </math> $ inline $ \ hat {y} _i $ inline $   . <br><br>  Now, the task is to train the network - to make the network response coincide with the correct answer.  First you need to measure how wrong the neural network is.  This will be measured by the error function. <math> </math> $ inline $ L (\ hat {y} _i, y_i) $ inline $   .  And we impose restrictions: <br><br>  one. <math> </math> $ inline $ \ hat {y} _i \ xrightarrow {} y_i \ Rightarrow L (\ hat {y} _i, y_i) \ xrightarrow {} 0 $ inline $ <br>  2 <math> </math> $ inline $ \ exists ~ dL (\ hat {y} _i, y_i) $ inline $ <br>  3 <math> </math> $ inline $ L (\ hat {y} _i, y_i) \ geq 0 $ inline $ <br><br>  Restriction 2 impose on all functions of layers <math> </math> $ inline $ f_j $ inline $   - let them all be differentiable. <br><br>  Moreover, in fact (about this, I omitted) some of these functions depend on the parameters - the weights of the neural network - <math> </math> $ inline $ f_j (\ boldsymbol {x} _i | \ boldsymbol {\ omega} _j) $ inline $   .  And the whole idea is to pick such weights to <math> </math> $ inline $ \ hat {y} _i $ inline $   coincided with <math> </math> $ inline $ y_i $ inline $   on all objects dataset.  I note that the weight is not in all functions. <br><br>  So where are we staying?  All functions of the neural network are differentiable, the error function is also differentiable.  Recall one of the properties of the gradient - to show the direction of growth of the function.  We take advantage of this, restrictions 1 and 3, the fact that <br><p><math> </math> $$ display $$ L (F (\ boldsymbol {x} _i)) = L (f_k (f_ {k-1} (\ ldots (f_1 (\ boldsymbol {x} _i))))) = L (\ hat {y} _i) $$ display $$ </p><br>  and the fact that I can count partial derivatives and derivatives of a complex function.  Now there is everything you need in order to calculate <br><p><math> </math> $$ display $$ \ frac {\ partial L (F (\ boldsymbol {x} _i))} {\ partial \ boldsymbol {\ omega_j}} $$ display $$ </p><br>  for any i and j.  This partial derivative indicates the direction in which you want to change <math> </math> $ inline $ \ boldsymbol {\ omega_j} $ inline $   to increase <math> </math> $ inline $ L $ inline $   .  To reduce the need to take a step towards <math> </math> $ inline $ - \ frac {\ partial L (F (\ boldsymbol {x} _i))} {\ partial \ boldsymbol {\ omega_j}} $ inline $   nothing complicated. <br><br>  So the network learning process is built like this: several times in a cycle we go through the whole dataset (this is called an era), for each object we consider <math> </math> $ inline $ L (\ hat {y} _i, y_i) $ inline $   (this is called forward pass) and consider the partial derivative <math> </math> $ inline $ \ partial L $ inline $   for all scales <math> </math> $ inline $ \ boldsymbol {\ omega_j} $ inline $   then weights are updated (this is called backward pass). <br><br>  I note that I have not yet introduced any specific functions and layers.  If at this stage it is not entirely clear what to do with all this, I suggest that you continue reading - there will be more mathematics, but now it will come with examples. <br><br><h2>  Maths.  Part 2 (complicated) </h2><br><h3>  Error function </h3><br>  I will start at the end and output the error function for the classification problem.  For the regression problem, the output of the error function is well described in the book Deep Learning.  Immersion in the world of neural networks. <br><br>  For simplicity, there is a neural network (NN) that separates photos of cats from photos of dogs, and there is a set of photos of cats and dogs for which there is a correct answer. <math> </math> $ inline $ y_ {true} $ inline $   . <br><p><math> </math> $$ display $$ NN (picture | \ Omega) = y_ {pred} $$ display $$ </p><br>  All that I will do next is very similar to the maximum likelihood method.  Therefore, the main task is to find the likelihood function.  If we omit the details, then such a function that matches the prediction of the neural network and the correct answer, and if they match, gives a great value, if not, on the contrary.  The probability of a correct answer comes to mind with the given parameters: <br><p><math> </math> $$ display $$ p (y_ {pred} = y_ {true} | \ Omega) $$ display $$ </p><br>  And now we will make some trick that does not seem to follow from anywhere.  Let the neural network produce a response in the form of a two-dimensional vector, the sum of which is 1. The first element of this vector can be called the measure of confidence that the photo is a cat, and the second element the measure of confidence that the photo is a dog.  Yes, it's almost likelihood! <br><p><math> </math> $$ display $$ NN (picture | \ Omega) = \ left [\ begin {matrix} p_0 \\ p_1 \\\ end {matrix} \ right] $$ display $$ </p><br>  Now the likelihood function can be rewritten in the form: <br><p><math> </math> $$ display $$ p (y_ {pred} = y_ {true} | \ Omega) = p_ \ Omega (y_ {pred}) ^ t_ {0} * (1 - p_ \ Omega (y_ {pred})) ^ t_ {1} = \\ p_0 ^ {t_0} * p_1 ^ {t_1} $$ display $$ </p><br>  Where <math> </math> $ inline $ t_0, t_1 $ inline $   tags of the right class, for example, if <math> </math> $ inline $ y_ {true} = cat $ inline $   then <math> </math> $ inline $ t_0 == 1, t_1 == 0 $ inline $   , if a <math> </math> $ inline $ y_ {true} = dog $ inline $   then <math> </math> $ inline $ t_0 == 0, t_1 == 1 $ inline $   .  Thus, the probability of a class that should have been predicted by the neural network (but not necessarily predicted by it) is always considered.  Now it can be generalized to any number of classes (for example, m classes): <br><p><math> </math> $$ display $$ p (y_ {pred} = y_ {true} | \ Omega) = \ prod_0 ^ m p_i ^ {t_i} $$ display $$ </p><br>  However, in any dataset there are many objects (for example, N objects).  It would be desirable, that on each or the majority of objects the neural network would give the correct answer.  And for this you need to multiply the results of the formula above for each object from the dataset. <br><p><math> </math> $$ display $$ MaximumLikelyhood = \ prod_ {j = 0} ^ N \ prod_ {i = 0} ^ m p_ {i, j} ^ {t_ {i, j}} $$ display $$ </p><br>  To get good results, this function must be maximized.  But, first, to minimize steeper, because we have a stochastic gradient descent and all the buns for it - we simply assign a minus, and, secondly, it is difficult to work with a huge work - logarithmically. <br><p><math> </math> $$ display $$ CrossEntropyLoss = - \ sum \ limits_ {j = 0} ^ {N} \ sum \ limits_ {i = 0} ^ {m} t_ {i, j} \ cdot \ log (p_ {i, j }) $$ display $$ </p><br>  Wonderful!  The result is cross-entropy or, in the binary case, logloss.  This function is easy to read and even easier to differentiate: <br><p><math> </math> $$ display $$ \ frac {\ partial CrossEntropyLoss} {\ partial p_j} = - \ frac {\ boldsymbol {t_j}} {\ boldsymbol {p_ {j}}} $$ display $$ </p><br>  It is necessary to differentiate for the back-propagation error algorithm.  I note that the error function does not change the dimension of the vector.  If, as in the case of MNIST, the output is a 10-dimensional vector of answers, then when calculating the derivative we get a 10-dimensional vector of derivatives.  Another interesting thing is that only one element of the derivative will not be zero, where <math> </math> $ inline $ t_ {i, j} \ neq 0 $ inline $   , that is, with the right answer.  And the less likely the correct answer is predicted neural network on this object, the more it will be the error function. <br><br><h3>  Activation functions </h3><br>  At the output of each fully connected layer of the neural network, a nonlinear activation function must be present.  Without it, it is impossible to train a content neural network.  If you run ahead, the fully connected layer of the neural network is simply a multiplication of the input data by a matrix of weights.  In linear algebra, this is called a linear mapping ‚Äî some linear function.  The combination of linear functions is also a linear function.  But this means that such a function can approximate only linear functions.  Alas, this is not why neural networks are needed. <br><br><h4>  Softmax </h4><br>  Usually this function is used on the last layer of the network, since it turns the vector from the last layer into a vector of ‚Äúprobabilities‚Äù: each element of the vector lies from 0 to 1 and their sum is 1. It does not change the dimension of the vector. <br><p><math> </math> $$ display $$ Softmax_i = \ frac {e ^ {x_i}} {\ sum \ limits_ {j} e ^ {x_j}} $$ display $$ </p><br>  We now turn to the search for a derivative.  Because <math> </math> $ inline $ \ boldsymbol {x} $ inline $   Is a vector, and all its elements are always present in the denominator, then taking a derivative we get Jacobians: <br><p><math> </math> $$ display $$ J_ {Softmax} = \ begin {cases} x_i - x_i \ cdot x_j, i = j \\ - x_i \ cdot x_j, i \ neq j \ end {cases} $$ display $$ </p><br>  Now about backpropagation.  From the previous layer (usually the error function) comes the vector of derivatives <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   .  If <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   came from the error function on MNIST, <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   - 10-dimensional vector.  Then the Jacobian has a dimension of 10x10.  To obtain <math> </math> $ inline $ \ boldsymbol {dz_ {new}} $ inline $   which will go further to the previous layer (do not forget that we go from the end to the beginning of the network when the error propagates back), we need to multiply <math> </math> $ inline $ \ boldsymbol {dz} $ inline $   on <math> </math> $ inline $ J_ {Softmax} $ inline $   (row per column): <br><p><math> </math> $$ display $$ dz_ {new} = \ boldsymbol {dz} \ times J_ {Softmax} $$ display $$ </p><br>  The output is a 10-dimensional vector of derivatives <math> </math> $ inline $ \ boldsymbol {dz_ {new}} $ inline $   . <br><br><h4>  Relu </h4><br><p><math> </math> $$ display $$ ReLU (x) = \ begin {cases} x, x&gt; 0 \\ 0, x &lt;0 \ end {cases} $$ display $$ </p><br>  ReLU began to be massively used after 2011, when the article ‚ÄúDeep Sparse Rectifier Neural Networks‚Äù was published.  However, such a function was known before.  Such a concept as ‚Äúactivation force‚Äù is applicable to ReLU (for more information about this, read the book Deep Learning. Immersion in the World of Neural Networks).  But the main feature that makes ReLU more attractive than other activation functions is a simple calculation of the derivative: <br><p><math> </math> $$ display $$ d (ReLU (x)) = \ begin {cases} 1, x&gt; 0 \\ 0, x &lt;0 \ end {cases} $$ display $$ </p><br>  Thus, ReLU is computationally more efficient than other activation functions (sigmoid, hyperbolic tangent, etc.). <br><br><h3>  Full connected layer </h3><br>  Now is the time to discuss the fully connected layer.  The most important of all the others, because it is in this layer that all the weights are found that need to be adjusted in order for the neural network to work well.  A fully connected layer is simply a matrix of weights: <br><p><math> </math> $$ display $$ W = | w_ {i, j} | $$ display $$ </p><br>  A new internal representation is obtained when the weights matrix is ‚Äã‚Äãmultiplied by the input column: <br><p><math> </math> $$ display $$ \ boldsymbol {x} _ {new} = W \ cdot \ boldsymbol {x} $$ display $$ </p><br>  Where <math> </math> $ inline $ \ boldsymbol {x} $ inline $   has a size <math> </math> $ inline $ input \ _shape $ inline $   , but <math> </math> $ inline $ x_ {new} $ inline $   - <math> </math> $ inline $ output \ _shape $ inline $   .  For example, <math> </math> $ inline $ \ boldsymbol {x} $ inline $   - 784-dimensional vector, and <math> </math> $ inline $ \ boldsymbol {x} _ {new} $ inline $   - 100-dimensional vector, then the matrix W has a size of 100x784.  It turns out that on this layer is 100x784 = 78,400 weights. <br><br>  When back propagating an error, you need to take the derivative with respect to each weight of this matrix.  Simplify the problem and take only the derivative with respect to <math> </math> $ inline $ w_ {1,1} $ inline $   .  When multiplying the matrix and vector, the first element of the new vector <math> </math> $ inline $ \ boldsymbol {x} _ {new} $ inline $   equals <math> </math> $ inline $ x_ {new ~ 1} = w_ {1,1} \ cdot x_1 + ... + w_ {1,784} \ cdot x_ {784} $ inline $   and derivative <math> </math> $ inline $ x_ {new ~ 1} $ inline $   by <math> </math> $ inline $ w_ {1,1} $ inline $   will be just <math> </math> $ inline $ x_1 $ inline $   , you just need to take the derivative of the amount above.  Similarly, for all other scales.  But this is not yet an algorithm for back-propagating an error, as long as it is just a matrix of derivatives.  It is necessary to remember that from the next layer this (the error goes from the end to the beginning) comes a 100-dimensional gradient vector <math> </math> $ inline $ d \ boldsymbol {z} $ inline $   .  The first element of this vector <math> </math> $ inline $ dz_1 $ inline $   will be multiplied by all elements of the derivative matrix that ‚Äúparticipated‚Äù in creating <math> </math> $ inline $ x_ {new ~ 1} $ inline $   that is to <math> </math> $ inline $ x_1, x_2, ..., x_ {784} $ inline $   .  Similarly, the other elements.  If we translate it into the language of linear algebra, then it is written as: <br><p><math> </math> $$ display $$ \ frac {\ partial L} {\ partial W} = (d \ boldsymbol {z}, ~ dW) = \ left (\ begin {matrix} dz_ {1} \ cdot \ boldsymbol {x} \ \ ... \\ dz_ {100} \ cdot \ boldsymbol {x} \ end {matrix} \ right) _ {100} $$ display $$ </p><br>  The output is a matrix of 100x784. <br><img src="https://habrastorage.org/webt/1m/8_/hl/1m8_hljpr28gm3dikkgpsk4zss8.png"><br><br>  Now you need to understand what to transfer to the previous layer.  For this and for a greater understanding of what actually happened now, I want to write down what happened when taking the derivatives on this layer in a slightly different language, moving away from the specifics of ‚Äúwhat is multiplied by‚Äù to the functions (again). <br><br>  When I wanted to adjust the weights, I wanted to take the derivative of the error function on these weights: <math> </math> $ inline $ \ frac {\ partial L} {\ partial W} $ inline $   .  Above it was shown how to derive derivatives with respect to error functions and activation functions.  Therefore, we can consider the following case (in <math> </math> $ inline $ d \ boldsymbol {z} $ inline $   all derivatives of the error function and activation functions are already sitting): <br><p><math> </math> $$ display $$ \ frac {\ partial L} {\ partial W} = d \ boldsymbol {z} \ cdot \ frac {\ partial \ boldsymbol {x} _ {new} (W)} {\ partial W} $ $ display $$ </p><br>  This can be done because you can consider <math> </math> $ inline $ \ boldsymbol {x} _ {new} $ inline $   , as a function of W: <math> </math> $ inline $ \ boldsymbol {x} _ {new} = W \ cdot \ boldsymbol {x} $ inline $   . <br>  You can substitute this in the formula above: <br><br><p><math> </math> $$ display $$ \ frac {\ partial L} {\ partial W} = d \ boldsymbol {z} \ cdot \ frac {\ partial W \ cdot \ boldsymbol {x}} {\ partial W} = d \ boldsymbol { z} \ cdot E \ cdot \ boldsymbol {x} $$ display $$ </p><br>  Where E is the matrix consisting of units (NOT the identity matrix). <br><br>  Now when you need to take a derivative of the previous layer (even for simplicity of calculations, this will also be a fully connected layer, but in general it does not change anything), then you need to consider <math> </math> $ inline $ \ boldsymbol {x} $ inline $   as a function of the previous layer <math> </math> $ inline $ \ boldsymbol {x} (W_ {old}) $ inline $   : <br><p><math> </math> $$ display $$ \ begin {gathered} \ frac {\ partial L} {\ partial W_ {old}} = d \ boldsymbol {z} \ cdot \ frac {\ partial \ boldsymbol {x} _ {new} (W )} {\ partial W_ {old}} = d \ boldsymbol {z} \ cdot \ frac {\ partial W \ cdot \ boldsymbol {x} (W_ {old})} {\ partial W_ {old}} = \\ = d \ boldsymbol {z} \ cdot \ frac {\ partial W \ cdot W_ {old} \ cdot \ boldsymbol {x} _ {old}} {\ partial W_ {old}} = d \ boldsymbol {z} \ cdot W \ cdot E \ cdot \ boldsymbol {x} _ {old} = \\ = d \ boldsymbol {z} _ {new} \ cdot E \ cdot \ boldsymbol {x} _ {old} \ end {gathered} $$ display $$ </p><br>  Exactly <math> </math> $ inline $ d \ boldsymbol {z} _ {new} = d \ boldsymbol {z} \ cdot W $ inline $   and need to send to the previous layer. <br><br><h2>  Code </h2><br><blockquote>  First of all, this article is aimed at explaining the mathematics of neural networks.  I will give the code quite a bit of time. </blockquote><br>  This is an example of the implementation of the error function: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrossEntropy</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, y_true, y_hat)</span></span></span><span class="hljs-function">:</span></span> self.y_hat = y_hat self.y_true = y_true self.loss = -np.sum(self.y_true * np.log(y_hat)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.loss <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> dz = -self.y_true / self.y_hat <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dz</code> </pre> <br>  The class has methods for forward and backward pass.  At the time of a straight pass, an instance of the class saves the data inside the layer, and at the time of the back pass it uses them to calculate the gradient.  The rest of the layers are constructed in the same way.  This makes it possible to write a fully connected neural in this style: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MnistNet</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.d1_layer = Dense(<span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) self.a1_layer = ReLu() self.drop1_layer = Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) self.d2_layer = Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>) self.a2_layer = ReLu() self.drop2_layer = Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>) self.d3_layer = Dense(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) self.a3_layer = Softmax() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, train=True)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dz, learning_rate=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, mini_batch=True, update=False, len_mini_batch=None)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre><br>  The full code can be found <a href="https://github.com/iKintosh/dense_NN">here</a> . <br>  Also I advise to study this <a href="https://habr.com/ru/post/459822/">article on Habr√©</a> . <br><br><h2>  Conclusion </h2><br>  I hope I was able to explain and show that quite simple mathematics is behind neural networks and that it is absolutely not scary.  Nevertheless, for a deeper understanding, it is worth trying to write your own ‚Äúbicycle‚Äù.  Corrections and suggestions are happy to read in the comments. </div><p>Source: <a href="https://habr.com/ru/post/460589/">https://habr.com/ru/post/460589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460569/index.html">Writing software with the functionality of client-server utilities Windows, part 01</a></li>
<li><a href="../46057/index.html">What are you psychologically comfortable to enter as a login</a></li>
<li><a href="../460573/index.html">Google claims that ‚ÄúreCAPTCHA‚Äù does not abuse user data. Should I believe it?</a></li>
<li><a href="../460577/index.html">Long live the king: the cruel world of hierarchy in a pack of stray dogs</a></li>
<li><a href="../460587/index.html">Wireless module for capacitive soil moisture sensor on nRF52832</a></li>
<li><a href="../46059/index.html">Inner world OZON.ru</a></li>
<li><a href="../460591/index.html">Getting root on the router Tenda Nova MW6</a></li>
<li><a href="../460593/index.html">"Universal" in the development team: good or harm?</a></li>
<li><a href="../460599/index.html">News from the world of OpenStreetMap ‚Ññ 468 (07/02/2019-08.07.2019)</a></li>
<li><a href="../4606/index.html">Mozilla started creating Firefox 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>