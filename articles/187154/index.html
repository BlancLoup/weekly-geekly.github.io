<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Spaghetti article about spaghetti code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of an article by Michael O. Church - What is spaghetti code? 

 The easiest way for an epithet to lose its original meaning is to become t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Spaghetti article about spaghetti code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b65/907/741/b65907741112fc26d1dcb5df4dc2925f.png" alt="image"><br><br>  <i>Translation of an article by Michael O. Church - <a href="http://michaelochurch.wordpress.com/2012/08/15/what-is-spaghetti-code/">What is spaghetti code?</a></i> <br><br>  The easiest way for an epithet to lose its original meaning is to become too broad, to begin to mean a little more than just ‚ÄúI don‚Äôt like it‚Äù.  This refers to the term ‚Äúspaghetti code‚Äù, which people often use as a synonym for the concept of ‚Äúbad code‚Äù.  The problem is that not every bad code is a spaghetti code.  Spaghetti code is a particularly dangerous and specific kind of bad code, and its particular evil lies in the very way we develop software.  Why?  Because individual people rarely write spaghetti code on their own.  Rather, a certain style in the design makes it increasingly common with time.  In order to understand this, one has to consider the original context in which the notion of ‚Äúspaghetti code‚Äù was defined - the terrible (and mostly archaic) use of the <i>goto</i> operator. <br><a name="habracut"></a><br>  The <i>goto statement</i> is a simple and powerful mechanism for controlling the flow of program execution: moving to another point in the code.  This is what a compiled assembler program actually does in order to transfer control, even if the source code is written using more modern structures such as loops and functions.  Using <i>goto</i> , anyone can implement any control flow they need.  It is also difficult not to agree that at the moment <i>goto</i> is inappropriate for the source code of more modern programs.  Exceptions to this rule exist, but they are extremely small.  More modern languages ‚Äã‚Äãdo not even have this operator. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The <i>goto</i> operator makes the code difficult to read, because if the program management can jump from one place to another, then it is impossible to say with certainty what condition the program is in when executing a particular piece of code.  <i>Goto-based</i> programs cannot easily be broken down into components, because any point in the code can be a mole's norm to any other part of the code.  As a result, such code turns into ‚Äúeverything everywhere‚Äù and to understand even a separate part of the code, one must already understand all this confusion, and later it becomes impossible for large programs.  This can be easily compared with a bowl of spaghetti, where extracting even one macaroni includes navigation through a large ball of macaroni.  You can not just look at the plate and understand what kind of macaroni with which confused, instead you have to carefully unravel the whole tangle. <br><br>  Spaghetti code is a code where ‚Äúeverything is everywhere‚Äù and answer questions such as (a) where a certain part of the functionality is implemented, (b) where an object is created and how it happens and (c) how to determine the critical section for correction .  Just calling a couple of simple questions already want to look at the code, which will require an understanding of the entire program.  That is, the constant diagnostics of the source code is necessary in order to be able to answer the simplest questions.  This is the code that will remain a mystery for those who do not have enough discipline to follow each pasta from beginning to end.  This is the spaghetti code. <br><br>  What makes spaghetti code dangerous is that, unlike other types of bad code, this has become a common by-product of software entropy.  If the code has the correct modular structure, but some modules are of poor quality, people will fix the bad code if this is important to them.  Bad, erroneous or slow code can be fixed without changing interfaces.  To be honest, it is much easier to identify a bug in small, independent functions than in a giant bundle of code that is designed to solve too many problems.  Spaghetti code is evil, because (a) it is a very common subtype of bad code, (b) it is almost impossible to fix it without changing the functionality, which would be like crashing if there are people dependent on the old program behavior and (d) for reasons , which I will get to a little later, the emergence of such code cannot be prevented by the typical code verification processes. <br><br>  The reason I think it's important to separate the concept of ‚Äúspaghetti code‚Äù from the broader concept of ‚Äúbad code‚Äù is because a lot of what makes a code bad is too subjective.  A lot of conflicts and rudeness in <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581%25D0%25BE%25D0%25B2%25D0%25BC%25D0%25B5%25D1%2581%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D1%258B">collaboration software</a> (or in its absence) are the result of a predominantly male tendency to ridicule unqualified creativity (or its perception, and in terms of code, this is very often biased perception): to beat an alpha status candidate until do not stop pestering us with your incompetent ideas.  The problem with this pattern of behavior is that it is useless and rarely makes a person better in what he is trying to do.  There are also many disgusting people who define good and bad programmers on the basis of the visual component, so their definition of ‚Äúgood code‚Äù comes down to ‚Äúcode that looks the same as written by me‚Äù.  I feel that the problem of spaghetti code is better defined in scale than the big but too subjective problem of the ‚Äúbad code‚Äù.  We will never reach a consensus on the issue of ‚Äúspaces or tabs‚Äù, but we all agree that the spaghetti code is incomprehensible and useless.  Moreover, since spaghetti code is the most common and destructive type of bad code, most of the causes and cautions regarding this subtype can be extended to other categories of bad code. <br><br>  People usually use the concept of ‚Äúbad code‚Äù meaning ‚Äúdisgusting code‚Äù, but if it is possible to determine <i>why</i> they find a piece of code bad and disgusting and find out possible ways to fix it, then this is much better from most of the spaghetti code.  Spaghetti code is incomprehensible and often completely unrecoverable.  If you know <i>why you</i> hate a certain piece of code, then this code is already higher in quality than spaghetti code, since the latter is just a faceless nonsense. <br><br>  What causes spaghetti code?  For some time the main reason for the spaghetti code was the <i>goto</i> operator, but it lost its popularity and still remains in oblivion because it has ceased to be significant.  Now the reason is something completely different, namely, modern bydloizatsiya object-oriented programming.  Inheritance plays a special role here, and, as a result, not thought-out abstractions: the use of parametrization characteristic of a particular class, implying a single use case, or the addition of unnecessary parameters.  I admit that the statement that OOP, as it is now practiced, is a spaghetti code, is not an incontestable point of view.  Just as in due time, the harm of using the <i>goto</i> operator was not considered indisputable. <br><br>  One of the biggest problems of comparison software (be it a comparison of approaches, techniques, languages, or platforms) is that most comparisons focus on simple examples.  Twenty lines of code do not reveal anything sinister, unless these lines are written with intentional vile intent.  A twenty-line program written using <i>goto</i> is generally quite acceptable, and may even be easier than writing without using it.  On twenty lines, a set of step-by-step instructions with some explicit control transfer is a very natural way of presenting a program.  For static programs (for example, of a platonic form, which will never be changed and will not receive maintenance), which can be read in one go, this structure may simply be different.  But already on twenty thousand lines of the program with <i>goto</i> become more than incomprehensible.  Twenty thousand lines of a program with <i>goto</i> lend itself to such a number of hacks, extensions and optimizations that the original vision of building things is simply lost.  And the fact that a program can end up in any part of the code ‚Äúfrom anywhere‚Äù means that to safely change the code you need to be confidently aware of the number of these ‚Äúfrom anywhere‚Äù.  Everything is everywhere.  This not only makes the code difficult to understand, but also means that every modification of the code is likely to make it worse, due to unforeseen consequences.  Over time, software becomes ‚Äúbiological.‚Äù  By this term, I mean that it develops a behavior model in which all components are independent, but some modules may be hidden. <br><br>  The <i>goto</i> operator did not take place as a programming language construct, because it gave rise to a lot of problems associated with the constant diagnostics of a program written using it.  Less favored, but more narrowly specialized structures, such as procedures, functions, and well-defined data structures, received greater favor.  For the only case where people needed global flow control (error handling), exceptions were developed.  It was a transition from extreme universality and abstraction of programs written using <i>goto</i> to the concreteness and specificity of parts (such as procedures) of solving specific problems.  In non-structural programming, you can write a Great Program that does a lot of things: it adds new possibilities for every taste and changes the course of things as you need.  It should not solve some kind of ‚Äúproblem‚Äù (it's so boring ...), but it can be a meta-framework with a built-in interpreter.  Structural programming encourages people to break down their programs into specific parts that solve one problem and, if possible, make these parts reusable.  This principle became the basis for the Unix systems philosophy (do one thing and do it well) and functional programming (achieve the simplicity of determining exact mathematical semantics, avoiding global states). <br><br>  Another thing I want to say about the <i>goto statement</i> is that it is rarely needed as a primitive language level.  You can achieve the same effect using the while loop - a counter variable declared outside the loop and used by the switch-case construct, either increases (step), continuing the loop, or is reset ( <i>goto</i> ).  This can, if you wish, be expanded into one giant program that will run as one such cycle, but such code is never written.  The fact that this is almost never done indicates the fact that the use of <i>goto</i> is rarely required.  Thus, structural programming indicates insanity, to which some descend when trying to control highly non-local flows. <br><br>  Nevertheless, there was a time when the rejection of <i>goto</i> was an extremely controversial issue, and all these ideas of structured programming looked like nonsense.  The objection sounded like this: why use functions and procedures if the <i>goto</i> operator is much more powerful? <br><br>  Similarly, why use <a href="http://dsorokin.blogspot.com/2013/03/blog-post.html">referential transparent functions</a> and immutable records if objects are much more powerful?  An object can eventually have a <i>run</i> or <i>call</i> or <i>apply</i> method, so it can be a function.  It can also have static or constant fields and be a record.  But at the same time, it can do much more: an object can have initializers and finalizers and open recursions and fifty methods if someone makes such a decision.  So what's the fuss about this meaningless structured programming, which means that people will create their programs from constructs that are much less powerful, such as writing, whose fields never change and whose classes do not contain initialization magic? <br><br>  The answer is that the availability of power is not always good.  <i>Power</i> in programming is an advantage for the person who writes the code, and not for the person who then reads it, but the service (for example, the need to understand the code) starts from about 2000 lines or from six weeks, but objectively on a project by more than one developer.  On real projects, no one will be engaged only in writing code.  Often we have to read both our own code and the code of other people.  An unreadable code is simply unacceptable, and is allowed only due to the fact that there is a lot of it, and also because the ‚Äúbest practices‚Äù of the PLO adopted in many software companies generate it.  A more ‚Äúpowerful‚Äù abstraction is more general and, therefore, less specific, which means that it is difficult for those who read such code to determine exactly what it is used for.  But people who single-handedly write code often remain fairly straightforward - a powerful abstraction <i>can have</i> 18 possible uses, but only one of them is actually involved.  In this case, there is a kind of individual vision (although usually not documented) that helps to avoid confusion.  The danger arises when a person not dedicated to this vision begins to modify the code.  Often, these modifications are hacks, which do not explicitly imply another of the remaining 17 uses.  This, as a rule, leads to contradictions, and they in turn lead to errors.  Unfortunately, the people responsible for correcting these bugs have an even smaller idea of ‚Äã‚Äãthe original vision that lies behind the code, and their modifications add even more hacks.  Some patches may occur, but the overall quality of the code is reduced.  This is the process of ‚Äúspaghettizing‚Äù code.  Nobody just sits down like that and starts writing spaghetti code for himself.  This happens by gradually ‚Äústretching‚Äù the process and almost always several developers are responsible for it.  In software, ‚Äústeep slopes‚Äù are really real and the fall can be very sudden. <br><br>  Object-oriented programming, originally designed to prevent spaghetti code, was (due to the use of ‚Äúdesign patterns‚Äù without a complete understanding) one of its worst sources.  The ‚Äúobject‚Äù can easily combine the code and data in it, while having any number of interfaces, while the class can freely spawn subclasses throughout the program.  Object-oriented programming harbors great power, and with disciplined use, it can be very effective.  But most programmers can't handle it, and over time their code turns into spaghetti. <br><br>  One of the problems of spaghetti code is that it is formed gradually, which makes it difficult to detect in the code verification process, because every change that leads to ‚Äúspaghettizing‚Äù outside the big picture may look purely positive.  The advantage is that the changes the manager or client needed ‚Äújust yesterday‚Äù appear in the code, and on the other hand, it all looks like a moderate amount of additional difficulties.  Even in the Dark Times, nobody <i>went to goto</i> and did not say: ‚ÄúI am going to write a completely incomprehensible program with 40 <i>goto</i> operators pointing to one point of code.‚Äù The confusion accumulated gradually, while the development of the program was transferred from one person to another.  The same is true for object-oriented spaghetti.  There is no concrete transition point from a clean initial design to an incomprehensible spaghetti code.  This happens over time, when people abuse the power of the PLO to push incomprehensible hacks, which would not be necessary if everyone understood how the programs they modify work, and if clearer (albeit less powerful) abstractions were used .  All this means that the blame for ‚Äúspaghettizing‚Äù lies on everyone and not at the same time: any single developer can declare with confidence that it was not his changes that sent the code straight to hell.  That is why large software manufacturers (as opposed to the minimalist philosophy of Unix-systems), as a rule, adhere to the following policy: no one knows who is really to blame for something. <br><br>  Additional code checks are great for detecting obviously bad practices, such as mixing spaces and tabs, or too long lines.  Therefore, the more cosmetic aspects of the ‚Äúbad code‚Äù are less interesting (using the definition of ‚Äúinteresting‚Äù as a synonym for ‚Äúalarming‚Äù) than the spaghetti code.  We already know how to deal with them with additional code checks.  We can even configure our continuous integration servers to reject this code.  As for the spaghetti code, which has no clear definition, it is not so easy to do, if not impossible at all.  A complete check of all program code is intended to determine it, but I have seen very few companies willing to invest the time and resources necessary for such checks.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the long term (10 years or more), I think it is almost impossible, with the exception of teams that develop vital or critical software that provides a high level of discipline for an indefinite period. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The answer, I think, is that the Big Code simply does not work. Dynamic typing ‚Äúfalls‚Äù in large programs, and static typing fails in another way. All this is true for object-oriented programming, imperative programming, and to a lesser, but still noticeable degree for functional programming (manifested in an increase in parameters placed in streams). Problems with ‚Äú </font><i><font style="vertical-align: inherit;">goto</font></i><font style="vertical-align: inherit;"> ‚Äù</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄùWas not, since its nature allowed the code to become the Big Code very quickly. But the cruel reality is that the Big Code is not a ‚Äúsilver bullet‚Äù. Large programs simply become incomprehensible. Complexity and large size are not ‚Äúsometimes not desirable‚Äù, on the contrary - they are always dangerous. People like Steve Yegge </font></font><a href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have long understood this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's why I think the Unix systems philosophy is inherently correct: programs should not be unclear swampy things that grow in scale and never become complete. The program should solve one problem and do it well. If it becomes large and cumbersome, it must be disassembled into separate parts: libraries and scripts, executable files and data. Ambitious software projects should not have an all-or-nothing structure, as separate programs, because each programming paradigm or set of tools just breaks into this. Instead, such projects should be structured as systems and much attention should be paid to this. This means that you need to pay attention to the resiliency, interchangeability of parts and communication protocols. It requires more discipline,rather than developing a randomly expanding big program, but worth it. In addition to the obvious advantages of a cleaner, more convenient code, it adds what people actually read this code, rather than adding thoughtlessly to hacks, not understanding what it actually does. This means that they are improving as developers over time and the quality of their code becomes better in the long run.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ironically, PLO was originally intended to promote something like minimal software. The original vision of the PLO did not imply that people should sit down and write huge, complex objects, but it meant that they should use the PLO </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when complexity is inevitable. Examples of successful use in this area are databases. People need relational databases in terms of transaction integrity, durability, availability, concurrency and performance, so complexity is a must. The databases are incredibly complex, and I can say with confidence that it took decades for the computer world to achieve their worthy realization, regardless of the huge financial incentives to make it faster. But at the same time, when a database can be complicated (as needed), the interface for using it is much simpler (SQL). You do not specify which search strategy the database should use, you simply write SELECT (describe what the user wants to receive,and not how to get it) and let the query optimizer take care of it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I note that databases are a kind of exception in my dislike of the Big Code. Their complexity is a well-understood need, and there are people willing to devote their careers exclusively to their study. But people do not have to spend their careers on understanding typical business applications. And they will not. They will refuse it, and will transfer the code to other hands, thereby accelerating its spaghettizing.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why Big Code? Why does it exist, despite its pitfalls? And why do programmers so quickly start using OOP tools without asking if their power and complexity are really needed? I think there are several reasons. One of them is laziness: people will give preference to the study of one big general-purpose abstraction, rather than take the time to master highly specific abstractions and situations in which they need to be applied. Why would anyone study linked lists and arrays or all of these incomprehensible structures, such as trees, if we already have an ArrayList? Why know how the program uses reference transparent functions if objects can do the same job (and even much more)? Why learn to use the command line,if modern IDEs can protect you from being able to see the damn thing even once in your life? Why learn new programming languages ‚Äã‚Äãif Java is already Turing complete? The Big Code arises from the predominance of the following position: why break a large program into modules, if modern compilers can easily cope with hundreds of thousands of lines of code? If computers don't care when they encounter Big Code, why should we care about this?then why should we care about this?then why should we care about this?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if closer to the point, then I believe that all this is nothing but arrogance with a little bit of greed. The Big Code comes from the belief that a software project will be so popular and successful that people will endure its complexity ‚Äî ideas in the manner that its own subject-oriented programming language (DSL) will be as huge as C or SQL. It also appears due to the lack of willingness to recognize the problem as solved, and the program is completed even when a significant part of the work has already been completed. It also emerges from the fallacies of what programming really is. Instead of solving existing well-defined problems and getting out of the way, as programs designed for minimalist methodology do, Big Code programs do much more than necessary.Such projects are often inclusive and with impractical ‚Äúvision‚Äù, which implies the creation of software for the sake of software. This introduces confusion, because the ‚Äúvision‚Äù in the corporate environment, as a rule, quickly becomes a policy. Big Code programs are always a reflection of the environment that spawned them (</font></font><a href="http://en.wikipedia.org/wiki/Conway%2527s_law"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conway's law</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and they are always more like a collection of parodies and specific humor, rather than the universal language of mathematics and computer science.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another problem in this play. Managers simply adore the Big Code, because when a programmer-program ratio becomes many-to-one instead of one-to-many, efforts can be tracked and the number of staff can be determined. Minimalistic software methodologies are excellent, but they require the trust of programmers in their ability to distribute their time properly for more than one task, and most tyrannosaurus managers feel uncomfortable in doing so. The Big Code doesn't really work, but it gives managers a sense of control over the distribution of technical effort. He also accompanies the mixing of size and success, which managers often do (as evidenced by the question on the interview for managers ‚ÄúHow many subordinates did you have?‚Äù).Long-term spaghettification, which is the result of the Big Code, rarely becomes a problem for such managers. They do not see how this happens, and often leave the project before it becomes a problem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summing up, it is safe to say that the spaghetti code is a bad code, but not all bad code is a spaghetti code. </font><font style="vertical-align: inherit;">Spaghetti code is a product of industrial programming, which is often (but not always) the result of passing code through a large number of hands, and an inevitable consequence of the methodology for developing large software products and the result of object-oriented programming that comes from defective management processes. </font><font style="vertical-align: inherit;">The antidote to spaghetti code is aggressive and active refactoring and making efforts to keep the program compact, efficient, with clean source code and, most importantly, consistent. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the translator: The article is quite extensive, so I will be grateful if you inform the PM of any inaccuracies or errors.</font></font></i> </div><p>Source: <a href="https://habr.com/ru/post/187154/">https://habr.com/ru/post/187154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187138/index.html">Highscreen Omega Q - Budget Quad</a></li>
<li><a href="../187142/index.html">Development of IntelliJ IDEA plugin. Part 2</a></li>
<li><a href="../187146/index.html">RThrust - automatic testing system for BC motors</a></li>
<li><a href="../187148/index.html">Comparison of two GPS Data Loggers</a></li>
<li><a href="../187152/index.html">Newcomer</a></li>
<li><a href="../187158/index.html">Russian Open Quadcopter Championship</a></li>
<li><a href="../187162/index.html">Just5 Brick Presentation: How I Met Thomofon + Answers to Habroid Questions</a></li>
<li><a href="../187164/index.html">HttpRequest - a library for easy work with the HTTP protocol</a></li>
<li><a href="../187166/index.html">Sound transmission through pictures in social networks</a></li>
<li><a href="../187168/index.html">Small office scan optimization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>