<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operating Systems: Three Easy Pieces. Part 4: Scheduler Introduction (Translation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction to operating systems 
 Hi, Habr! I want to bring to your attention a series of articles-translations of one interesting in my opinion lit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operating Systems: Three Easy Pieces. Part 4: Scheduler Introduction (Translation)</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction to operating systems </h1><br>  Hi, Habr!  I want to bring to your attention a series of articles-translations of one interesting in my opinion literature - OSTEP.  This material takes a rather in-depth look at the work of unix-like operating systems, namely, working with processes, various schedulers, memory, and other similar components that make up a modern OS.  The original of all materials you can see <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">here</a> .  Please note that the translation was made unprofessionally (fairly freely), but I hope I saved the general meaning. <br><br>  Laboratory work on this subject can be found here: <br><br><ul><li>  <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html">original</a> </li><li>  <a href="https://github.com/remzi-arpacidusseau/ostep-code">original</a> </li><li>  <a href="https://github.com/bykvaadm/OS/tree/master/ostep">my personal adaptation</a> </li></ul><br>  Other parts: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/en/post/446340/">Part 1: Intro</a> </li><li>  <a href="https://habr.com/en/post/446866/">Part 2: Abstraction: the process</a> </li><li>  <a href="https://habr.com/en/post/447182/">Part 3: Introduction to the Process API</a> </li><li>  <a href="https://habr.com/en/post/449026/">Part 4: Scheduler Introduction</a> </li></ul><br>  And you can also look to me on the channel in the <a href="https://t.me/bykvaadm">telegram</a> =) <br><a name="habracut"></a><br><h2>  Scheduler Introduction </h2><br>  <u>The crux of the problem: How to develop a policy planner</u> <u><br></u>  <u>How should basic scheduler frameworks be developed?</u>  <u>What should be the key assumptions?</u>  <u>What metrics are important?</u>  <u>What are the basic techniques used in early computing systems?</u> <br><br><h3>  Workload assumptions </h3><br>  Before discussing possible policies, let's start with a few simplifying digressions about the processes running in the system, which are collectively called <b>workload</b> .  Defining the workload as a critical part of building a policy and the more you know about the workload, the better the quality policy you can write. <br><br>  We make the following assumptions about the processes running on the system, sometimes also called <b>jobs</b> .  Practically all these assumptions are not realistic, but are necessary for the development of thought. <br><br><ol><li>  Each task is running the same amount of time. </li><li>  All tasks are set simultaneously </li><li>  The task is working until its completion, </li><li>  All tasks use only CPU, </li><li>  The time of each task is known. </li></ol><br><h3>  Scheduler Metrics </h3><br>  In addition to some load assumptions, some other tool for comparing different scheduling policies is needed: scheduler metrics.  A metric is just some measure of something.  There are a number of metrics that can be used to compare planners. <br><br>  For example, we will use a metric called turnaround time.  The task turnaround time is defined as the difference between the task completion time and the task arrival time in the system. <br><br>  <u>Tturnaround = Tcompletion ‚àí Tarrival</u> <br><br>  Since we assumed that all tasks arrived at the same time, Ta = 0 and thus Tt = Tc.  This value will naturally change when we change the above assumptions. <br><br>  Another metric is <b>fairness</b> .  Productivity and honesty are often opposing characteristics in planning.  For example, the scheduler can optimize performance, but at the cost of waiting for other tasks to run, thus honesty is reduced. <br><br><h3>  FIRST IN FIRST OUT (FIFO) </h3><br>  The most basic algorithm that we can implement is called FIFO or <b>first come (in), first served (out)</b> .  This algorithm has several advantages: it is very simple to implement and it fits all our assumptions, doing the job quite well. <br><br>  Consider a simple example.  Suppose 3 tasks were set at the same time.  But suppose that task A came a bit earlier than all the others, so the list of execution will be earlier than the others, just like B with respect to B. Suppose that each of them will be executed for 10 seconds.  What would be the average time to complete these tasks? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a43/acd/1b4a43acd8a0f18c24bbdd831529bbda.jpg" alt="image"><br><br>  By counting the values ‚Äã‚Äã- 10 + 20 + 30 and dividing by 3, we get the average program execution time equal to 20 seconds. <br><br>  Now we will try to change our assumptions.  In particular, assumption 1 and thus we will no longer assume that each task is executed the same amount of time.  How will the FIFO show itself this time? <br><br>  As it turns out, the different execution times of the tasks extremely negatively affect the productivity of the FIFO algorithm.  Suppose that task A is executed 100 seconds, while B and C will still be 10 each. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/bee/3fe/a7abee3fefd7a0cf481d0322f40e732f.jpg" alt="image"><br><br>  As can be seen from the figure, the average time for the system is (100 + 110 + 120) / 3 = 110.  This effect is called <b>the convoy effect</b> , when some short-term consumers of any resource will stand in line after a heavy consumer.  It‚Äôs like a line at a grocery store when you‚Äôre in front of you with a full cart.  The best solution is to try to change the cashier or relax and breathe deeply. <br><br><h3>  Shortest job first </h3><br>  Is it possible to somehow solve a similar situation with heavy processes?  Of course.  Another type of scheduling is called <b>Shortest Job First</b> (SJF).  Its algorithm is also quite primitive - as the name implies, the shortest tasks will be launched first one by one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/feb/207/778feb20723fa2d019620b97d27f2830.jpg" alt="image"><br><br>  In this example, the result of running the same processes will be an improvement in the average turnover time of programs and it will be <b>50 instead of 110</b> , which is almost 2 times better. <br><br>  Thus, for the given assumption that all tasks arrive at the same time, the SJF algorithm seems to be the most optimal algorithm.  However, our assumptions still do not seem realistic.  This time we change Assumption 2 and this time imagine that tasks can be at any time, and not all at the same time.  What problems can it cause? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/6df/332/4846df332de36b42bf891e167ef3f751.jpg" alt="image"><br><br>  Imagine that task A (100s) arrives at the very first and starts to be executed.  At time t = 10, tasks B, C arrive, each of which will take 10 seconds.  Thus, the average execution time is (100+ (110-10) + (120-10)) \ 3 = 103. What could the planner do to improve the situation? <br><br><h3>  Shortest Time-to-Completion First (STCF) </h3><br>  In order to improve the situation, we omit assumption 3 that the program is up and running until completion.  In addition, we will need hardware support and, as you might guess, we will use a <b>timer</b> to interrupt a running task and <b>switch contexts</b> .  Thus, the scheduler can do something at the moment of receipt of tasks B, C - stop the execution of task A and put tasks B and C into processing and after they finish continue the process A. Such a scheduler is called <b>STCF</b> or <b>Preemptive Job First</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0eb/900/a1f/0eb900a1f8b96a0952061727037faf4f.jpg" alt="image"><br><br>  The result of this scheduler will be the following result: ((120-0) + (20-10) + (30-10)) / 3 = 50.  Thus, such a scheduler becomes even more optimal for our tasks. <br><br><h3>  Metric Response Time (Response Time) </h3><br>  Thus, if we know the running time of the tasks and the fact that these tasks use only the CPU, STCF will be the best solution.  And once in early times, these algorithms worked and pretty well.  However, now the user spends most of the time behind the terminal and expects productive interactive interaction from it.  Thus, a new metric was born - <b>the response</b> time. <br><br>  The response time is calculated as follows: <br><br>  <u>Tresponse = Tfirstrun ‚àí Tarrival</u> <br><br>  Thus, for the previous example, the response time will be: A = 0, B = 0, B = 10 (abg = 3.33). <br><br>  And the STCF algorithm turns out to be not so good in a situation when 3 tasks arrive at the same time - it will have to wait until the small tasks are completely completed.  Thus, the algorithm is good for the turnover time metric, but bad for the interactivity metric.  Imagine that sitting at the terminal in an attempt to print characters in the editor you would have to wait more than 10 seconds, because some other task takes the processor.  This is not very nice. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="image"><br><br>  So we face another problem - how can we build a scheduler that is sensitive to response time? <br><br><h3>  Round robin </h3><br>  To solve this problem, a <b>round robin</b> (RR) algorithm was developed.  The basic idea is quite simple: instead of starting tasks to complete, we will run the task for a certain period of time (called a time slice) and then switch to another task from the queue.  The algorithm repeats its work until all tasks are completed.  At the same time, the program must be a multiple of the time after which the timer will interrupt the process.  For example, if a timer interrupts the process every x = 10ms, then the size of the process execution window should be a multiple of 10 and be 10.20 or x * 10. <br><br>  Consider an example: ABC tasks arrive simultaneously in the system and each of them wants to work for 5 seconds.  The SJF algorithm will perform each task to the end, before running another.  In contrast, the RR algorithm with the launch window = 1c will go through the tasks as follows (Fig. 4.3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="image"><br>  <i>(SJF Again (Bad for Response Time)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e40/351/12e/e4035112ea5d27958b0e099ed19a6c41.jpg" alt="image"><br>  <i>(Round Robin (Good For Response Time)</i> <br><br>  The average response time for the algorithm RR (0 + 1 + 2) / 3 = 1, whereas for SJF (0 + 5 + 10) / 3 = 5. <br><br>  It is logical to assume that the time window is a very important parameter for RR, the smaller it is, the higher the response time.  However, it cannot be made too small, since the time for context switching will also play its part in overall performance.  Thus, the timing of the execution window is set by the OS architect and depends on the tasks that it plans to perform.  Context switching is not the only service operation that spends time - the running program still has many things to operate, for example, different caches and with each switch it is necessary to save and restore this environment, which can also take a lot of time. <br><br>  RR is a great scheduler if it were only a response time metric.  But how will the task time metric behave with this algorithm?  Consider the example above when the operating time is A, B, B = 5s and arrive at the same time.  Task A will end at 13, B at 14, C at 15 s and the average turnaround time will be 14 s.  Thus, RR is the worst algorithm for the turnover metric. <br><br>  More generally, any RR-type algorithm is fair, it divides the work on the CPU equally between all processes.  And thus, these metrics are constantly in conflict with each other. <br><br>  Thereby, we have several opposed algorithms and there are still a few assumptions - that the task time is known and that the task only uses the CPU. <br><br><h3>  Mixing with I / O </h3><br>  First of all, we remove assumption 4 that the process only uses the CPU, naturally this is not the case, and processes can also apply to other equipment. <br><br>  When a process requests an I / O operation, the process goes to the blocked state, waiting for the I / O to complete.  If I / O is sent to the hard disk, such an operation can take up to several ms or longer, and the processor will be idle at this moment.  At this time, the scheduler may take the processor by any other process.  The next decision that the scheduler has to make is when the process completes its I / O.  When this happens, an interrupt will occur and the OS will transfer the process that caused the I / O to the ready state. <br><br>  Consider an example of several tasks.  Each of them needs 50ms of CPU time.  However, the first one will go to I / O every 10ms (which will also be executed by 10ms).  Process B simply uses a 50ms processor without I / O. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50a/488/cae/50a488cae4476f65002df9ea966f9ef7.jpg" alt="image"><br><br>  In this example, we will use the STCF scheduler.  How will the scheduler behave if you run a process like A on it?  He will proceed as follows - first, process A will fully complete, and then process B. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/f5e/326/151f5e326437859d65d29541dbe0e94f.jpg" alt="image"><br><br>  The traditional approach to solving this problem is to interpret every 10 ms subtask of process A as a separate task.  Thus, when starting with the STJF algorithm, the choice between the 50-ms task and the 10-ms task is obvious.  Then when subtask A is complete, process B and I / O will start.  After completing the I / O, it will be decided to restart the 10-ms process A instead of the process B. Thus, it is possible to implement an overlap when the CPU is used by another process while the first waits for I / O.  And as a result, the system is better utilized - at the moment when interactive processes are waiting for I / O, other processes can run on the processor. <br><br><h3>  The oracle is no more </h3><br>  Now let's try to get rid of the assumption that the time of the task is known.  This is generally the worst and unrealistic assumption from the entire list.  In fact, in average statistical OSs, the OS itself usually knows very little about the execution time of tasks, so how can we build a scheduler without knowing how long the task will be executed?  Perhaps we could use some RR principles to solve this problem? <br><br><h3>  Total </h3><br>  We reviewed the basic ideas of scheduling tasks and reviewed 2 families of planners.  The first one starts the shortest task at the beginning and thus increases the turnover time, the second one is torn between all tasks equally, increasing the response time.  Both algorithms are bad where the algorithms of the other family are good.  We also looked at how parallel use of CPU and I / O can improve performance, but never solved the problem with OS clairvoyance.  And in the next lesson we will look at a planner who looks to the near past and tries to predict the future.  And it is called multi-level feedback queue. </div><p>Source: <a href="https://habr.com/ru/post/449026/">https://habr.com/ru/post/449026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449008/index.html">Logging HTTP requests in Spring Boot using Reels</a></li>
<li><a href="../449014/index.html">Promoting Ethereum DAPP</a></li>
<li><a href="../449016/index.html">Optical file system steganography</a></li>
<li><a href="../449022/index.html">Analysis of the CUBA Platform code using PVS-Studio</a></li>
<li><a href="../449024/index.html">"The Mystery of the Third Planet" with improved neural networks graphics</a></li>
<li><a href="../449028/index.html">Anger, bargaining and depression when working with InfluxDB</a></li>
<li><a href="../449036/index.html">And again the wolf in sheep's clothing</a></li>
<li><a href="../449038/index.html">Manage Docker Containers in Go</a></li>
<li><a href="../449040/index.html">Security Week 17: Supply Chain Attacks</a></li>
<li><a href="../449042/index.html">DevDays'19 Hackathon (Part 1): Diary with Recommendations, Walk Generator and Liquid Democracy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>