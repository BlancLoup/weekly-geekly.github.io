<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DevOps in Development: Automating Web Application Code Writing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear Habrazhiteli! 

 Today DevOps is on the wave of success. Practically at any conference devoted to automation, one can hear from the spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DevOps in Development: Automating Web Application Code Writing</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear Habrazhiteli! <br><br>  Today DevOps is on the wave of success.  Practically at any conference devoted to automation, one can hear from the speaker that ‚Äúwe have implemented DevOps here and there, applied this and that, it became much easier to conduct projects, etc., etc.‚Äù.  And this is commendable.  But, as a rule, the introduction of DevOps in many companies ends at the automation stage of IT Operations, and very few people talk about the introduction of DevOps directly into the development process itself. <br><br>  I would like to correct this little misunderstanding.  DevOps in development can come through the formalization of the code base, for example, when writing a GUI for the REST API. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I would like to share with you the solution of a non-standard case that our company faced - we had the opportunity to automate the creation of a web application interface.  I will tell you about how we came to this task and what we used to solve it.  We do not believe that our approach is the only correct one, but we like it very much. <br><br>  I hope this material will be interesting and useful to you. <br><br>  Well, let's start! <br><a name="habracut"></a><br><h2>  Prehistory </h2><br>  This story began about a year ago: it was a beautiful summer day and our development department was engaged in creating the next web application.  On the agenda was the task of introducing a new feature into the application - it was necessary to add the ability to create custom hooks. <br><br><img src="https://habrastorage.org/webt/qi/lf/ot/qilfotaamoa_fpuerti3np8chlm.png" alt="The process of adding a new feature on the old architecture"><br><br>  At that time, the architecture of our web application was built in such a way that in order to implement a new feature, we had to do the following: <br><br><ol><li>  On the back-end: to create a model for a new entity (hooks), describe the fields of this model, describe all the logic of actions (actions) that the model can perform, etc. <br></li><li>  On the front-end: to create a presentation class corresponding to the new model in the API, manually describe all the fields that this model has, add all types of actions that the given presentation can launch, etc. <br></li></ol><br>  It turns out that we were simultaneously in two places at once, it was necessary to make very similar changes in the code, one way or another, ‚Äúduplicating‚Äù each other.  And this, as you know, is not good, because with further changes, developers would need to make edits in two places at the same time. <br><br>  Suppose we need to change the type of the field ‚Äúname‚Äù from ‚Äústring‚Äù to ‚Äútextarea‚Äù.  To do this, we will need to make this edit in the model code on the server, and then make similar changes in the presentation code on the client. <br><br>  Is it too complicated? <br><br>  Previously, we put up with this fact, since many applications were not very large and the approach with ‚Äúduplication‚Äù of code on the server and on the client was the place to be.  But on that same summer day, before the start of the introduction of a new feature, something clicked inside us, and we realized that it was impossible to continue this work.  The current approach was very unreasonable and demanded a lot of time and labor.  In addition, ‚Äúduplication‚Äù of the code on the back-end and the front-end could lead to unexpected bugs in the future: developers could make changes on the server and forget to make similar changes on the client, and then everything would not go according to plan. <br><br><h2>  How to avoid code duplication?  Search for a solution </h2><br>  We began to wonder how we can optimize the process of introducing new features. <br><br>  We asked ourselves the question: ‚ÄúCan we now avoid duplicating changes in the model‚Äôs presentation on the front-end, after any change in its structure on the back-end?‚Äù <br><br>  We thought and answered: "No, we can not." <br><br>  Then we asked ourselves another question: ‚ÄúOkay, what is the reason for this duplication of code?‚Äù <br><br>  And here it hit us: the problem, in fact, is that our front-end does not receive data on the current API structure.  The front-end does not know anything about the models that exist in the API, until we ourselves inform him about this. <br><br>  And then we had an idea: what if we build the architecture of the application so that: <br><br><ul><li>  The front-end received from the API not only the data of the models, but also the structure of these models; </li><li>  The front-end dynamically formed views based on the structure of the models; </li><li>  Any change in the structure of the API is automatically displayed on the front-end. </li></ul><br>  Introduction of a new feature will take much less time, since it will only require changes on the back-end side, and the front-end will automatically pick up everything and present it to the user properly. <br><br><h2>  Universality of new architecture </h2><br>  And then, we decided to think a little more widely: is the new architecture suitable only for our current application, or can we use it somewhere else? <br><br><img src="https://habrastorage.org/webt/og/ay/ju/ogayjuenpbmvwxxlrxpm09banza.png" alt="Common for many web applications features"><br><br>  After all, one way or another, almost all applications have a part of the similar functionality: <br><br><ul><li>  there are users for almost all applications, and therefore it is necessary to have the functionality associated with the registration and authorization of the user; </li><li>  almost in all applications there are several types of representations: there is a view for viewing the list of objects of a certain model, there is a view for viewing a detailed record of one single object of the model; </li><li>  almost all models have attributes similar in type: string data, numbers, etc., and therefore, you need to be able to work with them both on the back-end and on the front-end. </li></ul><br>  And since our company often performs custom web application development, we thought: why do we need to reinvent the wheel every time and develop similar functionality from scratch each time, if you can write a framework once that would describe all the basic, common to many applications, things, and then, creating a new project, use ready-made developments as dependencies, and, if necessary, declaratively change them in a new project. <br><br>  Thus, in the course of a long discussion, we had the idea of ‚Äã‚Äãcreating VSTUtils - a framework that: <br><br><ol><li>  It contained the basic, most similar for most applications, functionality; </li><li>  Allowed to generate a front-end on the fly based on an API structure. </li></ol><br><h2>  How to make friends back-end and front-end? </h2><br>  Well, we must do, we thought.  We already had a certain back-end, a certain front-end, too, but neither the server nor the client had a tool that could inform or get data about the API structure. <br><br>  In the search for a solution to this problem, our eye fell on the <a href="https://swagger.io/docs/specification/about/">OpenAPI</a> specification, which, based on the description of the models and the relationships between them, generates a huge JSON containing all this information. <br><br>  And we thought that, in theory, when the application is initialized on the client, the front-end can receive this JSON from the API and build all the necessary views based on it.  It remains only to teach our front-end to do it all. <br><br>  And after a while we did teach him. <br><br><h2>  Version 1.0 - what was the result </h2><br>  The architecture of the first version of the VSTUtils framework consisted of 3 conditional parts and looked like this: <br><br><ol><li>  <b>Back-end:</b> <br><ul><li>  <u>Django and Python</u> - all the logic associated with the models.  Based on the basic model of the Django Model, we have created several classes of basic models of VSTUtils.  All actions that these models can perform we have implemented using Python; <br></li><li>  <u>Django REST Framework</u> - REST API generation.  Based on the description of the models, a REST API is formed, thanks to which the server and the client communicate; <br></li></ul></li><li>  <b>Layer between back-end and front-end:</b> <br><ul><li>  <u>OpenAPI</u> - JSON generation with a description of the API structure.  After all models have been described on the back-end, views are created for them.  Adding each of the views adds the necessary information to the final JSON: <br><div class="spoiler">  <b class="spoiler_title">JSON'a Example - OpenAPI Scheme</b> <div class="spoiler_text"><pre><code class="json hljs">{ // ,     (, ), //   -  , //  -     . definitions: { //    Hook. Hook: { // ,     (, ), //   -   , //  -       (,    ..). properties: { id: { title: <span class="hljs-string"><span class="hljs-string">"Id"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, readOnly: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, name: { title: <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength:<span class="hljs-number"><span class="hljs-number">1</span></span>, maxLength: <span class="hljs-number"><span class="hljs-number">512</span></span>, }, type: { title: <span class="hljs-string"><span class="hljs-string">"Type"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"HTTP"</span></span>,<span class="hljs-string"><span class="hljs-string">"SCRIPT"</span></span>], }, when: { title: <span class="hljs-string"><span class="hljs-string">"When"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"on_object_add"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_upd"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_del"</span></span>], }, enable: { title:<span class="hljs-string"><span class="hljs-string">"Enable"</span></span>, type:<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, }, recipients: { title: <span class="hljs-string"><span class="hljs-string">"Recipients"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength: <span class="hljs-number"><span class="hljs-number">1</span></span>, } }, // ,     ,    . required: [<span class="hljs-string"><span class="hljs-string">"type"</span></span>,<span class="hljs-string"><span class="hljs-string">"recipients"</span></span>], } }, // ,     (, ), //   -   ( URL), //  -     . paths: { //      '/hook/'. '/hook/': { //    get    /hook/. //  ,       Hook. get: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_list"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Return all hooks."</span></span>, // ,       ,     . parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"id"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A unique integer value (or comma separated list) identifying this instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"name"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A name string value (or comma separated list) of instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"type"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Instance type."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, ], // ,     (, ), //   -   ; //  -   . responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { properties: { results: { type: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, items: { //   ,       . $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, }, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, //    post    /hook/. //  ,       Hook. post: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_add"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Create a new hook."</span></span>, parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"data"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"body"</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, ], responses: { 201: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, } } }</code> </pre> </div></div></li></ul></li><li>  <b>Front-end:</b> <br><ul><li>  <u>JavaScript</u> is a mechanism that pans the OpenAPI schema and generates views.  This mechanism is run once, when the application is initialized on the client.  By sending a request to the API, it receives in response the requested JSON with a description of the API structure and, analyzing it, it creates all the necessary JS objects containing the parameters of the model views.  This API request is quite weighty, so we cache it and re-request it only when the application version is updated; </li><li>  <u>JavaScript SPA libs</u> - rendering views and routing between them.  These libraries were written by one of our front-end developers.  When a user accesses a particular page, the rendering engine produces page rendering based on the parameters previously stored in JS view objects. </li></ul></li></ol><br>  Thus, what we have: we have a back-end, which describes all the logic associated with the models.  Then OpenAPI comes into play, which, based on the model description, generates JSON with a description of the API structure.  Next, the baton is transmitted to the client, which, by analyzing the generated JAP generated by OpenAPI, automatically generates a web interface. <br><br><h2>  The introduction of features in the application on the new architecture - how it works </h2><br>  Remember the task about adding custom hooks?  Here is how we would implement it in an application based on VSTUtils: <br><br><img src="https://habrastorage.org/webt/ud/yr/af/udyrafi5o5grqlzqovkat8ursko.png" alt="The process of adding a new feature on the new architecture"><br><br>  Now, thanks to VSTUtils, we don‚Äôt need to write anything from scratch.  Here is what we do to add the ability to create custom hooks: <br><br><ol><li>  On the back-end: we take and inherit from the most appropriate class in VSTUtils, add a new functionality, characteristic of the new model; </li><li>  On the front-end: <br><ul><li>  if the view for this model is no different from the basic VSTUtils view, then we do nothing, everything is automatically displayed properly; </li><li>  if you need to somehow change the behavior of the view, using the mechanism of signals, we declaratively extend or completely change the basic behavior of the view. <br></li></ul></li></ol><br>  As a result, we got a pretty good solution, we achieved our goal, our front-end became auto-generated.  The process of introducing new features into existing projects has noticeably accelerated: releases began to appear once every 2 weeks, whereas previously we released releases every 2-3 months with a much smaller number of new features.  I would like to note that the development team has remained the same; it is the new application architecture that has given us such fruits. <br><br><h2>  Version 1.0 - our hearts demand change </h2><br>  But, as you know, there is no limit to perfection, and VSTUtils is no exception. <br><br>  Despite the fact that we were able to automate the formation of a front-end, the solution we initially wanted was not straightforward. <br><br>  The client-side application architecture was not thoroughly thought out, and turned out to be not as flexible as it could be: <br><br><ul><li>  the process of introducing functional overloads was not always convenient; </li><li>  The OpenAPI schema parsing mechanism was not optimal; </li><li>  views and routing between them were rendered using self-written libraries, which also did not suit us for a number of reasons: <br><ul><li>  these libraries were not covered by tests; </li><li>  there was no documentation for these libraries; </li><li>  they didn‚Äôt have any community - in the case of finding bugs in them or leaving the employee who wrote them, the support of such a code would be very difficult. </li></ul></li></ul><br>  And since in our company we adhere to the DevOps approach and try to standardize and formalize our code as much as possible, then in February of this year we decided to conduct a global refactoring of the front-end framework VSTUtils.  We had several tasks: <br><br><ul><li>  to form not only classes of representations on the front-end, but also classes of models ‚Äî we realized that it would be more appropriate to separate the data (and their structure) from their presentation.  In addition, the presence of several abstractions in the form of representation and model would greatly facilitate the addition of overloads of the basic functionality in projects based on VSTUtils; </li><li>  use a tested framework for rendering and routing, with a large community (Angular, React, Vue) - this will allow us to give the whole headache with the support of the code associated with rendering and routing within our application. </li></ul><br><h2>  Refactoring - choosing a JS framework </h2><br>  Among the most popular JS frameworks: Angular, React, Vue, our choice fell on Vue because: <br><br><ul><li>  Vue codebase weighs less than React and Angular; <br><br>  <i><a href="https://gist.github.com/Restuta/cda69e50a853aa64912d">Comparative table</a> of framework sizes Gzipped version</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Framework </th><th>  Size, kb </th></tr><tr><td>  Angular 2 </td><td>  111 </td></tr><tr><td>  Angular 2 + RX </td><td>  143 </td></tr><tr><td>  Angular 1.4.5 </td><td>  51 </td></tr><tr><td>  React 0.14.5 + React DOM </td><td>  40 </td></tr><tr><td>  React 0.14.5 + React DOM + Redux </td><td>  42 </td></tr><tr><td>  React 15.3.0 + React DOM </td><td>  43 </td></tr><tr><td>  Vue 2.4.2 </td><td>  21 </td></tr></tbody></table></div></li><li>  the page rendering process takes <a href="https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8">less</a> time for Vue than for React and Angular; <br><img src="https://habrastorage.org/webt/lo/eu/6m/loeu6mow9u1qbcz3nbanmldjmwu.png" alt="comparing the speed of rendering pages with different javascript frameworks relative to pure javascript"></li><li>  The Vue entry threshold is much lower than in React and Angular; </li><li>  Native syntax patterns; </li><li>  Elegant, detailed documentation available in several languages, including Russian; </li><li>  A developed ecosystem that provides, in addition to the Vue base library, libraries for routing and for creating a reactive data warehouse. </li></ul><br><h2>  Version 2.0 - the result of front-end refactoring </h2><br>  The process of global refactoring of front-end VSTUtils took about 4 months and this is what we ended up with: <br><br><img src="https://habrastorage.org/webt/6a/wr/9k/6awr9kuruhmeq9gey-isefn_21u.png" alt="new architecture fron-end VSTUtils"><br><br>  The VSTUtils front-end framework still consists of two large blocks: the first is parsing the OpenAPI schema, the second is rendering views and routing between them, but both of these blocks have a number of significant changes. <br><br>  The mechanism that casts the OpenAPI scheme has been completely rewritten.  The approach to parsing this scheme has changed.  We tried to make the front-end architecture as similar as possible to the back-end architecture.  Now, on the client side, we have not just a single abstraction in the form of representations, now we also have abstractions in the form of models and QuerySets: <br><br><ul><li>  Objects of the Model class and its descendants are objects corresponding to the Django Models abstraction on the server side.  Objects of this type contain data on the structure of the model (model name, model fields, etc.); </li><li>  objects of the QuerySet class and its descendants are objects corresponding to the Django QuerySets abstraction on the server side.  Objects of this type contain methods that allow you to perform requests to the API (add, modify, retrieve, delete data of model objects); </li><li>  View objects are objects that contain data about how to present a model on a particular page, what template to use to ‚Äúrender‚Äù the page, what other model representations this page can refer to, etc. </li></ul><br>  The unit responsible for rendering and routing has also changed noticeably.  We have abandoned samopisny JS SPA libraries in favor of the framework Vue.js.  We developed our own Vue components that make up all the pages of our web application.  Routing between views is performed using the vue-router library, and we use vuex as the reactive storage of the application state. <br><br>  I would also like to note that on the front-end side, the implementation of the Model, QuerySet and View classes does not depend on the means of rendering and routing, that is, if we suddenly want to switch from Vue to some other framework, for example, to React or something new, all we need to do is rewrite the Vue components into the components of the new framework, rewrite the router, the repository, and that‚Äôs it - the VSTUtils framework will work again.  The implementation of the Model, QuerySet and View classes will remain the same, since it does not depend on Vue.js.  We believe that this is a very good help for possible future changes. <br><br><h2>  Let's sum up </h2><br>  Thus, the reluctance to write ‚Äúduplicate‚Äù code resulted in the task of automating the formation of the front-end of a web application, which was solved by creating the VSTUtils framework.  We managed to build a web application architecture in such a way that the back-end and front-end complement each other harmoniously and any change in the API structure is automatically picked up and displayed properly on the client. <br><br>  The advantages that we have received from the formalization of the web application architecture: <br><br><ul><li>  Releases of applications running on the basis of VSTUtils began to come out 2 times more often.  This is due to the fact that now for the introduction of a new feature, often, we need to add code only on the back-end, the front-end is automatically generated - this saves time; </li><li>  Simplified update base functionality.  Since now all the basic functionality is assembled in one framework, in order to update some important dependencies or make improvements to the basic functionality, we need to make changes only in one place - in the VSTUtils code base.  When updating VSTUtils version in child projects, all innovations will automatically pick up; </li><li>  Finding new employees has become easier.  Agree, it is much easier to find a developer under a formalized technology stack (Django, Vue) than to look for a person who agrees to work with an unknown samopis.  Search results for developers who mentioned Django or Vue in their CVs on HeadHunter (across all regions): <br><ul><li>  Django - 3,454 resumes were found for 3,136 applicants; </li><li>  Vue - 4,092 CVs of 3,747 job seekers found. </li></ul></li></ul><br>  The disadvantages of this formalization of the web application architecture include the following: <br><br><ul><li>  Due to the parsing scheme OpenAPI application initialization on the client takes a little longer than before (about 20-30 milliseconds longer); </li><li>  Bad search indexing.  The fact is that at the moment we are not using the server rendering in the framework of VSTUtils, and the entire content of the application is generated in the final form already on the client.  But our projects often do not need high search results and for us it is not so critical. </li></ul><br>  At this my story comes to an end, thank you for your attention! <br><br><h2>  useful links </h2><br><ul><li>  <a href="https://swagger.io/docs/specification/about/">OpenAPI specification</a> ; </li><li>  <a href="https://github.com/vstconsulting/vstutils">VSTUtils repository</a> ; </li><li>  <a href="https://github.com/vstconsulting/polemarch">Sample project created on the basis of VSTUtils</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/456146/">https://habr.com/ru/post/456146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456124/index.html">Using Typescript with React - A Beginner's Guide</a></li>
<li><a href="../456126/index.html">Recalculate a ton of money and explore the mine: how the robots have already found a place among us</a></li>
<li><a href="../45613/index.html">Wikipoogle</a></li>
<li><a href="../45614/index.html">How Habr Tested Visual Studio</a></li>
<li><a href="../456144/index.html">KubeCon EU 2019: 10 key findings</a></li>
<li><a href="../456148/index.html">News of the week: Facebook denies Huawei applications, OS Aurora instead of Android, penalties for mining</a></li>
<li><a href="../456154/index.html">Core UX Features & MVP when creating a product</a></li>
<li><a href="../456158/index.html">A little about the sources of nuclear fuel</a></li>
<li><a href="../456160/index.html">Reinforcement training or evolutionary strategies? - Both</a></li>
<li><a href="../456168/index.html">Where was your home millions of years ago?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>