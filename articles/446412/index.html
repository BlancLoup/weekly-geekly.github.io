<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>KDB + database: from finance to Formula 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="KDB +, a KX product, is a well-known in narrow circles, an exceptionally fast, column-based database for storing time series and analytical calculatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>KDB + database: from finance to Formula 1</h1><div class="post__text post__text-html js-mediator-article">  KDB +, a <a href="http://www.kx.com/">KX</a> product, is a well-known in narrow circles, an exceptionally fast, column-based database for storing time series and analytical calculations based on them.  Initially, she enjoyed (and enjoys) great popularity in the finance industry ‚Äî all top 10 investment banks and many well-known hedge funds, stock exchanges, and other organizations use it.  Recently, KX decided to expand its client base and now offer solutions in other areas where there is a large amount of data ordered by time or otherwise - telecom, bioinformatics, production, etc.  In particular, they became a partner of the Aston Martin Red Bull Racing team in Formula 1, where they help collect and process data from car sensors and analyze tests in a wind tunnel.  In this article I want to tell you what features of KDB + make it overproductive, why companies are willing to spend a lot of money on it, and finally, why this is not really a database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efa/f84/839/efaf84839e64d7c0026568d2b8019cd9.jpg"><br><a name="habracut"></a><br>  In this article I will try to tell in general what KDB + is, what opportunities and limitations it has, what is its use for companies wishing to process large amounts of data.  I will not go into the details of KDB + implementation and the details of its Q programming language. Both of these topics are very extensive and deserve separate articles.  A lot of information on these topics can be found on code.kx.com, including a book on Q - Q For Mortals (see the link below). <br><br><h2>  Some terms </h2><br><ul><li>  <b>In-memory database.</b>  A database that stores data in RAM for faster access.  The advantages of such a database are clear, and the disadvantages are the possibility of data loss, the need to have a lot of memory on the server. <br></li><li>  <b>Column database.</b>  A database where data is stored by colic, and not record by record.  The main advantage of such a database is that data from one column is stored together on disk and in memory, which greatly speeds up access to it.  There is no need to load columns that are not used in the query.  The main disadvantage is that it is difficult to modify and delete records. <br></li><li>  <b>Time series</b>  Data with a date or time type column.  As a rule, the ordering of time is important for such data so that it is easy to determine which record precedes or follows the current one, or to use functions whose result depends on the order of the records.  Classic databases are built on a completely different principle - the representation of a set of records as a set, where the order of records is not defined in principle. <br></li><li>  <b>Vector.</b>  In the context of KDB +, this is a list of elements of one atomic type, for example, numbers.  In other words, an array of elements.  Arrays, unlike lists, can be stored compactly and processed using vector instructions of the processor. <br></li></ul><br><h2>  History reference </h2><br>  KX was founded in 1993 by Arthur Whitney, who had previously worked at Morgan Stanley Bank on the A + language, the heir to APL, a very original and once popular language in the financial world.  Of course, at KX, Arthur continued in the same vein and created the vector-functional language K, guided by the ideas of radical minimalism.  Programs in K look like a jumbled set of punctuation marks and special characters, the meaning of signs and functions depends on the context, and each operation carries a lot more sense than it does in familiar programming languages.  Due to this, the K program takes up minimal space ‚Äî a few lines can replace text pages of a verbose language like Java ‚Äî and is an over-concentrated implementation of the algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A function on K that implements a large part of the LL1 parser generator according to a given grammar: <br><br><pre><code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> pp:{q:{(x;p3(),y)};r:$[<span class="hljs-number"><span class="hljs-number">-11</span></span>=@x;$x;<span class="hljs-number"><span class="hljs-number">11</span></span>=@x;q[`N;$*x];<span class="hljs-number"><span class="hljs-number">10</span></span>=abs@@x;q[`N;x]  <span class="hljs-number"><span class="hljs-number">2.</span></span>   ($)~*x;(`P;p3 x <span class="hljs-number"><span class="hljs-number">1</span></span>);(<span class="hljs-number"><span class="hljs-number">1</span></span>=<span class="hljs-meta"><span class="hljs-meta">#x)&amp;11=@*x;pp[{(1#x;$[2=#x;;,:]1_x)}@*x]  3.      (?)~*x;(`Q;pp[x 1]);(*)~*x;(`M;pp[x 1]);(+)~*x;(`MP;pp[x 1]);(!)~*x;(`Y;p3 x 1)  4.      (2=#x)&amp;(@x 1)in 100 101 107 7 -7h;($[(@x 1)in 100 101 107h;`Ff;`Fi];p3 x 1;pp[*x])  5.      (|)~*x;`S,(pp'1_x);2=#x;`C,{@[@[x;-1+#x;{x,")"}];0;"(",]}({$[".sC"~4#x;6_-2_x;x]}'pp'x);'`pp];  6.   $[@r;r;($[1&lt;#r;".s.";""],$*r),$[1&lt;#r;"[",(";"/:1_r),"]";""]]}</span></span></code> </pre> <br>  Arthur embodied this philosophy of extreme efficiency with a minimum of body movements in KDB +, which appeared in 2003 (I think it‚Äôs clear where the letter K in the title is from) and is nothing more than an interpreter of the fourth version of the K language. K is called Q. Q also adds support for a specific SQL dialect, QSQL, and the interpreter adds support for tables as a system data type, tools for working with tables in memory and on disk, etc. <br><br>  Thus, from the user's point of view, KDB + is simply an interpreter of the Q language with support for tables and SQL-like expressions in LINQ style from C #.  This is the most important difference between KDB + from other databases and its main competitive advantage, which is often overlooked.  This is not a database + auxiliary disabled language, but a full-fledged powerful programming language + built-in support for database functions.  This distinction will play a decisive role in listing all the benefits of KDB +.  For example‚Ä¶ <br><br><h2>  The size </h2><br>  By modern standards, KDB + has just a microscopic size.  It is literally one executable file smaller than a megabyte and one small text file with some system functions.  In reality, it is less than one megabyte and companies pay tens of thousands of dollars a year for a single processor on a server for this program. <br><br><ul><li>  This size allows KDB + to feel great on any hardware - from the Pi microcomputer to servers with terabytes of memory.  It does not affect the functionality in any way; moreover, Q starts instantly, which allows using it as a scripting language as well. <br></li><li>  With this size, the Q interpreter is completely placed in the processor's cache, which speeds up the execution of programs. <br></li><li>  With this size of the executable file, the Q process takes up very little memory space, you can run them in the hundreds.  At the same time, if necessary, Q can operate with tens or hundreds of gigabytes of memory in a single process. <br></li></ul><br><h2>  Versatility </h2><br>  Q is perfect for a variety of tasks.  Q process can serve as a historical database and provide quick access to terabytes of information.  For example, we have dozens of historical databases, in some of which one uncompressed data day takes up more than 100 gigabytes.  However, with reasonable restrictions, the request to the database will be executed in tens to hundreds of milliseconds.  In general, we have a universal timeout - 30 seconds - for user requests, and it rarely works. <br><br>  With the same ease, Q can be an in-memory database.  Adding new data to tables in memory is so fast that user requests are a limiting factor.  The data in the tables is stored in columns, which means that any operation on the column will use the processor's cache at full capacity.  In addition to this, KX tried to implement all the basic operations like arithmetic through the vector instructions of the processor, maximizing their speed.  Q can also perform tasks not inherent in databases - for example, process streaming data and calculate in "real time" (with a delay of tens of milliseconds to several seconds depending on the task) different aggregation functions for financial instruments for different time intervals or build a model of perfect influence. transactions on the market and carry out its profiling almost immediately after its commission.  In such tasks, most often the main time delay is made not by Q, but by the need to synchronize data from different sources.  High speed is achieved due to the fact that the data and functions that process them are in the same process, and processing is reduced to the execution of several QSQL expressions and joins that are not interpreted, but are executed by binary code. <br><br>  Finally, you can write any service processes on Q.  For example, Gateway processes that automatically distribute user requests to the right databases and servers.  The programmer has complete freedom to implement any algorithm for balancing, prioritization, fault tolerance, access rights, quotas, and in general what your heart desires.  The main problem here is that you have to implement all this yourself. <br><br>  For example, I will list what types of processes we have.  All of them are actively used and work together, combining dozens of different databases into one, processing data from multiple sources and serving hundreds of users and applications. <br><br><ul><li>  <b>Connectors (feedhandler) to data sources.</b>  As a rule, these processes use external libraries that are loaded into Q. The C-interface in Q is extremely simple and allows you to easily create proxy functions for any C / C ++ library.  Q is fast enough to handle, for example, processing the flow of FIX messages from all European stock exchanges simultaneously. <br></li><li>  <b>Data distributors (tickerplant),</b> which serve as an intermediate link between connectors and consumers.  At the same time, they write incoming data to a special binary log, providing consumers with resistance to connection losses or restarts. <br></li><li>  <b>In-memory database (rdb).</b>  These databases provide the fastest possible access to raw, fresh data by storing them in memory.  As a rule, they accumulate data in tables during the day and reset them at night. <br></li><li>  <b>Persist Database (pdb).</b>  These databases provide the preservation of data for today in the historical database.  As a rule, unlike rdb, they do not store data in memory, but use a special cache on the disk during the day and copy the data at midnight into the historical database. <br></li><li>  <b>Historical bases (hdb).</b>  These databases provide access to data for previous days, months, and years.  Their size (in days) is limited only by the size of the hard drives.  Data can be located anywhere, in particular on different disks to speed up access.  It is possible to compress data using several algorithms to choose from.  The structure of the database is well documented and simple, the data is stored in standard files, so that they can be processed, including by means of the operating system. <br></li><li>  <b>Base with aggregated information.</b>  They store various aggregations, usually with, grouped by instrument name and time interval.  In-memory databases update their state with each incoming message, and historical data stores pre-calculated data to speed up access to historical data. <br></li><li>  Finally, <b>gateway processes</b> serving applications and users.  Q allows you to implement a fully asynchronous processing of incoming messages, their distribution across databases, checking access rights, etc.  I note that messages are not limited and most often are not SQL expressions, as is the case with other databases.  Most often, the SQL expression is hidden in a special function and is constructed based on the parameters requested by the user ‚Äî time conversion is performed, filtering is performed, data is normalized (for example, the stock price is leveled if dividends are paid), etc. <br></li></ul><br>  Typical architecture for one data type: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99a/13e/5e9/99a13e5e9813f09a2d40b676669c052a.png"><br><br><h2>  Speed </h2><br>  Although Q is an interpreted language, it is also a vector language.  This means that many built-in functions, in particular, arithmetic, take arguments of any form ‚Äî numbers, vectors, matrices, lists, and the programmer is expected to implement the program as operations on arrays.  In such a language, if you add two vectors of a million elements, it no longer plays the role that the language is interpretable, addition will be performed by a super-optimized binary function.  Since the lion's share of time in Q programs is spent on operations with tables using these basic vectorized functions, we have a very decent speed at the output, which allows us to process a huge amount of data even in one process.  This is similar to the mathematical libraries in Python - although Python itself is a very slow language, it has many excellent numpy libraries that allow you to process numeric data at the speed of the compiled language (by the way, numpy is ideologically close to Q). <br><br>  In addition, the KX very carefully approached the design of tables and optimize the work with them.  First, several types of indexes are supported, which are supported by built-in functions and can be applied not only to columns of tables, but also to any vectors - grouping, sorting, unique attribute and special grouping for historical bases.  The index is superimposed elementary and automatically adjusted when adding elements to a column / vector.  Indexes equally well can be superimposed on columns of tables both in memory and on disk.  When executing a QSQL query, indexes are used automatically, if possible.  Secondly, work with historical data is done through the OS file mechanism (memory map).  Large tables are never loaded into memory, instead, the necessary columns are displayed directly into memory and only that part of them is actually loaded (here they also help with indexes), which is necessary.  There is no difference for a programmer whether data is in memory or not, the mechanism for working with mmap is completely hidden in the depths of Q. <br><br>  KDB + is not a relational database, tables can contain arbitrary data, while the order of rows in the table does not change when new items are added and can and should be used when writing queries.  This feature is urgently needed to work with time series (data from stock exchanges, telemetry, event logs), because if the data is sorted by time, the user does not need to use any SQL tricks to find the first or last time line or N rows in the table , determine which line follows the Nth line, etc.  The joins of tables are simplified even more, for example, finding the last quote in a table of 500 million items for 16000 VOD.L transactions takes about a second on the disk and ten milliseconds in memory. <br><br>  An example of a time join - a quote table is mapped into memory, so there is no need to specify VOD.L in where, an index on the sym column is implicitly used, and the fact that the data is sorted by time.  Almost all joins in Q are normal functions, not the select part of an expression: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> aj[`sym`time;<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> trade <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date=<span class="hljs-number"><span class="hljs-number">2019.03</span></span><span class="hljs-number"><span class="hljs-number">.26</span></span>, sym=`VOD.L;<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> quote <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> date=<span class="hljs-number"><span class="hljs-number">2019.03</span></span><span class="hljs-number"><span class="hljs-number">.26</span></span>]</code> </pre><br>  Finally, it is worth noting that the engineers at KX, starting with Arthur Whitney himself, are really obsessed with efficiency and are making every effort to get the most out of the standard Q functions and optimize the most frequent patterns of use. <br><br><h2>  Total </h2><br>  KDB + is popular with businesses primarily because of its exceptional versatility - it serves equally well as an in-memory database, as a base for storing terabytes of historical data, and as a platform for analyzing data.  Due to the fact that data processing takes place directly in the database, a high speed of work and saving of resources are achieved.  A full-fledged programming language integrated with database functions allows you to implement the entire stack of necessary processes on one platform, from receiving data to processing user requests. <br><br><h2>  additional information </h2><br><h3>  disadvantages </h3><br>  A significant disadvantage of KDB + / Q is the high threshold of entry.  The language has a strange syntax, some functions are heavily overloaded (value, for example, has about 11 use cases).  Most importantly, it requires a radically different approach to writing programs.  In a vector language, you need to think all the time in terms of array transformations, implement all cycles through several variants of map / reduce functions (which are called adverbs in Q), never try to save money by replacing vector operations with atomic ones.  For example, to find the index of the Nth occurrence of an element in an array, you should write: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> element=vector)[N]</code> </pre><br>  although it looks terribly inefficient by C / Java standards (= creates a Boolean vector, where it returns indices of true elements in it).  But such a record makes the meaning of the expression more understandable and you use fast vector operations instead of slow atomic ones.  The conceptual difference between the vector language and the rest is comparable to the difference between the imperative and functional approaches to programming, and we must be ready for this. <br><br>  Some users are also unhappy with QSQL.  The fact is that it only looks like real SQL.  In fact, this is just an interpreter of SQL-like expressions that does not support query optimization.  The user must write the optimal queries himself, and in Q, to which many are not ready.  On the other hand, of course, you can always write the optimal query yourself, and not rely on the black box optimizer. <br><br>  As a plus, the Q - Q For Mortals book is available for free on <a href="https://code.kx.com/q4m3/">the company's website</a> , and many other useful materials are also collected there. <br><br>  Another big minus is the cost of the license.  These are tens of thousands of dollars a year for one CPU.  Only large firms can afford such expenses.  Recently, KX has made the licensing policy more flexible and provides an opportunity to pay only during use or to rent KDB + in Google and Amazon clouds.  KX also offers a <a href="https://kx.com/connect-with-us/download/">free version for non-commercial purposes</a> (32-bit or 64-bit on request). <br><br><h3>  Competitors </h3><br>  There are quite a few specialized databases built on similar principles - columnar, in-memory, focused on very large amounts of data.  The problem is that these are specialized databases.  A bright example is Clickhouse.  This database has a very similar to KDB + principle of storing data on disk and the index structure, it performs some queries faster than KDB +, although it is not essential.  But even as the Clickhouse database is more specialized than KDB + - web analytics vs arbitrary time series (this distinction is very important - because of it, for example, Clickhouse does not have the ability to use orderliness of records).  But, most importantly, Clickhouse does not have the universality of KDB +, a language that would allow to process data directly in the database, and not load it in advance into a separate application, build arbitrary SQL expressions, use arbitrary functions in the query, create processes not related to the performance of the historical database .  Therefore, it is difficult to compare KDB + with other databases, they may be better in certain use cases or simply better if we are talking about classical database tasks, but I don‚Äôt know another equally effective and versatile tool for processing temporary data. <br><br><h3>  Python integration </h3><br>  To simplify working with KDB + for people who are not familiar with the technology, KX created libraries for tight integration with Python in a single process.  It is possible to call any python function from Q, and vice versa, to call any Q function from Python (in particular, QSQL expressions).  Libraries convert, if necessary (for the sake of efficiency, not always) data from the format of one language into the format of another.  As a result, Q and Python live in such a close symbiosis that the boundaries between them are erased.  As a result, the programmer, on the one hand, has full access to numerous useful Python libraries, on the other hand, he gets a fast database integrated with Python, which is especially useful to those involved in machine learning or modeling. <br><br>  Working with Q in Python: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> &gt;&gt;&gt; q() <span class="hljs-number"><span class="hljs-number">2.</span></span>q)trade:([]date:();sym:();qty:()) <span class="hljs-number"><span class="hljs-number">3.</span></span> q)\ <span class="hljs-number"><span class="hljs-number">4.</span></span> &gt;&gt;&gt; q.insert(<span class="hljs-string"><span class="hljs-string">'trade'</span></span>, (date(<span class="hljs-number"><span class="hljs-number">2006</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'IBM'</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)) <span class="hljs-number"><span class="hljs-number">5.</span></span> k(<span class="hljs-string"><span class="hljs-string">',0'</span></span>) <span class="hljs-number"><span class="hljs-number">6.</span></span> &gt;&gt;&gt; q.insert(<span class="hljs-string"><span class="hljs-string">'trade'</span></span>, (date(<span class="hljs-number"><span class="hljs-number">2006</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'MSFT'</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)) <span class="hljs-number"><span class="hljs-number">7.</span></span> k(<span class="hljs-string"><span class="hljs-string">',1'</span></span>)</code> </pre><br><h3>  Links </h3><br>  Company website - <a href="https://kx.com/">https://kx.com/</a> <br>  Website for developers - <a href="https://code.kx.com/v2/">https://code.kx.com/v2/</a> <br>  Book Q For Mortals (in English) - <a href="https://code.kx.com/q4m3/">https://code.kx.com/q4m3/</a> <br>  Articles on the topic of KDB + / Q applications from kx employees - <a href="https://code.kx.com/v2/wp/">https://code.kx.com/v2/wp/</a> </div><p>Source: <a href="https://habr.com/ru/post/446412/">https://habr.com/ru/post/446412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446400/index.html">Dmitry Dumik, Chatfuel: about Y Combinator, technology entrepreneurship, behavior change and awareness</a></li>
<li><a href="../446402/index.html">Multilingual applications in Angular</a></li>
<li><a href="../446404/index.html">Modern PGP Alternatives</a></li>
<li><a href="../446406/index.html">The Tale of Ivan the Economist - the Future Programmer</a></li>
<li><a href="../446408/index.html">Universal DRO based on Arduino Nano - shDRO</a></li>
<li><a href="../446414/index.html">Good thing will not be called rust</a></li>
<li><a href="../446418/index.html">Cloudflare introduced its own VPN service based on application 1.1.1.1 for mobile devices</a></li>
<li><a href="../446422/index.html">QuietOn - headphones that kill ...</a></li>
<li><a href="../446424/index.html">The history of a single report</a></li>
<li><a href="../446428/index.html">How HR's bumblebee plant built</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>