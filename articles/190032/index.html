<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ARMs for the little ones: what time is it?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will deal with two important questions: how to write more efficient code with CMSIS and how to correctly calculate the speed of the processor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ARMs for the little ones: what time is it?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d33/7ce/a78/d337cea7800de8ea90a8aa51a3ac8522.jpg"><br><br>  Today we will deal with two important questions: how to write more efficient code with CMSIS and how to correctly calculate the speed of the processor.  We will start with the second part and study the processes that occur in LPC1114 to generate a clock frequency. <br><br><a name="habracut"></a><br>  Clock frequency - the main source of "labor" in the processor, its generator can be compared with the heart of a person.  Different processor components can use different frequencies, which, however, usually arise in the same chip (or resonator). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Most processors have a built-in resonator and the ability to connect an external resonator or crystal.  Why is this done?  Basically, to reduce the cost of the processor.  The built-in resonator typically has an error of about 1%, which may be enough for many tasks, but there are even more tasks for which such accuracy is unacceptable.  In fact, if we consider, for example, the time on the built-in resonator, the error per day can reach 14 minutes.  If you transmit a packet over the network about once every half hour, this is absolutely not a critical error.  Another thing, if you make an alarm clock. <br><br><img src="https://habrastorage.org/storage2/122/d12/3c0/122d123c09dfce6c32a3508f93ce9b1e.png"><br>  (image from <a href="http://www.nxp.com/documents/user_manual/UM10398.pdf">LPC111x User Manual</a> ) <br><br>  Above is an overview of the clock generator, divided into components.  Now we will deal with each of them separately. <br><br><h4>  ‚ìµ Primary frequency </h4><br>  <code>MAINCLKSEL</code> sets the basic frequency on which almost everyone else depends.  It can be based on one of several sources. <br><br>  First, it is IRC - internal resonator.  The operating frequency is 12 MHz (in fact, it can be tuned in small limits), the error is about 1%.  It is from here that the processor clock frequency is generated at the time of launch, so that the entire boot code is executed at a clock frequency of 12 MHz.  The variant is as simple as possible (you don‚Äôt need to do anything at all so that it works), it does not require additional external components.  Unfortunately, it has its own problems: the resonator, as I already mentioned, is somewhat inaccurate, moreover, it is not particularly interesting for us to drive the core at 12 MHz, when it works fine at 50 MHz. <br><br>  Secondly, the main frequency can be set from another internal generator - watchdog oscillator, which is usually used for watchdog operation.  This oscillator operates at speeds (programmatically adjustable) from 9.4 kHz to 2.3 MHz with an error of ¬± 40% - it would not seem like the best solution for the fundamental frequency.  On the other hand, this is exactly the wonderful and energy efficient solution if you need to put the kernel into sleep mode, while leaving some part of the periphery working. <br><br>  Third, we can get the fundamental frequency from the system oscillator before or after the <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B9%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D1%258B" title="Phase locked loop">PLL</a> .  We will not now delve into the specifics of the PLL, since this is quite a voluminous topic.  I advise those interested to study the section ‚Äú3.11 System PLL functional description‚Äù. <br><br><h4>  ‚ì∂ System Oscillator </h4><br>  The system oscillator is that part of the processor that will not work without hardware modifications, it lacks the main working force of the oscillator - a crystal (or a quartz resonator) that needs to be connected outside, for which any modern processor has XTALIN / XTALOUT pins. <br><br>  Specifically, the LPC1114 (however, like the other processors of the LPC111x line) supports crystals with an oscillation frequency from 1 MHz to 25 MHz.  In addition to the crystal itself, you will also need two capacitors, the values ‚Äã‚Äãof which depend on the parameters of the selected crystal.  Here I refer you to the <a href="http://www.nxp.com/documents/data_sheet/LPC111X.pdf">datasheet</a> , where in section 12.3 (XTAL input) there is both a wiring diagram and a table with recommended capacitors.  In the test circuit, I tried to use a crystal with a frequency of 12 MHz, a load capacity of 20 pF and two 39 pF capacitors, but this mode of operation will not be considered further. <br><br>  If you have a reliable external clock source, then you can skip the system oscillator, then the clock frequency is taken from the pin XTALIN. <br><br>  The system oscillator can be used directly as a generator of the main frequency, or it can be previously passed through the PLL. <br><br><h4>  ‚ì∑ PLL </h4><br>  Without going into electrical mechanics, a PLL is a device that multiplies and then divides the input clock frequency.  The PLL input can receive the frequency from the IRC or the system oscillator, and the output will be used for the fundamental frequency. <br><br>  Configuring the PLL parameters is potentially dangerous for the processor internals, because I recommend the <a href="http://www.lpcware.com/content/nxpfile/lpc11xx-main-pll-calculator">NXP-based utility</a> (successfully converted and running to Google Drive) to select the necessary parameters, just set the oscillator frequency at the input and the total frequency you want to receive, and it will calculate the possible options. <br><br>  The network has an <a href="http://forum.stellarisiti.com/topic/446-lpc1114-tweaking-the-internal-clock-to-run-at-50mhz/">interesting note</a> on how to raise the IRC frequency to generate 50 MHz at the PLL output, but to debug this result, you need an oscilloscope. <br><br><h4>  ‚ì∏ System frequency </h4><br>  Usually, the core (the fact that Cortex-M0) operates at the main frequency, but, if necessary, the main frequency can be divided (up to 255), resulting in a total system frequency.  In addition to the core itself, flash memory, RAM and all peripherals will work at this frequency, with the exception of SPI and UART.  Keep in mind that the maximum frequency here is 50 MHz. <br><br><h4>  ‚ìπ And what about SPI and UART? </h4><br>  Due to the specifics of these interfaces, they have their own dedicated frequency dividers, for example, with UART it allows you to select the desired bitrate. <br><br>  Despite a certain non-obviousness of the circuit, not the main frequency, but the system frequency falls at the input of the divider. <br><br>  Calculation of the bitrate divider is quite a difficult task, so once again I send you to the instruction - ‚Äú13.5.15 UART Fractional Divider Register (U0FDR - 0x4000 8028)‚Äù.  There is both a calculation formula and an explanation for an additional fractional argument, as well as a block diagram for finding the right parameters for a given bit rate and a couple of examples. <br><br>  In SPI, everything is somehow significantly simpler, most likely because the master on the bus sets the frequency, and the rest of the devices work on it ‚Äî absentee synchronization is not required.  So the only thing we can do is set a divider.  The important point is that when the processor is running in master mode, the minimum divider is 2, i.e., at a system frequency of 48 MHz, the data transfer rate on SPI will be 24 MHz. <br><br>  <b>UPD</b> : as <a href="https://habrahabr.ru/users/valeriyk/" class="user_link">valeriyk</a> correctly noted, this divider is not the only thing that affects the output frequency.  For SPI, for example, the carrier frequency is calculated by the formula: <code>PCLK / (CPSDVSR * (SCR + 1))</code> , where PCLK is the periphery frequency;  CPSDVSR - ‚Äúpredivider‚Äù;  SCR is the number of prescaler cycles per output bit. <br><br><h4>  ‚ì∫ Watchdog on guard of vital activity </h4><br>  Watchdog, by its very nature, is an isolated component.  Therefore, a system, IRC or a separate oscillator can be used as the leading frequency.  In the same way, watchdog has its own dedicated divider. <br><br>  Why do you need a separate clock for watchdog?  If the program accidentally breaks the main generator, of course!  Then she will still have a chance to be reset by the watchdog timer. <br><br><h4>  ‚ìª Out </h4><br>  Finally, the processor can generate a clock output on the CLKOUT pin (one of the alternative functions for GPIO 0.1).  As the leading frequency, we can use any of the available to us: from oscillators (IRC, system or watchdog) or system frequency (after the PLL, if it is on).  And, of course, your divider. <br><br><h4>  A bit about mbed </h4><br>  We looked at the clock generation process in LPC1114 in detail, but what about LPC1768?  In fact, each processor line can be (and most likely it will have its own special approach, so the instructions on this topic should be studied very carefully. The LPC1768 also has an internal oscillator - IRC, but it works at 12 MHz. Besides it has (main) oscillator identical to the system oscillator. On mbed, a 12 MHz crystal is connected to it. Finally, there is a real-time clock (RTC) oscillator, but the crystal is not connected to it. <br><br>  Also, in addition to the main PLL, there is an additional one that is used to generate a working USB frequency.  All peripheral components have independent adjustable dividers with respect to the operating frequency. <br><br><h4>  Practical nuances of changing frequency </h4><br>  Changing the working clock frequency entails several consequences.  The most obvious is the need to reconfigure timers.  Also, you will need to reinitialize the peripherals working with protocols where it is important to fix the carrier frequency (UART, USB).  Finally, the number of ticks to access flash memory also plays an important role.  The default value of LPC1114 is 3 clocks (operating frequency up to 50 MHz, see the FLASHCFG register documentation), which is quite enough for our tasks.  But the default value of LPC1768 is 4 clocks, with an operating frequency of up to 80 MHz, which is not enough for us. <br><br>  However, operating at a higher frequency is likely to be beneficial.  Embedded processors spend most of their time in sleep mode, so the faster they work out the wakefulness cycle, the less energy they will spend in the end. <br><br><h4>  For the work! </h4><br>  Now we have the necessary theoretical baggage, and we are ready to apply this knowledge in practice - to make the LED blink deterministically, 1 time per second. <br><br>  As you saw earlier, a lot of tasks are performed in the same type - by writing and reading registers (in general, <b>all</b> tasks are performed exactly this way).  ARM took care of the fact that tasks that are not tied to a specific processor can be performed by the same C code, for this CMSIS exists - a set of drivers for the processor core.  Vendors usually extend it with drivers for the rest of the periphery. <br><br>  The difficult moment with CMSIS is that sometimes it is not quite clear where to find the current version.  The basic set of files can be downloaded directly from <a href="http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">ARM</a> , at the time of writing, version 3.01 is available there.  In addition to the header files, ARM provides a library for versatile complex calculations on DSP (which is still not in our hardware).  The situation is worse with drivers from specific manufacturers.  In NXP, for example, CMSIS for LPC1114 is based on CMSIS 1.30, and for LPC1768 - on 2.10.  Moreover, in the set of peripheral drivers there are obvious errors in the code.  And drivers for TI chips have to be thoroughly searched in Google. <br><br>  Two important conclusions can be drawn from this: first, the driver code is almost all open, so ‚Äútrust but verify‚Äù: the instruction and datasheet are your main literature on working with peripherals.  Secondly, there is almost nothing in the drivers that you couldn‚Äôt write yourself, that is, it is a great and often working reference material.  The main thing - do not forget to treat it critically, if something looks strange - smoke the instructions on the processor. <br><br>  The source code is now somewhat more structured.  Although as a result it has grown significantly in the number of files, it is now much easier to maintain several different platforms.  Sources for today's example are available on GitHub: <a href="https://github.com/farcaller/arm-demos">farcaller / arm-demos</a> (pull requests for new architectures are welcome!). <br><br>  The source tree is not yet fully combed, in particular, I did not get rid of primitive <code>boot.s</code> and <code>memmap.ld</code> .  The next part will be entirely devoted to the issues of the linker (including garbage collection and proper initialization of .data and .bss), where we will tackle all the controversial issues to the end.  The whole code is divided into three categories: <code>app/</code> contains the ‚Äúapplication‚Äù files - the actual working code of the example itself.  It is decorated in the style of arduino, through the functions <code>setup()</code> and <code>loop()</code> .  Platform <code>platform/</code> stores descriptions of different platforms and platform-specific functions (except <code>platform/common</code> , whose files are linked to all platforms).  Finally, in <code>cpu/</code> are CMSIS for specific processors. <br><br>  This whole harvester is going to be a funny little Rakefile.  Probably, it would be possible to get by with make, but I would like to put everything neatly into one file, so you‚Äôll need Ruby no older than version 1.9 to build examples. <br><br><h4>  Work on the clock </h4><br>  To accomplish our task (remember, we need to flash the LED exactly once a second) we would need some kind of timer.  Fortunately, there are several timers in LPC-shny processors, we will work with the most unified - SysTick.  This timer is described directly in CMSIS, that is, there is a high probability that it will be in any other processor.  It is supposed to be used to measure time slices when switching tasks in the OS, but nothing prevents it from being used for simple tasks. <br><br>  SysTick is a simple timer that counts down to zero from a given value, where it sets an overflow bit, jerks an interrupt, and starts counting from the beginning. <br><br>  <code>platform/common/systick.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">platform_systick_setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> load)</span></span></span><span class="hljs-function"> </span></span>{ SysTick-&gt;CTRL = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; SysTick-&gt;LOAD = load &lt; <span class="hljs-number"><span class="hljs-number">0xffffff</span></span> ? load : <span class="hljs-number"><span class="hljs-number">0xffffff</span></span>; SysTick-&gt;VAL = <span class="hljs-number"><span class="hljs-number">0</span></span>; SysTick-&gt;CTRL = <span class="hljs-number"><span class="hljs-number">0x05</span></span>; }</code> </pre><br><br>  To begin with about syntax.  These wonderful structures are accessible to us from CMSIS, it is no longer necessary to remember where the registers are located, and access to the fields is realized much more clearly. <br><br>  To initialize the timer, we write 4 to the control register.  This turns off the timer, if it was turned on, turns off the interrupt, and sets SysTick to use the processor frequency (remember, the default is 12 MHz).  Next, we load the starting point of reference into the SYST_RVR register, limiting the maximum to 16777215, reset the current register value to zero and start the timer. <br><br>  Now, how do we wait one second: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">platform_systick_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; i = SysTick-&gt;CTRL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((i &amp; <span class="hljs-number"><span class="hljs-number">0x00010000</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { i = SysTick-&gt;CTRL; } }</code> </pre><br><br>  We read the COUNTFLAG value from the SYST_CSR register.  COUNTFLAG is set to one when the counter goes to a new circle, and is reset to zero when reading.  Thus, we will be in a loop until the counter overflows. <br><br>  Let's look in other files of our project.  <code>app/systick-blink.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"platform.h"</span></span></span><span class="hljs-meta"> void setup() { platform_led_setup(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PLATFORM == MBED platform_systick_setup(4000000); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> PLATFORM == PROTOBOARD platform_systick_setup(12000000); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Unknown platform #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } void loop() { platform_led_toggle(1); platform_systick_wait(); platform_led_toggle(0); platform_systick_wait(); }</span></span></code> </pre><br><br>  It's all quite clear.  Initialize the ‚Äúdriver‚Äù of the LED and the timer, and in the cycle we turn on / off the LED with a delay.  Depending on the platform, we use a different start value for the timer (IRC on mbed and protoboard work for us at different frequencies).  And how does the code of the LED itself? <br><br>  <code>platform/protoboard/led.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LPC11xx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_PIN (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;9) void platform_led_setup() { LPC_GPIO1-&gt;DIR |= LED_PIN; } void platform_led_toggle(int on) { LPC_GPIO1-&gt;MASKED_ACCESS[LED_PIN] = on ? LED_PIN : 0; }</span></span></span></span></code> </pre><br><br>  As you can see, with CMSIS everything became really more readable.  The only interesting point is that instead of the general register of the GPIO, we now use a register with a mask.  It allows you to set GPIO bits for specific pins with a mask, i.e., you can simply write the desired value without thinking about maintaining the state of neighboring pins.  More details (and in pictures) about this can be found in the instructions: "12.4.1 Write / read data operation". <br><br>  For comparison, here is the code for mbed.  <code>platform/mbed/led.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LPC17xx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_PIN (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;18) #define LED_PIN_IN_B2 (1&lt;&lt;2) void platform_led_setup() { LPC_GPIO1-&gt;FIODIR |= LED_PIN; } void platform_led_toggle(int on) { LPC_GPIO1-&gt;FIOMASK2 |= ~LED_PIN_IN_B2; if (on) { LPC_GPIO1-&gt;FIOSET2 = LED_PIN_IN_B2; } else { LPC_GPIO1-&gt;FIOCLR2 = LED_PIN_IN_B2; } }</span></span></span></span></code> </pre><br><br>  As you can see, it is very similar.  LPC1768 does not have the ability to set the mask directly in the pointer address, but there is a byte access to the registers, which generates a slightly more efficient assembler listing. <br><br>  You can <code>rake build_protoboard</code> project with the <code>rake build_protoboard</code> or <code>rake build_mbed</code> .  You can even immediately flash the device: <code>rake upload_protoboard TTY=/dev/ftdi/tty/device</code> or <code>rake upload_mbed MOUNT=/Volumes/MBED</code> respectively.  Now the LEDs blink identically on both devices. <br><br><h4>  Play frequency? </h4><br>  It seems that we have decided the task - the LED flashes at the correct interval, but something else remains behind the scenes.  The maximum operating frequency of the LPC1114 is 50 MHz, and the LPC1768 has even more - 100 MHz, it turns out that we are driving them hardly a third of the power! <br><br>  It is time to do the correct platform initialization.  <code>platform/protoboard/init.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CLOCK_MODE_IRC 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 12 MHz #define CLOCK_MODE_IRC_WITH_PLL 1 // 48 MHz #define CLOCK_MODE_SYS_WITH_PLL 2 // 48 MHz with external 12MHz crystal #define CLOCK_MODE CLOCK_MODE_IRC</span></span></span></span></code> </pre><br><br>  Three LPC1114 templates are available in the source code: standard 12 MHz from IRC, 48 MHz from IRC passed through the PLL, and 48 MHz from the system oscillator passed through the PLL.  The latter option requires additional hardware support, but we are considering it, since this is a very relevant mode of use. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">platform_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// set up system oscillator and toggle PLL to point at it #if CLOCK_MODE == CLOCK_MODE_SYS_WITH_PLL int i; // power up system oscillator LPC_SYSCON-&gt;PDRUNCFG &amp;= ~(1 &lt;&lt; 5); // oscillator is not bypassed, runs at 1-20MHz range LPC_SYSCON-&gt;SYSOSCCTRL = 0; // allow circutry to settle down for (i = 0; i &lt; 200; ++i) __NOP(); // set PLL clock source to system oscillator LPC_SYSCON-&gt;SYSPLLCLKSEL = 1; // wait for PLL clock source to be updated LPC_SYSCON-&gt;SYSPLLCLKUEN = 1; LPC_SYSCON-&gt;SYSPLLCLKUEN = 0; LPC_SYSCON-&gt;SYSPLLCLKUEN = 1; while (!(LPC_SYSCON-&gt;SYSPLLCLKUEN &amp; 1)) ; #endif</span></span></code> </pre><br><br>  If we work from the system oscillator, it must be correctly initialized, and first of all - to include.  As we discussed earlier, the oscillator can be skipped if an already generated clock signal is present at the XTALIN input. <br><br>  After the initial initialization, a small delay should be made.  Next, we transfer the PLL to work from the system oscillator (instead of IRC), for this there is an interesting mechanism: we write 0, we write 1, we wait - the register will start to return 1. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// set up PLL if it's used #if CLOCK_MODE == CLOCK_MODE_IRC_WITH_PLL || CLOCK_MODE == CLOCK_MODE_SYS_WITH_PLL // set up PLL dividers LPC_SYSCON-&gt;SYSPLLCTRL = 0x23; // M = 3, P = 12MHz // PLLout = 12MHz * (M+1) / P = 48MHz // power up PLL LPC_SYSCON-&gt;PDRUNCFG &amp;= ~(1 &lt;&lt; 7); // wait until PLL is locked while (!(LPC_SYSCON-&gt;SYSPLLSTAT &amp; 1)) ; // switch main clock to be driven from PLL LPC_SYSCON-&gt;MAINCLKSEL = 3; // wait for main clock source to be updated LPC_SYSCON-&gt;MAINCLKUEN = 1; LPC_SYSCON-&gt;MAINCLKUEN = 0; LPC_SYSCON-&gt;MAINCLKUEN = 1; while (!(LPC_SYSCON-&gt;MAINCLKUEN &amp; 1)) ; #endif</span></span></code> </pre><br><br>  The second part initializes the PLL, which at this stage receives a signal from either the IRC or the system oscillator at the input.  We adjust the dividers according to the formula from the instruction, turn on the PLL and wait until it is blocked.  The main frequency after loading works from IRC, we transfer it to work from the output of the PLL and wait until this change is ‚Äúfixed‚Äù. <br><br>  At 48 MHz for SysTick we need 48000000 cycles, but this is more than its maximum value.  One solution is to wait for several timer cycles, which is implemented in the <code>platform_systick_wait_loop</code> function (another option would be to use the 32-bit CT32B0 timer). <br><br>  LPC1768 code, again, is generally similar.  The important point here is that the output from the PLL should be at least 275 MHz, when the input to the processor is no more than 100 MHz.  In general, we carefully check the dividers.  It is also important to note that we increase the number of ticks needed to access flash memory, because we will work at a frequency that deducts than the default value. <br><br>  <code>platform/mbed/init.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// if we go for clock &gt; 80 MHz, we need to set up flash access time LPC_SC-&gt;FLASHCFG = (LPC_SC-&gt;FLASHCFG &amp; 0xFFF) | 0x4000; // 4 cpu clocks</span></span></code> </pre><br><br>  The code shown in the example is relevant <b>only</b> for LPC1768 on mbed, since it is tied to a specific frequency of the crystal.  Moreover, if you are working with LPC1768 "directly", then its bootloader starts with IRC with <b>the</b> PLL <b>turned on</b> , so you need to turn it off in its initializer. <br><br><h4>  Summing up </h4><br>  I also wanted to tell you today about CLKOUT and how you can control the frequency with a logic analyzer or an oscilloscope, but the article would be too big.  CLKOUT, 32-bit timers, interrupts, and sleep modes ‚Äî all of this will be in future releases. <br><br>  I was reached by a box with Stellaris LaunchPad, I‚Äôll think about how best it would be to add another architecture without inflating the story.   , LPC1114    ,        . <br><br>     ¬´¬ª,     . <br><br> PS  ,   <a href="https://habrahabr.ru/users/pfactum/" class="user_link">pfactum</a>        .   ,     :-). <br><br><h6> <a rel="license" href=""><img alt="Creative Commons License" src="https://habrastorage.org/getpro/habr/post_images/a58/dd6/778/a58dd6778494eefb36a9b5ccee5d6187.png"></a>  This work is available under <a rel="license" href="">the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported license</a> .  The program text of the examples is available under <a rel="license" href="http://unlicense.org/">the Unlicense license</a> (unless otherwise indicated in the headers of the files).                  . </h6></div><p>Source: <a href="https://habr.com/ru/post/190032/">https://habr.com/ru/post/190032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190016/index.html">ntdll! LdrHotPatchRoutine & DEP / ASLR bypass (MS13-063)</a></li>
<li><a href="../190020/index.html">Distributed brute-force attack on the CMS from the point of view of the hoster</a></li>
<li><a href="../190022/index.html">Automotive technology. IT look</a></li>
<li><a href="../190024/index.html">Elsevier - my contribution to his fall [translation]</a></li>
<li><a href="../190028/index.html">Little Things to Remember When Using RavenDB</a></li>
<li><a href="../190034/index.html">"Related News" with PHP, phpmorphy and MySQL</a></li>
<li><a href="../190040/index.html">Application of GSM gateway Termit Sprut Universal</a></li>
<li><a href="../190042/index.html">The key to happiness or quality is included. The cry of the soul of the programmer</a></li>
<li><a href="../190044/index.html">Google released HTML5 parser on pure C</a></li>
<li><a href="../190046/index.html">Science under lock and key. The second part of</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>