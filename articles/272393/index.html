<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a ToDo application with Realm and Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the development of smartphones in recent years, many tools have been developed to simplify the lives of developers, ensuring their maximum perfor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a ToDo application with Realm and Swift</h1><div class="post__text post__text-html js-mediator-article">  With the development of smartphones in recent years, many tools have been developed to simplify the lives of developers, ensuring their maximum performance and quality.  Taking a leading position in the App Store today is not an easy task.  And to teach your application to scale even harder.  When the application is used by millions of users, you should monitor the application and, if necessary, perform all operations instantly.  Therefore, one of the problems faced by many developers is Database.  It really causes a headache for each of us, and I think that today you have only two options: SQLite and Core Data.  I was a big fan of Core Data and its ability to work with records and persistent data, but I realized that I wasted a lot of time working with it when developing applications.  Recently, I ran into <a href="https://realm.io/">Realm</a> , the new best replacement for SQLite and Core Data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13d/edf/e36/13dedfe36c5b2749a5ad6cb2a3512262.jpg" alt="Realm and swift"><br><a name="habracut"></a><br><h3>  What is Realm? </h3><br>  Realm is a cross-platform mobile database for iOS (available in Swift &amp; Objective-C) and Android.  Realm was created to be better and faster than SQLite and Core Data.  It is not only better and faster, but also easy to use, so you can do a lot with just a few lines of code.  Realm is completely free and you can use it without any restrictions.  Realm was created for mobile applications, and this is new, since in the last decade, we have not noticed innovations in mobile databases.  Now, to work with a mobile database, you have only one option, which is SQLite or any wrapper that uses SQLite.  Realm is designed to be easy to use, as it is not ORM, and it uses its own persistence mechanism for greater performance and speed. <br><br><h3>  Why Realm? </h3><br>  <a href="https://realm.io/">Realm is</a> incredibly fast and easy to use, you only need a couple of lines of code to perform any task, regardless of whether it reads or writes to the database.  Here I will try to collect all the advantages and reasons why using Realm is the best choice when working with a database in a mobile application: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Easy to install:</b> you will learn about this in the next section about working with Realm.  Install Realm more easily than you can imagine.  Using a simple command in Cocoapods, you will be taken to work with Realm. </li><li>  <b>Fast:</b> Realm is an incredibly fast library for working with a database.  Realm is faster than SQLite and CoreData, and the benchmarks here are the best proof for this. </li><li>  <b>Cross-platform:</b> Realm database files are cross-platform and can be shared between iOS and Android.  Regardless of whether you are working with Java, Objective-C, or Swift, you will use high-level models. </li><li>  <b>Scalable:</b> scalability is very important to consider when developing a mobile application, if the application works with a large number of users and a large number of entries.  You should consider this from the very beginning when designing and choosing tools.  Realm is ready for scalability and work with large amounts of data in the shortest possible time.  You will add speed and anti-aliasing to your application when using Realm. </li><li>  <b>Well documented and have excellent support:</b> The Realm team provided readable, well-organized documentation about Realm.  If you have problems, you can contact them via Twitter, Github or Stackoverflow. </li><li>  <b>Reliable:</b> Realm is used by companies in mobile applications like Pinterest, Dubsmash, and Hipmunk .. </li><li>  <b>Free:</b> with all these amazing features Realm is completely free. </li></ul><br><br><h3>  let's start </h3><br>  Let's get started with Realm, use it to create a simple iPhone application using Swift.  The demo project will be a simple todo application.  The user can add Task to Task Lists (Task Lists), each list can contain several tasks.  The task has a title, notes, a date, an image, and a boolean value that indicate its completion or vice versa.  Before you start working with a project in Xcode.  We must first configure Xcode and install the necessary tools for working with Realm. <br><br><h3>  Requirements </h3><br>  Please consider the following requirements: <br><ul><li>  iOS 8 or higher, OS X 10.9 or higher. </li><li>  Xcode 6.3 or higher. </li><li>  Realm has two versions, one for Swift 2.0 and the other for Swift 1.2.  We recommend using Realm for Swift 2.0.  You can use it for Swift 1.2, but it will no longer be supported by the Realm team in the future, so for security it's better to use Swift 2.0. </li></ul><br><br><h3>  Configuring Xcode and Required Tools </h3><br>  Before you start setting up a project in Xcode, please make sure that you install <a href="http://habrahabr.ru/company/luxoft/blog/149631/">CocoaPods</a> on your computer, since we will use it to install Realm in an Xcode project.  If you are not familiar with <a href="https://cocoapods.org/">CocoaPods</a> , you can familiarize yourself with a few tutorials online, and learn more about <a href="https://cocoapods.org/">getting</a> started. <br><br>  Now, create a new project in Xcode with the ‚ÄúSingle View Application‚Äù template and name it ‚ÄúRealmTasks‚Äù or whatever.  Make sure Swift is selected as a development language.  Now go to the project directory in the terminal and run the following command to initialize CocoaPods. <br><pre><code class="objectivec hljs">pod init</code> </pre> <br>  Then open the pod file generated by the Xcode program and edit it to add the <i>pod 'RealmSwift'</i> right after the target object, so it should look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44c/9d5/493/44c9d54933bd90fafec9dcea346c1a04.png" alt="pod RealmSwift"><br><br>  Next, run the ‚Äúpod install‚Äù command to load the Realm into the project.  After finishing, you will see a new workspace for Xcode, created next to the project file.  Please open the workspace, RealmTasks.xcworkspace you no longer have to open xcodeproj.  After you open the workspace, you will see something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b23/49e/628/b2349e62811448c00bcf158f8bdb7d11.png" alt="workspace"><br><br>  Now Xcode is ready to work with Realm, but you need to install some more tools to make it even easier to work with Realm. <br><br><h3>  Installing Realm plugin for Xcode </h3><br>  The Realm team provided a very useful plug-in for Xcode, which you can use to create Realm models.  To install the plugin, we will use <a href="http://alcatraz.io/">Alcatraz</a> .  For people who do not know what Alcatraz is, this is a very simple and useful open source package manager for automatically installing plugins, templates in Xcode.  To install Alcatraz, simply paste the following command into the terminal and then restart Xcode. <br><pre> <code class="objectivec hljs">curl -fsSL https:<span class="hljs-comment"><span class="hljs-comment">//raw.githubusercontent.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span></span></code> </pre><br>  Then in Xcode, select Window and select Package Manager, as in the following image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/700/700/908/7007009080f6e6315b6a54281b0e5c05.png" alt="Package manager"><br><br>  Then a pop-up window will open, select which plugin or template to install for Xcode in it, in the search panel you can search for any plug-ins or templates to customize your Xcode.  Enter ‚ÄúRealm‚Äù in the search bar and the ‚ÄúRealmPlugin‚Äù plugin will appear, then click <b>Install</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/422/b2f/f2f422b2fae5c4f091b1e7834446513b.png" alt="Realmplugin"><br><br><h3>  Realm browser </h3><br>  The last tool I want to mention is the Realm browser.  This browser helps you read and edit your .realm database files.  These files are created in your application with all the information about the entities, attributes, and records in the database tables.  We have already said that these files can be shared among various platforms like iOS or Android.  To download the scope browser tool, visit the iTunes store to download the latest version.  Open the application, then select Tools -&gt; Generate demo database.  This will create a test realm database file, and you can open and view its contents using a browser.  It will look like this when you open your demo database: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c1/244/e30/1c1244e30e3bea57ea851f0c2ee1fdf6.png" alt="Realm browser"><br><br>  As you can see in the RealmTestClass1 class, there are 1000 entries, and it shows the various types of parameters (columns) of this class.  We will burn about the types of support properties in the following sections. <br><br>  <i>Now everything is ready to work with Realm.</i>  <i>Let's start.</i> <br><br><h3>  Database Model Classes </h3><br>  Now the game has begun!  First we will create model classes or our database.  To create model classes in Realm, simply create ordinary Swift classes that extend the object class.  Think of an Object as the base class for all classes of the Realm model, you can also extend any class that extends the Object at the end.  Once you create your class, you will need properties.  Realm supports various types of properties as follows: <br><pre> <code class="objectivec hljs">‚Äì Int, Int8, Int16, Int32, and Int64 ‚Äì Boolean ‚Äì Float ‚Äì String ‚Äì <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span> ‚Äì <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> ‚Äì Class  Object -    <span class="hljs-string"><span class="hljs-string">'  '</span></span> ‚Äì List &lt;Object&gt; -    <span class="hljs-string"><span class="hljs-string">'  '</span></span></code> </pre><br>  The List, like the Realm class, contains a collection of object instances; see a screenshot of the demo database; the last column was just an array of pointers for existing records in another table.  When working with Realm classes, you should know that you can cope with them, as with any other Swift classes.  For example, you can add methods or protocols and use them like any other Swift class. <br><br>  <i>To chat is not tossing the bags, show me the code!</i> <br><br>  Ok, now let's use the Realm plugin that we installed in Xcode to create the Realm class.  Go to Xcode and create a new file.  On the right sidebar, select Realm: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3de/650/cf9/3de650cf998d9c664db9899743d0da61.png" alt="realm model"><br><br>  Then select Swift and enter the class name as Task.  Now you will see something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98a/37a/b11/98a37ab1131b178636315c8652a58782.png" alt="Task swift"><br><br>  Now the Task class is ready to add new properties. <br><br><h3>  Properties </h3><br>  Of course, we have to add properties to the Task class.  The task will have a name (String), createdAt (NSDate), notes (String) and isCompleted (Bool).  After adding properties, the class will look like this: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Task: Object { dynamic var name = <span class="hljs-string"><span class="hljs-string">""</span></span> dynamic var createdAt = <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>() dynamic var notes = <span class="hljs-string"><span class="hljs-string">""</span></span> dynamic var isCompleted = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// Specify properties to ignore (Realm won't persist these) // override static func ignoredProperties() -&gt; [String] { // return [] // } }</span></span></code> </pre><br>  We added properties for the Task class and added the var prefix to all properties. <br><br>  Then, let's create a TaskList class that will be used to save the task: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TaskList: Object { dynamic var name = <span class="hljs-string"><span class="hljs-string">""</span></span> dynamic var createdAt = <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>() let tasks = List&lt;Task&gt;() <span class="hljs-comment"><span class="hljs-comment">// Specify properties to ignore (Realm won't persist these) // override static func ignoredProperties() -&gt; [String] { // return [] // } }</span></span></code> </pre><br>  The TaskList class has a name, createdAt and List is a task list.  Here we have some comments: <br><br><ul><li>  List &lt;Object&gt; is used for one-to-many relationships, because TaskList has many tasks. </li><li>  The list is very similar to the array created in the methods and accesses objects using an indexed subscript conversion.  List, as you can see, is typed and all objects must be of the same type. </li><li>  List &lt;T&gt; is a generic data type, and this is why we did not add a dynamic property before declaring a task property, because generic properties cannot be represented in Objective-C during the execution of a task. </li></ul><br>  Creating relationships in Realm is quite simple, as you saw in previous implementations for one-to-many relationships.  And as we said for one-to-one relationships instead of a list, we will use an object type.  Consider the following example: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person: Object{ dynamic var name = <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Car: Object{ dynamic var owner:Person? }</code> </pre><br>  In the previous example, the owner property acts as a one-to-one relationship to the Person data model. <br><br>  Now that the main classes have been created, I will continue to discuss with you about Realm, creating a simple ToDo application.  First <a href="https://github.com/hossamghareeb/realmtasks">download the</a> app and watch it.  Run it in Xcode 7 (or higher), and you will see the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/106/411/cdd/106411cddc3a4a5c9d83f71278c6f67f.png" alt="realm-todo-list-app"><br><br>  In the project, I added two view controllers: TasksViewController and TaskListViewController.  The first controller is used to display the task item, while the second controller is used to display all available tasks.  In the list view, click the + button to add a task list.  The selection of the task list will continue on the next screen.  There you can add several tasks. <br><br>  With the main idea of ‚Äã‚Äãthe demo application, now let's see how to add a new task list to the Realm database.  To do this, you will need to process several elements: <br><br><ul><li>  Create a new TaskList model object, and save to Realm. </li><li>  Make a request to read the list from the database to update the user interface </li></ul><br><br>  To save objects to Realm, all you need to do is create a subclass of the object model, and then write the object to Realm.  Here is an example of a snippet of code you need: <br><pre> <code class="objectivec hljs">let taskListA = TaskList() taskListA.name = <span class="hljs-string"><span class="hljs-string">"Wishlist"</span></span> let wish1 = Task() wish1.name = <span class="hljs-string"><span class="hljs-string">"iPhone6s"</span></span> wish1.notes = <span class="hljs-string"><span class="hljs-string">"64 GB, Gold"</span></span> let wish2 = Task(value: [<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Game Console"</span></span>, <span class="hljs-string"><span class="hljs-string">"notes"</span></span>: <span class="hljs-string"><span class="hljs-string">"Playstation 4, 1 TB"</span></span>]) let wish3 = Task(value: [<span class="hljs-string"><span class="hljs-string">"Car"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>(), <span class="hljs-string"><span class="hljs-string">"Auto R8"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>]) taskListA.tasks.appendContentsOf([wish1, wish2, wish3])</code> </pre><br>  We create a task list by creating an instance of the TaskList class and then setting its properties.  Then we create 3 Task type objects (wish1, wish2 and wish3).  Here I demonstrated 3 ways to create Realm objects: <br><br><ol><li>  In the object wish1: just create a class Realm and set properties. </li><li>  In the object wish2: You can pass properties to the dictionary with keys (property names) and values. </li><li>  In the object wish3: You can pass properties using arrays.  The values ‚Äã‚Äãin the array must be in the same order as the corresponding properties in the class model declarations. </li></ol><br><br><h2>  Nested objects </h2><br>  Another feature when creating objects in Realm is nested objects.  This function can be used when you have a one-to-one or one-to-many relationship, which means that you have properties of type Object or List &lt;Object&gt;.  In this case, when you use approach # 2 or # 3, you can replace an object with an array or a dictionary representing its properties.  Here is an example of nested objects: <br><pre> <code class="objectivec hljs">let taskListB = TaskList(value: [<span class="hljs-string"><span class="hljs-string">"MoviesList"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>(), [[<span class="hljs-string"><span class="hljs-string">"The Martian"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>(), <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>], [<span class="hljs-string"><span class="hljs-string">"The Maze Runner"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>(), <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]]])</code> </pre><br>  In the above code, we create a movie list and set the name, createAt, and an array of tasks.  Each task is created using an array of properties.  For example, [‚ÄúThe Maze Runner‚Äù, NSDate (), ‚Äú‚Äù, are true] represents a task with the name, createAt, notes, and the Boolean variable isCompleted or vice versa. <br><br><h3>  Saving objects in Realm </h3><br>  Now you need to know how to create Realm objects and use them at any time, you must save them to the Realm database with write transactions.  When you save data to Realm, you can access these objects in any stream as long as they are stored in Realm.  To complete a write transaction, you must have a Realm object.  An instance of Realm (also referred to as scope) represents the Realm database.  You can create an instance as follows: <br><pre> <code class="objectivec hljs">let uiRealm = try! Realm()</code> </pre><br>  We use to add this line at the top of AppDelegate.swift to share the object across all Swift files.  Later you can easily call a write method like this: <br><pre> <code class="objectivec hljs">uiRealm.write { () -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> uiRealm.add([taskListA, taskListB]) }</code> </pre><br>  First, the uiRealm object is created in the AppDelegate class and will be shared by the application.  The Realm object must be created only once, because it is not multi-threaded and cannot be shared between threads.  If you want to perform a write operation on another thread, then you must create a new Realm object.  I named it as ‚ÄúuiRealm‚Äù, because this instance is defined for the UI stream. <br><br>  Now let's go back to our application, we save the task lists after the user clicks the Create button.  In the TasksViewController displayAlertToAddTask method, we have a createAction object: <br><pre> <code class="objectivec hljs">let createAction = <span class="hljs-built_in"><span class="hljs-built_in">UIAlertAction</span></span>(title: doneTitle, style: <span class="hljs-built_in"><span class="hljs-built_in">UIAlertActionStyle</span></span>.Default) { (action) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let taskName = alertController.textFields?.first?.text <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> updatedTask != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// update mode uiRealm.write({ () -&gt; Void in updatedTask.name = taskName! self.readTasksAndUpateUI() }) } else{ let newTask = Task() newTask.name = taskName! uiRealm.write({ () -&gt; Void in self.selectedList.tasks.append(newTask) self.readTasksAndUpateUI() }) } }</span></span></code> </pre><br>  In the above code, we get the task name from the text field and call the Realm write method to save the task list. <br><br>  Please note that when performing multiple entries at the same time, they block each other and block the flow in which they were executed.  Thus, you should consider running it in a separate thread, not in the UI thread.  Another feature is that, reads are not blocked while you are performing write transactions.  This is useful because your application can perform many read operations. <br><br><h3>  Retrieving Objects </h3><br>  Now that you have learned how to write data to Realm, but it is useless, not knowing how to get it back!  Querying a Realm database is easy.  You have many options for setting and filtering data.  When executing the query in Realm, it returns a list of the Results object.  Just think of Results as a Swift array, because its interface is very similar to an array. <br><br>  When you have a copy of Results, you get the data directly from the disk.  Any data changes (in transactions) will result in data changes on the disk.  In Realm, to query objects, simply call the method of the object with the name of the class as a parameter.  Let's see how to use it to read TaskLists and update the UI: <br><br>  We defined this property in TasksListsViewController: <br><pre> <code class="objectivec hljs">var lists : Results&lt;TaskList&gt;!</code> </pre><br>  And we implement the readTasksAndUpdateUI method as follows: <br><pre> <code class="objectivec hljs">func readTasksAndUpdateUI() { lists = uiRealm.objects(TaskList) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskListsTableView.setEditing(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskListsTableView.reloadData() }</code> </pre><br>  And in the tableView method (_: cellForRowAtIndexPath: _), we display a list of names and the number of tasks inside this list: <br><pre> <code class="objectivec hljs">func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, cellForRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>{ let cell = tableView.dequeueReusableCellWithIdentifier(<span class="hljs-string"><span class="hljs-string">"listCell"</span></span>) let list = lists[indexPath.row] cell?.textLabel?.text = list.name cell?.detailTextLabel?.text = <span class="hljs-string"><span class="hljs-string">"\(list.tasks.count) Tasks"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell! }</code> </pre><br>  Pretty simple, isn't it?  The last thing to do is to call the readTasksAndUpdateUI function in the viewWillAppear method to make sure that the view is always updated when it is opened. <br><pre> <code class="objectivec hljs">override func viewWillAppear(animated: Bool) { readTasksAndUpdateUI() }</code> </pre><br>  This is how we read and write task lists using Realm.  Next, you will learn how to perform an update or delete operation in Realm.  Before we begin, let's go through some code fragments in the project template to edit / delete operations from lists. <br><br>  First we have a Boolean value in TaskListsViewController, called isEditingMode, which is used to switch between edit and normal modes: <br><pre> <code class="objectivec hljs">var isEditingMode = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br>  When you click on the Edit button, the didClickOnEditButton method will be called: <br><pre> <code class="objectivec hljs">@IBAction func didClickOnEditButton(sender: <span class="hljs-built_in"><span class="hljs-built_in">UIBarButtonItem</span></span>) { isEditingMode = !isEditingMode <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskListsTableView.setEditing(isEditingMode, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  This action will enable / disable UITableView editing mode using the setEditing method in UITableView.  In UITableView, a standard action in edit mode will show a ‚Äúdelete‚Äù action in cells, but starting with iOS 8.0, a new method called editActionsForRowAtIndexPath has been added to UITableViewDelegate to customize the actions that will appear in the cells when the user swipes over them. <br><br>  We implement this method to add two actions: delete and edit as follows: <br><pre> <code class="objectivec hljs">func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, editActionsForRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) -&gt; [<span class="hljs-built_in"><span class="hljs-built_in">UITableViewRowAction</span></span>]? { let deleteAction = <span class="hljs-built_in"><span class="hljs-built_in">UITableViewRowAction</span></span>(style: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewRowActionStyle</span></span>.Destructive, title: <span class="hljs-string"><span class="hljs-string">"Delete"</span></span>) { (deleteAction, indexPath) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//Deletion will go here let listToBeDeleted = self.lists[indexPath.row] uiRealm.write({ () -&gt; Void in uiRealm.delete(listToBeDeleted) self.readTasksAndUpdateUI() }) } let editAction = UITableViewRowAction(style: UITableViewRowActionStyle.Normal, title: "Edit") { (editAction, indexPath) -&gt; Void in // Editing will go here let listToBeUpdated = self.lists[indexPath.row] self.displayAlertToAddTaskList(listToBeUpdated) } return [deleteAction, editAction] }</span></span></code> </pre><br>  Here we have added two ways to use UITableViewRowAction actions, which takes an action style, a name, and a handler for handling actions.  Currently, actions will look like this when you slide your finger over a cell or when you click on a destructive button in edit mode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba9/fdf/3d3/ba9fdf3d3fb04b67656cec031c615145.png" alt="edit mode"><br><br>  This is what the application interface looks like for deleting and updating. <br><br><h3>  Deleting Objects </h3><br>  To delete objects and data from the Realm database, you can simply call the delete method of the Realm object, passing the object for deletion.  And, of course, this needs to be done in a write transaction.  Take a look at the following code, which shows how we delete the task list from the database: <br><pre> <code class="objectivec hljs">let listToBeDeleted = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.lists[indexPath.row] uiRealm.write({ () -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> uiRealm.delete(listToBeDeleted) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.readTasksAndUpdateUI() })</code> </pre><br>  After the deletion, we called the readTasksAndUpdateUI function to get new data and update the UI. <br><br>  Instead of deleting one object, there is another function called deleteAll, which allows you to delete all the data for all classes in the database.  This method is very useful when you save data for the current user, and you want to clear the database when it logs out. <br><pre> <code class="objectivec hljs">uiRealm.write({ () -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> uiRealm.deleteAll() })</code> </pre><br><h3>  Upgrade Objects </h3><br>  In Realm, there are many ways to update objects, but all of them must be executed inside a write transaction.  Below we consider some approaches for updating objects. <br><br><h2>  Use of properties </h2><br>  You can update any Realm object simply with a set of properties with a new value inside the record block.  For example, in TasksViewController, we simply change the state of the task by setting the property: <br><pre> <code class="objectivec hljs">uiRealm.write({ () -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> task.isCompleted = <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre><br><h2>  Using primary keys </h2><br>  Realm supports marking a single string or int property on an object as a primary key.  When creating a Realm object using the add () function, if the key already exists, then the object will be updated with new values. <br><br>  Here is an example: <br><pre> <code class="objectivec hljs">let user = User() user.firstName = <span class="hljs-string"><span class="hljs-string">"John"</span></span> user.lastName = <span class="hljs-string"><span class="hljs-string">"Smith"</span></span> user.email = <span class="hljs-string"><span class="hljs-string">"example@example.com"</span></span> user.id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// Updating User with id = 1 realm.write { realm.add(user, update: true) }</span></span></code> </pre><br>  The identifier is set as the primary key.  If a user with id 1 exists, Realm will update the object accordingly.  Otherwise, Realm will insert the object into the database. <br><br><h2>  Using KVC (Key-Value Coding) </h2><br>  If you are an experienced iOS developer, you should be familiar with key-value coding.  Realm classes like Object, Results, and List are KVC compliant.  It helps to set / update properties at runtime.  Another interesting feature of matching KVC in List and Results, is that you can update collection objects as a whole without having to iterate over each object and update them.  I know that you cannot fully understand this.  Let's look at this example: <br><pre> <code class="objectivec hljs">let tasks = uiRealm.objects(Task) uiRealm.write { () -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks.setValue(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, forKeyPath: <span class="hljs-string"><span class="hljs-string">"isCompleted"</span></span>) }</code> </pre><br>  In the code above, I made a request to get all the Task objects, and set isCompleted to true for all returned objects.  This means that I have marked all tasks in the database as completed with just one line of code. <br><br>  Let's go back to our ToDo app.  If you look again at the displayAlertToAddTaskList method, you will find the following code fragment: <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// update mode uiRealm.write({ () -&gt; Void in updatedList.name = listName! self.readTasksAndUpdateUI() })</span></span></code> </pre><br>  It is executed when the user edits the list of names.  We simply update the list of names by setting the name property. <br><br><h3>  Task mapping </h3><br>  I introduced you to most of the code in TaskListViewController.  Now let's take a look at TasksViewController, which is used to display the task item in the task list.  The controller has a UITableView, which is divided into two sections: completed and open tasks.  In TasksViewController, we have these properties: <br><pre> <code class="objectivec hljs">var selectedList : TaskList! var openTasks : Results&lt;Task&gt;! var completedTasks : Results&lt;Task&gt;!</code> </pre><br>  The selectedList is used to store the selected task list passed to TaskListsViewController.  To filter tasks by state: open or completed, we declare two variables: openTasks and completedTask.  For filtering, we will use the magic function <i>filter ()</i> with Realm.  Let's see what it looks like in the code before I explain to you how filtering works: <br><pre> <code class="objectivec hljs">func readTasksAndUpateUI(){ completedTasks = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.selectedList.tasks.filter(<span class="hljs-string"><span class="hljs-string">"isCompleted = true"</span></span>) openTasks = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.selectedList.tasks.filter(<span class="hljs-string"><span class="hljs-string">"isCompleted = false"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tasksTableView.reloadData() }</code> </pre><br>  In the method, we call the filter method to filter the results.  Realm provides an easy way to filter your request using the <i>filter ()</i> method.  A method can be invoked by instances of a list, result, and object.  It returns specific objects based on the condition specified in the filter string.  You can think of a filter as NSPredicate.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, we can say that they are absolutely the same. </font><font style="vertical-align: inherit;">You can create an NSPredicate with a predicate string and pass it to filter the method as if you were filtering completed tasks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at another example:</font></font><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// using predicate string var redCars = realm.objects(Car).filter("color = 'red' AND name BEGINSWITH 'BMW'") // using NSPredicate let aPredicate = NSPredicate(format: "color = %@ AND name BEGINSWITH %@", "red", "BMW") redCars = realm.objects(Car).filter(aPredicate)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above code, we filter these cars by red color, and whose name begins with ‚ÄúBMW‚Äù. </font><font style="vertical-align: inherit;">The first line of code simply uses the filter strings to perform the filtering. </font><font style="vertical-align: inherit;">Alternatively, you can use NSPredicate to achieve the same results. </font><font style="vertical-align: inherit;">Here is a table that briefly describes the most common filter comparison operators:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b89/5a6/da8/b895a6da8d9a0e9d11b4f16ee5af0be4.png" alt="realm-database-info"><br><br><h3>  Sorting </h3><br> ,         Realm,    ,        .  ‚Äî     ,  Realm.  List  Results,    ,    .  ,   ,           .   UI    ,      : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5f/096/c84/d5f096c84dd657f0650eb038b544cb05.png" alt="Screen"><br><br>    ,   ,     : <br><pre> <code class="objectivec hljs">@IBAction func didSelectSortCriteria(sender: <span class="hljs-built_in"><span class="hljs-built_in">UISegmentedControl</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sender.selectedSegmentIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// AZ self.lists = self.lists.sorted("name") } else{ // date self.lists = self.lists.sorted("createdAt", ascending:false) } self.taskListsTableView.reloadData() }</span></span></code> </pre><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realm is a very easy and simple solution for managing local data storage and databases. Realm gives you the ability to scale and simplifies work by writing just a few lines of code. For most applications and even for games, I think you need to use this database, so give it a chance.</font></font><br><br><h3>  What's next? </h3><br>         Realm        ,   <i></i> , <i></i> , <i></i> , <i></i> . Realm      ,    .  ,      ‚Äî   Realm,        . <br><br>     Todo app    <a href="https://github.com/hossamghareeb/realmtasks"></a> . </div><p>Source: <a href="https://habr.com/ru/post/272393/">https://habr.com/ru/post/272393/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272383/index.html">Postulates Go</a></li>
<li><a href="../272385/index.html">True Snowden</a></li>
<li><a href="../272387/index.html">Resources for designers and front-end developers</a></li>
<li><a href="../272389/index.html">Desktop JavaScript applications. Part 1</a></li>
<li><a href="../272391/index.html">The story of how I wrote OS in Minecraft</a></li>
<li><a href="../272395/index.html">PostgreSQL Document Designing API (Part 1)</a></li>
<li><a href="../272397/index.html">Cloud services that help us every day</a></li>
<li><a href="../272399/index.html">Passion for the domain Sex.com</a></li>
<li><a href="../272401/index.html">50 typical gaming camera design errors (part 1)</a></li>
<li><a href="../272403/index.html">The font of your letters spoils your life.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>