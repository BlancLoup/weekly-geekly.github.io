<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python Prefix Trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I recently completed the datrie library, which implements the prefix tree (see Wikipedia or Habr ), with a python . I hasten to share it. 

 In short,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python Prefix Trees</h1><div class="post__text post__text-html js-mediator-article">  I recently completed the datrie library, which implements the prefix tree (see <a href="http://en.wikipedia.org/wiki/Trie">Wikipedia</a> or <a href="http://habrahabr.ru/post/111874/">Habr</a> ), with a <a href="http://habrahabr.ru/post/111874/">python</a> . I hasten to share it. <br><br>  In short, we can assume that datrie.Trie is a replacement for the standard dict, which, under certain conditions (keys - strings), takes up less memory, has a comparable speed of obtaining an individual element and supports additional operations (getting all the prefixes of a given string, getting all strings beginning with this string, etc.), which work about as fast as ‚Äúdictionary‚Äù operations. <br><br>  Works under Python 2.6-3.3, supports unicode, LGPL license. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  <a href="https://github.com/kmike/datrie">datrie</a> is a <a href="https://github.com/kmike/datrie">cython</a> wrapper over <a href="http://linux.thai.net/~thep/datrie/datrie.html">libdatrie</a> .  In libdatrie, a version of the prefix tree is implemented, in which the state machine for transitions between nodes is stored in special 2 arrays + suffix compression is implemented (branches that do not branch are stored in another separate array of "tails").  This is not exactly the ‚Äústate of art‚Äù version of trie (HAT-trie and so on should be faster), but the option is quite fast / efficient and with a good ready implementation (and the implementation can in practice kill any algorithm). <br><br>  The existing variants of trie-shaped structures for python did not suit me.  Pure implementation pitons will inevitably consume a lot of memory, they sweep aside immediately.  Other implementations of trie-shaped structures for python: <br><br><ul><li>  trie.c in biopython.  Does not support Unicode (although this is OK), does not work under 3.x (and in order to make it work under 3.x, you need to rewrite the wrapper well, because the library is implemented as a ‚Äúbare‚Äù C-extension); </li><li>  <a href="https://github.com/buriy/python-chartrie">github.com/buriy/python-chartrie</a> from <a href="https://habrahabr.ru/users/buriy/" class="user_link">buriy</a> is quite fast (__getitem__ faster than datrie as a result), takes a lot of memory (to fix this, you need to change the data structure, i.e., the library base), it‚Äôs not enough functional, does not support unicode (although this is OK); </li><li>  <a href="http://www.dalkescientific.com/Python/PyJudy.html">www.dalkescientific.com/Python/PyJudy.html</a> - old, complex, it is not clear whether it works (it is written that it supports 2.3 and 2.4) </li></ul><br><br>  Maybe there is something else, but, in any case, I didn‚Äôt find the option ‚Äúset - earned - everyone is happy!‚Äù, Therefore I think that I‚Äôve been able to cover up the desire to remember C and understand better in Cython and Python C-API trie implementations for python. <br><br>  Installation (as is usually the case when installing extensions, a compiler is required): <br><br> <code>pip install datrie</code> <br> <br>  Creature: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> string <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datrie trie = datrie.Trie(string.ascii_lowercase)</code> </pre><br><br>  When creating you need to immediately say what keys you can use with this trie (explicitly specify the alphabet or ranges).  This is a libdatrie restriction that allows you to effectively store the state machine and support unicode ‚Äî first, the allowed ranges of unicode characters are specified, then the unicode keys are translated into a more compact internal representation. <br><br>  <i>It seems to me that it would have been possible in practice to get by with single-byte encodings like cp1251 and have approximately the same functionality and efficiency, but the approach with character ranges also works well, it is done well in libdatrie and all right.</i>  <i>I therefore write that ‚ÄúUnicode does not support is OK‚Äù - in the case of trie, single-byte encoding may be a convenient option.</i> <br><br>  Then you can work with trie as with a dictionary: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>trie[<span class="hljs-string"><span class="hljs-string">u'foo'</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; trie[<span class="hljs-string"><span class="hljs-string">u'foobar'</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; trie[<span class="hljs-string"><span class="hljs-string">u'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar value'</span></span> &gt;&gt;&gt; trie.setdefault(<span class="hljs-string"><span class="hljs-string">u'foobar'</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">u'foo'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> trie <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; trie[<span class="hljs-string"><span class="hljs-string">u'foo'</span></span>] <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  The keys must be Unicode :) In Python 3.x it is quite natural, in 2.x in the examples you have to put the letter u, forgive.  Values ‚Äã‚Äãcan be any type of object, which is not typical for C-implementations of trie (usually there are integers as values).  In fact, ‚Äúinside‚Äù values ‚Äã‚Äãand truth are integers, but datrie.Trie uses them as indices in an array of ‚Äúreal‚Äù values.  For those who do not need this feature (for example, they don‚Äôt care for the values ‚Äã‚Äãat all), there is a datrie.BaseTrie in the datrie, which can store only numbers a little faster. <br><br>  A little bit about speed.  All measurements were carried out on a trie.Trie with hundreds of thousands of unique Russian and English words (50/50) and int-values ‚Äã‚Äã"1", other measurements (on a million urls) can be found <a href="http://stackoverflow.com/a/5479374/114795">here</a> or (better still) by yourself on your data .  I carried out speed measurements only in order to have some general idea of ‚Äã‚Äãthe order of magnitudes, and to track the regressions in the library, so take them accordingly;  All source code and data are in the repository.  In addition, I will not write anywhere about the asymptotic complexity of various operations, since  did not explore it.  In theory, it should be like a trie from Wikipedia (for example, getting an element or searching by the prefix - O (m), where m is the key length), but the implementation details (both libdatrie and my wrapper) can change everything;  if someone builds the corresponding graphs, I will, of course, be grateful. <br><br>  The operations of receiving an element, checking in, updating an element work on average 2-3 times slower than the standard dictionary (i.e. fast, on my beech it is from 1 to 3 million operations per second for the above-mentioned trie).  The exception is the insertion of a new value in the trie, it works much slower (about 50 thousand operations per second for the same trie with Russian and English words).  At the same time, trie on such data takes up much less space in RAM: 3-5M (depending on the interpreter) vs 20M + in a regular dictionary <i>(memory measurements were clumsy and I cannot vouch for specific numbers)</i> . <br><br>  Those.  datrie.Trie can be used as a replacement for dict, if there are a large number of not very long lines (for example, words or urls), the data is mainly used in the read-only mode (or ‚Äúupdate-only‚Äù) and I want to save RAM 2-3 times lower access speed. <br><br>  So that this pseudo-read-only is not very embarrassing, trie can be saved to a file and loaded from a file: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>trie.save(<span class="hljs-string"><span class="hljs-string">'my.trie'</span></span>) &gt;&gt;&gt; trie2 = datrie.Trie.load(<span class="hljs-string"><span class="hljs-string">'my.trie'</span></span>)</code> </pre><br><br>  Another trie feature is that some operations that in dict (and any other hash table) would require brute force or large amounts of memory to build additional indexes in the prefix tree work almost as quickly (and some even faster) , just like getting values. <br><br>  You can check if there are elements in trie whose keys start with a given prefix (it is even faster than a simple in check): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>trie.has_keys_with_prefix(<span class="hljs-string"><span class="hljs-string">u'fo'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br><br>  You can find all the prefixes of this string that are in this trie (this is slower, according to tests - 500-600th operations / sec): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>trie.prefixes(<span class="hljs-string"><span class="hljs-string">u'foobarbaz'</span></span>) [<span class="hljs-string"><span class="hljs-string">u'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">u'foobar'</span></span>] &gt;&gt;&gt; trie.prefix_items(<span class="hljs-string"><span class="hljs-string">u'foobarbaz'</span></span>) [(<span class="hljs-string"><span class="hljs-string">u'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), (<span class="hljs-string"><span class="hljs-string">u'foobar'</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)]</code> </pre><br><br>  You can find all items whose keys start with this line: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>trie.keys(<span class="hljs-string"><span class="hljs-string">u'fo'</span></span>) [<span class="hljs-string"><span class="hljs-string">u'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">u'foobar'</span></span>] &gt;&gt;&gt; trie.items(<span class="hljs-string"><span class="hljs-string">u'fo'</span></span>) [(<span class="hljs-string"><span class="hljs-string">u'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), (<span class="hljs-string"><span class="hljs-string">u'foobar'</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; trie.values(<span class="hljs-string"><span class="hljs-string">u'foob'</span></span>) [<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre><br><br>  In the last example, most of the time is now spent on the construction of results, rather than on the search, this can be optimized;  Now the speed was somewhere around 150-300 thousand values ‚Äã‚Äã/ sec (for example, with a prefix of length 7 and an average of 3 values ‚Äã‚Äãit is 70 thousand operations / sec). <br><br>  Datrie.Trie has various methods, help and additional speed measurement results can be found in the README in the repository. <br><br>  Under pypy, everything started on my debian (10 times slower than under cpython);  on a poppy under pypy it didn't start (with a normal python it should work on a poppy, on Linux and under windows).  C API - pypy extensions will always be slow, since  Cpyext works through a crutch, and cython generates the C extension API.  It was possible to write a wrapper on ctypes, but it would be slow under the usual python (and not the fact that fast under pypy) + it is inconvenient to distribute ctypes-extensions.  The guys from pypy are now sawing <a href="https://bitbucket.org/cffi/cffi">cffi</a> , they promise that it will be fast (both under cpython and under pypy).  Plus, it is possible that cython will ever learn how to generate not C extension API, but cffi extensions.  Then, perhaps, happiness will come) In the meantime, I don‚Äôt know what to do with pypy.  Nothing, I guess;  somehow everything works under Linux and all right. <br><br>  In the process of implementation, I crashed with utf_32_le codec in python.  There is a bug with the patch ( <a href="http://bugs.python.org/issue15027">bugs.python.org/issue15027</a> ), but the patch is not committed yet.  Initially, all operations in datrie worked 10 times slower, but then we managed to do in one place without standard utf_32_le encoding a string and it all worked better.  This codec is used in a couple of ‚Äúhot‚Äù places, so I think that if it is accelerated, some operations in the datrie can earn up to 2 times faster. <br><br>  The iteration on the tree now is also not the most effective, this is due to the peculiarities of the libdatrie interface.  But the author of libdatrie is a great person and is going to fix everything, so the prospects are not bad. <br><br>  As usual, patches, bug reports, ideas, benchmarks, pull requests, etc. are welcome! <br><br>  <a href="https://github.com/kmike/datrie">github</a> / <a href="https://bitbucket.org/kmike/datrie">bitbucket</a> , to whom that is more convenient. </div><p>Source: <a href="https://habr.com/ru/post/147963/">https://habr.com/ru/post/147963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147956/index.html">Physics Robocode</a></li>
<li><a href="../147957/index.html">Summer promotion "Quick start!"</a></li>
<li><a href="../147958/index.html">Basics of programming for children and the humanities - no computers in the classroom!</a></li>
<li><a href="../147959/index.html">Attack on Steve Mann due to augmented reality glasses</a></li>
<li><a href="../147960/index.html">Blackberry jam for green men</a></li>
<li><a href="../147964/index.html">Simple automation: photo album</a></li>
<li><a href="../147965/index.html">5 free Microsoft tools for monitoring Active Directory health</a></li>
<li><a href="../147966/index.html">Coursera is a small revolution: +12 universities,> 100 online courses</a></li>
<li><a href="../147969/index.html">Project vs Department</a></li>
<li><a href="../147970/index.html">Wireless chargers: updates, work principles and good news</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>