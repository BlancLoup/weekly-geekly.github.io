<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Radioactivity meter (radiometer) with Glonass receiver and data transmission via Wi-Fi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes a homemade device for measuring radioactivity, determining the coordinates of GLONASS \ GPS and having a channel of exchange via...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Radioactivity meter (radiometer) with Glonass receiver and data transmission via Wi-Fi</h1><div class="post__text post__text-html js-mediator-article"> The article describes a homemade device for measuring radioactivity, determining the coordinates of GLONASS \ GPS and having a channel of exchange via Wi-Fi.  Also described are the internal microprocessor software and an external program (Visual Basic) for receiving, displaying data and writing them to log files. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f6/776/ae8/6f6776ae839ec56e8e35fe8413df660b.jpg"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the last few years I have been engaged in the construction and practical manufacturing of various home automation, control and monitoring of environmental parameters devices during my free time.  Now I have a lot of free time and I got the opportunity to describe what was done. <br><br>  My devices are connected to the home network via Wi-Fi, in the home network there is a silent fanless control machine with a solid-state disk.  This machine performs the functions of the system core, it runs data acquisition programs from a variety of sensors and an external device control program. <br><br>  The task that I wanted to solve with a radiometer, I formulated like this: ‚ÄúI want to have a device that will measure radiation in a general sense‚Äù.  The device must show the level of natural background radiation, respond to changes in this background, have a measurement range of at least the applied sensor and be able to transfer data to an external recorder.  It would be nice to have a search function in the device: when you can move the device near the ‚Äúhot spot‚Äù and find it by changing the readings of the built-in indicators.  It would be nice to have the autonomy of food for a while, for example, walk around the dacha and check if everything is in order. <br><br>  The first question to decide is which sensor to apply.  Studying materials on the measurement of radioactivity gave me an understanding that the optimal sensor for my task is an ordinary Geiger-Muller sensor.  Traditionally, these devices are called ‚ÄúGeiger-Muller counters‚Äù, although in reality they do not consider anything, but give impulses to each particle that could start the avalanche breakdown process in the measuring chamber.  Therefore, I use the term "sensor".  There are a lot of them, for different purposes.  I wanted my device to be sensitive enough to beta radiation, not just gamma.  Widespread and cheap (in the range of 200 - 1000 r) SBM20 are insensitive to beta radiation, they do not have a window that is transparent to beta particles.  The SBM20 is primarily sensitive to gamma radiation, and to a fairly powerful one.  It is clear why they were made for military purposes.  The use of such a sensor in the radiometer requires a large time of data accumulation for more or less adequate measurement of the natural background.  For the SBM20, this time usually takes 46 seconds, while the number of accumulated pulses is equal to the current gamma background value in micro X-rays per hour.  But I wanted more sensitivity to beta radiation.  I did not count on a cataclysm, I was interested in the everyday dimension of small values.  If you want to be ready for a cataclysm, you can search and buy some DP5V from storage, replace three capacitors with good film capacitors and get a military-style device, in a green box, foolproof, suitable for measuring radiation up to 200 roentgens per hour in extreme conditions. <br><br>  I will also note that there are other methods for detecting charged particles, for example, on the basis of scintillation crystals and photomultiplier tubes.  These measurement methods make it possible to measure the distribution of the power spectrum of a radiation flux, but for my purpose it is redundant and very expensive. <br><br>  So, I need a Geiger-Muller counter with beta sensitivity.  Fortunately, these sensors are manufactured in Russia.  I chose the Beta sensors.  They are produced by <a href="http://consensus-group.ru/">NPF Consensus</a> .  A very kind and customer attitude of the plant employees played a certain role in the decision to buy just such a sensor.  I tormented them with stupid Dummy questions and received quite adequate answers to them.  To buy a sensor, I had to go to Zaprudnya.  It is about 100 km on Dmitrovka, almost reaching Dubna.  A desire to see new places also played a role in the decision making about the trip :) <br><br>  The <a href="http://consensus-group.ru/katalog/alfa-beta-gamma-counters/33-beta-2">BETA-2</a> sensor I have chosen has a mica window with an area of ‚Äã‚Äã13.8 cm2 and is sensitive to beta radiation. <br><br>  To work he needs 400v.  An important sensor parameter is recovery time.  The essence of the sensor operation is the ionization of the gas in the chamber during the passage of a charged particle and the subsequent avalanche breakdown, then the additives in the gas come into play and quench the discharge.  The sensor after quenching the discharge takes some time to restore sensitivity.  This time (the term "dead time") is indicated in the characteristics and for specifically Beta-2 is 140 microseconds minimum.  Converting to frequency gives us the maximum pulse frequency from the sensor in the region of 8 kHz. <br><br>  Passport scan: <br><img src="https://habrastorage.org/getpro/habr/post_images/e4a/dc1/918/e4adc19185fd03c889359ab4cd204743.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/9dd/c76/3df9ddc767857e15198f479ed02f7ba1.jpg"><br><br>  There are two methods for retrieving data from a Geiger-Muller counter.  The first is that a resistor in the region of 10 mega ohms is put in series with the anode and a negative pulse is fed through a capacitor with a unit of picofarad and an operating voltage of about 500 volts to the recording circuits.  The pulse is suitable for direct control of the chip's CMOS input. <br>  The second is that a resistor is placed in the cathode circuit and a positive pulse is produced on it, which is fed to the base of the transistor.  With this inclusion is not required high-voltage capacitor. <br>  The standard method recommended by the manufacturer is to remove the signal from the anode.  NPF Consensus experts could not answer why such inclusion is correct.  I received the answer later from the author of the PN400 power converter ‚Äî he believes that a large cathode surrounds the anode and plays the role of a screen for the anode, and such switching on reduces interference and the number of false positives. <br><br>  Schematic diagram of the radiometer <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9a/781/060/a9a7810608431069dc74d49f7456d6d8.jpg"><br><br>  Construction photos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/5d2/a09/3865d2a09127b7fe403f17393f87e798.jpg"><br><br>  The signal from the sensor through the forming protective circuit can be directly fed to the inputs of the microprocessor.  But I decided to put an additional forming element on the dual 564AG1 one-shot one.  The first one-shot creates a pulse of 50 Œºs duration, and the second ‚Äì2.5 ms to feed to the LED.  The LED serves as a trigger indicator and allows you to search for a hot spot by the intensity of the blinking diode.  Initially, I wanted to put two counters - one for beta, the other for gamma.  Therefore, a two-channel timer was used and an HL2 led indicator was supplied to the output of the first channel of the single vibrator. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a9/2e8/a8d/0a92e8a8da6959fed537ab3a6961a871.jpg"><br><br>  After launching the first channel, I was convinced that Beta-2 responds well to the natural background (1), the cost of the second sensor is still high (2) and I also wanted to install a navigation sensor (3).  Of these three reasons, the decision to change the plan appeared, not to put a second gamma sensor, but to put a navigation sensor. <br><br>  Therefore, the SMD LED remained in place, the timing chains of the second channel AG1 were changed (the resistor was increased from 2 to 100 k) and the output of the second channel was output to a large bright red matte LED on the front panel.  A 50 Œºs pulse is clearly visible, but a 2.5 ms pulse is seen perfectly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ae/d6a/d6f/7aed6ad6fb70a7dcf5e207eee7c2932d.jpg">  ÔÅä <br><br>  This hardware solution will also work if Arduino Nano fails, allowing you to navigate the environment by the frequency of the LED blinking. <br>  I didn‚Äôt make sound accompaniment because the main application of the device is the measurement of background activity. <br><br>  As a radiometer processor, I chose the Arduino Nano.  The reasons for this choice are the price (200 rubles from China), small size, a huge number of ready-made solutions and already existing experience of using such boards in homemade products.  The main question was - is there enough processor speed to process the pulses that quickly follow each other?  From the study of similar devices and descriptions of programs, it became clear that the supply of pulses from the counter to the input of the processor and the programming of the interrupt requires a high speed of the processor and serious programming efforts.  However, fortunately, the applied processor has three timers-counters, two of which can be switched to the external pulse counting mode from the outer leg of the processor.  This radically simplifies the task.  It is enough to zero the counter at the beginning of the measurement cycle and at the end read the number of pulses.  The account is performed at the hardware level, without requiring the attention of the processor.  The resource of the processor can be used to exchange data and draw the screen of the device. <br><br>  The algorithm for recalculating the number of accumulated pulses for a certain time is based on the passport characteristic of the counter: <br><br>  Sensitivity to 60 Co imp / ŒºR: 160 √∑ 240 <br><br>  Those.  to calculate the x-ray per hour, you need to know the number of pulses, the time interval and the sensitivity of the counter.  The calculation formula for sensitivity 200 looks like this: <br><br>  R = CT / DELTA_T * 18 <br><br>  Where CT is the number of pulses per DELTA_T interval in seconds, and R is the current value of radiation in micro X-rays per hour. <br><br>  Those interested can derive the formula on their own, it is not difficult :) <br><br>  Measurement of radioactivity is the measurement of the parameters of a stationary random process.  The random process is characterized by expectation and root-mean-square deviation. The smaller the standard deviation, the more accurately we measured the parameters of the random process.  RMS decreases to stationary value with increasing number of pulses.  Those.  the more accurately we want the result, the longer we have to measure. <br><br>  From a practical point of view, this means that for measuring the background and small fluctuations of this background, the measurement time should be long ‚Äî a couple of minutes.  If we want to use the device to search for a ‚Äúhot spot‚Äù - it is desirable to minimize time. <br><br>  To meet both requirements, I made an adaptive measurement algorithm.  To this end, during the pulse counting process, the sketch checks the contents of the counter during each pass and if it is more than a predetermined setpoint (100), then an early exit from the cycle occurs.  If there is no excess, then the counting of pulses goes before the time expires in 120 seconds.  Thus, in the background measurement mode, the measurement takes 120 seconds, which gives the standard deviation 1.3. <br><br>  Screenshot of the Radiometer program, measurement of background values: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/28a/d0f/f4a28ad0f90b9e252f5205a84fd7958b.jpg"><br><br>  If the situation changes dramatically, the score ends much earlier and the readings of both the built-in display and the external receiver are updated much faster.  The setting ‚Äú100‚Äù is selected from the observation of the background measurements, in 2 minutes the number of pulses is usually in the range of 50-80.  When measuring the compass activity, the counting cycle is about 10 seconds, the standard deviation is 17.6: <br>  Screenshot Radiometer, measurement of the radioactivity of the old compass: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/206/9e7/f2a/2069e7f2af80ccb08c1dd4f4f2b3e9f0.jpg"><br><br>  Here is this compass: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b06/1a5/b83/b061a5b831f555cda355520b6be3cc6a.jpg"><br><br>  Here is a photo of the usual situation, the measured background is 11 ŒºR \ h, which is close to normal for Moscow. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c0/827/554/3c082755422bcd1e8915f65b9fb6a6b8.jpg"><br><br>  To power a Geiger-Muller counter, a 400 volt source is required. <br>  I used the ready-made converter PN3-400-0.1M, purchased for 750 p.  These transducers can be purchased through ebay (search for ‚ÄúGeiger counter power supply module 1VV 400V high voltage‚Äù or for ‚ÄúAdjustable telescope‚Äù). <br>  I didn‚Äôt want to wait and I found the author of the product (it turned out to be Moscow region), he recommended one of his representatives in Moscow to me and he was brought to the nearest metro station for cash.  There were no problems with the product, it worked right away and did not cause any questions. <br><br>  I used a rather large housing for the instrument: the Gainta 413, measuring 150 by 80 by 30, bought in Brown Bear.  At first I thought about two Geiger-Muller counters - one for beta, the second for gamma.  It would be possible in one measurement cycle to obtain data immediately on both gamma and beta separately.  Space for the second counter was provided above the first.  However, after launching the system, I saw that with a single sensor, the radiometer does what I want - it cheerfully responds to background radiation, to an old compass, to crystal objects, to thorium welding electrodes, and to a bag of potassium fertilizers.  Therefore, I refused to install the second sensor on the gamut and switched to a backup plan - the placement of Glonass / GPS navigator.  Practical use was thought of as follows: I found a ‚Äúhot spot‚Äù (for example at the dacha), wrote down the coordinates, and handed it over to the MOE for decontamination.  In reality, it was just interesting to try to tinker with the new technology. <br><br>  Beta particles are characterized by low penetrating power.  Even a sheet of paper - a serious obstacle, not to mention the body thickness of about 5 mm.  In order to use all the features of the Beta 2 sensor, I have provided an opening round flap to give Beta radiation direct access to the sensor.  The round hole in the body is made with a circular saw on wood.  The cover is made based on the launcher of domestic intercontinental ballistic missiles.  On the reverse side are attached flat limiters from the debris of a stationery knife, reduced to a rectangular shape on the sharpener.  A magnet from the terminal client kit is used to fix the lid.  In this terminal client such magnets are used as legs.  When working with a magnet, we must remember that the Curie point of this alloy is less than 80 degrees Celsius and overheating will lead to the loss of properties. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/335/4f7/82f/3354f782f2de9acb93430791986847d3.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0f/be0/aee/e0fbe0aee5f9eaa9b7fd005d9eb6f8fd.jpg"><br><br>  The device of the lower part of the body with an opening cover for the passage of beta particles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caf/3d2/949/caf3d2949e48997d5f6d93e8fdad2a97.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/473/10c/583/47310c58390c39a4640762c8be2dd68a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5be/33e/0a1/5be33e0a1be190f9316ba270feb0f57d.jpg"><br><br>  The Beta-2 sensor is placed on the bottom plate in the hole slightly larger than the diameter of the meter.  Under the counter, self-adhesive felt circles are installed, performing the role of spacers between the bottom surface of the sensor and the housing.  The mica sensor window is very thin and requires careful handling.  During final assembly after debugging, I aligned the sensor with the hole in the case and fixed the sensor with hot glue. <br><br>  You need to open the window if you need to measure activity or search for a weak beta emitter. <br>  For example: an old compass with a glowing in the dark composition.  With the lid closed - 70 microroentgen per hour.  With the lid open - 200 microroentgen per hour. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d39/70f/b57/d3970fb577511bb7e080e005aeefa482.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/206/9e7/f2a/2069e7f2af80ccb08c1dd4f4f2b3e9f0.jpg"><br><br>  Measurements of the radioactivity of crystal glassware: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52b/995/5c9/52b9955c92627ff9be33c545c900b6f5.jpg"><br><br><hr><br>  Navigation module <br><br>  At first I found a receiver based on UBLOX7m on ebay GPS \ Glonass.  This device looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b9/a18/b60/3b9a18b60c06791e7ffc7b3d4b0771f7.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5af/223/cad/5af223cad81ca53bcafb57dbe8531577.jpg"><br><br><br>  It is simple to connect - just feed it (+ 3.3V) and connect the 3.3 v connector via the serial.  I used an FT232 based converter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cda/4c2/d85/cda4c2d859cd17030a346a465fbe6e3d.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cd/40d/7fb/0cd40d7fb2a88b63914996c84b67608d.jpg"><br><br>  The branded program allows you to play with the module - get the coordinates of the place, look at the satellites, etc. <br><br>  Screenshot of the ublox program: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fc/991/94c/4fc99194cae874dad238abc2f4685c9a.jpg"><br><br>  Unfortunately, the module, although it can work with the Glonass constellation, but in a truncated version.  First, the module is single channel - i.e.  he can only work with one constellation at a specific time.  Switching the constellation requires reloading the module.  Secondly, when the constellation Glonass is turned on, the module stops working with data from the satellite of the differential correction. <br><br>  I wanted the module to work simultaneously with Glonass and GPS.  There are such modules, in particular, ML8088 of the St. Petersburg firm Navia.  Unfortunately, I did not find a ready-to-use module suitable for installation in a homemade device.  There are ready-made devices on the ML8088, but they were not suitable for my device either in price or size.  And I decided to make my own module :).  I bought a <a href="http://www.dessy.ru/catalog-pdc363027.html">B35-3556920-AMT03 [GPS / GLONASS]</a> antenna and a <a href="http://www.dessy.ru/catalog-pdc345502.html">ML8088s</a> module in <a href="http://www.dessy.ru/catalog-pdc345502.html">DESSY.RU</a> .  The antenna needs a dual-system - the Glonass and GPS have slightly different carrier frequencies. <br><br>  According to the instructions of the manufacturer of the antenna, it should be installed on a conductive base measuring 7 to 7 cm in the center.  It was very successful - a 7 by 7 cm square was precisely placed in my body.  When designing the glonass module, I had to decide how to connect the antenna to the input of the ML8088 module.  The manual should use a microstrip or coplanar line with an impedance of 50 ohms.  Such a line requires reasonably accurate conductor strips on the PCB.  Make it my favorite method of cutting tracks on the board with a stationery knife is difficult.  Having carefully considered the situation, I decided to do without a microstrip line at all and connect the antenna directly to the receiver input.  The manual says - the shorter the transmission line from the antenna to the input, the better.  So, zero length is optimal.  It was necessary to develop a fee, respectively, from the installation of the antenna.  However, when the size of the board is 7 by 7 cm, the displacement of the micromodule does not cause any problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/0b1/9bd/0bf0b19bdb34418fda07fd4cf1a3c305.jpg"><br><br>  This design required a certain sequence of installation elements.  First, it was necessary to glue the antenna, then adjust the ML8088 so that the antenna leg goes into the recess of pin 21 and grab the ML8088 in that position.  Then mark the position of the conclusions ML8088, remove the micromodule, cut through the tracks.  And solder the legs of the chip, taking breaks for cooling.  Unfortunately, I was mistaken and did not tamper with the deepening of the antenna output before soldering the antenna.  The soldering did not work out, the system caught a couple of satellites after an hour of work ... Having considered the situation, I decided to remove the antenna, chew the output and solder the antenna back.  The difficulty is that it is necessary to simultaneously detach the antenna from the base and unsolder the output.  But I was lucky - I put the diagnosis ‚Äúnot drunk‚Äù correctly and the antenna bounced off the leg as soon as I a little bit unstuck the antenna from the base.  Then everything turned out well - the output was tangled, the antenna was soldered and the system worked as it should. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e5/3c7/51d/7e53c751d1ce716ab3c9ae69007cba36.jpg"><br><br>  When diluting the antenna connection, it is imperative to consider the requirement from the documentation - the antenna ground must be connected to pins 20 and 22 and more to not have contact with the common ground.  This is necessary to prevent the formation of earth loops and reduce noise immunity.  Conclusions 20 and 22 of the ML8088 are connected to the ground inside the micromodule. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out that in the factory supply in the ML8088sE there is a firmware firmware that does not support the slow blinking of the output ‚Äúthere is a solution‚Äù. I signed with the manufacturer and received a new firmware and detailed instructions for flashing. I did it all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want to thank Vladimir Osadchy (technical director of </font></font><a href="http://naviaglonass.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), who kindly and patiently answered my questions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was not possible to convert the signal "there is a solution to the navigation problem (GNSS)". This is a signal that flashes at a half-heart rate if the module has solved the navigation task and the data issued by it is correct. The signal amplitude is 1.8 volts and the load capacity of this output is about 2 ma. But the scheme from the manual (ML8088sE inclusion AppNote 1_1.pdf) did not work.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d52/3d2/788/d523d2788860f87959bf038ffee3fdf7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems that there was not enough load capacity to achieve a confident opening of the transistor. The effect was strange - if the system started incorrectly - a sufficient signal was generated at this output to control the conversion circuit and the control LED blinked happily with Morse code. And when the system started correctly, the signal amplitude was smaller and the transistor did not open. According to the developer, the signal should be enough. He brought an oscilloscope from the balcony and made sure that there is a signal, but the level is low, only 0.4 volts ... Vladimir Osadchy called a specific model of the transistor, which works exactly for him, but I went my own way and applied another LM393 junk comparator :). The second channel of this comparator I used to indicate the PPS signal. Along the way, I changed the parameters of the 1PPS signal, made a 200 Œºs long signal.Now I have a comfortable unobtrusive display of the functioning of the system with a short smile :).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final version of the Glonass / GPS module looks like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f70/83b/19b/f7083b19b31b728fea50d559847affb0.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and placed in the case: The </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/58e/be0/929/58ebe0929307a8add696f85d9b7cf264.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upper non-attached connector is designed to fill the firmware into the module. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yellow rectangle of soft plastic - spacer, abutted against Beta-2 when closing the case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ML8088sE module has two exchange channels for the serial port. Navigation data comes one at a time, debug information or firmware follow through the second. By default, the channels are tuned to the speed of 115200. I switched them to 57600. I had to do so because of the speed limitations of the second Wi-Fi channel of the HI-LINK HLK-RM04 module. Details about it below.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I used an external backup battery like CR2032. With it, the start of the module is much faster, since everything necessary for a quick calculation of the positions of the satellites and from capture to tracking mode is already in memory. In this mode, a module reset is usually not required. Reset is needed when you first turn on or if the module did not start correctly. If the module did not start correctly, the LED of the presence of the solution will repeat a certain code cyclically. A reset causes the module to return to normal. In my case, a reset was required after soldering parts. I implemented two independent mechanisms for resetting the module. The first is a regular button, recessed in the case, so as not to interfere and not to accidentally press it. The second is software. At startup, the sketch waits for five seconds, then begins to receive data from the ML8088sE.If there is no data for the timeout interval, the sketch resets the module with a negative pulse from the A0 pin. It is important - when starting the module, it is necessary that the reset pin be in the high-impedance third state. Therefore, after issuing the reset command, I put the output A0 in input mode. The button and the output of Arduino are connected in the "mounting or" mode.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My device </font></font><a href="http://dx.com/p/hi-link-hlk-rm04-serial-port-ethernet-wi-fi-adapter-module-blue-black-214540"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">communicates</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the outside world through the </font><a href="http://dx.com/p/hi-link-hlk-rm04-serial-port-ethernet-wi-fi-adapter-module-blue-black-214540"><font style="vertical-align: inherit;">‚ÄúHI-LINK HLK-RM04 Serial Port-Ethernet-Wi-Fi Adapter Module‚Äù module</font></a><font style="vertical-align: inherit;"> , which is essentially a mini-router with great capabilities. I use it in converter mode, serial port to Wi-Fi. The device has two ports, one can work at speeds up to 115200, the second - up to 57600. Glonass navigator is connected to the second port and therefore the ML8088 exchange rate had to be reduced to 57600. Unfortunately, this module comes from China without an internal antenna and tuned to an external the antenna. The photo in the store has an internal chip antenna. I had to buy external </font></font><a href="http://www.dessy.ru/catalog-pdc349987.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANT 2.4 ESG-2400-12 UFL-F</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> antennas in DESSY.RU and demand from DX a commensurate price reduction. </font></font><a href="http://www.dx.com/p/2-4ghz-ieee-802-11-b-g-n-wi-fi-antenna-for-tablet-pc-163281"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similar antennas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also in DX, it is probably worth buying them immediately when ordering a Wi-Fi module. I tried to connect to the module two different whip antennas from some router and PCI card ‚Äî it works, but the signal level is about 10 dB lower compared to a flat antenna. Plus it is much more convenient when placed inside the case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Wi-Fi module has a 3.3 volt output from the internal stabilizer. It is enough to power the Glonass module ML8088sE.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first channel is used to work with Arduino. The data generated in the Arduino program (from the radiometer) is transmitted to the first channel of the Wi-Fi module and transmitted to the home network. They can be received by any program like PUTTY, which can be connected to the specified IP address and port. Navigator is connected to the second serial port. The data from the navigator also goes to the serial port of Arduino, the program processes the data from the navigator and displays it on the screen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I researched the issue of using the software serial of the port, but I decided that it would not work reliably and would require programming with great effort. So I came up with a hardware hack :).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let me remind you how the transmission of information on the serial port. The serial signal is transmitted by negative drops from +5 to 0. In the initial, inactive state, the signal has a high level (+ 5V). Inside the Arduino Nano, the signal from the FT232 output is transmitted to the serial input of the ATMEGA328P via a protective resistor of 1 kilo. Here is a piece of the concept:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd9/82f/73e/dd982f73e7c13a5a2bc54da4643e60ff.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The top diagram shows the connection of the RX and TX pins inside the Arduino board. The RX Atmega328P pin is directly connected to the pin of the Arduino connector and at the same time via a 1k resistor to the TX pin of the USB serial FT232RL. This makes it possible to transmit the serial date to the connector's pin and the signal will go directly to the desired microprocessor output and be processed correctly if the output of the FT232 is high. This condition is met when the computer does not send anything to Arduino, or Arduino works autonomously without being connected to the computer. In this case, the Atmega328P serial input turns out to be actually pulled to 5 volts through a 1 com resistor, as shown in the bottom diagram. In order not to interfere with the normal transmission of data from a computer via FT232 - you must use the transmitter with an open collector and output it to the closed state,when it is necessary to ensure the regular work of the channel series I just had a number of dual-channel comparators of type LM393, having an open collector type output.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The signal from the serial port of the Glonass module is transmitted through a comparator with an open collector type output. When the processor is reset, output A1 rises to the third state. The comparator's inverting input is actually connected to ground through resistor R11. At the non-inverting input of the comparator there is a positive voltage in the range from 0.4 to 3.3 volts. The output of the comparator is in a fully closed state and does not affect the work of Arduino in any way. The exchange of the microprocessor with the computer, loading the sketch into the memory - everything happens as usual. After starting the sketch, output A1 is switched to exit mode and a high level of +5 volts is set on it. The voltage at the inverting input becomes 1.65 V (half of 3.3V). The comparator begins to work as a repeater series of the signal from the Glonass module.The sketch reads data from the standard serial of the port and processes incoming data. When you start downloading a sketch to Arduino, first FT232 generates a processor reset, output A1 goes to the third state, and the output of the comparator goes to the closed state and ceases to affect the Arduino input series. Data transfer from the Glonass module is terminated and the sketch is loaded in a regular manner.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The LM393 comparator is used simply because there were a lot of them in the box on the table, where they got after dismantling from the gas sensor modules. Naturally, for the implementation of such a hack, you can use another logical element with an open collector type output or a control input to transfer the output to the third state. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method of connecting information flows is called ‚Äúinstallation OR‚Äù.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second channel of the Wi-Fi channel of the module is used for full communication with the ML8088 module for the Navia program supplied by Navia. The program can communicate with the module connected to the serial port. I used the Tibbo program to organize a virtual serial port. Tibbo, unlike similar programs, automatically starts and organizes the channel without the need for manual intervention. I also tried the Virtual serial port driver from </font></font><a href="http://www.hw-group.com/products/hw_vsp/index_en.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWGroup</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It works, but it requires manual manipulations after starting the computer&gt;, this is inconvenient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are a couple of screenshots: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/944/781/739/944781739076482eab0218199836e20a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/412/fae/9a3/412fae9a30f8cfbf2c8707a815662762.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another screenshot, interesting by the presence of a differential correction satellite, it is in the blue circle: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/0a7/f59/2ba0a7f59069294322ad6792587701b7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I run this complex in a virtual machine running VMware workstation.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the screenshots you can see that TIBBO has established a connection with 192.168.1.155:8081 and presented it as virtual serial port COM3. In Navia GLONASS, the communication port COM3 is set and the entire farm automatically takes off steadily when the virtual computer starts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the authors of Navia GLONASS will be interested in finalizing the program so that it can communicate directly not only with the serial port, but also with the TCPIP channel. </font><a href="http://www.dx.com/ru/p/2-2-serial-spi-tft-color-lcd-module-for-arduino-red-silver-234675"><font style="vertical-align: inherit;">Display</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> applied to the device</font></font><a href="http://www.dx.com/ru/p/2-2-serial-spi-tft-color-lcd-module-for-arduino-red-silver-234675"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was bought on the dilkstrime for about 300 p. The display uses a controller ILI9341, of which almost everything is known, there are libraries and extensive experience of use. The only subtlety - the display is powered by +5 volts, and the inputs are designed for 3.3v. If you connect directly with Arduino nano - it will not work, but it will not burn either. I used the simplest converter 5 -&gt; 3.3 -connected resistors 2.7 K. The MOSI signal does not require a resistor - it goes from the display to the processor. The LED signal also does not require conversion.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The standard TFT v2 library with minor modifications was used to work with the display. </font><font style="vertical-align: inherit;">In the standard library, the output of the symbol illuminates the necessary points, but does not erase non-illuminated ones. </font><font style="vertical-align: inherit;">The first time after erasing the screen, everything will be correct, and the second and subsequent ones will not. </font><font style="vertical-align: inherit;">Matrix points will only be turned on, but not turned off, and in a dozen iterations on the screen you will get a rectangle completely lit up with the symbol color. </font><font style="vertical-align: inherit;">I added a piece to the library code that outputs the background color to unused points in the symbol.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changes in library code</font></font></b> <div class="spoiler_text"> old: <br><br> void TFT::drawChar( INT8U ascii, INT16U poX, INT16U poY,INT16U size, INT16U fgcolor) <br>  { <br> if((ascii&gt;=32)&amp;&amp;(ascii&lt;=127)) <br>  { <br>  ; <br>  } <br>  else <br>  { <br> ascii = '?'-32; <br>  } <br> for (int i =0; i&lt;FONT_X; i++ ) { <br> INT8U temp = pgm_read_byte(&amp;simpleFont[ascii-0x20][i]); <br> for(INT8U f=0;f&lt;8;f++) <br>  { <br> if((temp&gt;&gt;f)&amp;0x01) <br>  { <br> fillRectangle(poX+i*size, poY+f*size, size, size, fgcolor); <br>  } <br><br>  } <br><br>  } <br>  } <br><br> new: <br><br> void TFT::drawChar( INT8U ascii, INT16U poX, INT16U poY,INT16U size, INT16U fgcolor) <br>  { <br> if((ascii&gt;=32)&amp;&amp;(ascii&lt;=127)) <br>  { <br>  ; <br>  } <br>  else <br>  { <br> ascii = '?'-32; <br>  } <br> for (int i =0; i&lt;FONT_X; i++ ) { <br> INT8U temp = pgm_read_byte(&amp;simpleFont[ascii-0x20][i]); <br> for(INT8U f=0;f&lt;8;f++) <br>  { <br> if((temp&gt;&gt;f)&amp;0x01) <br>  { <br> fillRectangle(poX+i*size, poY+f*size, size, size, fgcolor); <br>  } <br>  else <br>  { <br> fillRectangle(poX+i*size, poY+f*size, size, size, BLACK); <br>  } <br><br>  } <br><br>  } <br>  } <br></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also had to change the pieces of code responsible for jerking the legs of RESET and CS. </font><font style="vertical-align: inherit;">The library is designed to use D4 and D5 pins, and I needed them to work with timers. </font><font style="vertical-align: inherit;">Therefore, the display pins are connected to pins D8 (Reset) and D9 (CS) and the following changes are made to the code:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changes in library code</font></font></b> <div class="spoiler_text"> old: <br><br> #define TFT_RST_LOW {DDRD |= 0x10;PORTD &amp;=~ 0x10;} //Added by Vassilis Serasidis (18 Oct 2013) <br> #define TFT_RST_HIGH {DDRD |= 0x10;PORTD |= 0x10;} //Added by Vassilis Serasidis (18 Oct 2013) <br> #define TFT_CS_LOW {DDRD |= 0x20;PORTD &amp;=~ 0x20;} <br> #define TFT_CS_HIGH {DDRD |= 0x20;PORTD |= 0x20;} <br><br> new: <br><br> #define TFT_RST_LOW {DDRB |= 0x01;PORTB &amp;=~ 0x01;} //changed by Sergey Dronsky 26 dec 2013 <br> #define TFT_RST_HIGH {DDRB |= 0x01;PORTB |= 0x01;} //changed by Sergey Dronsky 26 dec 2013 <br> #define TFT_CS_LOW {DDRB |= 0x02;PORTB &amp;=~ 0x02;} //changed by Sergey Dronsky 26 dec 2013 <br> #define TFT_CS_HIGH {DDRB |= 0x02;PORTB |= 0x02;} //changed by Sergey Dronsky 26 dec 2013 <br></div></div><br><br>  The full text of the program and the modified libraries can be found <a href="">here.</a> <br><br>  In the final version of the device, only the T1 counter is engaged, counting the pulses from the D5 pin.  Conclusion D4 remained untapped. <br><br>  Since the device is designed for use in the 24 by 7 mode, I took measures against the screen burn-out effect.  All elements displayed on the screen change color randomly and move around the screen a bit too randomly.  I can not say that it is very necessary for proper operation, but programming was fun :) <br><br>  The device is powered through the mini usb connector on the Arduino.  The internal battery was not provided for, and to ensure the ability to work autonomously - for example, to check the garden area, a 4000 mAh power bank was purchased.  Measurements showed that the actual capacity is about 3000 mah, but this capacity is enough for the radiometer to work for more than 10 hours.  Walk around the cottage is enough in abundance. <br>  To receive and process data, use the Radiometer program, written in Visual Basic in the Visual StudioExpress 2012 environment. <br><br>  The program receives data from the radiometer in the background stream, displays the received data in the form of text and graphics: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/28a/d0f/f4a28ad0f90b9e252f5205a84fd7958b.jpg"><br><br>  The program has a mechanism for reconnecting in case of a signal failure.  If the channel has fallen and there is no data after the specified timeout has expired, the program will close the channel, clean the ‚Äútails‚Äù and open the channel again.  And it will do so until the connection is restored.  In the case of a radiometer, the timeout is set to 3 minutes.  The normal data arrival interval is 2 minutes.  The program correctly performs and disconnects - switching on the transmitting module, Wi-Fi access point or any connected equipment along the data flow path. <br>  The channel opening and closing events are written to the log.  Also marked the event start and stop the program. <br>  Data and events are separately written to two separate text files. <br>  When the timer is triggered, once every 10 minutes, the program for recording statistics in a log file is executed. <br><br>  Upon the arrival of data from the channel, they are placed in a buffer and, when certain conditions are reached, this buffer is sent to the input data processing program.  In this program, the condition is that the last bytes of the string are equal to vbCrLf (i.e., Hex (0D0A), they are also the characters "carriage return", "return string"). <br><br>  The processing routine checks the input string for formal validity using a regular expression mechanism.  If the line has an invalid format - this is left a mark in the log file.  If the string has a valid format, the program splits the string into elements using a regular expression mechanism, resulting in an array of elements. <br><br>  Further processing consists in entering the necessary elements into arrays of the ‚ÄúFIFO queue‚Äù type (QUEUE). <br><br>  The QUEUE array calculates the maximum, minimum, average, and the standard deviation.  To calculate the maximum, minimum and average, the ready-made methods of the object are used.  The calculation of the standard deviation is done by outputting the elements of the queue to the array and processing this array.  As far as I was able to understand from the documentation, you can make your own method, but it did not happen with a swoop and I left it for the future :). <br><br>  The length of the queue is chosen to be 2400 elements, which, given the data arrival interval of two minutes, gives a background image of radioactivity approximately 80 hours ago. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/518/183/285/518183285d648ce40c52010387ded278.jpg"><br><br>  The peak on the graph is the result of a compass offering. <br><br>  The program can be downloaded <a href="">here.</a> <br><br>  Description of the sketch in Arduino. <br><br>  Block ‚Äìsketch scheme: <br><br>  Run the program <br>  Display initialization <br>  Initialization of timer T1, transfer it to the pulse counting mode from an external input. <br>  Initialization of the serial exchange at a speed of 57600 <br>  Sketch basic loop <br>  Counter reset <br>  Memorizing start time <br>  Receive data from the serial port, search message 1 ("$ GPRMC") <br>  Receive data from the serial of the port, search for message 2 ("$ GPGGA") <br>  Receive data from the serial port, search message 3 ("$ GPVTG") <br>  Parsing and displaying data from GLONASS \ GPS <br>  Displays the current state of the T1 counter <br>  Check the condition of the end of the cycle - the time has expired or the counter counted more than 100 pulses <br>  Fixing meter and timer readings <br>  Calculation of radioactivity <br>  Display output <br>  Output to the series channel <br><br>  Description of the output to the built-in display. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83d/94e/a6f/83d94ea6f2d6382ddfea1200422ce5d1.jpg"><br><br>  The first line shows the number of registered pulses in the process of measuring radioactivity.  The number changes about once a second. <br><br>  The second line shows the calculated value of radioactivity in the previous cycle. <br><br>  Next is a block of four lines.  This is the output of information from the Glonass \ GPS module. <br><br>  The first line - UTC time, date, number of satellites, the data from which were used in the solution calculation, a sign of the solution (letter A or V) <br>  095623 140514 08 A - 9:56:23 UTC 05/14/2014 8 satellites and there is a solution. <br><br>  The second line is the latitude and speed in km / h. <br>  5545.13119 N means 55 degrees 45.13119 minutes north latitude <br><br>  Third row longitude <br>  03739.20397 E means 37 degrees 39.20397 minutes east <br><br>  The fourth is the speed in miles per hour, the angle of movement in degrees and the height in meters. <br><br>  The output of GLONASS \ GPS data is made simply - parts of the character strings are simply output without any conversion. <br><br>  Next, the maximum value of the radioactivity at the time of observation is displayed. <br>  A running graph shows the change in radioactivity over time.  The graph automatically adjusts to the maximum value in the ring buffer.  When you bring a compass, we get the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb6/91b/74b/bb691b74bf621e58a8d0ba22d465985b.jpg"><br><br>  I will be glad to answer questions. </div><p>Source: <a href="https://habr.com/ru/post/222891/">https://habr.com/ru/post/222891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222875/index.html">Java OSM Geocoder</a></li>
<li><a href="../222877/index.html">We program stm32 microcontrollers with QtCreator</a></li>
<li><a href="../222883/index.html">Adaptive interface for transformers on the example of Krita Gemini</a></li>
<li><a href="../222885/index.html">bb-mobile micrON-4: headset with the form of a phone with support for SMS and notifications</a></li>
<li><a href="../222887/index.html">International Agile Consortium ICAgile: Agile, Lean and all-all</a></li>
<li><a href="../222895/index.html">2GIS showed new</a></li>
<li><a href="../222903/index.html">Wikiroutes 1.0</a></li>
<li><a href="../222905/index.html">Making a media matrix on the knee</a></li>
<li><a href="../222907/index.html">Tron fan created for himself a virtual reality with the help of 3 Kinect and Oculus Rift</a></li>
<li><a href="../222915/index.html">When will we take off? Overview of flying cars (and motorcycle)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>