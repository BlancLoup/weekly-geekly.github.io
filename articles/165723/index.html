<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Advanced VIM Setup</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the rules for effective use of the editor says the following - determine what you spend most time typing, and improve it. 
 As practice shows, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Advanced VIM Setup</h1><div class="post__text post__text-html js-mediator-article">  One of the rules for effective use of the editor says the following - determine what you spend most time typing, and improve it. <br>  As practice shows, often users of this editor are limited to installing options, which of course is not small.  Then they put some plugin-mega-pack on the advice of experts, and everything seems to be fine, except ... first, second, third ... <br>  But if you go further, you can find an infinite potential for increased productivity in the use of its editor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1f/274/3d7/c1f2743d7e80895892d94f35c78ec940.jpg"><br><br>  In this article I will try to describe a slightly advanced way to tweak Vim. <br>  We will consider internal scripting with you and we will understand that there is nothing terrible in it, an ordinary scripting language. <br>  This material is designed for fairly trained users of the editor Vim.  For those who figured out what are editor modes, buffers, windows.  The article is written in the style of "One chapter - one specific recipe - one description of the syntactic structure of the language." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Change history or if else statement </h4><br>  Here is an example of using an if statement in your vimrc to set options <br><pre><code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> version &gt;= 700 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>=64 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> undolevels=128 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> undodir=~/.vim/undodir/ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> undofile <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> undolevels=1000 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> undoreload=10000 endif</code> </pre> <br>  This piece of code includes very useful features available since version 7.00: after you close the editor (or, more precisely, the current buffer), in previous versions the history of UNDO-REDO was lost.  Starting from 7.00, it became possible to record this history in service files for each previously opened buffer. <br>  That is, now you can change the buffer, close the window, turn off the editor altogether, but by opening again any file, the history of your changes will be restored. <br><br><h4>  Fast switching buffers or creating your own function </h4><br>  Switching between loaded buffers should be fast.  It is not very convenient to constantly dial: bn,: bp,: b #.  Therefore, we will create our own switching function and hang this functionality on the hotkeys. <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! ChangeBuf(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (&amp;modified &amp;&amp; &amp;modifiable) execute <span class="hljs-string"><span class="hljs-string">":w"</span></span> endif execute a:cmd endfunction nnoremap &lt;silent&gt; &lt;Co&gt; :call ChangeBuf(<span class="hljs-string"><span class="hljs-string">":b#"</span></span>)&lt;CR&gt; nnoremap &lt;silent&gt; &lt;Cn&gt; :call ChangeBuf(<span class="hljs-string"><span class="hljs-string">":bn"</span></span>)&lt;CR&gt; nnoremap &lt;silent&gt; &lt;Cp&gt; :call ChangeBuf(<span class="hljs-string"><span class="hljs-string">":bp"</span></span>)&lt;CR&gt;</code> </pre><br>  As you know, if the file is modified, the commands: bn,: bp, b # will not work and will display a warning that you need to save it.  For this we write this function, in which we check whether the file is modified and whether it can be modified at all. <br>  Here we create a function whose argument will take just those commands for switching buffers, described above. <br>  nnoremap creates a binding of a specific key combination for an action.  Argument \ &lt;silent \&gt; - suppress echo output. <br><br>  <sub>Here it is necessary to give some explanation on the variables in .vimrc, namely, almost all of them begin with some prefix, separated from the name by a colon.</sub>  <sub>Prefix means scope.</sub>  <sub>Here are the basic prefixes:</sub> <sub><br></sub>  <sub>a: var - function argument</sub> <sub><br></sub>  <sub>b: var - variable for current buffer</sub> <sub><br></sub>  <sub>g: var - global variable</sub> <sub><br></sub>  <sub>l: var is a variable declared in the function body</sub> <sub><br></sub>  <sub>v: var - global defined in the Vim editor itself</sub> <br><br><h4>  Buffer list or for loop </h4><br>  I do not really like the output of buffers on the command: ls, if only because the output is multiline.  Therefore, we analyze an example with a for loop to display a list of open buffers in one line.  The advantage of this solution is that I can call this function anywhere, including in the method described in the previous section.  It turns out that when you change the current buffer, a list of other open buffers will be immediately displayed. <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! BufList() <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> status = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(1, last_buffer_nr()+1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bufnr(<span class="hljs-string"><span class="hljs-string">"%"</span></span>) == i <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> status = status . <span class="hljs-string"><span class="hljs-string">' '</span></span> . <span class="hljs-string"><span class="hljs-string">'['</span></span> . bufname(i) . <span class="hljs-string"><span class="hljs-string">']'</span></span> <span class="hljs-string"><span class="hljs-string">"  continue endif if buflisted(i) let status = status . ' ' . bufname(i) endif endfor return status endfunction</span></span></code> </pre><br>  Here we simply form a line with a list of open buffers.  We select the current buffer in square brackets. <br>  As we can see, the for loop is very similar to the loop from the same Python. <br><br>  <sub>Here it is necessary to point out that a number of functions of the Vim editor accept the so-called expression as an argument.</sub>  <sub>For the function bufnr () for example, the expression may be, for example, the character "%" gives the number of the current buffer, "$" gives the number of the last buffer.</sub>  <sub>For each function, it's better to still watch: help func ()</sub> <sub><br></sub> <br><br><h4>  Automatically executable script or reading data from the current buffer </h4><br>  I often start writing new scripts.  And it is convenient for me that the file can be immediately executable. <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ModeChange() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> getline(1) =~ <span class="hljs-string"><span class="hljs-string">"^#!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> getline(1) =~ <span class="hljs-string"><span class="hljs-string">"bin/"</span></span> silent !chmod a+x &lt;afile&gt; endif endif endfunction au BufWritePost * call ModeChange()</code> </pre><br>  Here we take and read the first line from the file, and if it starts with '#!'  and there is a 'bin /' in it, then we make the file executable.  After we hang the autocommand on the BufWritePost event. <br><br><h4>  Automatic preparation of the script or insert into the current buffer </h4><br>  This example is related to the previous one.  If we start writing a new script in python, it would be convenient if there was immediately a blank in it, for example, the main function, some imports, the interpreter definition line.  Let's demonstrate. <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! WritePyinit() <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> @q = <span class="hljs-string"><span class="hljs-string">" \#\!/usr/bin/env python\n\#-*- encoding: utf-8 -*-\n\nimport sys, warnings\n\nwarnings.simplefilter('always')\n\ndef main(argv=sys.argv):\n pass\n\nif __name__ == \"__main__\":\n sys.exit(main())\n"</span></span> execute <span class="hljs-string"><span class="hljs-string">"0put q"</span></span> endfunction autocmd BufNewFile *.py call WritePyinit()</code> </pre><br>  It's simple.  If you have a new * .py file, the standard code will be added to it. <br><div class="spoiler">  <b class="spoiler_title">New test.py file</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python #-*- encoding: utf-8 -*- import sys, warnings warnings.simplefilter('always') def main(argv=sys.argv): pass if __name__ == "__main__": sys.exit(main())</span></span></code> </pre><br></div></div><br><br><h4>  Automatic documentation or write vimrc with Python syntax </h4><br>  This article would not be complete if I didn‚Äôt show how to insert into .vimrc in another programming language.  I'll show it on the example of Python. <br>  The code must be documented.  Python documentation is often written as DocStrings.  Let us show an example of how it is possible by the combination of the keys to automatically be transferred to the place where the documentation should be. <br><div class="spoiler">  <b class="spoiler_title">Autodocumentation</b> <div class="spoiler_text"><pre> <code class="python hljs">function! WriteDocstrings() python &lt;&lt;EOF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vim <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re linenr = vim.current.window.cursor[<span class="hljs-number"><span class="hljs-number">0</span></span>] indentr = vim.current.window.cursor[<span class="hljs-number"><span class="hljs-number">0</span></span>] line = vim.current.line n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i != <span class="hljs-string"><span class="hljs-string">' '</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> n += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(line) == <span class="hljs-number"><span class="hljs-number">0</span></span>: n = <span class="hljs-number"><span class="hljs-number">0</span></span> vim.current.buffer.append(<span class="hljs-string"><span class="hljs-string">' '</span></span>*n + <span class="hljs-string"><span class="hljs-string">' '</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-string"><span class="hljs-string">'"""'</span></span>, linenr) vim.current.buffer.append(<span class="hljs-string"><span class="hljs-string">' '</span></span>*n + <span class="hljs-string"><span class="hljs-string">' '</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span>, linenr) vim.current.buffer.append(<span class="hljs-string"><span class="hljs-string">' '</span></span>*n + <span class="hljs-string"><span class="hljs-string">' '</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-string"><span class="hljs-string">'"""'</span></span>, linenr) vim.current.window.cursor = (vim.current.window.cursor[<span class="hljs-number"><span class="hljs-number">0</span></span>]+<span class="hljs-number"><span class="hljs-number">2</span></span>, n+<span class="hljs-number"><span class="hljs-number">4</span></span>) EOF endfunction</code> </pre></div></div><br>  Again, nothing tricky, ordinary HERED-Docs. <br>  Here we use the module for Python vim.  Next, we search for the beginning of the current block, insert quotes for documentation there, and move the cursor to the beginning of the future documentation. <br><br>  <sub>You need to take into account that in order for this code to work, you need python support in your vim.</sub>  <sub>You can check this as follows:</sub> <sub><br></sub> <pre> <sub><code class="bash hljs">vim --version | grep <span class="hljs-string"><span class="hljs-string">'+python'</span></span></code></sub> </pre> <sub><br></sub>  <sub>If there is support, then everything is fine.</sub>  <sub>If not, you must either build Vim yourself, or put another package.</sub>  <sub>In Debian / Ubuntu / Mint, I recommend installing the vim-nox package.</sub> <sub><br></sub> <pre> <sub><code class="bash hljs">apt-get install nox</code></sub> </pre> <sub><br></sub> <br><br><h4>  Conclusion </h4><br>  The article was quite voluminous.  I hope I showed that you can add little features to your editor quite simply. <br>  Now, having understood the basic principles of advanced editor settings, you can write more useful additions, for example, commenting on a block of selected text, opening documentation of any functions. <br><br><h6>  List of useful materials </h6><br>  <a href="http://www.vim.org/">Vim official website</a> <br>  <a href="http://vimdoc.sourceforge.net/htmldoc/">VIMDOC, with hyperlinks</a> <br>  <a href="http://vimdoc.sourceforge.net/htmldoc/if_pyth.html">Vim for python module documentation</a> <br><br><div class="spoiler">  <b class="spoiler_title">UPD1: vimrc peeled off</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span> Comments/uncomments strings and selected text <span class="hljs-string"><span class="hljs-string">" When buffer changing try to save it "</span></span> Convinient view of statusline <span class="hljs-string"><span class="hljs-string">" AutoResave sessions on exit "</span></span> Auto settings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> DJANGO omni completion <span class="hljs-string"><span class="hljs-string">" "</span></span>Mapped Keys <span class="hljs-string"><span class="hljs-string">" Mode Combination Description "</span></span> N &lt;Cn&gt; Next buffer with saving <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> possible <span class="hljs-string"><span class="hljs-string">" N &lt;Cp&gt; Prev buffer with saving if possible "</span></span> N &lt;Co&gt; Last viewed buffer <span class="hljs-string"><span class="hljs-string">" N &lt;Ce&gt; Clear highlighting after searching "</span></span> I &lt;Cq&gt; Set normal mode <span class="hljs-string"><span class="hljs-string">" N &lt;Cc&gt; Comment Lines "</span></span> N &lt;Cu&gt; Uncomment Lines <span class="hljs-string"><span class="hljs-string">" I &lt;C-Space&gt; Show popup menu OmniCompletion "</span></span> I &lt;Tab&gt; If popupmenu is showed list it elements <span class="hljs-string"><span class="hljs-string">" NIV &lt;F5&gt; Bonding Mode(useful when pasting from X-buffer) "</span></span> I &lt;Ah&gt; Left <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> insert mode <span class="hljs-string"><span class="hljs-string">" I &lt;Aj&gt; Down in insert mode "</span></span> I &lt;Ak&gt; Up <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> insert mode <span class="hljs-string"><span class="hljs-string">" I &lt;Al&gt; Right in insert mode "</span></span> N ,p Paste after <span class="hljs-string"><span class="hljs-string">" N ,P Paste before "</span></span> N &lt;Cj&gt; Down <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> long line <span class="hljs-string"><span class="hljs-string">" N &lt;Ck&gt; Up in long line "</span></span> V &lt;Cc&gt; Comment Line <span class="hljs-string"><span class="hljs-string">" V &lt;Cu&gt; Uncomment Line filetype on filetype plugin on set tabstop=4 set shiftwidth=4 set smarttab set expandtab set softtabstop=4 set autoindent let python_highlight_all = 1 set t_Co=256 autocmd FileType html,xhtml,xml,htmldjango,htmljinja,eruby,mako setlocal noexpandtab autocmd FileType *.py set tw=80 autocmd FileType python nnoremap &lt;Ca&gt; :call WriteDocstrings()&lt;CR&gt; "</span></span>nnoremap &lt;Ca&gt; :call WriteDocstrings()&lt;CR&gt; autocmd BufWritePre *.py normal m`:%s/\s\+$//e `` autocmd BufRead *.py <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> smartindent cinwords=<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">elif</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">while</span></span>,try,except,finally,def,class autocmd BufNewFile *.py call WritePyinit() autocmd VimLeave * !reset <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nu <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ruler <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> mousehide syntax on <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> backspace=indent,eol,start whichwrap+=&lt;,&gt;,[,] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> showtabline=0 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> foldcolumn=1 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> wrap <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> linebreak <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> nobackup <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> noswapfile <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> encoding=utf-8 <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> fileencodings=utf8,cp1251 <span class="hljs-string"><span class="hljs-string">"Searchig options set showmatch set hlsearch set incsearch "</span></span>Layouts <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> fencs=utf-8,cp1251,koi8-r,ucs-2,cp866 <span class="hljs-string"><span class="hljs-string">"memory, history, undotree if version &gt;= 700 set history=64 set undolevels=128 set undodir=~/.vim/undodir/ set undofile set undolevels=1000 set undoreload=10000 endif "</span></span>Sessions -   , . <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sessionoptions=buffers,tabpages,<span class="hljs-built_in"><span class="hljs-built_in">help</span></span>,blank,globals,localoptions,sesdir,slash,options <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! SaveSession(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v:this_session != <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Tmp(filename) execute <span class="hljs-string"><span class="hljs-string">":mksession! "</span></span>.v:this_session endfunction autocmd VimLeavePre * :call Tmp(<span class="hljs-string"><span class="hljs-string">"xxx"</span></span>) endif endfunction au SessionLoadPost * :call SaveSession() <span class="hljs-string"><span class="hljs-string">"Titles, statuses set laststatus=2 set showtabline=2 set title set statusline=%1*%m%*%2*%r%*%3*%h%w%*%{expand(\"%:p:~\")}\ %&lt; set statusline+=%=Col:%3*%03c%*\ Ln:%3*%04l/%04L%* set statusline+=%(\ File:%3*%{join(filter([&amp;filetype,&amp;fileformat!=split(&amp;fileformats,\",\")[0]?&amp;fileformat:\"\",&amp;fileencoding!=split(&amp;fileencodings,\",\")[0]?&amp;fileencoding:\"\"],\"!empty(v:val)\"),\"/\")}%*%) set titlestring=%t%(\ %m%)%(\ %r%)%(\ %h%)%(\ %w%)%(\ (%{expand(\"%:p:~:h\")})%)\ -\ VIM "</span></span>autocmd VimLeavePre * silent mksession! ~/.vim/lastSession.vim <span class="hljs-string"><span class="hljs-string">"autocmd VimEnter * silent source! ~/.vim/lastSession.vim "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">" set langmap=q,w,e,r,t,y,u,i,o,p,[,],a,s,d,f,g,h,j,k,l,\\;,',z,x,c,v,b,n,m,\\,,.,`,Q,W,E,R,T,Y,U,I,O,P,{,},A,S,D,F,G,H,J,K,L,:,\\"</span></span>,Z,X,C,V,B,N,M,&lt;,&gt;,~ <span class="hljs-string"><span class="hljs-string">"Buffers function! ChangeBuf(cmd) if (&amp;modified &amp;&amp; &amp;modifiable) execute "</span></span>:w<span class="hljs-string"><span class="hljs-string">" endif execute a:cmd endfunction nnoremap &lt;silent&gt; &lt;Co&gt; :call ChangeBuf("</span></span>:b<span class="hljs-comment"><span class="hljs-comment">#")&lt;CR&gt; nnoremap &lt;silent&gt; &lt;Cn&gt; :call ChangeBuf(":bn")&lt;CR&gt; nnoremap &lt;silent&gt; &lt;Cp&gt; :call ChangeBuf(":bp")&lt;CR&gt; nnoremap &lt;C-CR&gt; O&lt;ESC&gt;j inoremap &lt;Cq&gt; &lt;ESC&gt; nnoremap &lt;Ce&gt; :nohlsearch&lt;CR&gt; inoremap &lt;Ce&gt; &lt;ESC&gt;I inoremap &lt;Ca&gt; &lt;ESC&gt;A function! BufList() let status = "" for i in range(1, last_buffer_nr()+1) if bufnr("%") == i let status = status . ' ' . '[' . bufname(i) . ']' continue endif if buflisted(i) let status = status . ' ' . bufname(i) endif endfor return status endfunction "Copy/Paste if has("clipboard") set clipboard=autoselect endif "Autoaddition set formatoptions-=o "scripting function ModeChange() if getline(1) =~ "^#!" if getline(1) =~ "bin/" silent !chmod a+x &lt;afile&gt; endif endif endfunction au BufWritePost * call ModeChange() if expand("%:t") =~ "py$" set makeprg=python endif if expand("%:t") =~ "sh$" set makeprg=/bin/bash endif if !has("gui_running") imap &lt;C-@&gt; &lt;CX&gt;&lt;CO&gt; else imap &lt;C-Space&gt; &lt;CX&gt;&lt;CO&gt; endif filetype plugin on set ofu=syntaxcomplete#Complete set complete=.,b,t,k,u,k set completeopt-=preview set completeopt+=longest autocmd FileType python set omnifunc=pythoncomplete#Complete autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS autocmd FileType html set omnifunc=htmlcomplete#CompleteTags autocmd FileType css set omnifunc=csscomplete#CompleteCSS if expand("%:t") =~ "^.*\.py$" let $PYTHONPATH = fnamemodify("%", ":p:h:h") let $DJANGO_SETTINGS_MODULE = fnamemodify("%", ":p:h:t").".settings" endif set completeopt=longest,menuone "    "set paste "set nopaste "set invpaste set pastetoggle=&lt;F5&gt; "Folding set foldenable set foldmethod=syntax autocmd FileType tex set foldmethod=indent "  "color blackboard let g:solarized_termcolors=256 colorscheme solarized set background=dark "Remaps inoremap &lt;Ah&gt; &lt;Co&gt;h inoremap &lt;Aj&gt; &lt;Co&gt;j inoremap &lt;Ak&gt; &lt;Co&gt;k inoremap &lt;Al&gt; &lt;Co&gt;l nnoremap ,p o&lt;ESC&gt;p nnoremap ,P O&lt;ESC&gt;p nnoremap &lt;Cj&gt; gj nnoremap &lt;Ck&gt; gk " nnoremap &lt;Cc&gt; :call CommentLine()&lt;cr&gt; nnoremap &lt;Cu&gt; :call UnCommentLine()&lt;cr&gt; vmap &lt;Cc&gt; :call CommentLine()&lt;cr&gt; vmap &lt;Cu&gt; :call UnCommentLine()&lt;cr&gt; " function! WritePyinit() let @q = " \#\!/usr/bin/env python\n\#-*- encoding: utf-8 -*-\n\nimport sys, warnings\n\nwarnings.simplefilter('always')\n\ndef main(argv=sys.argv):\n pass\n\nif __name__ == \"__main__\":\n sys.exit(main())\n" execute "0put q" endfunction function! WriteDocstrings() if !has('python') echo "Error: Required vim compiled with +python" finish endif python &lt;&lt;EOF import vim import re linenr = vim.current.window.cursor[0] indentr = vim.current.window.cursor[0] line = vim.current.line n = 0 for i in line: if i != ' ': break n += 1 if len(line) == 0: n = 0 vim.current.buffer.append(' '*n + ' '*4 + '"""', linenr) vim.current.buffer.append(' '*n + ' '*4 + '', linenr) vim.current.buffer.append(' '*n + ' '*4 + '"""', linenr) vim.current.window.cursor = (vim.current.window.cursor[0]+2, n+4) EOF endfunction """""""""""""""" "  """""""""""""""" function __is_django_template() let l:a = getpos(".") if search("{\%.*\%}", '', line("$")) != 0 let b:b = cursor(l:a[1], l:a[2], "off") return 1 endif return 0 endfunction function RetFileType() let file_name = buffer_name("%") if file_name =~ '\.vim' return ["\"", ""] elseif __is_django_template() == 1 return ['{% comment %}' , '{% endcomment %}'] elseif file_name =~ '\.html$' || file_name =~ '\.xhtml$' || file_name =~ '\.xml' return ["&lt;!--", "--&gt;"] endif return ["#", ""] endfunction au BufEnter * let b:comment = RetFileType() function! CommentLine() let stsymbol = b:comment[0] let endsymbol = b:comment[1] execute ":silent! normal 0i" . stsymbol . "\&lt;ESC&gt;A" . endsymbol . "\&lt;ESC&gt;" endfunction function! UnCommentLine() let file_name = buffer_name("%") let stsymbol = b:comment[0] let endsymbol = b:comment[0] execute ":silent! normal :s/^\s*" . stsymbol . "//\&lt;CR&gt;" execute ":silent! normal :s/\s*" . endsymbol . "\s*$//\&lt;CR&gt;" endfunction let ropevim_vim_completion=1 function! CmdLine(str) exe "menu Foo.Bar :" . a:str emenu Foo.Bar unmenu Foo endfunction " From an idea by Michael Naumann function! VisualSearch(direction) range let l:saved_reg = @" execute "normal! vgvy" let l:pattern = escape(@", \/.*$^~[]) let l:pattern = substitute(l:pattern, "\n$", "", "") if a:direction == b execute "normal ?" . l:pattern . "^M" elseif a:direction == gv call CmdLine("vimgrep " . /. l:pattern . / . **/*.) elseif a:direction == f execute "normal /" . l:pattern . "^M" endif let @/ = l:pattern let @" = l:saved_reg endfunction "Basically you press * or # to search for the current selection vnoremap &lt;silent&gt; * :call VisualSearch('f')&lt;CR&gt; vnoremap &lt;silent&gt; # :call VisualSearch('b')&lt;CR&gt; vnoremap &lt;silent&gt; gv :call VisualSearch('gv')&lt;CR&gt; "PYDOC if exists('*s:ShowPyDoc') &amp;&amp; g:pydoc_perform_mappings call s:PerformMappings() finish endif if !exists('g:pydoc_perform_mappings') let g:pydoc_perform_mappings = 1 endif if !exists('g:pydoc_highlight') let g:pydoc_highlight = 1 endif if !exists('g:pydoc_cmd') let g:pydoc_cmd = 'pydoc' endif if !exists('g:pydoc_open_cmd') let g:pydoc_open_cmd = 'split' endif setlocal switchbuf=useopen highlight pydoc cterm=reverse gui=reverse function s:ShowPyDoc(name, type) if a:name == '' return endif if g:pydoc_open_cmd == 'split' let l:pydoc_wh = 10 endif if bufloaded("__doc__") let l:buf_is_new = 0 if bufname("%") == "__doc__" " The current buffer is __doc__, thus do not " recreate nor resize it let l:pydoc_wh = -1 else " If the __doc__ buffer is open, jump to it silent execute "sbuffer" bufnr("__doc__") let l:pydoc_wh = -1 endif else let l:buf_is_new = 1 silent execute g:pydoc_open_cmd '__doc__' if g:pydoc_perform_mappings call s:PerformMappings() endif endif setlocal modifiable setlocal noswapfile setlocal buftype=nofile setlocal bufhidden=delete setlocal syntax=man silent normal ggdG " Remove function/method arguments let s:name2 = substitute(a:name, '(.*', '', 'g' ) " Remove all colons let s:name2 = substitute(s:name2, ':', '', 'g' ) if a:type == 1 execute "silent read !" g:pydoc_cmd s:name2 else execute "silent read !" g:pydoc_cmd "-k" s:name2 endif normal 1G if exists('l:pydoc_wh') &amp;&amp; l:pydoc_wh != -1 execute "silent resize" l:pydoc_wh end if g:pydoc_highlight == 1 execute 'syntax match pydoc' "'" . s:name2 . "'" endif let l:line = getline(2) if l:line =~ "^no Python documentation found for.*$" if l:buf_is_new execute "bdelete!" else normal u setlocal nomodified setlocal nomodifiable endif redraw echohl WarningMsg | echo l:line | echohl None else setlocal nomodified setlocal nomodifiable endif endfunction " Mappings function s:PerformMappings() nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;Leader&gt;pw :call &lt;SID&gt;ShowPyDoc('&lt;CR&gt;&lt;CW&gt;', 1)&lt;CR&gt; nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;Leader&gt;pW :call &lt;SID&gt;ShowPyDoc('&lt;CR&gt;&lt;CA&gt;', 1)&lt;CR&gt; nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;Leader&gt;pk :call &lt;SID&gt;ShowPyDoc('&lt;CR&gt;&lt;CW&gt;', 0)&lt;CR&gt; nnoremap &lt;silent&gt; &lt;buffer&gt; &lt;Leader&gt;pK :call &lt;SID&gt;ShowPyDoc('&lt;CR&gt;&lt;CA&gt;', 0)&lt;CR&gt; " remap the K (or 'help') key nnoremap &lt;silent&gt; &lt;buffer&gt; K :call &lt;SID&gt;ShowPyDoc(expand("&lt;cword&gt;"), 1)&lt;CR&gt; endfunction if g:pydoc_perform_mappings call s:PerformMappings() endif " Commands command -nargs=1 Pydoc :call s:ShowPyDoc('&lt;args&gt;', 1) command -nargs=* PydocSearch :call s:ShowPyDoc('&lt;args&gt;', 0)</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/165723/">https://habr.com/ru/post/165723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165709/index.html">GCW Zero on Kickstarter</a></li>
<li><a href="../165711/index.html">Prototyping with Wireframesketcher</a></li>
<li><a href="../165713/index.html">Degrees - the key to fast hierarchy (Django example)</a></li>
<li><a href="../165715/index.html">Implementation of morphological search on Kohana (phpMorphy library)</a></li>
<li><a href="../165719/index.html">Find an idea: the ideal object</a></li>
<li><a href="../165725/index.html">Like I had for the first time with Kiwi</a></li>
<li><a href="../165727/index.html">How and why we made our micro markup validator</a></li>
<li><a href="../165729/index.html">Ultimate performance: C #</a></li>
<li><a href="../165731/index.html">Daydream: Interactive screensaver for Android 4.2</a></li>
<li><a href="../165733/index.html">Video review of monoblock (tablet) Sony VAIO Tap 20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>