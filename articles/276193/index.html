<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finite Volume method - implementation on the example of thermal conductivity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes the implementation of the well-known finite volume method for the numerical solution of partial differential equations. It is us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finite Volume method - implementation on the example of thermal conductivity</h1><div class="post__text post__text-html js-mediator-article">  The article describes the implementation of the well-known finite volume method for the numerical solution of partial differential equations. It is used to divide a region into any standard elements (finite volumes) - triangles, quadrangles, etc. The method of visualizing the calculation results is also self-written. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/d8d/0bc/466/d8d0bc46681946c686fb892c0666e502.png"></div><br><br><a name="habracut"></a><br><h3>  <b>Finite Volume (FVM) method</b> </h3><br>  The method is based on dividing the region into non-intersecting control volumes (elements), the nodal points where a solution is sought. Solving it - we find the values. <br>  desired variables at nodal points. For a single element, the equation is obtained by integrating the original diff of the equation with respect to the element and approximating the integrals. <br><br>  The term final volume in the article will often be replaced with the Element, for convenience we will consider them equivalent (the element in this article has nothing to do with the finite element method). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are 2 different ways to solve the FVM problem: <br>  1) the faces of the control volume coincide with the faces of the element <br>  2) the faces of the control volume pass through the centers of the faces of the elements (into which the region is divided). The desired variables are stored at the vertices of these elements. A control volume is built around each vertex.  For a non-rectangular grid, this method has 2 more subspecies. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d67/26a/b53/d6726ab5301d4f9a93d0c11106cb26f3.png"></div><br>  We will use method 1) with control volumes coinciding with the elements into which the region is divided. <br><br>  Some advantages of FVM: <br><ul><li>  preservation of basic quantities throughout the region, such as system energy, mass, heat fluxes, and so on. This condition is fulfilled even for a rough computational grid </li><li>  high speed of calculation. Many calculated values ‚Äã‚Äãcan be calculated when a region is divided into elements, and it is not necessary to calculate them at each time step. </li><li>  ease of use for tasks with complex geometry and curvilinear borders. The ease of using different geometric types of elements - triangles, polygons. </li></ul><br>  The FVM method is implemented on the example of the heat equation: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/dca/709/d2c/dca709d2c7fe40d2bfebc62ab4634b90.gif"></div><br>  So the main steps in the implementation of FVM: <br><ol><li>  Translation diff equations into a form suitable for FVM - integration over the control volume </li><li>  Drawing up a discrete analogue, choosing a method for converting derivatives and other integrands into discrete form </li><li>  Obtaining an equation for each of the control volumes into which the region is divided. Compilation of a system of linear equations and its solution. </li></ol><br><br><h3>  <b>Time discretization.</b> </h3><br>  For the time derivative, we use the standard simplest method of Euler. This will be an explicit time scheme, where the sought from the previous step are taken. And at the first step, we set the initial conditions. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/50e/87a/d12/50e87ad12eaa4bd795db32093120d5fd.gif"></div><br><h3>  <b>A bit of theory or the first step in the implementation of FVM</b> </h3><br>  Using the divergence theorem, the integral of volume is transformed into an integral of area. The meaning is that we replace integration over the entire internal volume of our element with integration only over the surface of this volume. This formulation is more suitable for the 3D case. For 2D, instead of volume V - the area of ‚Äã‚Äãthe element, and instead of S - the perimeter of the element. It turns out that the integral over the area is replaced by an integral along the perimeter. In fact, the degree of derivative decreases. If, for example, there is a second derivative, then only  ervaya, when was the first - instead of the derivative will be sought peremennaya.Nado just have to remember that we are dealing not with the usual derivative with a divergence. <br>  So the second term in our equation after integration is transformed as follows: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/725/2c2/e52/7252c2e520a9422e95deb542ae5dce6f.gif"></div><br><br><h3>  <b>FVM on a standard rectangular grid</b> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a8a/719/d9d/a8a719d9d267433b81e4ba10e606bbac.png"></div><br>  The figure shows Element C and its neighboring elements <b>on the right (E), on the left (W), on the top (N) and on the bottom (S)</b> . The element C has 4 faces marked with letters <b>ewns</b> . It is these 4 faces that make up the perimeter of the element and integration is performed. For each element, as a result, we obtain a discrete analog of the original diff equation. <br><br>  Let us make a discrete analogue for element C. To begin, we need to understand the integral (3). The integral is in fact a sum. Therefore, we replace the integral over the entire surface of the element by the sum of the 4 components of this surface, ie 4 edges of the element. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/eb7/d44/81d/eb7d4481d4304cd9beb60cd65871b054.gif"></div><br>  The <b>ewns</b> indices here mean that the expression or variable is calculated in the center of the corresponding face. <br>  Now let's put together the resulting simplifications of the parts of the original diff equation - terms (2) and (4). We get the first approximation level: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/7ca/844/833/7ca8448332b34181ae682ace752a4b79.gif"></div><br>  Now we only need to approximate (4) until the end, since the gradient enters there, and we need to convert it into numerical form. In fact, this sum represents the sum of heat fluxes through the edges. Our case is simplified for a rectangular grid, because the normal to the face only 1 component remains - either along the x axis or along y. <br>  Let us analyze this process in detail using the example of the e face. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e60/764/904/e60764904deb44d0acb154bf716bd9c5.png"></div><br>  Now we substitute instead of the sum in the equation (5) the obtained discrete analogs for 4 faces: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e70/356/1ad/e703561ad222469783b915159118bf69.gif"></div><br>  Equation (7) is the final equation for the element C, from which we obtain at each time step a new value of temperature (Tnew) in the element C. <br><br><h3>  <b>Boundary conditions on a rectangular grid</b> </h3><br>  The figure shows the element C whose face e is at the boundary and the temperature values ‚Äã‚Äãon this face are known, either as a given temperature or as a given heat flux through the face. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/b68/038/1c9/b680381c9fc24848a99520abfe438908.png"></div><br>  We consider only 2 types of boundary conditions. <br><ol><li>  Tb temperature set at border </li><li>  FluxB flow is set on the border, we consider only the case when FluxB = 0, i.e.  face e will be insulated </li></ol><br>  Case 2) is the simplest, since it turns out that the e face is not required at discretization (since all the coefficients are Flux = 0) and you can simply skip it. <br><br>  Now consider case 1). Discretization of the edge e will be generally similar to the one that has already been described. There will be only 2 changes - instead of Te there will be a known boundary value Tb and instead of a distance DXe it will be DXe / 2. Otherwise, you can consider the value Te as if this would be an ordinary neighboring node E. Now we shall write out the term for the boundary element C in more detail. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/1a4/4d4/605/1a44d46056b847f59fde217d3fdad6b2.gif"></div><br><h3>  <b>An example of numerical calculations on a rectangular grid</b> </h3><br>  As an example, consider the area divided into 9 elements, grid 3 * 3. On the first slides, the following boundary conditions are applied: T = 0 on 3 sides, T = 240 set to the bottom. On the second slide line, on the sides, the boundary conditions with Flux are set. = 0, above T = 0, below T = 240. In each case there are 2 pictures, one with a breakdown of the area 3 * 3 elements, the second 40 * 40. <br><div class="spoiler">  <b class="spoiler_title">Calculation code for both cases (in the source is called heat2dminimum)</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPhysic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Tc, Te, Tw, Tn, Ts; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> FluxC, FluxE, FluxW, FluxN, FluxS; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Tb = <span class="hljs-number"><span class="hljs-number">240</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Tb0 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imax; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; jmax; j++) { Tc = T[i, j]; dx = dh; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == imax - <span class="hljs-number"><span class="hljs-number">1</span></span>) { Te = Tb0; dx = dx / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Te = T[i + <span class="hljs-number"><span class="hljs-number">1</span></span>, j]; FluxE = (-k * FaceArea) / dx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Tw = Tb0; dx = dx / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Tw = T[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j]; FluxW = (-k * FaceArea) / dx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == jmax - <span class="hljs-number"><span class="hljs-number">1</span></span>) { Tn = Tb0; dx = dx / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Tn = T[i, j + <span class="hljs-number"><span class="hljs-number">1</span></span>]; FluxN = (-k * FaceArea) / dx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Ts = Tb; dx = dx / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Ts = T[i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>]; FluxS = (-k * FaceArea) / dx; FluxC = FluxE + FluxW + FluxN + FluxS; T[i, j] = Tc + delt * (FluxC * Tc - (FluxE * Te + FluxW * Tw + FluxN * Tn + FluxS * Ts)); } } <span class="hljs-comment"><span class="hljs-comment">//Insulated public void RunPhysic2() { double Tc, Te, Tw, Tn, Ts; double FluxC, FluxE, FluxW, FluxN, FluxS; double dx = 0; double Tb = 240; double Tb0 = 0; int i, j; for (i = 0; i &lt; imax; i++) for (j = 0; j &lt; jmax; j++) { Tc = T[i, j]; dx = dh; Te = 0; Tw = 0; if (i == imax - 1) FluxE = 0; else { Te = T[i + 1, j]; FluxE = (-k * FaceArea) / dx; } if (i == 0) FluxW = 0; else { Tw = T[i - 1, j]; FluxW = (-k * FaceArea) / dx; } if (j == jmax - 1) { Tn = Tb0; dx = dx / 2; } else Tn = T[i, j + 1]; FluxN = (-k * FaceArea) / dx; if (j == 0) { Ts = Tb; dx = dx / 2; } else Ts = T[i, j - 1]; FluxS = (-k * FaceArea) / dx; FluxC = FluxE + FluxW + FluxN + FluxS; T[i, j] = Tc + delt * (FluxC * Tc - (FluxE * Te + FluxW * Tw + FluxN * Tn + FluxS * Ts)); } }</span></span></code> </pre> <br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ac3/36b/a23/ac336ba23e6246ed8587102d059ff13e.png"></div><br><h3>  <b>FVM in problems with complex geometry</b> </h3><br>  This is where the advantage of FVM is manifested, where also, as in the finite element method, it is possible to represent a region with round borders through splitting into triangles or any other polygons. But FVM has another 1 plus - when going from triangles to polygons with a large number of sides absolutely nothing is required, of course, if the code was written for an arbitrary triangle and not an equilateral one. Moreover, without changing the code, you can use a mixture of different elements - triangles, polygons, squares, and so on. <br><br>  Consider the general case when the vector connecting the centers of 2 elements does not coincide with the vector of the normal to the common face of these elements. The flux calculation through the edge will now consist of 2 parts. In the first, the orthogonal component will be calculated and in the second, the so-called ‚Äúcross‚Äù -diffusion". <br><br>  The picture shows 2 elements, C is the current element under consideration and F is the neighboring element. Let us describe the discretization for the face separating these 2 elements. The vector connecting the centers of the elements is DCF. Vector e is the unit vector in the direction of DCF. Vector Sf is directed along the normal to the face, its length is equal to the length of the face. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a7f/f38/793/a7ff38793a15431da859731d78cc3240.png"></div><br>  The calculation scheme looks like this. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e39/d7d/6d3/e39d7d6d374e49d087c3865ae04b9785.png"></div><br>  The second term here is cross-diffusion, it will be the greater, the greater the difference between the vectors Ef and Sf, if they coincide, then it is equal to 0. <br>  We first write out the orthogonal part (minimum correction method). <br><div style="text-align:center;"><img src="https://habrastorage.org/files/009/24c/69b/00924c69bff44283b2e41b3b0631e356.png"></div><br>  In the source, I did not implement the term with cross-diffusion, because the question arose - how to check the correctness of such a implementation. Visually, the comparison of Matlab's and mine‚Äôs results was no different in the absence of cross-diffusion. which ultimately makes crossdiffusion = 0. Perhaps later I will return to this issue. <br><br>  The calculation of boundary elements is no different from the calculations not at the border, instead of the center of the neighboring element is taken the center of the face, well, and as usual the temperature at the border is substituted. <br>  In my implementation, the result is: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/fe8/89f/7aa/fe889f7aa4844fbbbd6d7c6029fadba7.gif"></div><br><div class="spoiler">  <b class="spoiler_title">Calculation code for an arbitrary polygon (in the source is called heat2PolyTeach)</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> bc, ac; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sumflux; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] aa = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] bb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (e = <span class="hljs-number"><span class="hljs-number">0</span></span>; e &lt; elementcount; e++) { Element elem = elements[e]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nf; bc = <span class="hljs-number"><span class="hljs-number">0</span></span>; ac = <span class="hljs-number"><span class="hljs-number">0</span></span>; sumflux = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nn = <span class="hljs-number"><span class="hljs-number">0</span></span>; nn &lt;<span class="hljs-number"><span class="hljs-number">6</span></span>; nn++) { aa[nn] = <span class="hljs-number"><span class="hljs-number">0</span></span>; bb[nn] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (nf = <span class="hljs-number"><span class="hljs-number">0</span></span>; nf &lt; elem.vertex.Length; nf++) { Face face = elem.faces[nf]; Element nb = elem.nbs[nf]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (face.isboundary) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (face.boundaryType == BoundaryType.BND_CONST) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> flux1; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> flux; flux1 = elem.k * (face.area / elem.nodedistances[nf]); Vector2 Sf = face.sf.Clone(); Vector2 dCf = elem.cfdistance[nf].Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sf * dCf &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) Sf = -Sf; <span class="hljs-comment"><span class="hljs-comment">//1) minimum correction //Vector2 DCF = elem.cndistance[nf].Clone(); Vector2 e1 = dCf.GetNormalize(); Vector2 EF = (e1 * Sf) * e1; flux = elem.k * (EF.Length() / dCf.Length()); ac += flux; bc += flux * face.bndu; bb[nf] = flux; } else if (face.boundaryType == BoundaryType.BND_INSULATED) { double flux; flux = 0; ac += flux; bc += flux * face.bndu; bb[nf] = flux; } } else { double flux1; double flux; flux1 = -elem.k * (face.area / elem.nodedistances[nf]); Vector2 Sf = face.sf.Clone(); Vector2 dCf = elem.cfdistance[nf].Clone(); if (Sf * dCf &lt; 0) Sf = -Sf; Vector2 DCF = elem.cndistance[nf].Clone(); Vector2 e1 = DCF.GetNormalize(); //corrected flux //1) minimum correction Vector2 EF = (e1 * Sf) * e1; flux = -elem.k * (EF.Length() / DCF.Length()); sumflux += flux * nb.u; ac += -flux; aa[nf] = -flux; } } elem.u = elem.u + delt * (bc - sumflux - ac * elem.u); } }</span></span></code> </pre><br></div></div><br><h3>  <b>Examples and verification of results</b> </h3><br>  The test was conducted by comparing the results in Matlab and my implementation.  Mesh was used the same, was unloaded from Matlab and loaded into the program. For some triangle artifacts do not pay attention, this is just an incomprehensible rendering glitch. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/4c1/b79/c89/4c1b79c89b3340d3a57288526f0c5408.png"></div><br><h3>  <b>Description of the source structure</b> </h3><br>  <a href="https://github.com/nexscifix/FiniteVolume">GitHab source is here</a> <br>  The main version in the heat2PolyV2 folder. What applies to the computing part lies in heat2PolyV2 \ Src \ FiniteVolume \. <br><br>  At the beginning of the file Scene2.cs are the parameters that can be changed for display in different color schemes, scale, mesh display, etc. The examples themselves are stored in heat2PolyV2 \ bin \ Debug \ Demos \ <br>  Unloading from Matlab is simple - you need to open the pde toolbox, open the m file (or create it yourself from scratch), go to the Mesh-Export mesh menu, click OK;  go to the main Matlab, variables will appear in the panel - mat of the pet, open the savemymesh.m file, execute it, the p.out file will appear, transfer it to the Demos folder. <br>  In the source code to select an example, you must specify the file name in the line param.file = "p"; (FormParam.cs). Next you need to apply boundary conditions - for ready-made examples, you can simply uncomment the corresponding blocks in MainSolver.cs: <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//p.out public void SetPeriodicBoundary()</span></span></code> </pre><br>  The meaning here is simple - Matlab divides the boundaries by domain, for example, external and internal. Also, for each domain, the boundaries are divided into parts (groups) so that conditions can be set on sections of the border separately - for example, right or bottom. <br>  It is possible not to use Matlab at all, but to manually register all elements (triangles) and their vertices + faces (only for boundary elements) <br><div class="spoiler">  <b class="spoiler_title">Description of the structure of the .out file</b> <div class="spoiler_text">  The file is divided into sections - ## Points (vertices), ## Triangle (triangles) and ## Boundary (faces - only those that are on the border) <br>  ## Points - coordinates of points, the first line is x, the second is y. <br>  ## Triangle - triangles, the first line is the index of the 1st vertex in the ## Points array, 2 and 3 lines are the indices 2 and 3 of the triangle top. <br>  ## Boundary is the faces, the first line is the index of the 1st vertex of the face, the 2nd is the index of the second vertex, the fifth line is the group, the sixth is the domain <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Description of source folders</b> <div class="spoiler_text">  Sources are written in Visual Studio 2010 c #. Used by Matlab R2012a. <br>  <a href="https://github.com/nexscifix/FiniteVolume">Source code github</a> <br><ul><li>  <b>heat2PolyV2</b> - final version <br></li><li>  <b>other \ heat2Utrianglestatic</b> - implemented an example from the book p346 versteeg_h malalasekra_w_ An_introduction_to_computational_fluid ... <br></li><li>  <b>other \ water2dV2</b> - an attempt to solve the Navier-Stokes equations in part using FiniteVolume <br></li><li>  <b>matlab</b> - m files of examples pde toolbox + savemymesh.m which unloads a ready .out file for heat2PolyV2 <br></li></ul><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">List of books on the subject</b> <div class="spoiler_text"><ul><li>  <b>The finite volume method</b> - there is already a second edition <br></li><li>  <b>F.Moukalled L.Mangani M.Darwish The finite volume method of computational fluid dynamics 2016</b> - released recently (almost yesterday :) <br></li><li>  <b>Patankar S.-Numerical methods for solving problems of heat transfer and fluid dynamics-Energoatomizdat (1984)</b> <br></li><li>  <b>Patankar S.V.-Numerical solution of problems of heat conduction and convective heat exchange during flow in channels MEI (2003)</b> <br></li><li>  <b>Ferziger JH Peric 2001 Computational Methods for Fluid Dynamics</b> - although not directly related to FVM, but very useful <br></li></ul><br><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/276193/">https://habr.com/ru/post/276193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276175/index.html">Automatic installation and configuration of PostgreSQL using Wix #</a></li>
<li><a href="../276179/index.html">WLAN architecture: what to choose?</a></li>
<li><a href="../276185/index.html">XAML Developer Chips: Embedded Converters</a></li>
<li><a href="../276187/index.html">We are implementing an analogue of Apple iCloud Voicemail using free grammars from Yandex</a></li>
<li><a href="../276189/index.html">Moxy - MVP implementation for Android with a pinch of magic</a></li>
<li><a href="../276195/index.html">Algorithms for searching palindromes</a></li>
<li><a href="../276205/index.html">Add instructions to the microprocessor MIPS, which work in the pipeline as his own</a></li>
<li><a href="../276209/index.html">Millimetric is back. Now - Open Source</a></li>
<li><a href="../276211/index.html">The study of common Malvari under Android</a></li>
<li><a href="../276213/index.html">OpenSSL eliminates a dangerous vulnerability that allowed an attacker to decrypt HTTPS traffic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>