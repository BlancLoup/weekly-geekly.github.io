<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúLike a ram on a new gate‚Äù or custom ‚Äúpseudo-3D‚Äù objects in NanoCAD using the MultiCAD.NET API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my opinion, one of the best ways to learn something is to share knowledge with other people. 

 This time I needed to understand how to create cust...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúLike a ram on a new gate‚Äù or custom ‚Äúpseudo-3D‚Äù objects in NanoCAD using the MultiCAD.NET API</h1><div class="post__text post__text-html js-mediator-article">  In my opinion, one of the best ways to learn something is to share knowledge with other people. <br><br>  This time I needed to understand how to create custom objects in NanoCAD using the MultiCAD.NET API.  Nanosoft‚Äôs blog has an article from 2013 that explains the basic issues of <a href="https://habrahabr.ru/company/nanosoft/blog/184482/">creating custom primitives</a> .  But it would not be interesting to agree, just to reproduce this article, so we will add it a bit. <br><br>  In our case, we <b>will create a pseudo-three-dimensional door</b> , which will also be able to open and close.  And so that our little door is not lonely, we will create a girlfriend for her - the same wall. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under the concept of ‚Äúpseudo-3D‚Äù in this case, I mean that our objects will not have the properties of a rigid body model, that is, it will simply be a set of connected geometric primitives in a three-dimensional coordinate system.  Maybe this is not quite the correct term, but so far I have not picked up anything better. <br><br>  Unfortunately, with all the desire you cannot call me a programmer right now, so this article will be in the style of a beginner to beginners and surely all the code and the techniques you meet in it can be improved. <br><br>  Anyway, if you are interested in: design, CAD, NanoCAD, development under .NET and in particular in C #, as well as sheep and <b>Sesame Street</b> , then perhaps this article is just for you. <br><br>  Are you also interested in where the sheep and Sesame Street are?  Then you are welcome under the cat. <br><br> <a href="https://www.youtube.com/watch%3Fv%3DHWiZj4I8DUY"><img src="https://habrastorage.org/webt/hl/hl/8w/hlhl8wlmf6q8mfnuuodg4jqjn9y.png"></a> <br><a name="habracut"></a><br>  I will not force a dramatic pause, the sheep are a kind of metaphor explaining the meaninglessness of what we are going to do today (picture a little later). <br><br>  Well, Sesame Street, here is simply because I recently remembered about her and I was smashed by a terrible nostalgia for the Muppets, so that they will help us withstand the uniform style of the story. <br><br>  Probably it was stupid to reveal all the intrigue so quickly?  But I hope that you still continue to read the article. <br><br>  Content: <br>  <a href="https://habr.com/ru/post/342680/">Part I: With the new CAD!</a>  <a href="https://habr.com/ru/post/342680/">(Introduction).</a> <br>  <a href="https://habr.com/ru/post/342680/">Part II: We write code under NanoCAD 8.5</a> <br>  <a href="https://habr.com/ru/post/342680/">Part III: Trying to adapt the code for a free NanoCAD 5.1.</a> <br>  <a href="https://habr.com/ru/post/342680/">Part IV: The Multi-Kukish (Conclusion)</a> <br><a name="I"></a><br><h3>  1. With the new CAD!  (Introduction). </h3><br><img src="https://habrastorage.org/webt/p0/ie/ms/p0iemsujipq3tpqt2kjmpj8mqbs.png"><br><br>  I would like to start with the fact that a stable version of the fresh NanoCAD 8.5 SDK has become available on the <a href="http://developer.nanocad.ru/">NanoCAD developer</a> portal and this time we will be guided by it. <br><br>  In my last article focused on NanoCAD 8.1, I shared my opinion on the platform, we discussed the process of preparing the project for the assembly and wrote a simple command, so if you missed it and are completely unfamiliar with NanoCAD and developed using the MultiCAD .NET API, you can start from the article <a href="https://habrahabr.ru/post/342186/">"Scarless Face" or the first steps in Multicad.NET API 7 (for Nanocad 8.1)</a> <br><br>  This time I plan to do less ‚Äúpour water‚Äù and pay more attention to the technical side. <br><br>  The only thing before going on to develop our facilities is to say that before starting the preparation of this article, I essentially only used the free versions of NanoCAD (NC 5.1), which was released in 2013 already. <br><br>  There were two reasons for this: it is completely free for any purpose, and the second reason is that I have a very weak computer, so AutoCAD slows down on it and loads a hell of a lot. <br><br>  But since before writing this article, I had to practice ‚Äúpens‚Äù to draw the object, and also to understand how the three-dimensional viewing of the object works, well, and most importantly, restart the CAD 10,000 times during the debugging process, I had a little time to look at NanoCAD 8.5 . <br><br>  So at first glance I can say the following, it is more pleasant to draw than in the old free version, and it loads as fast as the old NanoCAD 5.1, that is, NC 8.5 starts several times faster than its peer - AutoCAD 2017 (if anyone is curious, write in the comments, I will stopped with a stopwatch).  It only remains to hope that one day the company will update the free version, transferring to it new APIs and new features in terms of the functions of the ‚Äúelectronic panel machine‚Äù. <br><br>  And finally, as I understand in the versions of NanoCAD available for developers, the module of three-dimensional solid modeling is turned on, but I could not understand the API to it, especially for objects created by the user.  Maybe another time we will study it.  For now we will be content with "pseudo-3D" objects. <br><br>  This even has its advantage, our library after a small adaptation will be launched in the free NanoCAD 5.1, where there is no solid modeling at all.  But more on that later. <br><a name="II"></a><br><h3>  2. We write code under NanoCAD 8.5 </h3><br> <a href="https://www.youtube.com/watch%3Fv%3DTka-miw3tvc"><img src="https://habrastorage.org/webt/ek/vs/9h/ekvs9hhizk8ej7c0zxg9zdfjwqu.png"></a> <br><br>  Yes, yes, Count von Znach counted everything correctly!  Looking ahead to exactly so many sheep, walls and doors we get at the end.  Now Count Znak will have a new assignment - count views and votes for the article.  <i>I can already hear it straight: ‚Äúone, one view, two or two views, three ...‚Äù</i> <br>  As usual, the full code of the classes and an example of dwg files can be found on <a href="https://github.com/bosonbeard/Funny-models-and-scripts/tree/master/2.ForNanoCAD/1.Pseudo_3D_for_NanoCAD">GitHub</a> . <br><br>  And now we will begin to disassemble it in parts.  I did not begin to make ready-made assemblies, I think you will be able to build the project yourself, <a href="https://habrahabr.ru/post/342186/">in the last article</a> , I described in detail how to create and configure the project for MS Visual Studio 2015, for NanoCAD 8.1, and so nothing has changed since that moment. <br><br>  Therefore, this time I will only briefly mention the procedure for assembling under Nanocad 8.5: <br><br><ol><li>  Create a new project. Select the platform. NET Framework 4, as a template, select the class library C #. </li><li>  For the Nanocad version of x64 (and I have this) from the SDK \ include-x64 \ folder, add links to the project to: mapibasetypes.dll, mapimgd.dll, imapimgd.dll.  Do not forget for all three libraries to copy the property locally to False. </li><li>  Also add links to the assembly from Microsoft: System.Windows.Forms.dll, System.Drawing.dll. </li><li>  In the project properties, on the ‚ÄúDebug‚Äù tab, as an action at startup, select ‚Äúopen in external program‚Äù and specify the path to the NC 8.5 executable file (I have C: \ Program Files \ Nanosoft \ nanoCAD x64 Plus 8.5 \ nCad.exe ) </li><li>  Create two classes DoorPseudo3D.cs and WalllPseudo3D.cs for the door and the wall respectively. </li><li>  Let's go to the address C: \ ProgramData \ Nanosoft \ nanoCAD x64 Plus 8.5 \ DataRW (you may differ) and find or create the file load.config with the following content </li></ol><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">module</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"C:\Users\...\bin\Debug\nanodoor2.dll"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  You naturally have the name of the project and the path to it may differ. <br><br>  Well, that‚Äôs all, we‚Äôre ready for development, now, by pressing F5, NC 8.5 starts automatically and our assembly is loaded right away, all that remains is to enter the commands that we have developed. <br><br>  Once again, I‚Äôm not a programmer, so most likely there will be a lot of flaws in the code: failures when saving, moving or copying objects, and simply non-optimal solutions.  If someone, without greatly complicating the code, will be able to bring the ego to mind - ‚Äúearthly bow‚Äù. <br><br>  But anyway, on the basis of this code, we will be able to sort out a little how to create our objects, which means that it performs its main goal. <br><br>  Well, of course, I must say a big thank you to Alexander Polkhovsky from the NanoCAD developers forum, he helped me a lot with redefining the functionality related to moving and rotating an object (useful for opening / closing the door).  Yes, and to all the other forum participants, too, thank you, I will remind that at the moment one of the most accessible sources of information on the MultiCAD.NET API. <br><br>  We start with the wall, because it is simpler in execution. <br><br>  First, let's add namespaces. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.Runtime; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.DatabaseServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.Geometry; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.CustomObjectBase; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad;</code> </pre><br>  Then create a custom object class. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nanowall2</span></span> { <span class="hljs-comment"><span class="hljs-comment">//change "8b0986c0-4163-42a4-b005-187111b499d7" for your Guid from Assembly. // Be careful GUID for door and wall classes must be different! // Otherwise there will be problems with saving and moving [CustomEntity(typeof(WalllPseudo3D), "8b0986c0-4163-42a4-b005-187111b499d7", "WalllPseudo3D", "WalllPseudo3D Sample Entity")] [Serializable] public class WalllPseudo3D : McCustomBase {</span></span></code> </pre><br>  Take the class name you want (you can leave mine as well), the main thing is that it inherit from McCustomBase. <br><br>  All class attributes are required, I honestly do not fully understand the parameters of the CustomEntity attribute, so I stupidly remade it by analogy. <br><br>  ‚Äú8b0986c0-4163-42a4-b005-187111b499d7‚Äù - in my example, this is a GUID, I apparently ‚Äúclicked‚Äù the moment where the .NET documentation explained how to work with it.  I can only say one thing. For simplicity, I took it from the assembly settings file, replacing the last digit to ensure uniqueness.  If the GUID of the door and wall classes is completely the same, miracles will begin: when copying, the doors will turn into doors and the doors will lose their functionality after saving the file, I‚Äôve fixed it, I hope, and you will have no problems. <br><br>  Define the class fields. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Point3d _pnt1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Point3d _pnt2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d(<span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _h = <span class="hljs-number"><span class="hljs-number">2085</span></span>;</code> </pre><br>  The fields _pnt1 and _pnt12 are the base points on which the geometry of our wall will be built (the length of the wall is in fact), _h is the wall height by default (after creating an object you can correct it). <br><br>  Next, create a team on call, which will outline our door. <br><br>  DrawWall in the CommandMethod attribute is the name of the command that you will enter on the command line to call an object, you can shorten it, for example, with a DWall, without losing functionality. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CommandMethod(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DrawWall"</span></span></span><span class="hljs-meta">, CommandFlags.NoCheck | CommandFlags.NoPrefix)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawWall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { WalllPseudo3D wall = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WalllPseudo3D(); wall.PlaceObject(); }</code> </pre><br>  We in the class implementing our team create a new instance of the wall class (if this is not done, then all the walls in my office will begin to be perceived as one ‚Äúuber‚Äù wall).  And we will define the PlaceObject method a bit later. <br><br>  We define the procedure for drawing the object. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GeometryBuilder dc</span></span></span><span class="hljs-function">)</span></span> { dc.Clear();</code> </pre><br>  I do not fully understand this piece, but somehow the API has a GeometryBuilder class, on the basis of which we will continue to sculpt our wall. <br>  Dc.Clear, apparently clears every time all the geometry previously built for an instance of a class. <br><br>  Further easier. <br><br><pre> <code class="cs hljs"> Point3d pnt1 = _pnt1; Point3d pnt2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d(_pnt2.X, pnt1.Y, <span class="hljs-number"><span class="hljs-number">0</span></span>); Point3d pnt3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d(pnt2.X, pnt1.Y+<span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Point3d pnt4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d(pnt1.X , pnt3.Y, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set the color to ByObject value dc.Color = McDbEntity.ByObject; Vector3d hvec = new Vector3d(0, 0, _h);</span></span></code> </pre><br>  We define four base points on the basis of which the base and top of the wall will be built, with the first and second points being linked to the class fields, which means we will be manipulating them later.  Our wall in length will be built according to the distance between the _pnt1 and pnt2 points, but the wall width is set rigidly and cannot be corrected (this is done for simplicity), but you can easily redefine the logic of work by analogy. <br><br>  dc.Color - seems to set the "color by block" property for an object. <br><br>  The vector hvec is the height of our wall, which we will add to the base to build the top. <br><br>  Next we draw the lower and upper sides of the wall. <br><br><pre> <code class="cs hljs"> dc.DrawPolyline(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d[] { pnt1, pnt2, pnt3, pnt4, _pnt1 }); dc.DrawPolyline(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point3d[] { _pnt1.Add(hvec), pnt2.Add(hvec), pnt3.Add(hvec), pnt4.Add(hvec), pnt1.Add(hvec)});</code> </pre><br>  We connect bottom and top with ribs. <br><br><pre> <code class="cs hljs"> dc.DrawLine(pnt1, pnt1.Add(hvec)); dc.DrawLine(pnt2, pnt2.Add(hvec)); dc.DrawLine(pnt3, pnt3.Add(hvec)); dc.DrawLine(pnt4, pnt4.Add(hvec));</code> </pre><br>  Create a contour from pollinium for hatching and then fill it with brick hatching (you can see the names of the hatchings in the program itself).  And I did not manage to shade through the list of polylines I had to repeat the procedure twice.  I think I did not take into account something. <br><br>  We only shade 2 wall surfaces - the longest, if you want you can shade the rest yourself. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Create contours for the front and rear sides and hatch them // In this demo, we hatch only two sides, you can tailor the others yourself List&lt;Polyline3d&gt; c1 = new List&lt;Polyline3d&gt;(); c1.Add(new Polyline3d( new List&lt;Point3d&gt;() { pnt1, pnt1.Add(hvec), pnt2.Add(hvec), pnt2, pnt1, })); dc.DrawGeometry(new Hatch(c1, "BRICK", 0, 20, false, HatchStyle.Normal, PatternType.PreDefined, 30), 1); List&lt;Polyline3d&gt; c2 = new List&lt;Polyline3d&gt;(); c2.Add(new Polyline3d( new List&lt;Point3d&gt;() { pnt4, pnt4.Add(hvec), pnt3.Add(hvec), pnt3, pnt4, })); dc.DrawGeometry(new Hatch(c2, "BRICK", 0, 20, false, HatchStyle.Normal, PatternType.PreDefined, 30), 1); }</span></span></code> </pre><br>  Define a custom property for an object, since in my opinion it is more convenient to draw in a two-dimensional form, it is not convenient to set the wall height at the moment of drawing, it was possible to make the installation of the wall height as part of its drawing procedure, but we will go more simply by adding a property the help of which we will change the height after it is drawn. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Define the custom properties of the object [DisplayName("Height")] [Description("Height of wall")] [Category("Wall options")] public double HWall { get { return _h; } set { //Save Undo state and set the object status to "Changed" if (!TryModify()) return; _h = value; } }</span></span></code> </pre><br>  According to the attributes [DisplayName ("Height")] - the name that will be in the properties window, [Description ("Height of wall")], is a description, but I did not understand where it is displayed, [Category ("Wall options")] - category of fields, as you will see later on the example of the doors, it is fashionable to group our fields for convenience. <br>  Well, then the property usually goes on, if you ever made public properties in Unity 3D, then the mechanism is similar, we can have access to the class fields directly from the editor (in our case from CAD). <br><br>  TryModify () is a required method, it must be called before each change in the properties of an object, as I understood.  We will meet with him a couple of times. <br><br>  Next, we redefine the method responsible for placing the object in the drawing (remember, we used to call it before). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> hresult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlaceFlags lInsertType</span></span></span><span class="hljs-function">)</span></span> { InputJig jig = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputJig(); <span class="hljs-comment"><span class="hljs-comment">// Get the first box point from the jig InputResult res = jig.GetPoint("Select first point:"); if (res.Result != InputResult.ResultCode.Normal) return hresult.e_Fail; _pnt1 = res.Point; // Add the object to the database this.DbEntity.AddToCurrentDocument(); //Exclude the object from snap points jig.ExcludeObject(ID); // Monitoring mouse moving and interactive entity redrawing jig.MouseMove = (s, a) =&gt; { TryModify(); _pnt2 = a.Point; this.DbEntity.Update(); }; // Get the second box point from the jig res = jig.GetPoint("Select second point:"); if (res.Result != InputResult.ResultCode.Normal) { this.DbEntity.Erase(); return hresult.e_Fail; } _pnt2 = res.Point; return hresult.s_Ok; }</span></span></code> </pre><br>  This code is almost entirely borrowed from the example from Nanosoft I mentioned in the first chapter, I do not understand it 100%, but if in short we call the command to enter the first point of the wall (jig.GetPoint), then put it into the drawing (DbEntity. AddToCurrentDocument ()), after which we exclude the object from the bindings so that it does not prevent us from entering the second point (_pnt2). <br><br>  If everything is normal, then the object is placed in the drawing, if not (for example, input is not completed), then the object is deleted. <br><br>  And the last do the handles to change the size of the wall. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Create a grip for the base point of the object public override bool GetGripPoints(GripPointsInfo info) { info.AppendGrip(new McSmartGrip&lt;WalllPseudo3D&gt;(_pnt1, (obj, g, offset) =&gt; { obj.TryModify(); obj._pnt1 += offset; })); info.AppendGrip(new McSmartGrip&lt;WalllPseudo3D&gt;(_pnt2, (obj, g, offset) =&gt; { obj.TryModify(); obj._pnt2 += offset; })); return true; } } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> There are many shortcomings in this code. // Including failures when working with copying, moving objects and saving files, you can improve it if you want. }</span></span></code> </pre><br>  As I understand it, the code from the example I mentioned above is obsolete in terms of pens (for NC 8.X) and it is better to focus on the code <a href="https://habrahabr.ru/company/nanosoft/blog/234181/">from this example</a> . <br><br>  Well, of course, I‚Äôm warning you that my code is far from ideal, so I‚Äôll be happy with adequate, imputed edits. <br><br>  Now consider the door.  The beginning is the same. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.Runtime; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.DatabaseServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.Geometry; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad.CustomObjectBase; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Multicad; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nanodoor2</span></span> { <span class="hljs-comment"><span class="hljs-comment">//change "8b0986c0-4163-42a4-b005-187111b499d7" for your Guid from Assembly. // Be careful GUID for door and wall classes must be different! // Otherwise there will be problems with saving and moving [CustomEntity(typeof(DoorPseudo3D), "8b0986c0-4163-42a4-b005-187111b499d9", "DoorPseudo3D", "DoorPseudo3D Sample Entity")] [Serializable] public class DoorPseudo3D : McCustomBase { // First and second vertices of the box private Point3d _pnt1 = new Point3d(0, 0, 0); private double _h = 2085; private Vector3d _vecStraightDirection = new Vector3d(1, 0, 0); private Vector3d _vecDirectionClosed = new Vector3d(1, 0, 0); public enum status { closed , middle, open }; private status _dStatus = status.closed; [CommandMethod("DrawDoor", CommandFlags.NoCheck | CommandFlags.NoPrefix)] public void DrawDoor() { DoorPseudo3D door = new DoorPseudo3D(); door.PlaceObject(); }</span></span></code> </pre><br>  Unless a field was added that will be responsible for whether our door is open or closed, and two vectors will appear _vecStraightDirection - responsible for the current door turn, _vecDirectionClosed - stores data on the door turn in the closed state.  This will all come in handy later. <br><br>  But directly in the geometry of the door, as you would expect there are small changes. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GeometryBuilder dc</span></span></span><span class="hljs-function">)</span></span> { dc.Clear(); <span class="hljs-comment"><span class="hljs-comment">// Define the basic points for drawing Point3d pnt1 = new Point3d(0, 0, 0); Point3d pnt2 = new Point3d(pnt1.X + 984, pnt1.Y, 0); Point3d pnt3 = new Point3d(pnt2.X + 0, pnt1.Y+50, 0); Point3d pnt4 = new Point3d(pnt1.X , pnt3.Y, 0); // Set the color to ByObject value dc.Color = McDbEntity.ByObject; Vector3d hvec = new Vector3d(0, 0, _h); // Draw the upper and lower sides dc.DrawPolyline(new Point3d[] { pnt1, pnt2, pnt3, pnt4, pnt1 }); dc.DrawPolyline(new Point3d[] { pnt1.Add(hvec), pnt2.Add(hvec), pnt3.Add(hvec), pnt4.Add(hvec), pnt1.Add(hvec)}); // Draw the edges dc.DrawLine(pnt1, pnt1.Add(hvec)); dc.DrawLine(pnt2, pnt2.Add(hvec)); dc.DrawLine(pnt3, pnt3.Add(hvec)); dc.DrawLine(pnt4, pnt4.Add(hvec)); // Drawing a Door Handle dc.DrawLine(pnt2.Add(new Vector3d( - 190, -0, _h*0.45)), pnt2.Add(new Vector3d(-100, 0, _h * 0.45))); dc.DrawLine(pnt3.Add(new Vector3d(-190, 0, _h * 0.45)), pnt3.Add(new Vector3d(-100, 0, _h * 0.45))); // Create contours for the front and rear sides and hatch them // In this demo, we hatch only two sides, you can tailor the others yourself List&lt;Polyline3d&gt; c1 = new List&lt;Polyline3d&gt;(); c1.Add(new Polyline3d( new List&lt;Point3d&gt;() { pnt1, pnt1.Add(hvec), pnt2.Add(hvec), pnt2, pnt1, })); List&lt;Polyline3d&gt; c2 = new List&lt;Polyline3d&gt;(); c2.Add(new Polyline3d( new List&lt;Point3d&gt;() { pnt4, pnt4.Add(hvec), pnt3.Add(hvec), pnt3, pnt4, })); dc.DrawGeometry(new Hatch(c1, "JIS_WOOD", 0, 170, false, HatchStyle.Normal, PatternType.PreDefined, 500), 1); dc.DrawGeometry(new Hatch(c2, "JIS_WOOD", 0, 170, false, HatchStyle.Normal, PatternType.PreDefined, 500), 1); }</span></span></code> </pre><br>  First, note that we build the door one point at a time, that is, the size of the door is rigidly fixed in width and height (well, so that it differs from the wall).  Also, the section ‚Äú// Drawing a Door Handle‚Äù was added, there are 2 lines that indicate a conventional handle, and we also replaced the type of hatching with JIS_WOOD <br><br>  But the PlaceObject method is simpler here, due to the fact that the second handle is not needed. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> hresult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlaceFlags lInsertType</span></span></span><span class="hljs-function">)</span></span> { InputJig jig = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputJig(); <span class="hljs-comment"><span class="hljs-comment">// Get the first box point from the jig InputResult res = jig.GetPoint("Select first point:"); if (res.Result != InputResult.ResultCode.Normal) return hresult.e_Fail; _pnt1 = res.Point; // Add the object to the database DbEntity.AddToCurrentDocument(); return hresult.s_Ok; }</span></span></code> </pre><br>  Next comes the complete novelty with respect to the wall class.  For which I thanked Alexander at the beginning of the article. <br><br>  Below, we will redefine the method that is in some mysterious way responsible for creating the transformation matrix (displacement and rotation) of our door. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Method for changing the object's SC (the graph is built at the origin of coordinates). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/ summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name = "tfm"&gt;</span></span></span><span class="hljs-comment"> The matrix for changing the position of the object. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/ param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> True - if the matrix is passed, False - if not. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/ returns&gt;</span></span></span><span class="hljs-comment"> public override bool GetECS(out Matrix3d tfm) { // Create a matrix that transforms the object. // The object is drawn in coordinates(0.0), then it is transformed with the help of this matrix. tfm = Matrix3d.Displacement(this._pnt1.GetAsVector()) * Matrix3d.Rotation (-this._vecStraightDirection.GetAngleTo(Vector3d.XAxis, Vector3d.ZAxis), Vector3d.ZAxis, Point3d.Origin); return true; }</span></span></code> </pre><br>  I do not fully understand the work of this method, but it seems that with each movement it transforms our door depending on the base point and the rotation vector, this ultimately allows us to open or close the door in the drawing. <br><br>  Next, we redefine the event that seems to occur when the object is transformed. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTransform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Matrix3d tfm</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// To be able to cancel(Undo) McUndoPoint undo = new McUndoPoint(); undo.Start(); // Get the coordinates of the base point and the rotation vector this.TryModify(); this._pnt1 = this._pnt1.TransformBy(tfm); this.TryModify(); this._vecStraightDirection = this._vecStraightDirection.TransformBy(tfm); // We move the door only when it is closed if not - undo if (_dStatus == status.closed) _vecDirectionClosed = _vecStraightDirection; else { MessageBox.Show("Please transform only closed door"); undo.Undo(); } undo.Stop(); }</span></span></code> </pre><br>  To begin with, I will say that in order not to get stuck with the development, I simplified some points, especially those solutions that were given to me with difficulty.  One of these simplifications is the restriction on door manipulation. <br><br>  You can only move, rotate, copy and somehow change the door in the closed state (it is installed by default). <br><br>  In order for it to work this way, we create an undo object and mark the starting point for committing changes. <br><br>  After that, if everything is normal, we transfer the state _pnt1 and the vector ._vecStraightDirection to their state after transformation. <br><br>  Then the condition is checked, if the door was closed, the changes are applied and additionally entered into a vector that stores the position of the closed door. <br>  If the door was open (or ajar), we give an error message and discard all changes. <br><br>  The door height field is similar to a wall. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Define the custom properties of the object [DisplayName("Height")] [Description("Height of door")] [Category("Door options")] public double HDoor { get { return _h; } set { //Save Undo state and set the object status to "Changed" if (!TryModify()) return; _h = value; } }</span></span></code> </pre><br>  But the next field - new <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DisplayName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Door status"</span></span></span><span class="hljs-meta">)</span></span>] [Description(<span class="hljs-string"><span class="hljs-string">"Door may be: closed, middle, open"</span></span>)] [Category(<span class="hljs-string"><span class="hljs-string">"Door options"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> status Stat { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dStatus; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Save Undo state and set the object status to "Changed" if (!TryModify()) return; // Change the rotation vector for each of the door states switch (value) { case status.closed: _vecStraightDirection = _vecDirectionClosed; break; case status.middle: _vecStraightDirection = _vecDirectionClosed.Add(_vecDirectionClosed.GetPerpendicularVector().Negate() * 0.575) ; break; case status.open: _vecStraightDirection = _vecDirectionClosed.GetPerpendicularVector()*-1; break; default: _vecStraightDirection = _vecDirectionClosed; break; } _dStatus = value; } }</span></span></code> </pre><br>  It is here that we are responsible for the state of the door, a drop-down list appears in the properties window with the values: closed, middle, open (one to one, as the definition of the first class enumeration). <br><br>  When choosing each of the values, the vector responsible for turning the door eventually changes. <br><br>  When closed, it is set to the previously saved state of _vecDirectionClosed; <br><br>  In the half-open state, the resulting vector is obtained, which rotates our door at an angle of about 30 degrees, so that it is similar to the designation according to GOST. <br><br>  When open, we just take a perpendicular to our closed state vector with a negative value (so that the door opens down by default). <br><br>  I think the default case is not needed at all, but I left it. <br><br>  Well, the last is a handle for manipulation. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Create a grip for the base point of the object public override bool GetGripPoints(GripPointsInfo info) { info.AppendGrip(new McSmartGrip&lt;DoorPseudo3D&gt;(_pnt1, (obj, g, offset) =&gt; { obj.TryModify(); obj._pnt1 += offset; })); return true; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> There are many shortcomings in this code. // Including failures when working with copying, moving objects and saving files, you can improve it if you want. }</span></span></code> </pre><br>  For it you can drag and all.  From time to time, I have pens on both objects, wherever I go, but I don‚Äôt have the strength to debug it (I thought I would finish the article faster, and I had already killed three full days). <br><br>  So, press F5 and use the DRAWWALL and DRAWDOOR commands to insert our doors and walls. <br>  As a result, we get what's in the picture.  On it I show you the work of the library from 4 different angles.  Sheep unfortunately flat, and I drew them by hand.  Well, the doors with walls slightly differ from those in the latest version of the .dwg file on GitHub, just made a couple of edits, and it was too lazy to retake screenshots. <br><br>  <i>If you will be loading your library manually with the NETLOAD command, remember that it must be loaded before opening the file with our objects, or they are recognized as proxy objects.</i> <br><br>  For those who are new to working with Nanocad, I remind you that getting a three-dimensional view of your objects is conveniently done like this: view-&gt; orbit-&gt; dependent orbit, and you can return the two-dimensional view back like this: view-&gt; views and projections-&gt; view in plan-&gt; current UCS. <br><br><img src="https://habrastorage.org/webt/et/ki/0r/etki0rwk6eiqlifwnfis29xp6aw.png"><br><br><a name="III"></a><br><h3>  3. We try to adapt the code for a free NanoCAD 5.1. </h3><br><img src="https://habrastorage.org/webt/td/b7/ko/tdb7kopodkzgdtwlffqc4sfriww.jpeg"><br><br>  In the last article, for some reason, the face painting team did not work for me, but this time we managed to adapt the code and our object is launched with some limitations in the free version of NanoCAD 5.1. <br><br>  To begin, briefly tell you how to set up the environment, almost no difference. <br><br>  Therefore, I again only briefly mention the procedure for assembling under Nanocad 5.1: <br><br><ol><li>  Create a new project, select the .NET Framework 3.5 platform, and select a C # class library as a template. </li><li>  For the Nanocad version x32 (and 5.1 is only this) from the SDK \ include \ folder, add a link to the project to: mapimgd.  Do not forget to copy the property locally to False. </li><li>  Also add links to the assembly from Microsoft: System.Windows.Forms.dll, System.Drawing.dll. </li><li>  In the project properties, on the ‚ÄúDebug‚Äù tab, as the action at startup, select ‚Äúopen in external program‚Äù and specify the path to the NC 5.1 executable file (I have C: \ Program Files (x86) \ Nanosoft \ nanoCAD 5.1 \ nCad. exe) </li><li>  I even before the heap in the "Assembly" set the final platform - x86. </li><li>  Create two classes DoorPseudo3D_nc51.cs and WalllPseudo3D_nc51.cs for the door and the wall respectively. </li><li>  Let's go to C: \ ProgramData \ Nanosoft \ nanoCAD 5.1 \ DataRW (you may differ) and find or create a load.config file with the following content <br></li></ol><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">module</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"C:\Users\...\bin\Debug\ nanodoor2_51.dll"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Your file paths will be yours. <br><br>  The code will not drastically differ, so I will hide both classes under the spoiler and explain only the differences. <br><br>  So, the wall: <br><br><div class="spoiler">  <b class="spoiler_title">Complete code for the wall</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Use Microsoft .NET Framework 3.5 and old version of MultiCad.NET (for NC 5.1) //Class for demonstrating the capabilities of MultiCad.NET //Assembly for the Nanocad 5.1 //Link mapimgd from Nanocad SDK //Link System.Windows.Forms and System.Drawing //The commands: draws a pseudo 3D wall. //This code in the part of non-infringing rights Nanosoft can be used and distributed in any accessible ways. //For the consequences of the code application, the developer is not responsible. //More detailed - https://habrahabr.ru/post/342680/ using System; using System.ComponentModel; using Multicad.Runtime; using Multicad.DatabaseServices; using Multicad.Geometry; using Multicad.CustomObjectBase; using Multicad; namespace nanowall2 { //change "8b0986c0-4163-42a4-b005-187111b499d7" for your Guid from Assembly. // Be careful GUID for door and wall classes must be different! // Otherwise there will be problems with saving and moving [CustomEntity(typeof(WalllPseudo3D_nc51), "b4edac1f-7978-483f-91b1-10503d20735a", "WalllPseudo3D_nc51", "WalllPseudo3D_nc51 Sample Entity")] [Serializable] public class WalllPseudo3D_nc51 : McCustomBase { // First and second vertices of the box private Point3d _pnt1 = new Point3d(100, 100, 0); private Point3d _pnt2 = new Point3d(500, 100, 0); private double _h = 2085; private double _scale = 1000; [CommandMethod("DrawWall", CommandFlags.NoCheck | CommandFlags.NoPrefix)] public void DrawWall() { WalllPseudo3D_nc51 wall = new WalllPseudo3D_nc51(); wall.PlaceObject(); } public override void OnDraw(GeometryBuilder dc) { dc.Clear(); // Define the basic points for drawing Point3d pnt1 = _pnt1; Point3d pnt2 = new Point3d(_pnt2.X, pnt1.Y, 0); Point3d pnt3 = new Point3d(pnt2.X, pnt1.Y+(150 * _scale), 0); Point3d pnt4 = new Point3d(pnt1.X , pnt3.Y, 0); // Set the color to ByObject value dc.Color = McDbEntity.ByObject; Vector3d hvec = new Vector3d(0, 0, _h * _scale); // Draw the upper and lower sidestes dc.DrawPolyline(new Point3d[] { pnt1, pnt2, pnt3, pnt4, pnt1 }); dc.DrawPolyline(new Point3d[] { _pnt1.Add(hvec), pnt2.Add(hvec), pnt3.Add(hvec), pnt4.Add(hvec), pnt1.Add(hvec)}); // Draw the edges dc.DrawLine(pnt1, pnt1.Add(hvec)); dc.DrawLine(pnt2, pnt2.Add(hvec)); dc.DrawLine(pnt3, pnt3.Add(hvec)); dc.DrawLine(pnt4, pnt4.Add(hvec)); } //Define the custom properties of the object [DisplayName("WScale")] [Description("Wall Scale")] [Category("Wall options")] public double WScale { get { return _scale; } set { if (!TryModify()) return; _scale = value; } } [DisplayName("Height")] [Description("Height of wall")] [Category("Wall options")] public double HWall { get { return _h; } set { //Save Undo state and set the object status to "Changed" if (!TryModify()) return; _h = value; } } public override hresult PlaceObject(PlaceFlags lInsertType) { InputJig jig = new InputJig(); // Get the first box point from the jig InputResult res = jig.GetPoint("Select first point:"); if (res.Result != InputResult.ResultCode.Normal) return hresult.e_Fail; _pnt1 = res.Point; // Add the object to the database this.DbEntity.AddToCurrentDocument(); //Exclude the object from snap points jig.ExcludeObject(ID); // Monitoring mouse moving and interactive entity redrawing jig.MouseMove = (s, a) =&gt; { TryModify(); _pnt2 = a.Point; this.DbEntity.Update(); }; // Get the second box point from the jig res = jig.GetPoint("Select second point:"); if (res.Result != InputResult.ResultCode.Normal) { this.DbEntity.Erase(); return hresult.e_Fail; } _pnt2 = res.Point; return hresult.s_Ok; } // Create a grip for the base point of the object public override bool GetGripPoints(GripPointsInfo info) { info.AppendGrip(new McSmartGrip&lt;WalllPseudo3D_nc51&gt;(_pnt1, (obj, g, offset) =&gt; { obj.TryModify(); obj._pnt1 += offset; })); info.AppendGrip(new McSmartGrip&lt;WalllPseudo3D_nc51&gt;(_pnt2, (obj, g, offset) =&gt; { obj.TryModify(); obj._pnt2 += offset; })); return true; } } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> There are many shortcomings in this code. // Including failures when working with copying, moving objects and saving files, you can improve it if you want. }</span></span></code> </pre></div></div><br>  What is the difference, firstly, when I tried to insert objects into an empty drawing, then Nanocad scaled it to me so that neither the wall nor the door could be seen, and I added a field with a scale. <br><br>  For a wall, it changes the thickness of the wall, and for a door, it changes its thickness and length. <br><br>  Accordingly, the necessary coordinates are now multiplied by the scale for which there is an open property. <br><br>  And the second difference in the old version of the MultiCAD.NET API is that there is no class for working with hatching, I can assume that it can be implemented through the API for regular .NET, but I did not. <br><br>  Now the door: <br><br><div class="spoiler">  <b class="spoiler_title">Full door code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Use Microsoft .NET Framework 3.5 and old version of MultiCad.NET (for NC 5.1) //Class for demonstrating the capabilities of MultiCad.NET //Assembly for the Nanocad 5.1 //Link mapimgd from Nanocad SDK //Link System.Windows.Forms and System.Drawing //The commands: draws a pseudo 3D door. //This code in the part of non-infringing rights Nanosoft can be used and distributed in any accessible ways. //For the consequences of the code application, the developer is not responsible. //More detailed - https://habrahabr.ru/post/342680/ // PS A big thanks to Alexander Vologodsky for help in developing a method for pivoting object. using System; using System.ComponentModel; using System.Windows.Forms; using Multicad.Runtime; using Multicad.DatabaseServices; using Multicad.Geometry; using Multicad.CustomObjectBase; using Multicad; namespace nanodoor2 { //change "8b0986c0-4163-42a4-b005-187111b499d7" for your Guid from Assembly. // Be careful GUID for door and wall classes must be different! // Otherwise there will be problems with saving and moving [CustomEntity(typeof(DoorPseudo3D_nc51), "b4edac1f-7978-483f-91b1-10503d20735b", "DoorPseudo3D_nc51", "DoorPseudo3D_nc51 Sample Entity")] [Serializable] public class DoorPseudo3D_nc51 : McCustomBase { // First and second vertices of the box private Point3d _pnt1 = new Point3d(0, 0, 0); private double _scale = 1000; private double _h = 2085; private Vector3d _vecStraightDirection = new Vector3d(1, 0, 0); private Vector3d _vecDirectionClosed = new Vector3d(1, 0, 0); public enum status { closed , middle, open }; private status _dStatus = status.closed; [CommandMethod("DrawDoor", CommandFlags.NoCheck | CommandFlags.NoPrefix)] public void DrawDoor() { DoorPseudo3D_nc51 door = new DoorPseudo3D_nc51(); door.PlaceObject(); } public override void OnDraw(GeometryBuilder dc) { dc.Clear(); // Define the basic points for drawing Point3d pnt1 = new Point3d(0, 0, 0); Point3d pnt2 = new Point3d(pnt1.X + (984 * _scale), pnt1.Y, 0); Point3d pnt3 = new Point3d(pnt2.X + 0, pnt1.Y+(50 * _scale), 0); Point3d pnt4 = new Point3d(pnt1.X , pnt3.Y, 0) ; // Set the color to ByObject value dc.Color = McDbEntity.ByObject; Vector3d hvec = new Vector3d(0, 0, _h * _scale) ; // Draw the upper and lower sides dc.DrawPolyline(new Point3d[] { pnt1, pnt2, pnt3, pnt4, pnt1 }); dc.DrawPolyline(new Point3d[] { pnt1.Add(hvec), pnt2.Add(hvec), pnt3.Add(hvec), pnt4.Add(hvec), pnt1.Add(hvec)}); // Draw the edges dc.DrawLine(pnt1, pnt1.Add(hvec)); dc.DrawLine(pnt2, pnt2.Add(hvec)); dc.DrawLine(pnt3, pnt3.Add(hvec)); dc.DrawLine(pnt4, pnt4.Add(hvec)); // Drawing a Door Handle dc.DrawLine(pnt2.Add(new Vector3d( -190 * _scale, -0, _h*0.45 * _scale)), pnt2.Add(new Vector3d(-100 * _scale, 0, _h * 0.45 * _scale))); dc.DrawLine(pnt3.Add(new Vector3d(-190 * _scale, 0, _h * 0.45 * _scale)), pnt3.Add(new Vector3d(-100 * _scale, 0, _h * 0.45 * _scale))); } public override hresult PlaceObject(PlaceFlags lInsertType) { InputJig jig = new InputJig(); // Get the first box point from the jig InputResult res = jig.GetPoint("Select first point:"); if (res.Result != InputResult.ResultCode.Normal) return hresult.e_Fail; _pnt1 = res.Point; // Add the object to the database DbEntity.AddToCurrentDocument(); return hresult.s_Ok; } /// &lt;summary&gt; /// Method for changing the object's SC (the graph is built at the origin of coordinates). /// &lt;/ summary&gt; /// &lt;param name = "tfm"&gt; The matrix for changing the position of the object. &lt;/ param&gt; /// &lt;returns&gt; True - if the matrix is passed, False - if not. &lt;/ returns&gt; public override bool GetECS(out Matrix3d tfm) { // Create a matrix that transforms the object. // The object is drawn in coordinates(0.0), then it is transformed with the help of this matrix. tfm = Matrix3d.Displacement(this._pnt1.GetAsVector()) * Matrix3d.Rotation (-this._vecStraightDirection.GetAngleTo(Vector3d.XAxis, Vector3d.ZAxis), Vector3d.ZAxis, Point3d.Origin); return true; } public override void OnTransform(Matrix3d tfm) { // To be able to cancel(Undo) McUndoPoint undo = new McUndoPoint(); undo.Start(); // Get the coordinates of the base point and the rotation vector this.TryModify(); this._pnt1 = this._pnt1.TransformBy(tfm); this.TryModify(); this._vecStraightDirection = this._vecStraightDirection.TransformBy(tfm); // We move the door only when it is closed if not - undo if (_dStatus == status.closed) _vecDirectionClosed = _vecStraightDirection; else { MessageBox.Show("Please transform only closed door (when its status = 0)"); undo.Undo(); } undo.Stop(); } //Define the custom properties of the object [DisplayName("Height")] [Description("Height of door")] [Category("Door options")] public double HDoor { get { return _h; } set { //Save Undo state and set the object status to "Changed" if (!TryModify()) return; _h = value; } } [DisplayName("DScale")] [Description("Door Scale")] [Category("Door options")] public double DScale { get { return _scale; } set { if (!TryModify()) return; _scale = value; } } [DisplayName("Door status")] [Description("0-closed, 1-midle, 2-open")] [Category("Door options")] public status Stat { get { return _dStatus; } set { //Save Undo state and set the object status to "Changed" if (!TryModify()) return; // Change the rotation vector for each of the door states switch (value) { case status.closed: _vecStraightDirection = _vecDirectionClosed; break; case status.middle: _vecStraightDirection = _vecDirectionClosed.Add(_vecDirectionClosed.GetPerpendicularVector().Negate() * 0.575) ; break; case status.open: _vecStraightDirection = _vecDirectionClosed.GetPerpendicularVector()*-1; break; default: break; } _dStatus = value; } } // Create a grip for the base point of the object public override bool GetGripPoints(GripPointsInfo info) { info.AppendGrip(new McSmartGrip&lt;DoorPseudo3D_nc51&gt;(_pnt1, (obj, g, offset) =&gt; { obj.TryModify(); obj._pnt1 += offset; })); return true; } } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> There are many shortcomings in this code. // Including failures when working with copying, moving objects and saving files, you can improve it if you want. }</span></span></code> </pre></div></div><br>  Again, almost everything is the same, the only thing is that in version 5.1 it looks like the field processes enumerations differently and in the object properties window instead of closed / open, we will see enumeration values: 0, 1, 2 this is not very obvious, so we slightly changed the warning about by mistake.  Also, the door has no hatching and there is an extra property for scale (by the way, if you wish, you can also implement it in classes for NC 8.5). <br><br>  It turns out like this: <br><br><img src="https://habrastorage.org/webt/wh/je/ku/whjekukwfeo3obig6msadilksfu.jpeg"><br><br><a name="IV"></a><br><h3>  4. Multikukish (Conclusion) </h3><br> <a href="https://www.youtube.com/watch%3Fv%3Dei1DvIgW_PU"><img src="https://habrastorage.org/webt/my/ic/fr/myicfrgymann7arojumclgfulva.png"><br></a> <br><br>  As you remember from the last article, Nanosoft and I are in no way connected, which means I can afford a small element of criticism.  The developers declare support for the MultiCAD.NET API in AutoCAD and ZWCAD through a certain layer, there is even <a href="https://habrahabr.ru/company/nanosoft/blog/242497/">an article about it</a> . <br><br>  But it seems that this is a non-priority direction of development.  In the <a href="https://habrahabr.ru/post/342186/">last article, I wrote</a> that I could not test this function because I have AutoCAD 2017 installed on my computer, and the last layer posted on the developers' website - ‚ÄúMultiCAD_AC_ZC_Enabler_2209_RU.zip‚Äù (which is already 1.5 years old) does not support anything older than AutoCAD 2016. For the sake of such pleasure, I did not want another version of AutoCAD. <br><br>  This time I decided to try another option, downloaded the trial version of ZWCAD + 2015, again the latest version that this layer supports.  I don‚Äôt know, maybe I‚Äôve got a ‚Äúhandle‚Äù, but neither this library nor the library from the previous article ever ‚Äúflew up‚Äù in ZWCAD.  Therefore, if someone succeeds in running it, and he will share a screenshot, I will be grateful. <br><br>  But as for the rest, I must say that the more you fiddle with this API, the more you pull in and even start to enjoy a little, it is noticeable that the API is improving, some members of the API classes already have a valid description in Russian, and the API itself becomes more self-sufficient. <br><br>  I think that when NanoCAD 9 comes out (or whatever they call it) with support for DWG 2018, it will be even better (especially if the developers promised at the forum, it will be followed by a new free <a href="http://forum.nanocad.ru/index.php%3Fshowtopic%3D7837">NanoCad</a> ). <br><br>  So I want to say to all participants of the Nanocad Developer Forum - thanks for the help, developers - thanks for posting NC 8.5, and for all readers - thanks for mastering the article to the end. <br><br> <b>PS</b>          ,   ,   ¬´ ¬ª           (      ,    ).           ‚Ä¶ <br><br><div class="spoiler"> <b class="spoiler_title">...</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kl/nh/wi/klnhwisc8p5sdv_fsrzm8oymbro.png"><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/342680/">https://habr.com/ru/post/342680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342666/index.html">Facebook or Google? Where it is more profitable to advertise in 2017</a></li>
<li><a href="../342668/index.html">How to write your first Linux device driver. Part 3</a></li>
<li><a href="../342670/index.html">The experience of identifying one bug or how not to make out your code</a></li>
<li><a href="../342674/index.html">About the rotation matrix in simple words</a></li>
<li><a href="../342676/index.html">Detailed analysis of the crackme01_x64 solution</a></li>
<li><a href="../342684/index.html">Glass brick fences, online translator plot, remote Boeing hacking</a></li>
<li><a href="../342686/index.html">Optimize frontend. Part 1. Why I don‚Äôt like the word treeshaking or where the webpack deceives you</a></li>
<li><a href="../342688/index.html">Career or science: why at ITMO University you do not need to choose one thing</a></li>
<li><a href="../342690/index.html">How to limitlessly * surf ** on a smartphone for 20 *** rubles a month</a></li>
<li><a href="../342692/index.html">IaaS Digest: Guides, Trends, and Cases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>