<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedding functional objects, functions and lambdas through templates and unification using virtual in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article shows some of the mechanisms that allow you to get quite productive (embedded at compile time) and easily scalable code for managing call...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedding functional objects, functions and lambdas through templates and unification using virtual in C ++</h1><div class="post__text post__text-html js-mediator-article">  This article shows some of the mechanisms that allow you to get quite productive (embedded at compile time) and easily scalable code for managing calls to various objects using standard C ++ technologies. <br><br><h3>  About the task </h3><br>  Some time ago there was a need to implement a small module, which, depending on the user (runtime) information, would perform various actions inside the program kernel.  At the same time, the main requirements were maximum performance (optimizability) of the code, the absence of third-party dependencies, and simple scaling in the event of adding functionality. <br><br>  For greater simplicity and readability, only the most complex key mechanisms will be shown in the code examples.  Machine code examples are provided for the Microsoft compiler when optimizing O2. <br><a name="habracut"></a><br><h3>  The first steps </h3><br>  The solution to the problem in the style of "C" would be a simple use of pointers to functions, the values ‚Äã‚Äãof which are specified during data processing.  However, besides the pointers themselves, it was necessary to store some additional information for each function.  As a result, to provide the most common solution, the choice focused on an abstract class with the required set of fields and methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The object approach allows you to abstract from low-level implementations and work with broader concepts, which in my opinion makes it easier to understand the code and device of the program as a whole. <br><br>  A simple example of this class: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObj</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> FType = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>( *)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~MyObj() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>  Here the main is the virtual operator " <b>()</b> ", the Virtual destructor is needed from <a href="http://en.cppreference.com/w/cpp/language/destructor"><u>obvious</u></a> considerations, and FType just defines the semantics of the main method in terms of the types of arguments and return. <br><br>  Having a similar class, manipulations with function pointers are replaced by working with pointers to the MyObj type.  Pointers can be conveniently stored in lists or, say, tables, and all that remains is to initialize correctly.  The main difference is that objects can have a state and the inheritance mechanism is applicable for them.  This greatly expands and simplifies the possibility of adding various ready-made functionality from external libraries to this code. <br><br>  With this approach, there is another important plus: the call control itself is transferred to the virtuality mechanism, which provides some protection against errors and problems with optimization at the compiler level. <br><br><h3>  Embedding </h3><br>  Actually the most important step to the optimal work of the program is the writing of inline code.  In essence, this requires that the executed sequence of instructions be minimally dependent on the data runtime.  In this case, the compiler will be able to embed the code of functions to the place of their call instead of switching (calling) to an address and / or throwing out unnecessary pieces of code.  The same criteria allow us to collect machine code avoiding long jumps and frequent changes to the processor cache, but this is another story. <br><br>  Unfortunately in our case there is an obvious problem with the choice of actions on user data.  This process has been transferred to the virtuality mechanism and the next thing to do is ensure that everything else is built in.  To do this, you need to use inheritance and calls for third-party functionality to move inside the overloaded methods.  In this case, they can be successfully embedded and optimized. <br><br><h3>  Inheritance </h3><br>  The first step is to deal directly with the inheritance of an abstract class.  The simplest way is the ‚Äúmanual‚Äù operator overload during inheritance.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyObj { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }; }addObj; <span class="hljs-comment"><span class="hljs-comment">// manually inherited structure MyObj* po = &amp;addObj; int res = (*po)( a, b );</span></span></code> </pre> <br>  In this case, it turns out that an optimized call to the virtual method will immediately transfer to the folding of two numbers.  When optimizing O2, MSVS produces approximately the following machine code for calling * (register preparation, argument packing): <br><br><pre> <code class="cpp hljs">push dword ptr [b] mov eax,dword ptr [esi] mov ecx,esi push dword ptr [a] call dword ptr [eax]</code> </pre> <br>  and such code for the actual overloaded method: <br><br><pre> <code class="cpp hljs">push ebp mov ebp,esp mov eax,dword ptr [a] add eax,dword ptr [b] pop ebp ret <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  <i>* The first part is absolutely the same for all cases, since it depends only on the semantics of the call itself, therefore this code will be further ignored.</i>  <i>This article always uses the option <code>res = (*po)(a, b);</code></i>  <i>.</i> <br><br>  In some cases, optimization is even better, for example, g ++ can compress the folding of integers to 2 instructions: lea, ret.  In this article, for brevity, I will limit myself to examples obtained on the Microsoft compiler, while noting that the code was also tested for g ++ under linux. <br><br><h3>  Functors </h3><br>  The logical continuation is the question ‚Äúwhat if you need to execute complex code implemented in third-party functions?‚Äù.  Naturally, this code must be executed inside the overloaded method of the successor MyObj, but if you manually create your own (even anonymous) class for each case, initialize its object and pass on its address, you can not even remember about clarity and scalability. <br><br>  Fortunately, in C ++ there is an excellent template mechanism for this, which implies the compile-time resolution of the code and, accordingly, embedding.  Thus, you can arrange a simple template that will take a functor as a parameter, create an anonymous inheritor class MyObj, and call the resulting parameter inside an overloaded method. <br><br>  But (of course there is a ‚Äúbut‚Äù), what about lambda and other dynamic objects?  It is worth noting that <a href="http://en.cppreference.com/w/cpp/language/lambda">lambda</a> in C ++, because of their implementation and behavior, must be perceived as objects, and not as functions.  Unfortunately, lambda expressions in C ++ do not meet the requirements of the template parameter.  This problem is torn to fix in the 17th standard, and even without it, not everything is so bad. <br><br>  A simple and very pleasant solution was peeped <a href="http://stackoverflow.com/questions/28616943/lambda-as-template-parameter">here</a> .  In fact, it consists in fair transmission of a dynamic object as a function argument with further dances with a tambourine, but the compiler can easily optimize this code and embed everything that is needed. <br><br>  As a result, you can write a small pair: a wrapper class and a wrapper function that will give the result we need: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapping</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyObj { Func _f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Wrapping( Func f ) : _f( f ) {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _f( a, b ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapping</span></span></span><span class="hljs-class">&lt;Func&gt;* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Wrapping&lt;Func&gt; W( f ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; }</code> </pre><br>  To initialize the pointer, simply call the function Wrap and pass the desired object as an argument.  Moreover, in view of the peculiarities of the concept of a functor (and this is exactly the work with it), an argument can be absolutely any executable object or just a function with an appropriate number of arguments, even if they are of a different type. <br><br>  An example of a call might be: <br><br><pre> <code class="cpp hljs">po = Wrap( []( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b ) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } );</code> </pre> <br>  Despite the complicated look, the set of instructions for the overloaded ‚Äú <b>()</b> ‚Äù operator will be very simple, actually identical to that obtained with manual inheritance and embedding: <br><br><pre> <code class="cpp hljs">push ebp mov ebp,esp mov eax,dword ptr [a] add eax,dword ptr [b] pop ebp ret <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  All complex conditional transitions and initializations occur when Wrap is called, after which only the mechanism for invoking virtual methods remains.  In addition to all the work goes with a static object, which means there is hope for the lack of calls to the heap and longjumps. <br><br>  Interestingly, almost any instances can be embedded.  For example, the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddStruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } }; ... op = Wrap( AddStruct() );</code> </pre><br>  Will have the following machine code overloaded operator: <br><br><pre> <code class="cpp hljs">push ebp mov ebp,esp mov eax,dword ptr [a] add eax,dword ptr [b] pop ebp ret <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Those.  same as with manual embedding.  I managed to get similar machine code even for an object created through new.  But we will leave this example aside. <br><br><h3>  Functions </h3><br>  The above code has significant problems when it comes to normal functions.  This wrapper can easily accept as an argument a pointer to a function of the type: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }; ... po = Wrap( sub );</code> </pre><br>  But in the machine code of the overloaded method there will be another call, respectively, with the transition: <br><br><pre> <code class="cpp hljs">push ebp mov ebp,esp push dword ptr [b] mov eax,dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">4</span></span>] push dword ptr [a] call eax add esp,<span class="hljs-number"><span class="hljs-number">8</span></span> pop ebp ret <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  This means that in view of certain circumstances (namely, the different nature of functions and objects) in this way, the function cannot be built in. <br><br><h4>  Functions with identical semantics </h4><br>  Returning to the beginning of the article, remember that for embedding you can pass the desired object (and in this case, a function) through the template parameter.  And just once for the function pointer this action is allowed.  I use the type defined in our abstract class that defines the semantics of the method being called, you can easily overload the wrapper wrapper pair specifically for such functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWrapping</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyObj { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f( a, b ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;MyObj::FType f&gt; FWrapping&lt;MyObj::FType, f&gt;* Wrap() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FWrapping&lt;MyObj::FType, f&gt; W; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; }</code> </pre> <br>  Wrapping Overloaded Wrap for View Functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } ... po = Wrap&lt;add&gt;();</code> </pre> <br>  You can get the optimal machine code, identical to that obtained by manual inheritance: <br><br><pre> <code class="cpp hljs">push ebp mov ebp,esp mov eax,dword ptr [a] add eax,dword ptr [b] pop ebp ret <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br><h4>  Functions with excellent semantics </h4><br>  The last question is the situation when the function necessary for embedding does not coincide in type with that declared in MyObj.  For this case, you can easily add another overload of the wrapper function, in which the type will be passed as another template parameter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWrapping</span></span></span><span class="hljs-class">&lt;Func, f&gt;* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span><span class="hljs-class">() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FWrapping&lt;Func, f&gt; W; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; }</code> </pre> <br>  Calling this function requires manual indication of the type of the function being transferred, which is not always convenient.  To simplify the code, you can use the <code>decltype( )</code> keyword: <br><br><pre> <code class="cpp hljs">po = Wrap&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( add )*, add&gt;();</code> </pre> <br>  It is important to note the need to put " <b>*</b> " after <code>decltype</code> , otherwise the development environment may give an error message about the lack of a Wrap implementation that satisfies these arguments.  Despite this, the project is likely to compile normally.  This discrepancy is caused by the rules for determining types when passing to a template and, in fact, by the principle of operation of <code>decltype</code> .  To avoid an error message, you can use a construct such as <code>std::decay</code> to ensure correct type substitution, which is conveniently wrapped in a simple macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> declarate( X ) std::decay</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; decltype( X ) &gt;::type ... po = Wrap&lt;declarate( add ), add&gt;();</span></span></span></span></code> </pre> <br>  Or just to track compliance manually, if you do not want to produce entities. <br><br>  Of course, the machine code when embedding such a function will be different, since at least a type conversion is required.  For example, when calling a function defined as: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } ... op = Wrap&lt;declarate(fadd), fadd&gt;();</code> </pre> <br>  From the disassembler will be about this: <br><br><pre> <code class="cpp hljs">push ebp mov ebp,esp movd xmm1,dword ptr [a] movd xmm0,dword ptr [b] cvtdq2ps xmm1,xmm1 cvtdq2ps xmm0,xmm0 addss xmm1,xmm0 cvttss2si eax,xmm1 pop ebp ret <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br><h4>  Functions together </h4><br>  Having received additional overloads of the Wrap function for embedding the other functions proper, in order to avoid code repetition and to get closer to Zen, you can redefine one of the options by calling another: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWrapping</span></span></span><span class="hljs-class">&lt;Func, f&gt;* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span><span class="hljs-class">() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FWrapping&lt;Func, f&gt; W; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;MyObj::FType f&gt; FWrapping&lt;MyObj::FType, f&gt;* Wrap() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Wrap&lt;MyObj::FType, f&gt;(); }</code> </pre> <br>  It should be noted that all three overloads of the function Wrap can exist simultaneously, since the parameters of the templates obey the same rules regarding polymorphism as the arguments of the functions. <br><br><h3>  Together </h3><br>  As a result of the above, for &lt;50 lines we got a mechanism that allows you to automatically convert any executable objects and functions with fairly <i>close *</i> semantics to a unified type with the possible addition of necessary properties and maximum embedding of the executable code. <br><br>  <i>* close enough for this example means a coincidence in the number of arguments and subject to the coincidence or possibility of implicit type conversion.</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObj</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> FType = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>( *)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~MyObj() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapping</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyObj { Func _f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Wrapping( Func f ) : _f( f ) {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _f( a, b ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWrapping</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyObj { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f( a, b ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapping</span></span></span><span class="hljs-class">&lt;Func&gt;* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Wrapping&lt;Func&gt; W( f ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWrapping</span></span></span><span class="hljs-class">&lt;Func, f&gt;* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span><span class="hljs-class">() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FWrapping&lt;Func, f&gt; W; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;MyObj::FType f&gt; FWrapping&lt;MyObj::FType, f&gt;* Wrap() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Wrap&lt;MyObj::FType, f&gt;(); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> declarate( X ) std::decay</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; decltype( X ) &gt;::type</span></span></span></span></code> </pre> <br>  A potential problem for this mechanism is the need to "wrap" functions with an excellent number of arguments or types not implicitly (implicitly).  A certain solution is to call such functions (functors) inside a wrapped lambda.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; c )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*b*c; }; ... po = Wrap( []( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b )-&gt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> volume( a, b, <span class="hljs-number"><span class="hljs-number">10</span></span> ); } );</code> </pre> <br>  Code examples are <a href="">here</a> .  To build you need to use C ++ 11.  In order to see the difference in embedding - O2 optimization.  The code is prepared to avoid excessive embedding. <br>  ______________________________ <br><br><h4>  Addition </h4><br><br>  In the comments there were several important questions that I will try to answer. <br><br><h5>  1) Differences from <code>std::function</code> : </h5><br><br>  First of all, I want to note that the essence of the task was to transfer the call control to the virtuality mechanism (the reason for this need is beyond the scope of the article).  Therefore, all variants of the <code>Wrap</code> function should be perceived as a <b>way to generate a class of successor</b> .  Therefore, each call must be made ‚Äúmanually‚Äù - the use of functions inside the cycle will lead to incorrect program behavior.  This is a disadvantage compared to the same <code>std::function</code> . <br><br>  The second important point is that this implementation does NOT work with dynamic memory.  This gives a potential advantage in terms of performance.  Moreover, if in practice there is an urgent need to use dynamic memory all the same, it will be necessary to change just a couple of lines inside each function with the addition of the <code>new</code> operator.  However, in this case, be sure to need to control the cleaning of memory (which is now happening automatically). <br>  With this approach, it is still possible to embed the executable code (similar to what happens in <code>std::function</code> , and at the same time it remains a working mechanism for virtual calls. <br><br><h5>  2) <code>Wrap</code> incorrectly when calling multiple times for objects of the same type with different states </h5><br><br>  Thanks to attentive people - I really missed the possibility of incorrect (not obvious) work of the code in the case when, when processing functors of the same type, different instances with different states are transferred.  In this case, the static object of the <code>Wrapping</code> class will be initialized only 1 time with the very first argument.  All other calls will have no effect. <br><br>  The first thing to do is add protection against such situations.  To do this, you can simply add a flag and generate an exception when trying to reinitialize, for example like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapping</span></span></span><span class="hljs-class">&lt;Func&gt;* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrap</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> recallFlag{}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( recallFlag ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"Second Wrap of the same type!\n"</span></span>; recallFlag++; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Wrapping&lt;Func&gt; W( f ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;W; }</code> </pre><br>  (I apologize for the nonstandard object for throw) <br><br>  However, this is not a solution to the problem, but only an alarm in case of accidents. <br><br>  A simple and effective solution is to add a parameter (with a default value) to the template of the Wrap function.  If necessary, this parameter can be changed, and then another implementation of the function will be called, respectively, with another static Wrapping instance: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, class Func&gt; Wrapping&lt;Func&gt;* Wrap( Func f ) {...}</code> </pre><br><br>  After that, each time you call for the arguments of one type, you will need to pass a new value as a parameter.  Manually doing this is somewhat inconvenient.  There are several solutions: <br>  - add a small macro using the predefined macro __COUNTER__ or __LINE__. <br>  - to collect on the basis of the above-mentioned macros a certain template counter. <br>  - go on an <s>esoteric</s> exotic path and collect a purely template counter. <br><br>  <b>The first</b> solution is very reliable and simple.  However, please note that when using Wrap in different files, the __LINE__ macro can give the same result, and the __COUNTER__ macro is not standard, although it is implemented on most compilers.  Also, conflicts can arise if other modules of the program use this macro in some way and require sole rights to it.  In general, the solution looks like this: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OWrap( ... ) \ Wrap</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;__COUNTER__&gt;( __VA_ARGS__ )</span></span></span></span></code> </pre><br>  In addition, you can define macros for a simple call to Wrap under function arguments: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FWrap( ... ) \ Wrap</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;declarate( __VA_ARGS__ ), __VA_ARGS__&gt;()</span></span></span></span></code> </pre><br><br>  <b>The second</b> option can be implemented using for example solutions <a href="http://www.codeproject.com/Articles/776770/Automatic-Static-Cplusplus-Counter-with-Scope"><u>from here</u></a> and <a href="http://stackoverflow.com/questions/6166337/does-c-support-compile-time-counters"><u>from here</u></a> .  Then you can just as well substitute the result inside the macro. <br><br>  <b>Last</b> , but in my opinion - the most interesting version is inspired by <a href="http://b.atch.se/posts/constexpr-counter/"><u>this</u></a> article.  In fact, this is a rather thin implementation, although it is completely within the framework of the C ++ 11 standard.  The result makes it possible to directly substitute the counter into the template without using additional macros, for example like this: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = next(), class Func&gt; Wrapping&lt;Func&gt;* Wrap( Func f ) {...}</code> </pre><br>  where <code>next()</code> is the implementation of the template counter. <br><br>  It is worth noting that you need to think three times and ask all the available employees before throwing such code into production, although the result is extremely interesting and useful.  A detailed description and implementation of this mechanism I will post the following addition or a separate article. </div><p>Source: <a href="https://habr.com/ru/post/310276/">https://habr.com/ru/post/310276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310262/index.html">15 most popular programming languages ‚Äã‚Äãaccording to GitHub</a></li>
<li><a href="../310264/index.html">How I started writing third-party projects to gain experience</a></li>
<li><a href="../310266/index.html">As the heroes of the game OverWatch once bald, and we returned them the hair</a></li>
<li><a href="../310268/index.html">REST server and thin client using vibe-d</a></li>
<li><a href="../310270/index.html">Naive implementation of std :: bind (boost :: bind)</a></li>
<li><a href="../310278/index.html">Gitlab-CI and Ansible-lint syntax checking</a></li>
<li><a href="../310282/index.html">The second wave of fateful changes GitHub</a></li>
<li><a href="../310284/index.html">React.js: build an isomorphic / universal application from scratch. Part 2: add bootstrap, pages and routing</a></li>
<li><a href="../310286/index.html">What links to use: absolute or relative?</a></li>
<li><a href="../310288/index.html">ClusterR clustering, part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>