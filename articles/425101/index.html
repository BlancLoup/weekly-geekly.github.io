<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker + Laravel = ‚ù§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I will talk about my experience in wrapping up a Laravel application in a Docker container, so that the frontend and backend develope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker + Laravel = ‚ù§</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/89c/b0e/91f/89cb0e91fd1efafb24b66b7ee44dc1b0.png" alt="laravel-in-docker"></p><br><p> In this article, I will talk about my experience in wrapping up a Laravel application in a Docker container, so that the frontend and backend developers could work with it locally, and launching it in production was as simple as possible.  Also, CI will automatically run static code analyzers, <code>phpunit</code> tests, and build images. </p><br><p>  "And what is the difficulty?"  - you can say, and you will be partly right.  The fact is that quite a lot of discussion has been devoted to this topic in the Russian-speaking and English-speaking communities, and I would conditionally divide almost all the studied threads into the following categories: </p><br><ul><li>  "I use docker for local development. I put <a href="https://laradock.io/">laradock</a> and I don‚Äôt know the troubles."  Cool, but what about the automation and production launch? </li><li>  "I collect one container <em>(monolith)</em> based on <code>fedora:latest</code> (~ 230 Mb), put all the services in it (nginx, bd, cache, etc), run everything inside the supervisor."  Too great, easy to run, but what about the ideology of "one container - one process"?  How are things going with balancing and process control?  What is the size of the image? </li><li>  "Here you have the pieces of configs, we season with extracts from sh-scripts, add magical env-values, use."  Thank you, but how about at least one living example, which I could fork and play fully? </li></ul><br><p>  Everything that you read below is a subjective experience that does not claim to be the ultimate truth.  If you have additions or indications of inaccuracy - welcome to comments. </p><br><blockquote>  For the impatient - a <a href="https://gitlab.com/tarampampam/laravel-in-docker">link to the repository</a> , which you can incline to run the Laravel application with one command.  It is also not difficult to run it on the same <a href="https://rancher.com/">rancher</a> , properly linking the containers, or using the <code>docker-compose.yml</code> product version as a starting point. </blockquote><a name="habracut"></a><br><h2 id="chast-teoreticheskaya">  Part theoretical </h2><br><p>  What tools will we use in our work, and what will we do with accents?  First of all, we will need the ones installed on the host: </p><br><ul><li>  <code>docker</code> - at the time of this writing, I used version <code>18.06.1-ce</code> </li><li>  <code>docker-compose</code> - it does an excellent job with linking containers and storing necessary environment values;  version <code>1.22.0</code> </li><li>  <code>make</code> - you might be surprised, but it fits perfectly into the context of working with the docker </li></ul><br><blockquote>  You can <code>curl -fsSL get.docker.com | sudo sh</code> <code>docker</code> on <code>debian</code> like systems with the command <code>curl -fsSL get.docker.com | sudo sh</code>  <code>curl -fsSL get.docker.com | sudo sh</code> , but <code>docker-compose</code> better put with the help of <code>pip</code> , since the most recent versions live in its repositories ( <code>apt</code> far behind, as a rule). </blockquote><p>  This list of dependencies can be completed.  What you will use to work with source codes - <code>phpstorm</code> , <code>netbeans</code> or <code>vim</code> vandal - only you decide. </p><br><p>  Next is an improvised QA in the context <em>(I‚Äôm not afraid of the word) of</em> designing images: </p><br><ul><li><p>  <strong>Q: Basic image - which one is better to choose?</strong> </p><br></li><li><p>  <strong>A:</strong> The one that is "thinner", without excesses.  On the basis of <a href="https://hub.docker.com/_/alpine/"><code>alpine</code></a> <em>(~ 5 Mb),</em> you can collect everything your heart desires, but most likely you will have to play around with assembling services from sources.  Alternatively, <a href="https://hub.docker.com/_/debian/"><code>jessie-slim</code></a> <em>(~ 30 Mb)</em> .  Or use the one that is most often used on your projects. </p><br></li><li><p>  <strong>Q: Why is image weight important?</strong> </p><br></li><li><p>  <strong>A:</strong> Decrease in traffic volume, decrease in the probability of an error when downloading (less data - less probability), decrease in the space consumed.  The rule "Reliability is Reliable" (¬© "Snatch") does not work here. </p><br></li><li><p>  <strong>Q: But my friend <code>%friend_name%</code> says that a "monolithic" image with all dependencies is the best way.</strong> </p><br></li><li><p>  <strong>A:</strong> Let's just count.  The application has 3 dependencies - PG, Redis, PHP.  And you wanted to test how it will behave in bundles of different versions of these dependencies.  PG - versions 9.6 and 10, Redis - 3.2 and 4.0, PHP - 7.0 and 7.2.  If each dependency is a separate image - you will need 6 of them, which you don‚Äôt even need to collect - everything is ready and lies on <code>hub.docker.com</code> .  If, for ideological reasons, all the dependencies are "packed" in one container, will you have to reassemble it with pens ... 8 times?  Now add a condition that you still want to play <code>opcache</code> with <code>opcache</code> .  In the case of decomposition, it is simply a change in the tags of the images used.  Monolith is easier to run and maintain, but this is a road to nowhere. </p><br></li><li><p>  <strong>Q: Why is a container supervisor evil?</strong> </p><br></li><li><p>  <strong>A:</strong> Because <code>PID 1</code> .  You do not want an abundance of problems with zombie processes and be able to flexibly "add capacity" where it is needed - try to run one process per container.  The peculiar exceptions are <code>nginx</code> with its workers and <code>php-fpm</code> , which tend to produce processes, but you have to put up with it (moreover, they are not bad at responding to <code>SIGTERM</code> , quite correctly ‚Äúkilling‚Äù their workers).  Having run all the demons by the supervisor - in fact, you probably doom yourself to problems.  Although, in some cases, it is difficult to manage without it, but these are exceptions. </p><br></li></ul><br><p>  Having decided on the main approaches let's move on to our application.  It should be able to: </p><br><ul><li>  <code>web|api</code> - give statics by <code>nginx</code> , and generate dynamic content by <code>fpm</code> </li><li>  <code>scheduler</code> - run native task scheduler </li><li>  <code>queue</code> - process jobs from queues </li></ul><br><p>  The basic set, which, if necessary, can be expanded.  Now let's move on to the images that we have to collect in order for our application to ‚Äútake off‚Äù (their code names are given in brackets): </p><br><ul><li>  <code>PHP + PHP-FPM</code> ( <strong>app</strong> ) - the environment in which our code will run.  Since the PHP and FPM versions will be the same for us, we collect them in one image.  So with configs it is easier to manage, and the composition of the packages will be identical.  Of course - FPM and application processes will run in different containers. </li><li>  <code>nginx</code> ( <strong>nginx</strong> ) - that would not bother with the delivery of configs and optional modules for <code>nginx</code> - we will assemble a separate image with it.  Since it is a separate service, it has its own docker-file and its context. </li><li>  Application <strong>sources</strong> ( <strong>sources</strong> ) - the source will be delivered using a separate image, mounting the <code>volume</code> with them to the container with the app.  Base image - <code>alpine</code> , inside - only source codes with installed dependencies and assets collected using webpacks (build artifacts) </li></ul><br><p>  The rest of the development services are launched in containers, pulling them from <code>hub.docker.com</code> ;  in production, they are running on separate servers, clustered together.  All that remains for us is to tell the application <em>(via the environment)</em> at which addresses / ports and with what details it is necessary to knock them.  Even cooler is to use service-discovery for these purposes, but this is not about this time. </p><br><p>  Having defined the part of the theoretical part, I suggest moving on to the next part. </p><br><h2 id="chast-prakticheskaya">  Part practical </h2><br><p>  I propose to organize the files in the repository as follows: </p><br><pre> <code class="hljs css">. ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> #    <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>   ‚îÇ  ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> ‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ ... ‚îÇ  ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> ‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ ... ‚îÇ  ‚îî‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">sources</span></span> ‚îÇ    ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> ‚îÇ    ‚îî‚îÄ‚îÄ ... ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">src</span></span> #   ‚îÇ ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> ‚îÇ ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">bootstrap</span></span> ‚îÇ ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span> ‚îÇ ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">artisan</span></span> ‚îÇ ‚îî‚îÄ‚îÄ ... ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose-</span></span>    ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Makefile</span></span> ‚îú‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHANGELOG</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span> ‚îî‚îÄ‚îÄ <span class="hljs-selector-tag"><span class="hljs-selector-tag">README</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span></code> </pre> <br><blockquote>  You can view the structure and files by clicking on <a href="https://gitlab.com/tarampampam/laravel-in-docker">this link</a> . </blockquote><p>  To build a service, you can use the command: </p><br><pre> <code class="bash hljs">$ docker build \ --tag %local_image_name% \ -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%</code> </pre> <br><p>  The only difference is the build of the image with the source code - it needs the build context (the last argument) to be equal to <code>./src</code> . </p><br><p>  I recommend using the rules for naming images in the local registry that use <code>docker-compose</code> by default, namely: <code>%root_directory_name%_%service_name%</code> .  If the project directory is called <code>my-awesome-project</code> , and the service is called <code>redis</code> , then the name of the image (local) is better to choose <code>my-awesome-project_redis</code> respectively. </p><br><blockquote>  To speed up the build process, you can tell the docker to use the cache of the previously compiled image, and the launch <code>--cache-from %full_registry_name%</code> used for this.  Thus, the docker daemon will look at the start of a particular instruction in the Dockerfile - has it changed?  And if not (the hash will converge) - he will skip the instruction, using the already prepared layer from the image, which you tell it to use as a cache.  This thing is not so bad that it will rebuild the process, especially if nothing has changed :) <br><br>  Pay attention to <code>ENTRYPOINT</code> application container launch scripts. </blockquote><p>  The image of the environment for launching an application (app) was collected taking into account the fact that it will work not only in production, but also locally, developers need to interact with it effectively.  Installing and removing <code>composer</code> dependencies, running <code>unit</code> tests, <code>tail</code> logs and using familiar aliases ( <code>php /app/artisan</code> ‚Üí <code>art</code> , <code>composer</code> ‚Üí <code>c</code> ) should be without any discomfort.  Moreover, it will also be used to run <code>unit</code> tests and static code analyzers ( <code>phpstan</code> in our case) on CI.  That is why its Dockerfile, for example, contains the line for installing <code>xdebug</code> , but the module itself is not included (it is enabled only using CI). </p><br><blockquote>  Also for the <code>composer</code> globally put the package <code>hirak/prestissimo</code> , which greatly boosts the installation process of all dependencies. </blockquote><p>  In production, we mount inside it into the <code>/app</code> directory the contents of the <code>/src</code> directory from the source image.  For development - we "prokidyvat" a local directory with source codes of the application ( <code>-v "$(pwd)/src:/app:rw"</code> ). </p><br><p>  And here lies one difficulty - it is the <strong>access rights to files</strong> that are created from the container.  The fact is that by default, the processes running inside the container are started from root ( <code>root:root</code> ), the files created by these processes (cache, logs, sessions, etc) are also, and as a result, you don‚Äôt have anything with them You can do this by not running <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code> . </p><br><p>  As one of the solutions is to use <a href="https://boxboat.com/2017/07/25/fixuid-change-docker-container-uid-gid/">fixuid</a> , but this solution is straightforward "so-so."  The best way I <code>USER_ID</code> local <code>USER_ID</code> and its <code>GROUP_ID</code> inside the container, and <a href="">start processes with these values</a> .  By default, substituting <code>1000:1000</code> values ‚Äã‚Äã(default values ‚Äã‚Äãfor the first local user) got rid of the <code>$(id -u):$(id -g)</code> call <code>$(id -u):$(id -g)</code> , and if necessary, you can always override them ( <code>$ USER_ID=666 docker-compose up -d</code> ) or put docker-compose in the <code>.env</code> file. </p><br><p>  Also, when running <code>php-fpm</code> do not forget to disable <code>opcache</code> in it - otherwise the <code>opcache</code> is "what the hell is this!"  you will be provided. </p><br><p>  For the "direct" connection to redis and postgres, I‚Äôve thrown additional ports "outward" ( <code>15432</code> and <code>15432</code> respectively), so there is no problem in principle to "connect and see what and how it really is". </p><br><p>  I keep the container with the code name <code>app</code> running ( <code>--command keep-alive.sh</code> ) for convenient access to the application. </p><br><p>  Here are some examples of solving "everyday" tasks with <code>docker-compose</code> : </p><br><table><thead><tr><th>  Operation </th><th>  Executable command </th></tr></thead><tbody><tr><td>  Installing the <code>composer</code> package </td><td> <code>$ docker-compose exec app composer require package/name</code> </td> </tr><tr><td>  Running phpunit </td><td> <code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code> </td> </tr><tr><td>  Installing all node dependencies </td><td> <code>$ docker-compose run --rm node npm install</code> </td> </tr><tr><td>  Install node-package </td><td> <code>$ docker-compose run --rm node npm i package_name</code> </td> </tr><tr><td>  Launch of live asset reassembly </td><td> <code>$ docker-compose run --rm node npm run watch</code> </td> </tr></tbody></table><br><p>  All startup details can be found in the <strong><a href="">docker-compose.yml file</a></strong> . </p><br><h4 id="coy-make-zhiv"><del>  Choi </del>  <code>make</code> alive! </h4><br><p>  Packing the same commands every time becomes boring after the second time, and since programmers are by their nature lazy creatures, let's take care of their ‚Äúautomation‚Äù.  To keep a set of <code>sh</code> scripts is an option, but not as attractive as a <code>Makefile</code> , especially since its applicability in modern development is greatly underestimated. </p><br><blockquote>  You can find the complete Russian-language manual on it at <a href="https://blog.hook.sh/nix/makefile-full-doc/">this link</a> . </blockquote><p>  Let's see how running <code>make</code> in the root of the repository looks like: </p><br><pre> <code class="bash hljs">[user@host ~/projects/app] $ make <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> app-pull Application - pull latest Docker image (from remote registry) app Application - build Docker image locally app-push Application - tag and push Docker image into remote registry sources-pull Sources - pull latest Docker image (from remote registry) sources Sources - build Docker image locally sources-push Sources - tag and push Docker image into remote registry nginx-pull Nginx - pull latest Docker image (from remote registry) nginx Nginx - build Docker image locally nginx-push Nginx - tag and push Docker image into remote registry pull Pull all Docker images (from remote registry) build Build all Docker images push Tag and push all Docker images into remote registry login Log <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> to a remote Docker registry clean Remove images from <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> registry --------------- --------------- up Start all containers (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> background) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development down Stop all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers restart Restart all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers shell Start shell into application container install Install application dependencies into application container watch Start watching assets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> changes (node) init Make full application initialization (install, seed, build assets) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Execute application tests Allowed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> overriding next properties: PULL_TAG - Tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pulling images before building own (<span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) PUBLISH_TAGS - Tags list <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building and pushing into remote registry (delimiter - single space, <span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) Usage example: make PULL_TAG=<span class="hljs-string"><span class="hljs-string">'v1.2.3'</span></span> PUBLISH_TAGS=<span class="hljs-string"><span class="hljs-string">'latest v1.2.3 test-tag'</span></span> app-push</code> </pre> <br><p>  He is very good at goal dependency.  For example, to start <code>watch</code> ( <code>docker-compose run --rm node npm run watch</code> ) it is necessary for the application to be "raised" - all you have to do is set the target <code>up</code> as dependent - and you need not worry about what you will forget to do before calling <code>watch</code> - <code>make</code> will do everything for you.  The same applies to running tests and static analyzers, for example, before committing changes - run <code>make test</code> and all the magic will happen for you! </p><br><p>  Needless to say that for assembling images, downloading them, specifying <code>--cache-from</code> and everything else - no longer worry? </p><br><p>  You can view the contents of the <code>Makefile</code> <strong><a href="https://gitlab.com/tarampampam/laravel-in-docker/blob/master/Makefile">here</a></strong> . </p><br><h2 id="chast-avtomaticheskaya">  Part automatic </h2><br><p>  Let's get to the final part of this article - this is an automation of the process of updating images in the Docker Registry.  Although in my example GitLab CI is used - to transfer the idea to another integration service, I think it will be quite possible. </p><br><p>  First of all, we define and name the image tags used: </p><br><table><thead><tr><th>  Tag name </th><th>  Purpose </th></tr></thead><tbody><tr><td> <code>latest</code> </td> <td>  Images collected from the <code>master</code> branch. <br>  The state of the code is the most "fresh", but not yet ready to be released. </td></tr><tr><td> <code>some-branch-name</code> </td> <td>  Images compiled in brunch <code>some-branch-name</code> . <br>  Thus, we can ‚Äúroll out‚Äù changes on any environment that were implemented only within a specific brunch before they were merged with the <code>master</code> branch ‚Äî it‚Äôs enough to ‚Äúpull out‚Äù images with this tag. <br>  And - yes, the changes can affect both the code and the images of all services in general! </td></tr><tr><td> <code>vX.XX</code> </td> <td>  Actually, the release of the application (use to deploy a specific version) </td></tr><tr><td> <code>stable</code> </td> <td>  Alias, for the tag with the most recent release (use to deploy the most recent stable version) </td></tr></tbody></table><br><p>  The release is done by posting a tag in the <code>vX.XX</code> format. </p><br><p>  To speed up the build, the caching of the <code>./src/vendor</code> and <code>./src/node_modules</code> + <code>--cache-from</code> directories is used for the <code>docker build</code> , and consists of the following stages: </p><br><table><thead><tr><th>  Stage name </th><th>  Purpose </th></tr></thead><tbody><tr><td> <code>prepare</code> </td> <td>  Preparatory stage - assembling images of all services <strong>except the</strong> source image </td></tr><tr><td> <code>test</code> </td> <td>  Testing the application (running <code>phpunit</code> , static code analyzers) using images <strong>collected at the prepare stage</strong> </td></tr><tr><td> <code>build</code> </td> <td>  Installing all <code>composer</code> dependencies ( <code>--no-dev</code> ), <code>webpack</code> <code>assets</code> with <code>webpack</code> , and <code>webpack</code> image with source code <strong>including artifacts obtained</strong> ( <code>vendor/*</code> , <code>app.js</code> , <code>app.css</code> ) </td></tr></tbody></table><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c2/873/625/8c2873625893ec1a0605e24bf85ef541.png" alt="pipelines screenshot"></p><br><blockquote>  Build on the <code>master</code> branch, producing <code>push</code> with the <code>latest</code> and <code>master</code> tags </blockquote><p>  On average, all the assembly steps take <strong>4 minutes</strong> , which is a pretty good result (parallel execution of tasks is our everything). </p><br><p>  You can familiarize yourself with the contents of the configuration ( <strong><code>.gitlab-ci.yml</code></strong> ) of the collector at <strong><a href="">this link</a></strong> . </p><br><h2 id="vmesto-zaklyucheniya">  Instead of conclusion </h2><br><p>  As you can see, organizing work with a php application (using the example of <code>Laravel</code> ) using Docker is not so difficult.  As a test, you can fork the <a href="https://gitlab.com/tarampampam/laravel-in-docker">repository</a> , and replacing all occurrences of <code>tarampampam/laravel-in-docker</code> with your own - try everything "live" on your own. </p><br><p>  To start locally - execute only 2 commands: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$_</span></span> $ make init</code> </pre> <br><p>  Then open <code>http://127.0.0.1:9999</code> in your favorite browser. </p><br><p>  <strong><em>‚Ä¶ Take this opportunity to</em></strong> </p><br><p>  <em>At the moment I am working on a TL autocode project, and we are looking for talented php developers and system administrators (the development office is located in Yekaterinburg).</em>  <em>If you consider yourself to be the first or the second - write our HR letter with the text "I want to develop a team, resume:% link_on_resume%" on email <code>hr@avtocod.ru</code> , we help with relocation.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425101/">https://habr.com/ru/post/425101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425091/index.html">What kind of nonsense is happening with the popularity ratings of programming languages?</a></li>
<li><a href="../425093/index.html">IoT solutions for housing and communal services: what will be the smart meters and who should serve them?</a></li>
<li><a href="../425095/index.html">Open webinar "Game" 2048 "</a></li>
<li><a href="../425097/index.html">"The law of Spring" was supposed to earn from October 1, but the operators do not have enough documentation</a></li>
<li><a href="../425099/index.html">What I understood and what problems I encountered creating the Hacker News clone</a></li>
<li><a href="../425103/index.html">Stop Google predators chasing your kids</a></li>
<li><a href="../425105/index.html">Intel ME Manufacturing Mode - hidden threat or what is behind CVE-2018-4251 vulnerability in MacBook</a></li>
<li><a href="../425107/index.html">Fintech Digest: problems of biometrics on mobiles, leasing phones from Samsung, securities on the blockchain</a></li>
<li><a href="../425109/index.html">The book "Java in the cloud. Spring Boot, Spring Cloud, Cloud Foundry ¬ª</a></li>
<li><a href="../425111/index.html">Promotional tricks that can cost you money and reputation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>