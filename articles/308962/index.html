<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using TCL in FPGA Development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I have not written an article on my favorite topic for a long time and finally matured for something more or less decent and worthwhile. In thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using TCL in FPGA Development</h1><div class="post__text post__text-html js-mediator-article">  Hello!  I have not written an article on my favorite topic for a long time and finally matured for something more or less decent and worthwhile.  In this article we will discuss a very interesting task that the development engineer faces almost every day.  I suggest you look at how you can use all the power and simplicity of <b>TCL scripts</b> for designing on <b>FPGA</b> .  In this article, the description is based on <i>Xilinx</i> FPGA, but this does not negate the capabilities of TCL scripts for FPGA crystals from other manufacturers. <br><br><img src="https://habrastorage.org/files/9a9/d58/766/9a9d58766db04ddc993a2301d50f40c1.jpg"><br>  Interesting?  <i>Go‚Ä¶</i> <br><a name="habracut"></a><br><h3>  What is TCL? </h3><br>  <b>TCL (Tool Command Language)</b> is a high-level scripting language for performing various tasks.  Often, TCL is used in conjunction with the <i>Tk</i> graphical shell <i>(Tool Kit)</i> , but this aspect will not be considered in this article.  The language is widely used in various tasks of process automation: <br><br><ul><li>  Testing of complex modules, nodes, parts of the code; </li><li>  Speed ‚Äã‚Äãprototyping; </li><li>  Creating graphical interfaces for console applications; </li><li>  The introduction of applications and tasks. </li></ul><br>  Anyway, the main function of the TCL language is the <b>automation of routine tasks</b> , and a significant <u>reduction in the time</u> spent on development.  TCL programs do not require <u>build and compilation</u> , which makes the task of debugging scripts simple and straightforward.  The TCL interpreter is distributed under a <u>free license</u> and is available for almost all platforms (it is available by default in many Linux distributions).  This means that you can use it without any restrictions in the development of private programs and proprietary applications.  As of this writing, the current version of TCL is 8.6.  There are many distributions available for working with TCL scripts, their debugging and visualization - <i>MyTcl, TclKit, ActiveTcl</i> , etc.  The price for 1 ActiveTcl license is about ~ $ 1500, which is unjustified for developing commercial applications.  From personal practice, most developers use the familiar command line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All TCL programs consist of <b>commands</b> , which are separated by the symbol <b>";"</b>  or the start of a new line.  As in many other programming languages, the first word is a command, the other words are command arguments. <br><br>  <i>command arg1 argt2 ... argN</i> <br><br>  For example: <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> NewValue ‚ÄúHello World!‚Äù puts <span class="hljs-variable"><span class="hljs-variable">$NewValue</span></span></code> </pre> <br>  The first command creates the variable <i>NewValue</i> , and the second command prints the value of the variable to the console.  To use variables <u>with spaces</u> , quotes are used.  In other cases, they are not required.  The result of the execution of commands is shown in the figure below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5a0/89e/e84/5a089ee841134927bebf05f71a2ff9a7.png"></div><br>  In my opinion, the main convenience of the TCL language is that any argument of a command <u>can be replaced by another command</u> .  To do this, it must be placed in square brackets.  In the example below, I will show this opportunity.  In addition, TCL is able to <u>control program behavior</u> based on various events.  This means that the command handler can perform certain actions not only on the condition recorded in the script, but also on various external events (changing the value of a variable in an external file, capturing data in the channel, ending the execution of the application, reaching the timer counter of a certain value and etc.).  The TCL language is rich in a set of commands and contains quite convenient means of working with data arrays and regular expressions.  On TCL, the ability to write functions and procedures is implemented, a description of cycles and expressions by condition is available, which makes writing code much easier. <br><br><h4>  Why do you need TCL? </h4><br>  Almost all developers on FPGA / ASIC sooner or later encounter the TCL language in their projects.  In modern development of FPGA TCL scripts are actively used for automation and process integration tasks.  TCL is included in all leading CAD FPGAs - <i>Quartus</i> for <i>Altera</i> , <i>ISE Design Suite</i> and <i>Vivado</i> for <i>Xilinx</i> .  What can TCL do? <br><br><ul><li>  creating a project (adding source files, setting options, design hierarchies, assigning a top-level file, etc.), </li><li>  synthesis and tracing (up to the creation of independent stages with different settings), </li><li>  testing complete nodes, individual modules and the entire project, </li><li>  automatic generation of restriction files (UCF / XCI) based on templates, </li><li>  checking the time constraints for the synthesized and traced project. </li><li>  setting the parameters of the FPGA circuits, components and primitives, setting options for IP cores, </li></ul><br>  etc. <br><br>  All these stages, one way or another, are the <b>basic operations</b> in the development process on the FPGA: from creating models of node behavior in VHDL / Verilog languages ‚Äã‚Äãto debugging a finished project in CAD at the stage of synthesis and tracing.  As a rule, complex projects contain a large number of modules written by different developers, several IP cores, restriction files, libraries, and function packages.  As a result, the finished project has a certain hierarchical structure and a set of rules for connecting certain modules to the required project nodes.  It is difficult for a developer to keep in mind the knowledge of where and how the debugged modules should be located and what functions they perform, if they use their work, but knowledge of their work is not required at the design stage (the so-called ‚Äú <i>black-box</i> ‚Äù modules).  TCL script comes to the rescue, which manages the structure of the project and connects the required nodes according to pre-prepared templates.  This provides flexibility in development and gives the possibility of repeatability of finished nodes during migration from one project to another. <br><br>  As a rule, simultaneously with the stage of creating new nodes for the FPGA, the stage of debugging of these nodes proceeds separately from the project and together with the complete system.  Primary modeling is carried out abstracted from FPGA on a computer in specialized CAD and modeling environments: these are Modelsim, ISim, Aldec Active-HDL and others.  To accomplish the task of debugging projects, TCL scripts also come to the rescue, allowing you to handle events that occur during the simulation, and make decisions on the results of the model.  When debugging an RTL node purely in HDL languages, it can be difficult to write a model, since any change in the behavior of the circuit will result in the need to change the model and testing sets.  Using a bunch of models in HDL language and TCL scripts is quite convenient and allows you to speed up the debugging process as well as unify complex tests for many solutions. <br><br>  The stages of writing code and debugging are followed by the usual steps of synthesis, placement and tracing of the project in the FPGA chip.  Perhaps this is one of the most difficult steps, which requires large computing resources of the workstation and a long execution time to complete.  TCL scripts allow you to manage execution events at each stage, analyze the results of various calculations to achieve the best characteristics of the layout and tracing of the project (the amount of resources occupied, the maximum clock frequencies, acceptable values ‚Äã‚Äãof timing delays, etc.).  In addition, TCL makes it possible to eliminate routine actions for selecting and changing settings, restarting the verification stages, and restarting a specific stage when creating the FPGA firmware file.  Such design automation almost completely eliminates the constant presence of a person at these stages. <br><br>  I hope that, having finished reading these lines, you are already convinced that TCL is a convenient and powerful thing that is extremely necessary to use in your projects.  Below I will analyze one of the useful scripts that is used by our team to create a project in the Vivado environment, to add already written source files, various IP cores, XCI restriction files, and much more. <br><br><h4>  TCL your FPGA! </h4><br>  Consider one of the simplest TCL scripts to automatically create a project on a FPGA.  The preliminary steps are quite minimal: the local machine requires a directory with the <i>source code of the project</i> , as shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/666/08e/79a/66608e79abfd46b48aeb2b4fee53f67f.png"></div><br>  For convenience, I use independent directories for projects created in the <i>Xilinx ISE Design Suite</i> environment and in <i>Vivado</i> , if the FPGA family allows it ( <i>7 series: Artix, Kintex, Virtex</i> ).  The source files are in the <b>/ src</b> directory, the <b>vivado</b> project <b>is</b> in the same directory, and the project for the ISE environment is created in the <b>/ ise</b> directory, but the synthesis and layout results are stored in the <b>/ implement</b> directory.  All this is done for the convenience of project management in general and independent management in different environments.  It also makes the hierarchy more visual and saves you from a heap of junk files in the source code.  Separately, you should note the <b>/ top</b> directory in the source directory, where the top-level file and the necessary restriction files lie (for ISE this is <b>* .ucf</b> file, for Vivado this is <b>* .xdc</b> file). <br><br>  The project contains mixed <i>IP cores</i> - old ones created in ISE and new ones created in Vivado.  The core_k7 directory contains all the cores created in CoreGenerator for ISE.  They are not regenerated or updated when used in a Vivado project (the * .vhd file is used for modeling, the * .ngc file is used for synthesis, and the * .xco file is not added to the Vivado project).  The / ipcores directory contains new kernels in the * .xci format, created directly in the Vivado environment.  It should be noted that a separate subdirectory is required for each core; otherwise, the ‚Äú <b>LOCKED</b> ‚Äù attribute is set for the IP cores in the project, which makes it impossible to update the cores and regenerate them for synthesis. <br><br>  Let us proceed to the description of the TCL script: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 1: Specify project settings set TclPath [file dirname [file normalize [info script]]] set NewLoc [string range $TclPath 0 [string last / $TclPath]-5] set PartDev "xc7k325tffg900-2" set PrjDir [string range $TclPath 0 [string last / $NewLoc]] set TopName [string range $NewLoc [string last / $NewLoc]+1 end]</span></span></code> </pre> <br>  The first line looks for the location of the TCL script on the local machine (located in the <b>src / tcl</b> directory) and creates a string variable with the full path to the file. <br><br>  In the second line, an additional variable is created, from which part of the path is cut.  Both variables are necessary in order to manually not specify the path to the project and the name of the top-level file in the following variables. <br><br>  The variable <b>PartDev</b> contains the name of the FPGA crystal.  And this is the only variable that changes in the project!  All other lines of the script remain <b>UNCHANGABLE</b> in any project. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 2: Auto-complete part for path set PrjName $TopName.xpr set SrcDir $PrjDir/$TopName/src set VivNm "vivado" set VivDir $PrjDir/$TopName/$VivNm cd $PrjDir/$TopName pwd if {[file exists $VivNm] == 1} { file delete -force $VivNm } file mkdir $VivNm cd $VivDir</span></span></code> </pre> <br>  At the next stage, additional variables are created that determine the location of the source files, create a vivado directory if it is not there, etc.  I want to note that I check the presence of the vivado directory on the local machine.  If the directory exists, it is deleted and re-created so that there are no conflicts in the new project. <br><br>  The cd command changes the working directory, and the pwd command shows the location of the working directory. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 3: Find sources: *.vhd, *.ngc *.xci *.xco *.xdc etc. # This stage used instead of: add_files -scan_for_includes $SrcDir set SrcVHD [findFiles $SrcDir "*.vhd"] set SrcVer [findFiles $SrcDir "*.v"] set SrcNGC [findFiles $SrcDir "*.ngc"] set SrcXCI [findFiles $SrcDir "*.xci"] set SrcXDC [findFiles $SrcDir "*.xdc"] set SrcPCI [findFiles $SrcDir "cl_pcie*"] set NewLoc [string range $SrcPCI 0 [string last / $SrcPCI]-6]</span></span></code> </pre><br>  Everything is primitive and understandable here - variables are created that define the names of all source files in the / src directory.  To find files, use the findFiles procedure, which we will return to. <br><br>  A separate search is made for the component component of the PCI-E node, which is a basic and integral part for all our projects. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 4: Find all subdirs for IP cores (VHD, XCO, NGC, EDN) set PrjAll {} lappend PrjAll $DirIps $DirAdm $SrcDir/core_v2_ise $SrcDir/core_v4_ise $SrcDir/core_v5_ise $SrcDir/core_v6_ise $SrcDir/core_k7 $SrcDir/TestBench set SrcSim {} for {set i 0} {$i &lt; [llength $PrjAll]} {incr i} { set SrcXXX [findFiles [lindex $PrjAll $i] "*.vhd"] put $SrcXXX foreach SrcAdd $SrcXXX { lappend SrcSim $SrcAdd } }</span></span></code> </pre> <br>  At the next stage, all IP cores are searched in the project.  And the variable SrcSim recorded the names of the files that are used for modeling.  The lappend command in the loop adds other values ‚Äã‚Äãto the variable, forming an array, which in TCL is called a sheet.  At this preparatory part of the script ends and the creation of the project begins. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 5: Create project and add source files create_project -force $TopName $VivDir -part $PartDev set_property target_language VHDL [current_project] add_files -norecurse $SrcNGC add_files -norecurse $SrcXCI export_ip_user_files -of_objects [get_files $SrcXCI] -force -quiet add_files $SrcVHD add_files -fileset constrs_1 -norecurse $SrcXDC</span></span></code> </pre> <br>  We create a project, define the top-level file, set the FPGA chip type (in this example, it is Kintex-7 K325T), add the found source files. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 6: Set properties and update compile order set_property top $TopName [current_fileset] for {set i 0} {$i &lt; [llength $SrcSim]} {incr i} { set_property used_in_synthesis false [get_files [lindex $SrcSim $i]] } set NgcGlb [findFiles $DirIps "*.ngc"] for {set i 0} {$i &lt; [llength $NgcGlb]} {incr i} { set_property IS_GLOBAL_INCLUDE 1 [get_files [lindex $NgcGlb $i]] } set_property IS_GLOBAL_INCLUDE 1 [get_files $SrcPCI]</span></span></code> </pre><br>  Set options for simulation files (exclude from synthesis), set the <b>GLOBAL_INCLUDE</b> parameter for cores used in the PCI-E node (this is a specific feature required for our projects). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 7: Upgrade IP Cores (if needed) report_ip_status -name ip_status set IpCores [get_ips] for {set i 0} {$i &lt; [llength $IpCores]} {incr i} { set IpSingle [lindex $IpCores $i] set locked [get_property IS_LOCKED $IpSingle] set upgrade [get_property UPGRADE_VERSIONS $IpSingle] if {$upgrade != "" &amp;&amp; $locked} { upgrade_ip $IpSingle } } report_ip_status -name ip_status</span></span></code> </pre> <br>  At this stage, the search for IP-cores of the project in the XCI format is performed, the need to update the kernel version and the locked parameter, which is affected by the FPGA chip change, are checked.  After analyzing the kernels, an update is performed and a report on the successful operation is issued. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Stage 8: Set properties for Synthesis and Implementation (Custom field) set_property strategy Flow_PerfOptimized_high [get_runs synth_1] set_property strategy Performance_ExtraTimingOpt [get_runs impl_1] launch_runs synth_1 wait_on_run synth_1 open_run synth_1 -name synth_1 launch_runs impl_1 -to_step write_bitstream wait_on_run impl_1</span></span></code> </pre><br>  The final stage, at which the setup of the synthesis and trace settings is made, is selected from the list of available strategies.  Then, the synthesis, placement and tracing are run in turn until the FPGA firmware is fully wired. <br><br>  As you can see, using the script allows you to save the user from the routine work of creating a project, adding new files, updating IP cores and many other things of the same type.  The script is fully automated and requires the installation of a single argument - the type of FPGA crystal.  It can be set as a variable in the file, or as an argument that is executed simultaneously with the launch of the TCL script.  The figure below shows a screenshot of the project workspace in the Vivado environment, which was launched using a script: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/933/cc6/d4d/933cc6d4d9b24074a8157555f643ed40.png"></div><br>  Separately, you should pay attention to the <b>findFiles</b> procedure, with which you can search for all files in a directory.  Function arguments: <b>basedir</b> - search directory, <b>pattern</b> - search mask. <br><br><pre> <code class="bash hljs">proc findFiles { basedir pattern } { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> basedir [string trimright [file join [file normalize <span class="hljs-variable"><span class="hljs-variable">$basedir</span></span>] { }]] <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> fileList {} foreach fileName [glob -nocomplain -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {fr} -path <span class="hljs-variable"><span class="hljs-variable">$basedir</span></span> <span class="hljs-variable"><span class="hljs-variable">$pattern</span></span>] { lappend fileList <span class="hljs-variable"><span class="hljs-variable">$fileName</span></span> } foreach dirName [glob -nocomplain -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {dr} -path <span class="hljs-variable"><span class="hljs-variable">$basedir</span></span> *] { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> subDirList [findFiles <span class="hljs-variable"><span class="hljs-variable">$dirName</span></span> <span class="hljs-variable"><span class="hljs-variable">$pattern</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> { [llength <span class="hljs-variable"><span class="hljs-variable">$subDirList</span></span>] &gt; 0 } { foreach subDirFile <span class="hljs-variable"><span class="hljs-variable">$subDirList</span></span> { lappend fileList <span class="hljs-variable"><span class="hljs-variable">$subDirFile</span></span> } } } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$fileList</span></span> }</code> </pre> <br>  The search is performed in several steps: defining the working directory as a file template, creating a list by file name indicating the full path and creating a list-type list array if there are more than one files found.  An example of the function findFiles is shown in the figure below.  For clarification, written a cycle that displays all the files found.  As you can see, the full path to each file is indicated. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0d8/9c7/493/0d89c74939254453a9bf0d3a16b6d738.png"></div><br>  The script is run from the command line, or using the Vivado GUI application.  In the first case, you need to run Vivado TCL Shell and write a simple command <br><br><pre> <code class="hljs mel">vivado ‚Äìmode tcl ‚Äì<span class="hljs-keyword"><span class="hljs-keyword">source</span></span> %full_path/example.tcl</code> </pre> <br>  <strong>Note:</strong> from the command line, you can start the graphical environment by changing the mode to <b>gui by</b> starting the mode. <br><br>  In the Vivado environment, the scripts run uncomplicated and simple: <b>Menu -&gt; Tools -&gt; Run TCL Script ...</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ae0/f8c/d42/ae0f8cd4284c40e3b3693c436467707e.png"></div><br>  This completes the familiarity with the TCL language.  This is not the end of project automation.  In this simple example, I wanted to show how using TCL scripts you can automate FPGA design.  TCL is very convenient, easy to understand, and most importantly, open to use.  According to personal estimates, the introduction of scripts into the life of developers allows us to reduce the time for the complete creation of a project from the initial to the final stage, and to leave more time for "clean" development (writing code).  Below are useful links to get familiar with TCL scripts on FPGA. <br><br><h4>  Literature: </h4><br><ul><li>  <a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx2012_3/ug894-vivado-tcl-scripting.pdf">Vivado Design Suite User Guide - Using Tcl Scripting</a> </li><li>  <a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug835-vivado-tcl-commands.pdf">Vivado Design Suite Tcl Command Reference Guide</a> </li><li>  <a href="https://www.tcl.tk/man/tcl8.5/tutorial/tcltutorial.html">TCL Tutorial</a> </li><li>  <a href="https://marsohod.org/projects/plata1/302-tcl-script">Using TCL in the Mars Rover Project</a> </li><li>  <a href="https://habrahabr.ru/post/252247/">Static Time Analysis FPGA</a> </li><li>  <a href="https://habrahabr.ru/company/metrotek/blog/235707/">Raise SOC: ARM + FPGA</a> </li></ul><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/308962/">https://habr.com/ru/post/308962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308952/index.html">Porting a portfolio from Brainstorage to Freelansim</a></li>
<li><a href="../308954/index.html">How-to: interactive writing guide</a></li>
<li><a href="../308956/index.html">Microsoft Azure StorSimple: easy access to hybrid cloud. Part 1</a></li>
<li><a href="../308958/index.html">In the new list of the most profitable IT companies in Russia, 50% of the seats are occupied by foreign firms.</a></li>
<li><a href="../308960/index.html">Optimization by example. Imitation annealing against the ant algorithm. Part 1</a></li>
<li><a href="../308966/index.html">New release of Kali Linux 2016.2</a></li>
<li><a href="../308968/index.html">AMD introduces new security mechanisms for its AMD-V hypervisor</a></li>
<li><a href="../308972/index.html">The logic of consciousness. Part 3. Holographic memory in a cellular automaton</a></li>
<li><a href="../308974/index.html">Tabs or spaces? Analysis of 400 thousand GitHub repositories, billion files, 14 TB code</a></li>
<li><a href="../308976/index.html">A gift for September 1 to all fans of digital circuitry and computer architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>