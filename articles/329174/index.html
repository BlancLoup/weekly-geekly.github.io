<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Load testing: where to start and where to look</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You probably know that there is a big difference between how your application / service will work depending on how many users use it. What worked duri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Load testing: where to start and where to look</h1><div class="post__text post__text-html js-mediator-article"> You probably know that there is a big difference between how your application / service will work depending on how many users use it.  What worked during development could fall apart when the first real users arrived with their surroundings, and what worked with a hundred users could die when there were 10 thousand of them.  Or it happens that you all tested on artificial data, and then your base starts to slow down because of a user named ƒ∞nari. <br><br>  How bugs survive, when load tests are included in a project, where to get data for them and whether it is possible not to test at all by dumping the results into production immediately, we talked with Alexey Lavrenyuk (Yandex) and Vladimir Sitnikov (Netcracker) . <br><br><img src="https://habrastorage.org/web/9c5/0cc/a3a/9c50cca3a8c64d1597684f4733922e20.jpg"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/b4d/1a3/e43/b4d1a3e439004a799e513620370d17cf.jpg" align="left">  <b>A few words about yourself and your work.</b>  <b>How is your job related to testing?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> I am a developer at Yandex, in the load testing service.  I do tools and services for performance testing.  You can look at our open-source tools for load testing - <a href="https://github.com/yandex/yandex-tank">Yandex.Tank</a> and <a href="https://github.com/yandex/pandora">Pandora</a> , and on our service for load testing - Overload.  Now open access to its <a href="https://overload.yandex.net/">beta version</a> . <br><br>  Previously, we were able to test only the performance of server applications, now we are mastering mobile applications - this is a new trend.  For example, we test the power consumption of phones.  Read about it <a href="https://habrahabr.ru/company/yandex/blog/311046/">here</a> . <br><br><img src="https://habrastorage.org/web/248/251/e0f/248251e0fed74da8a71a0b5eb75f60a0.jpg" align="left">  <b>Vladimir Sitnikov:</b> I have been working for Netcracker for 12 years.  Now I take the position of a performance engineer, i.e.  I do not test products, but I observe how the system behaves in actual operation and in tests.  My responsibility is to analyze how certain solutions in the field of development and design affect the final result.  Therefore, I often do not just look at the test results, but also plan it.  This mainly refers to load testing. <br><br>  Once I myself was engaged in testing, but now it is in the past. <br><br>  <b>- Let's talk a little about theory.</b>  <b>Is it correct to say that problems at the testing stage appear because of developers who do not take into account any parameters of the problem or use an inappropriate solution?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> It is impossible to foresee everything in advance.  In a typical service, there are a lot of spins: to solve product problems, you can choose different algorithms, select the parameters of these algorithms, use libraries, frameworks, production settings in production, and hardware parameters.  In combination, these twisters give billions of combinations, and without a deep understanding of how the service works, you can sort them out for a very long time.  And this understanding cannot be obtained if you do not have a tool for conducting experiments and analyzing their results. <br><br>  Load testing is not a club that hits developers on the head when they write non-productive code.  This is a very powerful measuring device, in fact, an oscilloscope for an electronics engineer, allowing you to probe the code and find bottlenecks in it.  And then, after optimization, see (and demonstrate) the result in numbers and graphs. <br><br>  <b>Vladimir Sitnikov:</b> I would like to add.  ‚ÄúWhere do bugs come from at all‚Äù is a millennium issue.  And it is closely related to another interesting question - why, despite all the testing, bugs live to real systems and only appear there.  Why during testing we do not find them?  Do we incorrectly set the task? <br><br>  In my opinion, this is due to the fact that the development and support teams are different.  Some people make a decision and completely different - they are engaged in its support during the operation. <br><br>  Half of all problems in production is a combination of 2-3 stupid mistakes or design assumptions: someone created the wrong code, used a stupid algorithm, etc.  Each such error in itself does not affect the performance - modern iron is quite powerful, it digests a lot of things.  But together two or three mistakes ‚Äúshoot out‚Äù.  And because of the separation of development and support, the authors of these errors will not know about them. <br><br>  Rarely when, in fact, they search for the authors of the code and say: ‚ÄúPlease, you don‚Äôt have to write like that anymore.  But in order to be guaranteed not to make such mistakes in the future, the developer needs to get this experience.  With the support of its own system, conclusions from the "stuffed cones" would be made faster. <br><br>  <b>- Does it make sense in early load testing (at the development stage)?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> The most expensive errors are obtained when load testing was dragged by the ears to the finished project (I'm not talking about cases when the code is tested in production).  The code was written, it works functionally, but it turns out that where 10 answers per second are required (only), the service can digest only one, and even that with a creak.  Even worse, if the foundation is to blame - the framework that was chosen because ‚Äúeveryone uses it‚Äù or ‚Äúwell, it's so new, cool.‚Äù  That is, you have to rewrite everything at all. <br><br>  The sooner problems are caught, the easier it is to solve them. <br><br>  <b>- That is, we are starting to develop and simultaneously launch testing?</b> <b><br><br></b>  <b>Vladimir Sitnikov:</b> Yes and no.  Sometimes, at an early stage, you have to look quite roughly at what is happening.  This may make sense.  But, as a rule, the code does not work at first.  And measuring the performance of a code that, say, returns the wrong answer, is a bad job.  We spend time, resources (including machine), and the result is unknown. <br><br>  However, the launch of testing is quite a long history.  Before measuring something, you need to understand what it is to measure and on what data, whether we will run out of this data during the test, how we will resume them, what metrics we will monitor, what expectations we have regarding the results and t .P.  In a very small project, all this can be done in a day or two, simply by discussing and making the necessary decision.  But for a more or less large project, such issues are not solved in one day, especially since close interaction with the customer is required. <br><br>  There are cases when the customer comes with certain requirements from the very beginning, but more often they have to be formulated only at the ‚Äúconnection‚Äù stage of load testing. <br><br>  Therefore, thinking about load testing is from the very beginning.  And I would not consider load testing as an end product.  This is a process that must be followed to avoid certain mistakes.  As the solution is created (in the process of transition directly from development to testing and output to production), the purpose of load testing also changes.  First, it is used for debugging, then - for searching errors, and at the end - as a criterion that the solution is ready for production. <br><br>  Here it seems to me appropriate analogy with the usual testing.  When should it be included?  Not at the end of development.  That testers will come at the end of development and fix everything is a myth.  Testing does not fix, but looks for errors.  And load testing is a tool for finding errors of a certain kind.  However, unlike conventional testing, which essentially checks only the possibility of passing a program along an algorithm branch to a certain point, the load test is a beta test production, which leads to differences in data, load, the ratio of tests in the mix, etc. <br><br>  To successfully find errors, you must have a search criteria.  Therefore, as a process, load testing is launched closer to the beginning of development, and in fact it passes conditionally after the first testing cycle (automatic or manual), when someone gives a flick that the whole system behaves correctly. <br><br>  <b>- It is clear that absolutely not to test everything.</b>  <b>What points need to be tested first (in terms of load testing)?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> First of all, it is necessary to test the critical scenario - that is, the one that makes money.  And to conduct at least two types of tests: for frustration, to determine the limits of performance, and for measuring timings, to make sure that the service fits into the SLA.  That is, the service must be ‚Äúfinish off‚Äù and measure timings at the level of load that is assumed in production. <br><br>  <b>- How to start load testing?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> Before you start load testing, you need to make sure that you have performed a functional test and corrected all the bugs.  And it is on your stand.  Make sure that in the middle of your shooting to your booth, no one will come to download a couple of hundred gigabytes.  In general, prepare a convenient test environment in which no one will disturb you. <br><br>  <b>Vladimir Sitnikov:</b> Testing itself should start with the formulation of non-functional requirements - i.e.  performance and stability requirements. <br><br>  The most typical non-functional requirements (the most important quantitative estimates of the application) are the size of the data being processed, the time of their processing and the frequency of launches.  Any of these metrics is found in almost every project. <br><br>  The concept of "non-functional requirements" is extensive.  In different projects, their components may have different priorities.  For example, ‚Äúthe system should be able to work for 3 days without rebooting‚Äù or ‚Äúin case of loss and restoration of communication with the database, the application should return to normal operation in no more than 2 minutes‚Äù - these are also non-functional requirements. <br><br>  By the way, the concept of "non-functional requirements" forms the idea that it is something independent.  But in fact, these requirements describe how the functionality should work.  Those.  without non-functional requirements, and functional ones lose their meaning, nor is it possible to attach NFR to any randomly chosen functional requirement. <br><br>  <b>- Are there any general recommendations for conducting load testing?</b> <b><br><br></b>  <b>Vladimir Sitnikov:</b> In general, load testing is similar to the usual.  We take the most important scenarios or the ones we fear the most.  Therefore, someone with an understanding of the project should come and point out the most dangerous scenarios.  Next, we are already engaged in automation and measurements. <br><br>  <b>- How important is the interpretation of load testing results?</b> <b><br><br></b>  <b>Vladimir Sitnikov:</b> Great.  It‚Äôs not the numbers that are important, but understanding why they are like that.  If we got 42, this does not mean that the result is good.  The customer asked to work no longer than a minute, and we managed to take half a minute.  Are we great, disagree?  Not!  It is important to understand why we could not do faster, what we are up to.  And you have to be sure that the report is real. <br><br>  There was such an example: we measured how a virtual machine affects application performance, i.e.  compared the performance of an application running on hardware and an application running on a virtual machine.  They made measurements, got good numbers (close to the expected ones) - a discrepancy in performance of a few tenths of a percent.  This could all end.  But someone looked more closely at the results and realized that instead of launching the application, we returned a page with a login error.  In the tests we did not pass on the real application.  Instead, under the guise of each of the steps, we checked the speed of the login, which was denied on the wrong password. <br><br>  What does this example mean?  The fact that without an analysis of what was going on inside during the tests, we had the wrong conclusion.  Therefore, from the point of view of load testing, it is not the numbers that are obtained that are important, but an understanding of how these numbers are explained. <br><br>  <b>Alexey Lavrenyuk:</b> Very often, people underestimate the importance of graphs, look only at the final statistics.  If you do that too, I recommend google the Enscombe Quartet and see <a href="https://www.autodeskresearch.com/publications/samestats">this article</a> from Autodesk. <br><br>  Many popular load tools on the Internet, for example ab, provide only summary statistics and false confidence in service performance under load.  They hide the details, the dips in the graphs.  Such a failure can cost money (the buyer has left), and it is very easy to fix it (correct the parameters of the garbage collector). <br><br>  In addition, many popular and expensive load tools are architecturally incorrect and lie to you.  This is written <a href="http://bravenewgeek.com/everything-you-know-about-latency-is-wrong/">in this article</a> . <br><br>  <b>- What are the features of load testing a web service?</b>  <b>In theory, it is necessary to test not only the code, but also the environment, how is this done?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> You need to test everything that interests you.  If you suspect that application performance depends on traffic jams in Moscow, find a way to test it.  I am not joking, our geoservices automatically start load tests on traffic data when their level reaches 7 points. <br><br>  We also had a mobile application on the test, which was activated only if the phone came into motion.  That is, the phone during the test had to be wobbly.  Therefore, we carried these phones with us.  There was even an idea to build a special telephone shatalka, but the application was sent for revision, and the need for automation has disappeared so far. <br><br>  <b>- Where do the data for load testing your typical project come from?</b>  <b>Are mocks or production data used?</b> <b><br><br></b>  <b>Vladimir Sitnikov:</b> I would not say that there is a typical approach to the data.  Projects are still different.  There are those where the systems do not store data at all, but are intermediate links in a certain chain.  To test them, we simply generate the necessary information.  Sometimes, on the contrary, systems store something.  If this is, for example, the history of the records, there are no problems, sort of  But if the systems store some state (DB, etc.), then there are nuances. <br><br>  At the initial stage, when we do not have any dump of production, we have to generate data (discuss the business structure and generate the right amount of the right kind of data).  Unfortunately, I would not say that it works successfully.  The generated data allows you to survive for some time, but, unfortunately, to obtain data in this way, similar to the truth and suitable for different scenarios, is difficult.  And the games begin when we generate part of the data for one type of request, part for the other, part for the third.  It is more convenient for us to generate parts, but at the same time we get distortions: either there is too much data (because we want to have a reserve for each type of scenario), or we skip some scenarios.  Because of this, sooner or later we move to something more or less similar to dumps - import from external systems or production with masking. <br><br>  There are also problems with import.  We work in the telecom segment, where the dumps of production systems cannot be copied left and right.  There are certain types of data that simply cannot be copied.  Therefore it is necessary to invent how to make the system seem to work, but the data has been replaced by asterisks, etc. <br><br>  <b>- Isn't it easier to test immediately in production by connecting some share of users?</b> <b><br><br></b>  <b>Alexey Lavrenyuk:</b> In our case, this is not testing, this is a neat release.  In an amicable way, always, even after testing, you need to roll out to the share of users, because in production everything can go differently than in testing. <br><br>  What is the connection share of users differs from load testing?  In this case, you do not have the ability to fully manage the load, you cannot bring the service to the limit (users simply receive the 500 error), you cannot turn the knobs on it with impunity and monitor as much as they could on test servers. <br><br>  On the other hand, it is possible to contrive: send part of the production traffic to your test servers and use load tools there.  This is already load testing, just the source data is taken in real-time from the production environment. <br><br>  In other words, if you are satisfied with the answer ‚Äúwe hold / do not hold‚Äù (and with some probability to disappoint some share of its users), then it is possible and not to test load.  If you want to know the limits of performance, bottlenecks, in which monitoring it is better to look, for which twisters to grab in the first place and to whom to run - then still do load testing. <br><br>  <b>Vladimir Sitnikov:</b> This is not our case.  There are companies that test without problems in production.  They have a part of clients that can be redirected to a new version of the code.  In our case, we are talking about a system that is important for the business of our customers.  If it does not work, the customer loses money.  Therefore, the load tests are carried out before entering the code into operation. <br><br>  Our systems are important for the business of customers, and in many cases it is installed and serviced by completely different people - representatives of the customer.  Therefore, our customers have no desire to experiment on the combat system, and load tests are carried out before commissioning. <br><br>  <b>- Do you have any favorite tools for load testing?</b> <b><br><br></b>  <b>Vladimir Sitnikov:</b> Of course.  We have 3 main tools: we use Apache JMeter for testing the server side, we use Selenium for testing the browser and JMH for testing Java.  These tools cover the vast majority of needs. <br><br> <i>,        ,            2017 Piter.   ,        ,    <a href="https://heisenbug-piter.ru/talks/load-testing-a-web-service//"></a>    web-,    real time show  ¬´¬ª  web-  Python Tornado,   ,    ,    ,  ¬´ ¬ª,     ¬´¬ª  ¬´¬ª. <br><br>     ,      2017 Piter,   <a href="https://heisenbug-piter.ru/"> </a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/329174/">https://habr.com/ru/post/329174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329156/index.html">Two words about abstract forces ruling Worlds</a></li>
<li><a href="../329160/index.html">Unreal engine 4. Sequencer instead of Matinee</a></li>
<li><a href="../329166/index.html">Bug in NTFS, or how to hang the whole system</a></li>
<li><a href="../329168/index.html">Pygest # 9. Releases, articles, interesting projects from the world of Python [May 8, 2017 - May 22, 2017]</a></li>
<li><a href="../329170/index.html">Domestic processor from the company ELVIS</a></li>
<li><a href="../329176/index.html">From dependent types to homotopic type theory on Scala + Shapeless + ProvingGround</a></li>
<li><a href="../329178/index.html">PostgreSQL Diagnostic Techniques - Vladimir Borodin and Ildus Kurbangaliev</a></li>
<li><a href="../329180/index.html">We write an analogue of Paint on Objective-C</a></li>
<li><a href="../329182/index.html">Seminar "Modernization of engineering systems in the existing data center", May 31, Moscow</a></li>
<li><a href="../329184/index.html">Bitdefender Hypervisor Introspection: a new means of dealing with hidden cyber threats</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>