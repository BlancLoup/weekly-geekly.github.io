<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing a compiler for the cool language in C # for .NET (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Hello, dear habrayuzer. I would like to present you the material on the practical creation of a compiler that will translate the code w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing a compiler for the cool language in C # for .NET (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Hello, dear habrayuzer. I would like to present you the material on the practical creation of a compiler that will translate the code written in the Cool language into the <b>CIL</b> (Common Intermediate Language) virtual machine code for the <b>.NET</b> platform. I decided to split this material into <s>- for laziness to describe it all at once</s> <br><br>  In the <b>first</b> part, we will describe the process of writing grammar taking into account the priorities of operators in the ANTLR environment, as well as generating the lexer and parser for C #.  It will also examine the pitfalls that I met on my way.  Thus, I will try to save some time (maybe for myself in the future). <br><br>  In the <b><a href="http://habrahabr.ru/blogs/compilers/136714/">second</a></b> part, the process of building a <b>semantic</b> code <b>analyzer,</b> code <b>generation</b> and self-made code <b>optimization</b> <s>nobody</s> needs will be described.  There will also be described how to make a beautiful interface <s>with blackjack and whores</s> with syntax highlighting and folding of blocks, as in modern IDE.  At the end of the second part, I, of course, will lay out all the sources of my solution and talk about the further improvement of the architecture and code, at least as it seems to me. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  <i>Warning</i> : before developing this compiler, I practically did not study any thematic literature.  Everything was done by reading a few articles of interest to me, watching ANTLR <a href="http://javadude.com/articles/antlr3xtut/">video tutorials</a> on the official website and talking to ‚Äúrummaging‚Äù group mates.  So the developed software is far from ideal. <br><br>  In order for the reader to better understand me, I will first give some definitions (from Wikipedia): <ul><li>  <b>Token</b> - sequences of characters in lexical analysis in computer science, corresponding to a token. </li><li>  <b>A lexer</b> is a module for analytically parsing an input sequence of characters (for example, such as source code in one of the programming languages) to produce at the output a sequence of characters called "tokens" (like grouping letters into words). </li><li>  <b>Parser</b> is a module for comparing a linear sequence of lexemes (words, tokens) of a language with its formal grammar.  The result is a parse tree or syntax tree. </li></ul>  On Habrahabr, and not only, there are many articles explaining in detail how to write a grammar for mathematical expressions and languages, so I will not dwell on setting up the environment in detail.  Also, I will not delve into the theoretical issues of compiler construction, since there are also a number of quite good articles on this topic, for example, <a href="http://habrahabr.ru/blogs/programming/99162/">this cycle.</a> <br><br>  So, to develop a compiler, the following programs and libraries were used: <ol><li>  <a href="http://www.antlr.org/works/index.html"><b>ANTLRWorks</b></a> - IDE for writing grammars and generating code for lexers and parsers for various languages ‚Äã‚Äã(C, C #, Java, JavaScript, Objective-C, Perl, Python, Ruby, etc.).  Based on LL (*) parsing. </li><li>  <a href="http://www.antlr.org/wiki/display/ANTLR3/Antlr%2B3%2BCSharp%2BTarget"><b>ANTLR C # runtime distribution</b></a> (Antlr3.Runtime.dll) is used in the generated lexer and parser. </li><li>  <b>Visual Studio 2010</b> In the next article, we will look at a component under WPF, an advanced text editor for syntax highlighting and code completion ( <a href="http://www.codeproject.com/KB/edit/AvalonEdit.aspx">AvalonEdit</a> ). </li><li>  <b>Java Runtime Environment</b> (since ANTLRWorks is written in Java). </li><li>  <b>IL Disassembler</b> will be used in the second part in order to understand how the compiler, for example the C # language, generates CIL code and how it should look. </li></ol><h4>  Cool language description </h4><br>  <b>Cool</b> - Classroom Object-Oriented Language is, as we see from the name, a <s>useless</s> programming language that includes classes and objects.  Cool is a functional strictly typed language, i.e.  type checking occurs statically at compile time.  The program is essentially a set of classes.  Classes include a set of fields and functions (here they are called <i>feature</i> ). <br>  All fields are visible inside the base and derived classes.  All functions are visible from everywhere (public). <br>  This language is built on expressions ( <i>expression</i> ).  All functions can take expressions as arguments and the bodies of all functions are expressions that return a result.  Even functions such as string output return a result, namely an instance of the class from which they are called. <br>  Cool also contains static classes String, Int, Bool, from which you cannot inherit and which cannot take null values ‚Äã‚Äã(here it is called <i>void</i> ).  Objects of these classes are passed by <i>value</i> , not by reference. <br>  Keywords in this language: class, else, false, fi, if, in, inherits, isvoid, let, loop, pool, then, while, case, esac, new, of, not, true <br>  I want to note that some operators do not end with a curly brace (as in C-like ones) or with the word end;  (as in <s>dead</s> pascal), and the name of the name of the same operator in the reverse order (if -&gt; fi, loop -&gt; pool, case -&gt; esac). <br>  What do you think, if each statement returns a result, then what should return if?  After all, he can return the option of two alternatives.  The correct answer is: the closest common ancestor (in the textbook it is written about it is somehow difficult, there is still a special operator used).  Here is a picture for clarity: <br><img src="https://habrastorage.org/storage2/b4a/2eb/42d/b4a2eb42d4e46a5e77f619e13579e5a0.png"><br>  Picture 1. <br><br>  Here, in classes A and B, the closest common ancestor is class D. <br><br>  The <b>case statement</b> is similar to the if statement, applied several times. <br><br>  In the <b>while</b> construct, void is always returned (unless of course the loop is looping). <br><br>  Such a construction {&lt;expr1&gt;; ... &lt;exprn&gt;;  } returns the object of the expression exprn, i.e.  last expression. <br><br>  Functions here can be called not only for the class and its ancestor (virtual functions), but in general for any ancestors of this class.  This can be done using the '@' operator.  As an example, consider the class hierarchy in Figure 1. Let class E have a function func (), all other descendants redefine it in their own way.  Then, if we have an instance of object A and want to call the function func from class D, we need to use the following syntax: <pre><code class="hljs scala">result &lt;- (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>)<span class="hljs-meta"><span class="hljs-meta">@D</span></span>.func()</code> </pre> <br>  The keyword <b>SELF_TYPE is</b> used as a synonym for a class that describes a specific function.  The <b>self</b> identifier is a pointer to the current class (i.e. this in other languages). <br><br>  Local variables are entered in the Cool language using the <b>let</b> operator and they can only be used within this let block. <br><br>  <b>void</b> is an analogue of null, a sign that the object was not created. <br><br>  I think all the other operators do not need explanations, and if it‚Äôs not clear, then you can study the manual for this cool language dialect using the link at the end of the article. <br><br><h4>  Writing Cool Language Grammar at ANTLRWorks </h4><br>  So, the original grammar is given in the following form: <br><br><pre> <code class="hljs lua">program ::= <span class="hljs-string"><span class="hljs-string">[[class; ]]</span></span>+ class ::= class TYPE [inherits TYPE] { <span class="hljs-string"><span class="hljs-string">[[feature; ]]</span></span>*} feature ::= ID( [ formal <span class="hljs-string"><span class="hljs-string">[[, formal]]</span></span>*] ) : TYPE { expr } | ID : TYPE [ &lt;- expr ] formal ::= ID : TYPE expr ::= ID &lt;- expr | expr[@TYPE].ID( [ expr <span class="hljs-string"><span class="hljs-string">[[, expr]]</span></span>*] ) | ID( [ expr <span class="hljs-string"><span class="hljs-string">[[, expr]]</span></span>*] ) | <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> expr <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> expr fi | <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> expr loop expr pool | { <span class="hljs-string"><span class="hljs-string">[[expr; ]]</span></span> +} | let ID : TYPE [ &lt;- expr ] <span class="hljs-string"><span class="hljs-string">[[, ID : TYPE [ &lt;- expr ]]</span></span>]* <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> expr | case expr of <span class="hljs-string"><span class="hljs-string">[[ID : TYPE =&gt; expr; ]]</span></span>+ esac | new TYPE | isvoid expr | expr + expr | expr ? expr | expr ? expr | expr / expr | ~expr | expr &lt; expr | expr &lt;= expr | expr = expr | <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> expr | (expr) | ID | integer | <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> | <span class="hljs-literal"><span class="hljs-literal">true</span></span> | <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><br>  Notation: [[]] * - iteration;  [[]] + - positive iteration; So, what should be done after seeing such a grammar?  <s>Forget about it forever and about compilers.</s>  <s>Who needs another nepoyazyk ??</s>  So, if you immediately rewrite this grammar in ANTLR and generate lexer and parser code, then nothing good will come of it because of the following reasons: <ul><li>  The existence of <b>left recursion</b> .  Of course, ANTLRWorks, based on the recursive descent method, will immediately detect and produce an error of the following kind: <i>[fatal] rule compilation_unit has non-LL (*) ‚Ä¢ Resolve by left-factoring or using syntactic predicates or using backtrack = true option ...</i> And, of course, ANTLR has an option backtrack = true, which allows you to overcome this limitation.  But having applied it, it is necessary to come to terms with another node in the generated spacecraft for expression with left recursion.  So it would still be good to get rid of it.  In addition, as can be seen from this <a href="http://www.antlr.org/wiki/display/ANTLR3/How%2Bto%2Bremove%2Bglobal%2Bbacktracking%2Bfrom%2Byour%2Bgrammar">article</a> , this option slows down the work of the parser and the author recommends, if possible, to abandon it. </li><li>  But the main thing is that the <b>priority of operators is</b> not taken into account in this form of grammar.  If the left recursion affects only the efficiency of the parser, then ignoring this problem will lead to incorrect code generation later (for example, 2 + 2 * 2 will be equal to 8, not 6) </li></ul>  We read the manual further.  And then just written about the priorities of operations.  They take the following form (at the top - the highest, at the bottom - the lowest priorities). <ul><li>  . </li><li>  @ </li><li>  ~ </li><li>  isvoid </li><li>  * / </li><li>  + - </li><li>  &lt;= &lt;= </li><li>  not </li><li>  &lt;- </li></ul>  So, we need to build our grammar with these operations.  To do this, we adhere to the following construction rule: For each lower priority operator, we create a new rule that will contain the operator of this priority and the nonterminal for the higher priority operator in the right-hand part. I know that it sounds messy, so I‚Äôll quote this construction for our original grammar: <br><pre> <code class="hljs vbscript">expr: (ID ASSIGN^)* <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span>^)* relation; relation: addition ((LE^ | LT^ | GE^ | GT^ | EQUAL^) addition)*; addition: multiplication ((PLUS^ | MINUS^) multiplication)*; multiplication: isvoid ((MULT^ | DIV^) isvoid)*; isvoid: (ISVOID^)* neg; neg: (NEG^)* dot; dot: term ((ATSIGN <span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span>)? DOT ID LPAREN invokeExprs? RPAREN)? -&gt; ^(Term term ID? <span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span>? invokeExprs?);</code> </pre><br>  The term in this case includes all the remaining expressions that were not considered, i.e.  expressions with the same priority. <br><br>  Comments in the language are essentially a sequence of characters that must be ignored during lexical parsing.  For this, the ANTLR design is used <pre> <code class="hljs perl">{$channel = Hidden;};</code> </pre>  written to the right of each rule describing comments.  For example: <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">COMMENT</span></span> : <span class="hljs-string"><span class="hljs-string">'--'</span></span> .* (<span class="hljs-string"><span class="hljs-string">'\n'</span></span>|<span class="hljs-string"><span class="hljs-string">'\r'</span></span>) {$channel = Hidden;};</code> </pre> <br><br><h4>  ANTLR Operators </h4><br>  Next, I will describe the ANTLR operators used: <ol><li>  <b>!</b>  - it is necessary so that the extra language tokens do not interfere with parsing.  For example, brackets and other operators that are needed only for the parser (for example, the same endings of the syntax constructions fi, esac).  These operators are needed in order to build exactly the <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">syntactic tree</a> from the stream of tokens, and not the parse tree). </li><li>  <b>-&gt;</b> - needed to convert a sequence of tokens on the left side to a sequence of tokens on the right side, which would be convenient to handle when generating code. The operator ^ is also used along with this operator. </li><li>  <b>^ is</b> used to create a new node from the token marked by this operator and its descendants in the generated syntax tree.  There are two forms for this operator: <ul><li>  <b>Postfix.</b>  For example, for such a rule: <pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">relation:</span></span> addition ((LE^ <span class="hljs-params"><span class="hljs-params">| LT^ |</span></span> GE^ <span class="hljs-params"><span class="hljs-params">| GT^ |</span></span> EQUAL^) addition)*;</code> </pre>  a node is inserted into the syntax tree with one of the operators in brackets and the children <i>addition</i> , which is to the left of the operator and <i>addition</i> , which is to the right of the operator. </li><li>  <b>Prefix.</b>  For example, for such a rule: <pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span> (INHERITS <span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span>)? LCURLY featureList RCURLY -&gt; ^(<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span> featureList <span class="hljs-built_in"><span class="hljs-built_in">typeName</span></span>?)</code> </pre>  the parent node of the <i>Class</i> with the descendants of <i>typeName featureList typeName is inserted</i> into the syntax tree <i>.</i> </li></ul></li></ol><br>  All other used ANTLR operators do not need comments (for a person studying discrete mathematics), and if they do, then small ones: <ol><li>  <b>*</b> - Iteration. </li><li>  <b>+</b> - Positive iteration. </li><li>  <b>?</b>  - A left-standing token or a group of tokens may or may not be present. </li></ol>  I want to note that when using the '-&gt;' and '^' operators, it becomes necessary to introduce new tokens.  This is done in the corresponding tokens {} section. By the way, I support the fact that the .g file has a minimum of code intended for a specific lexer language and parser (in our case for C #).  However, this code still had to be used for the STRING token: <br><br><pre> <code class="hljs pgsql">STRING: <span class="hljs-string"><span class="hljs-string">'"'</span></span> { StringBuilder b = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> StringBuilder(); } ( <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span> { b.Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>);} | c=~(<span class="hljs-string"><span class="hljs-string">'"'</span></span>|<span class="hljs-string"><span class="hljs-string">'\r'</span></span>|<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { b.Append((<span class="hljs-type"><span class="hljs-type">char</span></span>)c);} )* <span class="hljs-string"><span class="hljs-string">'"'</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span> = b.ToString(); } ;</code> </pre><br><br>  Here StringBuilder is used to make string processing efficient. In principle, other blotches of such code are acceptable for optimizing the lexer, but not for all the rules. In order to specify namespaces in the C # code of the lexer and parser StringBuilder), the following constructs are used (some ‚Äúunnecessary‚Äù warnings are also disabled here): <br><br><pre> <code class="hljs pgsql">@lexer::<span class="hljs-keyword"><span class="hljs-keyword">header</span></span> {#pragma <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span> <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> <span class="hljs-number"><span class="hljs-number">3021</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Text; } @<span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">header</span></span> {#pragma <span class="hljs-built_in"><span class="hljs-built_in">warning</span></span> <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> <span class="hljs-number"><span class="hljs-number">3021</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Text;}</code> </pre><br><br>  After we compiled the grammar in ANTLRWorks, we need to generate the C # code of the lexer and the parser (thanks, cap). <br><br>  ANTLRWorks with the specified settings generates 3 files: <ul><li>  CoolGrammar.tokens </li><li>  CoolGrammarLexer.cs </li><li>  CoolGrammarParser.cs </li></ul><br><h4>  Using the generated lexer in C # code </h4><br>  Getting a list of all tokens in the generated C # code does not look very trivial (although it is not always necessary): <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ANTLRStringStream(Source); <span class="hljs-comment"><span class="hljs-comment">// Source -  . lexer = new CoolGrammarLexer(stream, new RecognizerSharedState() { errorRecovery = true }); IToken token; token = lexer.NextToken(); while (token.Type != CoolGrammarLexer.EOF) { //    . //  : CoolTokens.Dictionary[token.Type] (  '('  LPAREN, //     ,      ) //  : token.Text (  '('   "(") //     : token.Line //       : token.Column token = lexer.NextToken(); //   ,   ,      . } //           0, //        (  ). lexer.Reset();</span></span></code> </pre><br>  CoolTokens.Dictionary should be generated as follows: <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Lines = File.ReadAllLines(fileName); Dictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(Lines.Length); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Lines) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parts = line.Split(<span class="hljs-string"><span class="hljs-string">'='</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Dictionary.ContainsKey(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(parts[<span class="hljs-number"><span class="hljs-number">1</span></span>]))) Dictionary.Add(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(parts[<span class="hljs-number"><span class="hljs-number">1</span></span>]), parts[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre>  fileName - path to the CoolCompiler.tokens file <br><br><h4>  Using the generated parser in C # code </h4><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tokenStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommonTokenStream(lexer); <span class="hljs-comment"><span class="hljs-comment">//   lexer,   . parser = new CoolGrammarParser(tokenStream); Tree = parser.program(); //   ,     (.. program   ).</span></span></code> </pre>  To bypass the same syntax tree, the following properties and methods of the IList interface are used: <ul><li>  treeNode.ChildCount - the number of children at the node treeNode </li><li>  treeNode.GetChild (i) - getting a child at treeNode node i </li><li>  treeNode.Type is the token of this node.  It has type int and must be compared with constants declared in the lexer class.  For example: treeNode.Type == CoolGrammarLexer.EQUAL (whether this token is a '=' sign). I want to note that when traversing a tree, you must use the Type property, and not Text, because sranivanie numbers faster than string matching, to the probability of error is reduced, since all constants are generated automatically. </li><li>  treeNode.Line - the token line number in the code </li><li>  treeNode.CharPositionInLine - the position of the token in the code from the beginning of the line </li></ul>  I also wanted to pay special attention to the fact that when generating code from a grammar in C #, you need to put the <b>public</b> modifier before the grammar axiom (in this case before the program) so that you can call it later from the code (otherwise it will be private) <br><br><h4>  Conclusion </h4><br>  This article explained how to describe a grammar in the ANTLRWorks environment, which is then used to generate lexer and parser code in C #, as well as how to use a lexer and a parser.  The next article will cover the processing of language semantics (i.e., type checking, semantic error handling), how to bypass each node of the syntax tree and generate CIL code for the corresponding syntax, explaining the CIL instructions, explaining the operation of the virtual machine stack and using .NET library System.Reflection.Emit to facilitate code generation.  Of course, I will describe the pitfalls that I met on my way (in particular, the creation of a class hierarchy using System.Reflection.Emit).  Also there will be described how to make <s>beautiful wallpapers</s> beautiful and modern interface!  However, about what is written in the conclusion, is already partially written in the introduction. <br><br>  Finally, I would like to ask one question to the community about which I could not find the answer: <br><br>  For the C # lexer, I always generate such code to exclude a NoViableAltException, and this throw is impossible to intercept: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoViableAltException nvae) { DebugRecognitionException(nvae); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre>  <i>How can I write a grammar file so that in this line not only there was a throw, but for example, my exception was called or did the lexer continue to work at all?</i>  And then you have to correct this line every time you generate C # code. Note: the manipulations with @rulecatch in ANTLR did not lead to anything. <br><br>  It would be nice if someone figured out this problem and wrote the answer in the comments. <br><br><h4>  Recommended reading </h4><ul><li>  Definite ANTLR Reference, Terence Parr, 2007. </li><li>  Compilers  Principles, Technologies and Tools, 2008, Alfred V. Aho, Monica S. Lam, Ravi Seti, Jeffrey D. Ullman </li></ul>  <a href="http://narod.ru/disk/37785883001/CoolGrammar.7z.html">The manual on the language Cool, its grammar file with the extension .g, the environment ANTLRWorks</a> </div><p>Source: <a href="https://habr.com/ru/post/136528/">https://habr.com/ru/post/136528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136517/index.html">What is ITSM?</a></li>
<li><a href="../136518/index.html">Encapsulation - black box?</a></li>
<li><a href="../136520/index.html">Automatic spell checker in EXCEL</a></li>
<li><a href="../136525/index.html">LESS: programmable style language</a></li>
<li><a href="../136527/index.html">LG Electronics in 2012. Plans and business tasks</a></li>
<li><a href="../136529/index.html">Writing a simple plugin for Sublime Text 2</a></li>
<li><a href="../136530/index.html">Determining the dominant tones in the image</a></li>
<li><a href="../136531/index.html">Passive XSS in Yandex.Money</a></li>
<li><a href="../136533/index.html">DWM - minimalism in action</a></li>
<li><a href="../136534/index.html">Support The Daily WTF in support of the SOPA movement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>