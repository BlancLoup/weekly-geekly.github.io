<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The presumption of culpability of the programmer or why the compiler sometimes ‚Äútupit‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is again devoted to cyclic optimization. Why is it all about cyclic permutation optimizations? The fact is that this is one of the most effi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The presumption of culpability of the programmer or why the compiler sometimes ‚Äútupit‚Äù</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/429/a0d/a6c/429a0da6c4c5b2d06e4caa14e3b6ec14.png" alt="image"><br><br>  This post is again devoted to cyclic optimization.  Why is it all about cyclic permutation optimizations?  The fact is that this is one of the most efficient parts of an optimizing compiler.  The number of cyclic permutation optimizations includes both auto-vectorization and auto-parallelization.  These optimizations have their own specifics, but in general, all cyclic optimizations have common problems and common methods for solving them. <br>  Often you hear the opinion that the compiler in many cases "tupit".  I want to be a compiler's attorney here to show that the compiler‚Äôs life is not so easy, it is possible to cause an easy share of sympathy for its difficult part and to show what objective difficulties exist in processing the program and why in many cases the compiler rightly cannot do this or other optimizations that seem obvious to the programmer.  Well, at the same time I want to demonstrate some possibilities to help the compiler in its work.  It is clear that sometimes there are also subjective factors, in the face of developers who for some reason did not implement this or that functionality within the compiler. <br><br><a name="habracut"></a><br>  I will use the Intel compiler for Windows, but I think similar problems cause headaches for users and developers of all optimizing compilers with cyclic optimizations, so I hope this post will be useful for all programmers.  I assume that the reader has some basic ideas about interprocedural analysis, so I will refer to the possibilities of this analysis without a detailed explanation of what it is and how it works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://habrahabr.ru/company/intel/blog/161155/">In the previous post</a> I suggested looking at the change in the performance of the synthetic test caused by the use of high-level cycle distribution of loop splitting (loop distribution).  One of the main goals of the example was to show how the rearrangement of the order of operations can affect the operation of the memory subsystem and how many different performance factors can be changed.  Those.  The evaluation of the profitability of optimization is a rather difficult job, which is often made difficult by the lack of accurate information about the structure of the data being processed. <br>  And this is not all the difficulties that the compiler faces.  Before evaluating the possible benefits of a particular transformation, you need to spend some effort to recognize the cycles themselves and prove the very possibility of applying the permutation optimization.  Basically this post is devoted to the problem of recognizing loops and ambiguity resolution when working with memory. <br><br><h4>  Cycle Recognition </h4><br>  To perform cyclic permutation optimizations, the compiler must first recognize and classify cycles.  The main cyclic optimizations are applicable only to cycles with a certain number of iterations, having successively changing iterative variables (and as a result, not having transitions beyond the limits of the cycle and calls to unknown functions).  Consider, for example, a set of simple cycles located in a certain function foo: <br><br><pre><code class="hljs pgsql">extern <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">unknown</span></span>(); <span class="hljs-type"><span class="hljs-type">int</span></span> gn,gi; typedef struct vector { <span class="hljs-type"><span class="hljs-type">float</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> lbound; <span class="hljs-type"><span class="hljs-type">int</span></span> ubound; } vec; <span class="hljs-type"><span class="hljs-type">int</span></span> foo(<span class="hljs-type"><span class="hljs-type">int</span></span> n, <span class="hljs-type"><span class="hljs-type">float</span></span> *a, vec *v) { <span class="hljs-type"><span class="hljs-type">int</span></span> i,j; <span class="hljs-type"><span class="hljs-type">int</span></span> b[<span class="hljs-number"><span class="hljs-number">100</span></span>]; // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;gn;i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(gi=<span class="hljs-number"><span class="hljs-number">0</span></span>;gi&lt;n;gi++) a[gi]=<span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i=i*<span class="hljs-number"><span class="hljs-number">3</span></span>) b[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { j=<span class="hljs-type"><span class="hljs-type">unknown</span></span>(); b[i]=j; } // <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b[i] !=<span class="hljs-number"><span class="hljs-number">0</span></span>) break; b[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } // <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n&amp;&amp;i&lt;gn;i++) b[i] = i; // <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gn) break; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> b[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;n) goto <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; b[i] = <span class="hljs-number"><span class="hljs-number">100</span></span>; } // <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=v-&gt;lbound;i&lt;v-&gt;ubound;i++) { v-&gt;<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i]=i; } <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b[<span class="hljs-number"><span class="hljs-number">10</span></span>]; }</code> </pre> <br><br>  Did the compiler recognize these loops and is there a way to figure this out?  I don‚Äôt know a clear way (except for using internal dumps for developers), but there is an interesting indirect method related to issuing a report on the work of the auto vectorizer using the / Qvec-report2 key.  The / Qvec_report switch is used like this: <br><br>  / Qvec-report [n] <br>  control amount of vectorizer diagnostic information <br>  n = 0 no diagnostic information <br>  n = 1 indicate vectorized loops (DEFAULT when enabled) <br>  n = 2 indicate vectorized / non-vectorized loops <br>  n = 3 indicate vectorized / non-vectorized loops and prohibiting <br>  data dependence information <br>  ... <br><br>  If you compile the file with the default options and the / Qvec_report2 key, the compiler will display the following information: <br><br>  icl -Qvec_report2 test_loops.c <br>  .. \ test_loops.c (34): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (41): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (45): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (53): (col. 1) remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (16): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (20): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (24): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (28): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br>  .. \ test_loops.c (60): (col. 1) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br><br>  The phrase nonstandard loop and means that the loop has an inappropriate structure for performing loop optimization.  What is the reason that the compiler could not recognize and classify cycles? <br>  1 cycle: The global variable ‚Äúgn‚Äù is used in the exit condition.  At each iteration, the memory is modified through the ‚Äúa‚Äù pointer.  Theoretically, this pointer may refer to ‚Äúgn‚Äù and the condition for exiting the loop may change at each iteration. <br>  2 cycle: The same situation is connected with the use of the global variable ‚Äúgi‚Äù as an iterative variable of the cycle.  The iteration variable can be changed to any iteration through the "a" pointer. <br>  Cycle 3: The iteration variable changes nonlinearly. <br>  4th cycle: Call inside the loop of an unknown function.  Such a call may include, for example, exiting the program. <br>  5 cycle: There are several conditions under which the execution of the cycle can be interrupted.  Those.  the number of iterations of such a cycle cannot be determined at compile time. <br>  Cycle 6: The compiler was unable to parse the complex exit condition of the loop.  The use of the global ‚Äúgn‚Äù is not an obstacle here, since the cycle is working with the local array ‚Äúb‚Äù and this variable cannot be changed in the process. <br>  Cycle 7: A conditional transition within a cycle makes it difficult to determine the number of iterations.  The transition does not depend on the iterative variable, and here the compiler could take a conditional transition out of the loop.  But apparently for this you must first recognize the cycle. <br>  Cycle 8: Using goto with going to an outside loop makes the number of iterations of such a loop indefinite.  Although such a transition can not happen, but this problem also had to be solved BEFORE the phase of recognition of cycles. <br>  Cycle 9: A very typical case.  The array field can theoretically refer to the lbound or ubound fields.  This is one of the reasons why there are problems processing various containers from the STL library, such as vector. <br><br>  Most of the above difficulties in classifying cycles are associated with the problem of ambiguity resolution when working with memory (memory disambiguation).  To resolve this problem, the compiler uses both the provisions of the standards of programming languages ‚Äã‚Äãand the results of interprocedural analysis.  Since in my example the interprocedural analysis is not used to the full (by default, the Intel compiler uses ‚ÄìQip, that is, only the functions from the compiled source file are analyzed), the compiler basically has to use only the rules of the C and C + standards. +, which provide programmers with ample opportunities to organize various objects that refer to the same memory. <br><br>  We can formulate the following wishes for programmers who want to achieve the best result in optimizing their programs: <br>  1.) Do not use global variables and pointers in constructions that determine the behavior of a loop.  If necessary, create local variables. <br>  2.) Simplify, where possible, the exit condition of the loop.  For example, in cycle 6 it was possible to pre-calculate the smallest value for ‚Äún‚Äù and ‚Äúgn‚Äù and use it later in the output condition. <br>  3.) Avoid conditional jumps beyond the cycle. <br>  4.) Use the ‚ÄìQansi_alias option if you do not violate ANSI aliasing rules in your programs.  These rules state that incompatible types of pointers can never refer to the same memory.  Those.  By setting this option when compiling, you give the compiler the ability to use type information to resolve ambiguities when working with memory.  In this case, you let the compiler know that in your program, pointers refer only to objects of their own or compatible types. <br>  5.) Quite often, arguments are pointers passed to a function.  The C99 standard introduced a new restrict type qualifier for pointers.  restrict-qualification of pointers means that the data pointed to by such pointers does not indicate overlapping objects.  In the given example, the description of the function foo using this classifier would look like: int foo (int n, float * rest a, vec * rest v).  To use this functionality, you need to add the option ‚ÄìQstd = c99 when compiling. <br>  6.) When organizing your project, place the shared functions in one source file and use the static attribute to limit the scope of objects and functions to this source file.  This improves the ability of effective interprocedural analysis with the ‚ÄìQip option.  Looking ahead, I would like to note that a complete interprocedural analysis of-Qipo is very useful, but it significantly increases the compilation resources and compile time.  Therefore, with a competent project organization, the ‚ÄìQip option can be a very useful alternative, while providing performance comparable to -Qipo. <br>  7.) Use the option to enable interprocedural analysis and optimizations (-Qipo).  This option allows, for example, to determine whether the address was taken from a variable.  If it is possible to establish that the address of a variable has never been taken, then this greatly simplifies the elimination of ambiguity.  In addition, interprocedural analysis includes the collection of information about objects referenced by pointers (local and global <a href="http://en.wikipedia.org/wiki/Pointer_analysis">points-to analysis</a> ) and the properties of functions.  Substitution of the function body (inlining) can lead to the fact that the cycle with the function call becomes ‚Äúgood‚Äù and can be optimized.  All this is partly true for ‚ÄìQip. <br><br>  Well and not to offend fans of C ++ a small synthetic test in C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; class Array { public: Array(int n); ~Array() { free(Objects);}; void initArray(int x); int nobjects; int *Objects; }; Array::Array(int n) { nobjects = n; Objects = (int*) malloc(nobjects*sizeof(int)); } void Array::initArray(int x) { for(int i=0;i&lt;nobjects;i++) Objects[i] = x; }</span></span></span></span></code> </pre><br><br>  I am wondering if the loop is recognized inside initArray. <br>  Without the ‚ÄìQansi_alias option, everything is generally bad here, since the hidden pointer this appears, which, from the point of view of the compiler taught by bitter life, can point to anything.  ‚ÄìQansi_alias solves this problem and with this option the members of the class can no longer be aliased to this.  But even the presence of the ‚ÄìQansi_alias option does not help the compiler recognize the loop. <br><br>  icl -Qvec_report2 -Qansi_alias test_loops.cpp -c <br>  test_loops.cpp (18): (col. 2) Remark: loop was not vectorized: nonstandard loop is not a vectorization candidate. <br><br>  The compiler fears here that when writing to Objects, the variable nobjects can be changed.  As a result, the loop is not recognized.  The ‚ÄìQansi_alias option does not help, since the Objects and nobjects pointer is of the same type.  If this file were part of a project and we would build a project with the ‚ÄìQipo option, the compiler would recognize and vectorize this cycle if it proved that these objects cannot overlap in memory. <br>  Here we should focus on the fact that if you use a member of a class of type nobjects in an exit condition from a loop, the compiler sees this-&gt; nobjects.  Replacing this object with a local variable before the cycle will simplify the recognition of the cycle. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Array::initArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n=nobjects; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) Objects[i] = x; }</code> </pre><br><br>  Interestingly, if you declare nobjects a private class variable, then in this case, the cycle is vectorized.  This is due to interprocedural analysis (-Qip) performed for a single file. <br>  Thus it is possible to form a recommendation: <br>  6a) Use the private attribute for class members, if possible, to limit their scope.  Those.  This is a good recommendation from the point of view of writing modular code, but this principle also brings some benefits for optimizations. <br><br>  I would also like to note that in the case of a nest of cycles, an unrecognized internal cycle automatically leads to the rejection of all external cycles to it.  There are few cycle operations on the loop nest, for example loop interchange (loop interchange).  However, identifying nest loops can be very useful for performance. <br><br><h4>  Permissibility criterion for permutation optimizations </h4><br>  So, the main idea of ‚Äã‚Äãcyclic optimization is to change the order of the work performed.  Once the cycles have been recognized and classified and the real work begins.  It is necessary to determine the conditions under which one can do cyclic permutation optimizations and at the same time obtain an "equivalent program" or equivalent calculations.  From the point of view of an unbiased user, programs will be equivalent if, with the same input data, they receive the same results and the results are displayed in the same order.  If you think about when the change in the calculation order will result in the final result remaining unchanged, then it is easy to reproduce the equivalence criterion for the calculations.  Results will be the same if statements that are dependent on each other are executed in the same order in the original and modified calculations.  Those.  Independent instructions can be rearranged as you like, but the order of dependent calculations must be preserved.  And here appears such a key concept for optimizing compiler, as dependence. <br>  There are <a href="http://en.wikipedia.org/wiki/Data_dependency">data dependencies and control graphs</a> . <br>  If you want to apply a certain cyclic optimization, then to prove its correctness, you will need to make sure that the order of dependencies in the initial and derived cycle will be the same.  There is a rather complicated methodology for detecting dependencies when using in a loop (or loop nest) array A, indexed by iteration counters (iterative loop variables).  The compiler tries to determine if there is a call and write to the same memory at different iterations.  The best option for many cyclic optimizations is the absence of dependencies in the cycle.  (There are permutation optimizations that use dependencies in their work.) To determine dependencies, the compiler uses quite complex methods, but all this complex functionality will not be needed unless the ambiguity problem is solved when working with memory.  In this case, there are completely unexpected dependencies that can interfere with profitable optimizations. <br><br>  Again, take a small example and see how dependencies interfere with vectorization, as well as other optimizations.  In this case, all measures have been taken to prevent the use of one memory by different objects. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> foo(<span class="hljs-type"><span class="hljs-type">float</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> a, <span class="hljs-type"><span class="hljs-type">float</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> b, <span class="hljs-type"><span class="hljs-type">int</span></span> n, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> i,j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) { a[i] = a[i+<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>]; b[i] = b[i+<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br><br>  icl -Qstd = c99 -Qvec_report3 test_loops.c -c <br>  est_loops.c (4): (col. 1) remark: loop was not vectorized: existence of vector. <br>  .. \ test_loops.c (6): (col. 4) remark: vector dependence: assumed ANTI dependence between line 6 and b line 6. <br>  .. \ test_loops.c (6): (col. 4) remark: vector dependence: assumed between b line 6 and b line 6. <br>  .. \ test_loops.c (6): (col. 4) remark: vector dependence: assumed between b line 6 and b line 6. <br>  .. \ test_loops.c (6): (col. 4) remark: vector dependence: assumed ANTI dependence between line 6 and b line 6. <br>  .. \ test_loops.c (5): (col. 4) remark: vector dependence: assumed ANTI depending on line 5 and a line 5. <br>  .. \ test_loops.c (5): (col. 4) remark: 5: a line 5 and a line 5. <br>  .. \ test_loops.c (5): (col. 4) remark: 5: a line 5 and a line 5. <br>  .. \ test_loops.c (5): (col. 4) remark: vector dependence: assumed ANTI depending on line 5 and a line 5. <br><br>  The problem here is that when performing the shift of the vector, the compiler does not know how the variables ‚Äún‚Äù and ‚Äúoffset‚Äù correlate.  To help the compiler optimize these cycles, you can use pragmas: <br><br>  8) Use #pragma ivdep before a cycle if, according to your knowledge of the cycle, there can be no dependency in it.  Using pragmas can also help in recognizing a loop. <br><br>  Another widely known case with which the compiler has no chance to deal with dependencies is the case of using vector indexing, for example: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) a[ind[i]] += b[i]; }</code> </pre><br><br>  icl -Qstd = c99 -Qvec_report2 test_loops.c -c <br>  .. \ test_loops.c (4): (col. 1) Remark: loop was not vectorized: existence of vector dependence. <br>  .. \ test_loops.c (5): (col. 3) Remark: a dependence between a line 5 and a line 5. <br>  .. \ test_loops.c (5): (col. 3) Remark: a line between a line 5 and a line 5. <br>  .. \ test_loops.c (5): (col. 3) Remark: a line between a line 5 and a line 5. <br>  .. \ test_loops.c (5): (col. 3) Remark: a dependence between a line 5 and a line 5. <br><br>  The ind array can contain duplicate values, and then there will indeed be cyclic dependencies that prevent various optimizations.  In this case, #pragma ivdep also helps the compiler. <br>  In general, there are many such cases that can be invented, but I hope that in general my thought is understandable. <br><br><h4>  Conclusion: </h4><br>  This text was written to show that the work of the optimizing compiler in many cases is determined by the need to ensure the conservative nature of the use of optimizations.  Those.  optimization can be applied only when it is possible to prove its correctness. <br>  The conservative nature of the analysis should imply the presumption that the programmer is guilty of wanting to confuse and deceive the compiler.  You can go to meet the compiler and abandon some very common features of programming languages.  Also, languages ‚Äã‚Äãprovide various software tools to provide the compiler with additional information. <br>  I would be glad if someone will share experiences on this topic. </div><p>Source: <a href="https://habr.com/ru/post/162831/">https://habr.com/ru/post/162831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162815/index.html">What languages ‚Äã‚Äãdo you localize your programs in?</a></li>
<li><a href="../162817/index.html">The photo. Art of self-expression (B. Burnbaum)</a></li>
<li><a href="../162821/index.html">Museo Cyrillic</a></li>
<li><a href="../162825/index.html">Sending notifications of missed calls from Asterisk</a></li>
<li><a href="../162827/index.html">Twitter users can now download an archive of their messages.</a></li>
<li><a href="../162833/index.html">Does MOOC have any chances in Russia?</a></li>
<li><a href="../162835/index.html">Cisco plans to sell Linksys</a></li>
<li><a href="../162837/index.html">Do you use pirated software?</a></li>
<li><a href="../162839/index.html">What is a ‚Äúbackup‚Äù?</a></li>
<li><a href="../162841/index.html">Mobile browsers and position: fixed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>