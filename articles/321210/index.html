<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classical labyrinth generation algorithms. Part 2: Immersion in Accident</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 ‚Üí First part 

 So. Having estimated the response of the Habr audience and sorting out the cases, I set about writing the second article fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classical labyrinth generation algorithms. Part 2: Immersion in Accident</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ec0/af2/8bf/ec0af28bf45241ee9de2add7bf33e87b.png"><br><br><h2>  Foreword </h2><br>  ‚Üí <a href="https://habrahabr.ru/post/320140/">First part</a> <br><br>  So.  Having estimated the response of the Habr audience and sorting out the cases, I set about writing the second article from the cycle.  The reaction of the public turned out to be much more positive than my assumptions, which means that we continue the conversation on one of the most interesting procedural generation topics - the creation of labyrinths. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this part we will talk about what a random and pseudo-random generation is, what algorithms can give us equally likely labyrinths in no way similar to each other and what are their disadvantages.  The heroes of our today's adventure will be the Wilson algorithm and the Aldous-Broder algorithm for creating a random spanning tree (Uniform Spanning Tree).  <b>CAUTION TRAFFIC</b> . <br><a name="habracut"></a><br>  Let us recall what the ideal mazes in question are.  If from each vertex of the graph to any other there is exactly one path and it is impossible to pass all the vertices without passing along the same edge twice, then we call such a graph a <b>core tree</b> .  If in the maze in question from each cell to any other there is exactly one passage and it is impossible to visit all the cells without going through the same corridor twice, then we say that such a maze is <b>perfect</b> .  The meaning does not change for one simple reason - labyrinths are graphs, as I wrote in the last article.  If you have not read it yet, I strongly advise you to scroll a little higher, follow the link and get acquainted with it before moving on. <br><br>  And although the algorithms presented in this part are very slow and ‚Äústupid‚Äù, they need to be dealt with, since they are the foundation for our entire topic and for all my articles.  The main reason why I did not immediately start with them is that Wilson is not very easy to implement and understand for beginners, which does not prevent him from being extremely curious. <br><br><div class="spoiler">  <b class="spoiler_title">Pro lua</b> <div class="spoiler_text">  In Wilson‚Äôs algorithm, and possibly in some others, which I‚Äôm going to write about, the next (table [, index]) function is used to select a random cell that has not yet been visited.  Her description from the official Lua documentation: <blockquote>  Allows the application to retrieve all fields in the table.  The first parameter is the table, the second is the index in this table.  next returns the next index in the table and the corresponding value.  If the second parameter is nil, next returns the starting index and its associated value.  When calling the last index, or with nil in an empty table, next returns nil.  If the second parameter is missing, it is interpreted as nil.  In particular, you can use next (t) to check for an empty table or not. <br></blockquote><br>  Therefore, instead of selecting a cell with math.random and checking whether it is processed or using a stack of stack cells along with a hash table to track its location, you can use only one hash table, the keys of which will be hashed coordinates and take elements from it using next. <br><br><pre><code class="lua hljs">key = <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(cellsHash, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> start_x, start_y = aux.deHashKey(key) cellsHash[key] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ‚Äî ,  <span class="hljs-literal"><span class="hljs-literal">nil</span></span>  /</code> </pre> <br></div></div><br><h2>  <b>Offset and Accident</b> </h2><br>  What do we mean by random generation?  Can we say that if in the second maze, unlike the first, there are no two walls in the south, then they are completely random?  Or if the first labyrinth has two horizontal corridors more?  Yes and no. <br><br>  Speaking of randomness in the labyrinths, we must clearly understand what we mean.  Let's look at the result of the binary tree algorithm: <br><br><img src="https://habrastorage.org/files/1f3/f7d/90f/1f3f7d90f0ee4fbba511eaf6c9042dd3.png"><br><br><img src="https://habrastorage.org/files/b33/7fd/dcc/b337fddcc18f4f6f9d1690e137c95003.png"><br><br>  As you can see, although the labyrinths themselves are completely different, their displacement is slightly different. <br><br>  Did we get a random result?  Yes.  Can we take it as such?  Well, in my opinion, no. <br><br>  The problem is bias (bias), which largely determines the "accident".  Algorithms that, by definition, should create random mazes, eventually create similar ones.  If ‚Äúsimilarity‚Äù is pronounced, as in a binary tree, we say that such a maze is easily solved.  If, when comparing several labyrinths, it is difficult to unequivocally tell us what the algorithm is about, we say that such a maze is more difficult to solve.  To find the displacement, we need to compare several generation results and build a statistical model, according to which we could write a smarter search for the path, or ‚Äúmore intelligent‚Äù to solve mazes of this type.  For example, we can say that a binary tree algorithm has n times more horizontal passes than vertical ones.  This means that it will be possible to take into account the data and speed up the process of finding the exit. <br><br>  But what if we want the offset to not exist at all?  So that, for example, 9 unrelated points of the graph, each time we get a completely different spanning tree?  Then we need each of the directions for the algorithm to be equivalent.  This means that we allow passing along the vertices already passed, therefore, in each iteration of the cycle we will randomly choose one of four directions, regardless of whether we were there or not.  The only condition - do not go beyond the field. <br><br>  Speaking of the term Uniform Spanning Tree.  We already know what a spanning tree is.  By connecting all the vertices of the graph with edges so that it is impossible to get from any vertex to another without passing the same edge twice, we get a spanning tree.  But if there are more than two vertices in the graph, then there can be more tree variations, right?  So, Uniform Spanning Tree is one equally selected variation of a spanning tree in a certain graph. <br><br>  So.  We want completely random labyrinths completely different from each other, and are even ready to sacrifice speed.  Then let's get acquainted with the Aldous-Broder and Wilson algorithms. <br><br><h2>  <b>Aldous-Brodera Algorithm</b> </h2><br><img src="https://habrastorage.org/files/ea9/699/e97/ea9699e97af847d8ae245a20212cdcf7.png"><br><br><img src="https://habrastorage.org/files/c19/bf3/0e7/c19bf30e7b8341ee817b014c559e7fe2.png"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/084/f65/5b4/084f655b45044098919550948e35f60a.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9f7/838/76a/9f783876affb4a24ba271affe8a3e3ab.gif"></div><br><br>  <b>Description</b> <br><br>  Remember I said that the binary tree algorithm is the easiest to understand?  So, I'm cunning.  It is really simpler to implement, since there we always deal with only one direction and one considered row, but the Aldous-Broder algorithm went far ahead in primitiveness and ‚Äústupidity‚Äù.  Its whole meaning is to wander aimlessly around the field, hoping to stumble upon the top of the spanning tree being created and attach another, and then again randomly select a point in the maze and walk until we get into one of the connected ones. <br><br>  Aldous-Broder is free from any bias.  Perfectly.  All the labyrinths obtained with its help are completely random and not similar to each other.  The algorithm has no preferences for focus, entanglement, or any other characteristics.  The resulting labyrinths are random and equiprobable. <br><br>  The problem may be the imperfection of random number generators, which themselves can cause any values ‚Äã‚Äãand produce them more often.  But if you use, for example, a randomness generator based on natural noise (wind, decay of uranium), then, perhaps, you can finally fully enjoy the work of the algorithm. <br><br>  Admittedly, the observation of his work truly gives an awareness of all the perishability and meaninglessness of being.  To write a gif with his animation, I spent a lot of time, because I didn‚Äôt want to keep within 30 seconds in a 5 √ó 5 field.  When it was necessary to connect only one last unchecked cell to the spanning tree, Aldous-Broder would go to another corner and wind circles there.  It was necessary to significantly increase the speed of animation and reduce the field, so that, finally, he managed to bypass all the cells of the maze. <br><br>  It was created by two independent researchers who studied equally probable variants of spanning trees: David Aldous, a professor at the University of California, Berkeley, and Andrei Broder, a scientist who now works at Google.  It is difficult to say unequivocally in which area these studies would be useful.  However, besides labyrinths, the algorithm often emerges in works on mathematical probability, which, however, is not surprising, given the principle of its operation. <br><br>  <b>Formal algorithm:</b> <br><br><ol><li>  Select a random vertex (cell).  Absolutely random; </li><li>  Select a random adjacent vertex (cell) and go into it.  If it has not been visited, add it to the tree (connect with the previous one, remove the wall between them); </li><li>  Repeat step 2 until all cells are visited. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Work example</b> <div class="spoiler_text">  The red color highlights our current position on the field. <br><br>  Starting from the upper left corner.  There is nothing unusual. <br><br><img src="https://habrastorage.org/files/a1a/ac3/20f/a1aac320f9824b96b2af0ec8bc804cfe.png"><br><br>  Randomly decide to go to the right and remove the wall between the two cells.  Good, we do. <br><br><img src="https://habrastorage.org/files/e2b/91e/0cb/e2b91e0cb28f48cba245c224b68ca9b6.png"><br><br>  Bad luck.  Our RNG tells us to go back, that is, to the left. <br><br><img src="https://habrastorage.org/files/ce7/d98/8bf/ce7d988bf95f44c4b875cb039a457ca1.png"><br><br>  And now down.  Along the way, we connect all the unvisited cells and remove walls between them. <br><br><img src="https://habrastorage.org/files/a2e/fc2/173/a2efc2173bf54fda8c62a6f74d93e2d6.png"><br><br>  Once again lucky.  Way down! <br><br><img src="https://habrastorage.org/files/886/d7e/e2c/886d7ee2c3da4cc4866d421c3013a979.png"><br><br>  Okay, one return can be forgiven. <br><img src="https://habrastorage.org/files/c44/fd5/1ed/c44fd51ed98d41ae9c575587cb616499.png"><br><br>  We choose to go to the right and remove the wall. <br><br><img src="https://habrastorage.org/files/5e3/04f/738/5e304f7388114a0385be2f12f3b8a804.png"><br><br>  And here we are twice unlucky and we return to the very beginning. <br><br><img src="https://habrastorage.org/files/366/646/a0b/366646a0b1e14b17ab1be1cec4591ef1.png"><br><img src="https://habrastorage.org/files/748/9e9/350/7489e9350cae4a57baa4fe49cde97976.png"><br><br>  The choice fell twice to the right.  Great, at least some variety. <br><br><img src="https://habrastorage.org/files/28c/189/5af/28c1895afb1f4ec2a5fb2fc9c3ee1610.png"><br><img src="https://habrastorage.org/files/e5c/d40/beb/e5cd40beb32340a6a2e458efbc5d7ace.png"><br><br>  Go down below and remove the wall. <br><br><img src="https://habrastorage.org/files/70f/8a2/10c/70f8a210c6864405ac08f50d1bdc8c48.png"><br><br>  And here, although we are moving to the next cell, we don‚Äôt remove the wall, since they are already in the same tree. <br><br><img src="https://habrastorage.org/files/746/a79/2f8/746a792f8bbb45ef8ccfee413d222822.png"><br><br>  It's time to wander aimlessly, walk. <br><br><img src="https://habrastorage.org/files/f57/ca6/689/f57ca668915746308daa59fbfd7d48ee.png"><br><img src="https://habrastorage.org/files/ff2/eca/cef/ff2ecacef0e040e496a2f0db7bc55208.png"><br><img src="https://habrastorage.org/files/177/3c7/97e/1773c797ebd14de9afe28e671186e2c7.png"><br><img src="https://habrastorage.org/files/89b/e58/dbe/89be58dbe89f447cadda9f2570176278.png"><br><br>  We return to the cage 2-2 and descend below, removing the wall. <br><br><img src="https://habrastorage.org/files/0a6/e21/5ce/0a6e215ce75f461eb0cd9533d5c0534a.png"><br><br>  We finish our walk and get the generated maze. <br><br><img src="https://habrastorage.org/files/b01/d21/0a4/b01d210a432e4ef791649d70f4d08fc4.png"><br></div></div><br>  <b>Pros:</b> <br><br><ul><li>  There is no offset; </li><li>  Labyrinths are absolutely random, so it is impossible to create a specific algorithm for solving them; </li><li>  The complexity of the solution for the person; </li><li>  Simple implementation; </li></ul><br>  <b>Minuses:</b> <br><br><ul><li>  Speed.  While the maze is generated, you will have time to grow old and die; </li><li>  Does not allow to generate endless labyrinths; </li><li>  A strong drop in efficiency at the end of generation; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> aux = {} aux.width = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.height = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sx = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sy = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.dirs = {<span class="hljs-string"><span class="hljs-string">"UP"</span></span>, <span class="hljs-string"><span class="hljs-string">"DOWN"</span></span>, <span class="hljs-string"><span class="hljs-string">"LEFT"</span></span>, <span class="hljs-string"><span class="hljs-string">"RIGHT"</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.createGrid</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, columns)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> MazeGrid = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>, rows <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y] = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, columns <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y][x] = {visited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, bottom_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, right_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MazeGrid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mod.createMaze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x1, y1, x2, y2, grid)</span></span></span></span> aux.width, aux.height, aux.sx, aux.sy = x2, y2, x1, y1 aux.grid = grid <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> aux.createGrid(y2, x2) aux.aldous_broder() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aux.grid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.aldous_broder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> unvisited_cells = aux.width * aux.height <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ix = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(aux.sx, aux.width) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> iy = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(aux.sy, aux.height) aux.grid[iy][ix].visited = <span class="hljs-literal"><span class="hljs-literal">true</span></span> unvisited_cells = unvisited_cells - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> unvisited_cells ~= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dir = aux.dirs[<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dir == <span class="hljs-string"><span class="hljs-string">"UP"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> iy<span class="hljs-number"><span class="hljs-number">-1</span></span> &gt;= aux.sy <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aux.grid[iy<span class="hljs-number"><span class="hljs-number">-1</span></span>][ix].visited == <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> aux.grid[iy<span class="hljs-number"><span class="hljs-number">-1</span></span>][ix].bottom_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid[iy<span class="hljs-number"><span class="hljs-number">-1</span></span>][ix].visited = <span class="hljs-literal"><span class="hljs-literal">true</span></span> unvisited_cells = unvisited_cells - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> iy = iy<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> dir == <span class="hljs-string"><span class="hljs-string">"DOWN"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> iy+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= aux.height <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aux.grid[iy+<span class="hljs-number"><span class="hljs-number">1</span></span>][ix].visited == <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> aux.grid[iy][ix].bottom_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid[iy+<span class="hljs-number"><span class="hljs-number">1</span></span>][ix].visited = <span class="hljs-literal"><span class="hljs-literal">true</span></span> unvisited_cells = unvisited_cells - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> iy = iy+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> dir == <span class="hljs-string"><span class="hljs-string">"RIGHT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ix+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= aux.width <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aux.grid[iy][ix+<span class="hljs-number"><span class="hljs-number">1</span></span>].visited == <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> aux.grid[iy][ix].right_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid[iy][ix+<span class="hljs-number"><span class="hljs-number">1</span></span>].visited = <span class="hljs-literal"><span class="hljs-literal">true</span></span> unvisited_cells = unvisited_cells - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ix = ix+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> dir == <span class="hljs-string"><span class="hljs-string">"LEFT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ix<span class="hljs-number"><span class="hljs-number">-1</span></span> &gt;= aux.sx <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aux.grid[iy][ix<span class="hljs-number"><span class="hljs-number">-1</span></span>].visited == <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> aux.grid[iy][ix<span class="hljs-number"><span class="hljs-number">-1</span></span>].right_wall = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid[iy][ix<span class="hljs-number"><span class="hljs-number">-1</span></span>].visited = <span class="hljs-literal"><span class="hljs-literal">true</span></span> unvisited_cells = unvisited_cells - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ix = ix<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre><br></div></div><br><h2>  <b>Wilson's algorithm</b> </h2><br><img src="https://habrastorage.org/files/fe2/112/aba/fe2112abacea4afda1fac350bfcfd689.png"><br><br><img src="https://habrastorage.org/files/45f/26f/d10/45f26fd105dd4306a844d8a1146fecd8.png"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fc9/db9/9b6/fc9db99b62154bfb995b6489e342caed.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/198/51d/a13/19851da13b5f42518e8fde188c816df5.gif"></div><br>  <b>Description</b> <br><br>  Congratulations, we finally got to something more serious.  Wilson's algorithm is much more complicated than all the previous ones, both in implementation and in understanding.  The goal of Wilson, like his more stupid partner Aldous-Broder, is the generation of an equally probable random spanning tree.  And although the principle of work is somewhat similar, the details are very different. <br><br>  The algorithm is still based on the equally probable random selection of the side of movement in the maze (graph), with two important differences: <br><br>  Moving across the field, we ‚Äúmemorize‚Äù all the vertices that we visited until the vertex of the spanning tree was found.  As soon as we stumble upon an already added vertex, we add the resulting subgraph (branch) to our generated tree.  If a loop is created in a subgraph, then delete it.  By a cycle, I mean connecting a vertex that is already in a temporary subgraph with it, but at a different point.  In other words, there should not be vertices with more than 2 edges.  If you don‚Äôt understand now, it‚Äôs not scary - then you‚Äôll see it through the example of work. <br><br>  After the subgraph is attached to the spanning tree, the choice of the next random point comes exclusively from the not yet connected vertices.  Consequently, unlike Aldous-Brodera, Wilson is deprived of the disadvantage of aimless wandering around the already processed vertices. <br><br>  Wilson‚Äôs algorithm, like Aldos-Broder, generates completely random mazes without any bias.  The algorithm has no preferences for focus, entanglement, or any other characteristics.  Unfortunately, to obtain the best results, you should use hardware random number generators that do not have preferences in numbers. <br><br>  The algorithm itself was published by David Wilson in 1996 in his work on the generation of equally probable random spanning trees.  As before, in addition to labyrinths, materials pop up on various websites devoted to mathematical probabilities.  Moreover, I happened to stumble upon several interesting publications, concerning the Uniform Spanning Tree and the Wilson algorithm in particular.  If in one of them the algorithm itself is described more, in the other as a whole the concept itself and the mathematical basis of the spanning trees are described. <br><br>  If readers are interested, perhaps I will write part 2a, where I will give the works themselves and their partial translation.  The main reason why I avoid the mathematical justification here is my articles are aimed at beginners and people who find programming more interesting than dry math. <br><br>  <b>Formal algorithm:</b> <br><br><ol><li>  Select a random vertex not belonging to the spanning tree and add it to the tree; </li><li>  Select a random vertex that does not belong to the spanning tree and start traversing the graph (labyrinth) until we arrive at the already added vertex of the tree;  If a cycle is formed, delete it; </li><li>  Add all vertices of the resulting subgraph to the spanning tree; </li><li>  Repeat steps 2-3 until all vertices are added to the spanning tree. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Work example</b> <div class="spoiler_text">  Green highlights the first top of the tree.  Red - created branch (subgraph). <br><br>  Traditionally, you need to get to the upper left corner.  We start to build a branch with a 3-2 coordinate. <br><br><img src="https://habrastorage.org/files/c32/4b8/deb/c324b8deba6f4996ab3866c51bd5841d.png"><br><img src="https://habrastorage.org/files/5aa/6ed/046/5aa6ed046a904094b02e77299de117a6.png"><br><img src="https://habrastorage.org/files/e9c/8e6/46a/e9c8e646af564a42bbb391fbe263044b.png"><br><img src="https://habrastorage.org/files/9d0/aa3/572/9d0aa3572d9d4ebc9483ebe54d7ed78f.png"><br><br>  Here is an interesting and important point.  The algorithm decides to go up, thereby closing the branch in the coordinate 2-2. <br><br><img src="https://habrastorage.org/files/6e2/91e/72f/6e291e72f05d4efd93f4e063d257ab16.png"><br><br>  Remove the resulting cycle and start with a 2-2 build again. <br><br><img src="https://habrastorage.org/files/464/2ff/fbf/4642fffbf13a4d0382012f42b4ba3875.png"><br>  <a href="">habrastorage.org/files/e9c/8e6/46a/e9c8e646af564a42bbb391fbe263044b.png</a> <br><br>  Well, the algorithm decided to go upstairs and thus joined the main tree.  We remove the walls on the way and select the next cell. <br><br><img src="https://habrastorage.org/files/cd8/bd5/8fb/cd8bd58fbd6846d1aae7ae15c1bf1c09.png"><br><img src="https://habrastorage.org/files/e6d/4ca/3a2/e6d4ca3a24e2461584be977381686509.png"><br><br>  Again, we touched a newly created tree, removed the walls and started anew. <br><br><img src="https://habrastorage.org/files/426/1dc/57b/4261dc57b9084c1dbeb905097579ceb7.png"><br><img src="https://habrastorage.org/files/04e/a12/a6f/04ea12a6f46746faa4813364e4c971b1.png"><br><img src="https://habrastorage.org/files/c63/519/345/c635193455cc466093e603659759686e.png"><br><img src="https://habrastorage.org/files/d9e/76e/1a0/d9e76e1a00c54539bb8899abd02d2e97.png"><br><br>  Locked, removed the cycle, continued with 2-3 again. <br><br><img src="https://habrastorage.org/files/77e/482/644/77e48264497e4585a9b1952193e091c2.png"><br><br>  Joined with a tree, cleared the way from the walls.  We continued our journey in a new cage. <br><br><img src="https://habrastorage.org/files/d47/ea0/f88/d47ea0f88e2844a6b36bd675c6f0c455.png"><br><img src="https://habrastorage.org/files/c6a/96e/39f/c6a96e39f6404038b4b11d3abd0f64d6.png"><br><img src="https://habrastorage.org/files/447/f45/059/447f45059d6c47b1934ed29ae8cd571d.png"><br><br>  Again connected with the main tree, removed the walls, finished the labyrinth. <br><br><img src="https://habrastorage.org/files/cbb/b04/de6/cbbb04de6f1846159b398eb68c8ead9c.png"><br></div></div><br>  <b>Pros:</b> <br><br><ul><li>  There is no offset; </li><li>  Labyrinths are absolutely random, so it is impossible to create a specific algorithm for solving them; </li><li>  The complexity of the solution for the person; </li><li>  No pointless wandering; </li><li>  The speed compared with Aldous-Broder many times more; </li></ul><br>  <b>Minuses:</b> <br><br><ul><li>  Difficult implementation; </li><li>  Speed ‚Äã‚Äãdrops at the beginning of generation; </li><li>  Greater memory requirements than Aldous-Broder; </li></ul><br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> aux = {} aux.width = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.height = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sx = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.sy = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.grid = <span class="hljs-literal"><span class="hljs-literal">false</span></span> aux.dirs = {<span class="hljs-string"><span class="hljs-string">"UP"</span></span>, <span class="hljs-string"><span class="hljs-string">"DOWN"</span></span>, <span class="hljs-string"><span class="hljs-string">"LEFT"</span></span>, <span class="hljs-string"><span class="hljs-string">"RIGHT"</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.createGrid</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, columns)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> MazeGrid = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y = <span class="hljs-number"><span class="hljs-number">1</span></span>, rows <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y] = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, columns <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> MazeGrid[y][x] = {visited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, bottom_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, right_wall = <span class="hljs-literal"><span class="hljs-literal">true</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MazeGrid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mod.createMaze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x1, y1, x2, y2, grid)</span></span></span></span> aux.width, aux.height, aux.sx, aux.sy = x2, y2, x1, y1 aux.grid = grid <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> aux.createGrid(y2, x2) aux.wilson() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aux.grid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.hashKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * aux.height + (y - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.deHashKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(value/aux.height), value%aux.height + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.hashCells</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> vtable = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> yk, yv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(grid) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> xk, xv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(yv) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xv.visited == <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vtable[aux.hashKey(xk, yk)] = xv <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vtable <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux.wilson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> cellsHash = aux.hashCells(aux.grid) <span class="hljs-comment"><span class="hljs-comment">-- ,     local dirsStack = {} --   local dsHash = {} local dsSize = 0 --   local key, v = next(cellsHash, nil) v.visited = true cellsHash[key] = nil while next(cellsHash) do --    ,  key = next(cellsHash, nil) --        local start_x, start_y = aux.deHashKey(key) local ix, iy = start_x, start_y while not aux.grid[iy][ix].visited do -- ,        local dir = aux.dirs[math.random(1, 4)] local isMoved = false key = aux.hashKey(ix, iy) if dir == "UP" and iy-1 &gt;= aux.sy then iy = iy - 1 isMoved = true elseif dir == "DOWN" and iy+1 &lt;= aux.height then iy = iy + 1 isMoved = true elseif dir == "LEFT" and ix-1 &gt;= aux.sx then ix = ix - 1 isMoved = true elseif dir == "RIGHT" and ix+1 &lt;= aux.width then ix = ix + 1 isMoved = true end if isMoved then --    ,     if dsHash[key] then --   dirsStack[dsHash[key]].dir = dir for i = dsHash[key]+1, dsSize do local x, y = aux.deHashKey(dirsStack[i].hashref) dsHash[dirsStack[i].hashref] = nil dirsStack[i] = nil dsSize = dsSize - 1 end else local x, y = aux.deHashKey(key) --     dsSize = dsSize + 1 dsHash[key] = dsSize dirsStack[dsSize] = {dir = dir, hashref = key} end end end for i = 1, dsSize do --   aux.grid[start_y][start_x].visited = true cellsHash[aux.hashKey(start_x, start_y)] = nil aux.grid[start_y][start_x].point = false local dir = dirsStack[i].dir if dir == "UP" then aux.grid[start_y-1][start_x].bottom_wall = false start_y = start_y - 1 elseif dir == "DOWN" then aux.grid[start_y][start_x].bottom_wall = false start_y = start_y + 1 elseif dir == "LEFT" then aux.grid[start_y][start_x-1].right_wall = false start_x = start_x - 1 elseif dir == "RIGHT" then aux.grid[start_y][start_x].right_wall = false start_x = start_x + 1 end end dsHash, dirsStack, dsSize = {}, {}, 0 --    end end return mod</span></span></code> </pre><br></div></div><br><h2>  <b>Epilogue:</b> </h2><br>  Summing up all the above, it is worth noting that although we got to more complex algorithms and dealt with some new (for someone) graph concepts, the main difficulties are still ahead.  The unclearly convoluted algorithms of Eller, Kraskal and Prima, based solely on working with graphs and trees, provide us with difficult, if interesting, publications.  However, before you start writing them, you should look at the search algorithms with the return and something called "Catch &amp; Kill", whose work on the generation of the maze is very different from all the others.  I gave a hint on the topic of the next article. <br><br>  What else.  In the comments to the previous part, some people asked or threw off their generation algorithms, which was extremely entertaining and joyful.  If you once realized the creation of labyrinths in your own invented way and can now remember it - please share.  Perhaps, with your permission, in any of the articles I will write about him.  In general, I am glad to any interesting stories and memories on the subject.  It doesn‚Äôt matter if you remember how you drew mazes in a tetrad at school or on a computer at a university. <br><br>  Well, and as always.  Wishes, criticism, comments are always welcome and if you like the topic and want to see the next part, write about it in the comments. <br><br>  Sources of algorithms on Lua + render on Love2D (the code is laid out at the request in the comments. Did not react): <br>  <a href="https://github.com/RussDragon/Love2D-Mazes">Github</a> </div><p>Source: <a href="https://habr.com/ru/post/321210/">https://habr.com/ru/post/321210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321196/index.html">Cloud Bottlenecks: Pokemon Go and Trivia Crack Stories</a></li>
<li><a href="../321198/index.html">GameBoy Advance game protection against emulation</a></li>
<li><a href="../321202/index.html">The processor, it is a chipset, it is a chip, it is a platform, it is a system on a chip or what to pay attention to when choosing</a></li>
<li><a href="../321206/index.html">Analysis of Habrahabr and Geektimes articles</a></li>
<li><a href="../321208/index.html">Remote connection to the CodeMeter network key for ARCHICAD</a></li>
<li><a href="../321212/index.html">Study of the qualitative features of the dynamics of mathematical models of nonlinear nonautonomous systems</a></li>
<li><a href="../321214/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ248 (January 30 - February 5, 2017)</a></li>
<li><a href="../321216/index.html">Interesting clustering algorithms, part one: Affinity propagation</a></li>
<li><a href="../321220/index.html">A note on how to debug locks in the Linux kernel</a></li>
<li><a href="../321222/index.html">Unique users are not truly unique users.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>