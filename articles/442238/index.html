<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The use of smart accounts Waves. Part 1: from auctions to bonus programs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain is often associated only with cryptocurrencies, but the scope of the DLT technology is much wider. One of the most promising areas for the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The use of smart accounts Waves. Part 1: from auctions to bonus programs</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/pi/sa/8g/pisa8gy_wbapc-kdf-n026wjuko.png" alt="image"><br><br>  <i>Blockchain is often associated only with cryptocurrencies, but the scope of the DLT technology is much wider.</i>  <i>One of the most promising areas for the use of the blockchain is a smart contract that runs automatically and does not require trust between the parties who have concluded it.</i> <i><br></i> <br>  <b>RIDE - language for smart contracts</b> <br><br>  Waves has developed a special language for smart contracts - RIDE.  His complete documentation is <a href="https://docs.wavesplatform.com/en/technical-details/waves-contracts-language-description.html">here</a> .  And here - <a href="https://habr.com/post/424111/">article on this subject</a> on Habr√©. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The RIDE contract is a predicate and returns ‚Äútrue‚Äù or ‚Äúfalse‚Äù at the output.  Accordingly, the transaction is either recorded in the blockchain, or rejected.  Smart contract fully guarantees the fulfillment of specified conditions.  The generation of transactions from the contract in RIDE is currently not possible. <br><a name="habracut"></a><br>  Today, there are two types of Waves smart contracts: smart accounts and smart assets.  A smart account is a regular user account, but a script is set up for it that controls all transactions.  A smart account script might look like this: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  tx is a processed transaction that we allow using the pattern-matching mechanism only if it is not a transfer transaction.  Pattern matching in RIDE is used to check the type of transaction.  In a script of a smart account all existing <a href="https://docs.wavesplatform.com/en/technical-details/transactions-structure.html">types of transactions</a> can be processed. <br><br>  Also, variables can be declared in the script, if-then-else constructions and other methods of full-fledged condition checking are used.  In order for contracts to have provable completability and complexity (cost), which is easy to predict before commencing contract execution, RIDE does not contain loops and jump type operators. <br><br>  Other features of Waves accounts include the presence of a ‚Äústate,‚Äù that is, account status.  In the state account you can write an infinite number of pairs (key, value) using the date-transaction (DataTransaction).  Further this information can be processed both through the REST API and directly in the smart contract. <br><br>  Each transaction can contain an array of proofs in which you can enter the participant‚Äôs signature, the ID of the transaction, etc. <br><br>  Working with RIDE through <a href="https://ide.wavesplatform.com/">IDE</a> allows you to see the compiled type of the contract (if it is compiled), create new accounts and set scripts for it, as well as send transactions via the command line. <br><br>  For a full cycle, including creating an account, installing a smart contract on it, and sending transactions, you can also use the library to interact with the REST API (for example, C #, C, Java, JavaScript, Python, Rust, Elixir).  To start working with IDE, just press the NEW button. <br><br>  The possibilities of applying smart contracts are wide: from banning transactions to specific addresses (‚Äúblacklist‚Äù) to complex dApps. <br><br>  <i>Now let's look at specific examples of the application of smart contracts in business: during auctions, insurance and creating loyalty programs.</i> <i><br></i> <br>  <b>Auctions</b> <br><br>  One of the conditions for a successful auction is transparency: participants must be sure that bidding is not possible.  This can be achieved thanks to the blockchain, where the constant data on all bets and the time when they were made will be available to all participants. <br><br>  On the Waves blockchain, bids can be recorded in the state of an auction account via DataTransaction. <br><br>  You can also set the start and end time of the auction using block numbers: the frequency of block generation in the Waves blockchain is approximately <b>60</b> seconds. <br><br>  <i><b>1. English auction of the rising price</b></i> <br><br>  Participants in the English auction make bids, competing with each other.  Each new rate must exceed the previous one.  The auction ends when there is no longer anyone willing to exceed the last bid.  In this case, the participant who made the highest bid must provide the stated amount. <br><br>  There is also an auction option in which the seller sets the minimum price for the lot, and the final price must exceed it.  Otherwise, the lot remains unsold. <br><br>  In this example, we are working with an account specially created for the auction.  The duration of the auction is 3000 blocks, and the initial price of the lot is 0.001 WAVES.  A participant can make a bid by sending DataTransaction with the key ‚Äúprice‚Äù and the value of its bid. <br><br>  The price of a new rate must be higher than the current price of this key, and the participant must have at least [new_bid + commission] tokens on the account.  The participant's address must be recorded in the ‚Äúsender‚Äù field in DataTransaction, and the current height of the bid block must be within the bounds of the auction period. <br><br>  If at the end of the auction the participant assigned the highest price, he can send ExchangeTransaction to pay for the corresponding lot at the specified price and currency pair. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #,      let currentPrice = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #    then extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startPrice #    let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) let priceIsBigger = newPrice &gt; currentPrice let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(tx.sender) + fee &gt;= newPrice #,               let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; d.sender == addressFromString(extract(getString(d.data,<span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; priceIsBigger &amp;&amp; hasMoney &amp;&amp; correctFields <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let senderIsWinner = e.sender == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,    ,    let correctAssetPair = e.sellOrder.assetPair.amountAsset == token &amp;&amp; ! isDefined(e.sellOrder.assetPair.priceAsset) let correctAmount = e.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = e.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i><b>2. Dutch auction of the falling price</b></i> <br><br>  At the Dutch auction, the lot is initially offered at a price higher than the one that the buyer is willing to pay.  The price decreases step by step until one of the participants agrees to buy a lot at the current price. <br><br>  In this example, we use the same constants as in the previous one, as well as the price step while decreasing delta.  The account script checks if the participant is the first to place a bet.  Otherwise, DataTransaction is not accepted by the blockchain. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000000</span></span> let delta = <span class="hljs-number"><span class="hljs-number">100</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let currentPrice = startPrice - delta * (height - startHeight) #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,         <span class="hljs-string"><span class="hljs-string">"sender"</span></span> let noBetsBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(tx.sender) + fee &gt;= newPrice #,        let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; newPrice == currentPrice &amp;&amp; d.sender == addressFromString(extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; noBetsBefore &amp;&amp; hasMoney &amp;&amp; correctFields <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; #,           sender let senderIsWinner = e.sender == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,  mount   ,   - - waves let correctAssetPair = e.sellOrder.assetPair.amountAsset == token &amp;&amp; ! isDefined(e.sellOrder.assetPair.priceAsset) let correctAmount = e.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = e.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i><b>3. Auction "all-pay"</b></i> <br><br>  ‚ÄúAll-pay‚Äù - an auction, all participants of which pay the bid, pay, regardless of who wins the lot.  Each new participant pays a bet, and the participant who makes the maximum bet wins the lot. <br><br>  In our example, each auction participant makes a bid via DataTransaction with (key, value) * = ("winner", address), ("price", price).  Such DataTransaction is approved only if for this participant there is already a TransferTransaction with its signature and its rate is higher than all previous ones.  The auction continues until reaching the height endHeight. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let endHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #        let proofTx = extract(transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>])) height &gt; startHeight &amp;&amp; height &lt; endHeight &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> #,   ,    ,   ,    &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String(address.bytes) &amp;&amp; newPrice &gt; extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,    &amp;&amp; sigVerify(d.bodyBytes, d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) #  ,    &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> proofTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tr : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; tr.sender == address &amp;&amp; tr.amount == newPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) || ( height &gt; endHeight &amp;&amp; extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String((addressFromRecipient(t.recipient)).bytes) &amp;&amp; t.assetId == token &amp;&amp; t.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Insurance / Crowdfunding</b> <br><br>  Consider the situation when you need to insure user assets from financial losses.  For example, the user wants to get a guarantee that in the event of a token depreciation, he will be able to return the full amount paid for these tokens, and is willing to pay a reasonable amount of insurance. <br><br>  To do this, you need to issue "insurance tokens."  Then a script is installed on the policyholder‚Äôs account, which allows to execute only those ExchangeTransactions that meet certain conditions. <br><br>  To prevent double waste, you need to request the user to send the DataTransaction in advance to the insurer's account with (key, value) = (purchaseTransactionId, sellOrderId) and prohibit sending the DataTransactions with the key already used. <br><br>  Therefore, the user proofs must contain the transaction ID of the insurance token purchase.  The currency pair must be the same as in the purchase transaction.  The cost should also be equal to the one fixed at the time of purchase, minus the price of insurance. <br><br>  It is implied that subsequently the insurance account buys insurance tokens from the user at a price not lower than the one for which he acquired them: the insurance account creates Exchange Transaction, the user signs the order (if the transaction is correct), the insurance account signs the second order and the entire transaction and sends it to the blockchain . <br><br>  If the purchase does not occur, the user can create ExchangeTransaction in accordance with the rules described in the script, and send the transaction to the blockchain.  So the user can return the money spent on the purchase of insured tokens. <br><br><pre> <code class="scala hljs">let insuranceToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let freezePeriod = <span class="hljs-number"><span class="hljs-number">150000</span></span> let insurancePrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sellOrder.sender let correctAssetPair = e.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; purchase.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; e.sellOrder.assetPair.priceAsset == purchase.sellOrder.assetPair.priceAsset let correctPrice = e.price == purchase.price - insurancePrice &amp;&amp; e.amount == purchase.amount let correctHeight = height &gt; purchaseTxHeight + freezePeriod #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.sellOrder.id correctSender &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; correctHeight &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  An insurance token can be made a smart asset - for example, to prohibit its transfer to third parties. <br><br>  This scheme can also be implemented for crowdfunding tokens, which are returned to the owners if the required amount has not been collected. <br><br>  <b>Transaction taxes</b> <br><br>  Smart contracts are also applicable in cases when it is necessary to collect tax from each transaction with several types of assets.  This can be done through a new asset with established <a href="https://docs.wavesplatform.com/en/proposals/sponsored-transactions.html">sponsorship</a> for transactions with smart Assets: <br><br>  1. We release FeeCoin, which will be sent to users at a fixed price: 0.01 WAVES = 0.001 FeeCoin. <br><br>  2. Set the sponsorship for FeeCoin and the exchange rate: 0.001 WAVES = 0.001 FeeCoin. <br><br>  3. Set the following script for smart asset: <br><br><pre> <code class="scala hljs">let feeAssetId = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.feeAssetId == feeAssetId &amp;&amp; t.fee == t.amount / taxDivisor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Now every time someone transfers N smart assets, he will give you FeeCoin in the amount of N / taxDivisor (which can be bought from you at 10 * N / taxDivisor WAVES), and you will give to the Miner N / taxDivisor WAVES.  As a result, your profit (tax) will be 9 * N / taxDivisor WAVES. <br><br>  You can also tax using the smart asset script and MassTransferTransaction: <br><br><pre> <code class="scala hljs">let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t : <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; let twoTransfers = size(t.transfers) == <span class="hljs-number"><span class="hljs-number">2</span></span> let issuerIsRecipient = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].recipient == addressFromString(<span class="hljs-string"><span class="hljs-string">"3MgkTXzD72BTfYpd9UW42wdqTVg8HqnXEfc"</span></span>) let taxesPaid = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].amount &gt;= t.transfers[<span class="hljs-number"><span class="hljs-number">1</span></span>].amount / taxDivisor twoTransfers &amp;&amp; issuerIsRecipient &amp;&amp; taxesPaid <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Cashback and loyalty programs</b> <br><br>  Cashback is a type of loyalty program in which a portion of the amount spent on a product or service is returned to the customer. <br><br>  When implementing this case using a smart account, we must check the proofs just as we did in the insurance case.  To prevent double waste, the user must send a DataTransaction with (key, value) = (purchaseTransactionId, cashbackTransactionId) before receiving a cashback. <br><br>  We must also prohibit existing keys using DataTransaction.  cashbackDivisor is a unit divided by a cashback share.  Those.  if the share of cashback is 0.1, then cashback Divisor 1 / 0.1 = 10. <br><br><pre> <code class="scala hljs">let cashbackToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let cashbackDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sender let correctAsset = e.assetId == cashbackToken let correctPrice = e.amount == purchase.amount / cashbackDivisor #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Atomic swap</b> <br><br>  Atomic swap allows users to exchange assets without the help of the exchange.  In an atomic swap, both parties to the transaction are required to confirm it within a certain period of time. <br><br>  If at least one of the participants does not provide a correct confirmation of the transaction within the time allotted for the transaction, the transaction is canceled and no exchange takes place. <br><br>  In our example, we will use the following smart account script: <br><br><pre> <code class="scala hljs">let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') let beforeHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let secret = base58<span class="hljs-symbol"><span class="hljs-symbol">'BN6RTYGWcwektQfSFzH8raYo9awaLgQ7pLyWLQY4S4F</span></span>5' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let txToBob = t.recipient == <span class="hljs-type"><span class="hljs-type">Bob</span></span> &amp;&amp; sha256(t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == secret &amp;&amp; <span class="hljs-number"><span class="hljs-number">20</span></span> + beforeHeight &gt;= height let backToAliceAfterHeight = height &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> + beforeHeight &amp;&amp; t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span> txToBob || backToAliceAfterHeight <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i>In the next article, we will look at the use of smart accounts in financial instruments such as options, futures, and bills of exchange.</i> </div><p>Source: <a href="https://habr.com/ru/post/442238/">https://habr.com/ru/post/442238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442224/index.html">Bad advice: how to write technical documentation? Part two</a></li>
<li><a href="../442226/index.html">This is not available in your country: news that you can not find out from Russia</a></li>
<li><a href="../442230/index.html">Which of the developers living in the same city earns more: working remotely or in the office?</a></li>
<li><a href="../442232/index.html">Alternate Slf4j Logger "Reel"</a></li>
<li><a href="../442234/index.html">The colony. Epilogue</a></li>
<li><a href="../442242/index.html">Immediate news: the largest solar cell plant in the Western Hemisphere has begun work</a></li>
<li><a href="../442244/index.html">Rust 1.33 release</a></li>
<li><a href="../442248/index.html">NASA gave the go-ahead to the Dragon-2 unmanned test launch</a></li>
<li><a href="../442250/index.html">React and Vue: Strengths</a></li>
<li><a href="../442252/index.html">Python code life cycle - CPython execution model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>