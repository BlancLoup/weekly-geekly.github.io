<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How 3D robot scans</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many 3D scanning technologies in the world. On the basis of each of them created dozens of scanner models. Some scanners can scan only small...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How 3D robot scans</h1><div class="post__text post__text-html js-mediator-article">  There are many 3D scanning technologies in the world.  On the basis of each of them created dozens of scanner models.  Some scanners can scan only small objects, some are designed to scan people.  Others can scan a house or room.  The mere enumeration of various variations of scanners would take an entire article. <br>  In this article I will talk about one of the promising areas of scanning - about how robotic 3D scanners are made. <br><img width="650" src="https://habrastorage.org/files/9aa/3c4/a0f/9aa3c4a0ff8e479c8a1020357b5b2802.jpg"><br><a name="habracut"></a><br><br><h2>  Why do you need it? </h2><br>  <a href="https://www.artec3d.com/ru">3D scanning of an</a> object is not an instant process.  It requires a person to make a constant analysis of the current situation and, depending on the results, the adjustment of their actions.  Scanning large objects may take some time. <br>  Examples can be found <a href="http://www.youtube.com/watch%3Fv%3DYe_ORnuOwWU">here</a> and <a href="https://www.youtube.com/watch%3Fv%3DlBS1xOV0VHQ">here</a> . <br>  If you need to scan a lot of objects (for example, to solve the problem of quality control or to digitize the assortment of a store), then the best way is to rid yourself of the routine and use a robot.  Maybe this does not greatly accelerate the process, but it makes the result stable, repeatable and eliminates the operator from physical labor. <br>  <s>(Actually, the main argument is of course: because it‚Äôs cool! Human-like robots and everything!)</s> <br><img width="700" src="https://habrastorage.org/files/cf2/471/791/cf247179170544128815c15aa1be8fca.jpg"><br><br><h2>  The main difference and complexity of the process </h2><br>  When a person scans, he sees everything: what is scanned is bad, what is not to the end, where there is a hole in the scanned object.  The eyes are an independent scanner that allows you to check the quality of the incoming data and say ‚ÄúAHA!  Here you haven't watched! ‚Äù  But when the robot scans, such decisions must be made by him.  And the only information for making such decisions is the data obtained from the scanner.  And the data often looks like this: <br><img width="700" src="https://habrastorage.org/files/2d8/9e3/4c2/2d89e34c23a24a97810f036e842d1c1e.jpg"><br><img width="700" src="https://habrastorage.org/files/8e7/1a8/dcb/8e71a8dcbaac4739ba5dce5bc6e4258f.jpg"><br>  Here is the result of what happens if you scan for 15-20 seconds near the object. <br>  When scanning, all scanners give out either a cloud of points, or a cloud of polygons, or a depth map.  Any kind of information may contain holes.  Holes can appear for a variety of reasons: <br><ul><li>  There may indeed be a hole in the object. </li><li>  The object has a recess.  Sometimes the scanner simply cannot look inside: the base between the ‚Äúeyes‚Äù is too big <br><img width="350" src="https://habrastorage.org/files/b05/360/b43/b05360b4361f49edbadda6e7c3c4f1b5.PNG"></li><li>  If a scan is performed by radiation at a certain frequency, and inside the area there is a material that absorbs radiation at a given frequency (or specular reflection), then again there will be a hole </li><li>  If the scan is a passive scanner with two cameras, and the area is monotonous, then ... well, you already understood </li><li>  A large angle on the scan plane to the scanner can also cause a tear </li><li>  The hole will be if you can not scan from the "hole".  For example, the base of the statue or the back side of the statue standing close to the wall (it happened) </li><li>  I'm sure you can think of more cases. </li></ul><br>  But the robot scanner does not know the reasons.  He does not know whether the object has ended, or if it is glare.  The robot has no independent controls.  He learns the world around only through a scanner. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  How to fight? </h2><br>  <b>The first and easiest way</b> is to collect an excess amount of data or simply try to scan the object from all possible sides.  For example, like this: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/77CzptWyZgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  This approach has a number of disadvantages: <br><ul><li>  Scanning time is pretty long.  You have to twist the object for a long time. </li><li>  In the case of simple forms (a la beer cans), everything will be fine, but as soon as we try to scan something rather complicated with a large number of ‚Äúundercuts‚Äù, it turns out that many unscanned zones remain. </li><li>  Not the fact that all the provisions will be passed.  For example, to see some point inside the object, you need to look strictly from one side to within a couple of degrees, and to pass all 2œÄR <sup>2</sup> ‚âà 41253 square degrees is unrealistic (even if the cut off half-plane ‚âà20k) </li></ul><br><img width="700" src="https://habrastorage.org/files/0e7/bb9/93f/0e7bb993f1c94791989f0b6a808761d0.jpg"><br>  (a frame from the video above, you can see errors inside the sleeve) <br>  <b>The second approach</b> is a pre-calculated trajectory.  Of course, this can be done only in a limited number of scenarios, when the shape of the object is approximately known.  For example, in production for solving the problem of quality control of the manufactured product. <br>  <b>The third, the most reasonable and interesting way</b> - depending on the observed object, select the minimum number of species and the optimal trajectory of hand movement with the scanner in such a way as to achieve maximum coverage of the object. <br>  Based on the received data, a closed surface is constructed.  After that, areas for which the lowest accuracy is observed iteratively are observed (there is a surface, but there are no points confirming it).  Observe the region -&gt; recalculate the model -&gt; observe the region.  The result is a series of consecutive scans as a result of which the robot ‚Äúknows‚Äù the object. <br><img width="700" src="https://habrastorage.org/files/fc6/261/01b/fc626101b7d44d28822ca4375c05ef6e.PNG"><br>  The case remains for the small: take the math, which will allow to build the surface.  Add a module to assess the reliability of the constructed surface.  Run in a loop. <br><br><h2>  Poisson reconstruction </h2><br>  The most interesting and beautiful mathematics that solves the problem of constructing a surface from incomplete data is ‚ÄúPoisson recovery‚Äù.  The main assumption is that we consider one object.  Then we can imagine the ‚Äúhidden‚Äù function f (p) from a position in space.  A positive value is outside the object, a negative is inside.  On the desired surface of the object function will be zero. <br><img src="https://habrastorage.org/files/f06/0e1/653/f060e1653d6f4bf9942a2c4d64f250b5.PNG"><br>  It is clear that the gradient of f (p) on the surface is the vector of the normal to the desired surface of the object. <br>  When processing the primary data from the scanner, we already estimate the normals to the scanned surface.  Then the input data for the search for the function f (p) will be a set of points in space and normal to the surface of the object at these points: (p, n) <sub>i</sub> Usually, when scanning a less complex object, there are hundreds of thousands of such points. <br>  The meaning of this function f (p) and normals is easiest to understand in 2D.  On the left, normals to a 2D object, on the right, the value of the function f (shown by the third coordinate), blue color outside the object, orange color inside. <br><img src="https://habrastorage.org/files/e74/433/7fb/e744337fb4c848c5813c9c382f666c16.PNG"><br>  Points (p, n) <sub>i</sub> lie on the surface.  Ideally: <br><img src="https://habrastorage.org/files/817/c86/28b/817c8628b3a5438abe16f2d08cbebb25.png"><br>  where the inverted triangle is the Nabla operator (gradient vector). <br>  Naturally, the normals in the points and the positions of the points themselves contain measurement errors, so there is no such function f, and you should not look for it.  In this situation, the normal field v (x) is introduced and requires a minimum: <br><img src="https://habrastorage.org/files/dd5/35f/548/dd535f548d0c444ebcc5b61b6f635afe.png"><br>  This minimization problem is solved just by using the Poisson equation: <br><img src="https://habrastorage.org/files/dc4/ae8/c01/dc4ae8c01a4547ffa0459b0988996ef8.png"><br>  Who is interested in reading in more detail about the conclusion and mathematics: the <a href="http://www.cs.jhu.edu/~misha/MyPapers/SGP06.pdf">article of the</a> author who invented the method. <br>  And having solved this equation (there are many ways to solve the problem, but you have to go, of course, to a difference problem, and then to a huge linear equation), you need to find an isosurface with zero f, and use a <a href="https://ru.wikipedia.org/wiki/Marching_cubes">marching cube</a> algorithm to build a polygonal model. <br>  Here, by the way, several problems appear at once, which have to be overcome: <br><ol><li>  The field v (x) is a field of normals, in fact, it is not somewhat differentiated, and, therefore, it is necessary to ‚Äúsmear‚Äù them somehow in space.  In other words - to dream. </li><li>  Solution of the Poisson problem up to a constant.  And we need to find the surface of the object, so we have to solve another optimization problem in order to minimize the values ‚Äã‚Äãof the function f at all points p <sub>i</sub> . </li></ol><br>  But from all other sides this mathematical approach is good and reliably applicable in reality (although not a quick calculation process). <br>  The only thing is  Since the density of points p <sub>i</sub> in space is very variable, it is advisable to split the entire volume using an octree and solve the resulting difference equation taking into account the division into cubes of different sizes. <br><img src="https://habrastorage.org/files/538/2ce/2e2/5382ce2e2ba14484946ded2258b440d7.png"><br>  You can either set the smallest splitting level, or split up the space until no more than one point with the normal remains in each cell.  As a result, the number of cubes will be comparable to the number of points obtained during scanning. <br><br><h2>  Smooth Signed Distance Surface Reconstruction (almost Poisson Reconstruction) </h2><br>  There is another approach <a href="http://mesh.brown.edu/ssd/pdf/Calakli-pg2011.pdf">proposed by</a> F. Calakli and G. Taubin in 2011, which gives the same qualitative result, and under certain conditions is even better than the method with solving the Poisson equation, but is somewhat more accessible for understanding and programming.  In Wikipedia, these two methods are simply <a href="https://en.wikipedia.org/wiki/Poisson%2527s_equation">confused</a> . <br>  Similarly, we look for the function f (p), which is negative inside the object, and positive outside it.  In the same way, we want to bring the f (p) gradient closer to the normals in the given positions that we got during the scan.  But we will look for a minimum: <br><img src="https://habrastorage.org/files/0c2/3b1/3eb/0c23b13ebee743ce9bb7c1500734c674.png"><br>  It looks rather cumbersome, but in reality we only ask that the function at the points of Pi would be smaller (the first term), so that its gradient is closer to the normals at the same points (the second term), and that in the whole volume it has second derivatives were smaller, more precisely - the Hessian of function (third member).  The requirement for second derivatives is quite important, since  I want very much that, having gone beyond the boundaries of the object, the function does not start oscillating, and such nightmarish pictures fail: <br><img src="https://habrastorage.org/files/e1b/07b/18f/e1b07b18fdba4810bc33dd7397367a8e.png"><br>  Those.  everything was minimized, but having gone away from the points that we measured with the scanner, the function f (p) did not behave arbitrarily. <br>  And note that each member is a square.  This is not just because  just for quadratic forms, it is easy to analytically obtain an extremum (for the forms A * A-2 * b * A + c, the local minimum at the point A = b).  Just write everything in a differential form, i.e.  Let us replace the partial derivatives on the difference on the borders of small cubes, and then in the matrix, in order to use the focus with a minimum of square shape.  As a result, we obtain a linear system of equations, the unknown in which are the values ‚Äã‚Äãof the function f (p) inside the cubes.  And the cubes, as well as in the method of reconstruction described above, are worth taking unevenly, and building an octree tree.  Who is interested in a detailed conclusion, the <a href="http://mesh.brown.edu/ssd/pdf/Calakli-pg2011.pdf">text of the</a> article. <br>  It works in the same way as the method based on the Poisson equation.  There is one small advantage in that it is not necessary to "smear" the normals in space in order to be able to get the divergence from the vector field of normals, while losing accuracy and unnecessarily smoothing the object.  On the other hand, if the scanner rather roughly evaluates the normals, then this advantage can be a disadvantage of the method. <br><br><h2>  Measure of quality </h2><br>  By itself, the Poisson algorithm does not tell us what is visible and what is not.  We need to come up with some measure of quality to assess the reliability of the result.  The simplest measure is to walk along the surface in small cubes and see how many dots there are in each of them: <br><img src="https://habrastorage.org/files/56a/180/041/56a180041f47475a9078fa2e2baf0c95.jpg"><br>  The more points - the more confidence, the more red.  Such a measure of quality will be very representative.  Indeed, we cannot trust areas where we have not seen anything.  And if they saw, then, probably, there really is something. <br><br><h2>  Selection of further scanning direction </h2><br>  Now everything seems to be clear.  We need to select such points for further scanning, from which to make the next series of frames, which should be frozen into the main model. <br>  To do this, we mark out the surrounding space.  We will check each of its points by determining how many invalid points of the figure we will see from it.  The more such points - the more profitable to watch. <br><img width="700" src="https://habrastorage.org/files/4a0/01e/3f9/4a001e3f9ea640fd82c0a467c04844e9.jpg"><br>  It remains to find local maxima and launch observations: <br><img width="700" src="https://habrastorage.org/files/403/b2d/f22/403b2df22bf747fea7982e52c576e9f2.jpg"><br>  Then again Poisson is performed, then again an additional scan is performed.  And so on a circle, until the finished model appears. <br><br><h2>  Does Poisson need it at all? </h2><br>  Maybe you can scan well, so that everything was and so?  Why complicate a bunch of math?  Here is a simple example.  Three pictures.  <a href="https://www.artec3d.com/ru/3d-models">The 3D scan</a> was made by an <a href="https://www.artec3d.com/ru/3d-scanner/artec-spider">Artec Spider scanner</a> .  The first - the raw information from the scanner, in fact a cloud of points.  The second is the Fusion algorithm, which simply does averaging and position control.  The third is the Poisson algorithm.  And the difference is in the face! <br><img src="https://habrastorage.org/files/590/b04/f0a/590b04f0a8744a1293202232fd1aeec8.jpg"><br><img src="https://habrastorage.org/files/78c/119/5f3/78c1195f394c4620b545f55aacfea5ff.jpg"><br><img src="https://habrastorage.org/files/cdc/403/2cc/cdc4032ccda6437d9aab8a89e0027f85.jpg"><br>  And so this dragon will look whole: <br><img src="https://habrastorage.org/files/db1/c13/ab0/db1c13ab041f416ca4a4d63d582bed6c.jpg"><br><br><h2>  Putting it all together </h2><br>  As a result, the robot's surface scanning algorithm looks like this: <br><ol><li>  Making the primary scan </li><li>  Build according to the available information approximating surface </li><li>  We build a measure of the quality of the surface </li><li>  Selecting points for further scanning <br><ul><li>  If the points are of great importance - make a scan and go to step 2 </li><li>  If there is almost no information added when scanning, give the user a final scan </li></ul><br></li></ol><br><img width="700" src="https://habrastorage.org/files/2ba/a1d/248/2baa1d24801d4aeb8548c1f65fa810c1.PNG"><br>  In more detail about such a scanning scheme can be read, for example, <a href="http://www.cs.tau.ac.il/~dcor/articles/2014/quality-driven.pdf">here</a> . <br>  Or see how this whole thing works: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BLX4LbiUtSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  PS The robot in the video turns his head just like that, it has nothing to do with scanning <br>  PSS Thanks to <a href="https://habrahabr.ru/users/vasyutka/" class="user_link">Vasyutka</a> for the help in writing the article and the Artek team for numerous edits and bringing to mind! </div><p>Source: <a href="https://habr.com/ru/post/277885/">https://habr.com/ru/post/277885/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277867/index.html">DI, PHPUnit and setUp</a></li>
<li><a href="../277869/index.html">Top JavaScript Developer Tools</a></li>
<li><a href="../277871/index.html">[Peter] JUG.ru meeting with Kotlin developers</a></li>
<li><a href="../277873/index.html">Embedded World 2016: where does the embedded world go?</a></li>
<li><a href="../277875/index.html">Microsoft acquires Xamarin</a></li>
<li><a href="../277887/index.html">Corporate calendar shooting: how the story was created with EastBanc Technologies employees in roles</a></li>
<li><a href="../277889/index.html">Zabbix 3.0: Interface</a></li>
<li><a href="../277891/index.html">How we transported the data center of a western company to the Russian Federation due to the law on personal data</a></li>
<li><a href="../277893/index.html">Sessions and memory management in the assembly Vivaldi 1.0.403.15</a></li>
<li><a href="../277895/index.html">How to create email-auto-answers: Analysis of 100 applications to support services of IT companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>