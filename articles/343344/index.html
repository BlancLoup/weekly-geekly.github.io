<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LLVM source guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my in-depth course on compilers last fall, we spent some time studying the LLVM source tree. A million lines of C ++ code look scary, but I find it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LLVM source guide</h1><div class="post__text post__text-html js-mediator-article">  In my in-depth course on compilers last fall, we spent some time studying the LLVM source tree.  A million lines of C ++ code look scary, but I find it an interesting exercise, and at least some students agree, and I thought that I would try to write something like that.  We will use LLVM 3.9, but previous (and possibly future) releases are not much different. <br><img src="https://habrastorage.org/webt/dj/7v/ht/dj7vhtqrcaggifm0-ppl40p-pf8.jpeg"><br><a name="habracut"></a><br>  I don‚Äôt want to spend much time on the theoretical foundations of LLVM, but there are a few things you should know. <br><br>  The LLVM core does not contain frontends, only midland optimizers, several backends, documentation, and a lot of auxiliary code.  Frontends, such as Clang, live in separate projects. <br><br>  The intermediate code representation in the LLVM core lives in RAM and can be manipulated using the large C ++ API.  This view can be saved as readable text and parsed back into memory, but only for debugging convenience: during normal compilation using LLVM, a text IR is never generated.  Usually, the frontend builds IR using LLVM API calls, then runs some optimization passes, and then calls the backend, which generates an assembler or machine code.  When LLVM code is written to disk (which does not happen during normal compilation of C and C ++ projects using Clang), it is stored as a ‚Äúbitcode‚Äù, a compact binary representation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main documentation on the LLVM API is generated by doxygen, and can be found <a href="http://llvm.org/doxygen/index.html">here</a> .  This information is difficult to use if you do not already know exactly what you need to do and what to look for.  The tutorials referenced below are the starting point for exploring the LLVM API. <br><br>  Refer to the code.  <a href="https://github.com/llvm-mirror/llvm/tree/release_39">The root directory</a> contains: <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/bindings">bindings</a> - ‚Äúbundles‚Äù, allow you to use LLVM API from languages ‚Äã‚Äãother than C ++.  There are also other bundles, with language C (which will be discussed below), and Haskell (it is not in this tree). <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/cmake">cmake</a> - LLVM uses CMake, not autoconf.  Just say thanks to those who did it for you. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs">docs</a> - ReStructuredText documentation.  See an example <a href="">of a language guide</a> that defines the meaning of each LLVM instruction (GitHub displays .rst files as HTML by default, you can see the raw file <a href="">here</a> ).  The material in the subdirectory with the <a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs/tutorial">manual is</a> particularly interesting, but do not look at it there, better go <a href="http://llvm.org/docs/tutorial/">here</a> .  This is the best way to learn LLVM! <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/examples">examples</a> : These are the sources that come with the tutorial.  As LLVM hackers, you should get the code, CMakeLists.txt, etc. from here.  from here whenever possible. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/include">include</a> : The first subdirectory, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm-c">llvm-c</a> , contains bundles for the C language, which I did not use, but which looks quite reasonable.  It is important that LLVM developers try to keep these bundles stable, while the C ++ API changes with each release, although the rate of change seems to be slowing down over the last few years. <br><br>  The second subdirectory, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm">llvm</a> , is large: it contains 878 header files that define the LLVM API.  In general, it is easier to use doxygen-versions of these files than to read them directly, but often you have to download these files in search of a function. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib">The lib</a> contains really useful things, we will look at them below separately. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/projects">projects</a> does not contain anything by default, however LLVM components are copied here, such as compiler-rt (runtime libraries for such things as sanitizers), OpenMP support and LLVM C ++ libraries that live in other repositories. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/resources">resources</a> : something for Visual C ++ that neither you nor me need (more <a href="https://blog.regehr.org/archives/1453">here</a> ) <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/runtimes">runtimes:</a> another placeholder for external projects, added only last summer ( <i>2016. approx. transl.</i> ), and I do not know, in fact, what it is for. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/test">test::</a> large directory, contains thousands of LLVM unit tests, they run when you build a check target ( <i>make check-all, approx. transl.</i> ).  Most of these are .ll files that contain LLVM IR in text form.  They test different things, for example, that a pass of optimization leads to the expected result.  I will look at LLVM tests in detail in a future post. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/tools">tools:</a> LLVM itself is just a collection of libraries, and there is no dedicated main function in it.  Most of the subdirectories in the tools directory contain executable tools that are linked to the LLVM libraries.  For example, llvm-dis, this is a disassembler that translates a bitcode into a text assembler format. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/unittests">unittests:</a> more unit tests are also run when building a check target.  These are C ++ files that use the <a href="https://github.com/google/googletest">Google Test</a> framework to call the API directly, unlike the tests in the ‚Äútests‚Äù directory, which run LLVM functions not directly, but by running an assembler, disassembler, or optimizer. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/utils">utils:</a> emacs and vim mods to follow LLVM coding style, Valgrind file to suppress false positives, lit and FileCheck tools to support unit testing, and many other different things.  Perhaps most of them you do not need. <br><br>  OK, so far everything has been pretty simple.  We missed the <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib">lib</a> directory, which contains almost everything important.  Look at the subdirectories: <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Analysis">Analysis</a> directory contains many static analyzers, such as the analysis of aliases and global values.  Some analyzers have an LLVM pass structure and must be run by the pass manager, others are libraries, and can be called directly.  The strange member of the analyzer family, this InstructionSimplify.cpp, is actually a transformation, not an analysis.  I am sure that many will not notice a comment explaining what this passage is doing here. <br><br><div class="spoiler">  <b class="spoiler_title">here is this comment</b> <div class="spoiler_text">  This pass does not change IR itself.  The rule is that llvm :: SimplifyInstruction can only return constants and existing Value objects, which meets the requirements for the analyzer.  The passage calling SimplifyInstruction for each instruction is a transformation pass (lib / Transforms / Utils / SimplifyInstructions.cpp.). </div></div><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/AsmParser">AsmParser</a> : parsing text IR into memory. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Bitcode">Bitcode</a> : serialize IR into a compact format and read from a compact format into RAM. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/CodeGen">CodeGen:</a> a hardware-independent LLVM code generator, a framework on which the LLVM backends are written, and a set of libraries that these backends can use.  There is a lot of code (&gt; 100 KLOC), and, unfortunately, I don't know much about it. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/DebugInfo">DebugInfo</a> is a library to support the mapping between LLVM instructions and source code locations.  Lots of good information on <a href="http://llvm.org/devmtg/2014-10/Slides/Christopher-DebugInfoTutorial.pdf">these slides</a> from the 2014 LLVM Developers' Meeting talk. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ExecutionEngine">ExecutionEngine:</a> Although LLVM is usually translated to machine code or assembler, it can be executed by an interpreter.  The non-JIT interpreter did not work as it should the last time I tried to use it, but in any case, it works slower than JIT.  The latest <a href="http://llvm.org/devmtg/2016-11/">JIT API, Orc</a> , is here. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Fuzzer">Fuzzer:</a> this is <a href="http://llvm.org/docs/LibFuzzer.html">libFuzzer</a> , similar to <a href="http://lcamtuf.coredump.cx/afl/">AFL</a> ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B7%25D0%25B7%25D0%25B8%25D0%25BD%25D0%25B3">fuzzing</a> ).  It uses the LLVM functionality for fuzzing programs compiled using LLVM. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IR">IR</a> : various <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IR">IR</a> related code.  The code for outputting IR code in text format, for upgrading bitcode files created in earlier versions of LLVM, for folding constants in the process of creating IR nodes, etc. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IRReader">IRReader</a> , <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LibDriver">LibDriver</a> , <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LineEditor">LineEditor</a> : almost no one is interested in what is here, and there is hardly any useful code there at all. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Linker">Linker:</a> The LLVM module, like the C and C ++ compilation unit, contains functions and variables.  The linker combines multiple modules into one large module. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LTO">LTO:</a> Optimization of layout time, the subject of many posts and scientific articles, allows the optimizer to see beyond the individual compiled modules.  LLVM does the layout optimization ‚Äúfor free,‚Äù using a linker to create a large module and then optimizing it with normal optimization passes.  This is a good approach, but it does not scale for very large projects.  The modern approach is <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">ThinLTO</a> , which allows you to get most of the advantages for a small part of the price. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/MC">MC: The</a> compiler usually generates assembly code and allows the assembler to create machine code.  The MC subsystem in LLVM eliminates the intermediate and allows you to generate machine code directly.  This speeds up compilation and is especially useful when LLVM is used as a JIT compiler. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Object">Object</a> : Implementation of the details of object file formats, such as ELF. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ObjectYAML">ObjectYAML</a> - supports encoding object files in <a href="http://llvm.org/docs/YamlIO.html">YAML</a> .  I do not know why this is necessary. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Option">Option:</a> - command line parsing. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Passes">Passes: the</a> part of the pass manager that controls the start of the LLVM passes, taking into account the dependencies. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ProfileData">ProfileData:</a> - reads and writes profiling data to support optimization based on profiling. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Support">Support:</a> Support for various codes, including APInts (arbitrary precision integers widely used in LLVM), etc. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/TableGen">TableGen:</a> a kind of <a href="http://llvm.org/docs/TableGen/">Swiss knife</a> , a tool that receives as input .td files (of which there are more than 200 in LLVM) containing structured data, and C ++ generation code that is compiled into LLVM.  TableGen is used, for example, to implement assembler and disassembler. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Target">Target:</a> backends for different processors live here.  There are a lot of tablegen files.  You can create a new backend by making a clone of one of them, whose architecture is closest to yours, and then spending a couple of years in its development. <br><br>  <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Transforms">Transforms:</a> this is my favorite directory, here live Midland optimizers.  IPO contains interprocedural optimization, working between the boundaries of functions, they are usually not very aggressive, but they see a lot of code at once.  InstCombine is a peephole optimizer.  Instrumentation - support for sanitizer.  ObjCARC supports <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">this</a> .  Scalar contains compiler optimizations ‚Äúfrom the textbook‚Äù, I will try to write a more detailed post about the contents of this directory.  Utils is an auxiliary code.  Vectorize - LLVM autorunctor, the subject of great work in recent years. <br><br>  With this we will finish our review tour, I hope it was useful and, as always, you will let me know if I missed it somewhere or missed something. </div><p>Source: <a href="https://habr.com/ru/post/343344/">https://habr.com/ru/post/343344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343334/index.html">How to frontend developer set up a database</a></li>
<li><a href="../343336/index.html">How to teach a neural network to invent the names of Russian settlements</a></li>
<li><a href="../343338/index.html">27 free services for creating visual content without a designer</a></li>
<li><a href="../343340/index.html">7 Short Rules for Conquering the Global Market</a></li>
<li><a href="../343342/index.html">Yet another kaspersky crackme</a></li>
<li><a href="../343346/index.html">Distribution video. Ambush: nginx or php?</a></li>
<li><a href="../343348/index.html">3 Unusual Linux Networking Cases</a></li>
<li><a href="../343350/index.html">‚ÄúDo you want to be a system architect? There is only light and purity ... "</a></li>
<li><a href="../343352/index.html">How we did a huge amount of communication for a rather big security structure</a></li>
<li><a href="../343356/index.html">Interpolation polynomial on arbitrary functions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>