<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In-depth training in the garage - Two networks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second article in the series about the definition of a smile on the face. 

 In-depth training in the garage - Data Brotherhood 
 In-depth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In-depth training in the garage - Two networks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/641/f7e/846/641f7e846f0e41559d9dea3bfd9e24d3.png" width="520" alt="An example of the system"><br>  This is the second article in the series about the definition of a smile on the face. <br><br>  <a href="https://habrahabr.ru/post/277267/">In-depth training in the garage - Data Brotherhood</a> <br>  In-depth training in the garage - Two networks <br>  <a href="https://habrahabr.ru/post/277403/">In-depth training in the garage - Return smiles</a> <br><br><h2>  Calibration </h2><br>  So, you figured out the classifier, but you probably already noticed that the transcendental 99% somehow do not look very impressive during a combat detection test.  So I noticed.  Additionally, it can be seen that in the last two examples there is a very small step of the movement of windows, it will not work in life.  In the present, real launch, the step is expected to look more like a picture for the first network, and there you can clearly see an unpleasant fact: no matter how well the network is looking for faces, the windows will be poorly aligned to the faces.  And reducing the step is clearly not the appropriate solution to this problem for production. <br><a name="habracut"></a><br>  Well, I thought.  We found windows, but we found not exact windows, but, as it were, displaced ones.  How would you move them back so that the face is in the center?  Naturally, automatically.  Well, since I started networking, I decided to ‚Äúrestore‚Äù the windows by networking too.  But how? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first thought came to predict three numbers by the network: by how many pixels it is necessary to shift x and y and by which constant to increase (decrease) the window.  It turns out regression.  But then I immediately felt that something was wrong, as many as three regressions had to be done!  Yes, two of them are discrete.  Moreover, they are limited by the window movement in the original image, because there is no point moving the window far away: there was another window!  The last nail in the coffin of this idea turned out to be a couple of independent articles, which argued that the regression is much worse than the classification is solved by modern network methods, and that it is much less stable. <br><br>  So, it was decided to reduce the regression task to the classification problem, which turned out to be more than possible, given that I need to tug the window quite a bit.  For these purposes, I collected datasets, in which I took selected persons from the original dataset, shifted them to nine (including none) from different sides and increased / decreased to five different factors (including one).  Total received 45 classes. <br><br>  The astute reader here must be terrified: the classes turned out to be very strongly connected with each other!  The result of such a classification may have little to do with reality. <br><br>  To calm the inner mathematics, I gave three reasons: <br><br><ol><li>  In essence, network training is simply a search for the minimum loss function.  It is not necessary to interpret it as a classification. </li><li>  We do not classify anything, in fact, we emulate a regression!  Combined with the awareness of the first point, this allows you to not focus on formal correctness. </li><li>  That damn it works! </li></ol><br>  Since we do not classify, but emulate regression, we cannot simply take the best class and assume that it is correct.  Therefore, I take the distribution of classes, which gives the network for each window, delete very unlikely (&lt;2.2%, which is 1/45, which means that the probability is less than random), and for the remaining classes, I sum up their shifts with probabilities as coefficients and I get a regression in such a small non-basis <i>(there would be a basis, if the classes were independent, and no basis is the same :)</i> . <br>  So I introduced the second calibration network into the system.  She gave out a grade distribution, on the basis of which I calibrated the windows, hoping that the faces would be aligned to the center of the windows. <br><br>  Let's try to train just such a network: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_net12_cal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span><span class="hljs-function">:</span></span> network = lasagne.layers.InputLayer(shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), input_var=input) network = lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.1</span></span>) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">16</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nolin=relu) network = max_pool(network) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">128</span></span>, nolin=relu) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">45</span></span>, nolin=linear) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> network</code> </pre> <br>  And here is an algorithm for calculating the offset: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_calibration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> classes = np.array([(dx1, dy1, ds1), (dx2, d2, ds2), ...], dtype=theano.config.floatX) <span class="hljs-comment"><span class="hljs-comment"># ds --   scale min_cal_prob = 1.0 / len(classes) cals = calibration_net(*frames) &gt; min_cal_prob #       ,     (dx, dy, ds) = (classes * cals.T).sum(axis=0) / cals.sum(axis=1) #   --   ,   --     .      ,        return dx, dy, ds</span></span></code> </pre> <br>  And it works! <br><br><img src="https://habrastorage.org/files/144/d8a/ac3/144d8aac35e04f60850375c14f2bcc33.png" height="320" alt="Calibration"><br>  On the left, the source windows of the detection network (small), on the right, they are also calibrated.  It can be seen that the windows begin to group into explicit clusters.  Additionally, it helps to more effectively filter duplicates, since the windows belonging to one person intersect with a larger area and it becomes easier to understand that one of them needs to be filtered out.  It also allows reducing the number of windows in production by increasing the window sliding step along the image. <br><br>  At the same time, here are the results of learning a small calibration: <br><img src="https://habrastorage.org/files/51d/3af/4da/51d3af4da2d14a4f956ee90b28612a37.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/270/26b/a44/27026ba4450a47088003e28cc41c3955.png" width="340" height="264" alt="Accuracy"><br><br>  and large calibration: <br><img src="https://habrastorage.org/files/a52/c81/fc4/a52c81fc46544471976c46f83117eed3.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/dfc/894/b6d/dfc894b6da534bc8b2028fe555f1dbc8.png" width="340" height="264" alt="Accuracy"><br><br>  and here is the largest calibration network: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_net48_cal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span><span class="hljs-function">:</span></span> network = lasagne.layers.InputLayer(shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>), input_var=input) network = lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.1</span></span>) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = max_pool(network) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.3</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">256</span></span>, nolin=relu) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.3</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">45</span></span>, nolin=linear) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> network</code> </pre> <br>  These charts should be skeptical, because we do not need a classification, but a regression.  But empirical gazing shows that calibration, trained in this way, fulfills its purpose well. <br>  I also note that for calibration, the initial data set is 45 times more than for classification (45 classes for each person), but on the other hand, it could not be completed in the manner described above simply by setting the problem.  So, sausage, especially a large network, pretty. <br><br><h2>  Optimization II </h2><br>  Let's return to the detection.  Experiments have shown that a small network does not provide the desired quality, so it is imperative to learn more.  But the big problem is that even on a powerful GPU for a very long time to classify thousands of windows, which are obtained from a single photo.  Such a system would simply be impossible to bring to life.  In the current version there is a great potential for optimizations with cunning stunts, but I decided that they are not scalable enough and the problem should be solved qualitatively, not slyly optimizing flops.  And the decision is here, before our eyes!  A small network with an input of 12x12, one convolution, one pooling and classifier on top!  It works very quickly, especially considering that it is possible to run the classification on the GPU in parallel for all windows - it turns out almost instantly. <br><br><h2>  Ensemble </h2><br>  <i>Bind them.</i> <br><br>  So, it was decided to use not one classification and one calibration, but the whole ensemble of networks.  First there will be a weak classification, then a weak calibration, then a filtering of calibrated windows, which presumably indicate one person, and then only on these remaining windows to drive a strong classification and then a strong calibration. <br><br>  Later, the practice showed that it was still rather slow, so I made the ensemble as many as three levels: in the middle between the two, the "average" classification was inserted, followed by the "average" calibration and then filtering.  In such a combination, the system works fast enough that there is a real opportunity to use it in production if you apply some engineering efforts and implement some tricks, just to reduce flops and increase parallelism. <br><br>  Total we get the algorithm: <br><br><ol><li>  Find all the windows. </li><li>  Check the first detection network. </li><li>  Those that caught fire, we calibrate the first calibration network. </li><li>  Filter overlapping windows. </li><li>  Check the second detection network. </li><li>  Those that caught fire, we calibrate the second calibration network. </li><li>  Filter overlapping windows. </li><li>  Check the third detection network. </li><li>  Those that caught fire, we calibrate the third calibration network. </li><li>  Filter overlapping windows. </li></ol><br><h2>  Butchy windows </h2><br>  If you take steps from the second to the seventh for each window separately, it takes quite a long time: constant switching from CPU to GPU, inadequate utilization of parallelism on the video card and who knows what else.  Therefore, it was decided to make pipelined logic that could work not only with separate windows, but with bats of arbitrary size.  To do this, it was decided to turn each stage into a generator, and between each stage, put a code that also works as a generator, but not windows, but buoys and buffers the results of the previous stage, and accumulating a predetermined number of results (or end) gives the assembled batch further. <br><br>  This system not bad (30 percent) accelerated processing during detection. <br><br><h2>  Moar data! </h2><br>  As I noted above in the previous article, a large detection network learns with a creak: constant sharp jumps, and even talks about it.  And it's not about learning speed, as anybody who is familiar with network training thought first of all!  The fact is that there is still little data.  The problem is indicated - you can search for a solution!  And it was immediately found: Labeled Faces in the Wild. <br><br>  The combined dataset from FDDB, LFW and my personal refills has become almost three times the original.  What came out of it?  Less words, more pictures! <br><br>  A small network is noticeably more stable, converges faster, and the result is better: <br><img src="https://habrastorage.org/files/295/f7d/938/295f7d9384fc434bb8c4f623e7a952a4.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/db6/6b9/084/db66b908457540b0a829c0c5e3627b19.png" width="340" height="264" alt="Accuracy"><img src="https://habrastorage.org/files/cbc/c62/c85/cbcc62c851894d6080d08dab5da629a8.png" height="264" alt="Detection Example"><br><br>  A large network is also noticeably more stable, bursts are gone, it converges faster, the result is suddenly a bit worse, but 0.17% seems to me an acceptable error: <br><img src="https://habrastorage.org/files/437/c58/2d8/437c582d80df49c395205b466eda48a9.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/410/d21/16a/410d2116aa5a46ca8aa45a5ed0cd157f.png" width="340" height="264" alt="Accuracy"><img src="https://habrastorage.org/files/63b/5ad/f86/63b5adf866704179b0f0a6b0424bafcb.png" height="264" alt="Detection Example"><br><br>  Additionally, such an increase in the amount of data allowed us to increase the larger model for detection: <br><img src="https://habrastorage.org/files/2b1/c44/f84/2b1c44f8439b40529fafa8895fe591ac.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/082/563/23f/08256323fdb740a2abca905975be793a.png" width="340" height="264" alt="Accuracy"><img src="https://habrastorage.org/files/9fc/6b2/836/9fc6b28368834e6792f46e6e941ba99f.png" height="264" alt="Detection Example"><br><br>  We see that the model converges even faster, to an even better result and very stable. <br><br>  At the same time, I re-trained calibration networks on more data. <br><br>  Small calibration: <br><img src="https://habrastorage.org/files/e11/061/9a9/e110619a972f4f61962aeb67e6bf985f.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/9d7/b1f/2bc/9d7b1f2bc7e04b94855d1331a00e6d30.png" width="340" height="264" alt="Accuracy"><br><br>  and large calibration: <br><img src="https://habrastorage.org/files/a22/f0b/b2e/a22f0bb2e6214ac980b5a6e2f087b724.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/69f/b0f/c00/69fb0fc005c74fff9ef9a9fa0f946bf8.png" width="340" height="264" alt="Accuracy"><br><br>  In contrast to the detection network, one can see a dramatic improvement here.  This is because the original training set is not augmented and the source network suffers greatly from lack of data, as the network suffered for detection prior to augmentation. <br><br><h2>  Detection ready </h2><br>  A picture illustrating the entire pipeline (classification-1, calibration-1, filtering, classification-2, calibration-2, filtering, classification-3, calibration-3, filtering, global filtering, white faces from the training set): <br><br><img src="https://habrastorage.org/files/0b7/939/f71/0b7939f71886457cb13574247c82eaea.png" height="800" alt="image"><br>  Success! <br><br><h2>  Multi-resolution </h2><br>  At this point, those of you who are following the trends have probably already thought, saying that for a dinosaur, they use techniques from ancient times (4 years ago :), where are the fresh cool tricks?  And here they are! <br><br>  In the open spaces of arxiv.org, an interesting idea was underlined: let's consider feature maps in convolutional layers at different resolutions: it‚Äôs trite to make several inputs to the network: NxN, (N / 2) x (N / 2), (N / 4) x (N / 4) as many as you like!  And serve the same square, only differently reduced. <br>  Then, for the final classifier, all the cards are concatenated, and he seems to be able to look at different resolutions. <br><br>  It was to the left, it became to the right (measured on that very average network): <br><img src="https://habrastorage.org/files/06f/ec5/72f/06fec572f46a4c069f10f9fa9541cdbc.png" height="264" alt="image"><img src="https://habrastorage.org/files/388/adf/71d/388adf71d1ea4d4887210105d0120959.png" height="264" alt="image"><br><br>  It can be seen that in my case the network with several resolutions converges faster and is a little less loose.  Nevertheless, I rejected the idea as not working, since the small and medium networks should not be super-accurate, and I simply increased more instead of multiresolutions with even greater success. <br><br><h2>  Batch normalization </h2><br>  Batch normalization is a network regularization technique.  The idea is that each layer at the input accepts the result of the previous layer, in which there can be almost any tensor whose coordinates are supposedly somehow distributed.  And it would be very convenient for the layer if tensors with coordinates from a fixed distribution, one for all layers, were given to the layer, then it would not need to learn the conversion invariant to the distribution parameters of the input data.  Well, okay, let's insert some calculation between all the layers, which optimally normalizes the outputs of the previous layer, which reduces the pressure on the next layer and gives him the opportunity to do his job better. <br><br>  This technique helped me quite well: it allowed us to reduce the probability of a dropout while maintaining the same quality of the model.  Reducing the probability of a dropout in turn leads to an acceleration of the convergence of the network (and more retraining if done without normalizing the batch).  Actually, literally on all the graphs you see the result: the networks quickly converge to 90% of the final quality.  Before the normalization of the batches, the fall of the error was significantly more gentle (unfortunately, the results were not preserved, since there was no DeepEvent yet). <br><br><h2>  Inceptron </h2><br>  Of course, I could not resist digging into modern architectures and tried to train Inceptron for the classification of persons (not GoogLeNet, but a much smaller network).  Unfortunately, in Theano this model cannot be correctly made: the library does not support zero-padding of arbitrary size, so I had to tear off one of the branches of the Inception module, namely the right one in this picture: <br><br><img src="https://habrastorage.org/files/974/196/f3c/974196f3c45247519c4aea38998c9745.png" width="480" alt="Inception module"><br>  In addition, I had only three inception-modules on each other, and not seven, as in GoogLeNet, there were no preliminary exits, and there were no usual convolutionary-pooling layers at the beginning. \ <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_net64_inceptron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span><span class="hljs-function">:</span></span> network = lasagne.layers.InputLayer(shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>), input_var=input) network = lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.1</span></span>) b1 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">32</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b2 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">48</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b2 = conv(b2, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nolin=relu) b3 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">8</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b3 = conv(b3, num_filters=<span class="hljs-number"><span class="hljs-number">16</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = lasagne.layers.ConcatLayer([b1, b2, b3], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) network = max_pool(network, pad=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) b1 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b2 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b2 = conv(b2, num_filters=<span class="hljs-number"><span class="hljs-number">96</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nolin=relu) b3 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">16</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b3 = conv(b3, num_filters=<span class="hljs-number"><span class="hljs-number">48</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = lasagne.layers.ConcatLayer([b1, b2, b3], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) network = max_pool(network, pad=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) b1 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">96</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b2 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">48</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b2 = conv(b2, num_filters=<span class="hljs-number"><span class="hljs-number">104</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nolin=relu) b3 = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">8</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), nolin=relu) b3 = conv(b3, num_filters=<span class="hljs-number"><span class="hljs-number">24</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = lasagne.layers.ConcatLayer([b1, b2, b3], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) network = max_pool(network, pad=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">256</span></span>, nolin=relu) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">2</span></span>, nolin=linear) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> network</code> </pre> <br>  And I even got it! <br><img src="https://habrastorage.org/files/0ef/fab/b93/0effabb93f0f494bb7264dfe201e9894.png" height="264" alt="Mistake"><img src="https://habrastorage.org/files/a3f/8f0/b73/a3f8f0b7385343c1b3d54626fc57b1bb.png" height="264" alt="Accuracy"><br><br>  The result is a percentage worse than the usual convolutional network, which I have previously trained, but also worthy!  However, when I tried to train the same network, but out of four inception modules, it stably scattered.  I still have a feeling that this architecture (at least with my modifications) is very capricious.  In addition, batch normalization, for some reason, consistently turned this network into a complete raskolbas.  Here I suspect a semi-handmade batch normalization implementation for Lasagne, but in general, all this made me postpone Inceptron to a bright future with Tensorflow. <br><br><h2>  By the way, Tensorflow! </h2><br>  Of course, I tried it too!  I tried this fashionable technology on the same day, when it came out with high hopes and admiration by Google, our savior!  But no, he did not justify hope.  The stated automatic use of several GPUs is not in sight: on various cards, you need to place your hands on the hands;  it worked only with the last kuda, which I couldn‚Äôt put on the server at that time, had a hard-coded version of libc and did not start up on another server, and it was also collected manually using a blaze, which does not work in docker containers.  In short, some disappointments, although the very model of working with him is very good! <br><br>  Tensorboard also turned out to be a disappointment.  I don‚Äôt want to go into details, but I didn‚Äôt like everything and I started developing my monitoring called DeepEvent, screenshots from which you saw in the article. <br><br>  <i>In the next series:</i> <i><br></i>  <i>Smilies, ready system, results and, at last already, nice girls!</i> <i><br></i> <br></div><p>Source: <a href="https://habr.com/ru/post/277345/">https://habr.com/ru/post/277345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277335/index.html">Using functions in PostgreSQL as parameterized views</a></li>
<li><a href="../277337/index.html">Experiment: How irrational is exchange trading at short intervals (scalping)</a></li>
<li><a href="../277339/index.html">Theory of restrictions in interfaces (who killed the old graph?)</a></li>
<li><a href="../277341/index.html">NetSkills Online Networking School</a></li>
<li><a href="../277343/index.html">Building Android applications step by step, part two</a></li>
<li><a href="../277349/index.html">Ireland is a tasty morsel for building a data center</a></li>
<li><a href="../277351/index.html">Implementing a semantic news aggregator with extensive search capabilities</a></li>
<li><a href="../277353/index.html">Examination of SSL certificates, software licenses and backup space</a></li>
<li><a href="../277355/index.html">Data Center with warranty</a></li>
<li><a href="../277359/index.html">Database versioning on the fly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>