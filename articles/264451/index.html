<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On limitations in the applicability of the Minkowski metric in digital data processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time I came across an article on Habr√© in which people write how cool everything is and how well the Minkowski metric works. Time went on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On limitations in the applicability of the Minkowski metric in digital data processing</h1><div class="post__text post__text-html js-mediator-article">  Once upon a time I came across <a href="http://habrahabr.ru/post/208368/">an article</a> on Habr√© in which people write how cool everything is and how well the Minkowski metric works.  Time went on and on, and I wanted and wanted.  Finally, the task to which I wanted to apply this miracle turned up, and this is what happened: <br><br><img src="https://habrastorage.org/files/c95/612/e17/c95612e170f14be2ac7e579942a78ce6.png" alt="image"><br><a name="habracut"></a><br><br>  No-no-no, if I do it now, then you will not read the article.  It will be.  but later.  And before that I want to describe the task that started it all: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/71e/24d/baf/71e24dbaf97a417a9f6484dee5965ab4.png" alt="image"><br><img src="https://habrastorage.org/files/58c/c2f/66f/58cc2f66fcfd4983a9f6c913c39f8706.png"><br><br>  Right before you, there is a sufficiently high-quality approximation in the opinion of the algorithm.  There is nothing to blame him: convergence to the resulting polynomial is extremely slow, the standard deviation changes reluctantly, and due to the small number of starting points (only about two hundred), the distribution of residuals in the first approximation looks like normal. <br><br>  And so, in search of a universal criterion.  which would allow me to distinguish a random sequence from a regular sequence (I know that this is a whole problem, but still), the idea came to use fractals.  The fact is that the dimension of a random walk = 1.5.  It is hoped that by calculating the dimension of the discrepancy curve, we get 1.5 + - reasonable values. <br><br>  To calculate the Hausdorff dimension is still an idea, but with Minkowski everything is much simpler, although I had to sweat with it. <br><br>  Let us apply the approach used in the starting article: changing the scale, we will count the number of rectangles N through which the curve passes.  Having obtained the dependence log (N (e)) / log (e), we approximate directly with the help of the OLS.  The metric we seek is the slope coefficient. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;KeyValuePair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; dataList</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> minY = Double.MaxValue, maxY = Double.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> minX = minY, maxX = maxY; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dataList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minY &gt; pair.Value) minY = pair.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxY &lt; pair.Value) maxY = pair.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minX &gt; pair.Key) minX = pair.Key; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxX &lt; pair.Key) maxX = pair.Key; } m_bottomLeftY = minY; m_bottomLeftX = minX; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calculate(dataList, maxX, maxY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;KeyValuePair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; dataList, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxY</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dataList.Count() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scaleNumber = StartSize; scaleNumber !=FinishSize; ++scaleNumber){ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> XScale = (maxX - m_bottomLeftX) / scaleNumber; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> YScale = (maxY - m_bottomLeftY) / scaleNumber; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enumerator = dataList.GetEnumerator(); fillBoxes( (<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = enumerator.MoveNext(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { x = enumerator.Current.Key; y = enumerator.Current.Value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }, XScale, YScale); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = calculatedNumberBoxesAndReset(scaleNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count == <span class="hljs-number"><span class="hljs-number">0</span></span>) count = <span class="hljs-number"><span class="hljs-number">1</span></span>; m_boxesNumber[scaleNumber - StartSize] = Math.Log(count); } m_linearApproximator.approximate(m_scaleArgument, m_boxesNumber); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_linearApproximator.resultPolinomal.a[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> m_bottomLeftX, m_bottomLeftY;</code> </pre> <br>  Unlike the original article, I do not scale up exponentially, but in arithmetic, there is too little data for the first.  <i>m_linearApproximator</i> is a wrapper over the OLS, nothing clever and complex, and the OLS itself can be found either in the original article.  either in MathNet.Numerics.  The line <i>if (count == 0) count = 1</i> arose due to the implementation.  It covers the case when we have only one point. <br><br>  All magic is in the fillBoxes method, this is where the squares are filled: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillBoxes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GetDataDelegate dataIterator, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stepX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stepY</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> prevX=<span class="hljs-number"><span class="hljs-number">0</span></span>, prevY=<span class="hljs-number"><span class="hljs-number">0</span></span>, targetX=<span class="hljs-number"><span class="hljs-number">0</span></span>, targetY=<span class="hljs-number"><span class="hljs-number">0</span></span>; dataIterator(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prevX, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prevY); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexY = FinishSize, indexX = FinishSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentIndexX= calculateIndex(m_bottomLeftX, stepX, prevX), currentIndexY =calculateIndex(m_bottomLeftY, stepY, prevY) ; m_Boxes[currentIndexY, currentIndexX] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] CrossPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (dataIterator(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> targetX, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> targetY)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prevX == targetX &amp;&amp; prevY == targetY) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isBottom = targetY - prevY &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLeft = targetX - prevX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a = (targetY - prevY) / (targetX - prevX), fracA=<span class="hljs-number"><span class="hljs-number">1</span></span>/a; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> b = targetY - a * targetX; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> leftBorder = m_bottomLeftX + currentIndexX * stepX, bottomBorder = m_bottomLeftY + currentIndexY * stepY; CrossPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (leftBorder + (isLeft ? <span class="hljs-number"><span class="hljs-number">0</span></span> : stepX)) * a + b; CrossPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (bottomBorder + (isBottom ? <span class="hljs-number"><span class="hljs-number">0</span></span> : stepY) - b) * fracA; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( (targetY &lt; CrossPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>] == isBottom &amp;&amp; Math.Abs(targetY - CrossPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>]) / stepY &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) || (targetX &lt; CrossPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>] == isLeft &amp;&amp; Math.Abs(targetX - CrossPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>]) / stepX &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) )<span class="hljs-comment"><span class="hljs-comment">//    ? { if ( (bottomBorder - CrossPosition[0])/stepY &lt;= 1E-9 &amp;&amp; (CrossPosition[0] - bottomBorder - stepY)/stepY &lt;= 1E-9) currentIndexX += isLeft ? -1 : 1; if ( (leftBorder-CrossPosition[1])/stepX &lt;= 1E-9 &amp;&amp; (CrossPosition[1] -leftBorder - stepX)/stepX &lt;= 1E-9 ) currentIndexY += isBottom ? -1 : 1; m_Boxes[currentIndexY, currentIndexX] = true; leftBorder = m_bottomLeftX + currentIndexX * stepX; bottomBorder = m_bottomLeftY + currentIndexY * stepY; CrossPosition[0] = (leftBorder + (isLeft ? 0 : stepX)) * a + b; CrossPosition[1] = (bottomBorder + (isBottom ? 0 : stepY) - b) * fracA; } prevY = targetY; prevX = targetX; } }</span></span></code> </pre><br>  The raw data for me is a collection of points.  The only thing that is known is that the process being measured is continuous, but the process itself is completely arbitrary: to random interference of different powers, interference can arise and disappear.  In this case, the only way out is linear interpolation.  As a consequence of the smallness of the input data, errors associated with the passage of a straight line through a lattice site are unacceptable. <br><br>  Given these conditions, a universal solution that allows extension to any dimension is a step-by-step transition from square to square.  (Immediately I warn you, the code shown does not take into account cases when the straight line is vertical or horizontal) <br><br><div class="spoiler">  <b class="spoiler_title">Whole class</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MinkowskiDimension</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MinkowskiDimension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> finishSzie</span></span></span><span class="hljs-function">)</span></span> { StartSize = startSize; FinishSize = finishSzie; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MinkowskiDimension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> StartSize { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_startSize; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { m_startSize = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_startSize &lt; m_finishSize) { m_scaleArgument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[m_finishSize - m_startSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != m_scaleArgument.Count(); ++i) m_scaleArgument[i] = - Math.Log(m_startSize + i); m_boxesNumber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[m_scaleArgument.Count()]; } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_startSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FinishSize { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_finishSize; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { m_finishSize = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; m_Boxes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_startSize &lt; m_finishSize) { m_scaleArgument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[m_finishSize - m_startSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != m_scaleArgument.Count(); ++i) m_scaleArgument[i] = Math.Log(m_startSize + i); m_boxesNumber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[m_scaleArgument.Count()]; } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_finishSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] m_scaleArgument; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] m_boxesNumber; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;KeyValuePair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; dataList</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> minY = Double.MaxValue, maxY = Double.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> minX = minY, maxX = maxY; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dataList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minY &gt; pair.Value) minY = pair.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxY &lt; pair.Value) maxY = pair.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minX &gt; pair.Key) minX = pair.Key; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxX &lt; pair.Key) maxX = pair.Key; } m_bottomLeftY = minY; m_bottomLeftX = minX; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calculate(dataList, maxX, maxY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;KeyValuePair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; dataList, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxY</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dataList.Count() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scaleNumber = StartSize; scaleNumber !=FinishSize; ++scaleNumber){ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> XScale = (maxX - m_bottomLeftX) / scaleNumber; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> YScale = (maxY - m_bottomLeftY) / scaleNumber; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enumerator = dataList.GetEnumerator(); fillBoxes( (<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = enumerator.MoveNext(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { x = enumerator.Current.Key; y = enumerator.Current.Value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }, XScale, YScale); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = calculatedNumberBoxesAndIbit(scaleNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count == <span class="hljs-number"><span class="hljs-number">0</span></span>) count = <span class="hljs-number"><span class="hljs-number">1</span></span>; m_boxesNumber[scaleNumber - StartSize] = Math.Log(count); } m_linearApproximator.approximate(m_scaleArgument, m_boxesNumber); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_linearApproximator.resultPolinomal.a[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> m_bottomLeftX, m_bottomLeftY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillBoxes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GetDataDelegate dataIterator, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stepX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stepY</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> prevX=<span class="hljs-number"><span class="hljs-number">0</span></span>, prevY=<span class="hljs-number"><span class="hljs-number">0</span></span>, targetX=<span class="hljs-number"><span class="hljs-number">0</span></span>, targetY=<span class="hljs-number"><span class="hljs-number">0</span></span>; dataIterator(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prevX, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prevY); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexY = FinishSize, indexX = FinishSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentIndexX= calculateIndex(m_bottomLeftX, stepX, prevX), currentIndexY =calculateIndex(m_bottomLeftY, stepY, prevY) ; m_Boxes[currentIndexY, currentIndexX] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] CrossPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (dataIterator(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> targetX, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> targetY)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prevX == targetX &amp;&amp; prevY == targetY) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isBottom = targetY - prevY &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLeft = targetX - prevX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a = (targetY - prevY) / (targetX - prevX), fracA=<span class="hljs-number"><span class="hljs-number">1</span></span>/a; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> b = targetY - a * targetX; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> leftBorder = m_bottomLeftX + currentIndexX * stepX, bottomBorder = m_bottomLeftY + currentIndexY * stepY; CrossPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (leftBorder + (isLeft ? <span class="hljs-number"><span class="hljs-number">0</span></span> : stepX)) * a + b; CrossPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (bottomBorder + (isBottom ? <span class="hljs-number"><span class="hljs-number">0</span></span> : stepY) - b) * fracA; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( (targetY &lt; CrossPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>] == isBottom &amp;&amp; Math.Abs(targetY - CrossPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>]) / stepY &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) || (targetX &lt; CrossPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>] == isLeft &amp;&amp; Math.Abs(targetX - CrossPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>]) / stepX &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) )<span class="hljs-comment"><span class="hljs-comment">//    ? { if ( (bottomBorder - CrossPosition[0])/stepY &lt;= 1E-9 &amp;&amp; (CrossPosition[0] - bottomBorder - stepY)/stepY &lt;= 1E-9) currentIndexX += isLeft ? -1 : 1; if ( (leftBorder-CrossPosition[1])/stepX &lt;= 1E-9 &amp;&amp; (CrossPosition[1] -leftBorder - stepX)/stepX &lt;= 1E-9 ) currentIndexY += isBottom ? -1 : 1; m_Boxes[currentIndexY, currentIndexX] = true; leftBorder = m_bottomLeftX + currentIndexX * stepX; bottomBorder = m_bottomLeftY + currentIndexY * stepY; CrossPosition[0] = (leftBorder + (isLeft ? 0 : stepX)) * a + b; CrossPosition[1] = (bottomBorder + (isBottom ? 0 : stepY) - b) * fracA; } prevY = targetY; prevX = targetX; } } int calculateIndex(double startvalue, double scale, double value) { double index = (value - startvalue) / scale; int intIndex = (int) index; return Math.Abs(index - intIndex) &gt; 1E-9 || intIndex ==0 ? intIndex: intIndex -1; } int calculatedNumberBoxesAndIbit(int currentScaleSize) { int result=0; for (int i = 0; i != currentScaleSize; ++i) { for (int j = 0; j != currentScaleSize; ++j) { if (m_Boxes[i, j]){ ++result; m_Boxes[i, j] = false; } } } return result; } bool[,] m_Boxes; PolinomApproximation m_linearApproximator = new PolinomApproximation(1); }</span></span></code> </pre><br></div></div><br><br>  Let's test it on all possible lines: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lineDimensionTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_calculator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MinkowskiDimension(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List &lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = m_calculator.calculate(data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(result - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) Assert.Fail(); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>)); result = m_calculator.calculate(data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(result - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) Assert.Fail(); data.Clear(); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-5</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-9</span></span>)); result = m_calculator.calculate(data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(result - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) Assert.Fail(); data.Clear(); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-9</span></span>)); result = m_calculator.calculate(data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(result - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) Assert.Fail(); }</code> </pre><br>  It works and it is good.  Let's take a square now.  Argh, ran into what I warned about.  But it does not matter, let's turn the square upside down, and then add degenerate cases: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squareDimensiontest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m_calculator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MinkowskiDimension(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); data.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = m_calculator.calculate(data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(result - <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1E-9</span></span>) Assert.Fail(); }</code> </pre><br>  Result <b>1.1</b> .  Brr, what a strange thing.  But no, of course, 2 is for a flat figure, for a rectangle, and not for its contour.  Well, it is clear.  Let's add a number of scales;  1.05;  add more;  aim for the unit. <br><br>  It turns out that for a finite union of sets, the Minkowski dimension is the maximum for the dimension of each of the sets.  Those.  for a collection of direct dimensionality <b>1</b> .  In other words, our result is absolutely correct. <br><br>  Well, now you can prove that Popes is no different from the square.  Since  we represent the contour straight, then our area is divided either into a triangle or a square.  about the square, we all know.  What is the dimension of Minkowski at the square, we know - 2. And the triangle? <br><br><img src="http://latex.codecogs.com/gif.latex?\lim\limits_{\epsilon\to0}\frac{-\ln(N_\epsilon)}{\ln(\epsilon)}=\lim\limits_{\epsilon\to0}\frac{\ln&amp;space;0.5&amp;space;a-\ln\epsilon^2}{-\ln\epsilon}=2" alt="image"><br><br>  It is not strange, but also two.  This, by the way, breaks the assumption in the original article that the fractal dimension reflects the non-smoothness of the curve.  But this is by the way, the main thing is that in the end, the digitized pop Popes has the maximum dimension of 2 and 2. <br><br>  Another interesting example.  What is the dimension of the circle? <br><br><img src="http://latex.codecogs.com/gif.latex?\lim\limits_{\epsilon\to0}\frac{-\ln(N_\epsilon)}{\ln(\epsilon)}=\lim\limits_{\epsilon\to0}\frac{\ln&amp;space;\pi&amp;space;a-\ln\epsilon^2}{-\ln\epsilon}=2" alt="image"><br>  Too two.  And the circle? <br><img src="http://latex.codecogs.com/gif.latex?\lim\limits_{\epsilon\to0}\frac{-\ln(N_\epsilon)}{\ln(\epsilon)}=\lim\limits_{\epsilon\to0}\frac{\ln&amp;space;\pi&amp;space;a-\ln\epsilon}{-\ln\epsilon}=1" alt="image"><br><br>  Total: a circle, a square and a triangle (and Pope Lopez) are indistinguishable in us, this introduces serious difficulties in the model interpretation for the fractal dimension.  Classical interpolation between the data on a straight line results in that the dimensions of the contour tend to 1, and the area to two.  From this it is obvious that without some knowledge of a priori, its calculation loses its meaning.  Well, our small test also showed that the orientation of a complex curve introduces strong perturbations in our calculations, and their evaluation is extremely difficult without understanding what the parameter itself shows. </div><p>Source: <a href="https://habr.com/ru/post/264451/">https://habr.com/ru/post/264451/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264441/index.html">ARM programming on Pascal</a></li>
<li><a href="../264443/index.html">Parsing a Word document to pictures or a story about pre-diploma weekdays</a></li>
<li><a href="../264445/index.html">How does ecology affect data center cooling</a></li>
<li><a href="../264447/index.html">The realities of SharePoint migration to the cloud</a></li>
<li><a href="../264449/index.html">Cloud for developer companies, release one: Azure Marketplace - a store of services and solutions for every taste</a></li>
<li><a href="../264453/index.html">Cyber ‚Äã‚Äãgroup Hacking Team specialized in compromising Apple iDevice without jailbreak</a></li>
<li><a href="../264455/index.html">Anti-virus network for Virusday sites introduces a single tariff: 1499/149 rubles for 1 site per year</a></li>
<li><a href="../264457/index.html">Why NASA abandoned Unity in favor of Blend4Web</a></li>
<li><a href="../264459/index.html">The digest of news from the world of development on Unity</a></li>
<li><a href="../264461/index.html">Gartner analysts include HP among the ‚Äúvisionaries‚Äù in their ‚ÄúMagic Quadrant‚Äù on data center network infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>