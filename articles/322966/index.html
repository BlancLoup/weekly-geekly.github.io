<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL libpq connection pool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To work with PostgreSQL in C ++, there is a great library libpq. The library is well documented, there is even a full translation into Russian, from t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL libpq connection pool</h1><div class="post__text post__text-html js-mediator-article">  To work with PostgreSQL in C ++, there is a great library libpq.  The library is well documented, there is even a full translation into Russian, from the <a href="https://postgrespro.ru/docs/postgresql/9.6/libpq">PostgresPRO</a> company. <br><br>  When writing a server backend, I ran into the fact that there was no connection pool in this library, and work from the database was assumed to be quite intensive and one connection was obviously not enough.  To establish a connection each time to send the received data would be insane, because  connection is the longest operation, it was decided to write my own pool of connections. <br><a name="habracut"></a><br>  The idea is that at the start of the program we create several connections and store them in a queue. <br><br>  When the data arrives, we simply take the free connection from the queue, and if there are no free connections, wait for it to appear, use it to insert the data, and then put the connection back.  The idea is quite simple, quick to implement and, most importantly, the speed of work is very high. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's create a database in PostgreSQL called demo, with a demo sign like this <br><br><div class="spoiler">  <b class="spoiler_title">structures</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- Table: public.demo -- DROP TABLE public.demo; CREATE TABLE public.demo ( id integer NOT NULL DEFAULT nextval('demo_id_seq'::regclass), name character varying(256), CONSTRAINT demo_pk PRIMARY KEY (id) ) WITH ( OIDS=FALSE ); ALTER TABLE public.demo OWNER TO postgres;</span></span></code> </pre> <br></div></div><br>  We write the class that will be a connection to the database, the connection parameters will be written directly in the code to simplify it, in reality, of course, they must be stored in the configuration file and read from there when starting, so that when the server parameters change, you do not have to recompile the program. <br><br><div class="spoiler">  <b class="spoiler_title">pgconnection.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PGCONNECTION_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PGCONNECTION_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;mutex&gt; #include &lt;libpq-fe.h&gt; class PGConnection { public: PGConnection(); std::shared_ptr&lt;PGconn&gt; connection() const; private: void establish_connection(); std::string m_dbhost = "localhost"; int m_dbport = 5432; std::string m_dbname = "demo"; std::string m_dbuser = "postgres"; std::string m_dbpass = "postgres"; std::shared_ptr&lt;PGconn&gt; m_connection; }; #endif //PGCONNECTION_H</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">pgconnection.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pgconnection.h"</span></span></span><span class="hljs-meta"> PGConnection::PGConnection() { m_connection.reset( PQsetdbLogin(m_dbhost.c_str(), std::to_string(m_dbport).c_str(), nullptr, nullptr, m_dbname.c_str(), m_dbuser.c_str(), m_dbpass.c_str()), &amp;PQfinish ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (PQstatus( m_connection.get() ) != CONNECTION_OK &amp;&amp; PQsetnonblocking(m_connection.get(), 1) != 0 ) { throw std::runtime_error( PQerrorMessage( m_connection.get() ) ); } } std::shared_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;PGconn&gt; PGConnection::connection() const { return m_connection; }</span></span></span></span></code> std :: to_string (m_dbport) .c_str (), nullptr, nullptr, m_dbname.c_str (), m_dbuser.c_str (), m_dbpass.c_str ()), &amp; PQfinish); <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pgconnection.h"</span></span></span><span class="hljs-meta"> PGConnection::PGConnection() { m_connection.reset( PQsetdbLogin(m_dbhost.c_str(), std::to_string(m_dbport).c_str(), nullptr, nullptr, m_dbname.c_str(), m_dbuser.c_str(), m_dbpass.c_str()), &amp;PQfinish ); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (PQstatus( m_connection.get() ) != CONNECTION_OK &amp;&amp; PQsetnonblocking(m_connection.get(), 1) != 0 ) { throw std::runtime_error( PQerrorMessage( m_connection.get() ) ); } } std::shared_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;PGconn&gt; PGConnection::connection() const { return m_connection; }</span></span></span></span></code> </pre><br></div></div><br>  To prevent possible resource leaks, we will store the connection in a smart pointer. <br><br>  In the constructor, we call the PQsetdbLogin function, which establishes a connection to the database, returning a pointer to the PGconn * connection and translate the connection into asynchronous mode of operation. <br><br>  Upon completion of the work, the connection must be removed by the PQfinish function, to which the pointer returned by the PQsetdbLogin function is passed.  Therefore, the last parameter in the m_connection.reset () call is the address of the &amp; PQfinish function.  When the smart pointer goes out of scope and the link counter is reset, it will call this function, thereby completing the connection correctly. <br><br>  Now we need a class that will create, store and manage the work of the pool of connections. <br><br><div class="spoiler">  <b class="spoiler_title">pgbackend.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PGBACKEND_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PGBACKEND_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;mutex&gt; #include &lt;string&gt; #include &lt;queue&gt; #include &lt;condition_variable&gt; #include &lt;libpq-fe.h&gt; #include "pgconnection.h" class PGBackend { public: PGBackend(); std::shared_ptr&lt;PGConnection&gt; connection(); void freeConnection(std::shared_ptr&lt;PGConnection&gt;); private: void createPool(); std::mutex m_mutex; std::condition_variable m_condition; std::queue&lt;std::shared_ptr&lt;PGConnection&gt;&gt; m_pool; const int POOL = 10; }; #endif //PGBACKEND_H</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">pgbackend.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;fstream&gt; #include &lt;sstream&gt; #include "pgbackend.h" PGBackend::PGBackend() { createPool(); } void PGBackend::createPool() { std::lock_guard&lt;std::mutex&gt; locker_( m_mutex ); for ( auto i = 0; i&lt; POOL; ++i ){ m_pool.emplace ( std::make_shared&lt;PGConnection&gt;() ); } } std::shared_ptr&lt;PGConnection&gt; PGBackend::connection() { std::unique_lock&lt;std::mutex&gt; lock_( m_mutex ); while ( m_pool.empty() ){ m_condition.wait( lock_ ); } auto conn_ = m_pool.front(); m_pool.pop(); return conn_; } void PGBackend::freeConnection(std::shared_ptr&lt;PGConnection&gt; conn_) { std::unique_lock&lt;std::mutex&gt; lock_( m_mutex ); m_pool.push( conn_ ); lock_.unlock(); m_condition.notify_one(); }</span></span></span></span></code> </pre><br></div></div><br>  In the createPool function, we create a pool of connections, I set up 10 connections.  Next, we create the PGBackend class, and work with it through the connection functions ‚Äî which returns the free connection to the database, and freeConnection ‚Äî which puts the connection back into the queue. <br><br>  All this works on the basis of conditional variables, if the queue is empty, then there are no free connections, and the stream falls asleep until it is awakened through a conditional variable. <br><br>  The simplest example that uses our backend with a pool of connections is given in the main.cpp file.  In the "combat conditions" you will of course have some kind of cycle of events, upon the occurrence of which you will work with the database.  I have this boost :: asio, which works asynchronously and accepting events from the network, writes everything to the database.  It is unnecessary to bring it here, so as not to complicate the idea with a pool of connections.  Here we simply create 50 threads that work with the server through one PGBackend instance. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;thread&gt; #include &lt;iostream&gt; #include "pgbackend.h" void testConnection(std::shared_ptr&lt;PGBackend&gt; pgbackend) { //   auto conn = pgbackend-&gt;connection(); std::string demo = "SELECT max(id) FROM demo; " ; PQsendQuery( conn-&gt;connection().get(), demo.c_str() ); while ( auto res_ = PQgetResult( conn-&gt;connection().get()) ) { if (PQresultStatus(res_) == PGRES_TUPLES_OK &amp;&amp; PQntuples(res_)) { auto ID = PQgetvalue (res_ ,0, 0); std::cout&lt;&lt; ID&lt;&lt;std::endl; } if (PQresultStatus(res_) == PGRES_FATAL_ERROR){ std::cout&lt;&lt; PQresultErrorMessage(res_)&lt;&lt;std::endl; } PQclear( res_ ); } //    pgbackend-&gt;freeConnection(conn); } int main(int argc, char const *argv[]) { auto pgbackend = std::make_shared&lt;PGBackend&gt;(); std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt; vec; for ( size_t i = 0; i&lt; 50 ; ++i ){ vec.push_back(std::make_shared&lt;std::thread&gt;(std::thread(testConnection, pgbackend))); } for(auto &amp;i : vec) { i.get()-&gt;join(); } return 0; }</span></span></span></span></code> </pre><br></div></div><br>  This is compiled with the command: <br><br><pre> <code class="bash hljs">g++ main.cpp pgbackend.cpp pgconnection.cpp -o pool -std=c++14 -I/usr/include/postgresql/ -lpq -lpthread</code> </pre> <br>  Be careful with the number of database connections - this parameter is set by the <a href="https://postgrespro.ru/docs/postgrespro/9.6/runtime-config-connection">max_connections (integer)</a> parameter. <br><br>  <a href="https://github.com/borisovs/pool">Source</a> </div><p>Source: <a href="https://habr.com/ru/post/322966/">https://habr.com/ru/post/322966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322952/index.html">Translation of an interview with Julian Dragos (Scala)</a></li>
<li><a href="../322954/index.html">Simple Python program for hyperbolic approximation of statistical data</a></li>
<li><a href="../322956/index.html">Exceptions in Windows x64. How it works. Part 2</a></li>
<li><a href="../322958/index.html">Material UI and A / B tests are outdated - the future is behind adaptive interfaces</a></li>
<li><a href="../322962/index.html">What to expect: US IT trends in 2017 in the government and public sector</a></li>
<li><a href="../322968/index.html">Carry round, square roll: the story of Javista</a></li>
<li><a href="../322972/index.html">Implementing Frameworx in the Telecom API</a></li>
<li><a href="../322976/index.html">The book "Linux in practice"</a></li>
<li><a href="../322978/index.html">The birth of a new algorithm called Broo and comparison with Brotli and the rest</a></li>
<li><a href="../322980/index.html">Why learning is a new procrastination</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>