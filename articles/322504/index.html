<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generation of polygonal maps for games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wanted to learn how to generate interesting game cards that would not necessarily be realistic, and also to try techniques that I hadn‚Äôt worked with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generation of polygonal maps for games</h1><div class="post__text post__text-html js-mediator-article">  I wanted to learn how to generate interesting game cards that would not necessarily be realistic, and also to try techniques that I hadn‚Äôt worked with before.  I usually create maps with a different structure.  What can be done with a thousand polygons instead of a million tiles?  Distinctly distinguishable areas for a player can be useful for gameplay: locations of cities, places of quests, areas for capturing or colonizing, landmarks, points for finding a path, zones with varying difficulty, etc.  I generated maps using polygons, and then rasterized them into such maps: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc6/892/546/dc689254640d14e87682cc531609fcf7.png" alt="image"><br><br>  Many procedural map generators, including some of my previous projects, use noise functions (midpoint displacement, fractals, diamond-square, Perlin noise, etc.) to generate the height map.  I did not use them here.  Instead, I used <strong>a graph structure</strong> to simulate the elements determined by gameplay restrictions (height, roads, river flow, quests, monster types) and <strong>noise functions</strong> to simulate what is not limited to gameplay (coastal shape, location of rivers and trees). <br><a name="habracut"></a><br>  In this project I wanted to achieve three main indicators: good coastlines, mountains and rivers.  For the coast, I wanted to create island maps surrounded by the ocean, so as not to handle the behavior of characters walking along the edge of the map.  For the mountains, I started with a simple one: the mountains I have are the farthest from the coastline, so you can always go up to reach the top.  I also started working with rivers from simple: I drew the rivers from the coast to the mountains, so that you could always walk along the rivers to the coast. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First <strong><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/demo.html">see the demo</a> !</strong>  (Flash) Read how it works, or open source code.  Here is a description of the process: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fab/517/4a1/fab5174a1ee1f8b9352df3cc823877a9.png" alt="image"><br>  <i>1. We start with the structure of graphs created from polygons.</i>  <i>2. Mark it up.</i>  <i>3a.</i>  <i>Output to polygons.</i>  <i>3b.</i>  <i>If necessary, output to the tiles.</i> <br><br>  Each project has its own gameplay restrictions.  For this project, restrictions are partly taken from the <a href="https://ru.wikipedia.org/wiki/Realm_of_the_Mad_God">Realm of the Mad God</a> .  This is a multiplayer RPG in which players start the game alone on the coast, and then team up on top of a mountain to fight the bosses.  The height is directly related to the complexity and should monotonously increase.  And this is a key design constraint.  On the other hand, the height in Minecraft is not limited in this way, so the noise function is suitable for this game.  In the multiplayer age of empires, the location of resources is limited so that there is a balance between the players.  In Minecraft, resource allocation is unlimited.  When creating your own map generator, think about which aspects of your map should be set deliberately and which should be different on different maps.  All the information presented in this article can be used together or separately for your own project generator. <br><br><h2>  Polygons </h2><br>  The first step is to generate the polygons.  The easiest way to do this is to use a grid of hexagons and slightly distort it so that it looks unusual.  This approach works (and the techniques from this article will work if you use a distorted grid), but I wanted to use something else more unusual, so I picked random points and generated <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE">Voronoi polygons</a> , which are used <a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DVoronoi_Applications">in many cases</a> , including to create maps.  <a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DVoroWiki_main_page">Wiki on the Voronoi diagram is</a> incomplete, but it has useful information.  I use <a href="http://nodename.github.com/as3delaunay/">the as3delaunay</a> nodename <a href="http://nodename.github.com/as3delaunay/">library</a> , which has <a href="http://en.wikipedia.org/wiki/Fortune%27s_algorithm">a Forchun algorithm</a> implementation. <br><br>  Here is an example of random points (red) and polygons created on their basis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e16/2f7/9d6/e162f79d6eaafe3eef1f2ac002741a7a.png" alt="image"><br><br>  The shapes and sizes of polygons are quite uneven.  Random numbers are more ‚Äúclumsy‚Äù than people normally expect.  I wanted to achieve something closer to half-random "blue noise" or to <a href="http://bit-player.org/2011/a-slight-discrepancy">pseudo-randomness</a> , and not to random points.  I approached the desired result using a variant of <a href="http://en.wikipedia.org/wiki/Lloyd%27s_algorithm">the Lloyd algorithm</a> , which is a fairly simple way to more evenly distribute random points.  Lloyd‚Äôs algorithm replaces each point with a <a href="http://en.wikipedia.org/wiki/Centroid">centroid of a</a> polygon.  In my code, I barely average the corners (see <code>improveRandomPoints</code> ).  Here is the result of the dual use of approximation by the Lloyd algorithm: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e5/0d4/f45/5e50d4f45047626c820257840682526c.png" alt="image"><br><br>  Compare with <a href="">one</a> and <a href="">fifty</a> runs of the algorithm.  The more iterations, the more uniform the polygons become.  Two runs allow me to get good results while maintaining variability in each game. <br><br>  The sizes of polygons are improved by moving the centers of polygons.  The same approach is applicable to improve the length of the ribs.  By moving the corners by averaging the nearby centers, we get more uniform lengths of the edges, but this degrades the size of the polygons.  See the <code>improveCorners</code> function in the code.  However, the moved angles lose the properties of the Voronoi diagram.  These properties are not used in my map generator, but do not forget about it if you want to use them in the game.  You can either improve the length of the edges, or maintain the properties of the Voronoi distances. <br><br>  Using Voronoi diagrams adds complexity, so if you want to start with something simpler, try a grid of squares or hexagons (they are in the demo).  The rest of the techniques of this article will work for grid-based maps.  You can also accidentally shift the vertices of the grid so that it looks a bit more natural. <br><br><h2>  Map presentation </h2><br>  I present the map in the form of two connected <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25BE%25D0%25B2">graphs</a> : nodes and edges.  The first graph contains the nodes of each polygon and edges between adjacent polygons.  It is a <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_%25D0%2594%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5">Delone triangulation</a> , useful when working with neighboring points (for example, when finding a path).  The second graph contains the nodes of the <em>corners of</em> each polygon and the edges between the corners.  It contains the shapes of the Voronoi polygons.  This graph is useful for everything related to forms (for example, for rendering borders). <br><br>  Two graphs are connected.  Each triangle in the Delaunay triangulation corresponds to the angle of the polygon in the Voronoi diagram.  Each polygon in the Voronoi diagram corresponds to the angle in the Delone triangle.  Each edge in the Delone graph corresponds to an edge in the Voronoi graph.  This can be seen from the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80e/cb0/7bf/80ecb07bf51746b2a26ce2962cc6287c.png" alt="image"><br><br>  Polygons <code>A</code> and <code>B</code> adjacent, so the adjacency graph has a (red) edge between <code>A</code> and <code>B</code>  So that they are adjacent, there must be a polygon edge between them.  The (blue) edge of the polygon connects angles <code>1</code> and <code>2</code> in the Voronoi form graph.  <em>Each</em> edge in an adjacency graph corresponds to exactly one edge in a form graph. <br><br>  In the Delaunay triangulation, the triangle <code>A</code> - <code>B</code> - <code>C</code> connects three polygons, and can be represented by an angle of <code>2</code> .  Therefore, the angles of Delaunay triangulation are polygons in the Voronoi diagram, and vice versa.  Here is a larger example showing the relationship: the centers of the Voronoi polygons are shown in red and the corners in blue, the Voronoi edges in white, and the Delaunay triangulation in black: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/ab7/5d5/ae9ab75d567bcc0cedaf70ede55e0998.png" alt="image"><br><br>  This duality means that you can represent both graphs together.  There are <a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DPAN_graphs">different approaches</a> to combining these two graphs.  In particular, the <a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DSpatial_Data_Structures">edges may be common</a> .  Each edge in a normal graph leads to two nodes.  Instead of representing two edges separately in two graphs, I created edge points to <em>four</em> nodes: two polygon centers and two corners.  This turned out to be very convenient for combining two graphs into one. <br><br>  In the combined view, you can apply information from the Relationships Between Grid Parts sections of my <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/">article about grids</a> .  I do not use grids, so I don‚Äôt assign grid coordinates, but many algorithms that apply grids are also applicable here (for either of the two graphs). <br><br>  In the code, the <code>graph/</code> directory contains three classes: <code>Center</code> , <code>Corner</code> and <code>Edge</code> : <br><br><ul><li>  <code>Center.neighbors</code> is a set of adjacent polygons. </li><li>  <code>Center.borders</code> - many bordering edges </li><li>  <code>Center.corners</code> - many polygon corners </li><li>  <code>Edge.d0</code> and <code>Edge.d1</code> - polygons connected by the Delone edge </li><li>  <code>Edge.v0</code> and <code>Edge.v1</code> - angles connected by a Voronoi edge </li><li>  <code>Corner.touches</code> - many polygons related to this angle </li><li>  <code>Corner.protrudes</code> - many edges related to the angle </li><li>  <code>Corner.adjacent</code> is the set of angles connected to this angle. </li></ul><br><h2>  Islands </h2><br>  The next step is drawing the shoreline.  The borders of the map should be water, but other polygons can be marked as water or land using any method you choose.  The condition of the coastline is the proximity of land and water. <br><br>  Here is an example of the division of the world into land and water: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/20f/bf3/eb020fbf3f7645fef171c86fd741e449.png" alt="image"><br><br>  In the source code, <code>Map.as</code> contains the base code for generating the map.  The <code>IslandFunction</code> code returns <code>True</code> if the position is land, and <code>False</code> if <code>IslandFunction</code> water.  The demo includes four functions of the island: <ul><li>  <code>Radial</code> uses sine waves to create a round island. </li><li>  <code>Perlin</code> uses <code>Perlin</code> noise to control the shape </li><li>  <code>Square</code> fills the entire map land </li><li>  <code>Blob</code> draws my <a href="">logo</a> . </li></ul><br>  You can use any shape, ( <a href="http://www.reddit.com/r/rpg/comments/187o0v/im_not_sure_what_other_folks_do_but_this_is_how_i/">even fat stains on the pizza box</a> ).  In the future version of this project, I hope to add a drawing tool that allows you to create your own forms. <br><br>  The code sets the land / water value for both the centers and the corners of the polygons: <br><br><ol><li>  Assign water / land for <em>corners by</em> installing <code>Corner.water</code> based on <code>IslandFunction</code> . </li><li>  We assign water / land to <em>polygons</em> by installing <code>Center.water</code> , if some of the corners have a set of <code></code> . </li></ol><p>  A simple fill, starting from the border of the map, can determine which areas of the water are oceans (connected to borders) and lakes (surrounded by land): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc2/e73/8a3bc2e7334e2ae259354c8cc8cc8366.png" alt="image"><br><br>  In the code, the fill is performed at the centers of the polygons, and then we decide what should happen to the corners: <br><br></p><ol><li>  Set <code>Center.ocean</code> for any polygon connected to the map boundaries through water polygons.  If <code>Center.water</code> installed, and <code>.ocean</code> is not, then the area is a lake. </li><li>  Set <code>Center.coast</code> if the landfill is land but has a border with the ocean.  Coastal areas will later be drawn as beaches. </li><li>  Set the <code>Corner.ocean</code> if the corner is surrounded by polygons of the ocean. </li><li>  Set the <code>Corner.coast</code> if the angle concerns the landfills of the ocean and land. </li><li>  We <code>Corner.water</code> to maintain integrity with the surrounding area. </li></ol><br><h2>  Height </h2><br>  It would be most realistic to first determine the heights and then define the coastline as the boundary where the height reaches sea level.  Instead, I'll start in the reverse order.  Take a good coastline, and I will begin to build on it.  I will define altitude as the <strong>distance from the coast</strong> .  Initially, I tried to make heights in the centers of polygons, but setting heights in the corners was more convenient.  The edges connecting the corners can serve as valleys and ridges.  After calculating the height of the corners ( <code>Corner.elevation</code> ), the height of the polygon ( <code>Center.elevation</code> ) is calculated as the average of the height of the corners.  See the <code>Map.assignCornerElevations</code> and <code>Map.assignPolygonElevations</code> . <br><br>  For water polygons the distance is not calculated.  Firstly, because I wanted the lakes to be flat, not sloping, and secondly, this is how valleys are formed around the lakes, which helps direct the rivers to the lakes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f51/c09/1ca/f51c091ca571e373746f6d0ba77f373b.png" alt="image"><br><br>  There was one problem with this simple definition: some islands had too many mountains, while others had too few.  To correct this, I redistributed the heights so that they corresponded to the desired distribution, at which there would be more land with a small height (coast) than with a large height (mountains).  First, I sorted the angles by height, and then dropped the <code>x</code> heights of each of them to match the desired distribution function: <code>y(x) = 1 - (1-x)^2</code> .  In <code>Map.redistributeElevations</code> , the <code>y</code> coordinate is the position in the sorted list, and <code>x</code> is the desired height.  Using the formula for the roots of a quadratic equation, we can calculate the value of <code>x</code> .  At the same time, order is maintained, i.e.  elevation always increases when moving from shore to mountains. <br><br>  When moving from any point downwards, we will definitely come to the ocean.  This diagram shows the direction of the steepest descent from each corner, stored in <code>Corner.downslope</code> : <p></p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/49d/4b2/dfc/49d4b2dfc24e1106a40c2eb1122eaced.png" alt="image"><br><br>  Following the down arrow, we will gradually come to the ocean.  This will be useful for rivers, but may also be useful for calculating <a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DRivers_and_watersheds">watersheds</a> and other characteristics. <br><br>  My height serves two main purposes: <ol><li>  Types of <strong>biomes</strong> : great heights become snowy, stony or tundra.  The average heights are shrubbery, deserts, forests or meadows.  Small heights become rain forests, meadows and beaches. </li><li>  <strong>Rivers</strong> flow from areas with high altitudes to the coast.  Our heights always increase with distance from the coast, that is, there are no local minima that complicate the generation of rivers. </li></ol><br>  In addition, in games you can find your own application of data about heights.  For example, in <a href="http://www.realmofthemadgod.com/">Realm of the Mad God</a> heights are used to distribute monsters. <br><br>  This calculation of heights is suitable for simple islands, this is exactly what I needed for Realm of the Mad God.  To generate continents, you will need to change this step to generate one or more mountain ranges that are not necessarily located in the center, as well as individual volcanoes. <br><br><h2>  Rivers </h2><br>  I wanted to use two sources of fresh water: rivers and lakes.  The most realistic would be to determine the humidity depending on wind, cloudiness, dampness and precipitation, and then calculate the locations of rivers and lakes.  Instead, I start again from the end, that is, from good rivers, and go back. <br><br>  The shape of the island determines the location of areas of water and land.  Lakes are polygons of water that are not oceans.  Rivers use the descent directions shown above.  I chose random locations of corners in the mountains, and then went down the <code>Corner.downslope</code> to the ocean.  The river flows from corner to corner: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac7/301/95c/ac730195c7fc61ae9d7a48b6f0569489.png" alt="image"><br><br>  I tried to allow both between the centers and between the corners of the polygons, but I found out that the graph of angles creates much more beautiful rivers.  In addition, the lakes remain flat, so that the heights near the lakes are usually smaller.  Therefore, rivers naturally flow in and out of lakes.  Several rivers may have a common mouth.  Each time a river flows across the edge, I increase the volume of water stored in <code>Edge.river</code> by 1. During rendering, the width of the river is the square root of the volume.  This approach is simple and works well. <br><br><h2>  Humidity </h2><br>  Since I am performing the process in the opposite direction, I do not need the humidity to determine the presence of rivers.  However, humidity can be useful in distinguishing between <strong>biomes</strong> (deserts, swamps, forests, etc.).  Since rivers and lakes should be formed in areas of high humidity, I decided that humidity would decrease with increasing <strong>distance to fresh water</strong> .  <code>Corner.moisture</code> defined as <code>a^k</code> , where <code>a</code> &lt;1 (for example, 0.95), and <code>k</code> is the distance.  Unfortunately, in <code>Map.assignCornerMoisture</code> there are settings that I had to adjust to make the maps look convincing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/015/af9/15c/015af915c3084aa87ac3864303ecc123.png" alt="image"><br><br>  As in the case of heights, I redistributed the humidity to match the desired distribution.  In this case, I wanted to have approximately the same amount of dry and wet areas.  The desired distribution function is <code>y(x) = x</code> , so the redistribution code is very simple.  I sort the corners by humidity, and then assign the humidity of each corner angle position in the sorted list.  See code in <code>Map.redistributeMoisture</code> . <br><br>  In this map generator, humidity is used only for biomes.  However, in games you can find humidity data for other uses.  For example, in <a href="http://www.realmofthemadgod.com/">Realm of the Mad God,</a> humidity and altitude are used to distribute vegetation and monsters. <br><br><h2>  Biomes </h2><br>  Altitudes and humidity together provide good variability for assigning biome types.  I use altitude as a substitute for temperature.  If I made a generator of continents, then latitude could influence the temperature.  In addition, wind, evaporation, and rain shadow areas could be used to carry moisture like damp.  However, for this generator, I took a simple principle.  First, biomes depend on where they are located, in water or on land: <br><br><ul><li>  <code></code> - this is any polygon of water, connected to the border of the map </li><li>  <code></code> - any polygon of water not connected to the border of the map.  <code></code> Lake is a lake at high altitude (low temperature).  <code></code> - low-altitude lake </li><li>  <code></code> - any land plot near the ocean </li></ul><br>  For all landforms, I started with <a href="http://www.marietta.edu/~biol/biomes/biome_main.htm">the Whittaker diagram</a> and adapted it to fit my needs: <br><table><thead><tr><th rowspan="2">  Zone <br>  heights </th><th colspan="6">  Humidity zone </th></tr><tr><th>  6 <br>  (wet) </th><th>  five </th><th>  four </th><th>  3 </th><th>  2 </th><th>  one <br>  (dry) </th></tr></thead><tbody><tr><th>  four <br>  (high) </th><td colspan="3"> <code></code> </td> <td> <code></code> </td> <td> <code> </code> </td> <td> <code></code> </td> </tr><tr><th>  3 </th><td colspan="2"> <code></code> </td> <td colspan="2"> <code> </code> </td> <td colspan="2"> <code> </code> </td> </tr><tr><th>  2 </th><td> <code>  </code> </td> <td colspan="2"> <code>  </code> </td> <td colspan="2"> <code></code> </td> <td> <code> </code> </td> </tr><tr><th>  one <br>  (low) </th><td colspan="2"> <code>  </code> </td> <td colspan="2"> <code>  </code> </td> <td> <code></code> </td> <td> <code> </code> </td> </tr></tbody></table>  Here is the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fc/6e3/2fa/5fc6e32fada39a648948bbe9b7e17eff.png" alt="image"><br><br>  These biomes look good in the demo, but each game will have its own needs.  For example, in the <a href="http://www.realmofthemadgod.com/">Realm of the Mad God,</a> these biomes are ignored and their own biomes are used (based on height and humidity). <br><br><h2>  Noisy ribs </h2><br>  For some games, polygonal maps are enough.  However, in others the polygonal structure needs to be hidden.  The main way to do this is to replace the borders of the polygons with a noisy line.  Why did I create a polygonal structure if I am going to hide it?  I think the mechanics of the game and the algorithm for finding ways will benefit from having an internal structure. <br><br>  Recall that earlier we had <em>two</em> graphs: one for the Voronoi corners ( <code>1</code> , <code>2</code> in the diagram below) and edges (blue lines), and the other for the centers of polygons ( <code>A</code> , <code>B</code> ) and Delone edges (red lines) between them: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80e/cb0/7bf/80ecb07bf51746b2a26ce2962cc6287c.png" alt="image"><br><br>  I wanted to make both types of lines noisy so that they would not cross lines from other polygons.  In addition, I wanted them to be noisy and believable.  I realized that points <code>A</code> , <code>1</code> , <code>B</code> and <code>2</code> form a quadrilateral, and it is possible to limit the deviations of a line segment by this quadrilateral: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/784/2c0/6f57842c0cdca5e0a521d5853e348b48.png" alt="image"><br><br>  I divided the quadrilateral into four quadrilaterals.  Two could be used for the red rib (Delone), and two for the blue rib (Voronoi).  Since the lines remain in their allocated space and are connected in the center, they will never intersect.  So we have limited them.  Note that a quadrilateral may not be convex.  To divide it correctly, I divided it from the middle of the Voronoi rib instead of dividing at the intersection of the Voronoi and Delone edges. <br><br>  The whole map can be divided into areas of quadrangles between which there will be no empty space: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd8/7bd/3a9/bd87bd3a9504545fc10d5edeb3c9ac59.png" alt="image"><br><br>  This ensures that noisy lines will not be unnecessarily restricted.  (I wonder if these quadrangles can be useful in game mechanics?) <br><br>  You can use any noisy line algorithm that satisfies these limitations.  I decided to recursively subdivide the quadrilaterals and connect the line segments in small quadrilaterals into a full edge.  The algorithm is in <code>NoisyEdges.as</code> , the <code>buildNoisyLineSegments</code> function.  As a result, the edges of the polygons become curved: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9aa/eb5/1c9/9aaeb51c95bb1d9e474f4e062ee51e25.png" alt="image"><br><br>  You can adjust the noise in three places: <br><br><ol><li>  The results of the recursive function become segments smaller than a certain length.  I have an example of the <a href="">length of segment 7</a> , the <a href="">length of segment 4</a> and the <a href="">length of segment 1</a> .  In the demo maps, I used the size of the segment 1 for rivers and coasts, 3 in places of meeting biomes, and 10 in all other cases. </li><li>  There is a ratio between what space is given under the red quadrilaterals (Delone edges) and the blue quadrilaterals (Voronoi edges).  I chose a ratio of 0.5 in <code>NoisyEdges.NOISY_LINE_TRADEOFF</code> . </li><li>  In <code>NoisyEdges.subdivide</code> there is a range of random numbers.  In my demo, the selected range is 0.2-0.8, but it can be in the range of 0.0‚Äì1.0.  In addition, random numbers do not have to be linear.  More visual noise is obtained by avoiding a gap of about 0.5. </li></ol><br>  It turned out that noisy ribs strongly influence the appearance of the map, especially rivers and coastlines. <br><br><h2>  More noise </h2><br>  I usually like the <a href="http://simblob.blogspot.com/2009/06/noise-in-game-art.html">noise in the game art</a> , and I wanted to add some more noise to the maps.  In a real game map, noise may reflect vegetation or slight variations in topography.  In the demo ( <code>mapgen2.as</code> ), I filled the screen with a random noise texture, placing a noisy bitmap over the map.  I also smoothed the boundaries between neighboring polygons, gradually mixing colors: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a5/25a/50f/3a525a50f7305976f8ddd375e9487cf7.png" alt="image"><br><br>  Here is the result of rendering with 16,000 polygons, noisy edges, superimposed noisy texture and simple lighting: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc6/892/546/dc689254640d14e87682cc531609fcf7.png" alt="image"><br><br><h2>  Smooth transitions between biomes </h2><br>  Another way to mix biomes at the boundaries of polygons is to create gradients based on the height and humidity of each corner with the pixel-like biome assignment: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b3/432/169/7b343216919cb73431f43a247e1d5d8d.png" alt="image"><br><br>  If the game does not require the entire polygon to belong to the same biome, then this approach may be useful for creating more interesting boundaries. <br><br><h2>  Distorted Biome Transitions </h2><br>  Another way to make the map less polygonal is to distort the height and humidity maps: <br><br><ol><li>  Add Pearlin noise or random noise to the height and humidity of each pixel. </li><li>  Sample nearest points using Perlin or random noise to change coordinates. </li></ol><br>  Here is an example of how this can be achieved: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/780/ba3/1a2/780ba31a296e7d7d576597ad2cc616ba.png" alt="image"><br><br>  Adding noise to the height and humidity creates "fluctuations" in the areas near the transitions.  Sampling nearby points using noise distorts the shape of the borders. <br><br><h2>  Demo </h2><br>  To study the generated maps, I wrote a demo in Flash: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a4/327/e08/7a4327e0861cb1ea30834449fc2eb773.png" alt="image"><br><br>  <strong><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/demo.html">Try the demo</a> !</strong> <br><br><h2>  Source </h2><br>  I posted the sources on Actionscript under the MIT license, they <a href="https://github.com/amitp/mapgen2">are available on github</a> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you can read Java or Javascript, then I think you can figure it out with Actionscript. </font><font style="vertical-align: inherit;">I do not expect that the code will immediately become useful for everyone, but it can be a good starting point if you want to use these techniques to create your own game maps.</font></font><br><br><ul><li> <code>Map.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is the basic card generation system </font></font></li><li> <code>graph/*.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - graph representation (polygons, edges, angles) </font></font></li><li> <code>mapgen2.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - demo with rendering and GUI </font></font></li><li> <code>Roads.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - module adding roads along contour lines </font></font></li><li> <code>Lava.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - module that adds rifts with lava on the ribs with high altitude </font></font></li><li> <code>NoisyEdges.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used in the demo to create noisy edges </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The diagrams in this article are created from 300 polygons, by default, the demo uses 2000 with a maximum of 8000. Some of the code for creating diagrams was not checked, because it is ‚Äúfast and dirty‚Äù code written only for the diagrams of this article and is otherwise useless. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the code or my thoughts seem useful to you, I will be glad to know about it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projects investigating other algorithms </font></font></h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andy Gainey experimented with Voronoi diagrams on the sphere and decided instead to </font></font><a href="http://experilous.com/1/blog/post/procedural-planet-generation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create a map of subdivided icosahedra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with tectonic plates, air currents, temperature, humidity and biomes. </font><font style="vertical-align: inherit;">I was asked how to expand my map generator to create continents: it‚Äôs worth exploring the Andy project.</font></font></li><li>  <a href="http://mewo2.com/notes/terrain/">   ' (Martin O'Leary)   </a>       ,  ,  ,  /,      . <a href="https://heredragonsabound.blogspot.com/2016/10/welcome.html">  (Scott Turner)</a>   <a href="http://imgur.com/gallery/z2hnk"></a> ,    <a href="http://imgur.com/a/rVI6F"> </a> ,    2016    .   (Ryan Guy)  <a href="https://github.com/rlguy/FantasyMapGenerator">    </a> . </li><li> <a href="http://procworld.blogspot.com/2011/07/political-landscape.html">  (Miguel Cepero)  Voxel Farm</a>           ,   <a href="http://procworld.blogspot.ca/2016/04/geometry-is-destiny.html">     </a>     . </li><li>   (Tommy Waters)  <a href="http://eveliosdev.blogspot.com.au/2016/06/plate-tectonics.html"> </a> .  ,   ,    ,           . </li><li> ylcorcronlth  <a href="https://www.reddit.com/r/proceduralgeneration/comments/4wyida/random_walk_based_moisture_distribution/">     </a> </li><li>   (Cory Lee)  <a href="https://github.com/iskar909/political-map-generator">  </a>    . </li><li>   (Jesse Morgan)  ,        <a href="http://citygenerator.morgajel.net/"> </a> ( <a href="https://plus.google.com/112661873200782342936/posts"> </a>  <a href="https://github.com/CityGenerator/CityGenerator"> </a> ) </li><li>  Sword &amp; Scroll  <a href="http://www.indiedb.com/games/sword-scroll/news/progress-report-6">      </a> ( ) </li><li>   (Phill Spiess)    <a href="http://devblog.phillipspiess.com/projects/mapgen/"> </a>     ,    . </li><li>    (Christophe Le Besnerais)  <a href="">Javascript-</a>     . luckylooke   <a href="http://luckylooke.github.io/phaser-islandjs-plugin/"> Phaser.io</a> . </li><li>    (Kaelan Cooter)  <a href="http://blog.kaelan.org/hexagon-world-map-generation/">    </a>  , , , ,    . </li></ul><br><h3>       </h3><br><ul><li>   (Richard Janicek)  <a href="https://github.com/rjanicek/voronoi-map-haxe">Haxe-</a> ,   Javascript+Canvas  <a href="http://rjanicek.github.com/voronoi-map-haxe/"></a> .    <a href="https://github.com/rjanicek/voronoi-map-js">Javascript-</a>  . </li><li>   (Jeff Terrace)    <a href="https://github.com/jterrace/mapgen2/tree/utilities">   XML  COLLADA</a> ,   <a href="https://github.com/jterrace/collada2json">   COLLADA</a>  WebGL. </li><li>   (Alex Schr√∂der)   <a href="http://www.flickr.com/photos/kensanata/5685579540/">Perl-</a> ,     SVG. </li><li>   (Christopher Garrett)  <a href="https://github.com/czgarrett/delaunay-ios"> Voronoi/Delaunay  iOS</a> . </li><li>   (Adam Martin)   <a href="https://github.com/adamgit/Unity-delaunay"> Voronoi/Delaunay  Unity</a> ,   <a href="https://github.com/jceipek/Unity-delaunay">   (Julian Ceipek)</a> . </li><li>   (Christophe Guebert)  <a href="http://www.openprocessing.org/visuals/%3FvisualID%3D30809"> Java+Processing</a> . </li><li>   (Baran Kahyaoglu)  <a href="http://www.barankahyaoglu.com/blog/post/2012/04/28/Map-Generator-source-code-is-available-now!.aspx">  C#/.NET</a> ( <a href="https://bitbucket.org/brnkhy/mapgeneratorxna"> </a> ),  abhimir  <a href="https://github.com/abhimir/UnitySimpleMapGenerator">Unity-</a>   , <a href="http://gamedev.stackexchange.com/users/4708/chrish">   (Chris Herborth)</a> . </li><li>    (Tommy Waters)  <a href="https://github.com/Evelios/procIsland">  Javascript-</a>  <a href="https://github.com/Evelios/procIsland"></a>  <a href="http://eveliosdev.blogspot.com.au/2016/06/breathing-life-into-map.html">  </a> . </li><li>    <a href="https://github.com/zaynyatyi/voronoi-map-nme">  Haxe/NME</a> . </li><li>    (Connor Clark)  <a href="https://github.com/Hoten/Java-Delanuay">Java-</a> . </li><li> Kylepixel  <a href="https://github.com/kylepixel/terrain-generator">  Javascript</a> ,         . </li><li>  Nuclear Horse Studios  <a href="http://nuclearhorsestudios.com/">  C#/Unity</a> ( MIT). </li><li>   (Stafford Williams)  <a href="https://github.com/staff0rd/polygon-map-unity">  C#/Unity</a> ( MIT). </li><li>    (Gareth Higgins)  <a href="https://github.com/Zaneo/VoronoiMapGen">   C#</a> . </li><li>     (Mart√≠n Candela Calabuig) <a href="https://github.com/Rellikiox/MapGenerator">  C++</a> . </li><li>  (Tobias)   <a href="https://twitter.com/tobmansf/status/540617232326619136">  C++</a> </li><li>   (Spencer Judge)  <a href="https://github.com/Sushisource/DnDTG"> C++</a>       . </li><li>  BitAlchemists  <a href="http://bitalchemists.github.io/polygon_map/">  Dart</a> . </li><li>   .  (Thomas R. Koll)  <a href="https://github.com/tomk32/mapgen2">  Lua</a> ,     <a href="http://apri50.com/">Autonomous Planetary Research Individual 50</a> . </li><li> <a href="https://github.com/ace-design/island/">Island</a> ‚Äî    Scala,  ,      . </li><li> <a href="https://github.com/feelic/PtolemyJS">PtolemyJS</a> ‚Äî    Javascript        . </li><li>   (Jay Stevens)  <a href="https://github.com/Jay2645/Unreal-Polygonal-Map-Gen">  C++  Unreal 4</a> ( MIT). </li></ul><br><h3>  Other projects </h3><br><ul><li> <a href="https://github.com/Terasology/PolyWorld">PolyWorld</a>   Java-        Terasology (. <a href="https://www.youtube.com/watch%3Fv%3D7eOlKa9qa2Y"> </a> ). </li><li>  <a href="http://conquestgame.net/maps">Conquest</a>        . </li><li>  <a href="https://github.com/kdhillon/besiege">Besiege</a>       . </li><li>  <a href="http://terrafirmacraft.com/">TerraFirmaCraft 2</a>       . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This map generator was not intended for direct use, but in Welsh Piper ( </font></font><a href="http://www.welshpiper.com/nerd-therapy/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monster encounter tables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.welshpiper.com/minocra-campaign-map/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minocra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><a href="http://kingdomsintrevail.blogspot.com/2012/02/caldera-birth-of-world.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdoms in Trevail</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://crasta.wikia.com/wiki/Crasta"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cresta,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and other ( </font></font><a href="https://www.reddit.com/r/DnD/comments/2sbr7c/the_map_for_the_campaign_im_starting_tomorrow/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://www.reddit.com/r/DnD/comments/2st84s/just_made_my_first_overland_map_for_a_campaign/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.reddit.com/r/DnD/comments/2u5fjj/map_for_the_known_world_in_my_5e_campaign/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://www.reddit.com/r/imaginarymaps/comments/4w5fdy/i_created_an_island_with_cities_roads_railroads/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://www.reddit.com/r/worldbuilding/comments/4ypzih/give_me_some_feedback_on_my_worlds_map_my_biggest/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://www.reddit.com/r/imaginarymaps/comments/5kzzba/i_made_another_island_nation/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) games, the map generator is used to create maps . </font><font style="vertical-align: inherit;">Click the ‚Äúexport PNG‚Äù button to export a 2048x2048 PNG file, which you can then adapt to Photoshop for color, style, and markup.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appendix: Additional map features </font></font></h2><br><h3>  Modules </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried to structure the presentation of the maps so that the modules could mark them without creating dependencies on the code. The GUI module </font></font><code>mapgen2.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depends on </font></font><code>Map.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(base module) and </font></font><code>Roads.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(side module), but </font></font><code>Maps.as</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> depend on </font></font><code>Roads.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Each polygon, edge, and angle in a graph have an index that can be used as a key in an external table. In </font></font><code>Roads.as</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is an array </font></font><code>road</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indexed by the index of the ribs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where the base code of the card can refer to </font></font><code>edge.river</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as the base to the field, the module cannot do this. Instead, the module refers to a local variable </font></font><code>road[edge.index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This works for both centers and polygon corners. In this case, the base code remains clean. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have three modules: Roads, Lava, and NoisyEdges.</font></font><br><br><h3>  Roads </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realm of the Mad God does not use most of the functions of this map generator, but for it I created a road generator. I noticed that in the game, users naturally explore the rivers. Rivers lead players to the mountains where they die. I wanted to build roads at right angles to the rivers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I calculated the contour lines along the corners. Where the contour level changes, there is a road. This is a fairly simple algorithm, which is suitable in most cases, but sometimes creates small loops: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/629/d46/b9f/629d46b9f92d8ed61eceaf6972b29b1c.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the rivers meander along the Voronoi ribs (the blue lines in the diagram above), the roads run along Delaunay ribs (red lines). Roads are not handled by noise. Instead, they are drawn by splines between the midpoints of the edges:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/713/4c0/6a5/7134c06a538622d37ec3c61e44e813ab.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most landfills have two ‚Äúneighbors‚Äù with roads. </font><font style="vertical-align: inherit;">For them, the usual spline is used, connecting the two midpoints of the edges. </font><font style="vertical-align: inherit;">For polygons that have more than two ‚Äúneighbors‚Äù with roads, I draw an intersection with splines from all midpoints of the edges to the center of the polygon. </font><font style="vertical-align: inherit;">In the diagram above, the lower left polygon has an intersection, and the upper right polygon has an ordinary spline.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lava </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lava and the river follow the same paths. </font><font style="vertical-align: inherit;">Lava faults occur in high dry areas and are assigned to a subset of edges. </font><font style="vertical-align: inherit;">In the game, lava and water, of course, will be different, but they differ only in color and location. </font><font style="vertical-align: inherit;">Lava edges processed by noise:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7b/2fd/e54/c7b2fde54e26f0e619192ef2a4f48ec2.png" alt="image"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appendix: Opportunities for Improvement </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstract rendering </font></font></h3><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should correctly display the relevant parts of the world, not all the details. </font><font style="vertical-align: inherit;">In this project, I generate maps with a certain level of detail, but I don‚Äôt get to the detail of vegetation or cities, although maps are not completely abstract at the same time. </font><font style="vertical-align: inherit;">It may be possible to render more abstract maps in the style of maps of Middle-earth (like </font></font><a href="http://geektyrant.com/news/2008/10/7/guillermo-del-toro-talks-about-the-entire-pentology-of-middl.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">I wrote notes about </font></font><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/skyrim-maps/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">what I wanted to see in the game cards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Watersheds </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Following the down arrows (see the description in the section on heights), you can always find a path along the edges from any angle of the polygon to the coast. I use them to mark the places where water should flow into the ocean. All corners with the same source location can be considered part of the same watershed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The watershed code is incomplete. There is a watershed mode in the demo, but I don't like it. I tried to use the centers and corners of polygons as watershed boundaries, and in both cases the results were not good enough. I decided to postpone the calculations of the watersheds until they are needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think that the watersheds could be useful to give names to </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BE%25D0%25B4%25D0%25BE%25D1%2581%25D0%25B1%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B1%25D0%25B0%25D1%2581%25D1%2581%25D0%25B5%25D0%25B9%25D0%25BD"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">large areas.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the demo on the map about 1000 polygons of land. </font><font style="vertical-align: inherit;">For a game map, it would be nice to have fewer areas with names than polygons grouped together. </font><font style="vertical-align: inherit;">For example, XYZ mountains can be located above the XYZ valley, through which the XYZ river can flow. </font><font style="vertical-align: inherit;">Players will be able to understand that all these toponyms are related. </font><font style="vertical-align: inherit;">In this project, I did not advance much, but sooner or later I can return to it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Impassable boundaries </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my map generator, all boundaries between polygons are the same. </font><font style="vertical-align: inherit;">Between them there are smooth transitions. </font><font style="vertical-align: inherit;">It may be interesting to make some edges intermittent, so we can create rocks, abysses, plateaus and other abrupt changes in elevation. </font><font style="vertical-align: inherit;">See </font></font><a href="http://roguelikedeveloper.blogspot.com/2007/07/wilderness-generation-using-voronoi.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for how the Voronoi areas can be interesting for the gameplay.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relief analysis </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On polygonal maps, the search for paths must be fairly fast, and it can be used for the analysis of the relief. </font><font style="vertical-align: inherit;">For example, if two points are spatially close, but the path between them is long, this may mean that there is a bay or a mountain on the way, and that this will be a good place for a tunnel or bridge. </font><font style="vertical-align: inherit;">The pathfinding algorithm can also find places where bridges to the nearest islands are required. </font><font style="vertical-align: inherit;">Path polygons may strategically be more valuable than polygons rarely used for paths.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Named areas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I mentioned in the section on watersheds, I want to give names to different areas of the map. </font><font style="vertical-align: inherit;">Combining this function with the analysis of the relief, you can give names to rivers, mountains, lakes, groups of landfills, coastlines, oceans, forests, peninsulas, valleys, etc. </font><font style="vertical-align: inherit;">Names in one area may be related. </font><font style="vertical-align: inherit;">I did not work on this part, because I think that it is useful only in a particular game, and not in the general map generator. </font><font style="vertical-align: inherit;">With the theme of the game should be associated not only the names, it may be objects, quests and elements of the plot. </font><font style="vertical-align: inherit;">For example, the XYZ sword can only be found in the XYZ valley.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable density </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use the Forchun algorithm to subdivide a polygon into smaller polygons. </font><font style="vertical-align: inherit;">A map on which most of the world is roughly outlined, and some areas more detailed, may look interesting. </font><font style="vertical-align: inherit;">As an alternative approach, we can arrange initial points with variable density, so that in some areas there are more polygons than in others. </font><font style="vertical-align: inherit;">For example, instead of using the Lloyd algorithm, you can apply an </font></font><a href="http://devmag.org.za/2009/05/03/poisson-disk-sampling/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excess sampling of anti-aliasing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Improving Noisy Ribs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I implemented a very simple noisy rib system with jagged lines. </font><font style="vertical-align: inherit;">When you increase the map angles are very noticeable. </font><font style="vertical-align: inherit;">You can improve the system with the help of spline curves or fractal expansion, which will look more detailed when scaled.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appendix: Process Improvement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article was first three posts: </font></font><a href="http://simblob.blogspot.com/2010/09/polygon-map-generation-part-1.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">part 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on landfills, map views, islands, oceans, lakes, beaches and land; </font></font><a href="http://simblob.blogspot.com/2010/09/polygon-map-generation-part-2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">part 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about altitudes, rivers, humidity and biomes; </font></font><a href="http://simblob.blogspot.com/2010/09/polygon-map-generation-part-3.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about rendering, demo and source code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If anyone is interested in how I came to this, then here is a brief history:</font></font><br><br><ul><li>   2009      Wild Shadow Studios ,        .          ,    ,   <a href="http://simblob.blogspot.com/2010/01/simple-map-generation.html"> </a> .      ,         .    ,   ,      .    ,             ‚Äî , ,  , AI  NPC  .. </li><li>   2010          .   ,        .     ,   ,     , , , ,    - . <strong>  .</strong>      . ,     ,     .       ,    ,       .    ,         . </li><li>      ,        .       4    ,    .       ,  ,  ,  , , ,    .    <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA_(%25D0%25BF%25D1%2581%25D0%25B8%25D1%2585%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F)"></a> .    ! √≥         . </li><li>         ,      .     ,   ,     .       ,       UI .     UI   <em></em>    ,    .        ,    . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the end of August, I realized that I was working only on minor improvements, and decided that the project was ready for winding up. </font><font style="vertical-align: inherit;">I spent a long weekend in honor of Labor Day, writing down the results in this article (and posts). </font><font style="vertical-align: inherit;">It took a lot of time to create high-quality diagrams. </font><font style="vertical-align: inherit;">The diagrams revealed new bugs, so I switched to eliminating them, significantly simplifying one function (redistributing heights) and implementing a new one (redistributing humidity). </font><font style="vertical-align: inherit;">In addition, I renamed and commented on the code to make it easier to explain.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why am I tracking all this? </font><font style="vertical-align: inherit;">Because I'm trying to improve the process of working with such small (1-3 months) projects. </font><font style="vertical-align: inherit;">Here is what I want to remind:</font></font><br><br><ol><li>   <strong> </strong> ,    .  ,     ,     .      .         ,    ‚Ä¶ </li><li>     ,   <strong> </strong> .          ,      .     . </li><li>    <strong> </strong> .   ,    .     . </li><li>       . <strong> </strong>      .              . </li><li>       <strong> </strong> ,    .    ,       . </li><li> <strong>   </strong> .   .      ,    , , ,       git    . </li><li> <strong>  </strong>      ,  .      ,         .     . </li><li>   <strong> </strong> ,         .      .            ,      . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Great help was given by </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writing blog posts</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">They made me understand all parts of the system, look at all the data, and ensure that all the code is understandable. </font><font style="vertical-align: inherit;">The posts forced me to check every step of the map generation and improve those that are difficult to explain. </font><font style="vertical-align: inherit;">You need to start writing blog posts much earlier in the process. </font><font style="vertical-align: inherit;">Explanation is a good way to learn.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I will take these lessons into account when working on new projects. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appendix: Links </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I thank the </font></font><a href="http://www.dungeonleague.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dungeon League blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the excellent series of procedural map generation posts, the </font></font><a href="http://pcg.wikidot.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedural Content Generation wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><a href="http://pcg.wikidot.com/pcg-algorithm:map-generation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ideas on generating maps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the incomplete </font></font><a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DVoroWiki_main_page"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voronoi wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for useful resources about Voronoi diagrams. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks </font></font><code>nodename</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><a href="http://nodename.github.com/as3delaunay/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as3delaunay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is an Actionscript 3 library for generating Voronoi and Delone graphs. Also, thank you very much </font></font><code>polygonal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><a href="http://lab.polygonal.de/2007/04/21/a-good-pseudo-random-number-generator-prng/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PM_PRNG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a library of random numbers, which allowed me to use and change the seed value to reproduce sets of pseudo-random numbers. I used </font></font><a href="http://optipng.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the OptiPNG library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to optimize the PNG images of this article. </font></font><br><br> <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_%25D0%2594%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delaunay triangulation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and</font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voronoi polygons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are studied in many graphics courses. For example, see </font></font><a href="http://graphics.stanford.edu/courses/cs368-06-spring/handouts/Delaunay_1.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stanford CS 368</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PDF). I also studied </font></font><a href="http://en.wikipedia.org/wiki/Relative_neighborhood_graph"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relative adjacency </font></font></a><font style="vertical-align: inherit;"></font><a href="http://en.wikipedia.org/wiki/Gabriel_graph"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graphs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font><a href="http://en.wikipedia.org/wiki/Gabriel_graph"><font style="vertical-align: inherit;">Gabriel graphs</font></a><font style="vertical-align: inherit;"> , but did not use them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delaunay triangulation can be used for cards in the form of a </font></font><a href="http://en.wikipedia.org/wiki/Triangulated_irregular_network"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triangulated irregular structure</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Voronoi diagrams are also used to create maps. </font></font><br><br> <a href="http://en.wikipedia.org/wiki/Fortune%27s_algorithm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Forchun algorithm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is one of the algorithms capable of turning a set of points into Voronoi polygons. This is implemented in </font></font><code>as3delaunay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><a href="http://en.wikipedia.org/wiki/Lloyd%27s_algorithm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lloyd's algorithm is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used to improve the distribution of random points. It reduces the irregularity of the Voronoi polygons. On the Voronoi wiki there is incomplete information on the </font></font><a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DPAN_graphs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentation of graphs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the </font></font><a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DSpatial_Data_Structures"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentation of the ribs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as two pages that helped me in generating the rivers: </font></font><a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DRivers_and_watersheds"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rivers and watersheds</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DCrust_and_Skeleton"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crust and skeleton</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="http://www.reliefshading.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief Shading website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has </font></font><a href="http://www.reliefshading.com/examples/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">images of relief</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shading </font><a href="http://www.reliefshading.com/examples/index.html"><font style="vertical-align: inherit;">maps</font></a><font style="vertical-align: inherit;"> , as well as instructions for shading and coloring design. It is sad that I did not have enough time to apply these techniques. I also studied the Bing and Google maps to understand how various features are drawn in them; see </font></font><a href="http://www.41latitude.com/post/897973389/bing-maps-redesign"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://amitp.blogspot.com/2007/09/online-map-sites.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my blog post</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://infosthetics.com/archives/2010/06/bing_destination_map_automatic_napkin_sketching_of_maps.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="http://www.marietta.edu/~biol/biomes/biome_main.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Whittaker Chart</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is one way to predict common biomes with a given climate. Wikipedia has a page with</font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BE%25D0%25BC"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biome classification schemes and different biomes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also in Wikipedia there is a good </font></font><a href="http://en.wikipedia.org/wiki/List_of_landforms"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list of landforms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that you can try to generate with the help of a game map generator. For my project, I have not studied this list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ken Perlin (Ken Perlin) - master of work with noise, he came up with the noise of Perlin. He also created a lesser-known </font></font><a href="http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplex noise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PDF). In my project, I used Perlin's noise to create the overall shape of the island. Joe Slayton has a page on </font></font><a href="http://www.ridgenet.net/~jslayton/FunWithWilburVol6/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how to turn Perlin‚Äôs noise into islands</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . I was looking for information about blue noise and, before I found Lloyd‚Äôs algorithm for improving the distribution of random points, I came across an </font></font><a href="http://www.cs.virginia.edu/~gfx/pubs/antimony/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article by Dunbar and Humphreys about noise generation.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as on </font></font><a href="http://johanneskopf.de/publications/blue_noise/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Van's recursive tiles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I also looked at the </font></font><a href="http://www.red3d.com/cwr/texsyn/diary.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textures of Craig Reynold (Craig Reynold)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but did not have time to apply them anywhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also interesting to show </font></font><a href="http://liris.cnrs.fr/~egalin/articles.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">these articles of generating world</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.gozzys.com/wilderness-maps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nature map generator Gozzy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://donjon.bin.sh/world/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the world generator donjon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://gram.cs.mcgill.ca/papers/rudzicz-08-iterated.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an article on procedural generation roads</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.vision.ee.ethz.ch/~pmueller/wiki/CityEngine/PaperCities"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an article on procedural generation cities</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It seems that </font></font><a href="http://en.wikipedia.org/wiki/Straight_skeleton"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direct skeletons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be useful for defining mountain ranges, but as soon as I saw how well the ‚Äúdistance from the coast‚Äù approach works, I didn't need anything else. </font><font style="vertical-align: inherit;">Quite interesting is the generation of 3d-cards in </font></font><a href="http://www.bay12games.com/dwarves/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dwarf Fortress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></div><p>Source: <a href="https://habr.com/ru/post/322504/">https://habr.com/ru/post/322504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322494/index.html">The simplest way to avoid routine</a></li>
<li><a href="../322496/index.html">The world's easiest lock-free hash table</a></li>
<li><a href="../322498/index.html">11 steps to high email deliverability</a></li>
<li><a href="../322500/index.html">The CDN provider Cloudflare has injected the contents of its server‚Äôs memory into arbitrary webpage code.</a></li>
<li><a href="../322502/index.html">Downloading audio from mail.ru</a></li>
<li><a href="../322508/index.html">15 oddities in ruby ‚Äã‚Äãthat you should know</a></li>
<li><a href="../322510/index.html">Vertica + Anchor Modeling = start growing your mycelium</a></li>
<li><a href="../322512/index.html">Conversion and payment types in traffic arbitration</a></li>
<li><a href="../322514/index.html">Neural network imitation game</a></li>
<li><a href="../322520/index.html">Smart feeder: Machine Learning, Raspberry Pi, Telegram, a little learning magic + assembly instructions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>