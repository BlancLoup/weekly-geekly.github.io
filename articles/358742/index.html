<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular: ngx-translate lifehacks. TranslateCompiler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 


 In the near future I plan to publish some ngx-translate life hacks. 


- In the first part, we will rotate the Translateompiler order to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular: ngx-translate lifehacks. TranslateCompiler</h1><div class="post__text post__text-html js-mediator-article"><p>  Good day. </p><br><p>  In the near future I plan to publish some ngx-translate life hacks. </p><br><ul><li> In the first part, we will rotate the <code>Translateompiler</code> order to teach it to compile the pipes inside our json files. <a name="habracut"></a></li><li>  In the second part, we will write our own <code>TranslateLoader</code> to replace <code>TranslateHttpLoader</code> (which does not come from the ngx-translate box, but still it is a default loader, which can be installed separately). <br>  Our <code>TranslateLoader</code> will first of all pay attention to the browser language and contain fallback logic, as well as localize MomentJs and load via <code>APP_INITIALIZER</code> . <br>  Also consider the new ways to load ngx-translate json`ov into the application. <cut></cut></li><li><p>  The third part will be an experimental one - life hacking for Webpack users.  We will improve the ngx-translate infrastructure in the project and consider how to assemble translate json `s in the bundle (s). </p><cut></cut><br><h3 id="pristupim">  Let's get started </h3><br><p>  So let's say we need to display in the interface the date of creation of a certain entity, besides with additional text around. </p><br></li></ul><br><pre> <code class="hljs pgsql">&lt;p&gt;This entity created at <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">47</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span><span class="hljs-number"><span class="hljs-number">-02</span></span><span class="hljs-number"><span class="hljs-number">-2003</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> Guy&lt;/p&gt;</code> </pre> <br><p>  Add a new field to en.json for this line: </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"ENTITY_CREATED_AT"</span></span>: <span class="hljs-string"><span class="hljs-string">"This entity created at {{createdAtDate}} by {{guyName}}"</span></span></code> </pre> <br><p>  In the view of our component, naturally, we add a translate directive or pipe. </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ENTITY_CREATED_AT"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translateParams</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{createdAtDate: entity.createdAt, guyName: entity.name}"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  But with this approach, a problem arises - the createdAtDate field should already be localized, otherwise we will see just the result of <code>new Date().toString().</code> </p><br><p>  We have 2a solutions to this problem: </p><br><div class="spoiler">  <b class="spoiler_title">Some best practice!</b> <div class="spoiler_text"><p>  I prefer to transfer to translateParams an independent object the place to tie up the fields in json ªe to the fields of the real model. <br>  I mean: </p><br><pre> <code class="hljs pgsql">//our Entity model <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Entity { createdAt: <span class="hljs-type"><span class="hljs-type">Date</span></span>; <span class="hljs-type"><span class="hljs-type">name</span></span>: string; someComplexField: ComplexType; } //inside <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> HTML [translateParams]="{createdAtDate: entity.createdAt, guyName: entity.name}" // separate <span class="hljs-keyword"><span class="hljs-keyword">object</span></span></code> </pre> <br><p>  of course, it was possible in json ªe to refer to the fields of the real model, clearly indicating the field names in the Entity model: </p><br><pre> <code class="hljs vhdl"><span class="hljs-string"><span class="hljs-string">"ENTITY_CREATED_AT"</span></span>: <span class="hljs-string"><span class="hljs-string">"This entity created at {{createdAt}} by {{name}}"</span></span> //  <span class="hljs-keyword"><span class="hljs-keyword">entity</span></span>.createdAt, <span class="hljs-keyword"><span class="hljs-keyword">entity</span></span>.name</code> </pre> <br><p>  and in translateParams just pass the entity: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ENTITY_CREATED_AT"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translateParams</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"entity"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  And what if we already have support for 10 languages ‚Äã‚Äãand suddenly the model changes the name of one of the fields, which is tied to ngx-translate? </p></div></div><br><h6 id="help-funkciya-vnutri-komponenta-vyushki">  Help function inside the view component. </h6><br><p>  We can create a function inside the view component that will return to us a ready object for transfer to translateParams </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEntityTranslateParam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dateFormat: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { createdAtDate: moment.format(dateFormat, entity.createdAt), <span class="hljs-comment"><span class="hljs-comment">//      guyName: entity.name }; }</span></span></code> </pre> <br><p>  There is a drawback - we have to clutter up each component with such functions.  Of course, we can add some service that will create such objects for us, so that the code of our components is a bit cleaner, this only makes sense if the objects are large enough, because we still need to inject this service everywhere. </p><br><h6 id="razbit-entity_created_at-na-dve-chasti">  Split ENTITY_CREATED_AT into two parts. </h6><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"ENTITY_CREATED_AT_1"</span></span>: <span class="hljs-string"><span class="hljs-string">"This entity created at"</span></span>, <span class="hljs-string"><span class="hljs-string">"ENTITY_CREATED_AT_2"</span></span>: <span class="hljs-string"><span class="hljs-string">"by {{guyName}}"</span></span></code> </pre> <br><p>  Here it grows and becomes difficult to read HTML, but now we can use any kind of pipe!  (Of course, you can use the place-pipe directive, but you will have to create another html inside the div) </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'ENTITY_CREATED_AT_1' | translate}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{entity.createdAt | dateFormatPipe:LL}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'ENTITY_CREATED_AT_2' | translate:{guyName:entity.guyName} }}</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h6 id="hvala-razrabotchiku-ngx-translate-za-otlichnuyu-infrastrukturu">  Praise the ngx-translate developer for a great infrastructure! </h6><br><p>  When importing the ngx-translate module into our application, we can provide a custom <code>Translateompiler</code> . <br>  <a href="https://github.com/lephyrus/ngx-translate-messageformat-compiler">By the way, here is a link</a> to a great plural \ gender etc.  compiler that works with ngx-translate. </p><br><p>  Our task is to write our own TranslateCompiler, which will be able to execute pipes within ngx-translate localizations. <br>  Let's start with the preparation of DI (because we will take the pipes from Injector`a), and the initialization of ngx-translate. </p><br><p>  Add the necessary pipe to the providers of the module, in my case it is a <code>SharedModule</code> because the application contains more than one module. </p><br><pre> <code class="hljs ruby">@NgModule({ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-symbol"><span class="hljs-symbol">imports:</span></span> [ ...exportedModules ], <span class="hljs-symbol"><span class="hljs-symbol">declarations:</span></span> [ ...exportedDeclarations ], <span class="hljs-symbol"><span class="hljs-symbol">exports:</span></span> [ ...exportedModules, ...exportedDeclarations ], <span class="hljs-symbol"><span class="hljs-symbol">providers:</span></span> [ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> declare pipes available with injector [ DateFormatPipe, {<span class="hljs-symbol"><span class="hljs-symbol">provide:</span></span> <span class="hljs-string"><span class="hljs-string">'dateFormat'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">useExisting:</span></span> DateFormatPipe} ] ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><p>  Now we initialize ngx-translate and give it our <code>CustomTranslateCompiler</code> . <br>  In my case, I use <code>CoreModule</code> . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CustomTranslateCompiler } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'app/_core/services/translate/translate.compiler'</span></span>; @NgModule({ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> some needed providers imports: [ CommonModule, TranslateModule.forRoot({ compiler: { provide: TranslateCompiler, useClass: CustomTranslateCompiler, deps: [Injector] }, }) ], exports: [CommonModule, TranslateModule] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><p>  We can use only those pipelines that were announced in the providers module (in the example, dateFormst pipe) </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"ENTITY_CREATED_AT"</span></span>: <span class="hljs-string"><span class="hljs-string">"This entity created at {{createdAtDate | dateFormat:LL}} by {{guyName}}"</span></span></code> </pre> <br><p>  Determine, by default, <code>PipeTranslateCompiler</code> ; </p><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeTranslateCompiler</span></span> <span class="hljs-title"><span class="hljs-title">implements</span></span> <span class="hljs-title"><span class="hljs-title">TranslateCompiler</span></span> { constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> injector: Injector, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> errorHandler: ErrorHandler) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, lang: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> | Function</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compileTranslations</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">translations: any, lang: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">): any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> translations; } }</code> </pre> <br><p>  We have 2e functions: <br>  compileTranslations - our loaded json (which you could download via TranslateHttpLoader) gets at the input <br>  compile - gets only one value, and will be called when we explicitly add some fields to the ngx-translate via <code>TranslateService.set('some translate val', 'key', 'en')</code> . </p><br><p>  Since a large enough json can get into compileTranslations, we will need to recursively walk through the fields of the entire object and parse each value, I would like to know in advance which fields to parse and which not.  Therefore, I decided to save all fields that need to be saved via PipeTranslateCompiler with the @ symbol. </p><br><pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">"@ENTITY_CREATED_AT"</span></span>: <span class="hljs-string"><span class="hljs-string">"This entity created at {{createdAtDate | dateFormat:LL}} by {{guyName}}"</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-string"><span class="hljs-string">"OTHER_KEY"</span></span>: <span class="hljs-string"><span class="hljs-string">"This is regular entity"</span></span> //    </code> </pre> <br><p>  And now let's pay attention to the return type of the function f-tsii <code>compile - string | Function</code>  <code>compile - string | Function</code> , this means that we can turn any string value into a function, and when we in our HTML view use the translate pipe or directive, ngx-translate, knowing that if there is a function with a key, it will call it with parameters, which we pass to translateParams. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'ENTITY_CREATED_AT'</span></span> | translate:paramsObject}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">//  ENTITY_CREATED_AT -  transform      paramsObject.</span></span></code> </pre> <br><p>  So we need to parse the string <code>"This entity created at {{createdAtDate | dateFormat:LL}} by {{guyName}}"</code> and replace it with the function. </p><br><p>  First, let's imagine how we will store the result of parsing the string, so that later on the parameter base you can quickly get a string with the pipes already applied. <br>  I want to be able to parse 2+ pipes at once with 2+ parameters </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"SOME_KEY": "value1: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{dateField | dateFormat:LL}}</span></span><span class="xml"><span class="xml"> and value2: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{anotherField | customPipe:param1:param2}}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  So we need to parse the string with a regular expression, selecting the parts inside the brackets {{. *}}. <br>  For each highlighted bracket, you need information about what's inside, tobish the name of the pipe, an array of parameters of the pipe and the name of the field of the object. </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{__ | _:1:2}}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  Define a couple of interfaces for convenience: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">PipedObject</span></span> { property: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-comment"><span class="hljs-comment">// __ pipe: PipeDefinition; //  } interface PipeDefinition { name: string; // _ params: string[]; //   }</span></span></code> </pre> <br><p>  Parsing function: </p><br><pre> <code class="hljs bash">private parseTranslation(res: string): {pipedObjects: PipedObject[], matches: string[]} { //   <span class="hljs-string"><span class="hljs-string">"{{dateField | dateFormat:LL | additionalPipe:param1}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"{{anotherField | customPipe:param1:param2}}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> matches = res.match(/{{.[^{{]*}}/g); <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> pipedObjects: PipedObject[] = []; (matches || []).forEach((v) =&gt; { //     {{dateField | dateFormat:LL}} -&gt; dateField|dateFormat:LL|additionalPipe:param1 v = v.replace(/[{}\s]+/g, <span class="hljs-string"><span class="hljs-string">''</span></span>); //  : dateField|dateFormat:LL|additionalPipe:param1 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> pipes = v.split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> objectPropertyName = pipes[0]; // dateField pipes = pipes.slice(1); // [dateFormat:LL, additionalPipe:param1] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">let</span></span> pipe of pipes) { // customPipe:param1:param2 -&gt; [<span class="hljs-string"><span class="hljs-string">'customPipe'</span></span>, <span class="hljs-string"><span class="hljs-string">'param1'</span></span>, <span class="hljs-string"><span class="hljs-string">'param2'</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> pipeTokens = pipe.split(<span class="hljs-string"><span class="hljs-string">':'</span></span>); pipedObjects.push({ property: objectPropertyName, pipe: { name: pipeTokens[0], // customPipe params: pipeTokens.slice(1) // [<span class="hljs-string"><span class="hljs-string">'param1'</span></span>, <span class="hljs-string"><span class="hljs-string">'param2'</span></span>] } }); } }); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> {pipedObjects, matches}; }</code> </pre> <br><p>  Now, for a start, let's connect the parseTranslation and the function that compiles only one value - compile </p><br><pre> <code class="hljs cmake">public compile(value: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, lang: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.compileValue(value); } private compileValue(val): <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> { let parsedTranslation = this.parseTranslation(val); // ,    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (argsObj: object) =&gt; { //  -     ngx-translate        //      : value1: {{dateField | dateFormat:LL}} <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> value2: {{anotherField | customPipe:param1:param2}} let res = val; parsedTranslation.pipedObjects.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>((o, i) =&gt; { //   DI   ,        . const pipe = this.injector.get(o.pipe.name); const property = argsObj[o.property]; // argsObj -  -   [translateParams] //           pipe.transform(prop, o.pipe.params); const pipeParams = this.assignPipeParams(argsObj, o.pipe.params || []); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!property) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } let pipedValue = pipe.transform( property, pipeParams.length === <span class="hljs-number"><span class="hljs-number">1</span></span> ? pipeParams[<span class="hljs-number"><span class="hljs-number">0</span></span>] : pipeParams ); //  {{*.}}    . {{dateField | dateFormat:LL}} -&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> res = res.replace(parsedTranslation.<span class="hljs-keyword"><span class="hljs-keyword">matches</span></span>[i], pipedValue); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }; } private assignPipeParams(obj: object, params: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[]) { let assignedParams = []; params.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(p =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(obj.hasOwnProperty(p)) { assignedParams.push(obj[p]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { assignedParams.push(p); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assignedParams; }</code> </pre> <br><p>  For clarity, assignPipeParams allows us to pass parameters to a customPipe from a component. </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"@SOME": "value1: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{dateField | dateFormat:LL}}</span></span><span class="xml"><span class="xml"> and value2: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{anotherField | customPipe:param1}}</span></span><span class="xml"><span class="xml"> //      :LL  :param1 -        </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'@SOME' | myTranslate:{dateField: entity.value1, anotherField: entity.value2, param1: 'DYNAMIC_VALUE'} }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //    :param1  </span></span></code> </pre> <br><p>  I will not describe the method of parsing the entire json'a from compileTranslations, on the stack overflow you can find many methods of circumventing the entire json'a structure. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> compileTranslations(translations: any, lang: string): any { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iterateTranslations(translations); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> translations; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> iterateTranslations(obj) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.hasOwnProperty(key)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = obj[key]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isString = typeof <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> === <span class="hljs-string"><span class="hljs-string">'string'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-string"><span class="hljs-string">'@'</span></span> &amp;&amp; isString) { obj[key] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.compileValue(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   compileValue } else if(!isString) { this.iterateTranslations(val); } } } }</span></span></code> </pre> <br><p>  Done!  Now we can use the pipes inside the ngx-translate json `s! </p><br><div class="spoiler">  <b class="spoiler_title">New useful Angular 6 feature</b> <div class="spoiler_text"><p>  <a href="https://www.youtube.com/watch%3Fv%3Dy73NMviRoPY">Here you can see briefly and in fact what Angular Elements is.</a> <br>  <a href="https://github.com/academind/ng6-elements/tree/master/src">There is a source from the video</a> </p><br><p>  In general, because Angular Elements is still experimental, we still cannot compile web components from Angular and use them in any JavaScript application. </p><br><p>  But!  nevertheless, the benefits are already there.  Now we can create self bootstrap components, Angular 5, made the bootstrap of the entire application only at the initialization stage, but now we can "compile" the components at any time the application runs from the HTML string. </p><br><p>  This can be useful if we need to turn some HTML string from our API into a component. </p><br><p>  But it will also be useful for writing a ComponentTranslateCompiler!  Which can assemble components from our ngx-translate json `s. </p></div></div><br><p>  That's all.  Research and improve! </p><br><p>  <a href="https://gist.github.com/CapLonelyFlaw/7cab4642806e86e72cbfafd82c3bcf76">whole source</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/358742/">https://habr.com/ru/post/358742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358728/index.html">‚ÄúAccording to the GDPR‚Äù: how do social networks change their privacy policies and how they work with PD</a></li>
<li><a href="../358730/index.html">IT Relocation. Review of the pros and cons of living in Bangkok a year later</a></li>
<li><a href="../358732/index.html">Our long-term experiment - the introduction of Dell EMC ScaleIO in the KROK Cloud</a></li>
<li><a href="../358734/index.html">Splunk. A selection of useful materials from TS Solution</a></li>
<li><a href="../358736/index.html">Natural Language Processing</a></li>
<li><a href="../358744/index.html">Marvin Minsky "The Emotion Machine": Chapter 4 "Consciousness"</a></li>
<li><a href="../358746/index.html">Developing your own visualization plugin for Grafana</a></li>
<li><a href="../358748/index.html">Codable Tips and Examples</a></li>
<li><a href="../358750/index.html">Integration of Veeam Backup & Replication and PureStorage</a></li>
<li><a href="../358752/index.html">OpenVINO Toolkit - to look at the world with a clear look</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>