<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Calculation of the weight spectrum of a linear subspace in Wolfram Mathematica</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The process of calculating the weight spectrum 
 Root cause 


 This article owes its appearance to one rather long-standing question that was asked i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Calculation of the weight spectrum of a linear subspace in Wolfram Mathematica</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/baa/783/a7c/baa783a7c2564b2fa8f8ad6e2abbdc45.jpg"></p><br><p>  <em>The process of calculating the weight spectrum</em> </p><br><h2 id="pervoprichina">  Root cause </h2><br><p>  This article owes its appearance to one rather long-standing <a href="https://vk.com/wolframmathematica%3Fw%3Dwall-1172233_32760%252Fall">question</a> that was asked in the Wolfram Mathematica Russian-speaking support group.  However, the answer to it greatly grew and eventually began to live an independent life, and even got its own problems.  As is clear from the title of the article, the task was devoted to calculating the weight spectrum, and therefore it directly relates to discrete mathematics and linear algebra.  It also shows the solution in the programming language Wolfram Language.  Despite the fact that the essence of the problem is very simple (for simple basic vectors, it is completely solved in the mind), much more interesting is the process of optimizing the algorithm for finding the weight spectrum.  The authors are of the opinion that the problem considered in this article and the ways to solve it very well show how compilation and parallelization are used in Wolfram techniques.  Thus, the main goal is to show one of the effective ways to accelerate Mathematica code. </p><a name="habracut"></a><br><h2 id="formulirovka">  Wording </h2><br><p>  We quote the original formulation of the problem: </p><br><blockquote>  a) Let's call a vector a string of bits (values ‚Äã‚Äã0 or 1) of a fixed length N: that is, just 2 <sup>N</sup> different vectors are possible. <br><br>  b) Introduce the addition operation modulo 2 vectors (operation xor), which takes two vectors a and b to receive a vector a + b of the same length N. <br><br>  c) Let the set A = {a <sub>i</sub> |  i ‚àà 1..K} of 0 ‚â§ K ‚â§ 2 <sup>N</sup> vectors.  Let's call it generating: by adding a <sub>i of the</sub> set A, we can get 2 <sup>K</sup> vectors of the form ‚àë <sub>i = 1..K</sub> b <sub>i</sub> a <sub>i</sub> , where b <sub>i</sub> is equal to either 0 or 1. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      d) The weight of a vector is the number of single (non-zero) bits in the vector: that is, the weight is a natural number from 0 to N. <br><br>  It is required for the given generating sets of vectors and the number N to construct a histogram (spectrum) of the number of different vectors by their weight. <br><br>  Input format: <br>  Text file from a set of lines of the same length, one vector per line (characters 0 and 1 without separators). <br><br>  Output Format: <br>  A text file with a pair of values ‚Äã‚Äãfor the weight / number separated by a tab, one pair per line, sorted by the numerical value of the weight. </blockquote><br><h2 id="reshenie-vruchnuyu">  Manual solution </h2><br><p>  To begin with, we will try to solve the problem in our mind in order to understand the principle of calculating the weight spectrum.  For this we will use vectors of minimal length.  Then you just need to expand the algorithm for any number of vectors and any dimension.  Let given a basis of two vectors of two elements in each: </p><br><pre><code class="plaintext hljs">basis = {{0, 1}, {1, 1}}</code> </pre> <br><p>  Since there are only two vectors, all possible linear combinations and, accordingly, combinations of values ‚Äã‚Äãof b <sub>i</sub> will be 2 <sup>K</sup> , where K is the number of basis vectors.  We get 4 of the following linear combinations: </p><br><pre> <code class="plaintext hljs">mod2(0 * {0, 1}, 0 * {1, 1}) = {0, 0} mod2(0 * {0, 1}, 1 * {1, 1}) = {1, 1} mod2(1 * {0, 1}, 0 * {1, 1}) = {0, 1} mod2(1 * {0, 1}, 1 * {1, 1}) = {1, 0}</code> </pre> <br><p>  Here it is assumed that the addition function modulo two is already properly defined.  It turned out four vectors, the dimension of each is equal to two.  To finally calculate the spectrum you just need to count the number of units in each resulting vector, that is: </p><br><pre> <code class="plaintext hljs">sum({0, 0}) = 0 sum({1, 1}) = 2 sum({0, 1}) = 1 sum({1, 0}) = 1</code> </pre> <br><p>  Calculate the number of entries in the resulting list of each weight.  And then, according to the requirements of the task, the result should look like this: </p><br><pre> <code class="plaintext hljs">{{0, 1}, {1, 2}, {2, 1}}</code> </pre> <br><p><img src="https://habrastorage.org/web/a52/b8e/ba5/a52b8eba5dca49f8afa635d661f753f7.jpg"></p><br><h2 id="realizaciya-prostogo-algoritma-v-wolfram-mathematica">  The implementation of a simple algorithm in Wolfram Mathematica </h2><br><p>  So, now we‚Äôll try to record and automate everything that was done in our mind with the help of Wolfram Language.  To begin with, let's create a function that performs modulo-2 addition (as it was said in the problem statement): </p><br><pre> <code class="plaintext hljs">(*    *) mod2[b1_Integer, b2_Integer] := Mod[b1 + b2, 2] (*     *) mod2[b1_Integer, b2__Integer] := mod2[b1, mod2[b2]] (*        -  *) Attributes[mod2] := {Listable}</code> </pre> <br><p>  The next function should take as input a list of vectors and a list of coefficients b <sub>i</sub> - a vector whose length is equal to the number of vectors in the basis.  Returning a vector of the same dimension as the elements of the basis is a linear combination. </p><br><pre> <code class="plaintext hljs">(*        *) combination[basis: {{__Integer}..}, b: {__Integer}] /; Length[basis] == Length[b] := Apply[mod2, Table[basis[[i]] * b[[i]], {i, 1, Length[b]}]]</code> </pre> <br><p>  Now you need to get a list of all possible sets of coefficients b <sub>i</sub> .  Obviously, their number is 2 <sup>K</sup> , and all possible sets are simply writing all the numbers from 0 to 2 <sup>K</sup> -1 in binary representation.  Then the list of all possible linear combinations can be obtained as follows: </p><br><pre> <code class="plaintext hljs">linearCombinations[basis: {{__Integer}..}] := With[{len = Length[basis]}, Table[combination[basis, IntegerDigits[i, 2, len]], {i, 0, 2^len - 1}] ]</code> </pre> <br><p>  The result of the function above is a list of 2 <sup>K</sup> vectors.  All we have to do is calculate the weight of each vector in this list, and then count the number of meetings of each weight: </p><br><pre> <code class="plaintext hljs">weightSpectrum[basis: {{__Integer}..}] := Tally[Map[Total, lenearCombination[basis]]];</code> </pre> <br><p>  Check how it will work.  Create a basis from the list of random vectors and calculate the weight spectrum: </p><br><pre> <code class="plaintext hljs">(*   *) basis = RandomInteger[{0, 1}, {6, 6}] ws = weightSpectrum[basis] ListPlot[ws, PlotTheme -&gt; "Web"] (* Out[..] := {{0, 0, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1}, {1, 1, 0, 1, 0, 1}, {1, 0, 0, 1, 1, 0}, {1, 0, 0, 0, 1, 1}, {0, 1, 0, 1, 1, 1}} Out[..]:= {{0, 1}, {4, 15}, {3, 20}, {2, 15}, {1, 6}, {5, 6}, {6, 1}} *)</code> </pre> <br><p><img src="https://habrastorage.org/web/84a/30a/3e0/84a30a3e0bfc4df4a8d211dec415dd48.jpg"></p><br><p>  But what will happen if you try to calculate all the same, but for more vectors?  We use the <strong>AbsoluteTiming []</strong> function and see how the calculation time behaves itself depending on the size of the basis. </p><br><pre> <code class="plaintext hljs">basisList = Table[RandomInteger[{0, 1}, {i, 10}], {i, 1, 15}]; timeList = Table[ {Length[basis], First[AbsoluteTiming[weightSpectrum[basis]]]}, {basis, basisList} ]; ListPlot[timeList, PlotTheme -&gt; "Web", Joined -&gt; True]</code> </pre> <br><p><img src="https://habrastorage.org/web/7f6/5d6/c2d/7f65d6c2d6d84542a3a7877180cfd16f.jpg"></p><br><p>  <em>The dependence of the calculation time on the size of the basis for the same length of vectors</em> </p><br><p>  As can be seen in the resulting graph, the calculation time increases exponentially along with the addition of the number of vectors to the basis.  It turns out that for a basis of 15 vectors, where 10 elements each, the calculation of the spectrum takes about 10 seconds.  This calculation time is quite large, but there is nothing surprising in this, since it has already been said above that the number of linear combinations grows exponentially with the size of the basis, and hence the number of operations increases with the same speed.  Another factor that lowers the computation speed is that the code is not optimal.  Wolfram Language is an interpreted programming language and therefore is not initially considered to be fast enough, which means that standard functions will not give us maximum performance.  To solve this problem, we use the compilation. </p><br><h2 id="ispolzovanie-skompilirovannyh-funkciy">  Using compiled functions </h2><br><h3 id="korotko-o-compilehttpreferencewolframcomlanguagerefcompilehtml">  <strong><a href="http://reference.wolfram.com/language/ref/Compile.html">Compile in</a></strong> Brief </h3><br><p>  The syntax of this function is quite simple and very similar to <strong><a href="http://reference.wolfram.com/language/ref/Function.html">Function</a></strong> .  As a result, <strong>Compile</strong> always returns an "object" - a compiled function that can be applied to numeric values ‚Äã‚Äãor lists of numbers.  <strong>Compile</strong> does not support working with Wolfram Language strings, characters, or compound expressions (except expressions consisting of a <strong>List</strong> ).  Below are some examples of creating compiled functions. </p><br><pre> <code class="plaintext hljs">cSqr = Compile[{x}, x^2]; cSqr[2.0] (* Out[..] := 4.0 *) cNorm = Compile[{x, y}, Sqrt[x^2 + y^2]]; cNorm[3.0, 4.0] (* Out[..] := 5.0 *) cReIm = Compile[{{z, _Complex}}, {Re[z], Im[z]}]; cReIm[1 + I] (* Out[..] := {1.0, 1.0} *) cSum = Compile[{{list, _Real, 1}}, Module[{s = 0.0}, Do[s += el, {el, list}]; s]]; cSum[{1, 2, 3.0, 4.}] (* Out[..] := 10.0 *)</code> </pre> <br><p>  All available options and more detailed examples can be found in the official documentation at the link above.  Now let's go directly to the function for calculating the weight spectrum. </p><br><h3 id="kompilyaciya-vychisleniya-vesovogo-spektra">  Compiling weight spectrum computations </h3><br><p>  As in the simple case, you can create some simple functions and then apply them in turn to get the result.  And you can perform all operations in the body of just one function.  Both that and other method can be quite realized.  We will go the second way for the sake of diversity. </p><br><pre> <code class="plaintext hljs">cWeightSpectrumSimple = Compile[ {{basis, _Integer, 2}}, Module[ { k = Length[basis], spectrum = Table[0, {i, 0, Last[Dimensions[basis]]}] }, Do[ With[ { (*     2^k - 1  *) weight = Total[Mod[Total[IntegerDigits[b, 2, k] * basis], 2]] + 1 }, (*   spectrum    .  weight    -           1  ,       .   spectrum     .         ,      . *) spectrum[[weight]] = spectrum[[weight]] + 1 ], {b, 0, 2^k - 1} ]; Return[Transpose[{Range[0, Last[Dimensions[basis]]], spectrum}]] ] ]</code> </pre> <br><p>  As always, we will conduct a small test of the correctness of this function.  Similarly, we take a list of random bases with sizes from 2 to 15 vectors, where each vector consists of 10 elements and try to calculate the time at which the weight spectrum is calculated: </p><br><pre> <code class="plaintext hljs">basisList = Table[RandomInteger[{0, 1}, {i, 10}], {i, 2, 15}]; timeList=Table[{Length[basis],First[AbsoluteTiming[cWeightSpectrumSimple[basis]]]},{basis,basisList}]; ListLinePlot[timeList, PlotTheme -&gt; "Web"]</code> </pre> <br><p><img src="https://habrastorage.org/webt/db/ic/57/dbic57oxoqrxihx0nqvqk2oysze.png"></p><br><p>  As can be seen from the last graph - the difference with the result from the previous part is huge.  A small optimization of the algorithm in the form of an optimal weight calculation at the last stage and the use of compilation leads to an acceleration of 200 times!  This result is interesting because, on the one hand, it shows Mathematica as a fairly fast language, when properly applied, and on the other, it once again proves that Mathematica is a slow language because of interpretability, if you do not know the intricacies of the internal workings of functions. </p><br><h2 id="kod-greya">  Gray code </h2><br><h3 id="o-kode-greya">  About Gray Code </h3><br><p>  While thinking about how to solve the problem, a simple thought arose.  If suddenly the next value of <em>b <sub>i</sub></em> is zero, then there is generally no need to multiply the base vector by that number and add it.  Those vectors that are multiplied with zero values ‚Äã‚Äãdo not change the result.  At first it seemed like a great thought and it even worked.  Indeed, during the iteration of the list elements <em>b <sub>i</sub></em> just came out fewer vector addition operations.  Then came the next idea.  The subtraction and addition of vectors in the calculation of a linear combination is no different.  This means that the following is feasible: </p><br><pre> <code class="plaintext hljs">1 * {0, 1} + 0 * {1, 0} + 1 * {1, 1} == {0, 1} + {1, 1} {0, 1} + {1, 1} == {1, 0} -&gt; {1, 0} + {1, 1} == {0, 1}</code> </pre> <br><p>  That is, adding a vector to the intermediate sum is no different from subtracting.  And then it all came together in a great idea!  What if suddenly it turns out that in the cycle for the list <em>b <sub>i the</sub></em> difference between the representation <em>b <sub>k</sub></em> and <em>b <sub>k + 1 is</sub></em> just a few bits?  Then you can get a linear combination with the number <em>k</em> and add to it only those basic vectors whose index coincides with the numbers of the different bits between <em>k</em> and <em>k + 1</em> .  The result is a linear combination of <em>k + 1</em> .  And what if you go further?  Suddenly it turns out that the difference between adjacent linear combinations in just one vector?  If you build a direct sequence from 0 to 2 <sup>N</sup> -1 - then this is impossible.  But suddenly you can mix and arrange these numbers in some other order?  This, as it turned out, is called the Gray Code, a sequence of numbers, in which the difference between neighbors is only one digit.  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%2593%25D1%2580%25D0%25B5%25D1%258F">Wikipedia</a> describes one of the infinite set of codes - the mirror Gray Code and the method for obtaining it.  Below is an example of such a sequence: </p><br><table><thead><tr><th>  Decimal </th><th>  Binary </th><th>  Gray </th><th>  Gray as decimal </th></tr></thead><tbody><tr><td>  0 </td><td>  000 </td><td>  000 </td><td>  0 </td></tr><tr><td>  one </td><td>  001 </td><td>  001 </td><td>  one </td></tr><tr><td>  2 </td><td>  010 </td><td>  011 </td><td>  3 </td></tr><tr><td>  3 </td><td>  011 </td><td>  010 </td><td>  2 </td></tr><tr><td>  four </td><td>  100 </td><td>  110 </td><td>  6 </td></tr><tr><td>  five </td><td>  101 </td><td>  111 </td><td>  7 </td></tr><tr><td>  6 </td><td>  110 </td><td>  101 </td><td>  five </td></tr><tr><td>  7 </td><td>  111 </td><td>  100 </td><td>  four </td></tr></tbody></table><br><h3 id="ispolzovanie-v-skompilirovannoy-funkcii">  Use in compiled function </h3><br><p>  The use of compilation already significantly speeds up the calculation of the weight spectrum; now we will try to use the Gray code and optimize the addition of the linear combination vectors.  Only it is necessary to understand how to calculate the position of the changed bit at each step.  Fortunately, the 13th chapter of this <a href="https://github.com/KirillBelovTest/WeightSpectrumLinearSubspace/blob/master/Documentation/Russian/Books/Hackers%2520Delight.pdf">book</a> came to the rescue.  Entirely calculate the linear combination is required only once at the very beginning.  But, since it is precisely known that the first linear combination is a set of zeros, this will not be necessary.  Considering the above, you can create an even more optimized function for calculating the weight spectrum: </p><br><pre> <code class="plaintext hljs">WeightSpectrumLinearSubspaceGrayCodeEasy = Compile[{{basevectors, _Integer, 2}}, Module[{ n = Dimensions[basevectors][[-1]], k = Length[basevectors], s = Table[0, {n + 1}], currentVector = Table[0, {n}], (*   {0, 0, ..}*) m = 0, l = 0 }, (* ,     0      1         *) s[[1]] = 1; Do[ (*  *) m = Log2[BitAnd[-1 - b, b + 1]] + 1; (*     ,    *) currentVector = BitXor[currentVector, basevectors[[m]]]; (* *) l = Total[currentVector] + 1; s[[l]] = s[[l]] + 1, {b, 0, 2^k - 2} ]; (* Return *) s ], (*  ,       *) RuntimeOptions -&gt; "Speed", (*CompilationTarget -&gt; "C",*) CompilationOptions -&gt; {"ExpressionOptimization" -&gt; True} ];</code> </pre> <br><p>  Here is an example of the result for a basis of 16 vectors with a dimension of 512: </p><br><pre> <code class="plaintext hljs">basis = RandomInteger[{0, 1}, {16, 512}]; ListPlot[WeightSpectrumLinearSubspaceGrayCodeEasy[basis], PlotTheme -&gt; "Web", PlotRange -&gt; All, Filling -&gt; Bottom]</code> </pre> <br><p><img src="https://habrastorage.org/webt/pu/ga/ad/pugaadnl0kikto3t2zhkxqd08j0.png"></p><br><p>  As a result, a one-dimensional list of weights is returned.  This type of list is also quite correct, as it is easy to bring it to the view from the previous part.  The first element corresponds to the frequency of meeting the vector of zero weight.  The latter is the frequency of the meeting of the vector of units.  We use the same code to test performance: </p><br><pre> <code class="plaintext hljs">basisList = Table[RandomInteger[{0, 1}, {i, 10}], {i, 2, 15}]; timeList=Table[{Length[basis],First[AbsoluteTiming[WeightSpectrumLinearSubspaceGrayCodeEasy[basis]]]},{basis,basisList}]; ListLinePlot[timeList, PlotTheme -&gt; "Web"]</code> </pre> <br><p><img src="https://habrastorage.org/webt/u0/wa/gd/u0wagdzrx5bsnm1ozwwjeabegm0.png"></p><br><p>  <em>Calculation time on basis size</em> </p><br><p>  As a result, for the last basis from the list of 15 vectors, the computation speed increased by another 5 times.  But this is a slightly misleading result.  To understand how much efficiency has increased it is necessary to calculate the ratio of the calculation time for the last two functions: </p><br><pre> <code class="plaintext hljs">basisList = Table[RandomInteger[{0, 1}, {i, 10}], {i, 2, 20}]; timeList=Table[{ Length[basis], First[RepeatedTiming[cWeightSpectrumSimple[basis]]] / First[RepeatedTiming[WeightSpectrumLinearSubspaceGrayCodeEasy[basis]]] }, {basis,basisList} ]; ListLinePlot[timeList, PlotTheme -&gt; "Web"]</code> </pre> <br><p><img src="https://habrastorage.org/webt/gb/zg/3u/gbzg3ucbxjcmnac9up8knf4xrf8.png"></p><br><p>  <em>The ratio of the spectrum calculation time using gray code and without</em> </p><br><p>  From this graph it becomes clear that in fact this algorithm lowered the complexity of computations by one power.  And this will be the more noticeable and more efficient the larger the dimension of the vectors in the basis.  This result is obtained if the basis consists of vectors with dimension 128: </p><br><p><img src="https://habrastorage.org/webt/ho/hj/0r/hohj0rielsq0p8e7yetlnqwjyfc.png"></p><br><h2 id="parallelizaciya">  Parallelization </h2><br><h3 id="kak-chto-to-poschitat-v-mathematica-parallelno">  How to calculate something in Mathematica in parallel </h3><br><p>  Mathematica has a small set of functions that can perform asynchronous computations on different cores.  Only now it is necessary to define with terminology.  After all, a running process that represents something similar to a virtual machine in Mathematica is also called a kernel, i.e.  Kernel.  The Mathematics Core is an interactive execution environment operating in interpreter mode.  Each core takes necessarily one process in the system.  Threads in the usual sense of the language does not implement.  Accordingly, you need to understand that the kernels in standard use will not have shared memory.  Basically, all functions of this type begin on <strong><a href="https://reference.wolfram.com/language/Compile/tutorial/Parallel.html">Parallel</a></strong> .  The easiest way to find something asynchronously: </p><br><pre> <code class="plaintext hljs">ParallelTable[i^2,{i, 1, 10}] (*Out[..] := {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}*)</code> </pre> <br><p>  A number of functions work in a similar way: <br>  <strong><a href="https://reference.wolfram.com/language/ref/ParallelMap.html">ParallelMap</a></strong> , <strong><a href="https://reference.wolfram.com/language/ref/ParallelDo.html">ParallelDo</a></strong> , <strong><a href="https://reference.wolfram.com/language/ref/ParallelProduct.html">ParallelProduct</a></strong> , <strong><a href="https://reference.wolfram.com/language/ref/ParallelSum.html">ParallelSum</a></strong> , ... </p><br><p>  There are several ways to verify that this was not actually done on one core.  This is how you can get all the running kernels: </p><br><pre> <code class="plaintext hljs">Kernels[] (* Out[..] := {"KernelObject"[1, "local"], ... , "KernelObject"[N, "local"]} *)</code> </pre> <br><p>  The list will contain all currently running processes.  At the same time, they should also be displayed in the task manager. </p><br><p><img src="https://habrastorage.org/webt/14/me/vf/14mevfe3h9lwbjclyabcqnpzn1k.jpeg"></p><br><p>  Two of the six processes are responsible for running the session, and the rest are local kernels, which are used for parallel computing.  In this case, by default the number of local cores of Mathematica coincides with the number of physical cores of the processor.  But no one bothers to create more.  This is done using <strong><a href="https://reference.wolfram.com/language/ref/LaunchKernels.html">LaunchKernels [n]</a></strong> .  As a result, <em>an additional</em> n cores are launched.  And the number of available processor cores can be viewed in the <strong><a href="https://reference.wolfram.com/language/ref/%2524KernelCount.html">$ KernelCount</a></strong> variable. </p><br><p>  The functions listed at the beginning produce an automatic distribution of tasks among the processes.  However, there is a way to independently send code to run on a specific kernel.  This is done using <strong><a href="https://reference.wolfram.com/language/ref/ParallelEvaluate.html">ParallelEvaluate</a></strong> + <strong><a href="https://reference.wolfram.com/language/ref/ParallelSubmit.html">ParallelSubmit</a></strong> : </p><br><pre> <code class="plaintext hljs">ParallelEvaluate[$KernelID, Kernels[][[1 ;; 4 ;; 2]]] (* Out[..] := {1, 3}*)</code> </pre> <br><p>  This set of functions will be enough to be able to parallelize the task of calculating the weight spectrum. </p><br><h3 id="razdelenie-osnovnogo-cikla-na-chasti">  The division of the main loop into parts </h3><br><p>  Check whether the calculations actually occur in parallel.  For four physical cores, this means that the calculation on all four cores will take as much time as on one: </p><br><pre> <code class="plaintext hljs">basis = RandomInteger[{0, 1}, {24, 24}]; AbsoluteTiming[WeightSpectrumLinearSubspaceGrayCodeEasy[basis];][[1]] AbsoluteTiming[ParallelEvaluate[WeightSpectrumLinearSubspaceGrayCodeEasy[basis]];][[1]] (* Out[..] := 6.518... Out[..] := 8.790...*)</code> </pre> <br><p>  There is a time difference, but not fourfold.  So with this, everything is fine.  The next step is to figure out how to divide the task into several parts.  The most logical and effective is to compute only part of the linear combinations on each core.  That is, as a result, each core returns a partial spectrum.  But how to divide the list <em>b <sub>i</sub></em> .  After all, it is not a direct sequence!  In this case, a function is needed that calculates the value from the Gray Code sequence by index.  This is done like this: </p><br><pre> <code class="plaintext hljs">grayNum[basis_List, index_Integer] := IntegerDigits[BitXor[index, Quotient[index, 2]], 2, Length[basis]] Grid[Table[{i, Row[grayNum[{{0, 0}, {0, 1}, {1, 1}}, i]]}, {i, 0, 7}]]</code> </pre> <br><table><thead><tr><th>  index </th><th>  code </th></tr></thead><tbody><tr><td>  0 </td><td>  000 </td></tr><tr><td>  one </td><td>  001 </td></tr><tr><td>  2 </td><td>  011 </td></tr><tr><td>  3 </td><td>  010 </td></tr><tr><td>  four </td><td>  110 </td></tr><tr><td>  five </td><td>  111 </td></tr><tr><td>  6 </td><td>  101 </td></tr><tr><td>  7 </td><td>  100 </td></tr></tbody></table><br><p>  Now we modify the compiled function so that it considers only a partial spectrum in a certain range of indices of linear combinations: </p><br><pre> <code class="plaintext hljs">WeightSpectrumLinearSubspaceGrayCodeRange = Compile[{{basis, _Integer, 2}, {range, _Integer, 1}}, Module[{ n = Dimensions[basis][[-1]], k = Length[basis], s = Table[0, {n + 1}], currentVector = Table[0, {i, 1, Length[basis[[1]]]}], m = 0, l = 0 }, (*     *) If[range[[1]] =!= 0, currentVector = Mod[Total[basis Reverse[IntegerDigits[BitXor[range[[1]], Quotient[range[[1]] + 1, 2]], 2, k]]], 2]; ]; Mod[Total[basis IntegerDigits[BitXor[range[[1]] - 1, Quotient[range[[1]] - 1, 2]], 2, k]], 2]; s[[Total[currentVector] + 1]] = 1; Do[ m = Log2[BitAnd[-1 - b, b + 1]] + 1; currentVector = BitXor[currentVector, basis[[m]]]; l = Total[currentVector] + 1; s[[l]] = s[[l]] + 1, {b, First[range], Last[range] - 1, 1} ]; (* Return *) s ], (*  ,       *) RuntimeOptions -&gt; "Speed", (*CompilationTarget -&gt; "C",*) CompilationOptions -&gt; {"ExpressionOptimization" -&gt; True} ];</code> </pre> <br><p>  That is, if earlier the function counted all combinations with numbers from 0 to 2 <sup>N</sup> -1, then now this range can be set manually.  Now we will try to figure out how to divide this very range into equal parts depending on the number of available cores: </p><br><pre> <code class="plaintext hljs">partition[{i1_Integer, iN_Integer}, n_Integer] := With[{dn = Round[(iN - i1 + 1)/n]}, Join[ {{i1, i1 + dn - 1}}, Table[{dn * (i - 1), i * dn - 1}, {i, 2, n - 1}], {{(n - 1) * dn, iN}} ] ]</code> </pre> <br><p>  Now, in order to calculate the full spectrum in such a way, it is necessary to calculate it on each of the segments, and then add all the results.  For example: </p><br><pre> <code class="plaintext hljs">WeightSpectrumLinearSubspaceGrayCodeEasy[{{1, 1}, {1, 1}, {1, 1}}] WeightSpectrumLinearSubspaceGrayCodeRange[{{1, 1}, {1, 1}, {1, 1}}, {0, 3}] WeightSpectrumLinearSubspaceGrayCodeRange[{{1, 1}, {1, 1}, {1, 1}}, {4, 7}] (* Out[..] := {4, 0, 4} = Out[..] := {2, 0, 2} + Out[..] := {2, 0, 2} *)</code> </pre> <br><p>  The final step is to send these calculations to different kernels: </p><br><pre> <code class="plaintext hljs">WeightSpectrumLinearSubspaceGrayCodeParallel[basis: {{__Integer}..}] := With[{ kernels = (If[Kernels[] === {}, LaunchKernels[]]; Kernels[]), parts = partition[{0, 2^Length[basis] - 1}, Length[Kernels[]]] }, Total[WaitAll[Table[ ParallelEvaluate[ParallelSubmit[WeightSpectrumLinearSubspaceGrayCodeRange[basis, parts[[$KernelID]]]], kernel], {kernel, kernels} ]]] ]</code> </pre> <br><p>  Here you need to clarify.  Such a combination of <strong>ParallelEvaluate</strong> + <strong>ParallelSubmit</strong> in order to manually control which core will run on which part of the code.  ParallelEvaluate generally cannot figure out how to properly execute asynchronous code and ultimately does it in one stream.  In the general case, ParallelSubmit does not allow you to specify the correct core, but selects it automatically. <br>  Check if this feature works: </p><br><pre> <code class="plaintext hljs">ListPlot[WeightSpectrumLinearSubspaceGrayCodeParallel[RandomInteger[{0, 1}, {16, 128}]], PlotRange -&gt; All, PlotTheme -&gt; "Web", Filling -&gt; Bottom]</code> </pre> <br><p><img src="https://habrastorage.org/webt/i5/zp/ln/i5zplns53-seo0fm8skel7zy9_o.png"></p><br><p>  And as usual we will look at the difference in the speed of calculations.  Since a laptop with a 4-core processor is used, an acceleration of about 4 times is expected.  Plus, we must take into account the time for the division of tasks and the addition of the final result: </p><br><pre> <code class="plaintext hljs">basis = RandomInteger[{0, 1}, {20, 1024}]; AbsoluteTiming[WeightSpectrumLinearSubspaceGrayCodeEasy[basis];] AbsoluteTiming[WeightSpectrumLinearSubspaceGrayCodeParallel[basis];] (* Out[..] := {5.02..., Null} Out[..] := {1.5....., Null} *)</code> </pre> <br><p>  Naturally, with a larger number of processor cores, the difference will be more noticeable.  Now we will try to calculate the spectrum of the base more.  I wonder how long it will take?  Suppose we assume to increase the size of the basis until one calculation takes more than a minute: </p><br><pre> <code class="plaintext hljs">spectrums = Block[{i = 1, basis, res}, Reap[ While[True, i++; basis = RandomInteger[{0, 1}, {i, i}]; Sow[res = AbsoluteTiming[WeightSpectrumLinearSubspaceGrayCodeParallel[basis]]]; If[res[[1]] &gt; 60, Break[]] ] ][[-1, -1]]] ListPlot[spectrums[[-1, -1]], PlotLabel-&gt;Row[{"basis len: ", Length[spectrums] + 1, "; time: ", Round[spectrums[[-1, 1]], 0.01], " sec"}], Filling-&gt;Bottom,PlotTheme-&gt;"Web",PlotRange-&gt;All]</code> </pre> <br><p><img src="https://habrastorage.org/webt/8l/2z/xh/8l2zxhkrm538a-ykvase5evwjts.png"></p><br><p>  The picture clearly shows that in a minute and a half the function can calculate the spectrum for a basis of 29 vectors.  This is a very good result, given that the very first option, which does not use compilation, is gray code, parallelization is hardly capable of all the same in a reasonable time.  The computation time will be thousands of times longer if even for 15 vectors with dimension 10 the calculation took more than 10 seconds. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I do not know who and where applies all that was described in the article.  Wikipedia says the Gray Code has a practical purpose.  I also know that the calculation of spectra is often associated with encryption and some other problems of linear algebra. ,    ,                 :   ,         .   ,      . </p><br><p> PS    <a href="https://vk.com/asbunny"> </a> ,              . </p></div><p>Source: <a href="https://habr.com/ru/post/336350/">https://habr.com/ru/post/336350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336336/index.html">OCaml and RESTful JSON API using Eliom</a></li>
<li><a href="../336338/index.html">Accelerate Viola-Jones Method</a></li>
<li><a href="../336342/index.html">Agents, principals and online ticket booths in between</a></li>
<li><a href="../336346/index.html">How I did realtime roulette on NodeJS & VueJS</a></li>
<li><a href="../336348/index.html">Using the terminal when developing for Android</a></li>
<li><a href="../336352/index.html">Convenient use of Redux in vue components</a></li>
<li><a href="../336356/index.html">App Store on iOS 11: what it will be and what it means</a></li>
<li><a href="../336358/index.html">How to create a racist AI, without even trying. Part 1</a></li>
<li><a href="../336360/index.html">B2P: how in 5 years to collect 3,000 news for a corporate publication in an IT company numbering> 100 people</a></li>
<li><a href="../336362/index.html">Barclays Bank installed spyware sensors to track employees in the workplace</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>