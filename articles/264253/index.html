<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of all tasks of the final round of Yandex. Algorithm 2015</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The final of Yandex.Algorithm has finished today - the annual championship on sports programming, which is organized by Yandex. In 2015, the competiti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of all tasks of the final round of Yandex. Algorithm 2015</h1><div class="post__text post__text-html js-mediator-article">  The final of Yandex.Algorithm has finished today - the annual championship on sports programming, which is organized by Yandex.  In 2015, the competition was completely online - on the <a href="https://contest.yandex.ru/">Yandex.Contest</a> platform.  Applications for participation were filed by programmers from 73 countries.  Most of the participants are from Russia, Ukraine, Belarus, Kazakhstan, India, USA, Japan and China, but in general the geography of the championship is extremely extensive - Brazil, Indonesia, Peru, Dominican Republic, Mozambique, Senegal, Cayman Islands.  8.9% of those registered are girls.  Approximately half of all participants are students.  In total, we received applications from 3,722 people, of whom 28 reached the final. <br><br>  And the winner of Yandex.Algorithm-2015 was Gennady Korotkevich.  <strike>Out of habit, he</strike> showed the best result, deciding in the final round five of the six problems, while receiving 80 minutes of penalty time.  Gennady took the first place in the Yandex Championship both in 2013 and in 2014. <br><br><img src="https://habrastorage.org/files/4dc/310/84a/4dc31084a45442fea01fe15fca409949.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second place went to Peter Mitrichev, and the third - Yevgeny Kapun.  They solved four problems, while Peter scored 31 penalty minutes, and Eugene - 79 minutes.  The results of all the finalists can be viewed on the <a href="https://contest.yandex.ru/algorithm2015/contest/1242/standings/">Yandex.Algorithm</a> website. <br><br>  The tasks for Yandex.Algorithm are made by an international team, which includes both Yandex employees and invited experts - including the winners and finalists of the ACM ICPC and Topcoder Open competitions.  And we have traditionally prepared for you an analysis of all the tasks.  Solve all of them, no one managed.  Most of the participants coped with task B, but tasks A and D decided on just one person. <br><a name="habracut"></a><br><h3>  Task A. Task Manager </h3><br>  <i>The author of the analysis and tasks is Gleb Evroprop.</i>  <i>A graduate of Moscow State University, a double gold medalist ACM ICPC.</i> <br><br>  The intern Bomboslav is working on improving the task manager used by Yandex employees.  The current version of the manager associates with each of the <i>n</i> tasks assigned to the employee two parameters <i>c <sub>i</sub></i> and <i>u <sub>i</sub></i> - the importance and urgency of the task.  Higher values ‚Äã‚Äãof the parameters correspond to the greater importance or urgency of this task. <br><br>  Any employee can choose the order in which he will perform the tasks assigned to him.  The only restriction is as follows: if task <i>i</i> is <b>both</b> more important and more urgent than task <i>j</i> , that is, <i>c <sub>i</sub> &gt; c <sub>j</sub></i> and <i>u <sub>i</sub> &gt; u <sub>j</sub></i> , then it should be performed earlier. <br><br>  Bobmoslav decided to add to the task manager a recommender system that will prompt in what order it is necessary to perform the existing tasks.  Since it is too easy to build such an order, Bomboslav added the ability for employees to specify for each task the value of <i>p <sub>i</sub></i> , meaning the pleasure received from performing this task.  The values ‚Äã‚Äãof <i>p <sub>i</sub></i> for different tasks must be different. <br><br>  After the value of <i>p <sub>i</sub></i> is specified for each of the <i>n</i> tasks, the system should offer the employee such an order of execution that, firstly, no mandatory restrictions are violated, and secondly, the sequence of the values ‚Äã‚Äãof <i>p <sub>i</sub></i> corresponding to these tasks is lexicographically maximum .  In other words, from all sequences of performing tasks that meet the constraints on importance and urgency, the one in which the pleasure received by the employee from the first completed task is selected is selected.  In case there are several such options, the one in which the pleasure from the second completed task is maximized is chosen, and so on. <br><br>  <u>Input format</u>  The first input line contains a single number <i>n</i> - the number of tasks for this employee <i><nobr>(1‚â§ n ‚â§ 100 000)</nobr></i> . <br>  The following <i>n</i> lines describe the tasks in the manager.  Each of them contains three non-negative integers <i>c <sub>i</sub></i> , <i>u <sub>i</sub></i> and <i>p <sub>i</sub></i> - importance, urgency and desire to perform this task by an employee, respectively <i><nobr>(0 ‚â§ c</nobr> <sub>i</sub> , u <sub>i</sub> , p <sub>i</sub> ‚â§ 10 <sup>9</sup> )</i> .  It is guaranteed that all <i>p <sub>i</sub></i> are pairwise distinct. <br><br>  <u>Output format</u>  Output the correct sequence of execution of all tasks by the employee, in which the sequence of the corresponding values ‚Äã‚Äãof <i>p <sub>i is</sub></i> lexicographically maximum.  Tasks are numbered from one in the order in which they appear in the input.  Each task must occur in the sequence exactly once.  It is easy to show that the answer is always the only one. <br><br>  <b>Problem Solving A</b> <br><br>  Note that the condition for the difference of all <i>p <sub>i</sub></i> is essential, since it allows us to use the greedy algorithm, which iteratively extracts the minimum source.  A more detailed description of the algorithm: <br><br><ol><li>  Let some prefix of the optimal answer be constructed, only a certain subgraph remains from the initial graph. </li><li>  Consider the set of sources of the current graph, that is, the set of vertices into which no edges enter.  Obviously, the current topological sorting needs to be continued from one of the vertices belonging to this set.  Let's call these vertices active. </li><li>  Since all <i>p <sub>i are</sub></i> different, then due to the structure of the lexicographic comparison, the next vertex is determined uniquely.  Add an active vertex with maximum <i>p <sub>i</sub></i> to the current response prefix and remove it from the graph. </li></ol><br>  The asymptotic complexity of this solution is <i>O (V ‚àô E)</i> , if you simply implement a text description of the algorithm.  The asymptotics <i>O (V ‚àô logV + E)</i> is easily achieved ‚Äî all that is needed is to memorize the current half-input for all vertices and store the set of active vertices in some structure with the ability to quickly add an element and extract the maximum.  Such a structure can be a binary heap or any balanced search tree. <br><br>  However, in this problem, the graph is given implicitly, and, generally speaking, <i>E</i> may have a size of the order of n <sup>2</sup> , which is too much for these constraints.  It is required to think of a way to quickly determine the new active vertices, after removing the next source from the graph. <br><br>  Let us turn to the idea of ‚Äã‚Äãa compressed two-dimensional tree of segments.  A detailed analysis of this structure is not supposed here. We only <i>recall</i> that it has the dimension <i>O (n ‚àô logn)</i> from memory and allows you to respond to group requests (such as maximum, minimum, or sum in a rectangle during <i>O (log <sup>2</sup> n)</i> ).  This complexity is achieved by dividing the query area into <i>O (logn)</i> lanes by one of the dimensions, for each of which the structure of a one-dimensional tree of segments is already constructed.  In turn, each of these bands is again divided into <i>O (logn)</i> parts. <br><br>  We construct the partitioning in the previous paragraph for each of the <i>V</i> angles of the form <i>x&gt; x <sub>i</sub></i> and <i>y&gt; y <sub>i</sub></i> .  Then the vertex falls into the set of active at the moment when all the elementary regions that make up this angle become empty.  For each elementary region, we will maintain the current number of points inside it, as well as for each point, the number of elementary regions that form its angle and are not yet empty.  Please note that not all elementary areas that fall into this angle are meant here, but only those <i>O (log <sup>2</sup> n)</i> of them that form a partition of the area in the query to a two-dimensional tree of segments. <br><br>  The step of the algorithm now looks like this. <br><ol><li>  Select the active vertex with the maximum pi and remove it from the set of active ones. </li><li>  Consider all the elementary regions of a two-dimensional tree of segments that contained a point corresponding to a given vertex.  According to the properties of this structure, there will be no more than <i>O (log <sup>2</sup> n)</i> .  Each such area to reduce the counter by one. </li><li>  For all areas whose counter has become zero, it is necessary to consider a list of all points - such that this area is included in the decomposition of the corresponding angle.  These lists are built in advance, even before the launch of the main algorithm.  For each point in the list, the counter is also reduced by one. </li><li>  For all points whose counter has become zero, the corresponding vertices are added to the set of active ones. </li></ol><br>  Total running time: <i>O (n ‚àô log <sup>2</sup> n)</i> , as well as occupied memory. <br><br><h3>  Problem B. At a picnic on the bus </h3><br>  <i>The author of the task and analysis is Mikhail Tikhomirov.</i>  <i>Graduate of MSU, Topcoder Open 2014 finalist.</i> <br><br>  Every summer, Yandex employees go to nature on Yandex.Picnik.  For employees who do not have their cars, buses are rented from the office to the place of rest. <br><br>  You have information about the number of employees who need a bus.  In addition, some groups of employees would like to occupy seats in the same row of seats in the bus.  The bus, which provides the transport company, in the same row are six seats.  Before ordering, it is required to determine how many rows of six chairs are needed to accommodate all groups of employees as desired. <br><br>  <u>Input format</u>  The first line contains a single integer <i><nobr>(1 ‚â§ n ‚â§ 100)</nobr></i> - the number of groups of employees.  The next line contains <i>n</i> integers <i>a <sub>i</sub></i> , separated by spaces - sizes of groups <i><nobr>(1 ‚â§ a</nobr> <sub>i</sub> ‚â§6)</i> . <br><br>  <u>Output format</u>  Print one number - the minimum number of rows of six seats that can accommodate all groups according to the wishes. <br><br>  <b>Solution of Problem B</b> <br><br>  The general idea: if the number of places in a row does not exceed six, a simple greedy algorithm works. <br><br>  Obviously, each group of size 6, 5 or 4 must be placed in a separate row.  Groups of size 3 should be as tight as possible: fill <img src="https://tex.s2cms.ru/svg/%5Cleft%20%5B%20k%2F2%20%5Cright%20%5D">  rows in pairs of triples, and, perhaps, one of the remaining three to put in a separate row.  Indeed, suppose that there are two rows in the optimal partition, each of which contains one triple.  Then we swap one of the triples with those groups that sit in the same row as the second trio.  After several such operations, we move all triples so that the described condition is fulfilled. <br><br>  Now arrange the twos and single groups.  If you arrange everything except for units, then after that the arrangement of units is determined unambiguously: we fill in the remaining free places in the used rows, and then completely fill in the new rows one by one.  It is easy to see that deuces should be placed in the same way: as long as there are at least two places in one of the used rows, we will put another deuce there. <br><br>  The described algorithm can be briefly described as follows: we consider groups in descending order of size, each placed in a row, in which there is less than the entire place, but enough for our group. <br><br><h3>  Problem C. The whole work </h3><br>  <i>The author of the task and analysis is Oleg Khristenko.</i>  <i>Coordinator of Yandex.Algorithm, Open Cup, snarknews project.</i> <br><br>  Given <i>N - 1</i> fractions <i>u_i / d_i</i> , with <i><nobr>2 ‚â§ u</nobr> <sub>i</sub> ‚â§ N</i> and <i><nobr>2 ‚â§ d</nobr> <sub>i</sub> ‚â§ N</i> , all <i>u <sub>i</sub></i> are pairwise different and all <i>d <sub>i</sub></i> are pairwise different.  Choose at least 1 and at most <i>N / 10</i> fractions so that their denominators are powers of primes, and the product of all selected fractions is an integer. <br><br>  <u>Input format</u>  The first line contains one integer <nobr><i>N (10 ‚â§ N ‚â§ 10 <sup>6</sup> )</i></nobr> .  Each of the following <i>N - 1</i> lines contains one fraction in the format <i>u_i / d_i (2 ‚â§ u <sub>i</sub> , d <sub>i</sub> ‚â§ N, u <sub>i</sub> ‚â† u <sub>j</sub></i> for <i>i ‚â† j, di dj</i> with <i>i j</i> ).  There are no spaces between the numbers and the ‚Äú/‚Äù sign. <br><br>  <u>Output format</u>  Print two lines.  The first must contain an integer <i>M</i> - the number of selected fractions.  The following <i>M</i> lines must contain the selected fractions themselves, specified in the same format as in the input, one per line.  Denominators of all selected fractions must be powers of primes, that is, have the form <img src="//tex.s2cms.ru/svg/p%5E%7Bi%7D_%7Bk%7D_%7Bi%7D" alt="image">  where <i>p <sub>i</sub></i> is a prime and <i>k <sub>i</sub></i> is a positive integer.  Fractions can be displayed in any order.  One fraction can be selected no more than once. <br><br>  If there are several solutions, output any.  If there is no solution, output <i>-1</i> in the first line. <br><br>  <b>Parsing task C</b> <br><br>  Note that for <i>N</i> from 10 <sup>5</sup> to 2 ‚àô 10 <sup>5 the</sup> number of prime numbers not exceeding <i>N</i> is less than <i>N / 10</i> . <br>  We show that if you want to choose <i>P (N)</i> or more fractions, where <i>P (N)</i> is the number of prime numbers not exceeding <i>N</i> , then the problem always has a constructive solution. <br><br>  We will choose as follows.  First choose the fraction <i>N / 2</i> .  If <i>N is</i> even, the answer is received.  If <i>N is</i> odd, choose a fraction with the smallest simple divisor of <i>N</i> as the denominator.  If the numerator is even, the first two fractions are the answer.  If the numerator is divided by the denominator, the second fraction is the answer.  At each next step, we try to choose a fraction with the smallest simple divisor of the previous numerator as the denominator.  If it turns out that this number was already in the denominator at the <i>i-</i> th step, then the section from the <i>i-</i> th fraction to the last selected one is the answer.  Otherwise, select the appropriate fraction.  In the worst case, we thus choose all prime numbers not exceeding <i>N</i> as denominators, after which repetition will inevitably happen. <br><br><h3>  Task D. Unite and conquer </h3><br>  <i>The author of the analysis and tasks is Gleb Evroprop.</i> <br><br>  Not so long ago, Yandex employees patented an algorithm for optimal fragmentation of a large set of ordered data for transmission over the network.  Now they are faced with the task of searching for an already fragmented pattern in fragmented data.  It sounds difficult enough, but they are ready to challenge this task, especially with your help.  We will not go into their motivation and immediately proceed to the formulation of the problem. <br><br>  There is an initial sequence <i>a <sub>i</sub></i> , consisting of <i>n</i> numbers from 1 to 5, describing the sizes of consecutive parts in the fragmentation of the original data.  There is also a sequence <i>b <sub>i</sub></i> consisting of <i>m</i> numbers from 1 to 5, similarly describing the sizes of consecutive parts in a sample fragmentation. <br><br>  For one action, it is allowed to select any two neighboring elements in one of two sequences and combine them, replacing them with one element with a value equal to their sum.  Thus, from sequences <i>1, 2, 2</i> in one operation, only sequences <i>3, 2</i> and <i>1, 4</i> can be obtained.  After performing this operation in sequence, an element that is more than 5 may well appear. It is required to calculate the minimum number of actions that need to be done with these sequences so that the sequence <i>b <sub>i</sub></i> becomes a substring of the sequence <i>a <sub>i</sub></i> . <br><br>  <u>Input format</u>  The first line of the input contains two integers <i>n</i> and <i>m</i> - the number of fragments in the initial data partitioning and the number of fragments in the partitioning pattern for the search, respectively <nobr><i>(1 ‚â§n, m ‚â§ 200,000)</i></nobr> . <br><br>  The next line contains <i>n</i> numbers <i>a <sub>i</sub></i> , each from 1 to 5 inclusive, specifying the sizes of the fragments in the initial data partitioning. <br><br>  The last line contains <i>m</i> numbers <i>b <sub>i</sub></i> , describing the sizes of the fragments in the pattern partitioning in a similar format. <br>  <u>Output format</u>  Print a single integer - the minimum number of actions necessary for the second sequence to become a substring of the first.  If it is impossible to achieve this, then output <i>-1</i> . <br><br>  <b>Parsing task B</b> <br><br>  We will learn to solve for the beginning, in polynomial time, the problem of checking that there is some positive answer.  Enumerate two boundaries in the original sequence.  How to check that the sequence <i>b <sub>i is</sub></i> in principle possible to display <i>a <sub>i i</sub></i> in the selected fragment?  Check whether the sum of all elements <i>b <sub>i is</sub></i> equal to the sum of the selected elements <i>a <sub>i</sub></i> .  It is easy to see that this condition is necessary and sufficient, since without limiting the number of operations you can simply merge all the elements into one. <br><br>  The algorithm described above has complexity <i>O (n <sup>2</sup> + m)</i> .  Note that since all elements are positive, the sum on the subsegment will be a strictly monotonic function on both boundaries.  Using the method of two pointers, we solve the problem of checking the existence of a response in <i>O (n + m) time</i> . <br><br>  Suppose we know that the sum of the elements of the sequence <i>b <sub>i</sub></i> is equal to the sum of the elements in some sequence <i>c <sub>i</sub></i> (the sub-segment <i>a <sub>i</sub></i> ).  Determine the minimum number of merge operations needed to make these sequences the same.  Consider an arbitrary positive number <i>x</i> such that both sequences have a prefix equal to <i>x</i> .  One of these numbers <i>x</i> will match the first character in both sequences after all the joins have been completed.  It is easy to see that if there are two different <i>x <sub>1</sub></i> and <i>x <sub>2</sub> (x <sub>1</sub> &lt;x <sub>2</sub> )</i> that meet the above requirement, then the answer with the minimum number of unions (and therefore the maximum length) is never beneficial to start with <i>x <sub>2</sub></i> . <br><br>  Indeed, since each element in the final answer corresponds to sub-slices in each of the sequences <i>b <sub>i</sub></i> and <i>c <sub>i</sub></i> , this sub-segment can always be divided into two, which will form the elements <i>x <sub>1</sub></i> and <i>x <sub>2</sub> - x <sub>1</sub></i> .  From this it follows that the optimal answer can be typed greedily, using all <i>x</i> such that both sequences have a prefix equal to <i>x</i> .  The number of such <i>x</i> will determine the length of the response, and hence the number of operations. <br><br>  We learned how to isolate <i>O (n)</i> interesting sub-splices and find the answer for each of them in <i>O (n + m) time</i> .  This is still too slow.  We calculate all partial sums in both sequences and mark them in the bitmap.  Then the calculation of the number of matching elements is reduced to the calculation of the scalar product of two bit sequences.  You can calculate the result of the dot product of one sequence with all the suffixes of the other using the fast Fourier transform.  The final complexity of the solution is: <i>O (cn ¬∑ log (cn))</i> , where <i>c</i> is the upper bound on the elements <i>a <sub>i</sub></i> and <i>b <sub>i</sub></i> . <br><br><h3>  Problem E. Compact strings </h3><br>  <i>The author of the task and analysis is Michal Foriszek.</i>  <i>Finalist of Yandex. Algorithm 2013, author of ACM ICPC, IOI.</i> <br><br>  This task deals with strings of lowercase Latin letters (‚Äúa‚Äù - ‚Äúz‚Äù).  A string is called <b>compact</b> if there are only the same letters between any two identical letters in this string.  For example, the strings ‚Äúyandex‚Äù, ‚Äúaacccb‚Äù, and ‚Äúeeeee‚Äù are compact, and the strings ‚Äúaba‚Äù and ‚Äúaazbbzc‚Äù are not. <br><br>  You are given a pattern consisting of lowercase Latin letters and question marks ("?").  Each question mark represents one arbitrary lowercase Latin letter. Find the number of different compact strings that match the specified pattern.  Since the answer can be very large, output the remainder of dividing it by <i>10 <sup>9</sup> + 7</i> . <br><br>  <u>Input format</u>  The first line of the input contains an integer <i>t</i> - the number of test cases <nobr><i>(1 ‚â§ t ‚â§ 100)</i></nobr> .  Each of the following <i>t</i> lines defines one test case, which is a pattern of at least <i>1</i> and not more than <i>10 <sup>4</sup></i> characters inclusive.  The template can consist only of lowercase Latin letters and question marks. <br><br>  <u>Output format</u>  For each test case, output a single integer - the remainder of dividing the number of corresponding compact lines by <i>10 <sup>9</sup> + 7</i> . <br><br>  <b>Parsing task E</b> <br><br>  First, consider a simpler task: given a pattern, is there at least one compact string that corresponds to it?  Such a problem is simply solved in linear time: you need to remove all question marks and check whether the resulting string is compact.  Accordingly, the first step of our decision will be such a check;  if it fails, output 0. <br><br>  After that we will make some pre-submission that will help us in the future: whenever we see a string of consecutive question marks, to the right and left of which there is the same letter (for example, <i>z ??? z</i> ), we notice that question marks can be uniquely disclosed (will be equal to this letter itself), so that in the context of this task this line can be replaced by exactly one such letter (that is, the fragment <i>z ??? z</i> changes to <i>z</i> ). <br><br>  Further we will use the following notation: <br><ul><li>  <i>N</i> to denote the length of this pattern (in this problem no more than 10 <sup>4</sup> ); </li><li>  <i>S</i> to indicate the size of the alphabet (in this case, 26); </li><li>  <i>U</i> to indicate the number of letters of the alphabet that are not found in this pattern. </li></ul><br><br>  If <i>U = 0</i> , then the problem is solved simply.  For each block of consecutive question marks, it remains unknown only where the first letter ends and the second begins. <br><br>  For example, in block <i>a ???? b</i> , question marks can be replaced with a few (possibly zero) letters <i>a</i> at the beginning, and the remaining question marks will be replaced with letters <i>b</i> .  The number of options for each block is thus equal to the number of question marks plus one, and since the blocks are independent, the total number of options is equal to the product of these numbers. <br><br>  In the general case, when <i>U ‚â† 0</i> , additional options appear: we need to determine which of the letters that are missing in the template are present in the summary line and where.  Note that each of these letters must also form a continuous substring of the result string, so that if such a letter meets somewhere, then all its occurrences must belong to the same block of consecutive question marks. <br><br>  There are several ways to effectively count the number of such lines.  One of the possible approaches uses a fairly standard way: we will try to recursively generate all these lines, adding one letter at a time, then we will replace the generation with a count with memoization.  In case the corresponding actions are done correctly, as a result we will get a memorable recursive function that will respond to any request in <i>O (NU) time</i> . <br><br>  The recursive function will take the following arguments: <ol><li>  The number of characters in the template that remains to be processed. </li><li>  Number of letters not yet used. </li><li>  Type of last character processed. </li></ol><br>  The type can take one of four values: <ul><li>  <b>fixed</b> : the last processed character was a letter, which we put in a string, because they must. </li><li>  <b>past</b> : the last character processed was a question mark, and we decided to replace it with the last letter that was processed. </li><li>  <b>future</b> : the last processed was a question mark, and we decided to replace it with the next letter, which will occur in the template in the future (since our task is only counting, we don‚Äôt need to know what letter it is). </li><li>  <b>unused</b> : the last character processed was a question mark, and we decided to replace it with a letter that had not been used before. </li></ul><br><br>  Knowing the type of the previous letter, we know what opportunities we have for the disclosure of the next question mark.  For example, if the type was <b>future</b> , then the <b>future</b> type will be for all letters from the block. <br><br>  In addition, there is another approach that gives a slightly faster solution.  Note that after initialization (checking for the existence of a solution and replacing all trivial blocks with one letter), we can receive no more than <i>S + 1</i> blocks of consecutive question marks: one can be at the beginning of a line, and before starting any of the other blocks, some is a letter.  After initialization, all these letters will be different in pairs.  Thus, the number of blocks cannot exceed the number of letters in the alphabet by more than 1. <br><br>  Now we can calculate all the compact substrings that match the patterns using combinatorial methods.  For this, we use a recursive function that will process blocks of consecutive question marks.  Thus, the function will have two arguments: the number of blocks that remains to be processed, and the number of letters not currently used. <br><br>  Processing the new block, we will consider all the options for the number of unused letters that we want to use in this block at least once.  Thus, the answer will be equal to the product of the number of ways to select a specific set of unused letters (binomial coefficient) and the number of ways to arrange the already selected letters (factorial) and the number of ways to choose places where the chain of letters of one type ends and the other begins (again, the binomial coefficient) on the number of ways to fill the remaining blocks using the remaining unused letters (the result of a recursive call). <br><br>  Thus, we get a solution that uses <i>O (NU)</i> time to build a table of binomial coefficients for a given module and responds to a single request in <i>O (SU <sup>2</sup> ) time</i> . <br><br><h3>  Problem F. Random points </h3><br>  <i>The author - Ivan Kazmenko.</i>  <i>Graduate of St. Petersburg State University, author of the tasks of the championships of St. Petersburg State University and the Open Cup.</i> <br><br>  Consider the following linear congruential pseudo-random number generator.  The generator has a state - an integer <i><nobr>s (0 ‚â§ s &lt;2</nobr> <sup>32</sup> )</i> .  Every time when another pseudo-random integer is required in the interval <i>[0, X)</i> , the generator performs the transformation <i>S <sub>new</sub> = (a ‚àô S <sub>old</sub> + c) mod2 <sup>32</sup></i> .  After this, <i>S <sub>new</sub></i> becomes the new state of the generator, and the result is the number <img src="https://tex.s2cms.ru/svg/%5Cfrac%7BS_%7Bnew%7D%5Ccdot%20X%7D%7B2%5E%7B32%7D%7D" alt="image">  . <br><br>  In this task, <i>a = 134 775 813</i> and <i>c = 1</i> ‚Äî such values ‚Äã‚Äãare used in the built-in pseudo-random number generator in Borland Delphi 7. This generator is used to obtain <i>n</i> random points on a plane whose coordinates are integers from the interval <i>[0, 100 000 000 )</i> .  Consider two ways to generate points. <br><br>  In the first method (codename RAW), the generator is driven to some initial state <i>s</i> , after which it successively generates <i>2n</i> pseudo-random numbers <i>a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>2n</sub></i> in the desired interval.  After that, <i>n</i> random points are given by the following coordinate pairs: <i>(a <sub>1</sub> , a <sub>2</sub> ), (a <sub>3</sub> , a <sub>4</sub> ), ..., (a <sub>2n - 1</sub> , a <sub>2n</sub> )</i> . <br><br>  In the second method (codename SHUFFLED), the beginning of the process is the same: the generator is driven to some initial state s, after which it successively generates <i>2n</i> pseudo-random numbers <i>a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>2n</sub></i> in the desired interval.  However, then these <sub>2n</sub> numbers are rearranged randomly using the following version of <a href="https://en.wikipedia.org/wiki/Fisher%25E2%2580%2593Yates_shuffle">the Fisher-Yeats algorithm</a> (pseudo-code): <br><br>  <i>for i = 1,2, ..., 2 ‚àô n:</i> <i><br></i>  <i>k = random [0, i) + 1</i> <i><br></i>  <i>swap (a <sub>i</sub> , a <sub>k</sub> )</i> <br><br>  Here, <i>random [0, i)</i> is a pseudo-random integer from the interval <i>[0, i)</i> for which generation the same generator is used, and <i>swap (a <sub>i</sub> , a <sub>k</sub> )</i> swaps the numbers <i>a <sub>i</sub></i> and <i>a <sub>k</sub></i> ;  if <i>i = k</i> , nothing happens.  Before starting the execution of the pseudo-code, the generator is in the state in which it was after generating the numbers <i>a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>2n</sub></i> <br><br>  After the numbers <i>a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>2 n</sub></i> are rearranged, <i>n</i> random points, as in the first method, are defined by the following coordinate pairs: <i>(a <sub>1</sub> , a <sub>2</sub> ), (a <sub>3</sub> , a <sub>4</sub> ), ..., (a <sub>2 n - 1</sub> , a <sub>2 n</sub> )</i> . <br><br>  A sequence of <i>n</i> points is specified <i>(10,000 ‚â§ n ‚â§ 100,000)</i> .  It is known that it is obtained by one of the two methods described above.  In this case, it is unknown which method was chosen, as well as the initial state <i>s</i> .  Find out which point generation method was used. <br><br>  <u>Input format</u>  The first line contains an integer <i>n</i> - the number of points <i><nobr>(10,000 ‚â§ n ‚â§ 100,000)</nobr></i> .  The following n lines contain point descriptions, one per line.  Each point description consists of two integers separated by a space ‚Äî its <i>x</i> and <i>y</i> coordinates <i>(0 ‚â§ x, y &lt;100 000 000)</i> .  It is guaranteed that the points are obtained in one of two ways described in the condition. <br><br>  <u>Output format</u> <br>  Output "RAW" if the first method of generating points was used, and "SHUFFLED" if the second method was used. <br><br>  <b>Solution of Problem F</b> <br><br>  <b>General observations.</b>  It is easy to show that the random numbers generated form one cyclic sequence of 2 <sup>32</sup> numbers.  The only thing that depends on the initial state is which element of this cyclic sequence will start generating. <br><br>  <b>The first decision.</b>  This solution is probabilistic, that is, it gives the correct answer with a certain probability close to unity.  The basic idea is to come up with some property that is most likely inherent in only one of the two ways of generation, and then check that this property is either satisfied, or with high probability is not met. <br><br>  Here is a simple example of such a property.  Fix a small number <i>k</i> (for example, <i>k = 10</i> ).  Let the coordinates of <i>n</i> points be generated sequentially.  Then any continuous subsequence of points of length <i>k is</i> also obtained by sequential generation of random numbers, starting from a certain state.  And when generating <i>n</i> points with coordinate mixing, the probability that some kind of continuous subsequence of points of length <i>k is</i> obtained by sequential generation of random numbers is very small. <br><br>  The solution testing this property may look like this.     <i>t</i> (, <i>t = 10 <sup>6</sup></i> ).  <i>t</i>  :       <i>k</i>    .    ,   <i>k</i>         <i>n</i> .        , ,     .   , ,    . <br><br>  ,     <i>k</i>  <i>t</i>         10 <sup>- 10</sup> . <br><br>        <i>O(k)</i>  <i>O(k</i> log <i>n)</i> ,     ,              <i>O(1)</i> (-)  <i>O(logn)</i> (  ).      <i>O(n + tk)</i>  -  <i>O(n</i> log <i>n+tk</i> log <i>n)</i>    . <br><br> <b> .</b> ,    .  ,         <i>(x <sub>1</sub> )</i> .  ,  <img src="https://tex.s2cms.ru/svg/x_%7B1%7D%3D%5Cleft%20%5B%20%5Cfrac%7Bs%5Ccdot%2010%5E%7B8%7D%7D%7B2%5E%7B32%7D%20%7D%5Cright%20%5D" alt="image">  . , <i>s</i>   <img src="https://tex.s2cms.ru/svg/%5Cfrac%7Bx_1%5Ccdot%202%5E%7B32%7D%7D%7B10%5E8%7D" alt="image">  .    43  <i>s</i> ,      <i>x <sub>1</sub> <sub>.</sub></i>         <nobr><i>2n - 1</i></nobr> : <i>y <sub>1</sub> ,x <sub>2</sub> , y <sub>2</sub> , ..., x <sub>n</sub> , y <sub>n</sub></i> .   - <i>s</i>     , ,   .    <i>s</i>   ‚Äî ,   . <br><br> ,             :   <i>s</i>    ,     .       . </div><p>Source: <a href="https://habr.com/ru/post/264253/">https://habr.com/ru/post/264253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264243/index.html">CAD technology</a></li>
<li><a href="../264245/index.html">Online Payment Statistics</a></li>
<li><a href="../264247/index.html">Google and Samsung promise to regularly update Android</a></li>
<li><a href="../264249/index.html">New Hyper-V vNext features</a></li>
<li><a href="../264251/index.html">Golang to AeroFS</a></li>
<li><a href="../264255/index.html">Best practices from Google to develop Android applications</a></li>
<li><a href="../264257/index.html">How site developers create the future of TV</a></li>
<li><a href="../264259/index.html">Banana Pi: via U-Boot to Arch Linux</a></li>
<li><a href="../264261/index.html">Research gaming settings</a></li>
<li><a href="../264263/index.html">Accelerate the launch of BeagleBone or runit not for dummies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>