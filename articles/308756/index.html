<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Project Life in Production: Operational Tips</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An important point that is often overlooked by developers is the operation of the project. How to choose a data center? How to predict threats? What c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Project Life in Production: Operational Tips</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/03c/cd4/d38/03ccd4d384871d043423adc7bd07677f.jpg" alt="image"><br><br><p>  An important point that is often overlooked by developers is the operation of the project.  How to choose a data center?  How to predict threats?  What can happen at frontend level?  How to balance front-end?  How to monitor?  How to set up logs?  What metrics are needed? </p><br><p>  And this is only a frontend, and there is also a backend and a database.  Everywhere there are different laws and logic.  More information about the operation of highload projects in the report by Nikolay Sivko ( <a href="http://okmeter.io/">okmeter.io</a> ) from the HighLoad ++ Junior conference. </p><br><a name="habracut"></a><br><h1>  Project Life in Production: Operational Tips </h1><br><h2>  Nikolay Sivko ( <a href="http://okmeter.io/">okmeter.io</a> ) </h2><br><p>  I want to tell you about the operation.  Yes, the HighLoad conference is more about development, how to cope with high loads, etc.  etc. - the organizers gave me such an introduction, but I want to talk about fault tolerance, because, in my opinion, this is also important. </p><br><p>  It is necessary to begin with the statement of the problem - the definition of what we want. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/980/f8b/a25/980f8ba259038d81ba0413ad14954673.png"><br><br><p>  There will be no rocket science, no particularly top-secret recipes I will give.  I will base on the fact that the intended public is novice exploiters.  Therefore, it will be just a summary of how to plan for fault tolerance. </p><br><p>  At the entrance we have a website, and we will assume that he makes money.  Accordingly, if the site is turned off and is not available to users, then it does not earn money, and this is a problem.  Here we will solve it.  How much money he earns is a question, but we will try to do everything we can for not enormous money, i.e.  we have a small budget, and we decided to spend some time on fault tolerance. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/31a/dad/e0e/31adade0e67f4ae87dbc6d7c9e7635d4.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  We must immediately limit ourselves in desires, i.e.  make four nines, five nines immediately not worth it.  We will rely on everything that data centers offer us - they have a different level of certification, the data center design is certified, i.e.  as far as everything is fail-safe there, and we probably will not try to jump further than TIER III, i.e.  eight minutes of downtime per month, 99-98% uptime will come down to us.  Those.  we are not going to reserve a data center yet. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b4b/ba0/c29/b4bba0c29df0b972c6e2148704c60a58.png"><br><br><p>  In reality, when the data center is certified slightly lower than TIER III (or rather, I do not remember which order), then in fact the data centers in the modern world work quite well.  Those.  in Moscow, to find a data center that works steadily from year to year, as they say, without a single gap, is not difficult.  You can google, you can ask for feedback.  As a result, you got up somewhere and put your iron.  But everything that breaks inside the data center is more likely to fail, i.e.  Iron breaks, software breaks.  The software that was not written by you breaks down a bit less often, because there is a community, sometimes there is a vendor that monitors fault tolerance, but the software that you wrote is likely to break more often. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/7ea/6e8/2a7/7ea6e82a79aedb875ad83e8db2a705fe.png"><br><br><p>  We need to start somewhere.  Let's say there is a dedicated server for 20 thousand rubles a month, from this we will dance.  On it, we have a bunch of everything: the frontend, the backend, the base, some ancillary services, memcached, the queue with asynchronous tasks and the handlers that rake them up and make them.  Here?  We will work with this, and, in order. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/026/54f/60c/02654f60cfa31731c2425d61d285e150.png"><br><br><p>  Approximate algorithm - we take each subsystem, we approximately estimate how it can break, and we think how it can be repaired. </p><br><p>  I must say - to fix everything is unreal.  If it were possible to fix everything, there would be 100% uptime, and all this would not be necessary.  But let's try everything we can quickly close. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/1ca/7ec/c37/1ca7ecc373844121f170653d66f3b3a6.png"><br><br><p>  Accordingly, how does the average project work, starting from the year 2000?  There is a backend, there is a frontend, memcached often, but it doesn‚Äôt matter, the message queue, the handlers and the base.  If there is something else that we have not covered, approximately understanding the algorithm, you can do it yourself. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/926/ee8/fd2/926ee8fd209fa128dc1c84d9413887f5.png"><br><br><p>  Frontend.  What is it for?  It accepts all incoming requests, is committed to serving slow clients, somehow optimizing the load on our fatter backend, giving statics on its own from the disk, doing services to Transport Layer Security, in this case, to sites with respect to https, proxies requests for backends, balancing between backends, sometimes there is a built-in cache. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/323/2e6/cee/3232e6cee7588160f990dad3b404eb44.png"><br><br><p>  What can happen?  The piece of iron on which at you Nginx or other frontendovy server can stupidly break.  Nginx itself may die or something on this machine for various reasons.  It can blunt everything, for example, you have rested against resources, have rested against a disk, etc.  And in the end everything slows down.  Let's start to solve it. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/387/174/722/387174722f8d0030a7bff7b72ea6389d.png"><br><br><p>  The frontend in itself does not carry any condition, as a rule.  If this is not the case, then I advise you to fix it urgently.  If he is stateless, i.e.  it does not store data, the client is not obliged to come with his requests only to him, you can put several pieces of iron and, in fact, organize balancing between them. </p><br><p>  What are the difficulties?  As a rule, everything that happens above is not our area of ‚Äã‚Äãresponsibility, we cannot twist anything there, there is already a provider who gave us the string that we stuck into our server. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/076/e92/aa3/076e92aa32c44a717d31c7e714dfef7d.png"><br><br><p>  There are ways to do something about this too.  The first, most primitive thing you can do without having any skills is the DNS round robin.  Just for your domain, you specify several IPs, one IP of one frontend, another - of another, and everything works. </p><br><p>  The problem here is that the DNS does not know whether the server you registered there is working or not.  If you even teach the DNS to know about it and not give a broken IP in the response, you still have the DNS cache, there are crookedly configured caches for different providers, etc.  In general, you should not pledge the fact that you quickly change the DNS.  The reality is that even if you have a low TTL registered in the DNS, clients will still break into a non-working IP. </p><br><p> There are technologies that are generally called Shared IP, when one IP address is used between several servers, which you register in the DNS.  Implementation of protocols such as VRRP, CARP, etc.  Just google how to do it, then it will be clear. </p><br><p>  The problem here is what?  You need the provider to ensure that both servers are in the same Ethernet segment, so that they can transfer service heartbeats and so on. </p><br><p>  And yet - it does not provide you with load balancing, i.e.  Your backup server will always be idle.  The solution is simple - we take two servers, take two IP, one master for one, another master for another.  And they insure each other.  And in the DNS we register both, and everything is fine. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/5a0/bc5/13a5a0bc5143ff4a5e67bb3326912d3e.png"><br><br><p>  If you have in front of these servers some kind of a router or another network piece of hardware that can do routing, you can prescribe such simple hints for Cisco, let's say, equivalent routes and somehow make these routes get rid of the hardware, server is down.  For Juniper, this can be done using BFDd.  But, in general, these words will be available - google and master it. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/2ee/f35/e63/2eef35e63e82eacfb6199c2b66e86e9b.png"><br><br><p>  Something like this works through Cisco.  These are pieces of a config.  You announce one IP-address, and it has two routes - through one server and through the other.  Is the target IP hanging on each frontend on a lowback interface?  and somehow the check validation logic is provided.  Cisco itself is able to check the status of the router, for example, it can check the CB-connection on the Nginx port or something else, or just trite ping.  Everything is simple, it is unlikely that someone in a small project has its own router. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4ad/027/356/4ad02735671a42fb77cf2c00849b601d.png"><br><br><p>  Everything we do needs to be monitored at the same time because, despite how it reserves itself, you need to understand what is happening in your system. </p><br><p>  In the case of frontends, monitoring by logs works very well, i.e.  your monitoring reads logs, builds histograms, you start to see how many errors you give to your users and see how fast your website works. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ff7/776/fc9/ff7776fc9cd022e14965b3f9256b320f.png"><br><br><p>  About this picture is very revealing.  You see on the Y axis requests per second to your site.  In this case, about 500 requests per second.  In a normal situation, there are slow requests - they are marked in red - these are requests that are processed longer than a second.  Greens are those that are faster than 500 ms, yellows are something in the middle, and black is errors.  Those.  immediately you see how your site works - just like 5 minutes ago or not.  There are two red outliers - this is just a problem.  This slowed down the site, somewhere in the eye 30-40% of user requests were stupid. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/6eb/df2/3ef/6ebdf23efad13afc330aa79417736351.png"><br><br><p>  So, according to these metrics, you can set up alerts that will uniquely tell you how your site works - good or bad.  For example, here are the thresholds.  Those.  if for a site with 200 requests per second errors are more than 10 requests per second, then this is a criticized alert.  If the percentage of slow requests that are more than a second, more than five, for example, then this also criticized the alert. </p><br><p>  So, we covered the whole site with monitoring.  Well, not the whole site, but, in principle, the state of the site and, in general, we can go further. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/dfd/05a/28c/dfd05a28ca9627d385e771852023fc19.png"><br><br><p>  So, on this layer, we somehow closed two problems by reserving the frontends, we are checking the frontend and service on it on the way.  We have closed two problems; we will not solve the third problem, because it is difficult, because we need to rely on metrics in decision making.  We simply monitor it, and if we have a problem, we come and sort it out with our hands.  This is already 10 times better than nothing. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/0fe/e25/450/0fee25450bbe7718f6c9135bc54e21dc.png"><br><br><p>  Go ahead.  Backend.  What is the backend for?  It collects, receives data, as a rule, from some storages, from a database, somehow converts it and gives the answer to the user.  Accordingly, there is some part of the requests when we are waiting for someone.  There is a part when we calculate something, let's say we render the template and just give the answer to the user. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c53/0d6/7fb/c530d67fb3eb60017a78b96aa8318926.png"><br><br><p>  We write out the risks: the piece of iron has broken, the server itself has died up, there are problems with the services from which the backend takes data, i.e.  Tupit database, tupit something else, stupid due to the fact that we ourselves do not have enough resources, stupid from the fact that we received more requests than we can physically serve.  I wrote it out, but maybe not everything, I give you an approximate algorithm. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/09c/e8b/15d/09ce8b15d049baf0f10532d09c087c99.png"><br><br><p>  We start to think and close. </p><br><p>  Backend is also better to do stateless and store user sessions on disk, etc.  Thus, you simplify the task of balancing, i.e.  You can not bathe, where to send the next user request.  We can put a few pieces of iron and make balancing on the front end. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/19f/c0c/d5a/19fc0cd5a0c572fb5d85eb614b659d81.png"><br><br><p>  To protect yourself from a large number of requests for each backend, you need to understand what the limit of backend performance is and configure the limits in it.  Suppose there is a limit in apache that you can configure, that is, for example, ‚ÄúI take only 200 parallel requests and no longer take.  If more has come, I give ‚Äú503‚Äù - this is an intelligible status that I can no longer serve the request now. ‚Äù  Thus, we show the balancer or, in our case, the frontend, that the request can be sent to another server.  Thus, you do not suffer from overload - if your system is completely overloaded, you give the user "503" - a clear error like "Dude, I can not."  This is instead of all requests being blunted and hanging on hold, and customers do not understand what is happening at all. </p><br><p>  Also a moment that everyone forgets.  In projects that are developing rapidly, they forget to check timeouts for everything, i.e.  set timeouts.  If the input of your backend goes somewhere outside, let's say in the memcached database, you need to limit how much you will wait for a response.  You can not wait forever.  Waiting for, say, a postgress response, taking a connection with it, taking some resources, and you need to fall off in time, say: ‚ÄúThat's all, I can‚Äôt wait any longer‚Äù and give the error up.  Thus, you exclude situations when everything is dull with you, there is nothing in the logs, because all operations are in progress, and you do not understand what is happening.  It is necessary to limit timeouts and treat them very carefully, then you will get a more manageable system. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/276/075/73a/27607573a9d5407f130df185f3dc56c6.png"><br><br><p>  Balancing.  In this case, just.  If you have Nginx on the frontend, then you just prescribe a few upstream.  Again, about timeouts - for lokalki connection, the timeout should not be seconds, but tens of milliseconds, or even less, you have to look at your situation.  Speak, in which cases to repeat requests to a neighboring server.  Limit the number of retrae, so as not to cause a storm.  The big question is whether to retract requests for data modification, posts, etc.  Here, with fresh versions of Nginx, they do not default to such requests as POST, i.e.  no idempotent queries.  And this, in principle, is good, everyone has been waiting for this pen for a long time and, finally, it has appeared.  There you can customize other behavior if you want to retract posts. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/7a8/ebb/66d7a8ebb05e279c0c43ab1656d18b34.png"><br><br><p>  About the backend - we are also trying to monitor it at the same time.  We want to understand whether the process is alive, whether the socket TCP listen is open, which we expect the service to service, whether it responds to some special handle that checks its status, how much the service consumes, how much CPU it uses, how much it i have allocated memory, how much it sits in the swap, the number of descriptor files that it has opened, the number of I / O operations on the disk, in pieces, in traffic, etc., in order to understand whether it consumes more or as usual.  It is very important to understand, and it is important to understand this in time in order to compare with previous periods. </p><br><p>  Specific runtime metrics for Java are the heap state, the use of memory pools, garbage collection, how many of them there were in pieces, how many were there in seconds, per second, etc. </p><br><p>  For Python, there are their own, for GO'shki - their own, for everything related to runtime, there are separate metrics. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/633/a0b/011/633a0b011c97193c0f9203899733a3f6.png"><br><br><p>  You need to understand what the backend was doing, how many requests it took.  This can be shot in the log, it can be shot in statsd, the timings for each request, you need to understand how much time was spent on a particular request, how many errors were there.  Some of these metrics, in principle, see the frontend, because it acts as a client for the backend, and he sees if there was a mistake or a normal response.  He sees how much he was waiting for an answer.  We must surely measure and log how much the backend was waiting for all the services that stand outside of it, i.e.  this is the base, memcached, nosql, if it works with the queue, how many took to put the task in the queue.  And the time taken by some tangible pieces of the CPU, for example, rendering a template.  Those.  we write to the log: ‚ÄúI render such a template, it took me 3 ms,‚Äù that's all.  Those.  we see and can compare these metrics. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e12/21c/67b/e1221c67b7439a96bd02b5ee196909ee.png"><br><br><p>  Here is an example of how we measure CPU usage ruby ‚Äã‚Äãin one of the projects.  This is a summary schedule for all hosts; there are nine backends here.  We immediately see that we have some abnormal resource consumption here or not. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/387/803/e4e/387803e4ee2ce8609e7136b3e949edc1.png"><br><br><p>  Or, say, the request processing stage.  Here a third of the time is taken by standardization, we measured it.  And the rest is about a third, this is waiting for the database and waiting for the cache.  Immediately in sight, if we have a surge, let's say.  Here there is a jolt in the center, when we have dulled the cache, in another surge we have a dull base, for example, it is yellow, i.e.  it is immediately clear who is to blame, and it‚Äôs not necessary to search for anything for a long time. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/781/d8b/be7/781d8bbe74a5aaf57c3e9a58faa9f7b1.png"><br><br></p><p>  Total, we closed the case with the breakage of iron, we closed the case so that the service died, because the balancer ceases to balance on this host, and there are no problems.  We monitored the case when the base and other resources are tupit, because we measured, and also measured the number of errors.  We measured the consumption of resources and understand that, for example, if we slow down rendering, we look at how much more CPU process there is, ruby ‚Äã‚Äãor something else.  We are also monitoring it.  In principle, we have everything under control.  Because of the greater number of requests, we closed with restrictions, limits, so here, in principle, everything is also not bad. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/dd7/06c/76f/dd706c76fbc55731e85873b6d150dadb.png"><br><br><p>  According to the database.  What is her task?  It stores your data, that is, as a rule, the central data storage point is the base.  Perhaps, nosql, but we do not take it into account yet.  It responds to realtime requests from the user, i.e.  from the backend to the pages that the user is waiting for, and she does some analytical processing of requests, i.e.  somewhere in your nighttime the cron is triggered, it calculates how much you are doing there, etc. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/2f3/321/33e2f3321b42ce76e2d5610a1c62fbdb.png"><br><br><p>  What can happen to the base?  As always - the piece of iron broke, without this, nowhere, the pieces of iron break.  By the way, the statistics says that it‚Äôs impossible to expect that your piece of iron will work forever, despite all the reserves and so on, you must always allow this risk, and it will be correct and smart. </p><br><p>  Loss of data due to the pieces of iron, when we had data in a single copy, and the piece of iron died, we lost everything ... Or the piece of hardware is alive and some delete has come, or the data has somehow somehow been cached - this is a completely separate risk. </p><br><p>  The service died, well, postgress was nailed by oom killer or mysql - we also need to somehow understand that this is happening. </p><br><p>  The brakes are due to lack of resources, when you send requests to the database so much that, in principle, it cannot cope with the CPU or the disk, etc. </p><br><p>  Due to the fact that you sent 10 times more requests than the calculated ones, say, sent some traffic there, etc. </p><br><p>  Brakes due to curve queries - if you do not use indexes, or your data is somehow wrong, you also get brakes. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/0e1/cb1/3ac/0e1cb13ac0e9e838cc02e1bb024a8ae5.png"><br><br><p>  Let's try to do something with it. </p><br><p>  Replication  Replication is always needed.  There are almost no cases when you can do without replication.  We just take it and set it up to another server in master-slave mode and nothing more needs to be invented yet. </p><br><p>  The main workload of most projects is reading.  In principle, if you ensure read only the constant, stable operation of your site, then your superiors or you will be immensely pleased.  It is already 100,500 times better than nothing than falling. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/7e9/b87/8d2/7e9b878d2d900d56d4e52703c2780278.png"><br><br><p>  You can immediately unload all the SELECTs that are not sensitive to replication lag.  What it is?  The data on the replica does not go right away, but with a certain delay, depending on various reasons, ranging from the bandwidth of the channels to the replica there.  Requests that are requested by anonymous users, state, say, a directory ‚Äî they are not sensitive to replication lag.  If the data is delayed and the user gets irrelevant, nothing bad will happen.  And if a user fills in his profile and presses submit on a form, and you show him data that has not changed yet, let's say you took it from the replica, then this is already a problem.  In this case, SELECT must be done from the wizard.  But most of the load still goes to the replica.  And applications need to be taught that there is a replica, that it is lagging behind, at the same time, in addition to fault tolerance, you solve the problem of scaling the load on the read operation. </p><br><p>  To access the replica you can put a lot of replicas, and it is easy.  You can either unbalance incoming requests to these replicas, or teach the application to know that it has 10 replicas.  It is quite difficult and, as I understand it, standard tools and all kinds of frameworks do not know how to do this, you need to program a little.  But you get the opportunity to balance, do retracts, i.e.  if you make a user request and, say, replicas are behind your balancer, you get an error or timeout, you cannot make an attempt, because there is a chance that you will get to the same dead server.  Accordingly, you can teach the backend to know about 10 replicas, and if one of the replicas is lying, try another and, if it is alive, give the user his answer without error, and that is cool.  This is cleaning out such small-small problems, i.e.  also work on uptime. </p><br><p>  You need to understand what to do if the master is dead, and you have a reply.  First, you need to decide that you will switch. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4f7/e23/35e/4f7e2335ed2e4a15e7dea7f16dfcb23b.png"><br><br><p>  Suppose your server is dead, he has a panic there, he dies once every three years.  Then it‚Äôs just better for you to zarebut it, wait until it rises, and don‚Äôt plan all this garbage with switching, because it‚Äôs not free, it takes time, and it‚Äôs quite risky. </p><br><p>  If you do decide to switch, we reconfigure our backends to the replica, i.e.  we send the whole record to one of the replicas.  If this is a normal database (postgress), then in replica mode it will return errors for all modifying requests, inserts, updates, etc.  And it does not matter.  Then you, if necessary, wait until everything from the master to the replica reaches the end.  If he is alive.  If he is still lifeless, then there is nothing to wait for. </p><br><p>  You must finish the master if he is alive.  Those.  it is better to finish it so that such an incident does not happen, that someone writes to the disabled, old master and thus not to lose data.  Thus upgrade slave to master.  This is done differently in different solutions of database management systems, but there is a streamlined procedure. </p><br><p>  If there are still replicas, they need to be switched to the new master and, if you want to attach the old server somewhere, then turn it on as a replica. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/7ea/71c/49a/7ea71c49a38617ccb3dc9ab79ea0176f.png"><br><br><p>  In total, we have roughly considered what is happening and, in my opinion, what we have said is quite a swift operation, and I don‚Äôt want to do it on the machine, well, personally to me.  I would not dare.  It is better, nevertheless, to minimize the chance that you will have to switch and buy or rent better hardware or do something else.  Those.  we stupidly reduce the likelihood that the master is dead. </p><br><p>  Be sure to write instructions on how to switch the master in steps.  This will have to be done by a half-asleep person at four o'clock in the morning, who is in a stressful situation, he has a business related to the site, and he should not be particularly bothered to think what he is doing.  He must, of course, think, we still do not quite hire boots, but turn on the brain to a minimum.  Because it is a stressful situation. </p><br><p>  Be sure to test this instruction.  Untested instructions are not instructions.  So, we test the instruction, arrange the exercises, i.e.  we wrote instructions, we cut down the master, and we train, we do everything strictly according to the instructions and do not invent anything along the way.  If something goes wrong with you, we append the instructions immediately. </p><br><p>  Along the way, we measure time.  We need to measure the time to ensure that we cope with a similar problem in 30 or 15 minutes, or the total downtime is one and a half minutes, after the person came in, opened the laptop, went off-line and drove. </p><br><p>  The next time, if you changed the instructions, you need to hold repeated exercises.  If you are not satisfied with the time that ended up as a result of downtime, you can try to do something with it, optimize some steps, provide parallel copying of files somewhere or something else.  Just when you look at the steps, measure how much each step takes, and stir up some kind of optimization. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/6db/2ff/a40/6db2ffa40d30235240f2894490342df0.png"><br><br><p>  Separately, it is worth noting such a captain thing that replication is not a backup.  If you receive a request that kills the data, it will get to the replica too, and you will lose everything.  If you need to save data at all, then you need to make a backup. </p><br><p>  Backups, again, for different databases are done differently.  There are full backups, which are usually not made every second, there is the possibility of a backup, which you can catch up with daily dump or daily copy of data files using write ahead log or bin log or something else ... These bin logs need to be copied to the side neatly . </p><br><p> ,  ,     ,   ,             ‚Äî   ,   - ,       ,   . </p><br><p>      ,  ,      ,      ,          ‚Äî   .    ,  .  Those.  ,    ,    ,   ,    .    ,      ,  -,     ,  ? </p><br><img src="https://habrastorage.org/getpro/habr/post_images/286/596/688/2865966886b0ad3106546b7212f88b47.png"><br><br><p>   ‚Äî   ,  ,  ,  ,  , , /     ,   ,  listen socket,      . </p><br><p>     ,           5  .       . -   , - ,   postrgess  ,    CPU,      .   -  ,   ,   ,      ,           500 , ,  ,  ,    ?       -  ,    ,   ,        .  ,   ,     ,    ,       ,       ,       CPU,        . </p><br><p>    ‚Äî  .  ,    ‚Äî ,      ‚Äî  ,      .    ,            -,      1  ‚Äî   .  ,    , ..      .  ,    -    ,     . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/0c0/99b/28f/0c099b28fa7a600e229b1822f0a6f10a.png"><br><br><p>    postgress   .    ‚Äî  -  .    ,  ,    ,  ,    .. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f4c/d7d/ecff4cd7d9d880398934cf9beade78e8.png"><br><br><p>     .  Those.   ,    ,   -,  - ,     800 ,      50  . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/688/7de/95f/6887de95f59c07c36cfaf716426f95ad.png"><br><br><p>   . </p><br><p>   -   delete' ‚Äî    ,    ,          .   ,       . </p><br><p>  , ,   ‚Äî   ,     ,    read only . </p><br><p>  -   ‚Äî  .  -       .        ,    .  -     . </p><br><p>   ,       ,      3 ,   ,   5 ,     8    . ,    . , , ¬´       15 ¬ª ‚Äî     ,    ,    . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/14e/ff9/9e8/14eff99e8f3aa355b471a634db849b9f.png"><br><br><p>  memcached,      ,  ,     .   memcached  ,     . </p><br><p>     ,        .  Those.     ,        , ,        10  ,   . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d16/df5/6d7/d16df56d77a56447873c8b1cd4806d84.png"><br><br><p> ,  ,  ,   ,       memcached,  -  -  -  .   . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c4b/1ee/755/c4b1ee755a33d4971be03d2eb70fff33.png"><br><br><p> emcached   ,     ,     .   -  ,   .   ,  -,    , , ,          ,     .    ,   ,   memcached ,  ,   ,  . </p><br><p>    ,     ,      ,    , , ,     ,  , ,  ,     ,      ,     ,     ,     .    ,         .  ,  ,         ,    expire,  ,    ,  -  . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/36e/534/024/36e534024b01ab041f69dfc8b6eeedbb.png"><br><br><p>  ,     ,   .   ,     ,  ,   memcached  ,   ? ,  ,   ,    ,  ,    ,     n  ,    .         ,    , , memcached?  , ,   ,       ,       .     ,      .  Those. ,  ,   ‚Äî , ,   ? </p><br><p>    ,   .  Those.  - ,  ,    ,    , , ,    ?  ,  ,   . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/a3c/c0a/6caa3cc0aa6485a388bd2836b696d06a.png"><br><br><p>     memcached  , ..  ,     - ,     ,  -   .  ,    ,  98%    ,              . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/1ee/d88/c011eed884363b01af07f59f49e25f6c.png"><br><br><p>       .  ,  ,  memcached,      latency  ‚Ä¶ ,    -,     ,     .   ,   -       ‚Äî  ,      .        .  .   memcached     ,   ,   , -  . </p><br><p>   ‚Äî    . ,    . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c65/5ca/d44/c655cad44a296f99be9bd66dcd0b8683.png"><br><br><p>    .    ?      -   ,   ,  -  ,    .  ,     Message Queue.  publisher ‚Äî  ,     ,  consumer ‚Äî  ,      -   .. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c8d/951/66d/c8d95166d3e8409a205bb085e5f8c7bf.png"><br><br><p>   . </p><br><p>  .           ¬´¬ª, ,    -,    . </p><br><p>    ,   ,       2 .   ‚Äî  ,    . </p><br><p>    ‚Äî  ,    . </p><br><p>   , publisher   ,     ,  ,   - ,          , ,  ,  ,     , . </p><br><p>   -  . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/387/189/661/38718966175113d85d5a417a4439ab6b.png"><br><br><p>      ,       , ..     ‚Äî   ,      ‚Äî     . , , ,  , ,        .         .    ,         .      -,     , ,  ,   ,      ,   ,       ,    - . </p><br><p>      ,      ,  ,  ,      ,      3 ,  ,      ,        -. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/0c0/3d6/654/0c03d665456ac73e0ee95b39fceff3a2.png"><br><br><p>  ,        , ,  .     ,        10 .   .    ?           .  Those.     ,         , , .  , ,    ,   ,   ,    , ,    . ,    ,      ,         -   ,   ,     , .          ,    ,     . </p><br><p>   ,     ? </p><br><img src="https://habrastorage.org/getpro/habr/post_images/2d9/f18/33e/2d9f1833e86320e5da8d8ee6e84cb239.png"><br><br><p>      ,   , ,     ‚Äî      ,      ?  ,        .. ,     ,     ,      ,     ,    - ,     -. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bfc/44a/767/bfc44a76705726992b46af2f1319a5b1.png"><br><br><p>    ‚Äî      , ..     ,   ,     . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/225/e2b/fee/225e2bfeeda55c458c6ca93901863fde.png"><br><br><p>   ‚Äî   , ..      .         , ,    ,   .. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/1cc/aa9/136/1ccaa9136cc8c2fa5c0b85500f0610cd.png"><br><br><p>  To summarize      ,         .   ,  ,    -  , -    ,   ,       ,       . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/daa/abd/62b/daaabd62b83452bd268adbdd9802925a.png"><br><br><p>      20 . .  per month.          ,  ,  , -  ‚Äî    , ..     uptime  .  ,          ,  ,  ‚Äî     , , . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/68a/d0f/4a0/68ad0f4a0151926f42e4cc97a3a1a03d.png"><br><br><p>  .  ‚Äî  .      ,   , ,  ,  ,   .    Load Balancing, .    ,    ‚Äî   .        ,        5   ,  - SLA    . </p><br><p>      ,    .          ,    ,    CPU,      ,   ‚Äî  ,    .    ,   ‚Äî    ,   ,    ,      , ,     -,  ,    , ,  ,    .   ,      ,  ,    ,    . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/155/86c/663/15586c663d3ae5b9bc433d63b92e3237.png"><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Still, if you want to protect against the departure of the data center, then everything is exactly the same - you simply put backup glands in another data center, set up replication there, and you also need to deploy a new code there. </font><font style="vertical-align: inherit;">If we are talking about backends, you need to fill in static data there, well, just work with servers in several DCs. </font><font style="vertical-align: inherit;">You can make fault tolerant traffic either by switching the manual DNS, in case your data center is dead, or by using routing, BGP and your address blocks.</font></font></p><br><img src="https://habrastorage.org/getpro/habr/post_images/60e/1e3/d07/60e1e3d0717a9f8601da0a9fed5a5ded.png"><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We summarize everything that I told you today. </font></font></p><br><p> The most important thing is to understand the risks, i.e.  you just write out the risks, you can do nothing with them right now, but if you have a list, then this is already very good.  If you see that the risk is simple and it is very easy to close it right now, in 5 minutes, do it, your list is reduced, and the possible problems you need to remember, it becomes less.  If the scenario is complicated, try to reduce the likelihood of this risk triggering, if you cannot do this, then you can close some part of this problem, if you‚Äôre right at all, leave it to manual intervention, if you want to work out manual intervention to automatism, then write instructions, conduct exercises. </p><br><p>  Thus, if you have plans, then you are already tired of failover.  Everything else is just optimization and reduced downtime. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e55/bec/125/e55bec125b6eba8e498feee7e5b2a89d.png"><br><br><h3>  Contacts </h3><br><p>  Nikolay Sivko, <a href="">nsv@okmeter.io</a> .  <a href="https://habrahabr.ru/company/okmeter/">Company blog</a> okmeter.io on Habr√©. </p><br><h3>  Additional Information </h3><br><blockquote>  <font color="gray">Not enough information?</font>  <font color="gray">Or it is not clear at what point to connect these or other tips of Nikolai?</font>  <font color="gray">All this we will analyze in detail at the <a href="http://step2step.highload.ru/">master class of</a> Roman Ivliev on September 6.</font> <br></blockquote><p></p></div><p>Source: <a href="https://habr.com/ru/post/308756/">https://habr.com/ru/post/308756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308746/index.html">SWEET32 attack: Researchers have discovered a new way to crack the 3DES and Blowfish ciphers</a></li>
<li><a href="../308748/index.html">Published program Droidcon Moscow 2016</a></li>
<li><a href="../308750/index.html">Visual monitoring of the server infrastructure based on Nagios + Grafana</a></li>
<li><a href="../308752/index.html">Computer Science for Postgres Indexes</a></li>
<li><a href="../308754/index.html">Java benchmarks: random patterns and regular results</a></li>
<li><a href="../308762/index.html">Application Performance Management. HPE Recipe</a></li>
<li><a href="../308764/index.html">DDoS: IT Maniacs on the Point of Attack</a></li>
<li><a href="../308766/index.html">Horizon - realtime javascript backend</a></li>
<li><a href="../308768/index.html">Oracle Specialization: MUK Learning Center presents authorized training at Oracle University</a></li>
<li><a href="../308772/index.html">DisType: a simple application for communication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>