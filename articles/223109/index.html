<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Moving from MongoDB Full Text to ElasticSearch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my last post , with the Google Chrome extension for Likeastore , I mentioned the fact that we started using ElasticSeach as a search index. It was ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Moving from MongoDB Full Text to ElasticSearch</h1><div class="post__text post__text-html js-mediator-article">  In my last <a href="http://habrahabr.ru/company/likeastore/blog/222515/">post</a> , with the Google Chrome extension for <a href="https://likeastore.com/">Likeastore</a> , I mentioned the fact that we started using <a href="http://elasticsearch.com/">ElasticSeach</a> as a search index.  It was ElasticSeach that gave a fairly good performance and quality of search, after which it was decided to release an extension to chrome. <br><br>  In this post, I‚Äôll tell you that using MongoDB + ElasticSeach, there is a very effective NoSQL solution, and how to switch to ElasticSearch if you already have MongoDB. <br><a name="habracut"></a><br><h4>  A bit of history </h4><br>  Search functionality, the essence of our application.  The ability to find something quickly among thousands of our likes was what we started this project for. <br><br>  We had no deep knowledge of the theory of full-text search, and as the first approach we decided to try MongoDB Full Text Search.  Despite the fact that in version 2.4 full text is an experimental feature, it worked pretty well.  Therefore, for some time we left it, switching to more urgent tasks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Time passed and the database grew.  The collection on which we carry out the indexation began to type a certain size.  Starting from the size of 2 million documents, I began to notice a general decline in application performance.  This manifested itself in the form of a long opening of the first page, and an extremely slow search. <br><br>  All this time I have been looking at specialized search storages like <a href="http://elasticsearch.com/">ElasticSearch</a> , <a href="http://lucene.apache.org/solr/">Solr</a> or <a href="http://sphinxsearch.com/">Shpinx</a> .  But as it often happens in a startup, until ‚Äúthunder breaks out, the peasant will not overwrite‚Äù. <br><br>  Thunder "struck" 2 weeks ago, after the publication on one of the resources, we experienced a sharp increase in traffic and greater user activity.  New Relic sent scary letters stating that the application was not responding, and his own attempts to open the application showed that the patient was more likely alive than dead, but everything worked extremely slowly. <br><br>  A quick analysis showed that most HTTP requests fall off from 504, after the calls to MongoDB.  We are hosted on MongoHQ, but when we tried to open the monitoring console, nothing came of it.  The base was loaded to the very limit.  After the console was still able to open, I saw that Locked% went to the sky-high 110-140% and kept there, not going to go down. <br><br>  The service that collects user likes, makes quite a few inserts, and each such insert entails a re-calculation of the full-text index, this is an expensive operation, and reaching certain restrictions (including server resources), we simply rested against it limit. <br><br>  Data collection had to be disabled, the full-text index was deleted.  After the restart, the Locked index service did not exceed 0.7%, but if the user tried to search for something, we had to respond with an inconvenient ‚Äúsorry, search is on maintenance‚Äù ... <br><br><h4>  We try ElasticSeach locally </h4><br>  I decided to see what Elastic is, having tried it on my car.  For that kind of experiments, there has always been (there is, and I hope will be) <a href="http://www.vagrantup.com/">vagrant</a> . <br><br>  ElasticSeach is written in Java, and requires proper runtime. <br><br><pre><code class="bash hljs">&gt; sudo apt-get update &gt; sudo apt-get install openjdk-6-jre &gt; sudo add-apt-repository ppa:webupd8team/java &gt; sudo apt-get install oracle-java7-installer</code> </pre> <br>  Then you can check whether everything is fine by running <br><br><pre> <code class="bash hljs">&gt; java --version</code> </pre><br>  Elastic itself is extremely easy to install.  I recommend installing from a Debian package, because in this form it is easier to configure it to run as a service and not as a process. <br><br><pre> <code class="bash hljs">&gt; wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.1.deb &gt; dpkg -i elasticsearch-1.1.1.deb</code> </pre><br>  After that, it's ready to launch, <br><br><pre> <code class="bash hljs">&gt; sudo update-rc.d elasticsearch defaults 95 10 &gt; sudo /etc/init.d/elasticsearch start</code> </pre><br>  Having opened the browser and having followed the link, we receive approximately such answer. <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"ok"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"status"</span></span> : 200, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Xavin"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span> : { <span class="hljs-string"><span class="hljs-string">"number"</span></span> : <span class="hljs-string"><span class="hljs-string">"1.1.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"build_hash"</span></span> : <span class="hljs-string"><span class="hljs-string">"36897d07dadcb70886db7f149e645ed3d44eb5f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"build_timestamp"</span></span> : <span class="hljs-string"><span class="hljs-string">"2014-05-05T12:06:54Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"build_snapshot"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"lucene_version"</span></span> : <span class="hljs-string"><span class="hljs-string">"4.5.1"</span></span> }, <span class="hljs-string"><span class="hljs-string">"tagline"</span></span> : <span class="hljs-string"><span class="hljs-string">"You Know, for Search"</span></span> }</code> </pre><br>  Full deployment takes about 10 minutes. <br><br><h4>  Now you need to save and search. </h4><br>  ElasticSearch is an interface built on top of <a href="http://lucene.apache.org/core/">Lucene</a> technology.  It is without exaggeration the most complex technology, honed over the years, in which thousands of labor hours of high-end engineers were invested.  Elastic makes this technology available to mere mortals, and does it very well. <br><br>  I find some parallels, between Elastic and CounchDB - also HTTP API, also schemaless, same document orientation. <br><br>  After a quick installation, I spent a lot of time reading the <a href="http://www.elasticsearch.org/guide/">manual</a> , looking at the relevant <a href="http://www.elasticsearch.org/videos/">vidos</a> , until I realized how to save the document in the index and how to run the simplest search query. <br><br>  At this point, I used a naked curl, just as shown in the documentation. <br><br>  But for a long time to train "on cats" is not interesting.  I dumped the MongoDB production base, and now I had to transfer my entire collection from MongoDB to the ElasticSearch index. <br><br>  For this migration, I made a small <a href="https://github.com/likeastore/elaster">tool</a> - <a href="https://github.com/likeastore/elaster">elaster</a> .  Elaster, this is a node.js application that streams a given MongoDB collection into ElasticSearch, by creating the necessary index preliminarily and initializing it with a mapping. <br><br>  This process is not very fast (there are a couple of ideas, to improve elaster), but after about 40 minutes, all the entries from MongoDB were in ElasticSearch, you can try searching. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc2/8e9/88d/dc28e988de7e1f2d3bc9ca3040eb3be3.png" alt="image"><br><br><h4>  Creating a search query </h4><br>  <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html">Query DSL</a> , a query language for Elastic.  Syntax is just JSON, but to make an effective request is experience, practice and knowledge.  I confess, honestly, I haven't reached them yet, so my first attempt looked like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fullTextItemSearch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, query, paging, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!query) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">nextPage</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> page = paging.page || <span class="hljs-number"><span class="hljs-number">1</span></span>; elastic.search({ <span class="hljs-attr"><span class="hljs-attr">index</span></span>: <span class="hljs-string"><span class="hljs-string">'items'</span></span>, <span class="hljs-attr"><span class="hljs-attr">from</span></span>: (page - <span class="hljs-number"><span class="hljs-number">1</span></span>) * paging.pageSize, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: paging.pageSize, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">filtered</span></span>: { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-string"><span class="hljs-string">'query_string'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: query }, }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-attr"><span class="hljs-attr">term</span></span>: { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user.email } } } } } }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, resp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback(err); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = resp.hits.hits.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hit._source; }); callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, {<span class="hljs-attr"><span class="hljs-attr">data</span></span>: items, <span class="hljs-attr"><span class="hljs-attr">nextPage</span></span>: items.length === paging.pageSize}); }); }</code> </pre><br>  This is a filtered query, with paging, for issuing results for a single user.  When I tried to run it, I was amazed at how cool Elastic was.  The query execution time is 30-40ms, and even without some tweaks, I was pleased with the results of the issue! <br><br>  In addition, ElightSeach includes the Hightligh API to highlight the results.  Expanding the request to this type <br><br><pre> <code class="javascript hljs"> elastic.search({ <span class="hljs-attr"><span class="hljs-attr">index</span></span>: <span class="hljs-string"><span class="hljs-string">'items'</span></span>, <span class="hljs-attr"><span class="hljs-attr">from</span></span>: (page - <span class="hljs-number"><span class="hljs-number">1</span></span>) * paging.pageSize, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: paging.pageSize, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">filtered</span></span>: { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-string"><span class="hljs-string">'query_string'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">query</span></span>: query }, }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-attr"><span class="hljs-attr">term</span></span>: { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user.email } } }, }, <span class="hljs-attr"><span class="hljs-attr">highlight</span></span>: { <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">description</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: { } } } }</code> </pre><br>  The response to it (the hit object) will contain a nested highlight object, with an HTML ready for use on the front end, which makes it possible to do something like this, <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3e/3ba/258/b3e3ba2588c5cb66c13eb0635abd8e01.png" alt="image"><br><br><h4>  Modification of the application code </h4><br>  After the basic search has earned, it is necessary to make so that all new data that comes to MongoDB (as the main repository) will ‚Äúflow‚Äù into ElasticSearch. <br><br>  For this, there are special plug-ins, so-called.  rivers.  There are a lot of them, for different databases.  For MongoDB, the most widely used is <a href="https://github.com/richardwilly98/elasticsearch-river-mongodb">here</a> . <br><br>  River for MongoDB works on the principle of monitoring oplog from a local database, and transforming oplog events into ElasticSeach commands.  In theory, everything is simple.  In practice, I did not manage to get this plugin with MongoHQ (most likely the problem of the crippling nature of my hands, because the Internet is full of descriptions of successful uses). <br><br>  But in my case, it turned out to be much easier to go the other way.  Since I have only one collection in which there is only insert and find, it was easier for me to modify the application code, so that immediately after insert  ªand in MongoDB, I make a bulk command in ElasticSeach. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.waterfall([ readUser, executeConnector, findNew, saveToMongo, saveToEleastic, saveState ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ });</code> </pre><br>  Function saveToElastic <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> commands = []; items.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ commands.push({<span class="hljs-string"><span class="hljs-string">'index'</span></span>: {<span class="hljs-string"><span class="hljs-string">'_index'</span></span>: <span class="hljs-string"><span class="hljs-string">'items'</span></span>, <span class="hljs-string"><span class="hljs-string">'_type'</span></span>: <span class="hljs-string"><span class="hljs-string">'item'</span></span>, <span class="hljs-string"><span class="hljs-string">'_id'</span></span>: item._id.toString()}}); commands.push(item); }); elastic.bulk({<span class="hljs-attr"><span class="hljs-attr">body</span></span>: commands}, callback);</code> </pre><br>  I do not exclude that in more complex scenarios the use of the river will be more justified. <br><br><h4>  Unfolding in production </h4><br>  After the local experiment was completed, it was necessary to deploy all this in production. <br><br>  To do this, I created a new droplet on <a href="https://www.digitalocean.com/%3Frefcode%3Dde56d081b272">Digital Ocean</a> (2 CPU, 2 GB, 40 GB SDD) and in fact spent with it all the manipulations described above - install ElasticSeach, install node.js and git, install elaster and start data migration. <br><br>  As soon as the new instance was raised and initialized with data, I restarted the data collection services and the Likeastore API, already with the code modified under Elastic.  Everything worked very smoothly and there were no surprises in the production. <br><br><h4>  results </h4><br>  To say that I am satisfied with the transition to ElasticSearch is to say nothing.  This is really one of the few technologies that works out of the box. <br><br>  Elastic opened the possibility of creating an extension to the browser for quick search, as well as the possibility of creating an advanced search (by date, content type, etc.) <br><br>  However, I am still a complete noob, in this technology.  The feedback that we received since the transition to Elastic and the release of the expansion clearly indicates that improvements are needed.  If someone is ready to share their experience, I will be very happy. <br><br>  MongoDB is finally breathing freely, Locked% stays at 0.1% and does not seek upwards, which makes the application truly responsive. <br><br>  If you are still using MongoDB Full Text, I hope this post will inspire you to switch to ElasticSeach. </div><p>Source: <a href="https://habr.com/ru/post/223109/">https://habr.com/ru/post/223109/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223089/index.html">Smart home - cheap and cheerful, part 2</a></li>
<li><a href="../223091/index.html">[case] How to clean up the bottom: 90 days from the mess to the project office</a></li>
<li><a href="../223099/index.html">Free Software Foundation urges Mozilla to abandon DRM module in Firefox browser</a></li>
<li><a href="../223101/index.html">Development of a project management system in medium business organizations</a></li>
<li><a href="../223105/index.html">Hackspaces of China, part 2. Shenzhen, TechSpace, photo tour</a></li>
<li><a href="../223111/index.html">Vraschete - social and economic network</a></li>
<li><a href="../223115/index.html">In defense of javascript: void (0);</a></li>
<li><a href="../223117/index.html">Skylock - wireless bicycle lock on solar batteries</a></li>
<li><a href="../223119/index.html">What to read on the weekend. Digest news of the gaming industry</a></li>
<li><a href="../223121/index.html">Analysis of implicit user preferences. Scientific and Technical Workshop in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>