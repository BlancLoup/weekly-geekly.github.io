<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simulate Mixed Circuits on System Verilog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We lived, not, not so ... One day, early in the morning, when I came to work again, I found out that we only had one power supply in the server room a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simulate Mixed Circuits on System Verilog</h1><div class="post__text post__text-html js-mediator-article"><p>  We lived, not, not so ... One day, early in the morning, when I came to work again, I found out that we only had one power supply in the server room and it could turn off.  The whole day there was nothing to do, and I decided to write an article on Habr.  The article is aimed at beginners and idly interested. </p><br><p>  CMOS technology has reached such a level that modern chips are huge and very complex structures and systems assembled from systems.  At the same time, the cost of launching into production increases exponentially with decreasing technological standards.  Therefore, when developing, it is required to model and verify everything to the maximum extent possible.  The ideal case, which is even sometimes implemented in practice, when the chip is earned from the first run. </p><br><p>  Since we live in the analog world, even a digital chip should be able to communicate with this world.  Digital chips contain dozens of large analog blocks on a chip, such as ADC, DAC, PLL, secondary power supply, etc.  The exception to this rule is probably only large processors, such as Core i, etc., where all of this equipment is in the chipset. </p><a name="habracut"></a><br><p>  Traditionally, analog blocks are used to simulate spice simulators, such as pi-spice, mmsim, hspice, etc.  In such simulators, the scheme is described by a system of differential equations of enormous dimension (or by the matrix representing it).  Spice simulators at each step of the calculations find the solution of this system of equations by numerical methods.  Of course, methods are used to accelerate these calculations, such as: partitioning the matrix into submatrices, paralleling into a number of threads and computational cores, variable computing steps, etc. </p><br><p>  Unfortunately, numerical methods are fundamentally iterative and poorly parallelized, so this type of simulation, all the same, remains slow enough to simulate the system as a whole.  Nevertheless, it is widely used in the development of the analog blocks and analog circuits themselves.  We, however, lead the story about digital (as a whole) microcircuits containing analog blocks and analog-digital systems, where we would like to describe our blocks as formulas and equations, and solve these Navier-Stokes equations (joke) analytically.  The use of this technique does not cancel a much more accurate calculation on the spice simulator, but only complements it, allowing you to speed up development and modeling. </p><br><h2>  Analog Signal Presentation <br></h2><br><p>  A floating point type is well suited to represent analog signals.  In System Verilog, these are the types shortreal (equivalent to float in C) and real.  It should be noted that these are types of data with memory.  The value in them is updated only at the moment of assignment, i.e.  This type is similar to reg, but in which the memorized value is not represented by 0 or 1, but by voltage or current, represented in turn as a floating-point number. <br>  Now, we really need a type similar to wire, which is updated continuously, and not just at the time of recording.  I must say that there is no such type in System Verilog.  It is rumored that when discussing the standard, there was some movement in order to insert this functionality into it, but it was not realized in anything concrete.  However, if you use the ncsim simulator, then it contains the var modifier, which makes the real type and other types an analogue of wire.  Example: </p><br><pre><code class="hljs go"><span class="hljs-built_in"><span class="hljs-built_in">real</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> b; assign a = in1+in2; <span class="hljs-comment"><span class="hljs-comment">//   assign b = in1+in2; //   , b ‚Äì    in1+in2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Lyrical digression for net programmers</b> <div class="spoiler_text"><p>  The verilog program is a parallel program.  All lines of code are, in principle, independent and are executed both sequentially and in parallel, depending on certain conditions.  In this case, assign will work when you run this program and will work to its very end, calculate the amount continuously. </p></div></div><br><p>  If your simulator does not support var, you can do this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @( * ) //     <span class="hljs-keyword"><span class="hljs-keyword">always</span></span>    in1  in2 b &lt;= in1+in2;</code> </pre> <br><p>  The recording is less convenient, nevertheless quite working. </p><br><h2>  Data Type Conversion <br></h2><br><p>  The following functions are built into verilog for data conversion. </p><br><pre> <code class="hljs bash"><span class="hljs-variable"><span class="hljs-variable">$itor</span></span>() // <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> to real <span class="hljs-variable"><span class="hljs-variable">$rtoi</span></span>() // real to <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-variable"><span class="hljs-variable">$bitstoreal</span></span>() //reg [ : ] to real <span class="hljs-variable"><span class="hljs-variable">$realtobits</span></span>() // real to reg [ : ]</code> </pre> <br><p>  If the code that you want to convert to real - sign and is presented in an additional code, you need to be careful when using these functions, you may need to convert or expand the sign.  If for some reason you do not want to use these functions, you can use the following technique. </p><br><pre> <code class="hljs axapta">reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] code; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">real</span></span> voltage; always @( * ) begin a = {{<span class="hljs-number"><span class="hljs-number">24</span></span>{code[<span class="hljs-number"><span class="hljs-number">7</span></span>]}}, code[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]}; <span class="hljs-comment"><span class="hljs-comment">//    int voltage = a; end</span></span></code> </pre> <br><h2>  Verilog's Simplified Analog Block Models <br></h2><br><h3>  Amplifier with additive white noise </h3><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">amp</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">real</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">output</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">real</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class">);</span></span> parameter k = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  parameter seed = <span class="hljs-number"><span class="hljs-number">60</span></span>; parameter noise_power = -<span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   dB real noise; always @(*) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> noise = $sqrt(<span class="hljs-number"><span class="hljs-number">10</span></span>**(noise_power/<span class="hljs-number"><span class="hljs-number">10</span></span>))* $itor($dist_normal(seed, <span class="hljs-number"><span class="hljs-number">0</span></span> , <span class="hljs-number"><span class="hljs-number">100_000</span></span>))/<span class="hljs-number"><span class="hljs-number">100_000</span></span>; out = <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> * k + noise; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br><h3>  DAC with low pass filter </h3><br><pre> <code class="hljs vhdl">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span>ns / <span class="hljs-number"><span class="hljs-number">1</span></span>ps module DAC(input <span class="hljs-built_in"><span class="hljs-built_in">signed</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] DAC_code, output real <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> fs = <span class="hljs-number"><span class="hljs-number">10e-9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> ffilt = fs/<span class="hljs-number"><span class="hljs-number">64</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> CUTOFF = <span class="hljs-number"><span class="hljs-number">100e6</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> a = ffilt/(ffilt+(<span class="hljs-number"><span class="hljs-number">1</span></span>/(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">3.141592</span></span>* CUTOFF))); real DAC_out; // always @( * ) DAC_out &lt;= $bitstoint(DAC_code[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]); // <span class="hljs-number"><span class="hljs-number">1</span></span>  always #(<span class="hljs-number"><span class="hljs-number">0.5</span></span>*ffilt) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &lt;= a* DAC_out + (<span class="hljs-number"><span class="hljs-number">1</span></span>-a)*<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; endmodule</code> </pre> <br><h3>  ADC with nonlinearity </h3><br><pre> <code class="hljs lua">module ADC (<span class="hljs-built_in"><span class="hljs-built_in">input</span></span> real <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> clk, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] ADC_code) real adc_tf[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">255</span></span>]; real min_dist; int i,j; int dnl_file; initial begin dnl_file=$fopen(<span class="hljs-string"><span class="hljs-string">"DNL_file"</span></span>,<span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dnl_file==<span class="hljs-number"><span class="hljs-number">0</span></span>) $stop; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">256</span></span>;i=i+<span class="hljs-number"><span class="hljs-number">1</span></span>) $fscanf(dnl_file, <span class="hljs-string"><span class="hljs-string">"%f;"</span></span>, adc_tf[i]);//     <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) begin min_dist = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;<span class="hljs-number"><span class="hljs-number">256</span></span>; j=j+<span class="hljs-number"><span class="hljs-number">1</span></span>) //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>- adc_tf[j]) &lt; min_dist) begin min_dist = delta_abs; ADC_code[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]=j; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br><h3>  Multiphase clock source (PLL) </h3><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">module</span></span> MPLL (input en, input [<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]phase, output clk_out); <span class="hljs-attribute"><span class="hljs-attribute">parameter</span></span> REFERENCE_CLOCK_PERIOD=10e-<span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">parameter</span></span> PHASES_NUMBER=<span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [PHASES_NUMBER-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]PLL_phase=<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-string"><span class="hljs-string">'h00000000_FFFFFFFF; //    always #(REFERENCE_CLOCK_PERIOD/PHASES_NUMBER) if(en===1) PLL_phase[PHASES_NUMBER-1:0] &lt;= {PLL_phase[PHASES_NUMBER-2:0], PLL_phase[PHASES_NUMBER-1]}; //     assign clk_out = PLL_phase[phase]; //  endmodule</span></span></code> </pre> <br><p>  The use of such and similar, but more complex analytical models, speeds up calculations by orders of magnitude compared to spice modeling and allows you to actually simulate and verify the complete system on System Verilog. </p><br><h2>  Still accelerating <br></h2><br><p>  Unfortunately, modern systems are already so complex that this acceleration is not enough, in this case it is necessary to resort to parallelization.  Multi-threaded Verilog simulators, as far as I know, have not yet been invented, so you have to hand to hand. <br>  A new mechanism has been introduced in SystemVerilog for accessing external program modules ‚Äî the Direct Programming Interface (DPI).  Since  This mechanism is simpler, compared to the other two, we will use it. </p><br><p>  At the beginning of the module, where we want to call an external function, we need to insert the import line. <br>  import "DPI-C" function int some_funct (input string file_name, input int in, output real out); <br>  Then you can use it in Verilog in the usual way, for example, like this: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk) res1 &lt;= some_funct (‚Äúfile.name‚Äù, in1, out1);</code> </pre> <br><p>  How to compile and where the libraries are located is described in the documentation for the simulator. <br>  Below is an example of a program running in several threads. </p><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; typedef struct { //work specific double in; //    double out; //  ‚Ä¶ //thread specific char processing; //   pthread_mutex_t mutex; pthread_cond_t cond_start; pthread_cond_t cond_finish; void *next_th_params; pthread_t tid; }th_params; static th_params th_pool[POOL_SIZE];</span></span></span></span></code> </pre> <br><p>  Calculation function: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x_void_ptr)</span></span></span><span class="hljs-function"> </span></span>{ th_params *x_ptr = (th_params *)x_void_ptr; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  { //     pthread_mutex_lock (&amp;x_ptr-&gt;mutex); // x_ptr-&gt;processing = 0; //,    pthread_cond_signal(&amp;x_ptr-&gt;cond_finish); // ,   while(x_ptr-&gt;processing == 0) pthread_cond_wait(&amp;x_ptr-&gt;cond_start, &amp;x_ptr-&gt;mutex); //   x_ptr-&gt;processing = 1; //  -  pthread_mutex_unlock(&amp;x_ptr-&gt;mutex); // //  - ,    SSE2 ‚Ä¶ } }</span></span></code> </pre><br><p>  The function to start the calculated functions </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(th_params *tp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;i&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">pthread_attr_t</span></span> attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); pthread_create(th_pool-&gt;tid, &amp;attr, &amp;worker_thread, tp); } }</code> </pre> <br><p>  The function that distributes the work to the calculated functions (we will call it from Verilog all the time) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>;i+=<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//       pthread_mutex_lock(&amp;th_pool[i].mutex); // while(th_pool[i].processing == 1) pthread_cond_wait(&amp;th_pool[i].cond_finish, &amp;th_pool[i].mutex); //  pthread_mutex_unlock(&amp;th_pool[i].mutex); // } //         Verilog for(i=0;i&lt;12;i+=1) out[i] = th_pool[i].out; for(i=0;i&lt;12;i+=1) { pthread_mutex_lock (&amp;th_pool[i].mutex); // th_pool[i].in = in; //    th_pool[i].processing = 1; //    pthread_cond_signal (&amp;th_pool[i].cond_start); //  ,    pthread_mutex_unlock (&amp;th_pool[i].mutex); // } }</span></span></code> </pre> </div></div><br><p>  Unfortunately, modern systems are already so complex that this acceleration is not enough.  In this case, you have to resort to using OpenCL for calculations on a video card (no more complicated than DPI), calculations on a cluster or in the cloud.  In all these cases, the transport component is a serious limitation, i.e.  data transfer time to and from the calculating device.  The optimal task, in this case, is one where you need to count a lot, while there is, with respect to this calculation, a small amount of data, both source and result.  The same applies to the presented program, but to a lesser extent.  If this condition is not met, then often, it is faster to read on the processor alone. </p><br><p>  It should be noted that none of the presented methods does not work when there is no power in the server, however, it has just been submitted, youtube has started working again.  On this joyful note, I hasten to finish my story, work is waiting. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338922/">https://habr.com/ru/post/338922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338910/index.html">Taming the Snake with Reactive Flows</a></li>
<li><a href="../338912/index.html">From the life of werewolves</a></li>
<li><a href="../338914/index.html">Sugar Javascript</a></li>
<li><a href="../338918/index.html">Indeed, what is a CRM system?</a></li>
<li><a href="../338920/index.html">DevFest North in St. Petersburg on September 30</a></li>
<li><a href="../338924/index.html">Kotlin, puzzlers and 2 Kekses: Are you sure you know how Kotlin behaves?</a></li>
<li><a href="../338926/index.html">Computer vision. Intel Expert Answers</a></li>
<li><a href="../338928/index.html">In Search of Performance, Part 2: Java Profiling for Linux</a></li>
<li><a href="../338930/index.html">V8 under the hood</a></li>
<li><a href="../338932/index.html">React v16.0 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>