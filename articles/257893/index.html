<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Place and conquer! Use host new to optimize C ++ code.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Creating an object for an object, we often do not pay attention to such a ‚Äútrifle‚Äù as dynamic memory allocation. Along with copying and serialization,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Place and conquer! Use host new to optimize C ++ code.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d0d/4e3/6bf/d0d4e36bf0624c7b881fce6125434c2b.jpg"><br><br>  Creating an object for an object, we often do not pay attention to such a ‚Äútrifle‚Äù as dynamic memory allocation.  Along with copying and serialization, memory allocation from the heap through new gradually negates the advantages of C ++ in speed.  The more intensively we use the cherished new, the more difficult it becomes for the application, since the memory ends, is fragmented and in every possible way seeks to leak.  This fate has already befell convenient, but implicitly dangerous for the performance containers STL: vector, string, deque, map.  It is especially insulting to lose speed on the allocation of small objects in large quantities.  But there is a way to handle the memory allocation of such objects on the stack, while hiding implementation details in a special data class.  The new-placer mechanism will help us with this - an unsurpassed way to optimize an application full of frequent and small heap memory allocations. <br><a name="habracut"></a><br>  In the last lesson, we did amazing things: working with C ++ objects as containers, containing values ‚Äã‚Äãof the type computed at runtime and filled in dynamically.  We actively used the Copy-on-Write add-on over std :: shared_ptr, which referred to the actual data type when filling the object.  In this case, it was assumed that we will allocate memory dynamically for any initialization of data, calling new every time we need new data of an arbitrary type. <br><br>  This approach has its advantages.  Data can be shared between multiple objects, deferring copying.  You can, in principle, do not know in advance about the type of data.  However, this method has a number of drawbacks, due to which Copy-on-Write is used, as a rule, for potentially quite large objects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first drawback is found out immediately.  Mass dynamic memory allocation seriously slows down program execution, especially mass implicit memory allocation through new.  Yes, I am aware of both std :: string and std :: vector, which often, without asking the programmer, begin to reallocate the memory, causing one new after another (and we'll still talk about repositioning data in std :: vector).  A good specialist in C ++ development always knows about these funny features of standard containers and understands how to avoid the extra costs of allocating new memory segments.  What a clean si has always been good about is precisely the fact that any work with memory was performed transparently, in C ++ you always need to keep in mind a number of cases of implicit work with memory. <br><br>  The second disadvantage is a consequence of the first.  Frequent allocation of small segments of memory in large quantities will lead to terrible memory fragmentation and the inability to allocate even a rather small memory block in a single piece, for example, to initialize the same std :: vector or std :: string.  As a result, we get bad_alloc for no apparent reason.  The memory is much larger than needed, and it will not be possible to allocate a continuous block of even small size in conditions of highly fragmented memory. <br><br>  Thus, for small objects comparable to int64_t that can be safely placed on the stack, you can and should use a different data processing technique.  Such objects can be transferred by value, you can copy as many times as you like, without delaying until the first change, since one or two registers are trite. <br><br>  However, we should not deviate from the practice of declaring the details of the data in the implementation.  But we have to sacrifice something: we will need to know in advance the exact size of the data in bytes.  It is required in order to keep a buffer in the classroom for storing the object data along with the usual data pointer.  Now more. <br><br><h4>  First grade </h4><br>  Outwardly, almost nothing changes.  All the same class that provides the API objects.  The class contains a reference to the data whose class is declared through the forward declaration and will be moved to the implementation details.  Because of this, the class field cannot be declared an object of this type, however, the data type can be referenced with a simple pointer and get a buffer in advance to store the object data in the object itself.  If an object is created, for example, on a stack, then all data will be stored on the stack as part of an object.  Now consider an example so that everything falls into place: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">//    class data; //       static const size_t max_data_size = N; private: //    data* m_data; //  ,     char m_buffer[max_data_size]; };</span></span></code> </pre> <br>  In this code snippet, we continue the ideology of hiding data in the implementation, all we know about class data is the name of the class and the presence of a pointer to the data.  However, now we have the opportunity not to crawl over memory in heap.  A class in C ++ terminology still stores data in the form of its fields.  In fact, the data will be placed in the m_buffer buffer, the memory for which is already allocated when creating the class.  It remains only to explain the details of how to place the data in the buffer bytes. <br><br><h4>  Hosting new </h4><br>  As a rule, few remember about such a useful property of the operator new, as the ability to specify a ready-made memory area to accommodate the object being created.  All we need is to write new (m_buffer) to create any type of object in the allocated buffer.  It sounds simple, but you need to remember that we are paying a high price: beforehand specifying the maximum buffer size.  Moreover, the buffer size falls into the header file and is clearly involved in the declaration of the API. <br><br>  But we win in speed.  If, by allocating data on the heap for each initialization, we risk lagging behind Java, then by placing all the data on the stack, we have the speed of pure C, the unattainable speed for almost any high-level language except C ++.  At the same time, the level of abstraction is extremely high; we are building the API on ordinary C ++ objects, hiding implementation details.  The only limitation is the size that we specify;  we can no longer easily change in the implementation of the set of fields in the data class, always need to remember about the size.  Moreover, we need to check the size of the data described in the implementation for compliance with the one specified in the header file.  Just because the library build may differ from the version of the header files, for example, when it comes from various sources.  Let's look at an example of how such a test should look like, as well as creating an object in prepared memory that places new. <br><br><pre> <code class="cpp hljs">object::object() : m_data(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(m_buffer) object::data) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(object::data) &lt;= max_data_size, <span class="hljs-string"><span class="hljs-string">"..."</span></span>); }</code> </pre><br>  Here, static_assert is actually executed at the compilation stage, so the initialization of m_data will be performed only if object :: data has enough memory in the m_buffer buffer.  Similarly, for a descendant class, such as flower, object class, the data should also not exceed the specified bar, since we store the data in the implementation of the base class. <br><br><pre> <code class="cpp hljs">flower::flower(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; name) : object(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(get_buffer()) flower::data(name)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(flower::data) &lt; max_data_size, <span class="hljs-string"><span class="hljs-string">"..."</span></span> ); }</code> </pre><br>  Obviously, for this you need a protected-method get_buffer () to get the address m_buffer in the base class, as well as a protected constructor object from object :: data *.  Just as in the previous release, we inherit the data of the heirs from the base class data, therefore flower :: data * is compatible with object :: data *.  For security, it is necessary to add a check to the base constructor from object :: data * that the address of the previously allocated buffer is transmitted: <br><br><pre> <code class="cpp hljs">object::object(object::data* data_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(data_ptr) != <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(m_buffer)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> some_exception(...); m_data = data_ptr; }</code> </pre><br>  As a result, as before, we have the ability to emulate dynamic typing, working with ordinary class objects.  For example: <br><br><pre> <code class="cpp hljs">object rose = flower(<span class="hljs-string"><span class="hljs-string">"rose"</span></span>);</code> </pre><br><h4>  Objects with large data </h4><br>  It remains to find out what to do with objects whose data size goes beyond the indicated maximum.  In fact, everything is pretty simple here.  It suffices that the copy_on_write &lt;data :: impl&gt; size, which is essentially a superstructure over std :: shared_ptr &lt;data :: impl&gt;, fits into the limit, where impl is an implementation of a data class of arbitrary size.  Since the size of std :: shared_ptr &lt;data :: impl&gt; does not depend on the size of the data :: impl class objects themselves, we get a universal way of storing data with a transition from storage by value to storage by reference. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">huge</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">huge</span></span></span><span class="hljs-class">:</span></span>:data { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: copy_on_write&lt;impl&gt; m_impl; };</code> </pre><br>  However, let's digress from solving the problem of a single API for objects with dynamic typing and consider another example of optimization through hosting new. <br><br><blockquote><h4>  copy_on_write :: flashback </h4><br>  If someone missed the previous release, the copy_on_write class is a template class for storing data with copy optimization.  Emulating a pointer, this class has a tricky operator-&gt; overload for const and non-const cases.  When copying objects, we refer to the same data without causing expensive copying.  However, as soon as we call a non-constant data class method that potentially changes data, we unlink our copy of the data for the current object.  Simplified implementation looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> impl_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy_on_write</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: copy_on_write(impl_type* pimpl) : m_pimpl(pimpl) { } impl_type* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_pimpl.unique()) m_pimpl.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> impl_type(*m_pimpl)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_pimpl.get(); } impl_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_pimpl.get(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;impl_type&gt; m_pimpl; };</code> </pre><br>  Thus, when choosing the maximum data size for the built-in buffer, it is worth considering the size of the class containing copy_on_write as a field. </blockquote><br><h4>  Data Fields </h4><br>  The most powerful way to optimize via posting new is the fields of the selection records as a result of the SQL query.  A sample requests a set of data of a wide variety of types, from integer and real to strings and arrays.  Although the data itself is obtained dynamically and field types obtained from the database have to be initialized with dynamic typing emulation, but all the records contain the same set of field types by which you can determine the total data size for each record.  This allows us to allocate memory for record fields only once, by calculating the size of the field types included in each sample record.  You can also allocate memory once for all records as a single block, however, as a rule, after selecting records, various operations are performed on the records, including filtering and sorting them, so it makes sense to describe the records themselves as Copy-On-Write objects for the convenience of subsequent operations .  Allocating memory for each field from a heap is unreasonably expensive. <br><br>  This is how our write class will look like if we simplify the declaration and use copy_on_write directly from the data class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: record(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types); ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: copy_on_write&lt;data&gt; m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">:</span></span>:data { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types); ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; m_buffer; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field*&gt; m_fields; };</code> </pre><br>  Here, to simplify the explanation, the vector of field types std :: vector &lt;field :: type&gt; is entered, an array of enum-values.  In fact, this array should be typed from the arguments through boost :: fusion or, using Boost.Preprocessor, you can type an array of generalized objects of type object from any type of arguments.  We are now important is the mechanism of a single memory allocation from the heap for each record. <br><br><pre> <code class="cpp hljs">record::data::data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types) : m_buffer(field::calc_size(types)), m_fields(types.size()) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(types.begin(), types.end(), m_fields.begin(), [&amp;offset](field::type type, field*&amp; field_ptr) { field_ptr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(m_buffer + offset) field(type); offset += field::size(type); } ); }</code> </pre><br>  where field :: size calculates the size of the data given by field :: type, and field :: calc_size calculates the total size already needed for the entire set of record types, passed as std :: vector &lt;field :: type&gt;. <br><br>  The field is implemented similarly to the object type, which is essentially a dynamic content container.  Most types: int64_t, bool, double are scalars and are stored by value.  The std :: string type can also be stored by value, but it‚Äôs worth considering that the strings will almost certainly be stored on the heap and be dynamically allocated.  If you want to support a certain varchar of a certain length, then here, most likely, you will need your copy_on_write type with an array of characters of a fixed length. <br><br>  Different types of fields are similar to different types of objects inherited from the object class.  You can even not use enum, but tied directly to types, but, as a rule, parsing the result of an SQL query entails deserializing a packet of bytes with data, where all field types are known in advance, so enum does not entail any limitations for convenience.  Moreover, metaprogramming is not for the faint of heart, and we will not consider MPL and Boost.Fusion here. <br><br>  It remains to touch on the last important aspect of using allocating new - a pool of similar objects in C ++. <br><br><h4>  Pool of similar objects </h4><br>  As before, we optimize dynamic memory allocation.  What is a pool of objects?  This is an array of presets allocated in advance by a large group to initialize a specific type.  In a sense, the record above was a pool for field objects.  Also, you probably met a pool of objects, if you worked with high-level languages ‚Äã‚Äã(C #, Python, Java), because to select new objects, they use prepared memory segments in which they place objects, in essence, the object type.  After one of the pool objects is no longer needed, in other words, it was no longer referenced, it either immediately deinitialized, or waits for its sad fate in the form of another bypass of the Garbage Collector - the garbage collector - a special mechanism for removing orphaned good.  Generally speaking, deinitializing objects in a pool is its weak point.  But we get a speedy selection of objects, as a rule, either already initialized or prepared for initialization.  If we make, on the basis of our type object, a full-fledged pool of objects with deinitialization by the reference counter and with the Garbage Collector, we will get Java or Python.  If you needed something like this, maybe you shouldn‚Äôt make a fuss and take a ready-made language with garbage collection?  However, if in order to optimize objects of the same type, it was necessary to allocate in advance a large memory segment and the task really requires mass initialization of a large number of objects with a certain base class, then a pool of objects will avoid the mass of dynamic memory allocations. <br><br>  To understand, we need a clear application explanation.  How about the actual sample as a result of a SQL query with a pool for records?  This will optimize the mass allocation of memory for constructing objects in the sample records. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">selection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: selection(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row_count); ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: copy_on_write&lt;data&gt; m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">selection</span></span></span><span class="hljs-class">:</span></span>:data { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row_count); ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; m_types; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; m_buffer; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;record&gt; m_rows; }; selection::data::data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row_count) : m_types(types) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!row_count) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; m_rows.reserve(row_count); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row_data_size = field::calc_size(types); m_buffer.resize(row_count * row_data_size); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* offset = m_buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; row_count; ++i) { m_rows.push_back(record::inplace(offset, types)); offset += row_data_size; } }</code> </pre><br>  Where record :: inplace essentially creates these records not on the heap, but at a given address. <br><br><pre> <code class="cpp hljs">record record::inplace(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;field::type&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; types) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> record(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(address) record::data(types)); }</code> </pre><br>  We need a record constructor with initialization and a special destructor, more on that later.  This version of record initialization makes it impossible to use it in the previous version, that is, in the form of a class containing only the copy_on_write field.  We will not be able, calmly hoping for a dynamic selection of data in the heap, to roll records as we want.  On the other hand, we get a crazy performance boost with a large dataset.  However, there is a dirty trick in placing new, which you should be aware of. <br><br><h4>  Explicit destructor call </h4><br><blockquote><h4>  WARNING </h4><br>  If someone has a habit of not reading it up to the end or reading diagonally, it is very vain.  By skipping this important section, you can add memory to leak leakage - memory leaks, and in large quantities. </blockquote><br>  There is one more ‚Äúbut‚Äù when using the host new - you have to call the destructor yourself, manually, since delete will not do anything at all.  Therefore, a class containing data that is allocated to a previously prepared memory must explicitly call the destructor of the class created in memory in the destructor.  So, the object :: ~ object class destructor must explicitly call the object :: data :: ~ data destructor, and the record :: data :: ~ data destructor will have to call a whole number of field :: ~ field destructors - one for each field.  In order to visually show how this should happen, I will write out the object class in more detail. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: object(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~object(); ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; object(data* derived_data); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_data_size = N; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: data* m_data; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> m_buffer[max_data_size]; }; object::object() : m_data(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(m_buffer) data) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(data) &lt;= max_data_size, <span class="hljs-string"><span class="hljs-string">"..."</span></span>); } object::~object() { m_data-&gt;~data(); }</code> </pre><br>  Since the destructor for the data class must be described as virtual, the data will also be successfully deinitialized, whatever the heir object :: data is used for. <br><br>  You also need to redefine the constructor and copy operator, as well as the displacements, because unlike the case with copy_on_write, where we were satisfied with the auto-generated constructor, here each object looks at its data area with a simple pointer.  Therefore, correct the default behavior: <br><br><pre> <code class="cpp hljs">object::object(object <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; another) : m_buffer(max_data_size), m_data(another.clone_data_at(m_buffer)) { } object&amp; object::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (object <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; another) { destruct_data(); <span class="hljs-comment"><span class="hljs-comment">//     m_data = another.clone_data_at(m_buffer); return *this; } object::data* object::clone_data_at(void* address) { return m_data-&gt;clone_at(address); } //      //      object::data* object::data::clone_at(void* address) { return new(address) data(*this); } void object::destruct_data() { m_data-&gt;~data(); }</span></span></code> </pre><br>  Here, our new desctuct_data () method is requested in the object :: ~ object destructor.  Once asked, it means that there is a place for him.  For the constructor and the move operator, the behavior is similar: <br><br><pre> <code class="cpp hljs">object::object(object&amp;&amp; another) : m_data(another.move_data_to(m_buffer)) { } object&amp; object::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (object <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; another) { destruct_data(); <span class="hljs-comment"><span class="hljs-comment">//     m_data = another.move_data_to(m_buffer); return *this; } object::data* object::move_data_to(void* address) { return m_data-&gt;move_to(address); } //      //      object::data* object::data::move_to(void* address) { return new(address) data(std::move(*this)); } object::~object() { destruct_data(); }</span></span></code> </pre><br>  So, the danger of memory leak'ov eliminated.  Users of your API can develop easy. <br><br><h4>  Placing new versus new on the heap </h4><br>  As you have already noticed, classes that use host new are much more difficult to implement.  Every aspect of using a class implemented on the technique of placing an object into a prepared memory should be thoroughly tested.  The complexity of the usual new of any class, as a rule, is reduced to wrapping a smart pointer.  What is the benefit then, even if the emulation of dynamic typing is complicated by explicitly specifying the maximum size of the data type? <br><br>  Gain in speed.  The power of C ++ compared to more convenient C #, Java and Python is in execution speed.  Here we reach the highest speeds, because we don‚Äôt go to the heap for new objects.  And do not slow down the application in the longer term, avoiding memory fragmentation.  Fragmented memory like cheese: full of holes, and in the total the size of these holes allows you to push an orange there, but in fact the orange does not fit into any of the holes, each of them is too small.  Similarly, std :: vector, like std :: string, which require a segment of continuous memory, can at one point get std :: bad_alloc when redistributing elements. <br><br><h4>  Placing new in the standard library </h4><br>  Remember, I promised to tell you about placing new in std :: vector at the beginning of the article?  So, all the constructors of elements in std :: vector are called in prepared memory.  And destructors are also actively called for elements.  It doesn't matter for vectors from simple POD types like int or char, but if we want to select std :: vector, and custom has a non-trivial and heavy default constructor and a no less heavy copy constructor, then we get a lot of trouble if we don‚Äôt Know how std :: vector works with its data. <br><br>  So, what happens when we ask a vector to resize?  To begin with, the vector looks that it has not yet reserved the necessary number of bytes (the buffer the vector always allocates with a margin), after which it allocates a new buffer.  All existing elements are transferred to the new buffer by the relocation constructor via placing new at the appropriate address.  As a result, all the elements are in place.  After that, the vector gets the required number of elements to the end of the array, creating each one with a new allocator and a default constructor.  Similarly, in the opposite direction - reducing the number of elements will cause destructors "manually" when deleting elements. <br><br>  Unlike std :: vector, the std :: string container does not do placement new simply because it always stores a char that does not need constructors or destructors.  But a number of standard library containers: deque, list, map, and other class templates for storing arbitrary data ‚Äî are actively using hosting new in their implementation. <br><br>  No need to think about placing new as something akin to hak, it is a full-fledged language function that allows you to initialize an object with a designer for the specified memory.  This operation is similar to the old trick of the C language, when the allocated block of bytes was declared by a pointer to a certain type (usually a structure) and then work with this block of memory was carried out through this type of API. <br><br><h4>  What is the result? </h4><br>  Of course, the ability to use placing new where it is needed, and only when it is really needed, effectively and justifiably, does not come immediately.  Some of them fight back with the harm of preliminary optimization, others, on the contrary, only after reading the article will rush to embed new (m_buffer) where necessary and where not.  Over time, both come to a golden middle. <br><br>  The essence of the method is simple - if it is possible and necessary to place a class object in a memory prepared in advance, it is relatively simple to do this if you remember a couple of simple rules: <br><br><ul><li>  the memory must live all the time while the object lives in it, if the memory is rubbed, then the object will begin to refer to the broken memory segment; </li><li>  the class destructor for the object allocated to host new must be called manually, which is sad, but delete does not do anything with the memory of the pointer. </li></ul><br>  Everything else is limited only by the accuracy and boundless imagination of the developer.  That is you. <br><br><img src="https://xakep.ru/wp-content/uploads/2014/11/COVER_11_2014_LOW-326x420.jpg" alt="image"><br><br>  <i>First published in Hacker Magazine # 190.</i> <i><br></i>  <i>Author: Vladimir <a href="http://habrahabr.ru/users/qualab/" class="user_link">Qualab</a> Kerimov, Lead C ++ Developer, Parallels</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/257893/">https://habr.com/ru/post/257893/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257883/index.html">Comparative analysis of HL7 and openEHR</a></li>
<li><a href="../257885/index.html">Courses on ethical hacking and penetration testing: updated program</a></li>
<li><a href="../257887/index.html">Python nightmares: the implicit `this`</a></li>
<li><a href="../257889/index.html">Fast cross-platform HTML5 application on Framework7</a></li>
<li><a href="../257891/index.html">Escape from the dungeon types. We work with data, the type of which is determined dynamically.</a></li>
<li><a href="../257895/index.html">The sad story of forgotten characters. How not to go crazy when working with encodings in C ++</a></li>
<li><a href="../257897/index.html">That's the point, sailed! We learn to work with floating-point numbers and develop an alternative with fixed decimal precision.</a></li>
<li><a href="../257899/index.html">Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</a></li>
<li><a href="../257903/index.html">Introduction to functional programming in Python</a></li>
<li><a href="../257905/index.html">Travel SIM + cloud PBX and new approaches to the IP-PBX interface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>