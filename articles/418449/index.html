<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Binary modules for Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python is cool. We say ‚Äúpip install‚Äù and most likely the necessary library will be installed. But sometimes the answer will be: ‚Äúcompilation failed‚Äù, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Binary modules for Python</h1><div class="post__text post__text-html js-mediator-article">  Python is cool.  We say ‚Äúpip install‚Äù and most likely the necessary library will be installed.  But sometimes the answer will be: ‚Äúcompilation failed‚Äù, because there are binary modules.  Almost all modern languages ‚Äã‚Äãsuffer from some kind of pain, because there are many architectures, something needs to be collected for a specific machine, something needs to be linked with other libraries.  In general, an interesting, but little-studied question: how to make them and what problems are there?  Dmitry Zhiltsov ( <a href="https://habr.com/users/zaabjuda/" class="user_link">zaabjuda</a> ) tried to answer this question on MoscowPython Conf last year. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P7ihyyIDtME" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Under the cut text version of the report of Dmitry.  Let us briefly dwell on when binary modules are needed, and when they should be abandoned.  We will discuss the rules that should be followed when writing them.  Consider five possible implementation options: <br><br><ul><li>  Native C / C ++ Extension </li><li>  Swig </li><li>  Cython </li><li>  Ctypes </li><li>  Rusty </li></ul><br>  <strong>About speaker</strong> : Dmitry Zhiltsov has been developing for more than 10 years.  He works for CIAN as a system architect, that is, he is responsible for technical decisions and control over deadlines.  In his life, he managed to try and assembler, Haskell, C, and for the last 5 years he has been actively programming in Python. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  About company <br></h2><br>  Many who live in Moscow and rent housing, probably know about CIAN.  CIAN is 7 million buyers and tenants per month.  All these users every month, with the help of our service, find a place to live. <br><br>  About our company know 75% of Muscovites, and this is very cool.  In St. Petersburg and Moscow, we are practically considered monopolists.  At the moment we are trying to reach the regions, and therefore, the development has grown 8 times over the past 3 years.  This means that the teams increased 8 times, the speed of delivery of valuables to the user increased 8 times, i.e.  from the product idea to how the engineer‚Äôs hand rolled out the build to production.  We learned in our large team to develop very quickly, and very quickly understand what is happening at the moment, but today we will talk a little about something else. <br><br>  I will talk about binary modules.  Now almost 50% of the libraries in Python have some kind of binary modules.  And as it turned out, many people are not familiar with them and believe that this is something transcendental, something dark and unnecessary.  And other people suggest it is better to write a separate microservice, and not to use binary modules. <br><br>  The article will consist of two parts. <br><br><ol><li>  My experience: what are they for when it is better to use them and when not. <br></li><li>  Tools and technologists with which you can implement a binary module for Python. <br></li></ol><br><h2>  Why do we need binary modules <br></h2><br>  We all know that Python is an interpreted language.  It is almost the fastest interpreted language, but, unfortunately, its <strong>speed is not always sufficient</strong> for heavy mathematical calculations.  Immediately the thought arises that C will be faster. <br><br>  But Python has another pain - <strong>GIL</strong> .  A huge number of articles have been written about him and reports have been made on how to get around it. <br><br>  We also need binary extensions to <strong>reuse logic</strong> .  For example, we found a library in which all the functionality we need is available, and why not use it.  That is, do not re-write the code, we just take the ready-made code and reuse it. <br><br>  Many people believe that using binary extensions, you can <strong>hide the source code</strong> .  The question is very, very controversial, of course with the help of some wild perversions you can achieve this, but there is no 100% guarantee.  The maximum that can be obtained is to prevent the client from decompiling and see what happens in the code that you transferred. <br><br><h3>  When are binary extensions really needed? <br></h3><br>  It‚Äôs clear about speed and Python - when some function works very slowly with us and takes up 80% of the execution time of all the code, we start thinking about writing a binary extension.  But in order to make such decisions, you need to start, as one famous speaker said, to think with your brain. <br><br>  In order to write extensions, you need to take into account that, firstly, it will be a long time.  First you need to "lick" their algorithms, i.e.  see if there are any shoals. <br><br><blockquote>  In 90% of cases, after a thorough check of the algorithm, there is no need to write any extensions. <br></blockquote><br>  The second case where binary extensions are really needed is the <strong>use of multi threading for simple operations</strong> .  Now it is not so important, but it still remains in a bloody enterprise, in some system integrators, where it is still written in Python 2.6.  There is no asynchrony, and even for simple things, such as loading a bunch of pictures, multi-threading rises.  It seems that initially it does not bear any network costs, but when we upload the image to the buffer, the ill-fated GIL comes in and some brakes start.  As practice shows, such things are better solved with the help of libraries that Python knows nothing about. <br><br>  If you need to implement some specific protocol, it may be convenient to make simple C / C ++ code and get rid of a lot of pain.  I did this at one time in one telecom operator, since there was no ready-made library, I had to write it myself.  But I repeat, now this is not very relevant, because there is asyncio, and for most tasks this is enough. <br><br>  I have already said in advance about <strong>difficult operations</strong> .  When you have a number of crushers, large matrices and the like, it is logical that you need to do an extension in C / C ++.  I want to note that some people think that we don‚Äôt need binary extensions here, it‚Äôs better to do microservice in some ‚Äú <a href="https://golang.org/">super-fast language</a> ‚Äù and transfer huge matrices over the network.  No, it's better not to do that. <br><br>  Another good example of when they can and even need to be taken is when you have a <strong>well-established logic for the operation of a module</strong> .  If you have a Python module or library already in your company for 3 years, there are changes in it once a year and then 2 lines, then why not arrange it in a normal C library if there are free resources and time.  At a minimum, get an increase in performance.  And there will also be an understanding that if some fundamental changes are needed in the library, then it is not so easy and, perhaps, again, the brain should think about it and use this library somehow differently. <br><br><h3>  5 golden rules <br></h3><br>  I derived these rules in my practice.  They concern not only Python, but also other languages ‚Äã‚Äãfor which binary extensions can be used.  You can argue with them, but you can think and bring your own. <br><br><ol><li>  <strong>Export functions only</strong> .  Building classes in Python in binary libraries is quite laborious: you need to describe a lot of interfaces, you need to revise a lot of referential integrations in the module itself.  It's easier to write a small interface for a function. <br></li><li>  <strong>Use wrapper classes</strong> .  Some like OOP very much and want classes very much.  In any case, even if these are not classes, it is better to simply write a Python wrapper: create a class, set a class method or an ordinary method, call natively C / C ++ functions.  At a minimum, this helps maintain the integrity of the data architecture.  If you are using some kind of C / C ++ third-party extension that you cannot fix, then in the wrapper you can hack it so that it all works. <br></li><li>  <strong>You can't pass arguments from Python to an extension</strong> ‚Äî it's not even a rule, but rather a requirement.  In some cases this may work, but usually this is a bad idea.  Therefore, in your C code, you first have to make a handler that brings the Python type to type C. And only after that call any native function that already works with caching types.  The same handler accepts the response from the executable function and converts it into Python data types, and sends it to the Python code. <br></li><li>  <strong>Consider garbage collection</strong> .  In Python, there is a well-known GC, and you should not forget about it.  For example, we pass on a link a large piece of text and try to find some word in the library.  We want to parallelize it, pass the link to this particular area of ‚Äã‚Äãmemory and start several threads.  At this time, the GC simply takes and decides that nothing else refers to this object and removes it from the memory area.  In the same code, we just get a null reference, and this is usually the segmentation fault.  One should not forget about such a feature of the garbage collector and transfer the simplest data types to the library libraries: char, integer, etc. <br><br>  On the other hand, the language in which the extension is written may have its own garbage collector.  The combination of Python and the C # library in this sense is a pain. <br></li><li>  <strong>Explicitly define the arguments of the exported function</strong> .  By this I want to say that these functions will need to be annotated qualitatively.  If we accept the PyObject function, and in any case we will accept it in our sish libraries, then we will need to explicitly indicate which arguments belong to which types.  This is useful because if we pass the wrong data type, we get an error in the library library.  That is necessary for your convenience. <br></li></ol><br><h3>  Binary extensions architecture <br></h3><br><img src="https://habrastorage.org/webt/xq/q1/-0/xqq1-0l_omlmuok-v8yqryqkvku.png"><br><br>  Actually, there is nothing difficult in the architecture of binary extensions.  There is Python, there is a calling function, which lands on a wrapper, which natively calls sish code.  This call in turn lands on a function that is exported to Python and which it can directly call.  It is in this function that you need to bring data types to the data types of your language.  And only after this function has translated everything to us, we call the native function, which does the basic logic, returns the result in the opposite direction and throws it in Python, translating the data types back. <br><br><h2>  Technologies and tools <br></h2><br>  The most famous way to write binary extensions is the Native C / C ++ extension.  Just because it is standard Python technology. <br><br><h3>  Native C / C ++ extension <br></h3><br>  Python itself is implemented in C, and the methods and structures from python.h are used when writing extensions.  By the way, this thing is also good because it is very easy to implement it in an already finished project.  It is enough to specify xt_modules in setup.py and say that to build a project you need to compile such and such sources with such compilation flags.  Below is an example. <br><br><pre><code class="cpp hljs">name = <span class="hljs-string"><span class="hljs-string">'DateTime.mxDateTime.mxDateTime'</span></span> src = <span class="hljs-string"><span class="hljs-string">'mxDateTime/mxDateTime.c'</span></span> extra_compile_args=[<span class="hljs-string"><span class="hljs-string">'-g3'</span></span>, <span class="hljs-string"><span class="hljs-string">'-o0'</span></span>, <span class="hljs-string"><span class="hljs-string">'-DDEBUG=2'</span></span>, <span class="hljs-string"><span class="hljs-string">'-UNDEBUG'</span></span>, <span class="hljs-string"><span class="hljs-string">'-std=c++11'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wall'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wextra'</span></span>] setup ( ... ext_modules = [(name, { <span class="hljs-string"><span class="hljs-string">'sources'</span></span>: [src], <span class="hljs-string"><span class="hljs-string">'include_dirs'</span></span>: [<span class="hljs-string"><span class="hljs-string">'mxDateTime'</span></span>] , extra_compile_args: extra_compile_args } )] )</code> </pre> <br>  Pros Native C / C ++ Extension <br><br><ul><li>  Native technology. </li><li>  Easily integrated into the project build. </li><li>  The greatest amount of documentation. </li><li>  Allows you to create your own data types. </li></ul><br>  Cons Native C / C ++ Extension <br><br><ul><li>  High entry threshold. </li><li>  Knowledge of C is necessary. </li><li>  Boost.Python. </li><li>  Segmentation Fault. </li><li>  Difficulties in debugging. </li></ul><br>  On this technology, a huge amount of documentation is written, both standard and posts in all sorts of blogs.  A huge plus is that we can make our own Python data types and construct our classes. <br><br>  This approach has big drawbacks.  First of all, this is the entry threshold - not everyone knows C enough to code for production.  You need to understand that it is not enough to read the book and run to write native extensions.  If you want to do this, then: first learn C;  then start writing command utilities;  only then proceed to writing the extensions. <br><br>  Boost.Python is very good for C ++, it allows you to almost completely abstract from all these wrappers that we use in Python.  But the minus I think is that to take some part of it and import it into the project, without downloading the whole Boost, you need to sweat very much. <br><br>  Enumerating the difficulties in debugging in the minuses, I mean that now everyone is used to using the graphical debugger, and with binary modules such a thing will not work.  Most likely you will need to put GDB with a plugin for Python. <br><br>  Consider an example of how we create it. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Python.h&gt; static PyObject*addList_add(Pyobject* self, Pyobject* args){ PyObject * listObj; if (! PyARg_Parsetuple( args, "", &amp;listObj)) return NULL; long length = PyList_Size(listObj) int i, sum =0; //   return Py_BuildValue("i", sum); }</span></span></span></span></code> </pre><br>  First, we include the Python header files.  After that, we describe the addList_add function that Python will use.  The most important thing is to call the function correctly, in this case addList is our name of the sish module, _add is the name of the function that will be used in Python.  We pass the PyObject module itself and pass arguments, too, using PyObject.  After that we make standard checks.  In this case, we are trying to parse the argument tuple and say that this object - the literal "O" must be explicitly specified.  After this, we know that we have passed a listObj as an object, and we are trying to find out its length using standard Python methods: PyList_Size.  Notice, here we still cannot use sishnye calls to find out the length of this vector, but use the Python functional.  Omit the implementation, after which you must return all values ‚Äã‚Äãback to Python.  To do this, call Py_BuildValue, specify which data type we return, in this case ‚Äúi‚Äù is an integer, and the variable sum itself. <br><br>  In this case, everyone understands - we find the sum of all the elements of the list.  Let's go a little further. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; length; i++){ <span class="hljs-comment"><span class="hljs-comment">//     //   Python- PyObject* temp = PyList_GetItem(listObj, i); //  ,      //     C long long elem= PyLong_AsLong(temp); sum += elem; }</span></span></code> </pre><br>  Here is the same thing, at the moment listObj is a Python object.  And in this case we are trying to take list items.  For this, Python.h has everything you need. <br><br>  After we got temp, we try to cast it to long.  And only after that you can do something in C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  static char addList_docs[] = "add( ): add all elements of the list\n"; //    static PyMethodDef addList_funcs[] = { {"add", (PyCFunction)addList_add, METH_VARARGS, addList_docs}, {NULL, NULL, 0, NULL} };</span></span></code> </pre><br>  Once we have implemented the entire function, you need to write documentation.  <strong>Documentation is always good</strong> , and in this toolkit everything is there for easy reference.  Adhering to the convention on names, we call the module addList_docs and save the description there.  Now you need to register the module, for this there is a special structure PyMethodDef.  When describing properties, we say that the function is exported to Python under the name ‚Äúadd‚Äù, that this function calls PyCFunction.  METH_VARARGS means that a function can potentially accept any number of variables.  We also wrote down additional lines and described a standard check, in case we just imported the module, but didn‚Äôt apply to any method so that all of us would not fall. <br><br>  After we have announced all this we are trying to make a module.  We create moduledef and put everything that we have already done there. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PyModuleDef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moduledef</span></span></span><span class="hljs-class"> = {</span></span> PyModuleDef_HEAD_INIT, <span class="hljs-string"><span class="hljs-string">"addList example module"</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, adList_funcs, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre><br>  PyModuleDef_HEAD_INIT is a standard Python constant that you should always use.  ‚Äî1 indicates that no additional memory is required at the import stage. <br><br>  When we created the module itself, we need to initialize it.  Python is always looking for init, so we create PyInit_addList for addList.  Now from the collected structure you can call PyModule_Create and finally create the module itself.  Next, add the meta-information and return the module itself. <br><br><pre> <code class="cpp hljs">PyInit_addList(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>){ PyObject *<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = PyModule_Create(&amp;mdef); If (<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PyModule_AddStringConstant(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, <span class="hljs-string"><span class="hljs-string">"__author__"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bruse Lee&lt;brus@kf.ch&gt;:"</span></span>); PyModule_addStringConstant (Module, <span class="hljs-string"><span class="hljs-string">"__version__"</span></span>, <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>; }</code> </pre><br>  As you have already noticed, there is a lot to transform.  We must always remember about Python when we write in C / C ++. <br><br>  That is why, to make life easier for an ordinary mortal programmer, 15 years ago SWIG technology appeared. <br><br><h3>  Swig <br></h3><br>  This tool allows you to abstract Python bindings and write native sish code.  It has the same pros and cons as with Native C / C ++, but there are exceptions. <br><br>  SWIG advantages: <br><br><ul><li>  Stable technology. </li><li>  A large amount of documentation. </li><li>  Abstracts from binding to Python. </li></ul><br>  Cons SWIG: <br><br><ul><li>  Long tuning. </li><li>  Knowledge C. </li><li>  Segmentation Fault. </li><li>  Difficulties in debugging. </li><li>  The complexity of integration into the project assembly. </li></ul><br>  The first minus is that <strong>while you set it up, you'll lose your mind</strong> .  When I set it up for the first time, I spent a day and a half to launch it at all.  Then, of course, easier.  In the SWIG 3.x version it became easier. <br><br>  To no longer go into the code, consider the general scheme of SWIG. <br><br><img src="https://habrastorage.org/webt/93/4h/ul/934huleqgml-qurdnxrw8k0gjes.png"><br><br>  example.c is a C module that knows nothing about Python at all.  There is an interface file example.i, which is described in SWIG format.  After that, we run the SWIG utility, which from the interface file creates example_wrap.c - this is the same wrapper that we used to do with our hands.  That is, SWIG just creates a file wrapper for us, the so-called bridge.  After that, using GCC, we compile two files and get two object files (example.o and example_wrap.o) and then create our library.  Everything is simple and clear. <br><br><h3>  Cython <br></h3><br>  Andrei Svetlov made an excellent <a href="https://youtu.be/5-WoT4X17sk">report</a> at MoscowPython Conf, so I‚Äôll just say that this is a popular technology with good documentation. <br><br>  Pros of Cython: <br><br><ul><li>  Popular technology. </li><li>  Pretty stable. </li><li>  Easily integrated into the project build. </li><li>  Good documentation. </li></ul><br>  Cons Cython: <br><br><ul><li>  Its syntax. </li><li>  Knowledge C. </li><li>  Segmentation Fault. </li><li>  Difficulties in debugging. </li></ul><br>  Cons, as always, is.  The main one is its own syntax, which is similar to C / C ++, and very strongly to Python. <br><br>  But I want to emphasize that Python code can be accelerated using Cython by writing native code. <br><br><img src="https://habrastorage.org/webt/tk/8t/sh/tk8tshw1gla6nevwcjda4c9iq20.png"><br><br>  As you can see a lot of decorators, and this is not very good.  If you want to use Cython - refer to the report by Andrey Svetlov. <br><br><h3>  CTypes <br></h3><br>  CTypes is a standard Python library that works with the Foreign Function Interface.  FFI is a low-level library.  This is a native technology, it is often used to horror in the code, with its help it is easy to implement cross-platform. <br><br>  But FFI carries with it large overheads, because all bridges, all handlers at runtime are dynamically created.  That is, we loaded the dynamic library, and Python at this moment does not know anything at all what the library is.  Only when the library is called in memory are these bridges dynamically constructed. <br><br>  Pros CTypes: <br><br><ul><li>  Native technology. </li><li>  Easy to use in code. </li><li>  Easy to implement cross-platform. </li><li>  You can use almost any language. </li></ul><br>  Cons CTypes: <br><br><ul><li>  Bears overhead. </li><li>  Difficulties in debugging. </li></ul><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment">#load the shared object file Adder = CDLL('./adder.so') #Calculate factorial res_int = adder.fact(4) print("Fact of 4 = " + str(res_int))</span></span></code> </pre><br>  Took adder.so and at runtime natively called.  We can even pass native Python types. <br><br>  After all this, there is a question: ‚ÄúSomehow everything is difficult, everywhere C, what to do?‚Äù. <br><br><h3>  Rusty <br></h3><br>  At one time, I did not give this language due attention, but now I‚Äôm practically switching to it. <br><br>  Rust Pros: <br><br><ul><li>  Safe language. </li><li>  Powerful static guarantees of correct behavior. </li><li>  Easily integrated into the project build ( <a href="https://github.com/PyO3/setuptools-rust">PyO3</a> ). </li></ul><br>  Cons Rust: <br><br><ul><li>  High entry threshold. </li><li>  Long tuning. </li><li>  Difficulties in debugging. </li><li>  Documentation is not enough. </li><li>  In some cases, overhead. </li></ul><br>  Rust is a secure language with automatic proof of work.  The syntax itself and the language preprocessor itself do not allow making an explicit error.  At the same time, it is sharpened for variation, that is, it is obliged to process any result of the execution of a code branch. <br><br>  Thanks to the PyO3 team, there are good bindings for Python for Rust, and tools for integrating into a project. <br><br>  I'll take the cons to the fact that for an unprepared programmer, it's very long to tune it.  Little documentation, but in return for cons, we have no segmentation fault.  In Rust, in an amicable way, in 99% of cases, a programmer can get a segmentation fault only if he explicitly specified unwrap and just scored on this case. <br><br>  A small sample of the code of the same module that we considered before. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(proc_macro)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> pyo3; Use pyo3::prelude::*; <span class="hljs-comment"><span class="hljs-comment">/// Module documentation string 1 #[py::modinit(_addList)] fn init(py: Python, m: PyModule) -&gt; PyResult &lt;()&gt;{ py_exception!(_addList, EmptyListError); /// Function documentation string 1 #[pufn(m, "run", args= "*", kwargs="**" )] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt; { run(args, kwargs) } #[pyfn(m, "run", args="*", kwatgs="**")] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt;{ run(args,kwargs) } #[pyfn(m,"add")] fn add(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;i32&gt;{ let mut sum : i32 = 0 match py_list.len() { /// Some code Ok(sum) } Ok(()) }</span></span></code> </pre><br>  The code has a specific syntax, but you get used to it very quickly.  In fact, everything is the same here.  Using macros, we do modinit, which does all the extra work for us to generate all sorts of bindings for Python.  Remember I said, you need to do a handler wrapper, here is the same.  run_py converts types, then we call native code. <br><br>  As you can see, to export a function, there is syntactic sugar.  We simply say that we need the add function, and do not describe any interfaces.  We accept the list, which is exactly py_list, and not Object, because Rust will set up the necessary binders at compile time.  If we pass the wrong data type, as in the ssh extensions, a TypeError will occur.  After we got the list, we start processing it. <br><br>  Let's see in more detail what he is starting to do. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[pyfn(m, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"add"</span></span></span><span class="hljs-meta">, py_list=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"*"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> py_list.len() { <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt;<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(EmptyListError::new(<span class="hljs-string"><span class="hljs-string">"List is empty"</span></span>)), _ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sum : <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> py_list.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp:<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> item.extract() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(v) =&gt; v, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err_msg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"List item {} is not int"</span></span>, item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(ItemListError::new(err_msg)) } }; sum += temp; } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(sum) } } }</code> </pre><br>  The same code that was on C / C ++ / Ctypes, but only now on Rust.  There I tried to bring PyObject to some kind of long.  So that it would be if to us in the list, besides numbers, would there be a string?  Yes, we would get SystemEerror.  In this case, through <strong>let mut</strong> sum <strong>: i32 =</strong> 0;  we are also trying to get a value from list and bring it to i32.  That is, we will not be able to write this code without item.extract (), and we can combine it to the necessary type.  When we wrote i32, in case of a Rust error, at the compilation stage it will say: ‚ÄúHandle the case when not i32‚Äù.  In this case, if we have i32, we return the value, if this is a mistake - we throw an exception. <br><br><h2>  What to choose <br></h2><br>  After this small excursion we will think about what to choose in the end? <br><br>  The answer is really to your taste and color. <br><br>  I will not promote any particular technology. <br><br><img src="https://habrastorage.org/webt/hu/kt/bn/huktbnnsqfoydatdp7gzsisysjg.png"><br><br>  Just summarize: <br><br><ul><li>  In the case of SWIG and C / C ++, you need to know C / C ++ very well, to understand that the development of this module will incur some additional overhead.  But a minimum of tools will be used, and we will work in our native Python technology, which is supported by developers. </li><li>  In the case of Cython, we have a small entry threshold, we have a high development speed, and this is also an ordinary code generator. </li><li>  On account of CTypes, I want to caution about the relatively large overheads.  Dynamic library loading, when we do not know what kind of library it is, can cause a lot of trouble. </li><li>  Rust, I would advise to take to someone who does not know C / C ++.  Rust in production really has the least problems. </li></ul><br><div class="spoiler">  <b class="spoiler_title">useful links</b> <div class="spoiler_text">  <a href="https://github.com/zaabjuda/moscowpythonconf2017">https://github.com/zaabjuda/moscowpythonconf2017</a> <br>  <a href="https://docs.python.org/3/extending/building.html">https://docs.python.org/3/extending/building.html</a> <br>  <a href="https://cython.org/">https://cython.org</a> <br>  <a href="https://docs.python.org/376/library/ctypes.html">https://docs.python.org/376/library/ctypes.html</a> <br>  <a href="https://www.swig.org/">https://www.swig.org</a> <br>  <a href="https://www.rust-land.org/en-US/">https://www.rust-land.org/en-US/</a> <br>  <a href="https://github.com/PyO3">https://github.com/PyO3</a> <br>  <a href="https://www.youtube.com/watch%3Fv%3D5-WoT4X17sk">https://www.youtube.com/watch?v=5-WoT4X17sk</a> <br>  <a href="https://packaging.python.org/tutorials/distributing-packages/">https://packaging.python.org/tutorials/distributing-packages/#platformwheels</a> <br>  <a href="https://github.com/PushAMP/pamagent">https://github.com/PushAMP/pamagent</a> (combat use case) </div></div><br><blockquote>  Call for Papers <br><br>  We accept applications for <a href="https://conf.python.ru/">Moscow Python Conf ++</a> until September 7 - write in this simple <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dmpc2018">form</a> what you know about Python that you really need to share with the community. <br><br>  For those who are more interesting to listen to, I can tell you about the class reports. <br><br><ul><li>  <strong>Donald Whyte</strong> loves to talk about acceleration of mathematics in Python and prepares a <a href="https://conf.python.ru/2018/abstracts/3900">new story</a> for us: how to do math 10 times faster with the help of popular libraries, cunning and cunning, and code that is understandable and supported. <br></li><li>  <strong>Artyom Malyshev has</strong> gathered all his many years of experience in developing Django and is presenting a <a href="https://conf.python.ru/2018/abstracts/3911">report-guide</a> on the framework!  Everything that happens between receiving an HTTP request and sending a finished web page: exposing magic, a map of the internal mechanisms of the framework and a lot of useful tips for your projects. <br></li></ul><br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/418449/">https://habr.com/ru/post/418449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418439/index.html">The Basics of Progressive Web Applications</a></li>
<li><a href="../418441/index.html">Basics of privilege escalation in Windows</a></li>
<li><a href="../418443/index.html">GObject: encapsulation, instantiation, introspection</a></li>
<li><a href="../418445/index.html">Django Channels - the answer to the modern web</a></li>
<li><a href="../418447/index.html">Why Moscow Python Conf is now ++</a></li>
<li><a href="../418451/index.html">3D printing lessons. Effective support and changing the height of the layers in practice from the company 3Dtool</a></li>
<li><a href="../418453/index.html">GRAVITY observations further confirm the general theory of relativity.</a></li>
<li><a href="../418455/index.html">Open webinar "Specialist" at the helm ": first experience and mistakes"</a></li>
<li><a href="../418459/index.html">Development of LVDS scaler with two DisplayPort interfaces</a></li>
<li><a href="../418463/index.html">Working with data in Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>