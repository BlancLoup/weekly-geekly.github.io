<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Assert DSL on the example .Net</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No one denies the usefulness of tests in any complex system. Without tests, you can quickly go into chaos and spend most of your time in the debugger,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Assert DSL on the example .Net</h1><div class="post__text post__text-html js-mediator-article">  No one denies the usefulness of tests in any complex system.  Without tests, you can quickly go into chaos and spend most of your time in the debugger, searching for and catching indirect effects from changes in one or another part of the application.  Tests are important, necessary, and so on. <br><br>  According to science, tests are system documentation.  Competently written tests make it clear how the system works, how it behaves, and all this should be read as a ready-made specification of the behavior of the system.  Those.  ideally, a coherent and understandable text should be obtained.  This is an ideal, to which test methods are gradually approaching, starting from unit testing and most clearly manifested in behavioral / acceptance testing, when the tests themselves are already written in the business language (recall the Fitnesse at this point). <br><br>  When writing tests, you should not skimp on lines of code and classes, it is only important to structure them correctly.  I believe that it may be quite normal situation when you have a test class consists of only one test method - do not be ashamed of this, it is much better than classes on 20 screens.  HD screens. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, everything should be directed to the maximum clarity and clarity of tests, so that all interrelations are clearly visible.  To be able to restore the logic of the program for only one test.  Not only Assert DSL (Domain Specific Language), but also file naming, the <a href="http://www.arrangeactassert.com/why-and-what-is-arrange-act-assert/">Arrange Act Assert</a> approach will go into the matter of readability.  All this is <a href="http://www.gotdotnet.ru/blogs/ulu/5715/">not new approaches</a> as it turns out, but not widely known yet, judging by what I see in the projects around me.  Yes, and I myself came across new topics by chance, studying the <a href="https://github.com/structuremap/structuremap">source codes of</a> StructureMap. <br><br>  In order not to torment, I will immediately tell you what basic steps are proposed to improve the tests: <br><ul><li>  Name the test files according to the main method being tested. </li><li>  Use DSL to create objects to make methods as concise as possible. </li><li>  Try to write tests in the style of "one test method - one assert". </li><li>  Structure the insides of the dough. </li><li>  Create and use Assert DSL. </li></ul><br>  I think that for the majority of many of the items listed are not news, and almost all of them are used in real development. <br><br><a name="habracut"></a><br><br>  In a broad sense, this fits into the paradigm of the <strong>Arrange</strong> <strong>Act</strong> <strong>Assert</strong> , which suggests that it is necessary to clearly distinguish the preparation for the test, the action, the test.  In this case, it turns out that each test class will describe a specific preparation for the test.  In SetUp or in FixtureSetUp, the Act will ideally be specified and the tests will already check the result - Assert. <br><br>  It is best to show it with an example. <br><br>  Suppose we have a class Pirate, which is the implementation of the actions and capabilities of the pirate in the game.  A pirate can move around the field, pick up and leave gold, fight, swim, kill and die.  A lot of things he could and it would be wrong to push all the tests into one file and demarcate the tests by regions.  It is much better to make several test classes, for example: <br><ul><li>  PirateMovementTests </li><li>  PirateAndGoldTests </li><li>  PirateDefaultSettingsTests </li><li>  PirateActionTests </li></ul><br>  Hmm, the pirate is not so branched and more methods to devote them to a separate class.  But then we have a playing field, in which there are more responsible methods.  Suppose a class Field which is responsible for creating the playing field and general movement control.  His tests will be: <br><ul><li>  WhenCreateField </li><li>  WhenCreatePlayableField </li><li>  WhenGenerateShips </li></ul><br>  Then the tests inside the class name for example: <br><ul><li>  MaxSizeShouldBeDefined </li><li>  ShouldGenerateSeaOnBorder </li><li>  ShouldGenerateShips </li></ul><br>  Then when viewing the tests and results, you can read them as <em>When [game]</em> <em>Create</em> <em>Field [</em> <em>it]</em> <em>Should</em> <em>Generate</em> <em>Sea</em> <em>On [</em> <em>field's]</em> <em>Border</em> is almost pure English.  With pirates, you just need to write a little more in the method name, i.e. <br><ul><li>  PirateShouldLostGoldIfHeKilled </li><li>  ActionSurrenderShouldSendPirateOnShip </li></ul><br>  In the case when we can call the test class from the word <em>When</em> , this is a pure example on the Arrange Act Assert.  For example: <br><ul><li>  Arrange - <strong>when the playing field is created</strong> .  In the initialization of the test class, you can prepare everything to create a test playing field. </li><li>  Act - the <strong>creation of the playing field</strong> .  It can be used both in the test method itself and in the initialization of the test method. </li><li>  Arrange - <strong>check performance</strong> .  Ideally, the test method can only consist of it. </li></ul><br>  Example: <br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestFixture</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WhenCreateField</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Field field; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TestEmptyRules rule; [TestFixtureSetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange, Act rule = new TestEmptyRules(); field = rule.Field; } [Test] public void MaxSizeShouldBeDefined() { //Assert Position.MaxColumn.ShouldBeEqual(rule.Size); Position.MaxRow.ShouldBeEqual(rule.Size); } [Test] public void FieldShouldBeCreated() { //Assert field.ShouldBeNotNull(); } [Test] public void ItShouldBeGrassByDefault() { //Assert field.GetPlayableArea() .ShouldContain() .OnlyCellsOf(CellType.Grass); } ‚Ä¶ }</span></span></code> </pre> <br>  All the preparation is done in the initialization of the test class, and then only the checks go. <br><br>  One test - one test.  This can be seen in the examples above.  Immediately it is clear what is being tested and what should be the result.  Often there is a great temptation to add Assert to an already existing test - this is called ‚Äúadd a bunny‚Äù here, and so ‚Äúbunnies‚Äù can then get a bit worse because they will embarrass minds and steal extra time when raising tests after refactoring. <br><br>  Further, the structuredness of the tests is very important.  Compare: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HeMayKillFoes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> airplaneCell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AirplaneCell(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Black.Pirate; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foe = Red.Pirate; airplaneCell.PirateComing(foe); airplaneCell.PirateComing(player); airplaneCell.Pirates.ShouldContain().Exact(player); } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HeMayKillFoes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Arrange var airplaneCell = new AirplaneCell(4, 5); var player = Black.Pirate; var foe = Red.Pirate; airplaneCell.PirateComing(foe); //Act airplaneCell.PirateComing(player); //Assert airplaneCell.Pirates.ShouldContain().Exact(player); }</span></span></code> </pre> <br>  Despite the simplicity of the tests, and they should be simple, the first option, in my opinion, will take more time to realize where the preparations are underway, where the key method will be checked, and where the verification itself is.  In the second variant, the look easily determines the boundaries of the components and the mind is quicker aware of key points.  I guarantee that you yourself will then be easier to examine your tests and recall what exactly is being tested. <br><br>  Another example: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AtSecondTimeHeCanNotTransferToShip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Arrange var airplaneCell = new AirplaneCell(4, 5); var pirate = Black.Pirate; airplaneCell.PirateComing(pirate); //Act airplaneCell.Transfer(); airplaneCell.PirateComing(pirate); airplaneCell.Transfer(); //Assert pirate.State.ShouldBeEqual(PlayerState.Free); }</span></span></code> </pre> <br>  Key points are highlighted and the case for which the test is created is immediately clear.  At corridor testing of this approach, it turned out that the Act is the most controversial point in writing tests.  Different people often see differently what needs to be included in the test setup, and what is included in the action being tested.  The same moment is mentioned in all articles devoted to AAA, the same answer is given, to which we arrived with our colleagues: distinguish between what you consider necessary and how you agree.  Yes, thank you cap!  There are no strict rules. <br><br>  Now the key point, which probably already noticed the most attentive and writing tests comrades.  In tests there is no explicitly <strong>Assert</strong> construction. <br><br>  Honestly, I like this approach much more, because the <strong>first impulse is to write the property that needs to be tested</strong> .  Then you already understand that you need to enter the desired Assert, which I used to hang abbreviations for InteliSense.  For example, for Assert.AreEqual / Assert.That ($ actual $, Is.EqualTo ($ expected $)) was <strong>aae</strong> , i.e.  I typed this combination, pressed Tab and already have a pattern in the code.  But this is inconvenient, it was necessary to configure ReSharper, remember that assert goes first. <br><br>  It is much more convenient to use the potential of the language in terms of writing extension methods and using it.  Thus, you will always have a hint for all developers, regardless of whether they use ReSharper or CodeAssist, or some other system. <br><br> <a href=""><img title="improved" src="https://habrastorage.org/getpro/habr/post_images/199/94f/7a8/19994f7a88bd4efe4758a0a863ffdca7.gif" width="739" height="545"></a> <br><br>  In the illustration above you can see that the code is written on an intuitive, semantic level.  The first impulse is to write the value for testing, then we think how and with what to compare it, and the last step is to record the desired value.  Please note that IntelliSense suggests the type of expected value to check. <br><br> <a href=""><img title="standard" src="https://habrastorage.org/getpro/habr/post_images/4f2/ebf/535/4f2ebf5351f5812ad85a711b41eef28a.gif" width="739" height="599"></a> <br><br>  This illustration shows the standard approach to writing validation for nUnit.  We must remember that the service code Assert.That comes first.  IntelliSense does not always help when writing a value for verification.  The illustration shows the real work without scrolling to any item in the drop-down list.  After writing the value to check, again, you need to ‚Äúremember‚Äù the service word, write the type of check and when entering the expected IntelliSense value is powerless. <br><br>  Next, compare visually two approaches: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FieldShouldBeCreated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Assert field.ShouldBeNotNull(); } [Test] public void FieldShouldBeCreated() { //Assert Assert.IsNotNull(field); }</span></span></code> </pre> <br>  And another example: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxSizeShouldBeDefined</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// DSL Position.MaxColumn.ShouldBeEqual(rule.Size); Position.MaxRow.ShouldBeEqual(rule.Size); // nUnit Assert.That(Position.MaxColumn, Is.EqualTo(rule.Size)); Assert.That(Position.MaxRow, Is.EqualTo(rule.Size)); // MSTest Assert.AreEqual(Position.MaxColumn, rule.Size); Assert.That(Position. MaxRow, rule.Size); }</span></span></code> </pre> <br>  It seems to me that the first options, where extension methods are used, are more understandable and easy to read.  <strong>The main advantage is that you can clearly see what is and what is expected</strong> .  Although nUnit is good in this respect, which somewhat levels the difference in approaches, compared to MSTest, this is heaven and earth.  In general, MSTest does not understand for beginners where the expected result is, and where it is received. <br><br>  Another advantage of writing extension methods for checking tests can be their logical structure, consonant with the domain model.  It is best to demonstrate this again with an example: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItShouldBeGrassByDefault</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Assert field.GetPlayableArea() .ShouldContain() .OnlyCellsOf(CellType.Grass); } [Test] public void ItShouldBeGrassByDefault() { //Assert var playableArea = field.GetPlayableArea(); Assert.IsTrue(playableArea.All(cells =&gt; cells.CellType == CellType.Grass)); //or another case Assert.IsTrue(field.GetPlayableArea() .All(cells =&gt; cells.CellType == CellType.Grass)); }</span></span></code> </pre> <br>  Which way is clearer? <br><br>  I think it‚Äôs easy to develop your own test DSL for a specific use.  But as an example (not yet polished use): <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CollectionAssertCases </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldContain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IEnumerable enumerable</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollectionAssertCases(enumerable); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectionAssertCases</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IEnumerable enumerable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List AsList { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List(enumerable); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CollectionAssertCases</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable enumerable</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.enumerable = enumerable; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Elements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T[] elements</span></span></span><span class="hljs-function">)</span></span> { Assert.That(enumerable, Is.EquivalentTo(elements)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnlyCellsOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CollectionAssertCases collection, CellType cellType</span></span></span><span class="hljs-function">)</span></span> { Assert.IsTrue(collection.AsList.All(c =&gt; c.CellType == cellType)); }</code> </pre> <br>  Besides the fact that DSL for testing becomes more understandable and concise, it allows you to get rid of technically unimportant details.  Reduce duplication of code and increase the speed of writing tests. <br><br>  Another useful application can be found in technical code testing.  For example, I do not want any class property to suddenly become writable, and I can write a test for it easily. <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PiratesStateCanNotBeSetDirectly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Arrange var pirate = Black.Pirate; //Assert pirate.Property("State").ShouldBeReadonly(); }</span></span></code> </pre> <br>  The test is not cluttered with unnecessary methods and actions when working with reflection, but gives control over changing the API, if you work in a large or inexperienced team where it is not always possible to agree on one or another use of properties.  It works the same way as ‚Äúfoolproof‚Äù.  Agree that the test will not cause particularly vivid emotions, even among colleagues, ossified in their rejection, of reflection. <br><br>  Again, following the results of corridor testing on colleagues, it was discovered that the power of habit is a great thing - to immediately read the tests and write them is somewhat unusual.  The eyes are looking for a static class Assert and do not find what causes a slight bewilderment, while it turned out that the word Assert in the comments for some reason does not rush into the eyes.  I think this will pass quickly, since the flexibility of the mind must be present to the developers though. <br><br>  <strong>The advantages to the described approach include:</strong> <br><ul><li>  The process of writing a test in the course of human thought; </li><li>  Explicitly indicating the type of expected data in the prompt when creating an Assert expression; </li><li>  Readability test of the test; </li><li>  Readability tests in general. </li></ul><br>  <strong>By cons I would take:</strong> <br><ul><li>  Threshold of entry.  Beginners will need to explain what exists in the DSL project for checks and the rules for building it, in order to find the necessary methods using IntelliSense. </li></ul><br></div><p>Source: <a href="https://habr.com/ru/post/124254/">https://habr.com/ru/post/124254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124248/index.html">New firmware ABC 516</a></li>
<li><a href="../124249/index.html">ASUDD: What hangs over the road?</a></li>
<li><a href="../124251/index.html">How we show website design to client</a></li>
<li><a href="../124252/index.html">Toyota joined the Linux Foundation</a></li>
<li><a href="../124253/index.html">Cash is better than electronic</a></li>
<li><a href="../124255/index.html">Job Digest: Gamedev</a></li>
<li><a href="../124257/index.html">RIM goes for broke</a></li>
<li><a href="../124258/index.html">Multiplication of long numbers by the Karatsuba method</a></li>
<li><a href="../124260/index.html">Infographics. If social networks were schoolchildren</a></li>
<li><a href="../124261/index.html">Brand reversion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>