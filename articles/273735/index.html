<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebGL for everyone</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The idea of ‚Äã‚Äãthis article was born after several hard weeks of studying WebGL. On a personal example, it turned out that people who have not been con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebGL for everyone</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/91a/bd0/f4b/91abd0f4b8d047709c2b1259f1c02d63.png"><br><br>  The idea of ‚Äã‚Äãthis article was born after several hard weeks of studying WebGL.  On a personal example, it turned out that people who have not been confronted with 3D graphics before, have mostly mistaken ideas about the operation of this technology.  In addition, there was a problem with finding information on the Internet. <br><br>  WebGL, unlike Javascript, has a high threshold of entry, few people still use it, and even fewer of those who write about it.  Most manuals or articles jump right away to use a library.  But we all know that large universal tools are not always suitable for our tasks, or perhaps they do it at an unacceptable level: they lose speed, come with unnecessary baggage, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article wants to ease the threshold for entering a clean WebGL, give an initial idea and tell you where to go next. <br><a name="habracut"></a><br>  Technology WebGL allows you to draw graphics in the browser, using the capabilities of the video card, whereas previously we could only use the processor.  If you do not understand what it gives, I advise you to watch <a href="https://www.youtube.com/watch%3Fv%3D-P28LKWTzrI">this</a> small demonstration. <br><br>  WebGL is based on OpenGL ES 2.0, which, in turn, is a special version for working on mobile devices.  The WebGL specification was released in 2011 and is developed and maintained by the non-profit organization Kronos Group, whose site often lies, which further complicates the study.  It is known that the specification version 2.0 is currently being developed. <br><br><img src="https://habrastorage.org/files/5da/2fd/9ae/5da2fd9ae87941619424d82e8a48836d.png"><br>  <font color="#999999"><i>WebGL support statistics with different browsers from <a href="http://caniuse.com/">caniuse.com</a></i></font> <br><br>  WebGL is available in most modern browsers and is supported by 83% of users.  A nice bonus to developing on WebGL is that you will only support modern browsers and forget about ECMAScript 3 nightmares. <br><br>  If you think that WebGL draws 3D, you are mistaken.  WebGL knows nothing about 3D, it‚Äôs rather a low-level 2D API, and all it can do is draw triangles.  But he can draw a lot of them and very quickly. <br><br>  Want to draw a square?  Please connect two triangles.  Need a line?  No problem, just a few triangles connected in series. <br><br><h3>  How to draw a triangle </h3><br>  Since all the figures in WebGL are made up of triangles, let us analyze in stages how to display one triangle. <br><br>  Unlike OpenGL, in WebGL, only shaders are used for drawing.  Shaders are not connected in any way, as you might think, with shadows or shadows.  Perhaps, they thought precisely for this, but now they are used to draw anything and everything everywhere. <br><br>  A shader is a program running on a video card and using the GLSL language.  This language is quite simple, and learning it is not a problem. <br><br>  In total there are two types of shaders: vertex and fragment, and for drawing absolutely any shape both are always used.  We will deal with each in turn. <br><br>  To understand the essence of the vertex shader, we abstract from the task with a triangle and suppose that you want to draw a cube or any other shape with many vertices.  To do this, you need to specify its geometry, and the geometry, in turn, is specified by specifying the coordinates of the vertices.  Each time it would be unprofitable to calculate the new coordinates of all the vertices when the position of the cube changes in space.  It is better to shift such work from the processor to the video card, for this purpose there is a vertex shader. <br><br>  The coordinates of the vertices of the figure and the position of the local coordinate system in which these vertices are given are transferred to it.  The vertex shader is called for each of the vertices, it calculates their position in the global coordinate system and passes it on for the fragment shader to work. <br><br>  The vertex shader always calculates the position of the vertices, but at the same time it can do other work, for example, calculating the angle of incidence of light.  Enthusiasts do <a href="https://www.chromeexperiments.com/webgl">amazing things</a> using the capabilities of the vertex shaders. <br><br>  Knowledge of the position of the figure is not enough to draw it.  Information is also needed on how the figure should be painted; for this, a fragmentary shader serves.  It is called for each point of the figure's surface and, based on the information transferred, calculates the color of the pixel on the screen. <br><br><img src="https://habrastorage.org/files/896/27b/5df/89627b5df212491aa031e6b33a3a1847.png"><br>  <font color="#999999"><i>If the vertex shader determines the shape geometry, then the fragment shader determines its color.</i></font> <br><br>  As mentioned above, the shader code is written in the GLSL language.  Consider the shader code for a triangle: <br><br>  Example of a vertex shader: <br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> vec3 a_position; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> vec3 a_color; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> vec3 u_position; <span class="hljs-attribute"><span class="hljs-attribute">varying</span></span> vec3 v_color; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main(void) { <span class="hljs-attribute"><span class="hljs-attribute">v_color</span></span> = a_color; <span class="hljs-attribute"><span class="hljs-attribute">gl_Position</span></span> = vec4(u_position + a_position, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Fragment shader example: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; <span class="hljs-type"><span class="hljs-type">varying</span></span> vec3 v_olor; <span class="hljs-type"><span class="hljs-type">void</span></span> main(<span class="hljs-type"><span class="hljs-type">void</span></span>) { gl_FragColor = vec4(v_color.rgb, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  The code consists of variables and the main function that returns the main result of the shader: gl_Position passes the coordinates, and gl_FragColor sets the color. <br><br>  Shaders have three types of variables that are transferred from the main program: <br><ol><li>  attributes - available only in the vertex shader, different for each of the vertices; </li><li>  uniforms - available in both shaders and the same for all shader calls; </li><li>  varying - used to transfer information from the vertex shader to the fragment shader. </li></ol><br>  When calling a fragmentary shader for a specific point, the values ‚Äã‚Äãof varying variables are linearly interpolated between the vertices of the triangle to which this point belongs. <br><br><img src="https://habrastorage.org/files/ddc/37d/94e/ddc37d94ec0a407285bc917870c26100.png"><br>  <font color="#999999"><i>The values ‚Äã‚Äãof varying variables inside the triangle are calculated</i></font> <font color="#999999"><i><br></i></font>  <font color="#999999"><i>based on the values ‚Äã‚Äãof these variables at the vertices</i></font> <br><br>  Let's try to initialize these shaders.  First, get the WebGL context: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gl = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'webgl'</span></span>);</code> </pre><br>  The shader code is represented by a regular string and you need to compile it to use it: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'vertexShader'</span></span>).text); gl.compileShader(vertexShader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'fragmentShader'</span></span>).text); gl.compileShader(fragmentShader);</code> </pre><br>  To bind two types of shaders together, a shader program is used: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program);</code> </pre><br>  If uniform variables are directly linked to variables from js, then for attributes you need to use another entity - buffers.  Buffer data is stored in the video card memory, which gives a significant increase in rendering speed. <br><br>  In our case, we will need: <br><ol><li>  a vertex buffer that stores all the information about the location of the vertices of the geometry; </li><li>  color buffer with vertex color information. </li></ol><br>  Set the vertex buffer: <br><img src="https://habrastorage.org/files/7e8/2b8/1e5/7e82b81e52b548719407bb80dc46e0bd.png"><br>  <font color="#999999"><i>The geometry of our triangle</i></font> <br><br>  Vertices have coordinates: <br><ul><li>  (0, 0, 0); </li><li>  (0.5, 1, 0); </li><li>  (100). </li></ul><br>  It should be noted that when working with buffers, several features should be considered: <br><ol><li>  the data is transferred to the buffer in one array without nesting; in the case of our triangle, the data will be as follows: [0, 0, 0, 0.5, 1, 0, 1, 0, 0]; </li><li>  only <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">typed arrays</a> should be transmitted; </li><li>  Before you transfer data, you must specify which buffer will be used by the gl.bindBuffer method. </li></ol><br>  How it will look like in the program: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertexBuffer = gl.createBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>(vertices), gl.STATIC_DRAW);</code> </pre><br>  Create a similarly color buffer.  Specify the color for each of the vertices in the RGB format, where each component of the color is from 0 to 1: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colorBuffer = gl.createBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]; gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>(colors), gl.STATIC_DRAW);</code> </pre><br>  All that is left for us to draw a triangle is to associate the data with the variables of the shader program and call the rendering methods.  For this: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       var uPosition = gl.getUniformLocation(program, 'u_position'); var aPosition = gl.getAttribLocation(program, 'a_position'); var aColor = gl.getAttribLocation(program, 'a_color'); //         gl.useProgram(program); //   uniform-   gl.uniform3fv(uPosition, [0, 0, 0]); //    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); gl.enableVertexAttribArray(aColor); //    , RGB  3  gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0); //   gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0); //  ,      gl.clearColor(1.0, 1.0, 1.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); //   //       gl.drawArrays(gl.TRIANGLES, 0, 3);</span></span></code> </pre><br>  Our triangle is ready: <br> <a href="https://jsfiddle.net/Trufi/c11xno8j/embedded/result/"><img src="https://habrastorage.org/files/bed/e8f/313/bede8f313f2b43c2b271fb1d6531569f.png"></a> <br>  <font color="#999999"><i>Full sample code can be</i></font> <font color="#999999"><i><br></i></font>  <font color="#999999"><i>look <a href="https://jsfiddle.net/Trufi/c11xno8j/">here</a></i></font> <br><br>  As I said, the color of the pixels inside the triangle is linearly interpolated between the multicolored vertices.  We were able to draw the simplest shape using WebGL and got acquainted with shaders and buffers.  Let's move on to the next stage. <br><br><h3>  How to draw a cube and make it rotate </h3><br>  Let's try to complicate the task and draw a three-dimensional rotating cube.  The cube will consist of six faces, each with two triangles: <br><br><img src="https://habrastorage.org/files/15c/2b5/127/15c2b5127ee94e4eb462032e3aa1387f.png"><br><br>  We will have to register each vertex of each triangle.  There are ways to use a shorter entry, but first we will do it in a simple way: <br><div class="spoiler">  <b class="spoiler_title">It's simple</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertexBuffer = gl.createBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = [ <span class="hljs-comment"><span class="hljs-comment">//   -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, //   -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, 1, //   -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, //   -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, //   -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, 1, //   1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1 ]; gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);</span></span></code> </pre><br></div></div><br>  Similarly, we write the color buffer by coloring the faces of the cube in three colors: <br><ol><li>  (1, 0.5, 0.5) </li><li>  (0.5, 0.7, 1) </li><li>  (0.3, 1, 0.3) </li></ol><br><div class="spoiler">  <b class="spoiler_title">Also a simple example</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colorBuffer = gl.createBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = [ <span class="hljs-comment"><span class="hljs-comment">//   1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, //   1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, //   0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, //   0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, 0.5, 0.7, 1, //   0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, //   0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3, 0.3, 1, 0.3 ]; gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);</span></span></code> </pre><br></div></div><br>  The position of the triangle in space was set using a vector of dimension three.  But the figure can not only change position, it can still rotate and scale.  Therefore, in three-dimensional graphics are used not a position vector, but a matrix. <br><br>  It is known that the rotation matrix in three-dimensional space is defined using a 3 √ó 3 matrix.  A position vector is added to this matrix, so a 4 √ó 4 matrix is ‚Äã‚Äãultimately used. <br><br>  WebGL does not help us work with matrices in any way, so in order not to spend a lot of time on them, we will use the fairly well-known library <a href="http://glmatrix.net/">glMatrix</a> .  Let's create with it the unit position matrix: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cubeMatrix = mat4.create();</code> </pre><br>  To draw a three-dimensional object, we need to introduce the concept of a camera.  The camera, like any object, has its position in space.  It also determines which objects will be visible on the screen, and is responsible for transforming the shapes so that we have the illusion of 3D on the screen. <br><br><img src="https://habrastorage.org/files/dce/43b/f27/dce43bf2775e45b59838f9fba410871e.png"><br>  <font color="#999999"><i>Cube perspective on screen</i></font> <br><br>  The perspective matrix is ‚Äã‚Äãresponsible for this transformation.  With glMatrix, it is created in two lines: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cameraMatrix = mat4.create(); mat4.perspective(cameraMatrix, <span class="hljs-number"><span class="hljs-number">0.785</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth / <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br>  The mat4.perspective method (matrix, fov, aspect, near, far) takes five parameters: <br><ol><li>  matrix - the matrix to be changed; </li><li>  fov - viewing angle in radians; </li><li>  aspect - aspect ratio of the screen; </li><li>  near - the minimum distance to objects that will be visible; </li><li>  far - the maximum distance to objects that will be visible. </li></ol><br>  To make the cube image fall into the camera, move the camera along the Z axis: <br><pre> <code class="javascript hljs">mat4.translate(cameraMatrix, cameraMatrix, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-5</span></span>]);</code> </pre><br>  Unlike the triangle, the shaders for the cube additionally use a position matrix and a camera matrix: <br><br>  Vertex shader: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> vec3 a_position; <span class="hljs-attribute"><span class="hljs-attribute">attribute</span></span> vec3 a_color; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> mat4 u_cube; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> mat4 u_camera; <span class="hljs-attribute"><span class="hljs-attribute">varying</span></span> vec3 v_color; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main(void) { <span class="hljs-attribute"><span class="hljs-attribute">v_color</span></span> = a_color; <span class="hljs-attribute"><span class="hljs-attribute">gl_Position</span></span> = u_camera * u_cube * vec4(a_position, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Fragment Shader: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; <span class="hljs-type"><span class="hljs-type">varying</span></span> vec3 v_color; <span class="hljs-type"><span class="hljs-type">void</span></span> main(<span class="hljs-type"><span class="hljs-type">void</span></span>) { gl_FragColor = vec4(v_color.rgb, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  Shaders are initialized in the same way as in the case of a triangle: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'vertexShader'</span></span>).text); gl.compileShader(vertexShader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'fragmentShader'</span></span>).text); gl.compileShader(fragmentShader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uCube = gl.getUniformLocation(program, <span class="hljs-string"><span class="hljs-string">'u_cube'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uCamera = gl.getUniformLocation(program, <span class="hljs-string"><span class="hljs-string">'u_camera'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aPosition = gl.getAttribLocation(program, <span class="hljs-string"><span class="hljs-string">'a_position'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aColor = gl.getAttribLocation(program, <span class="hljs-string"><span class="hljs-string">'a_color'</span></span>);</code> </pre><br>  So that the cube does not stand still, but rotates, it is necessary to constantly change its position and update the frame.  Updating occurs by means of calling the built-in function requestAnimationFrame. <br><br>  Unlike other similar methods, requestAnimationFrame calls the transferred function only when the video card is free and ready to draw the next frame. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      var cubeMatrix = mat4.create(); //      var lastRenderTime = Date.now(); function render() { //      requestAnimationFrame(render); //       var time = Date.now(); var dt = lastRenderTime - time; //     Y mat4.rotateY(cubeMatrix, cubeMatrix, dt / 1000); //     Z mat4.rotateZ(cubeMatrix, cubeMatrix, dt / 1000); //  ,      gl.clearColor(1.0, 1.0, 1.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //    gl.enable(gl.DEPTH_TEST); gl.useProgram(program); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.enableVertexAttribArray(aPosition); gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); gl.enableVertexAttribArray(aColor); gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0); gl.uniformMatrix4fv(uCube, false, cubeMatrix); gl.uniformMatrix4fv(uCamera, false, cameraMatrix); gl.drawArrays(gl.TRIANGLES, 0, 36); lastRenderTime = time; } render();</span></span></code> </pre><br>  We get a rotating cube: <br> <a href="https://jsfiddle.net/Trufi/r36cw20t/embedded/result/"><img src="https://habrastorage.org/files/18f/45f/e19/18f45fe19dae45639cf96c63d0d2341c.png"></a> <br>  <font color="#999999"><i>Full sample code can be</i></font> <font color="#999999"><i><br></i></font>  <font color="#999999"><i>look <a href="https://jsfiddle.net/Trufi/r36cw20t/">here</a></i></font> <br><br>  We learned how to draw a simple cube, understood how to make it rotate, and became acquainted with the concepts of the position matrix and the camera. <br><br><h3>  How to debug </h3><br>  Since the part of the program is executed on the video card side when working with WebGL, the debugging process becomes much more complicated.  There are no familiar tools in the form of DevTools and even console.log.  On the Internet there are many articles and reports on this topic, here are just a few basic ways. <br><br>  To understand that the shader code was written with an error, after compiling the shaders, you can use the following method: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(gl.getShaderInfoLog(vertexShader)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(gl.getShaderInfoLog(fragmentShader)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gl.getProgramParameter(program, gl.LINK_STATUS)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Could not initialize shaders'</span></span>); }</code> </pre><br>  There is also a special browser extension for <a href="https://benvanik.github.io/WebGL-Inspector/">WebGL-Inspector</a> .  It allows you to track loaded shaders, buffers, textures in a video card, and calls to WebGL methods. <br><br>  There is also the Shader Editor, in Firefox DevTools this functionality is already built in, and for Chrome there is an <a href="https://github.com/spite/ShaderEditorExtension">extension</a> that allows editing the shader code right while the application is running. <br><br><h3>  Where to go next </h3><br>  In the article I tried to highlight the main points that can cause difficulties while studying WebGL.  Despite the fact that the work requires the use of different vectors, matrices and projections, it is not necessary to know how everything is arranged inside.  WebGL is a great tool for solving a variety of tasks, and it can be used not only in game dev.  Do not be afraid to try something new, discover new technologies and experiment. <br><br>  Finally - a list of useful resources where you can continue to explore WebGL. <br><ul><li>  Full code examples with a <a href="https://jsfiddle.net/Trufi/c11xno8j/">triangle</a> and a <a href="https://jsfiddle.net/Trufi/r36cw20t/">cube</a> . </li><li>  <a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf">A brief summary of</a> WebGL from the Kronos Group site. </li><li>  For more detailed study I recommend to go through a series of <a href="http://devburn.ru/%25D1%2583%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B8-webgl/">WebGL Learning</a> lessons. </li><li>  Free course on <a href="https://www.udacity.com/course/interactive-3d-graphics--cs291">Udacity</a> in 3D basics.  Although the course uses the three.js library, it will be useful to everyone. </li><li>  Report of Vladimir Agafonkin about <a href="https://www.youtube.com/watch%3Fv%3DyMmyzzApGy4">WebGL and Mapbox</a> with Frontend Dev Conf. </li><li>  <a href="https://docs.google.com/presentation/d/12AGAUmElB0oOBgbEEBfhABkIMCL3CUX7kdAPLuwZ964/edit">Report Slides</a> Debugging and Optimizing WebGL Applications. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/273735/">https://habr.com/ru/post/273735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273723/index.html">Script for quick assessment of the status of Linux systems</a></li>
<li><a href="../273725/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 24. "Exposure"</a></li>
<li><a href="../273727/index.html">Swift. Functional programming</a></li>
<li><a href="../273731/index.html">SWAT - DSL for rapid development of automated web application tests</a></li>
<li><a href="../273733/index.html">‚ÄúWings, paws and tails‚Äù of our Linux hosting, part 1: how we automated the deployment of infrastructure</a></li>
<li><a href="../273737/index.html">What year 2015 brought us?</a></li>
<li><a href="../27374/index.html">Chinese Internet: like a stone wall</a></li>
<li><a href="../273741/index.html">Adobe Playpanel project closes January 31, 2016</a></li>
<li><a href="../273743/index.html">QThread + QtSql the right way</a></li>
<li><a href="../273745/index.html">History of the 5th place in the Russian AI Cup 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>