<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering messages Protocol Buffers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By reverse engineering, in this context, I mean the restoration of the original message layout closest to the original used by the developers. There a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering messages Protocol Buffers</h1><div class="post__text post__text-html js-mediator-article">  By reverse engineering, in this context, I mean the restoration of the original message layout closest to the original used by the developers.  There are several ways to get what you want.  First, if we have access to the client application, the developers have not taken care to hide the debugging symbols and link to the LITE version of the protobuf library, then getting the original .proto files will not be difficult.  Secondly, if developers use LITE library assemblies, this certainly complicates the life of the reverser, but does not make reversing a useless exercise: with a certain skill, even in this case, you can restore .proto files quite close to the original. <br><a name="habracut"></a><br>  In this article, I would like to describe some techniques of reverse ptobobuf messages, thanks to which my protodec project appeared.  I will note that everything said relates to the protobuf encoding format of message version 2 (version 3 is not yet supported, packed fields too). <br><br><h3>  Training </h3><br>  To begin, I will create objects for research.  We will need 2 files: <br><br><div class="spoiler">  <b class="spoiler_title">addressbook.proto</b> <div class="spoiler_text"><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">package</span></span> tutorial; <span class="hljs-attribute"><span class="hljs-attribute">option</span></span> optimize_for = LITE_RUNTIME; <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Person { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> int32 id = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">optional</span></span> string email = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">enum</span></span> PhoneType { <span class="hljs-attribute"><span class="hljs-attribute">MOBILE</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">HOME</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">WORK</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PhoneNumber { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string number = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">optional</span></span> PhoneType type = <span class="hljs-number"><span class="hljs-number">2</span></span> [default = HOME]; } <span class="hljs-attribute"><span class="hljs-attribute">repeated</span></span> PhoneNumber phone = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> AddressBook { <span class="hljs-attribute"><span class="hljs-attribute">repeated</span></span> Person person = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">tut.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;cassert&gt; #include &lt;string&gt; #include "addressbook.pb.h" int main() { GOOGLE_PROTOBUF_VERIFY_VERSION; tutorial::AddressBook book; tutorial::Person * person = book.add_person(); person-&gt;set_id(1234); person-&gt;set_name("John Doe"); person-&gt;set_email("jdoe@example.com"); tutorial::Person_PhoneNumber * phone = person-&gt;add_phone(); phone-&gt;set_number("555-4321"); phone-&gt;set_type(tutorial::Person_PhoneType_HOME); std::string data = book.SerializeAsString(); assert(!data.empty()); std::cout.write(&amp;data[0], data.size()); google::protobuf::ShutdownProtobufLibrary(); }</span></span></span></span></code> </pre> </div></div><br>  Save them and collect everything together.  If you do not know what protoc is, then you need to read the introduction to the Protobuf library for your programming language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">protoc --cpp_out=. addressbook.proto &amp;&amp; g++ addressbook.pb.cc tut.cpp `pkg-config --cflags --libs protobuf` -s -o tut.lite.exe &amp;&amp; ./tut.lite.exe &gt; A</code> </pre> <br>  Delete or comment out the second line of the addressbook.proto file and execute the command: <br><br><pre> <code class="bash hljs">protoc --cpp_out=. addressbook.proto &amp;&amp; g++ addressbook.pb.cc tut.cpp `pkg-config --cflags --libs protobuf` -o tut.exe &amp;&amp; ./tut.exe &gt; B</code> </pre> <br>  After executing the above commands, we have two executable files tut.lite.exe and tut.exe, with LITE and the full build of the libprotobuf library, respectively.  Both programs do the same thing: a protobuf message is created, which is output to std :: cout.  We also have two binary files with the names A and B. The first is generated by the lite version, the second is the full version of the program.  Their content is identical.  In the screenshot below you can see the binary representation of this message and its textual appearance: <br><br><img src="https://habrastorage.org/files/2fd/1ef/1ec/2fd1ef1ecf0e4c12adff59c98f456468.png"><br><br>  Remove addressbook.proto and try to restore it. <br><br><h3>  Recovery of message scheme from Descriptor of executable data </h3><br>  Look at the contents of the adressbook.pb.cc file generated earlier by the protoc utility.  We should be interested in the protobuf_AddDesc_addressbook_2eproto function.  One of the first actions in it is to call the function :: google :: protobuf :: DescriptorPool :: InternalAddGeneratedFile, the first argument of which is the Descriptor protobuf message with information about the structure of the original messages. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... void protobuf_AddDesc_addressbook_2eproto() { static bool already_here = false; if (already_here) return; already_here = true; GOOGLE_PROTOBUF_VERIFY_VERSION; ::google::protobuf::DescriptorPool::InternalAddGeneratedFile( "\n\021addressbook.proto\022\010tutorial\"\332\001\n\006Person" "\022\014\n\004name\030\001 \002(\t\022\n\n\002id\030\002 \002(\005\022\r\n\005email\030\003 \001(" "\t\022+\n\005phone\030\004 \003(\0132\034.tutorial.Person.Phone" "Number\032M\n\013PhoneNumber\022\016\n\006number\030\001 \002(\t\022.\n" "\004type\030\002 \001(\0162\032.tutorial.Person.PhoneType:" "\004HOME\"+\n\tPhoneType\022\n\n\006MOBILE\020\000\022\010\n\004HOME\020\001" "\022\010\n\004WORK\020\002\"/\n\013AddressBook\022 \n\006person\030\001 \003(" "\0132\020.tutorial.Person", 299); ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile( "addressbook.proto", &amp;protobuf_RegisterTypes); Person::default_instance_ = new Person(); Person_PhoneNumber::default_instance_ = new Person_PhoneNumber(); AddressBook::default_instance_ = new AddressBook(); Person::default_instance_-&gt;InitAsDefaultInstance(); Person_PhoneNumber::default_instance_-&gt;InitAsDefaultInstance(); AddressBook::default_instance_-&gt;InitAsDefaultInstance(); ::google::protobuf::internal::OnShutdown(&amp;protobuf_ShutdownFile_addressbook_2eproto); } // ...</span></span></code> </pre> <br>  It contains information about listings, import lists, messages, names and data types of their fields, etc.  The format is not a secret and comes with the source code;  you can look at google / protobuf / descriptor.proto.  This data is used in reflection, for debug output of message content, etc. <br><br>  The protodec utility searches Descriptor data in a binary file and is able to save the recovered .proto files.  To do this, run the command: <br><br><pre> <code class="bash hljs">protodec --grab tut.exe</code> </pre> <br>  In response, we will see something like this: <br><br><img src="https://habrastorage.org/files/6d5/cdd/266/6d5cdd266229489db374c6a7909ef093.png"><br><br>  That is, in the end, we got almost the original source .proto file. <br><br><h3>  Recovery scheme from message bytes </h3><br>  If there is no access to the application (for example, it works somewhere on the server), then it will be problematic to get to the Descriptor data.  The same applies if the application is compiled with LITE optimization: reflection is not used, therefore, the Descriptor description of .proto files is not generated at the compilation stage, and therefore we will not be able to restore the original .proto files by the method mentioned earlier.  In this case, you can try to analyze the contents of protobuf messages.  I note that they must be 100% have the same structure (the root message must be the same for them).  We will need as many messages as possible;  the more data they contain, the better the result will be in the end. <br><br>  The protodec program can restore the schema of the specified protobuf message with its types loaded from a file.  To do this, run the command: <br><br><pre> <code class="bash hljs">protodec --schema A</code> </pre> <br><img src="https://habrastorage.org/files/841/093/b5d/841093b5d381482d9c2b795d98fa4d29.png"><br><br>  This output means that 3 messages were detected in this protobuf message (loaded from file A).  If we look at the original addressbook.proto, then the general is undoubtedly guessed: MSG1 is Person :: PhoneNumber, MSG2 is Person, and MSG3 is AddressBook.  I will describe the striking inconsistencies: <br><br><ol><li>  The MSG3.fld1 field must be repeated.  The problem here is that in the original message, in AddressBook.person there is only one element, and at the binary level it is impossible to distinguish the repeated field in this case.  If there were at least 2 elements in AddressBook.person, then it would be defined correctly.  That is why we need several messages of this scheme, with the maximum fullness; <br><br></li><li>  Some required fields must be optional.  This problem is also solved by analyzing a large number of messages, thanks to which one can understand where the required field should be, and where optional; <br><br></li><li>  The MSG2.fld2 field must be int32, and it is int64.  At the low level, in protobuf, all integer types (int32, int64, uint32, uint64, sint32, sint64, bool, enum) are stored as Varint.  Then you can understand from the context, whether the numbers in this field will be signed or unsigned, int64 is selected in order to save the maximum possible integer value for the programming language used. </li></ol><br>  Names, both fields and messages, are generated automatically, this metadata from the body of the protobuf message "get" is impossible, because  they are simply not there.  In this case, you can gradually rename messages and fields when their purpose becomes more or less clear from the context of the messages being examined.  Also, in the application itself, in the export list, you can sometimes find this information.  To do this, we need any utility that knows how to do this, for example, IDA.  Here, here we retrieved the names and order of the fields for the message tutorial :: Person, which has 4 fields: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f30/aab/84e/f30aab84eb5f4668acf82795ba087eb3.png"></div><br>  We do the same for the rest of the messages and as a result we get almost the original .proto file. <br><br><h3>  Check </h3><br>  As a result, we have approximately this .proto file: <br><br><div class="spoiler">  <b class="spoiler_title">tut2.proto</b> <div class="spoiler_text"><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">package</span></span> ProtodecMessages; <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PHONE { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string Number = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> int64 Type = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PERSON { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string Name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> int64 Id = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string Email = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> PHONE Phone = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ADDRESSBOOK { <span class="hljs-attribute"><span class="hljs-attribute">repeated</span></span> PERSON Person = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> </div></div><br>  We will write a small program to check that our restored schema can edit the original messages. <br><br><div class="spoiler">  <b class="spoiler_title">tut2.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; #include &lt;cassert&gt; #include "tut2.pb.h" int main() { GOOGLE_PROTOBUF_VERIFY_VERSION; //   protobuf   std::cin std::string data; ProtodecMessages::ADDRESSBOOK book; while (std::cin.peek() != EOF) data.push_back((char)std::cin.get()); //    ? assert(book.ParseFromString(data)); assert(book.person_size() &gt; 0); //   ProtodecMessages::PERSON * person = book.mutable_person(0); person-&gt;set_email("fake@name.com"); person-&gt;set_id(4321); //     std::cout data = book.SerializeAsString(); assert(!data.empty()); std::cout.write(&amp;data[0], data.size()); // Optional: Delete all global objects allocated by libprotobuf. google::protobuf::ShutdownProtobufLibrary(); }</span></span></span></span></code> </pre> </div></div><br>  Compile and run: <br><br><pre> <code class="bash hljs">protoc --cpp_out=. tut2.proto &amp;&amp; g++ tut2.pb.cc tut2.cpp `pkg-config --cflags --libs protobuf` -o tut2.exe</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a8c/aa9/247/a8caa924733a4a29823b8b0b49be0466.png"></div><br><h3>  References: </h3><br><ul><li>  <a href="https://developers.google.com/protocol-buffers/docs/cpptutorial">developers.google.com/protocol-buffers/docs/cpptutorial</a> </li><li>  <a href="https://developers.google.com/protocol-buffers/docs/encoding">developers.google.com/protocol-buffers/docs/encoding</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Protocol_Buffers">en.wikipedia.org/wiki/Protocol_Buffers</a> </li><li>  <a href="https://github.com/schdub/protodec">github.com/schdub/protodec</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/321790/">https://habr.com/ru/post/321790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321780/index.html">Offers and verticals in traffic arbitration</a></li>
<li><a href="../321782/index.html">Simple technology for classifying recognized pages of business documents based on the Template Matching method</a></li>
<li><a href="../321784/index.html">VR rendering and optimization</a></li>
<li><a href="../321786/index.html">Minimalism in game design: examples, tips and ideas. Part one</a></li>
<li><a href="../321788/index.html">From multichannel to omnicanality</a></li>
<li><a href="../321792/index.html">Test Pass Library</a></li>
<li><a href="../321796/index.html">Where do your ads live?</a></li>
<li><a href="../321798/index.html">Dynamic Shadow Tactics Detection</a></li>
<li><a href="../321800/index.html">Omnichannel: facilitating communication to customers and employees</a></li>
<li><a href="../321802/index.html">Dmitry Sorin, Senior Software Engineer at Atlassian, shared his impressions of five years of work at Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>