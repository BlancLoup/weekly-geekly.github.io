<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java cryptography</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article "Java Cryptography" by Jakob Jenkov. 


 This publication is a translation of the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java cryptography</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to your attention the translation of the article <a href="http://tutorials.jenkov.com/java-cryptography/index.html">"Java Cryptography"</a> by Jakob Jenkov. </p><br><p>  This publication is a translation of the first <a href="http://tutorials.jenkov.com/java-cryptography/index.html">Java Cryptography</a> article in a series of articles for beginners who want to learn the basics of cryptography in Java. </p><a name="habracut"></a><br><h2 id="oglavlenie">  Table of contents: </h2><br><ol><li>  Java Cryptography </li><li>  <a href="https://habr.com/ru/post/444814/">Java cipher</a> </li><li>  Java MessageDigest </li><li>  Java Mac </li><li>  Java Signature </li><li>  Java KeyPair </li><li>  Java KeyGenerator </li><li>  Java KeyPairGenerator </li><li>  Java KeyStore </li><li>  Java keytool </li><li>  Java Certificate </li><li>  Java CertificateFactory </li><li>  Java CertPath </li></ol><br><h1 id="java-cryptography">  Java Cryptography </h1><br><p>  <strong>The Java Cryptography API</strong> provides the ability to encrypt and decrypt data in java, as well as manage keys, signatures and authenticate (authenticate) messages, calculate cryptographic hashes, and more. </p><br><p>  This article explains the basics of how to use the Java Cryptography API to perform various tasks that require secure encryption. </p><br><p>  This article does not explain the basics of cryptographic theory.  You will have to look at this information somewhere else. </p><br><h2 id="rasshirenie-kriptografii-java">  Java cryptography extension </h2><br><p>  The Java cryptography API is provided by the so-called <strong>Java Cryptography Extension</strong> (JCE).  JCE has long been part of the Java platform.  Initially, JCE was separated from Java due to the fact that the United States had export restrictions on encryption technology.  Therefore, the most robust encryption algorithms were not included in the standard Java platform.  These more robust encryption algorithms can be used if your company is located in the USA, but in other cases you will have to use weaker algorithms or implement your own encryption algorithms and connect them to the JCE. </p><br><p>  Since 2017, the rules for exporting encryption algorithms to the United States have been significantly weakened and international encryption standards through Java JCE can be used in most parts of the world. </p><br><p>  Java cryptography architecture </p><br><p>  <strong>Java Cryptography Architecture (JCA)</strong> is the name of the internal cryptography API design in Java.  JCA is structured around several main classes and general purpose interfaces.  The real functionality of these interfaces is provided by the suppliers.  Thus, the Cipher class can be used to encrypt and decrypt some data, but the specific implementation of the cipher (encryption algorithm) depends on the particular provider used. </p><br><p>  You can also implement and connect your own providers, but you have to be careful with this.  Correctly implement encryption without security holes is difficult!  If you don‚Äôt know what you‚Äôre doing, it‚Äôs probably best for you to use the built-in Java provider or use a reliable provider such as Bouncy Castle. </p><br><h3 id="osnovnye-klassy-i-interfeysy">  Core Classes and Interfaces </h3><br><p>  The Java cryptography API consists of the following Java packages: </p><br><ul><li>  java.security </li><li>  java.security.cert </li><li>  java.security.spec </li><li>  java.security.interfaces </li><li>  javax.crypto </li><li>  javax.crypto.spec </li><li>  javax.crypto.interfaces </li></ul><br><p>  The main classes and interfaces of these packages are: </p><br><ul><li>  Provider </li><li>  SecureRandom </li><li>  Cipher </li><li>  MessageDigest </li><li>  Signature </li><li>  Mac </li><li>  AlgorithmParameters </li><li>  AlgorithmParameterGenerator </li><li>  Keyfactory </li><li>  SecretKeyFactory </li><li>  KeyPairGenerator </li><li>  KeyGenerator </li><li>  KeyAgreement </li><li>  KeyStore </li><li>  CertificateFactory </li><li>  CertPathBuilder </li><li>  CertPathValidator </li><li>  CertStore </li></ul><br><h3 id="provider-postavschik-kriptografii">  Provider (Cryptographic Provider) </h3><br><p>  The Provider class (java.security.Provider) is the central class in the Java crypto API.  In order to use the Java crypto API, you need to install a cryptographic provider.  The Java SDK comes with its own cryptographic provider.  Unless you explicitly install a cryptographic provider, the default provider will be used.  However, this cryptographic provider may not support the encryption algorithms you want to use.  Therefore, you may need to install your own cryptographic provider. </p><br><p>  One of the most popular cryptographic providers for the Java crypto API is called Bouncy Castle.  Here is an example where the BouncyCastleProvider is set up as a cryptographic provider: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.bouncycastle.jce.provider.BouncyCastleProvider; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.security.Security; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProviderExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Security.addProvider(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BouncyCastleProvider()); } }</code> </pre> <br><h3 id="cipher-shifr">  Cipher (Cipher) </h3><br><p>  The Cipher class (javax.crypto.Cipher) represents a cryptographic algorithm.  The cipher can be used to both encrypt and decrypt data.  The Cipher class is explained in more detail in the following sections, below is a brief description. </p><br><p>  Creating an instance of a cipher class that uses the AES encryption algorithm for internal use: </p><br><pre> <code class="java hljs">Cipher cipher = Cipher.getInstance(<span class="hljs-string"><span class="hljs-string">"AES/CBC/PKCS5Padding"</span></span>);</code> </pre> <br><p>  The <em>Cipher.getInstance (...)</em> method takes a string that determines which encryption algorithm to use, as well as some other algorithm parameters. <br>  In the example above: </p><br><ul><li>  AES - encryption algorithm </li><li>  CBC is the mode in which the AES algorithm can work. </li><li>  PKCS5Padding is how the AES algorithm should process the last bytes of data for encryption.  What exactly this means, look in the manual on cryptography in general, and not in this article. </li></ul><br><h4 id="inicializaciya-shifra">  Cipher Initialization </h4><br><p>  Before using a cipher instance, it must be initialized.  The cipher instance is initialized by calling the <em>init ()</em> method.  The <em>init ()</em> method takes two parameters: </p><br><ul><li>  Mode - Encryption / Decryption </li><li>  Key </li></ul><br><p>  The first parameter specifies whether the instance works with a cipher: encrypt or decrypt data.  The second parameter indicates which key they use to encrypt or decrypt data. </p><br><p>  Example: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); cipher.init(Cipher.ENCRYPT_MODE, key);</code> </pre><br><p>  Note that the key creation method in this example is not secure and should not be used in practice.  This article in the following sections will explain how to create keys more securely. </p><br><p>  To initialize a cipher instance to decrypt data, you must use Cipher.DECRYPT_MODE, for example: </p><br><pre> <code class="java hljs">cipher.init(Cipher.DECRYPT_MODE, key);</code> </pre> <br><h4 id="shifrovanie-ili-deshifrovanie-dannyh">  Encrypt or decrypt data </h4><br><p>  After initializing the cipher, you can start encrypting or decrypting the data by calling the <em>update ()</em> or <em>doFinal ()</em> methods.  The <em>update ()</em> method is used if you are encrypting or decrypting a piece of data.  The <em>doFinal ()</em> method is called when you encrypt the last piece of data, or if the data block that you pass to <em>doFinal ()</em> is a single data set for encryption. </p><br><p>  An example of data encryption using the <em>doFinal ()</em> method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] plainText = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] cipherText = cipher.doFinal(plainText);</code> </pre> <br><p>  To decrypt data, you must pass the encrypted text (data) to the <em>doFinal ()</em> or <em>doUpdate ()</em> method. </p><br><h3 id="keys-klyuchi">  Keys (Keys) </h3><br><p>  To encrypt or decrypt data, you need a key.  There are two types of keys depending on what type of encryption algorithm is used: </p><br><ul><li>  Symmetric keys </li><li>  Asymmetric keys </li></ul><br><p>  Symmetric keys are used for symmetric encryption algorithms.  Symmetric encryption algorithms use the same key for encryption and decryption. <br>  Asymmetric keys are used for asymmetric encryption algorithms.  Asymmetric encryption algorithms use one key for encryption, and another for decryption.  Public-key and private-key encryption algorithms are examples of asymmetric encryption algorithms. </p><br><p>  Somehow, the party that needs to decrypt the data must know the key necessary to decrypt the data.  If the decrypting party is not a party to encrypting the data, the two parties must agree on the key or exchange the key.  This is called key exchange. </p><br><h4 id="bezopasnost-klyucha">  Key security </h4><br><p>  Keys must be hard to guess so that an attacker cannot easily find the encryption key.  In the example from the previous section on the Cipher class, a very simple, hard-coded key was used.  In practice, this is not worth doing.  If the key of the parties is easy to guess, it will be easy for an attacker to decrypt the encrypted data and, possibly, create fake messages on its own.  It is important to make a key that is difficult to guess.  Thus, the key must consist of random bytes.  The more random bytes, the harder it is to guess, because there are more possible combinations. </p><br><h4 id="generaciya-klyucha">  Key generation </h4><br><p>  To generate random encryption keys, you can use the Java KeyGenerator class.  KeyGenerator will be described in more detail in the following chapters; here is a small example of its use here: </p><br><pre> <code class="java hljs">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"AES"</span></span>); SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyBitSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; keyGenerator.init(keyBitSize, secureRandom); SecretKey secretKey = keyGenerator.generateKey();</code> </pre> <br><p>  The resulting SecretKey instance can be passed to the <em>Cipher.init ()</em> method, for example: </p><br><pre> <code class="java hljs">cipher.init(Cipher.ENCRYPT_MODE, secretKey);</code> </pre> <br><h4 id="generaciya-pary-klyuchey">  Key pair generation </h4><br><p>  Asymmetric encryption algorithms use a key pair, consisting of a public key and a private key, to encrypt and decrypt data.  To create an asymmetric key pair, you can use KeyPairGenerator (java.security.KeyPairGenerator).  KeyPairGenerator will be described in more detail in the following chapters, below is a simple example of using Java KeyPairGenerator: </p><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair();</code> </pre> <br><h4 id="hranilische-klyuchey--key-store">  Key Store </h4><br><p>  Java KeyStore is a database that can contain keys.  Java KeyStore is represented by the KeyStore class (java.security.KeyStore).  The keystore can contain keys of the following types: </p><br><ul><li>  Private keys </li><li>  Public keys and certificates (Public keys + certificates) </li><li>  Secret keys </li></ul><br><p>  Private and public keys are used in asymmetric encryption.  The public key may have an associated certificate.  A certificate is a document proving the identity of a person, organization or device claiming ownership of a public key. </p><br><p>  The certificate is usually digitally signed by the verifier as evidence. <br>  Secret keys are used in symmetric encryption. The KeyStore class is quite complex, so it is described in more detail later in a separate chapter on Java KeyStore. </p><br><h4 id="instrument-upravleniya-klyuchami-keytool">  Key Management Tool (Keytool) </h4><br><p>  Java Keytool is a command line tool that can work with Java KeyStore files.  Keytool can generate key pairs to a KeyStore file, export certificates, and import certificates to KeyStore and some other functions.  Keytool comes with a Java installation.  Keytool is described in more detail later in a separate chapter on Java Keytool. </p><br><h3 id="daydzhest-soobscheniya-messagedigest">  Message Digest (MessageDigest) </h3><br><p>  When you receive encrypted data from the other side, can you be sure that no one has changed the encrypted data on the way to you? </p><br><p>  The usual solution is to compute the digest of the message from the data before encrypting it, and then encrypt both the data and the digest of the message and send it over the network.  Message digest is a hash value calculated from the message data.  If at least one byte changes in the encrypted data, the message digest calculated by the data will also change. </p><br><p>  When you receive the encrypted data, you decrypt it, compute the message digest from it, and compare the calculated message digest with the message digest sent along with the encrypted data.  If the two digest messages are the same, there is a high probability (but not 100%) that the data has not been changed. </p><br><p>  Java MessageDigest (java.security.MessageDigest) can be used to calculate message digests.  To create an instance of MessageDigest, the <em>MessageDigest.getInstance ()</em> method is called.  There are several different message digest algorithms.  You need to specify which algorithm you want to use when creating a MessageDigest instance.  Working with MessageDigest will be described in more detail in the Java chapter on MessageDigest. </p><br><h4 id="kratkoe-vvedenie-v-klass-messagedigest">  A brief introduction to the MessageDigest class: </h4><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>);</code> </pre> <br><p>  This example creates an instance of MessageDigest that uses the internal cryptographic hash algorithm SHA-256 to compute message digests. </p><br><p>  To compute a digest of some data, you call the <em>update ()</em> or <em>digest ()</em> method.  The <em>update ()</em> method can be called several times, and the message digest is updated inside the object.  When you send all the data you want to include in the message digest, you call <em>digest ()</em> and extract the message digest totals. </p><br><p>  An example of calling <em>update ()</em> several times followed by a call to <em>digest ()</em> : </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); messageDigest.update(data1); messageDigest.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest();</code> </pre> <br><p>  You can also call <em>digest ()</em> once, passing all the data to calculate the message digest.  Example: </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest(data1);</code> </pre> <br><h3 id="kod-autentifikacii-soobscheniya-mac">  Message Authentication Code (MAC) </h3><br><p>  The Mac Java class is used to create a MAC (Message Authentication Code) from a message.  The MAC is similar to message digest, but uses an additional key to encrypt message digest.  Only with both the original data and the key, you can check the MAC.  Thus, MAC is a more secure way to protect a data block from modification than message digest.  The Mac class is described in more detail in the Mac Java chapter, with a brief introduction below. </p><br><p>  A Java Java instance is created by calling the <em>Mac.getInstance ()</em> method, passing the name of the algorithm to use as a parameter.  Here's what it looks like: </p><br><pre> <code class="java hljs">Mac mac = Mac.getInstance(<span class="hljs-string"><span class="hljs-string">"HmacSHA256"</span></span>);</code> </pre> <br><p>  Before you create a MAC from data, you must initialize your Mac instance with the key.  Here is an example of initializing an instance of a Mac with a key: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> ,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); mac.init(key);</code> </pre> <br><p>  After initializing the Mac instance, you can calculate the MAC from the data by calling the <em>update ()</em> and <em>doFinal ()</em> methods.  If you have all the data to calculate the MAC, you can immediately call the <em>doFinal ()</em> method.  Here's what it looks like: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); mac.update(data); mac.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] macBytes = mac.doFinal();</code> </pre> <br><h3 id="podpis-signature">  Signature </h3><br><p>  The Signature class (java.security.Signature) is used to digitally sign data.  When the data is signed, a digital signature is created from this data.  Thus, the signature is separated from the data. </p><br><p>  A digital signature is created by creating a message digest (hash) from the data and encrypting that message digest using the private key of the device, person or organization that is supposed to sign the data.  The digest of the encrypted message is called a digital signature. </p><br><p>  To create a Signature instance, the <em>Signature.getInstance (...)</em> method is called: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>);</code> </pre> <br><h4 id="podpis-dannyh">  Data signature </h4><br><p>  To sign data, you must initialize the signature instance in signature mode by calling the initSign (...) method, passing the private key to sign the data.  An example of initializing a signature instance in signature mode: </p><br><pre> <code class="java hljs">signature.initSign(keyPair.getPrivate(), secureRandom);</code> </pre> <br><p>  After initializing the signature instance, you can use it to sign the data.  This is done by calling the update () method, passing the data for the signature as a parameter.  You can call the update () method several times to add data to create a signature.  After all the data has been transferred to the update () method, the sign () method is called to obtain a digital signature.  Here's what it looks like: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign();</code> </pre> <br><h4 id="proverka-podpisi">  Signature verification </h4><br><p>  To verify a signature, you need to initialize the signature instance in verification mode by calling the <em>initVerify (...)</em> method, passing the public key as a parameter to verify the signature.  An example of initialization of the signature instance in the scan mode looks like: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initVerify(keyPair.getPublic());</code> </pre> <br><p>  After initialization in verification mode, the data that is signed is transferred to the <em>update ()</em> method.  Calling the <em>verify ()</em> method returns <em>true</em> or <em>false</em> depending on whether the signature can be verified or not.  Here is the signature verification: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature2.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature);</code> </pre> <br><h4 id="polnyy-primer-podpisi-i-proverki">  Full sample signature and verification </h4><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair(); Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initSign(keyPair.getPrivate(), secureRandom); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign(); Signature signature2 = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature2.initVerify(keyPair.getPublic()); signature2.update(data); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature); System.out.println(<span class="hljs-string"><span class="hljs-string">"verified = "</span></span> + verified);</code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/444764/">https://habr.com/ru/post/444764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444750/index.html">The new version of Firefox blocks the automatic playback of media content.</a></li>
<li><a href="../444756/index.html">DARPA will develop a nuclear rocket engine</a></li>
<li><a href="../444758/index.html">Technical differences between BI systems (Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../444760/index.html">CNC machine from what was lying around in the garage</a></li>
<li><a href="../444762/index.html">CSTroN - a homemade monitor on a vintage CSTN-matrix with a VGA-input and control board on the FPGA</a></li>
<li><a href="../444766/index.html">Facebook employees had access to the passwords of Facebook and Instagram users.</a></li>
<li><a href="../444768/index.html">Decreased dependence on tagged data on generative-contention networks</a></li>
<li><a href="../444770/index.html">How we looked for data leakage in SimilarWeb</a></li>
<li><a href="../444774/index.html">Error with ru-RU locale migration to Google Chrome and how to get rid of it</a></li>
<li><a href="../444776/index.html">Do not be afraid to try, or How I became a programmer at an age far beyond 18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>