<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Schr√∂dinger's trusted download. Intel Boot Guard</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We suggest that you go down to a low level again and talk about the security of x86-compatible computer platform firmware. This time the main ingredie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Schr√∂dinger's trusted download. Intel Boot Guard</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/427/db4/031/427db403148c43f386cb653731c6438d.jpg"></div><br>  We suggest that you go down to a low level again and talk about the security of x86-compatible computer platform firmware.  This time the main ingredient of the research is Intel Boot Guard (not to be confused with Intel BIOS Guard!), A hardware-supported BIOS trusted boot technology that a computer system vendor can permanently turn on or off during the production phase.  Well, the research recipe is already familiar to us: thinly reverse-implement the implementation of this technology, describe its architecture, fill it with undocumented details, season to taste with attack vectors and mix.  Let's add some fire to the story of how for years a cloned error in the production of several vendors allows a potential attacker to use this technology to create a hidden rootkit in the system that is not deleted (even by the programmer). <br><br>  By the way, the article is based on the reports ‚ÄúGuarding rootkits: Intel BootGuard‚Äù from the <a href="https://2016.zeronights.ru/">2016 ZeroNights</a> conference and the 29th meeting of <a href="https://vk.com/defconrussia">DefCon Russia</a> (both presentations are <a href="https://github.com/flothrone/bootguard">here</a> ). <br><a name="habracut"></a><br><h2>  Firmware for Intel 64 computer platform </h2><br>  First, let's answer the question: what is the firmware of a modern computer platform with Intel 64 architecture?  Of course, UEFI BIOS.  But this answer will not be accurate.  Let's look at the drawing, which shows the desktop (laptop) version of this architecture. <br><br><img src="https://habrastorage.org/files/ff8/fc6/497/ff8fc64975be4cadbac085daf9ae100b.png"><br>  The basis is a bunch: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Processor (CPU, Central Processing Unit), which, in addition to the main cores, has a graphics core (not in all models) and a memory controller (IMC, Integrated Memory Controller); </li><li>  A chipset (PCH, Platform Controller Hub) containing various controllers for interacting with peripheral devices and controlling subsystems.  Among them is the notorious Intel Management Engine (ME), which also has firmware (Intel ME firmware). </li></ul><br>  Laptops, in addition to the above, assume the presence of a built-in controller (ACPI EC, Advanced Control and Power Interface Embedded Controller), which is responsible for the performance of the power subsystem, touchpad, keyboard, Fn-keys (screen brightness, sound volume, keyboard backlight, etc.). ) and other things.  And he also has his own firmware. <br><br>  So, the combination of the above firmware is the firmware of the computer platform (system firmware), which is stored on a shared SPI flash memory.  So that the users of this memory are not confused, where is whose, the contents of this memory is divided into the following regions (as shown in the figure): <br><br><ul><li>  UEFI BIOS; </li><li>  ACPI EC firmware (a separate region appeared from the Skylake processor microarchitecture (2015), but we have not yet seen in-the-wild examples of its use, so the firmware of the embedded controller is still included in the UEFI BIOS); </li><li>  Intel ME firmware; </li><li>  configuration (MAC address, etc.) of the integrated GbE network adapter (Gigabit Ethernet); </li><li>  Flash Descriptors (Flash Descriptors) - the main region of flash memory, which contains pointers to other regions, as well as permissions to access them. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/26e/10e/187/26e10e1874194234b17d474076d50666.png"></div><br>  Access control to regions (in accordance with the specified permissions) is handled by the SPI master bus - an SPI controller built into the chipset through which the memory is accessed.  If permissions are set to recommended (for security reasons) by Intel values, then each user of the SPI flash memory has full access (read / write) only to its region.  And the rest are either read-only or inaccessible.  A well-known fact: on many systems, the CPU has full access to the UEFI BIOS and GbE, read access only to flash descriptors, and access to the Intel ME region is not at all.  Why many, but not all?  What is recommended is optional.  More details will be discussed later in the article. <br><br><h3>  Mechanisms for protecting the firmware of a computer platform from modification </h3><br>  Obviously, the firmware of a computer platform should be protected from a possible compromise that would allow a potential attacker to gain a foothold in it (relive the OS updates / reinstallations), execute its code in the most privileged modes, etc.  And the separation of access to the regions of the SPI flash memory, of course, is not enough.  Therefore, to protect the firmware from modifications, various mechanisms are applied, specific to each environment. <br><br>  So, Intel ME firmware is signed to monitor integrity and authenticity, and is checked by the ME controller each time it is loaded into ME UMA memory.  This verification process has already been reviewed by us in one of the <a href="https://habrahabr.ru/company/dsec/blog/278549/">articles</a> on the Intel ME subsystem. <br><br>  And the ACPI EC firmware is usually checked for integrity only.  However, due to the fact that this binary is included in the UEFI BIOS, it almost always applies the same protection mechanisms that UEFI BIOS uses.  We will talk about them. <br><br>  These mechanisms can be divided into two categories. <br><br><h4>  Write protection in the UEFI BIOS region </h4><br><ol><li>  Physical protection of the contents of the SPI flash memory write-protect jumper; </li><li>  Protecting the projection of the UEFI BIOS region in the address space of the CPU using the PRx chipset registers; </li><li>  Block attempts to write to the UEFI BIOS region by generating and processing the corresponding SMI interrupt by setting the BIOS_WE / BLE and SMM_BWP bits in the chipset's registers; </li><li>  A more advanced option for such protection is Intel BIOS Guard (PFAT). </li></ol><br>  In addition to these mechanisms, vendors can develop and apply their own security measures (for example, signing capsules with UEFI BIOS updates). <br><br>  It is important to note that on a particular system (depending on the vendor), not all of the above protection mechanisms can be applied, they can not be applied at all, but they can be vulnerable implemented.  More information about these mechanisms and the situation with their implementation can be found in <a href="https://habrahabr.ru/post/266935/">this article</a> .  For those interested, we recommend that you familiarize yourself with the entire cycle of articles on security of the UEFI BIOS from <a href="https://habr.com/users/coderush/" class="user_link">CodeRush</a> . <br><br><h4>  UEFI BIOS authentication verification </h4><br>  When we talk about trusted boot technologies, the first thing that comes to mind is the Secure Boot.  However, architecturally it is designed to authenticate external components with respect to the UEFI BIOS (drivers, bootloaders, etc.), and not the firmware itself. <br><br>  Therefore, Intel in SoC-a with Bay Trail microarchitecture (2012) has implemented a hardware non-switchable Secure Boot (Verified Boot), which has nothing to do with the aforementioned Secure Boot technology.  Later (2013), this mechanism was improved and released under the name Intel Boot Guard for desktops with the Haswell microarchitecture. <br><br>  Before describing Intel Boot Guard, let us examine the runtime environments in the Intel 64 architecture, which, in combination, are the roots of trust for this trusted boot technology. <br><br><h3>  Intel CPU </h3><br>  Cap suggests that the processor is the main runtime environment in the Intel 64 architecture. Why is it the root of trust?  It turns out that this is what makes it possession of the following elements: <br><br><ul><li>  Microcode ROM is non-volatile, non-writable memory for microcode storage.  It is believed that the microcode is the implementation of the processor command system on the simplest instructions.  In the microcode, <a href="https://hi-news.ru/computers/intel-priznala-nalichie-kriticheskoj-nedorabotki-v-processorax-skylake.html">bugs</a> happen too.  So in the BIOS you can find binaries with microcode updates (they are superimposed at boot time, since ROM cannot be overwritten).  The contents of these binaries are encrypted, which significantly complicates the analysis (therefore, the specific content of the microcode is known only to those who develop it), and signed to control the integrity and authenticity; </li><li>  AES key to decrypt the contents of microcode updates; </li><li>  RSA public key hash that verifies the signature of microcode updates; </li><li>  RSA public key hash that verifies the signature of Intel's ACM (Authenticated Code Module) code modules that the CPU can run before the BIOS starts to execute (hello to microcode) or during its operation, when certain events occur. </li></ul><br><h3>  Intel ME </h3><br>  As many as <a href="https://habrahabr.ru/company/dsec/blog/278549/">two</a> <a href="https://habrahabr.ru/company/dsec/blog/282546/">articles</a> were devoted to this subsystem in our blog.  Recall that this executable environment is based on the microcontroller built into the chipset and is the most hidden and privileged in the system. <br><br>  Despite secrecy, Intel ME is also a root of trust because it has: <br><br><ul><li>  ME ROM - non-volatile, non-rewritable memory (update method is not provided), containing the start code, as well as the SHA256 RSA public key hash, which verifies the signature of the Intel ME firmware; </li><li>  AES key to store secret information; </li><li>  access to the integrated set of fyuzov (FPFs, Field Programmable Fuses) in the chipset for permanent storage of some information, including information set by the vendor of the computer system. </li></ul><br><h2>  Intel Boot Guard 1.x </h2><br>  A small disclaimer.  The version numbers of the Intel Boot Guard technology that we use in this article are conditional and may have nothing to do with the numbering that is used in Intel's internal documentation.  In addition, information provided here about the implementation of this technology was obtained during reverse engineering, and may contain inaccuracies compared with the specification for Intel Boot Guard, which is unlikely to ever be published. <br><br>  So, Intel Boot Guard (BG) is a hardware-supported verification technology authenticity UEFI BIOS.  Judging by its short description in [Platform Embedded Security Technology Revealed, head of Boot with Integrity, or Not Boot], it works like a chain of trusted downloads.  And the first link in it is the boot code (microcode) inside the CPU, which is triggered by the RESET event (not to be confused with the RESET vector in the BIOS!).  The CPU finds the code module (Intel BG startup ACM) developed and signed by Intel on the SPI flash memory, loads it into its cache, verifies (it was noted above that the CPU has a public key hash that verifies the ACM signature) and runs. <br><br><img src="https://habrastorage.org/files/9fb/0bc/20c/9fb0bc20cc0342e1b18421b30ed0f584.png"><br><br>  This code module is responsible for verifying the small starting part of the UEFI BIOS - Initial Boot Block (IBB), which, in turn, contains the functionality for verifying the main part of the UEFI BIOS.  Thus, Intel BG allows you to verify the authenticity of the BIOS before loading the OS (which can be performed under the supervision of the Secure Boot technology). <br><br>  Intel BG technology provides two modes of operation (and one does not interfere with the other, that is, both modes can be enabled on the system, and both can be turned off). <br><br><h3>  Measured boot </h3><br>  In the Measured Boot (MB) mode, each boot component (starting with the CPU boot ROM) ‚Äúmeasures‚Äù the next, using the capabilities of the TPM (Trusted Platform Module).  For those who do not know, we will explain. <br><br>  TPM has PCRs (Platform Configuration Registers) that record the result of a hash operation using the formula: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>M</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy=&quot;false&quot;>(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo>:</mo><mi>P</mi><mi>C</mi><mi>R</mi><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>P</mi><mi>C</mi><mi>R</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="51.446ex" height="2.66ex" viewBox="0 -832 22150.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-4D" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-65" x="1051" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="1518" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-73" x="2047" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-75" x="2517" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-72" x="3089" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-65" x="3541" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-28" x="4007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-64" x="4397" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="4920" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-74" x="5450" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="5811" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-29" x="6341" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-3A" x="7008" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-50" x="7564" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-43" x="8316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-52" x="9076" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-3D" x="10113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-48" x="11170" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="12058" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-73" x="12588" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-68" x="13057" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-28" x="13634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-50" x="14023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-43" x="14775" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-52" x="15535" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-7C" x="16295" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-48" x="16573" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="17462" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-73" x="17991" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-68" x="18461" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-28" x="19037" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-64" x="19427" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="19950" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-74" x="20480" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMATHI-61" x="20841" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-29" x="21371" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/dsec/blog/326556/&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiXQeOvZmuLVAM22E0iSth-x9rIkw#MJMAIN-29" x="21760" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>M</mi><mi>e</mi><mi>a</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mi>C</mi><mi>R</mi><mo>=</mo><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>P</mi><mi>C</mi><mi>R</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Measure (data): PCR = Hash (PCR | Hash (data)) </script></p><br><br>  Those.  the current PCR value depends on the previous one, while these registers are reset only during the system RESET. <br><br>  Thus, in the MB mode at some point in time, the PCRs reflect a unique (within the scope of the hashing operation) identifier of the code or data that was ‚Äúmeasured‚Äù.  PCR values ‚Äã‚Äãcan be used in some data encryption operations (TPM_Seal).  After that, their decryption (TPM_Unseal) will be possible only if the PCR values ‚Äã‚Äãdid not change as a result of the download (i.e., no ‚Äúmeasured‚Äù component was modified). <br><br><h3>  Verified Boot </h3><br>  The most terrible thing for those who want to modify the UEFI BIOS is the Verified Boot (VB) mode, in which each boot component cryptographically checks the integrity and authenticity of the next.  And in case of a verification error, one of the following occurs: <br><br><ul><li>  shutdown by timeout from 1 min to 30 min (so that the user has time to understand why his computer is not loaded, and, if possible, would try to restore the BIOS); </li><li>  immediate shutdown (so that the user does not have time to understand and, especially, do); </li><li>  continuation of work with a deadpan look (the case when there is no security, because there are more important things to do). </li></ul><br>  The choice of action depends on the specified Intel BG configuration (namely, the so-called enforcement policy), which is permanently recorded by the vendor of a computer platform in a specially designed storage - chipset fusions (FPFs).  More on this point will stop later. <br><br>  In addition to the configuration, the vendor generates two RSA 2048 keys and creates two data structures (shown in the figure): <br><br><ol><li>  The vendor root key manifest (KEYM, OEM Root Key Manifest), which puts the SVN (Security Version Number) of this manifest, the SHA256 hash of the next manifest's public key, the RSA public key (that is, the public part of the vendor's root key) to verify the signature of this manifest and signature itself; </li><li>  IBB Manifesto (IBBM, Initial Boot Block Manifest), which puts the SVN of this manifest, the SHA256 IBB hash, the public key to verify the signature of this manifest and the signature itself. </li></ol><br>  The SHA256 public key hash of the OEM Root Key is permanently written to the chipset fyuz (FPFs), as is the Intel BG configuration.  If the Intel BG configuration provides for the inclusion of this technology, then from this point on this system, update the BIOS (ie, be able to recalculate these manifests) can only the owner of the private part of the OEM Root Key,  vendor <br><br><img src="https://habrastorage.org/files/b36/0f5/7f4/b360f57f40bb4925a7b01b29d7f59209.png"><br><br>  When looking at the picture, doubts immediately arise about the need for such a long chain of verification ‚Äî one manifesto could be used.  Why complicate things? <br><br>  In fact, Intel thus provides the vendor with the opportunity to use different IBB keys for different product lines and one as the root.  If the private part of the IBB key (with which the second manifest is signed) is lost, the incident will affect only one product line and only until the vendor generates a new pair and includes the recalculated manifests in the next BIOS update. <br><br>  But if the root key (with which the first manifesto is signed) is compromised, it will not be possible to replace it, the revocation procedure is not provided because  The hash of the public part of this key is programmed into FPFs once and for all. <br><br><h3>  Intel Boot Guard Configuration </h3><br>  Now let's dwell on the Intel BG configuration and the process of its creation.  If you look at the corresponding tab in the GUI of the Flash Image Tool utility from the Intel System Tool Kit (STK), you will notice that the Intel BG configuration includes the hash of the public part of the vendor's root key, a couple of obscure values, and so on.  Intel BG profile. <br><br><img src="https://habrastorage.org/files/3fe/77b/323/3fe77b3233df4182bf284cb2a337bb9d.png"><br><br>  The structure of this profile is: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BG_PROFILE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Force_Boot_Guard_ACM : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Verified_Boot : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Measured_Boot : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Protect_BIOS_Environment : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Enforcement_Policy : <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 00b ‚Äì do nothing // 01b ‚Äì shutdown with timeout // 11b ‚Äì immediate shutdown unsigned long : 26; };</span></span></code> </pre> <br>  In general, the Intel BG configuration is very flexible.  Consider, for example, the flag Force_Boot_Guard_ACM.  When it is removed, in case the BG startup ACM module on the SPI flash memory is not found, there will be no trusted boot.  It will be untrusted. <br><br>  We have already mentioned above that the enforcement policy for the VB mode can be configured in such a way that, in the event of a verification error, an untrusted download will occur again. <br><br>  Leave such things to the discretion of vendors ... <br><br>  GUI utilities provide the following "ready" profiles: <br><table><tbody><tr><th>  room </th><th>  Mode </th><th>  Description </th></tr><tr><td>  0 </td><td>  No_FVME </td><td>  Intel BG technology turned off </td></tr><tr><td>  one </td><td>  VE </td><td>  VB mode is turned on, shutdown by timeout </td></tr><tr><td>  2 </td><td>  VME </td><td>  both modes are enabled (VB and MB), shutdown by timeout </td></tr><tr><td>  3 </td><td>  VM </td><td>  both modes are on, without shutting down the system </td></tr><tr><td>  four </td><td>  Fve </td><td>  VB mode on, off immediately </td></tr><tr><td>  five </td><td>  Fvme </td><td>  both modes are on, immediate shutdown </td></tr></tbody></table><br>  As already mentioned, the Intel BG configuration must be recorded once and for all by the system vendor in chipset fyuz (FPFs) - a small (according to unchecked information, only 256 bytes) hardware storage of information inside the chipset that can be programmed outside of Intel‚Äôs production capacity (therefore, it is <b>Field Programmable</b> Fuses). <br><br>  It is great for storing configurations because: <br><br><ul><li>  has one-time-programmable data storage area (just where the Intel BG configuration is written); </li><li>  only Intel ME can read and program it. </li></ul><br>  So, in order to set the configuration for Intel BG technology on a specific system, the vendor does the following during production: <br><br><ol><li>  Using the Flash Image Tool utility (from Intel STK) it creates a firmware image with a given Intel BG configuration in the form of variables within the Intel ME region (the so-called temporary mirror for FPFs); </li><li>  Using the Flash Programming Tool (from Intel STK), this image is written to the SPI flash memory of the system and closes the so-called.  manufacturing mode (in this case, the corresponding command is sent to Intel ME). </li></ol><br>  As a result of these operations, Intel ME commits to FPFs setpoints from a mirror for FPFs in the ME region, sets SPI flash descriptor resolutions to Intel recommended values ‚Äã‚Äã(described at the beginning of the article), and performs RESET systems. <br><br><h3>  Intel Boot Guard Implementation Analysis </h3><br>  In order to analyze the implementation of this technology with a specific example, we checked the following systems for signs of Intel BG technology: <br><table><tbody><tr><th>  System </th><th>  Note </th></tr><tr><td>  Gigabyte GA-H170-D3H </td><td>  Skylake, there is support </td></tr><tr><td>  Gigabyte GA-Q170-D3H </td><td>  Skylake, there is support </td></tr><tr><td>  Gigabyte GA-B150-HD3 </td><td>  Skylake, there is support </td></tr><tr><td>  MSI H170A Gaming Pro </td><td>  Skylake, no support </td></tr><tr><td>  Lenovo ThinkPad 460 </td><td>  Skylake, there is support, technology is included </td></tr><tr><td>  Lenovo Yoga 2 Pro </td><td>  Haswell, no support </td></tr><tr><td>  Lenovo U330p </td><td>  Haswell, no support </td></tr></tbody></table><br>  ‚ÄúSupport‚Äù refers to the presence of the Intel BG startup ACM module, the manifests mentioned above and the corresponding code in the BIOS, i.e.  implementation for analysis. <br><br>  As an example, take downloaded from the office.  Site vendor image SPI flash memory for Gigabyte GA-H170-D3H (version F4). <br><br><br><h4>  Intel CPU boot ROM </h4><br><br>  First of all, let's talk about the actions of the processor in case Intel BG technology is enabled. <br><br>  No samples of the decrypted microcode could be found, therefore, how the actions described below are implemented (in microcode or hardware) is an open question.  Nevertheless, the fact that modern Intel processors "know how" to produce these actions is a fact. <br><br>  After exiting the RESET state, the processor (into the address space of which the contents of the flash memory is already mapped) finds the FIT (Firmware Interface Table) table.  It is easy to find, the pointer to it is written at FFFF FFC0h. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e5c/b4b/bde/e5cb4bbdef034e0c98ff74d76e8811a7.PNG"></div><br>  In this example, at this address is the value of FFD6 9500h.  Turning to this address, the processor sees the FIT table, the contents of which are broken into records.  The first entry is the header of the following structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FIT_HEADER</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Tag[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '_FIT_ ' unsigned long NumEntries; // including FIT header entry unsigned short Version; // 1.0 unsigned char EntryType; // 0 unsigned char Checksum; };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d8/575/43a/4d857543a988455cb2b6e123019b4986.PNG"></div><br>  For some unknown reason, the cheksum is far from always counted in these tables (the field is left zero). <br><br>  The remaining entries indicate various binaries that need to be parsed / executed before the BIOS is executed, i.e.  before switching to legacy RESET vector (FFFF FFF0h).  The structure of each such record is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FIT_ENTRY</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> BaseAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> : <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> Version; <span class="hljs-comment"><span class="hljs-comment">// 1.0 unsigned char EntryType; unsigned char Checksum; };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/21d/7da/7a1/21d7da7a14a7471faf20a83abd636209.PNG"></div><br>  The EntryType field indicates the type of block that this entry points to.  We know several types: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FIT_ENTRY_TYPES { FIT_HEADER = <span class="hljs-number"><span class="hljs-number">0</span></span>, MICROCODE_UPDATE, BG_ACM, BIOS_INIT = <span class="hljs-number"><span class="hljs-number">7</span></span>, TPM_POLICY, BIOS_POLICY, TXT_POLICY, BG_KEYM, BG_IBBM };</code> </pre> <br>  Now it is obvious that one of the entries points to the location of the Intel BG startup ACM binary.  The header structure of this binary is typical for code modules developed by Intel (ACMs, microcode updates, Intel ME code sections, ...). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BG_ACM_HEADER</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ModuleType; <span class="hljs-comment"><span class="hljs-comment">// 2 unsigned short ModuleSubType; // 3 unsigned long HeaderLength; // in dwords unsigned long : 32; unsigned long : 32; unsigned long ModuleVendor; // 8086h unsigned long Date; // in BCD format unsigned long TotalSize; // in dwords unsigned long unknown1[6]; unsigned long EntryPoint; unsigned long unknown2[16]; unsigned long RsaKeySize; // in dwords unsigned long ScratchSize; // in dwords unsigned char RsaPubMod[256]; unsigned long RsaPubExp; unsigned char RsaSig[256]; };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/773/782/778/773782778bf44551b50edc7538da110f.PNG"></div><br>  The processor loads this binary into its cache, verifies and launches it. <br><br><h4>  Intel BG startup ACM </h4><br>  As a result of the analysis of this ACM, it became clear that he is doing the following: <br><br><ul><li>  Receives Intel BG configuration from Intel ME, recorded on chipset fusions (FPFs); </li><li>  finds KEYM and IBBM manifests, verifies them. </li></ul><br>  To find these manifests, ACM also uses the FIT table, which has two types of records to point to these structures (see FIT_ENTRY_TYPES above). <br><br>  Let us dwell on the manifestos.  In the structure of the first manifest, we see several obscure constants, the public key hash from the second manifest, and the OEM Root Key public key with the signature in the form of a nested structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KEY_MANIFEST</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Tag[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '__KEYM__' unsigned char : 8; // 10h unsigned char : 8; // 10h unsigned char : 8; // 0 unsigned char : 8; // 1 unsigned short : 16; // 0Bh unsigned short : 16; // 20h == hash size? unsigned char IbbmKeyHash[32]; // SHA256 of an IBBM public key BG_RSA_ENTRY OemRootKey; }; typedef struct BG_RSA_ENTRY { unsigned char : 8; // 10h unsigned short : 16; // 1 unsigned char : 8; // 10h unsigned short RsaPubKeySize; // 800h unsigned long RsaPubExp; unsigned char RsaPubKey[256]; unsigned short : 16; // 14 unsigned char : 8; // 10h unsigned short RsaSigSize; // 800h unsigned short : 16; // 0Bh unsigned char RsaSig[256]; };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/4dd/133/431/4dd13343105c4408a3a2340fc3374a6b.PNG"></div><br>  To verify the public key of the OEM Root Key, we recall the SHA256 hash from fyuzov, which at this moment has already been received from Intel ME, is used. <br><br>  We turn to the second manifest.  It consists of three structures: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBB_MANIFEST</span></span></span><span class="hljs-class"> {</span></span> ACBP Acbp; <span class="hljs-comment"><span class="hljs-comment">// Boot policies IBBS Ibbs; // IBB description IBB_DESCRIPTORS[]; PMSG Pmsg; // IBBM signature };</span></span></code> </pre> <br>  In the first - some constants: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ACBP</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Tag[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '__ACBP__' unsigned char : 8; // 10h unsigned char : 8; // 1 unsigned char : 8; // 10h unsigned char : 8; // 0 unsigned short : 16; // x &amp; F0h = 0 unsigned short : 16; // 0 &lt; x &lt;= 400h };</span></span></code> </pre> <br>  The second contains the SHA256 hash of IBB and the number of descriptors that describe the contents of IBB (that is, what the hash is considered to be from): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBBS</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Tag[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '__IBBS__' unsigned char : 8; // 10h unsigned char : 8; // 0 unsigned char : 8; // 0 unsigned char : 8; // x &lt;= 0Fh unsigned long : 32; // x &amp; FFFFFFF8h = 0 unsigned long Unknown[20]; unsigned short : 16; // 0Bh unsigned short : 16; // 20h == hash size ? unsigned char IbbHash[32]; // SHA256 of an IBB unsigned char NumIbbDescriptors; };</span></span></code> </pre> <br>  IBB descriptors follow this structure, one after the other.  Their contents have the following format: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBB_DESCRIPTOR</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> : <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> BaseAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Size; };</code> </pre> <br>  Everything is simple: each descriptor contains the address / size of the IBB chunk.  Thus, the concatenation of the blocks pointed to by these descriptors (in the order of the descriptors themselves) is IBB.  And, as a rule, IBB is a combination of all modules of the SEC and PEI phases. <br><br>  The second manifest completes the structure containing the IBB public key (verified by the SHA256 hash from the first manifest) and the signature of this manifest: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PMSG</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Tag[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '__PMSG__' unsigned char : 8; // 10h BG_RSA_ENTRY IbbKey; };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/0ac/ad9/d23/0acad9d2397f447d8d31b590e9385175.PNG"></div><br>  So, even before the UEFI BIOS starts to run, the processor will launch ACM, which will verify the authenticity of the contents of the partitions with the SEC and PEI phase codes.  Next, the processor exits the ACM, proceeds along the RESET vector and starts executing the BIOS. <br><br>  A verified PEI partition must contain a module that checks the remaining BIOS (DXE code).  This module is already developing IBV (Independent BIOS Vendor) or the system vendor itself.  Since  caught at our disposal and having Intel BG support, only Lenovo and Gigabyte systems turned out to be, consider the code extracted from these systems. <br><br><h4>  UEFI BIOS module LenovoVerifiedBootPei </h4><br>  In the case of Lenovo, this turned out to be the LenovoVerifiedBootPei {B9F2AC77-54C7-4075-B42E-C36325A9468D} module developed by Lenovo. <br><br>  His job is to search (by GUID) hash tables for DXE and DXE verification. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EFI_PEI_SERVICES-&gt;GetBootMode() != BOOT_ON_S3_RESUME) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindHashTable()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EFI_NOT_FOUND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!VerifyDxe()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EFI_SECURITY_VIOLATION; }</code> </pre> <br>  The hash table {389CC6F2-1EA8-467B-AB8A-78E769AE2A15} has the following format: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HASH_TABLE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Tag[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// '$HASHTBL' unsigned long NumDxeDescriptors; DXE_DESCRIPTORS[]; };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DXE_DESCRIPTOR</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> BlockHash[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// SHA256 unsigned long Offset; unsigned long Size; };</span></span></code> </pre> <br><h4>  UEFI BIOS module BootGuardPei </h4><br>  In the case of Gigabyte, this turned out to be the BootGuardPei {B41956E1-7CA2-42DB-9562-168389F0F066} module developed by AMI, therefore, present in any AMI BIOS with Intel BG support. <br><br>  Its algorithm works somewhat differently, however, comes down to the same: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bootMode = EFI_PEI_SERVICES-&gt;GetBootMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bootMode != BOOT_ON_S3_RESUME &amp;&amp; bootMode != BOOT_ON_FLASH_UPDATE &amp;&amp; bootMode != BOOT_IN_RECOVERY_MODE) { HOB* h = CreateHob(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindHashTable()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EFI_NOT_FOUND; WriteHob(&amp;h, VerifyDxe()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br>  The hash table {389CC6F2-1EA8-467B-AB8A-78E769AE2A15}, which he is looking for, has the following format: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> HASH_TABLE DXE_DESCRIPTORS[]; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DXE_DESCRIPTOR</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> BlockHash[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// SHA256 unsigned long BaseAddress; unsigned long Size; };</span></span></code> </pre> <br><h2>  Intel Boot Guard 2.x </h2><br>  Let us briefly describe another implementation of Intel Boot Guard, which was found in a newer Intel SoC-based system with Apollo Lake micro-architecture - ASRock J4205-IT. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Although this version will be used only in SoCs (new systems with Kaby Lake microarchitecture continue to use Intel Boot Guard 1.x), it is of great interest in exploring the new architecture for platforms on the Intel SoC, in which tangible changes have occurred, for example : </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the BIOS and Intel ME regions (or rather Intel TXE, according to the terminology for the Intel SoC) are now one IFWI region; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> even though Intel BG was enabled on the platform, such structures as FIT, KEYM, IBBM were not found in flash memory; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in addition to TXE and ISH cores (x86), a third core was added to the chipset (again ARC, by the way) - PMC (Power Management Controller), connected with the maintenance of the power subsystem and performance monitoring. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/28c/489/8fb/28c4898fbaf6481f860ce455be952899.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The content of the new IFWI region is a set of the following modules: </font></font><br><table><tbody><tr><th>  Bias </th><th>  Name </th><th>  Description </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0000 2000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SMIP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some kind of platform configuration, signed by the vendor </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0000 6000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RBEP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel TXE, x86 firmware code section, signed by Intel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0001 0000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PMCP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel PMC firmware code section, ARC, signed by Intel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0002 0000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FTPR </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel TXE, x86 firmware code section, signed by Intel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0007 B000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ucode </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> firmware updates for CPU, signed by Intel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0008 0000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IBBP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UEFI BIOS, SEC / PEI, x86 phases, signed by vendor </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0021 8000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ISHC </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel ISH firmware code section, x86, signed by vendor </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0025 8000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nftp </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intel TXE, x86 firmware code section, signed by Intel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0036 1000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IUNP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unknown </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0038 1000h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OBBP </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UEFI BIOS, DXE phase, x86, not signed </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When analyzing the TXE firmware, it became obvious that after RESET, TXE keeps the processor in this state until it prepares the basic contents of the address space for the CPU (FIT, ACM, RESET vector ...). </font><font style="vertical-align: inherit;">Moreover, TXE places this data in its SRAM, after which it temporarily grants the processor access there and ‚Äúreleases‚Äù it from the RESET.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guarding rootkits </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, now move on to the "hot." </font><font style="vertical-align: inherit;">Once we discovered that on many systems, SPI flash descriptors have permission to access SPI flash memory regions so that all users of this memory can write and read any region.</font></font> Those.  no way. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After checking with the MEinfo utility (from Intel STK), we saw that the manufacturing mode on these systems is not closed, therefore, the chipset fusions (FPFs) are left in an undefined state. </font><font style="vertical-align: inherit;">Yes, Intel BG in such cases is neither turned on nor turned off. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are talking about the following systems (with regards to Intel BG and what will be described later in the article, we will talk about systems with a Haswell microarchitecture and above):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all Gigabyte products; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all MSI products; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21 models of Lenovo laptops and 4 models of Lenovo servers. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, we reported the discovery to these vendors, as well as to Intel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adequate reaction followed only from </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lenovo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which recognized the problem and </font></font><a href="https://support.lenovo.com/ru/en/solutions/len_9903"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">released the patch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gigabyte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seemed to accept the information about the vulnerability, but did not comment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Communication with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> didn‚Äôt stop at our request to send in our open PGP key (to send them security advisory in encrypted form). They stated that ‚Äúthey are a hardware manufacturer and do not manufacture PGP keys‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But more to the point. Since fyuzy left in an unspecified state, the user (or an attacker) can program them yourself (the most difficult thing is to </font></font><a href="http://www.win-raid.com/t596f39-Intel-Management-Engine-Drivers-Firmware-amp-System-Tools.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find the Intel STK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">This requires the following steps. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boot into the Windows OS (in general, the actions described below can be done from under Linux, if you develop an analogue of the Intel STK under the desired OS). </font><font style="vertical-align: inherit;">Using the MEinfo utility, make sure that the fyuza on this system is not programmed.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/69e/7bc/571/69e7bc57175a46e49d2fd61c536f8b15.PNG"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Read the contents of the flash memory using the Flash Programming Tool.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a1d/aa4/921/a1daa492115b4b88a9c3c6c6d72f1dc8.PNG"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Open the read image using any UEFI BIOS editing tool, make the necessary changes (implement a rootkit, for example), create / edit existing KEYM and IBBM structures in the ME region.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dbf/156/645/dbf1566454b3484f8b24d19d87cf1e46.PNG"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/036/a33/1d6/036a331d67c8431eb749faa6da8fd4c8.PNG"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The picture shows the public part of the RSA key, the hash of which will be programmed into the chipset fyuzas along with the rest of the Intel BG configuration. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using the Flash Image Tool to build a new firmware image (setting the Intel BG configuration).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/328/fe6/dba/328fe6dba187429bae66ceb8fd40f6f3.PNG"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Write the new image to the flash memory using the Flash Programming Tool, verify with the MEinfo that the ME region now contains the Intel BG configuration.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/70e/9e7/86f/70e9e786f39c4bb8aa0b03c60c206f33.PNG"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using the Flash Programming Tool, close the manufacturing mode.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f76/976/657/f76976657b5143a288555c135302a055.PNG"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The system will reboot, after which with MEinfo you can make sure that the FPFs are now programmed.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/078/dfb/aaa/078dfbaaa58b4304be67243c1ac7ad79.PNG"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These actions </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will permanently</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enable Intel BG on this system. </font><font style="vertical-align: inherit;">You will not be able to cancel the action, which means:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only the owner of the private part of the root key (that is, the one who turned on Intel BG) will be able to update the UEFI BIOS on this system; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you return the original firmware to this system, for example, using a programmer, it will not even turn on (consequence of enforcement policy in case of verification error); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To get rid of such a UEFI BIOS, you need to replace the chipset with the programmed FPFs with a ‚Äúclean‚Äù one (i.e., re-solder the chipset, if you have access to an infrared soldering station with a car price, or just replace the motherboard). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To understand what such a rootkit can do, you need to evaluate what makes it possible to execute your code in the UEFI BIOS environment. </font><font style="vertical-align: inherit;">Say, in the most privileged processor mode, SMM. </font><font style="vertical-align: inherit;">Such a rootkit can have the following properties:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> run in parallel with the OS (you can set up processing by generating an SMI interrupt, which will be triggered by a timer); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have all the advantages of being in SMM mode (full access to the contents of RAM and hardware resources, secrecy from the OS); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rootkit's program code can be encrypted and decrypted when launched in SMM mode. </font><font style="vertical-align: inherit;">As a key for encryption, you can use any data that is available only in SMM mode. </font><font style="vertical-align: inherit;">For example, a hash from a set of addresses in SMRAM. </font><font style="vertical-align: inherit;">To get this key, you need to get into the SMM. </font><font style="vertical-align: inherit;">And this can be done in two ways. </font><font style="vertical-align: inherit;">Find the RCE in the SMM code and exploit it, or add your own SMM module to the BIOS, which is impossible, since we have enabled Boot Guard.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thus, this vulnerability allows an attacker to: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> create a hidden, undetectable rootkit of unknown purpose in the system; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> execute your code on one of the chipset cores inside the Intel SoC, namely, on Intel ISH (take a close look at the picture). </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/64e/24e/052/64e24e0522194897a618c1b3b049191e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7f3/72f/6c7/7f372f6c73f04c6296bd9f67564fbb3e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Although the capabilities of the Intel ISH subsystem have not yet been studied, it seems to be an interesting attack vector against Intel ME. </font></font><br><br><h2>  findings </h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The study provided a technical description of the operation of the Intel Boot Guard technology. </font><font style="vertical-align: inherit;">Minus a couple of secrets in the Intel-ovskoy model of security through obscurity.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An attack scenario is presented that allows you to create a non-removable rootkit in the system. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We saw that modern Intel processors are able to execute a lot of proprietary code even before the BIOS starts working. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Platforms with Intel 64 architecture are becoming less suitable for running free software: hardware verification, an increasing number of proprietary technologies and subsystems (three cores in the SoC chipset: x86 ME, x86 ISH and ARC PMC). </font></font></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mitigations </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vendors who intentionally leave manufacturing mode open should definitely close it. </font><font style="vertical-align: inherit;">So far, only eyes are closing and the new Kaby Lake systems show this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Users can turn off Intel BG themselves on their systems (which are affected by the described vulnerability) by running the Flash Programming Tool with the -closemnf option. </font><font style="vertical-align: inherit;">Previously, you should make sure (with the help of MEinfo) that the Intel BG configuration in the ME region provides for precisely turning off this technology after programming in FPFs.</font></font></div><p>Source: <a href="https://habr.com/ru/post/326556/">https://habr.com/ru/post/326556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326544/index.html">Tim Berners-Lee: Modern Internet should be decentralized and protected by encryption</a></li>
<li><a href="../326546/index.html">How to make the most? Five key points of an effective site</a></li>
<li><a href="../326550/index.html">How we made a completely new KOMPAS-3D: History in seven chapters ‚Üí part 1</a></li>
<li><a href="../326552/index.html">An article about static code analysis for managers that should not be read by programmers.</a></li>
<li><a href="../326554/index.html">Security Week 15: Leaky Modem in Huawei, VirusTotal as a data breach channel, Microsoft patches from Dridex</a></li>
<li><a href="../326564/index.html">Project generator</a></li>
<li><a href="../326566/index.html">Interesting prioritization of voice traffic in Telegram</a></li>
<li><a href="../326568/index.html">Autonumber in four languages. Part 1</a></li>
<li><a href="../326570/index.html">How to talk with artificial intelligence?</a></li>
<li><a href="../326572/index.html">Creating a single-player game: from idea to prototype</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>