<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Motion planning: visibility graph, road maps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day everyone. In this article I would like to tell you about a couple of algorithms related to computational geometry, which are currently widely...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Motion planning: visibility graph, road maps</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3db/997/e11/3db997e11960ec0e29fc65bef670ee5d.png"><br>  Good day everyone.  In this article I would like to tell you about a couple of algorithms related to computational geometry, which are currently widely used in game development.  If you at least once programmed a game in which there is a character (s) moving in a location, you had to solve the task of finding a path.  On one of the approaches to solving this problem and I want to tell. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  Let a set of non-intersecting polygons of P - polygonal obstacles be given.  Let there be an agent moving in the same plane - it is represented by a point.  Let start point s and end point f be given.  We need to build the shortest route from point s to point f, while we assume that the agent may be on the border of the obstacle, but not inside it. <br><br><h4>  Decision </h4><br><h5>  Optimal way </h5><br>  It can be proved that the optimal path is a piecewise linear broken line whose vertices coincide with the vertices of the obstacles. <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  <b>Part 1. The optimal path is a piecewise linear broken line.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Suppose that the shortest path T is not a piecewise linear broken line.  In this case, on the path T, there exists a point p that does not belong to any direct segment of T (Figure 1).  This means that there is an Œµ-neighborhood of the point p (Figure 2) into which no obstacle falls.  In this case, the subtrail T <sub>Œµ</sub> , which is inside the Œµ-neighborhood, can be shortened along a chord, connecting the intersection points of the Œµ-neighborhood with the path T. Since part of the path can be reduced, this means that the whole path can be reduced, and therefore the assumption is incorrect.  Path T is a piecewise linear broken line. <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/f8c/c45/daf/f8cc45daf856d8be956f6fac39d5a752.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/afb/909/63b/afb90963b7543d5765503b8ff7929459.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/dc6/698/75f/dc669875ffcfcda0b85287dda58fe993.png"></td></tr><tr><td><h6>  Figure 1. Point p on path T </h6></td><td><h6>  Figure 2. The Œµ-neighborhood of the point p </h6></td><td><h6>  Figure 3. Chord, which is the shortest path </h6></td></tr></tbody></table><br><br>  <b>Part 2. The tops of the path coincide with the tops of the obstacles.</b> <br>  Suppose now that the vertices of the path T do not coincide with the vertices of the obstacle polygons.  Consider the vertex v of the path T. The vertex cannot lie inside the free space, because otherwise, using a similar approach, we would find a shorter path along the chord in the Œµ-neighborhood of the vertex v (Figure 4).  Therefore, the vertex v must lie on the boundaries of the obstacles (at their vertices or on the edges).  But the vertex cannot lie on the edges either, since (again we consider the Œµ-neighborhood), we can cut along the chord (Figure 5). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/f31/1ee/c07/f311eec07f6db317b5b262d0ef296af1.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/fcb/cf5/88e/fcbcf588e74ebe4c6697492ec6d473fd.png"></td></tr><tr><td><h6>  Figure 4. Œµ-neighborhood of the top of the path lying in a free space </h6></td><td><h6>  Figure 5. Œµ-neighborhood of the top of the path lying on the edge </h6></td></tr></tbody></table><br><br>  The above means that the vertices of the piecewise linear path T must be located at the vertices of the obstacles-polygons. <br></div></div><br><br><h5>  Graph of visibility </h5><br>  We will call two points mutually visible if the segment connecting them does not contain internal points of obstacles-polygons. <br>  To build the shortest path is used visibility graph.  The vertices of the graph are the vertices of the obstacles-polygons.  The edges are connected only mutually visible vertices of the graph. <br><img src="https://habrastorage.org/getpro/habr/post_images/ee4/694/194/ee46941940dd1adbe9c6f115a6ebb6e7.png"><br><h6>  Figure 6. Example of a visibility graph. </h6><br><br>  Suppose we have built the visibility graph VG.  Add to the graph VG the vertices s and f, as well as the edges connecting them with all the visible vertices of them.  We obtain the extended graph VG <sup>+</sup> .  We will only need to find the shortest path from the vertex s to the vertex f in the graph VG <sup>+</sup> .  This can be done by applying <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">the Dijkstra algorithm</a> .  I will not talk in detail about it, because on the Internet there are a huge variety of articles, including on <a href="http://habrahabr.ru/post/111361/">Habr√©</a> .  It remains only to solve the problem of constructing the graph of visibility. <br><br><h5>  Visibility graph construction: naive algorithm </h5><br>  We will iterate over all pairs of vertices in the VG <sup>+</sup> graph and check for each of them whether the segment connecting the vertices of the obstacle edge does not intersect.  It is easy to see that the complexity of such an algorithm is O (n <sup>3</sup> ), since we have n <sup>2</sup> pairs of vertices and O (n) edges. <br><br><h5>  Construction of visibility graph for O (n <sup>2</sup> log (n)) </h5><br>  Let's try to build a graph of visibility a little faster.  For each vertex, we find all the vertices visible from it using the plane sweep method.  We need to solve the following problem: a set of segments (obstacle edges) and a point p are given on the plane.  Find all the ends of the segments visible from point p.  We will sweep the plane with a rotating beam starting at the point p (Figure 7).  The status of a sweeping straight line will be the segments that intersect it, ordered in increasing distance from the point p to the intersection point.  The event points will be the ends of the segments. <br><img src="https://habrastorage.org/getpro/habr/post_images/fed/b8f/1c1/fedb8f1c1709a0a779089da6ecf964f1.png"><br><h6>  Figure 7. Observing a plane by a rotating beam. </h6><br><br>  Ordered by angle relative to the axis passing through point p vertices will be stored in the event queue.  The status initialization takes O (nlog (n)) time, the event queue initialization also takes O (nlog (n)) time.  The total running time of the sweep algorithm is O (nlog (n)), thus, applying the algorithm for each vertex of the graph, we obtain the visibility graph in a time of order O (n <sup>2</sup> log (n)). <br>  More formally.  Let the number of edges of the set of non-intersecting polygons-obstruction be n.  In the spoilers, I will give the code in a pseudo-language, most similar to Java. <br><br><div class="spoiler">  <b class="spoiler_title">Building visibility graph</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> G </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildVisibilityGraph</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Set&lt;Segment&gt; segments)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  .        .   - . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> G visibilityGraph = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> G(getVertices(segments)); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Vertex v : visibilityGraph.getVertices()) { <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;Vertex&gt; visibleVertices = getVisibleVertices(v, segments); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Vertex w : visibleVertices) visibilityGraph.addEdge(v, w); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibilityGraph; }</code> </pre> </div></div><br><br>  The buildVisibilityGraph function takes as input a set of segments ‚Äî the edges of the obstacle polygons and returns the constructed visibility graph.  Explanations here, it seems to me, are not required.  Consider the pseudo-code of the getVisibleVertices function. <br><br><div class="spoiler">  <b class="spoiler_title">Listing all visible vertices</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Set&lt;Vertex&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVisibleVertices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vertex v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Set&lt;Segment&gt; segments)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    ( )  ,   pw ( w -  )   ,    v */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SortedSet&lt;Vertex&gt; sortedVertices = sortSegmentsVertices(v, segments); <span class="hljs-comment"><span class="hljs-comment">/*  I -  ,   v.   ,                   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BST&lt;Segment&gt; intersectedSegments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BST&lt;Segment&gt;(v, segments); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;Vertex&gt; visibleVertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;Vertex&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Vertex w : sortedVertices) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isVertexVisible(v, w, intersectedSegments)) visibleVertices.add(w); <span class="hljs-comment"><span class="hljs-comment">/*      ,   w       ( vw),  ,    w */</span></span> intersectedSegments.add(getIncidentSegments(v, w, Position.RightOf)); <span class="hljs-comment"><span class="hljs-comment">/*      ,   w       ( vw),  ,    w */</span></span> intersecedSegments.remove(getIncidentSegments(v, w, Position.LeftOf)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibleVertices; }</code> </pre></div></div><br><br>  So, the first thing vertices w ‚àà W are sorted by the angle between the ray vw and the vertical semi-axis passing through v.  This sorting is done in O (nlog (n)), for example, by merging sorting.  Then the set of visible vertices is initialized (by default, such a set is empty).  Next begins sweeping the plane.  In the sort order of the vertices, each of them is checked: is the vertex w visible from the vertex v.  Since such a check means the presence of intersections that are stored in a balanced tree, it can be performed in O (log (n)).  If the vertex is visible, you need to add it to the list of visible vertices.  And finally, regardless of the visibility of the vertex, it is necessary to change the status of the sweeping line.  To do this, for the current vertex w, you must remove from the list of current intersections all edges (segments) that end at this vertex (lie to the left of the line vw) and add all edges (segments) that start at it (lie to the right of the line vw) . <br>  Consider Figures 8-10: <br><div class="spoiler">  <b class="spoiler_title">Figures 8-10</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/3f9/845/935/3f9845935564a73eda464bd51cc619a2.png"><br><h6>  Figure 8. Step 1. Updating the status of a sweeping straight. </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/bcb/7e0/dd6bcb7e0b33d469770278286ce0fb35.png"><br><h6>  Figure 9. Step 2. Updating the status of a sweeping straight. </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/d43/9b3/73a/d439b373a4e119c572c973b67d71cf48.png"><br><h6>  Figure 10. Step 3. Updating the status of a sweeping straight. </h6><br></div></div><br>  So, in the first step (ray vw <sub>1</sub> ), two segments w <sub>1</sub> w <sub>5</sub> and w <sub>1</sub> w <sub>2</sub> are added to the tree, since they lie to the right of the ray vw <sub>1</sub> .  The status of the sweeping line is marked in orange. <br>  In the second step (the second vertex in the list is the vertex w <sub>3</sub> ), two more edges are added to the status: w <sub>3</sub> w <sub>2</sub> and w <sub>3</sub> w <sub>4</sub> .  Now in the status are 4 edges.  Finally, at the third step (vertex w <sub>2</sub> ), 2 edges are removed from the status: w <sub>3</sub> w <sub>2</sub> and w <sub>1</sub> w <sub>2</sub> . <br><br>  Ultimately, you should look at the function of checking the visibility of the vertex. <br><div class="spoiler">  <b class="spoiler_title">Vertex visibility function</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isVisible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vertex v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vertex w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BST&lt;Vertex&gt; intersections)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Segment currentSegment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Segment(v, w); <span class="hljs-comment"><span class="hljs-comment">/*  vw    ,   w,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intersects(currentSegment, w.getSegments()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ( )    vw. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentSegment.contains(w.getPreviousVertex())) { <span class="hljs-comment"><span class="hljs-comment">/*   ,  ,   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!v.getPreviousVertex().isVisible()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !intersections.hasIntersectionsWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Segment(w.getPrevious(), w)); } <span class="hljs-comment"><span class="hljs-comment">/*         (    vw    ) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections.intersectWithLeftMost(currentSegment); }</code> </pre></div></div><br>  This function should only return true if the vertex w is visible from the vertex v and false otherwise.  To do this, it is enough just to compare the length of the segment vw and the distance from the point v to the intersection with the nearest segment stored in the tree (the leftmost sheet).  But there are several marginal cases: <br><ul><li>  The ray vw intersects the edges incident to the vertices v or w </li><li>  The ray coincides with the edge on which there are other vertices. </li></ul><br><br>  Thus, the visibility check function works in the worst case for O (log (n)), because it uses search in a balanced tree.  The remaining operations are performed in constant time. <br><br><h5>  Road maps </h5><br>  Another route planning method is the use of road maps.  Sounds like a truism, doesn't it?  In this article, I will briefly talk about its essence (because the article is already quite voluminous), if anyone is interested, I will probably write another publication later.  So. <br><br>  We construct a rectangle containing all the polygons-obstacles inside (figure 11).  Consider the set of segments - the edges of the obstacles and construct a trapezoidal map for it (Figure 12), and then remove from the resulting map all the trapezoids lying inside the obstacles (Figure 13).  It takes O (nlog (n)) time to build a map, where n is the total number of obstacle vertices.  In order to decide whether to remove the trapezoid T, it suffices to take the edge top (T) and check whether an obstacle lies above or below it, the boundary of which contains this edge.  Thus, it will take O (n) time to remove all the extra trapezoids. <br>  If the starting and ending points are inside one trapezoid, then you can pass from the first point to the second in a straight line.  If these points lie in different trapezoid, then the path will cross several trapezoids, and, probably, in some of them we will have to make turns. <br>  We construct a road map ‚Äî graph G. The vertices of G are the midpoints of the vertical line segments drawn through the tops of the obstacles and the midpoints of the trapezoids.  Two vertices of the graph G are connected by an edge if and only if one of them is the middle of some trapezoid, and the other lies on the vertical edge of this trapezoid.  The graph G can be constructed from a trapezoidal map in time O (n).  Note that the graph G is a planar graph. <br>  In order to find a path from point s to point f, we first determine which trapezoid contains s and f.  If they got into one trapezoid, then the shortest path is a straight line.  Otherwise, we move in a straight line from point s to the middle of the trapezoid containing it, then move along the edges of the graph to the middle of the trapezoid containing point f (you can use wide search), and finally move to point f in a straight line from the middle of the trapezoid containing it (figure 14).  Since the trapezoidal map contains a linear number of trapezoids in n, and the number of segments of vertical lines drawn through the vertices of the obstacles is also linear in n, the graph G has O (n) vertices, and since it is planar, the number of edges is also O ( n).  Therefore, a wide search on G can be performed in O (n) time.  Since localization of a point in the trapezoidal map takes O (log (n)) time, it takes O (n) to build a path from point s to point f.  But the paths constructed using roadmaps will not be optimal. <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/6ef/05e/564/6ef05e5644370f8d01328d8b926b1fc5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/b1c/234/eb7/b1c234eb704410ce4fe55a8e69e774e9.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0b3/8fe/b4a/0b38feb4ab7961bd1eb72968c4d64446.png"></td></tr><tr><td><h6>  Figure 11. Building an enclosing rectangle </h6></td><td><h6>  Figure 12. Trapezoidal map </h6></td><td><h6>  Figure 13. Reduced trapezoidal map </h6></td></tr></tbody></table><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e5/647/1e4/4e56471e4847408491baeb805c77d618.png"><br><h6>  Figure 14. Built road map </h6><br><br><h4>  Subtasks </h4><br><h5>  Constructing a convex hull </h5><br>  In general, a scene is a collection of arbitrary objects.  For each of them, a convex hull can be constructed (well, or a bounding volume, if greater precision is not needed, or all objects resemble rectangles).  In order to be able to use the visibility graph for arbitrary geometry, it is necessary to map it to the set of polygons.  The simplest method is to construct a convex hull.  There are several different algorithms for its construction and this is a topic for a separate article, I just mention them here: <br><ul><li>  Naive algorithm.  Works for O (n <sup>4</sup> ).  For each ‚Äúnot extreme‚Äù (that is, such a point of a set through which a straight line can be drawn, relative to which the whole set will lie on one side), the following test is performed.  If it belongs to at least one triangle obtained from the points of the set, then it is a point of a convex hull.  In the set of N points N <sup>3</sup> triangles.  Therefore for each of the N points you need to perform N <sup>3</sup> checks. </li><li>  Slightly less naive algorithm.  O (n <sup>3</sup> ).  A complete graph is constructed with a set of nodes ‚Äî the points of the original set.  For each edge (of which N <sup>2</sup> ) the remaining N-2 points are checked.  Do they all lie on one side of this edge.  If so, then the edge belongs to the convex hull. </li><li>  Jarvis algorithm.  Works for O (n <sup>2</sup> ).  Imagine a lot of points on a plane.  Choose the leftmost among them (this can always be done (if there are several, then any among the left), it is obviously a point of a convex hull), and then ‚Äúwrap‚Äù the set as a gift.  Among all the other points we choose the one that has the smallest polar angle (by analogy with the construction of the visibility graph, we sweep it with a ray) </li><li>  Graham's Algorithm.  Works for O (nlog (n)).  I will not provide the description (as you understand, the faster the algorithm, the more scribbling) - google </li></ul><br><br><h5>  Intersection of segments </h5><br>  Finally, the last task that needs to be solved in the construction of the visibility graph is to check two segments for intersections.  This is a very good topic for a separate article, since there is also a lot of writing on this issue.  I just give you one of the methods for solving the problem that <a href="http://martin-thoma.com/how-to-check-if-two-line-segments-intersect/">I like</a> : <a href="http://martin-thoma.com/how-to-check-if-two-line-segments-intersect/">here it is</a> . <br><br><h4>  Conclusion </h4><br>  I hope someone article seemed interesting, and maybe even useful.  In the near future I plan to publish another article, and then we will see - let's arrange a survey on whether to continue. <br><div class="spoiler">  <b class="spoiler_title">Instead of a thousand words</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/335/57c/f4a/33557cf4a683e8e410b4b9a66d718b31.png"></div></div><br><br><h4>  Links </h4><br><ul><li>  Lectures on linear algebra, higher mathematics, discrete mathematics, theory of algorithms and computational geometry at the department Applied Mathematics SPbGPU </li><li>  M. de Berg, O. Cheong, M. Kreveld, M. Overmars "Computational Geometry", 2008 </li><li>  JE Goodman, J. O'Rourke, Discrete and computational geometry, 2004 </li><li>  <a href="https://github.com/Trimax/venta">Venta library</a> java implementation <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/199256/">https://habr.com/ru/post/199256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../199240/index.html">12-year-old student hacked government sites for Anonymous</a></li>
<li><a href="../199242/index.html">Optimus Popularis Keyboard Review (+ video)</a></li>
<li><a href="../199248/index.html">Andragogue Practitioner Tips: How We Learn</a></li>
<li><a href="../199252/index.html">Attention! Competition! We develop instant messenger Vkontakte for Tizen</a></li>
<li><a href="../199254/index.html">Given the ever-increasing number of camcorders</a></li>
<li><a href="../199258/index.html">Barcode Android Recognition</a></li>
<li><a href="../199264/index.html">Uzbeks and IT</a></li>
<li><a href="../199266/index.html">Runtime-generating .Net code for those who have no time</a></li>
<li><a href="../199268/index.html">How I did multilanguage on Codeigniter</a></li>
<li><a href="../199270/index.html">Blink Scroll lock'om with incoming email message (perl + bash)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>