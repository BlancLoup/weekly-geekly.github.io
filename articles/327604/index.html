<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.9 - Camera</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous lesson, the view matrix was discussed, and how it can be used to move around the scene (we moved the observer's point back a little). ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.9 - Camera</h1><div class="post__text post__text-html js-mediator-article"><br><p><img src="https://habrastorage.org/files/eb2/7ea/738/eb27ea738aca4d3789a0c0ee634dd463.png" alt="image" align="left" width="300">  In the previous lesson, the view matrix was discussed, and how it can be used to move around the scene (we moved the observer's point back a little).  In OpenGL, there is no <i>camera</i> concept, but you can try to imitate it by moving all the objects in the scene in the direction opposite to the observer‚Äôs movement, and thereby create the illusion that <b>we ourselves</b> are moving. </p><br><p>  In this tutorial we will look at how to create a camera in OpenGL.  We discuss the camera type FPS (First Person Shooter), which allows you to move freely in a three-dimensional scene.  In addition, we will talk about keyboard and mouse input, and finish by creating our own C ++ camera class. </p><br><a name="habracut"></a><br><br><p></p><div class="spoiler">  <b class="spoiler_title">Menu</b> <div class="spoiler_text"><p>  Part 1 </p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <b>Camera</b> <br><br>  Content: <br><ul><li>  <a href="https://habr.com/ru/post/327604/">Camera / View Space</a> </li><li>  <a href="https://habr.com/ru/post/327604/">1. Camera position</a> </li><li>  <a href="https://habr.com/ru/post/327604/">2. Camera direction</a> </li><li>  <a href="https://habr.com/ru/post/327604/">3. Right axis</a> </li><li>  <a href="https://habr.com/ru/post/327604/">4. Axis up</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Lookat</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Take a walk</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Movement speed</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Look around</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Euler angles</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Mouse control</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Zoom</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Camera class</a> </li><li>  <a href="https://habr.com/ru/post/327604/">Exercises</a> </li></ul><br></li></ol><br><p>  Part 2 </p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Lighting maps</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple lighting</a> </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  Part 3 </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp and Mesh class</a> </li></ol><br></div></div><br><br><a name="01_camera_view"></a><h2>  Camera / View Space </h2><br><p>  When we talk about camera / view space, we mean the view of all the vertices from the point of view of the camera, whose position in this space is the base point of the origin: the view matrix transforms the world coordinates into view coordinates, measured relative to the camera position and direction.  For an unambiguous mathematical description of the camera, we need its position in world space, the direction in which it looks, the vector indicating the right direction, and the vector indicating the direction upwards.  The attentive reader may notice that in fact we are going to create a coordinate system with 3 perpendicular axes and the camera position as a reference point. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/11f/4c4/861/11f4c4861254494fa06c3614e86b3a4e.png" alt="image"></div><br><br><a name="02_camera_position"></a><h4>  1. Camera position </h4><br><p>  Getting a camera position is easy.  Camera position is a vector containing camera coordinates in world space.  We will place the camera in the same place where we installed it in the previous lesson: </p><br><pre><code class="cpp hljs">glm::vec3 cameraPos = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>);</code> </pre> <br><blockquote><p>  Do not forget that the positive direction of the Z axis passes through the screen plane to you, therefore, if we want the camera to move backwards, we move along the positive Z axis. </p></blockquote><br><a name="03_camera_direction"></a><h4>  2. Camera direction </h4><br><p>  The next vector we need will be the direction vector of the camera.  So far, the camera is aimed at the base point of our scene: (0,0,0).  You have not forgotten that if we subtract two vectors from each other, then we get a vector that is the difference of the original vectors?  Subtracting the camera position vector from the origin point gives us the camera direction vector.  We know that the camera looks along the negative direction of the Z axis, and we need a vector directed along the positive Z axis of the camera itself.  If during subtraction we change the order of the arguments, we get a vector pointing in the positive direction of the camera axis Z: </p><br><pre> <code class="cpp hljs">glm::vec3 cameraTarget = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</code> </pre> <br><blockquote><p>  The name ‚Äú <b>direction</b> vector‚Äù is not quite appropriate, because this vector actually points in the direction opposite to the direction of the camera. </p></blockquote><br><a name="03_right"></a><h4>  3. Right axis </h4><br><p>  Another vector, without which we can not do, is a vector pointing to the <i>right side</i> and representing the positive direction of the camera axis X.  To calculate this vector, we will do a small trick, and for this we first set the vector pointing up (in world space).  Then we multiply the vector camera direction calculated in step 2 and the vector pointing up.  Since the result of a vector product is a vector perpendicular to the original vectors, we get a vector pointing in the positive direction of the x-axis (if we change the factors in some places, we get a vector that points in the negative direction of the x-axis): </p><br><pre> <code class="cpp hljs">glm::vec3 up = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</code> </pre> <br><a name="04_up"></a><h4>  4. Axis up </h4><br><p>  Now, when we have the vectors of two axes X and Z, to get a vector that would point in the positive direction of the camera Y-axis, it will be quite simple: we will make a vector multiplication of the right vector and the camera direction vector: </p><br><pre> <code class="cpp hljs">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</code> </pre> <br><p>  With the help of the vector product and small tricks we were able to calculate all the vectors that define the space of the Camera / View.  More sophisticated in mathematics readers, this algorithm in linear algebra is known as the Gram-Schmidt process.  Using these vectors, we can now create a <b>LookAt</b> matrix, which will be very useful for us to create a camera. </p><br><a name="05_lookat"></a><h2>  Lookat </h2><br><p>  One of the remarkable properties of matrices is that if you specify the coordinate space using 3 perpendicular (or linearly independent) axes, then from the vectors of these axes and the additional displacement vector, you can form a matrix, the multiplication by which will convert any vectors to this coordinate space.  This is exactly what the <b>LookAt</b> matrix does, and now that we have everything we need to define the Camera / View space, i.e.  3 perpendicular axes and camera position vector, we can create our own LookAt matrix: </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>LookAt&amp;#xA0;=&amp;#xA0;\&amp;#xA0;begin&amp;#xA0;{bmatrix}&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{red}&amp;#xA0;{R_x}&amp;#xA0;&amp;amp;&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{red}&amp;#xA0;{R_y}&amp;#xA0;&amp;amp;&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{red}&amp;#xA0;{R_z}&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;\\&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{green}&amp;#xA0;{U_x}&amp;#xA0;&amp;amp;&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{&amp;#xA0;green}&amp;#xA0;{U_y}&amp;#xA0;&amp;amp;&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{green}&amp;#xA0;{U_z}&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;\\&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{blue}&amp;#xA0;{D_x}&amp;#xA0;&amp;amp;&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{blue}&amp;#xA0;{D_y}&amp;#xA0;&amp;amp;&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{blue}&amp;#xA0;{D_z}&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;\\&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;1&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{bmatrix}&amp;#xA0;*&amp;#xA0;\&amp;#xA0;begin&amp;#xA0;{bmatrix}&amp;#xA0;1&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;-&amp;#xA0;{\&amp;#xA0;color&amp;#xA0;{Purple}&amp;#xA0;{P_x}}&amp;#xA0;\\&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;1&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;-&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{Purple}&amp;#xA0;{P_y}&amp;#xA0;\\&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;1&amp;#xA0;&amp;amp;&amp;#xA0;-&amp;#xA0;\&amp;#xA0;color&amp;#xA0;{Purple}&amp;#xA0;{P_z}&amp;#xA0;\\&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;0&amp;#xA0;&amp;amp;&amp;#xA0;1&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{bmatrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">LookAt&nbsp;=&nbsp;\&nbsp;begin&nbsp;{bmatrix}&nbsp;\&nbsp;color&nbsp;{red}&nbsp;{R_x}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{red}&nbsp;{R_y}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{red}&nbsp;{R_z}&nbsp;&amp;&nbsp;0&nbsp;\\&nbsp;\&nbsp;color&nbsp;{green}&nbsp;{U_x}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{&nbsp;green}&nbsp;{U_y}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{green}&nbsp;{U_z}&nbsp;&amp;&nbsp;0&nbsp;\\&nbsp;\&nbsp;color&nbsp;{blue}&nbsp;{D_x}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{blue}&nbsp;{D_y}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{blue}&nbsp;{D_z}&nbsp;&amp;&nbsp;0&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;\&nbsp;end&nbsp;{bmatrix}&nbsp;*&nbsp;\&nbsp;begin&nbsp;{bmatrix}&nbsp;1&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;-&nbsp;{\&nbsp;color&nbsp;{Purple}&nbsp;{P_x}}&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;-&nbsp;\&nbsp;color&nbsp;{Purple}&nbsp;{P_y}&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;&amp;&nbsp;-&nbsp;\&nbsp;color&nbsp;{Purple}&nbsp;{P_z}&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;\&nbsp;end&nbsp;{bmatrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>LookAt&nbsp;=&nbsp;\&nbsp;begin&nbsp;{bmatrix}&nbsp;\&nbsp;color&nbsp;{red}&nbsp;{R_x}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{red}&nbsp;{R_y}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{red}&nbsp;{R_z}&nbsp;&amp;&nbsp;0&nbsp;\\&nbsp;\&nbsp;color&nbsp;{green}&nbsp;{U_x}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{&nbsp;green}&nbsp;{U_y}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{green}&nbsp;{U_z}&nbsp;&amp;&nbsp;0&nbsp;\\&nbsp;\&nbsp;color&nbsp;{blue}&nbsp;{D_x}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{blue}&nbsp;{D_y}&nbsp;&amp;&nbsp;\&nbsp;color&nbsp;{blue}&nbsp;{D_z}&nbsp;&amp;&nbsp;0&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;\&nbsp;end&nbsp;{bmatrix}&nbsp;*&nbsp;\&nbsp;begin&nbsp;{bmatrix}&nbsp;1&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;-&nbsp;{\&nbsp;color&nbsp;{Purple}&nbsp;{P_x}}&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;-&nbsp;\&nbsp;color&nbsp;{Purple}&nbsp;{P_y}&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;&amp;&nbsp;-&nbsp;\&nbsp;color&nbsp;{Purple}&nbsp;{P_z}&nbsp;\\&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;\&nbsp;end&nbsp;{bmatrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> LookAt = \ begin {bmatrix} \ color {red} {R_x} & \ color {red} {R_y} & \ color {red} {R_z} & 0 \\ \ color {green} {U_x} & \ color { green} {U_y} & \ color {green} {U_z} & 0 \\ \ color {blue} {D_x} & \ color {blue} {D_y} & \ color {blue} {D_z} & 0 \\ 0 & 0 & 0 & 1 \ end {bmatrix} * \ begin {bmatrix} 1 & 0 & 0 & - {\ color {Purple} {P_x}} \\ 0 & 1 & 0 & - \ color {Purple} {P_y} \\ 0 & 0 & 1 & - \ color {Purple} {P_z} \\ 0 & 0 & 0 & 1 \ end {bmatrix} </script></p><br><p>  Where <font color="red">R</font> is the right vector, <font color="green">U</font> is the vector pointing up, <font color="blue">D</font> is the camera direction vector, and <font color="purple">P</font> is the camera position.  Notice that the camera position vector is inverted, because ultimately we will shift the world coordinates in the opposite direction of the camera movement.  Using the LookAt matrix as a view matrix allows you to effectively convert all world coordinates into the space we have just defined.  The LookAt matrix does exactly what its name says: it creates a view matrix that <i>looks at a</i> given target. </p><br><p>  Fortunately, the GLM library will do all this work for us.  We only need to indicate the position of the camera, the coordinate of the target and the vector in world space upward (the auxiliary vector that we used to calculate the right vector).  Using these data, GLM independently creates a LookAt matrix, which we can use as our matrix of the form: </p><br><pre> <code class="cpp hljs">glm::mat4 view; view = glm::lookAt(glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre> <br><p>  The functions <b>glm :: LookAt</b> require the following parameters: camera position, target coordinate, and upward vector.  The function will calculate a matrix of the form identical to the one we used in the previous lesson. </p><br><p>  Before we delve into the issues related to user input, let's have a little fun and twist the camera around our scene.  For simplicity, we will keep the camera aimed at the point (0,0,0) all the time. </p><br><p>  To calculate the position of our camera, we apply some trigonometry and calculate for each frame the coordinates X and Z, which will be a point located on a circular path.  Recalculating the X and Z coordinates in each frame, we will move through all points of the circle and, thus, the camera will begin to rotate around the scene.  Let's set the size of this circle with a constant radius value and, using the <b>glfwGetTime</b> function from the GLFW library, calculate for each iteration of the game cycle a new matrix of the form: </p><br><pre> <code class="cpp hljs">GLfloat radius = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; GLfloat camX = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glfwGetTime()) * radius; GLfloat camZ = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glfwGetTime()) * radius; glm::mat4 view; view = glm::lookAt(glm::vec3(camX, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, camZ), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre> <br><p>  If you run this code, you will see something like this: </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/camera_circle.mp4" type="video/mp4"></video></div></div></div><br><p>  Now, with this small code snippet, the camera rotates around the scene.  Don't be afraid to experiment with the radius and position / direction parameters to understand how the <i>LookAt</i> matrix works.  If you have something wrong, compare your code with the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera_circle">source code</a> , and the shaders with the texts of the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems%26type%3Dvertex">vertex</a> and <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/coordinate_systems%26type%3Dfragment">fragment</a> shaders. </p><br><a name="06_walk_around"></a><h2>  Take a walk </h2><br><p>  Rotate the camera around the scene of course fun, but even more interesting to move it yourself!  First, we will have to create the ‚Äúinfrastructure‚Äù of the camera, and for this at the beginning of our program, let's define several variables: </p><br><pre> <code class="cpp hljs">glm::vec3 cameraPos = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>); glm::vec3 cameraFront = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>); glm::vec3 cameraUp = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>);</code> </pre> <br><p>  Now the function call LookAt will be like this: </p><br><pre> <code class="cpp hljs">view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</code> </pre> <br><p>  First we set the camera to the position whose coordinate is stored in the variable <b>cameraPos</b> .  The direction of the camera is calculated as its current position + vector <b>cameraFront</b> , which we have just announced and initialized.  This ensures that despite the movement of the camera, it will always look in the direction of the target.  Let's play a little with these variables by changing the vector of <b>cameraPos by</b> pressing the keys. </p><br><p>  In <a href="https://habrahabr.ru/post/311234/">Lesson 1.3,</a> we created the <b>key_callback</b> callback function needed to get keyboard input from GLFW, and now let's add a few new checks for pressing certain buttons: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">key_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLFWwindow* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scancode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span></span>{ ... GLfloat cameraSpeed = <span class="hljs-number"><span class="hljs-number">0.05f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key == GLFW_KEY_W) cameraPos += cameraSpeed * cameraFront; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key == GLFW_KEY_S) cameraPos -= cameraSpeed * cameraFront; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key == GLFW_KEY_A) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key == GLFW_KEY_D) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; }</code> </pre> <br><p>  Whenever we press one of the WASD keys, the camera position is updated according to its new coordinates.  If we want to move forward or backward, then add or subtract the direction vector from the camera position vector.  When moving in the lateral direction, we find the vector directed <i>to the right</i> through the vector product and move along it.  With a lateral displacement of the camera, this creates a streyf effect familiar to gamers. </p><br><blockquote><p>  Please note that we normalize the resulting right vector.  If we did not do this, then depending on the value of <b>cameraFront, the</b> results of the vector product could be vectors of different lengths.  Without normalization of the right vector, the speed of the camera would not be constant, but would accelerate or slow down when the direction of the camera changes. </p></blockquote><br><p>  If you complement the <b>key_callback</b> function <b>with</b> this code snippet, you can move around the scene, moving forward / backward or to the side. </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/camera_inside.mp4" type="video/mp4"></video></div></div></div><br><p>  Having fun with this simple camera control system, you probably noticed that you cannot move in two directions at the same time (make a diagonal movement), and when you hold one of the keys, it first works once, and only then, after a short delay, continuous movement.  This is due to the fact that most input systems have an event-oriented architecture (event-driven architecture, EDA) capable of simultaneously processing only one keystroke, which the corresponding handler calls.  This works well in many GUI systems, but is not very suitable for smooth camera movement.  I will show a little trick to solve this problem. </p><br><p>  The trick is in the <b>key_callback</b> callback function to <b>keep</b> track of which keys were pressed or released.  Then, in the game cycle, we count these values, check which keys are active and, based on their state, change the value of the variable <b>cameraPos accordingly</b> .  Thus, in the handler function, we simply save the information about which keys were pressed or released, and respond to their states already in the game cycle.  First, let's create an array of variables of the logical type representing the pressed or released states of the keys: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> keys[<span class="hljs-number"><span class="hljs-number">1024</span></span>];</code> </pre> <br><p>  After that, in the <b>key_callback</b> function <b>,</b> we need to set the keystrokes to <i>true</i> , and those released to <i>false</i> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(action == GLFW_PRESS) keys[key] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(action == GLFW_RELEASE) keys[key] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  And let's create a new function, which we call <b>do_movement</b> , where we will update the coordinates of the camera, relying on the state of keystrokes: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Camera controls GLfloat cameraSpeed = 0.01f; if(keys[GLFW_KEY_W]) cameraPos += cameraSpeed * cameraFront; if(keys[GLFW_KEY_S]) cameraPos -= cameraSpeed * cameraFront; if(keys[GLFW_KEY_A]) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; if(keys[GLFW_KEY_D]) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; }</span></span></code> </pre> <br><p>  The code from the previous section has now been moved to the <b>do_movement</b> function.  Since the GLFW key identifier enums are simply integers, we can use them to index the array. </p><br><p>  And last but not least, we need to add a new function call to the body of the game cycle: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!glfwWindowShouldClose(window)) { <span class="hljs-comment"><span class="hljs-comment">//        glfwPollEvents(); do_movement(); //  ... }</span></span></code> </pre> <br><p>  Now you should be able to move simultaneously in two directions, and continuous movement should begin immediately after pressing the keys.  If you're stuck on something, feel free to compare your code with the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera_keyboard">source code</a> . </p><br><a name="04_movement_speed"></a><h3>  Movement speed </h3><br><p>  Currently, we use a constant value of the speed of movement when moving the camera.  In theory, this seems normal, but in practice, different users may have very different computational powers, as a result, on some computers at the same time many more frames will be drawn than on others.  And if one user draws more frames than another, then the <b>do_movement</b> function will be called more often. <br>  As a result, depending on the configuration of the computer, some users will move around the scene very quickly, while others will move very slowly.  But in spreading your program, you probably want it to work equally on any hardware. </p><br><p>  Graphic applications and games typically use a special variable <b>deltaTime</b> , in which they store the time spent on rendering the last frame output.  And then, all the speeds in the game are multiplied by this <b>deltaTime</b> value.  As a result, when the frame output takes a lot of time and the <b>deltaTime</b> value <b>is</b> large, then the speed multiplied by this variable will become larger, which will balance the overall performance.  When using this approach, the power of the computer ceases to influence the behavior of the program and no longer matters whether your computer is slow or very fast, the speed of the camera will be adjusted anyway, and all users will have the same result. </p><br><p>  To calculate the <b>deltaTime</b> value, we will need 2 global variables: </p><br><pre> <code class="cpp hljs">GLfloat deltaTime = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       GLfloat lastFrame = 0.0f; //    </span></span></code> </pre> <br><p>  Then, in each frame, we calculate the new <b>deltaTime</b> value for later use: </p><br><pre> <code class="cpp hljs">GLfloat currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame;</code> </pre> <br><p>  Now that we have <b>deltaTime</b> , we can take its value into account when calculating speeds: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GLfloat cameraSpeed = <span class="hljs-number"><span class="hljs-number">5.0f</span></span> * deltaTime; ... }</code> </pre> <br><p>  Together with the code from the previous section, we should have a smoother and more consistent system for moving the camera around the stage: </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/camera_smooth.mp4" type="video/mp4"></video></div></div></div><br><p>  And now we have a camera that moves at the same speed on any system.  If something goes wrong, check the <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera_keyboard_dt">source code</a> again.  Later we will make sure that the <b>deltaTime</b> value often appears in any code related to speed and movement. </p><br><a name="05_look_around"></a><h2>  Look around </h2><br><p>  Using only the keyboard to move is not very interesting.  Moreover, the lack of opportunity to turn around makes our movements quite constrained.  This is where the mouse comes in handy! </p><br><p>  In order to freely inspect the scene, we must change the direction vector of the <b>cameraFront</b> camera <b>guided</b> by mouse input.  However, changing the direction vector based on the turns of the mouse creates certain difficulties and requires some knowledge of trigonometry.  If you do not understand trigonometry, <strike>do not</strike> worry.  You can simply go to the sections with the source code and insert them into your program, and if you want to know the details, you can always return. </p><br><a name="06_euler_angles"></a><h3>  Euler angles </h3><br><p>  Euler angles are three quantities, described by Leonard Euler sometime in the 1700s, which can represent any rotation in three-dimensional space.  There are 3 Euler angles: <i>pitch</i> (pitch), <i>yaw</i> (yaw) and <i>roll</i> (roll).  They are illustrated in the following image: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6c9/dd0/6a7/6c9dd06a743f4305b816b63afb9dfbee.png"></div><br><p>  As seen in the first image, <b>pitch</b> is the angle that characterizes the amount of tilt up or down.  The second image shows <b>yaw</b> , which is the amount of turning left or right.  <b>The heel</b> sets the turn along the longitudinal axis, and is usually often used in various flight simulators.  Each Euler angle is given by one scalar quantity, and the combination of all three angles allows us to calculate any rotation vector in three-dimensional space. </p><br><p>  In our camera control system, we will use only the yaw and pitch angles, so we will not discuss the value of the roll here.  Having yaw and pitch values, we can convert them into a 3D vector of camera direction.  The process of converting yaw and pitch values ‚Äã‚Äãto a direction vector will require some trigonometric calculations.  Let's start with a simple example: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5bc/0e3/2e3/5bc0e32e30f148dfb42822d22cf3ecf5.png"></div><br><p>  If we set the length of the hypotenuse to 1, then from the main trigonometric relations (soh cah toa: Sine Opposite Hypotenuse, Cosine Adjacent Hypotenuse, Tangent Opposite Adjacent, ie, sine is the ratio of the opposite side to the hypotenuse, cosine is the ratio of the adjacent side to the hypotenuse , tangent - the ratio of the opposite leg to the adjacent one. It is known that the length of the adjacent leg is cos <font color="red">X</font> / <font color="purple">h</font> = cos <font color="red">X</font> / <font color="purple">1</font> = cos <font color="red">X</font> , and the length of the opposite side is sin <font color="green">Y</font> / <font color="purple">h</font> = sin <font color="green">Y</font> / <font color="purple">1</font> = sin <font color="green">Y.</font>  These formulas enable us to calculate the length of the projection of the hypotenuse on the X and Y axes at a given angle.  Let's use them to calculate the components of the camera direction vector: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/358/cf2/69b/358cf269bdd240129235c5fde4fbca59.png"></div><br><p>  This triangle is similar to the triangle from the previous illustration, and if we imagine that we are on the XZ plane and look at the Y axis, we can calculate the value of the Y-component (defining the orientation up or down) of the direction vector using the formula given for the first triangle.  The figure shows that the Y value for a given pitch angle sin: </p><br><pre> <code class="cpp hljs">direction.y = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(pitch)); <span class="hljs-comment"><span class="hljs-comment">// ,        </span></span></code> </pre> <br><p>  Here we calculated only the value of Y, now we need to calculate the components X and Z. Looking at the image of the triangle, we see that their values ‚Äã‚Äãare equal: </p><br><pre> <code class="cpp hljs">direction.x = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)); direction.z = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch));</code> </pre> <br><p>  Let's see how we find the corresponding components of the direction vector for the yaw angle: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/01f/35c/434/01f35c434d904a3ca729e3833bde7787.png"></div><br><p>  Just as in the figure of a triangle constructed for the pitch angle, this illustration shows the dependence of the X-component on the cos (yaw) value, and the Z-component on the sin (yaw).  Combining these values ‚Äã‚Äãwith the results calculated for the pitch angle will give us the final vector of the camera direction, built on two angles of rotation - pitch and yaw: </p><br><pre> <code class="cpp hljs">direction.x = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)) * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(yaw)); direction.y = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(pitch)); direction.z = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(yaw));</code> </pre> <br><p>  This gives us a formula for converting the pitch and yaw angles into a three-dimensional direction vector, which we can use to orient the camera.  Probably you have already wondered: how do we get the values ‚Äã‚Äãof yaw and pitch angles? </p><br><a name="07_mouse_input"></a><h3>  Mouse control </h3><br><p>  Pitch and yaw angles change their values ‚Äã‚Äãdepending on mouse movements (or game controller / joystick);  lateral movements of the mouse affect the yaw angle, and forward / backward movement affects the pitch angle.  The idea is to save the mouse coordinates for the last frame, and in the current frame compare them with the new coordinates and calculate how many pixels the mouse pointer has moved.  The greater this shift, the more it will change the value of the pitch and / or yaw, and, accordingly, the camera will turn to a greater angle. </p><br><p>  First we tell the GLFW library that it should capture the cursor and hide the mouse pointer.  Capturing the cursor means that after the application receives the input focus, the cursor will remain within the window (until the application loses focus or completes its work).  We can do this with one simple configuration call: </p><br><pre> <code class="cpp hljs">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After this call, wherever we move the mouse, its pointer will not be visible and will not be able to go beyond the window. </font><font style="vertical-align: inherit;">This is ideal for controlling camera in FPS type games.</font></font></p><br><p>     ,       ,    GLFW,        .    (   ),      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mouse_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLFWwindow* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xpos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ypos)</span></span></span></span>;</code> </pre> <br><p>  <b>xpos</b>  <b>ypos</b>    .  ,     GLFW     <b>mouse_callback</b> ,       : </p><br><pre> <code class="cpp hljs">glfwSetCursorPosCallback(window, mouse_callback);</code> </pre> <br><p>         FPS,       ,      : </p><br><ol><li>       . </li><li>         . </li><li>    /  / </li><li>     </li></ol><br><p>             .     -      .     ,       (  800  600): </p><br><pre> <code class="cpp hljs">GLfloat lastX = <span class="hljs-number"><span class="hljs-number">400</span></span>, lastY = <span class="hljs-number"><span class="hljs-number">300</span></span>;</code> </pre> <br><p>           : </p><br><pre> <code class="cpp hljs">GLfloat yaw = <span class="hljs-number"><span class="hljs-number">-90.0f</span></span>; GLfloat pitch = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>;</code> </pre> <br><p>        ,      : </p><br><br><pre> <code class="cpp hljs">GLfloat xoffset = xpos - lastX; GLfloat yoffset = lastY - ypos; <span class="hljs-comment"><span class="hljs-comment">//       Y-     lastX = xpos; lastY = ypos; GLfloat sensitivity = 0.05f; xoffset *= sensitivity; yoffset *= sensitivity;</span></span></code> </pre> <br><p>  ,        <b>sensitivity</b> ().     ,      ;      . </p><br><p>       <b>pitch</b>  <b>yaw</b> : </p><br><pre> <code class="cpp hljs">yaw += xoffset; pitch += yoffset;</code> </pre> <br><p>          ,         (      ).     ,         89  (   90   ,     89),        -89 .              ,   .                : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pitch &gt; <span class="hljs-number"><span class="hljs-number">89.0f</span></span>) pitch = <span class="hljs-number"><span class="hljs-number">89.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pitch &lt; <span class="hljs-number"><span class="hljs-number">-89.0f</span></span>) pitch = <span class="hljs-number"><span class="hljs-number">-89.0f</span></span>;</code> </pre> <br><p>  ,         ,         .   ,    ,        ,     . </p><br><p>                ,        : </p><br><pre> <code class="cpp hljs">glm::vec3 front; front.x = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)) * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(yaw)); front.y = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(pitch)); front.z = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(yaw)); cameraFront = glm::normalize(front);</code> </pre> <br><p>      ,    .   <b>cameraFront</b>        <b>glm::lookAt</b> ,      . </p><br><p>    ,  ,       ,     .      ,      <b>mouse_callback</b>  <b>xpos</b>  <b>ypos</b>           .           ,      ,   ,   .        -  <i>bool</i> ,    ,             <b>xpos</b>  <b>ypos</b> ;     ,        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstMouse) <span class="hljs-comment"><span class="hljs-comment">//      true { lastX = xpos; lastY = ypos; firstMouse = false; }</span></span></code> </pre> <br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mouse_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLFWwindow* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xpos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ypos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstMouse) { lastX = xpos; lastY = ypos; firstMouse = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } GLfloat xoffset = xpos - lastX; GLfloat yoffset = lastY - ypos; lastX = xpos; lastY = ypos; GLfloat sensitivity = <span class="hljs-number"><span class="hljs-number">0.05</span></span>; xoffset *= sensitivity; yoffset *= sensitivity; yaw += xoffset; pitch += yoffset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pitch &gt; <span class="hljs-number"><span class="hljs-number">89.0f</span></span>) pitch = <span class="hljs-number"><span class="hljs-number">89.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pitch &lt; <span class="hljs-number"><span class="hljs-number">-89.0f</span></span>) pitch = <span class="hljs-number"><span class="hljs-number">-89.0f</span></span>; glm::vec3 front; front.x = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(yaw)) * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)); front.y = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(pitch)); front.z = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(glm::radians(yaw)) * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(glm::radians(pitch)); cameraFront = glm::normalize(front); }</code> </pre> <br><p>  Like this!     ,         3D-!    - ,  <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera_mouse"> </a> . </p><br><blockquote><p>  :   ,      <i>firstMouse</i> ,       <b>glfwSetCursorPos</b>   ‚Äî   <i>lastX</i>  <i>lastY</i>  <b>glfwGetCursorPos</b> . </p></blockquote><br><a name="08_zoom"></a><h3>  </h3><br><p>           .       ,  <i> </i>  <i>fov</i>    .    ,          ,    .         .  ,         ,        : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLFWwindow* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xoffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yoffset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fov &gt;= <span class="hljs-number"><span class="hljs-number">1.0f</span></span> &amp;&amp; fov &lt;= <span class="hljs-number"><span class="hljs-number">45.0f</span></span>) fov -= yoffset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fov &lt;= <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) fov = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fov &gt;= <span class="hljs-number"><span class="hljs-number">45.0f</span></span>) fov = <span class="hljs-number"><span class="hljs-number">45.0f</span></span>; }</code> </pre> <br><p>   <i>yoffset</i>   ,   .    <b>scroll_callback</b> ,      <b>fov</b> .     <b>fov</b>  45.0f,       1.0f  45.0f. </p><br><p> , -   <b>fov</b> ,               ,    : </p><br><pre> <code class="cpp hljs">projection = glm::perspective(fov, (GLfloat)WIDTH/(GLfloat)HEIGHT, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">100.0f</span></span>);</code> </pre> <br><p> , ,       : </p><br><pre> <code class="cpp hljs">glfwSetScrollCallback(window, scroll_callback);</code> </pre> <br><p>  That's all.      ,       . </p><br><div class="oembed"><div><div style="left: 0px; width: 100%; height: 0px; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0px; left: 0px; width: 100%; height: 100%; position: absolute;"> Your browser does not support HTML5 video. <source src="https://learnopengl.com/video/getting-started/camera_mouse.mp4" type="video/mp4"></video></div></div></div><br><p>   ,   -  ,     <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera_zoom"> </a> . </p><br><blockquote><p> :   ,   ,   .              <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25BB%25D0%25B0%25D0%25B4%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BE%25D0%25BA"> </a> .        ,        . </p></blockquote><br><a name="09_camera_class"></a><h2>  Camera </h2><br><p>                  .            ,  ,    ,          ,          .      ,         ,     ( )  ,      ,         . </p><br><p>  ,    Shader,     Camera    .     Camera <a href="https://learnopengl.com/code_viewer.php%3Ftype%3Dheader%26code%3Dcamera"></a> .       .       ,              . </p><br><blockquote><p>   FPS-             ,        ,     .         ,      . ,  FPS-      90 ,       (0,1,0)  ,       . </p></blockquote><br><p>        Camera   <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera_with_class"></a> . </p><br><a name="10_exercises"></a><h2>  Exercises </h2><br><ul><li> ,        ,     FPS-,     c ,    ,    XZ: <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera-exercise1"></a> . </li><li>      <b>LookAt</b> ,       ,       .   <b>glm::LookAt</b>     ,    : <a href="https://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/camera-exercise2"></a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/327604/">https://habr.com/ru/post/327604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327592/index.html">Results of the third round of the Russian Code Cup 2017</a></li>
<li><a href="../327594/index.html">How to use the HTTP API to send emails</a></li>
<li><a href="../327596/index.html">Tale of creating a classic RTS at home from scratch (Part 2: "Resurrection")</a></li>
<li><a href="../327598/index.html">Security Week 17: DoublePulsar broke free, a hundred thousand Linksys found holes, SMSVova expelled from Google Play</a></li>
<li><a href="../327600/index.html">Outstanding portfolio creation guide</a></li>
<li><a href="../327606/index.html">SQL101: Change Recovery Model</a></li>
<li><a href="../327608/index.html">Video recording of the webinar "Julia - A Fresh Approach to Numerical Computing and Data Science"</a></li>
<li><a href="../327610/index.html">Seven Reasons You Can't Drop Clash Royale</a></li>
<li><a href="../327612/index.html">In 5 minutes, make Single Page Application available for Google and Facebook.</a></li>
<li><a href="../327614/index.html">Explanation of Neural Turing Machines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>