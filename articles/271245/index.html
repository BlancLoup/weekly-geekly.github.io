<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Risks and problems of password hashing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Security has always been an ambiguous topic, provoking numerous heated debates. And all thanks to the abundance of a variety of points of view and ‚Äúid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Risks and problems of password hashing</h1><div class="post__text post__text-html js-mediator-article">  Security has always been an ambiguous topic, provoking numerous heated debates.  And all thanks to the abundance of a variety of points of view and ‚Äúideal solutions‚Äù that suit some and are completely inappropriate for others.  I believe that hacking the security system of an application is just a matter of time.  Due to the rapid growth of computing power and the increase in complexity, today's secure applications will no longer be so tomorrow. <br><br>  <i>Note</i>  <i>Translation: for a more complete picture, the <a href="http://www.sitepoint.com/hashing-passwords-php-5-5-password-hashing-api/">Hashing Passwords with the PHP 5.5 Password Hashing API</a> , to which the author refers in the article, will also be waiting for you.</i> <br><a name="habracut"></a><br>  If you have not studied hashing algorithms, then you most likely perceive them as a <b>one-way function that converts variable-length data into fixed-length data</b> .  Let's analyze this definition: <br><ul><li>  <b>One-way function</b> : it is impossible to recover the original data from a hash using any effective algorithm. </li><li>  <b>Converting variable-length data into fixed-length data</b> : the input value may be ‚Äúinfinite‚Äù length, but the output value may not.  This implies that two or more input values ‚Äã‚Äãcan have the same hashes.  The shorter the hash length, the higher the probability of a collision. </li></ul><br>  The <a href="http://en.wikipedia.org/wiki/MD5">MD5</a> and <a href="http://en.wikipedia.org/wiki/SHA-1">SHA-1</a> algorithms no longer provide a sufficiently high reliability in terms of the likelihood of collisions (see <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BA%25D1%2581_%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25B9_%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">The Paradox of Birthdays</a> ).  Therefore, it is recommended to use algorithms that generate longer hashes ( <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-256, SHA-512</a> , <a href="http://en.wikipedia.org/wiki/Whirlpool_%2528cryptography%2529">whirlpool</a> , etc.), which makes the probability of a collision negligible.  Such algorithms are also called ‚Äú <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudo-random</a> functions‚Äù, i.e. the results of their work are indistinguishable from the results of the work of a full-fledged <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">random number generator</a> ( <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">true random number generator</a> , TRNG). <br><br><h1>  Disadvantages of simple hashing </h1><br>  The fact that using an efficient algorithm is impossible to perform a reverse operation of hashing and restore the original data does not mean that you cannot be hacked.  If you search well, you can find databases with hashes of common words and short phrases.  In addition, simple passwords can be quickly and easily <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B1%25D0%25BE%25D1%2580">bruteformed</a> or hacked <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B1%25D0%25BE%25D1%2580_%25D0%25BF%25D0%25BE_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D1%258E">through a dictionary</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is a <a href="http://sqlmap.org/">quick</a> demonstration of how the <a href="http://sqlmap.org/">sqlmap</a> tool <a href="http://sqlmap.org/">,</a> through SQL injection, <a href="http://sqlmap.org/">cracks</a> passwords using brute force hashes generated by the MD5 algorithm. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/udhyrYDBYRw%3Ffeature%3Doembed&amp;xid=17259,1500004,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiVgOlMUONE3OJZ3aN4tSs8xQt6Zg" frameborder="0" allowfullscreen=""></iframe><br><br>  Criminals can do even easier - <a href="http://bit.ly/15O4SLN">google</a> specific hashes in online databases: <br><ul><li>  <a href="http://www.hash-database.net/">www.hash-database.net</a> </li><li>  <a href="https://isc.sans.edu/tools/hashsearch.html">isc.sans.edu/tools/hashsearch.html</a> </li><li>  <a href="http://md5online.net/">md5online.net</a> </li><li>  <a href="https://crackstation.net/">crackstation.net</a> </li></ul><br>  You also need to understand that if two or more identical passwords have the same hashes, then by cracking one hash, we get access to all accounts where the same password is used.  For example: let us have several thousand users, surely several of them use the password 123456 (if the site settings do not make the password more complicated).  MD5 hash for this password is e10adc3949ba59abbe56e057f20f883e.  So if you get this hash and search in the database for this value, you will find all users with such a password. <br><br><h1>  Why are unsafe salt hashes? </h1><br>  To make it harder for attacks of the kind described, the so-called <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BB%25D1%258C_%2528%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F%2529">salt</a> is applied.  This is a standard tool, but in the conditions of modern computing power it is no longer enough, especially if the length of the salt is small. <br><br>  In general, the function using salt can be represented as follows: <br><br>  f (password, salt) = hash (password + salt) <br><br>  To make brute force attack difficult, the salt must be at least 64 characters long.  But the problem is that for further user authentication, the salt must be stored in the database in plain text. <br><br>  if (hash ([password entered] + [salt]) == [hash]) then the user is authenticated <br><br>  Due to the uniqueness of salt for each user, we can solve the problem of collisions of simple hashes.  Now all the hashes will be different.  Also, approaches with googling hashes and brute force will not work anymore.  But if an attacker gains access to salt or DB through SQL injection, he can successfully attack with a brute force or a dictionary search, especially if users choose common passwords (a la 123456). <br><br>  Nevertheless, hacking any of the passwords will not automatically calculate users who have the same password, because we have ALL the hashes are different. <br><br><h1>  Moment of chance </h1><br>  To generate suitable salt, we need a good random number generator.  Immediately forget about the rand () function. <br><br>  There is a wonderful <a href="http://www.random.org/randomness/">article</a> dedicated to this issue.  In short: the computer itself does not generate random data, it is a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2582%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">deterministic machine</a> .  That is, each executed algorithm, having received the same data several times at the input, will present the same result at the output. <br><br>  When a random number is wanted from a computer, it usually takes data from several sources (for example, environment variables: date, time, number of written / read bytes, etc.), and then performs calculations on them to obtain "random" data.  Therefore, such data is called <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudo-random</a> .  So, if somehow to recreate the set of initial states at the moment of execution of the pseudo-random function, then we will be able to generate the same number. <br><br>  If the pseudo-random generator is also incorrectly implemented, patterns can be detected in the data it generates, and with their help it is possible to predict the result of the generation.  Take a look at this picture, which is the result of the PHP function rand (): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50c/469/236/50c4692360d970e64ef356f74746f894.png" alt="image"><br><br>  Now compare with the data generated by a full-fledged random number generator: <br><br><img src="https://habrastorage.org/files/e50/c4c/4f8/e50c4c4f806f423ab6ca6253c403ebdd.png"><br><br>  Unfortunately, neither rand () nor mt_rand () can be considered suitable tools to ensure a high level of security. <br><br>  If you need to get random data, use the <a href="http://us3.php.net/openssl_random_pseudo_bytes">openssl_random_pseudo_bytes ()</a> function, which is available starting from version 5.3.0.  She even has a crypto_strong flag that will report a sufficient level of security. <br><br>  Usage example: <br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomBytes</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($byteLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* *   openssl_random_pseudo_bytes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (function_exists(<span class="hljs-string"><span class="hljs-string">'openssl_random_pseudo_bytes'</span></span>)) { $randomBytes = openssl_random_pseudo_bytes($byteLength, $cryptoStrong); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($cryptoStrong) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $randomBytes; } <span class="hljs-comment"><span class="hljs-comment">/* *  openssl_random_pseudo_bytes       * ,      */</span></span> $hash = <span class="hljs-string"><span class="hljs-string">''</span></span>; $randomBytes = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *  Linux/UNIX- /dev/urandom    , *       $hash */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_exists(<span class="hljs-string"><span class="hljs-string">'/dev/urandom'</span></span>)) { $fp = fopen(<span class="hljs-string"><span class="hljs-string">'/dev/urandom'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($fp) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (function_exists(<span class="hljs-string"><span class="hljs-string">'stream_set_read_buffer'</span></span>)) { stream_set_read_buffer($fp, <span class="hljs-number"><span class="hljs-number">0</span></span>); } $hash = fread($fp, $byteLength); fclose($fp); } } <span class="hljs-comment"><span class="hljs-comment">/* *     mt_rand(),    rand()! */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $byteLength; $i ++) { $hash = hash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>, $hash . mt_rand()); $char = mt_rand(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">62</span></span>); $randomBytes .= chr(hexdec($hash[$char] . $hash[$char + <span class="hljs-number"><span class="hljs-number">1</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $randomBytes; }</code> </pre> <br><h1>  Password stretching </h1><br>  You can embed password stretching, this makes brute force attacks more difficult.  Stretching is an iterative, or recursive, algorithm that calculates the hash itself over and over again, tens of thousands of times (or even more). <br><br><img src="https://habrastorage.org/files/fca/4f0/e50/fca4f0e50e8d468a8b37667f8d272cc2.jpg"><br><br>  The number of iterations should be such that the total computation time takes at least one second.  The longer the hashing is obtained, the more time the attacker has to spend on hacking. <br><br>  To crack a password with a stretch you need: <br><ol><li>  know the exact number of iterations, since any deviation will be given by another hash; </li><li>  wait at least a second between each attempt. </li></ol><br>  This makes the attack very unlikely ... but not impossible.  To overcome the second delay, the attacker must use a more productive computer than the one that the hashing algorithm was configured for.  Consequently, the hacking process may require additional costs. <br><br>  To stretch a password, you can use standard algorithms, such as PBDKDF2, which is a <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B0">key generation function</a> : <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *    ,     *  CPU/GPU.       * (      ).   *  ,   !   : - * http://ru.wikipedia.org/wiki/PBKDF2 - http://www.ietf.org/rfc/rfc2898.txt */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pbkdf2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($password, $salt, $rounds = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">15000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $keyLength = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $hashAlgorithm = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'sha256'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $start = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Key blocks to compute $keyBlocks = $start + $keyLength; // Derived key $derivedKey = ''; // Create key for ($block = 1; $block &lt;= $keyBlocks; $block ++) { // Initial hash for this block $iteratedBlock = $hash = hash_hmac($hashAlgorithm, $salt . pack('N', $block), $password, true); // Perform block iterations for ($i = 1; $i &lt; $rounds; $i ++) { // XOR each iteration $iteratedBlock ^= ($hash = hash_hmac($hashAlgorithm, $hash, $password, true)); } // Append iterated block $derivedKey .= $iteratedBlock; } // Return derived key of correct length return base64_encode(substr($derivedKey, $start, $keyLength)); }</span></span></code> </pre><br>  There are more time-consuming and memory-intensive algorithms, for example bcrypt (we'll talk about it below) or scrypt: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">// bcrypt    crypt() $hash = crypt($pasword, '$2a$' . $cost . '$' . $salt);</span></span></code> </pre><br><ul><li>  $ cost - the coefficient of labor intensity; </li><li>  $ salt is a random string.  It can be generated, for example, using the secure_rand () function described above. </li></ul><br>  The coefficient of complexity depends entirely on the machine on which the hashing is performed.  You can start from 09 and gradually increase until the duration of the operation reaches one second.  Starting from version 5.5, you can use the password_hash () function, we'll talk about this later. <br><br>  Currently PHP does not support scrypt, but you can use the <a href="https://github.com/DomBlack/php-scrypt">implementation from Domblack</a> . <br><br><h1>  The use of encryption technology </h1><br>  Many are confused in terms of "hashing" and "encryption".  As mentioned above, a hash is the result of a pseudo-random function, while encryption is the implementation of a <b>pseudo-random transformation</b> : the input data is divided into parts and processed in such a way that the result becomes indistinguishable from the result of a full-fledged random number generator.  However, in this case, you can perform the inverse transform and restore the original data.  The transformation is carried out with the help of a cryptokey, without which it is impossible to perform the inverse transformation. <br><br>  There is one more important difference between encryption and hashing: the size of the output message space is unlimited and depends on the size of the input data in a 1: 1 ratio.  Therefore, there is no risk of collisions. <br><br>  It is necessary to pay great attention to the use of encryption.  Do not think that to protect important data, it is enough just to encrypt it using some algorithm.  There are many ways to steal data.  The main rule is to never engage in amateur activities and use ready-made, tested implementations. <br><br>  Some time ago, Adobe had a powerful user database leak due to improperly implemented encryption.  Let's see what happened to them. <br><br><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2014/02/1392508204schema.png" alt="image"><br><br>  Suppose that the following data is stored in a table in plain text: <br><br><img src="https://habrastorage.org/files/f8b/2f8/9aa/f8b2f89aaf67418199e509d29e91ae9e.png"><br><br>  Someone at Adobe decided to encrypt passwords, but he made two big mistakes: <br><ol><li>  used the same crypto switch; </li><li>  left passwordHint fields unencrypted. </li></ol><br>  Suppose, after encryption, the table began to look like this: <br><br><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2014/02/1392508200pwdciphered.png" alt="image"><br><br>  We do not know which crypto switch was used.  But if you analyze the data, you can see that the same password is used in lines 2 and 7, as well as in lines 3 and 6. <br><br>  It's time to go to the password hint.  In line 6, this is ‚ÄúI'm one!‚Äù, Which is completely uninformative.  But thanks to line 3, we can assume that the password is queen.  Lines 2 and 7 separately do not allow to calculate the password, but if we analyze them together, then we can assume that this is halloween. <br><br>  For the sake of reducing the risk of data leakage, it is better to use different hashing methods.  And if you need to encrypt passwords, then pay attention to custom encryption: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/cBT5QXBbXY0%3Ffeature%3Doembed&amp;xid=17259,1500004,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhBib190smF97ynsfNTAlp25HnfFQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Suppose we have thousands of users and we want to encrypt all passwords.  As shown above, it is better to avoid using a single cryptokey.  But we cannot make a unique key for each user either, since the key storage itself will become a problem.  In this case, it is enough to use a common crypto switch for all, but at the same time to do a ‚Äúsetting‚Äù, unique for each user.  The combination of the key and the "settings" will be a unique key for each user. <br><br>  The simplest option ‚Äúsettings‚Äù is the so-called <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587">primary key</a> , unique for each entry in the table.  It is not recommended to use it in life, here it is shown only as an example: <br><br>  f (key, primaryKey) = key + primaryKey <br><br>  Here, the key and the primary key are simply linked together.  But to ensure security, you should apply a hashing algorithm or a key derivation function to them.  Also, instead of the primary key, you can use a <a href="https://ru.wikipedia.org/wiki/Nonce">one-time key</a> (an analogue of salt) for each record. <br><br>  If we apply custom encryption to our table, it will look like this: <br><br><img src="http://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2014/02/1392508518encrypted.png" alt="image"><br><br>  Of course, it will be necessary to do something else with the password hints, but still, at least something adequate has already happened. <br><br>  Please note that encryption is not an ideal solution for storing passwords.  Due to threats of code injection, it is better to avoid this method of protection.  For storing passwords, it is safest to use the bcrypt algorithm.  But we must not forget that even the best and proven solutions have vulnerabilities. <br><br><h1>  PHP 5.5 </h1><br>  Today, bcrypt is considered the best way to hash passwords.  But many developers still prefer older and weaker algorithms like MD5 and SHA-1.  And some do not even use salt when hashing.  In PHP 5.5, a new hashing API was introduced, which not only encourages the use of bcrypt, but also makes it much easier to work with.  Let's take a look at the basics of using this new API. <br><br>  Here are four simple functions: <br><ul><li>  password_hash () - password hashing; </li><li>  password_verify () - compare password with hash; </li><li>  password_needs_rehash () - password rehashes; </li><li>  password_get_info () - returns the name of the hashing algorithm and the options used during the hashing. </li></ul><br><h1>  password_hash () </h1><br>  Despite the high level of security provided by the crypt () function, many find it too complicated, which is why programmers often make mistakes.  Instead, some developers use a combination of weak algorithms and weak salts to generate hashes: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $hash = md5($password . $salt); <span class="hljs-comment"><span class="hljs-comment">// ,    </span></span></code> </pre><br>  The password_hash () function makes life easier for the developer and increases the security of the code.  To hash a password, it is enough to feed its functions, and it will return a hash that can be placed in the database: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $hash = password_hash($passwod, PASSWORD_DEFAULT);</code> </pre><br>  And that's it!  The first argument is a password as a string, the second argument is a hash generation algorithm.  The default is bcrypt, but if necessary, you can add a stronger algorithm that will allow you to generate strings of greater length.  If you use PASSWORD_DEFAULT in your project, make sure that the column width for storing hashes is at least 60 characters.  It is better to set 255 characters immediately.  As the second argument, you can use PASSWORD_BCRYPT.  In this case, the hash will always be 60 characters long. <br><br>  Note that you do not need to set the salt value or value parameter.  The new API will do everything for you.  Since salt is part of the hash, you do not have to store it separately.  If you still need to set your salt value (or value), then this can be done using the third argument: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $options = [ <span class="hljs-string"><span class="hljs-string">'salt'</span></span> =&gt; custom_function_for_salt(), <span class="hljs-comment"><span class="hljs-comment">//      'cost' =&gt; 12 //     10 ]; $hash = password_hash($password, PASSWORD_DEFAULT, $options);</span></span></code> </pre><br>  All this will allow you to use the latest security features.  If later a stronger hashing algorithm appears in PHP, your code will use it automatically. <br><br><h1>  password_verify () </h1><br>  Now consider the function of comparing a password with a hash.  The first is entered by the user, and the second we take from the database.  Password and hash are used as two arguments to the password_verify () function.  If the hash matches the password, the function returns true. <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (password_verify($password, $hash)) { <span class="hljs-comment"><span class="hljs-comment">// ! } else { //   }</span></span></code> </pre><br>  Remember that salt is part of a hash, so it is not specified separately here. <br><br><h1>  password_needs_rehash () </h1><br>  If you want to increase the security level by adding a stronger salt or by increasing the cost parameter, or the default hashing algorithm changes, then you probably want to overwrite all existing passwords.  This function will help to check each hash for which algorithm and parameters were used when creating it: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (password_needs_rehash($hash, PASSWORD_DEFAULT, [<span class="hljs-string"><span class="hljs-string">'cost'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>])) { <span class="hljs-comment"><span class="hljs-comment">//   ,     //          12 $hash = password_hash($password, PASSWORD_DEFAULT, ['cost' =&gt; 12]); //     ! }</span></span></code> </pre><br>  Do not forget that you will need to do this at the moment when the user tries to log in, as this is the only time you will have access to the password in the form of plain text. <br><br><h1>  password_get_info () </h1><br>  This function takes a hash and returns an associative array of three elements: <br><ul><li>  algo - constant, which allows to identify the algorithm; </li><li>  algoName - the name of the algorithm used; </li><li>  options - values ‚Äã‚Äãof different options used for hashing. </li></ul><br><h1>  Earlier versions of PHP </h1><br>  As you can see, it is easier to work with the new API than with the awkward crypt () function.  If you are using earlier versions of PHP, I recommend paying attention to the <a href="https://github.com/ircmaxell/password_compat">password_compact</a> library.  It emulates this API and automatically shuts down when you upgrade to version 5.5. <br><br><h1>  Conclusion </h1><br>  Unfortunately, there is still no perfect solution for data protection.  In addition, there is always the risk of hacking your security system.  However, the fight projectile and armor does not stop.  For example, our arsenal of remedies has recently been supplemented with so-called <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B3%25D1%2583%25D0%25B1%25D0%25BA%25D0%25B8">sponge functions</a> . </div><p>Source: <a href="https://habr.com/ru/post/271245/">https://habr.com/ru/post/271245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271235/index.html">How we tested the Russian workflow system on the Scala-R convergent platform</a></li>
<li><a href="../271237/index.html">Features of creating a turnkey web project from Startup Makers</a></li>
<li><a href="../271239/index.html">Testing a web service on Go</a></li>
<li><a href="../271241/index.html">Forecasting in the gaming industry. Part 3: Forecasts for the forecast industry</a></li>
<li><a href="../271243/index.html">ActiveRecord-based Ruby REST API for accessing tables in a database</a></li>
<li><a href="../271249/index.html">Modular ASP.NET 5 Application</a></li>
<li><a href="../271255/index.html">Objective-C: how blocks work</a></li>
<li><a href="../271257/index.html">Classic cryptanalysis</a></li>
<li><a href="../271259/index.html">Two-factor authentication of Cisco AnyConnect clients. FreeRadius and Google Authenticator</a></li>
<li><a href="../271261/index.html">PBX in your pocket: set up IP telephony for remote work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>