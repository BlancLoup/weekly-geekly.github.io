<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>jsonex - simplify complex client-server dialogs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The interaction between the client and the server is usually very simple and relies on a rather primitive toolkit. This does not create problems in an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>jsonex - simplify complex client-server dialogs</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e3d/7cf/309/e3d7cf3099649da9afd3ced531f84abe.png"><br><br>  The interaction between the client and the server is usually very simple and relies on a rather primitive toolkit.  This does not create problems in and of itself, but often even a slight complication of the task set doesn‚Äôt fit well with the usual approaches, giving rise to not very elegant patch solutions.  Many tasks are solved in each new project anew, haphazardly and independently from each other.  Such tasks include, for example: <br><br><ul><li>  Batch requests </li><li>  Date transfer as part of a complex data structure </li><li>  Designation of custom data types </li><li>  Forwarding round-trip data that the server should return in response </li><li>  Supplementing the request and response with metadata </li><li>  Handling errors that came in response </li></ul><br>  Developers spend a lot of time over and over again creating odd bikes on the server side, after which they also have to be supported on the client side. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      jsonex is an attempt to combine the solution of the above and many other tasks within a simple unified approach based on the concept of computable data (callable data). <br><a name="habracut"></a><br><h5>  Content </h5><br>  <a href="https://habr.com/ru/post/224261/">jsonex</a> <br>  <a href="https://habr.com/ru/post/224261/">Call notation</a> <br>  <a href="https://habr.com/ru/post/224261/">Context</a> <br>  <a href="https://habr.com/ru/post/224261/">Communication jsonex and JS</a> <br>  <a href="https://habr.com/ru/post/224261/">Callable data</a> <br>  <a href="https://habr.com/ru/post/224261/">Customer perspective</a> <br>  <a href="https://habr.com/ru/post/224261/">Benefits of Computable Data</a> <br>  <a href="&amp;xid=17259,15700023,15700043,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhhb1N6WvOTdE5gVqkA5QY0GYGBKyw#">Work with HTTP and web sockets</a> <br>  <a href="https://habr.com/ru/post/224261/">Safety considerations</a> <br>  <a href="https://habr.com/ru/post/224261/">JSON representation</a> <br>  <a href="https://habr.com/ru/post/224261/">Asynchronous calls</a> <br>  <a href="https://habr.com/ru/post/224261/">Arc</a> <br>  <a href="https://habr.com/ru/post/224261/">Conclusion</a> <br><br><h4><a name="jsonex"></a>  jsonex </h4><br>  The concept of computable data is simple and can be used for a wide variety of data formats.  A little further I will tell you how to use it <a href="https://habr.com/ru/post/224261/">in the framework of the JSON representation</a> .  But in order to demonstrate the idea in its pure form, let's start from afar. <br><br>  In many cases we use JSON, and it is beautiful.  It is simple, easy to read, allows you to represent hierarchical data structures, is widely supported.  However, some things would like to be improved, for example: <br><br><ul><li>  Allow comments </li><li>  Allow apostrophes for strings </li><li>  Allow to lower quotes for keys in dictionaries </li><li>  Allow trailing commas in dictionaries and lists </li></ul><br>  Our extended version of JSON (let's call it jsonex) could look, for example, like this: <br><br><pre><code class="javascript hljs">{ <span class="hljs-comment"><span class="hljs-comment">//  name: 'John', familyName: 'Smith', dateOfBirth: '1901-01-01', friendIds: [ 124124, 283746, /*   */ ], num: 123, }</span></span></code> </pre> <br>  Already not bad.  I would give a lot for the opportunity to write comments in JSON-configs.  But there is one rather dubious line in this example: <br><br><pre> <code class="javascript hljs"> dateOfBirth: <span class="hljs-string"><span class="hljs-string">'1901-01-01'</span></span>,</code> </pre><br>  What is it?  Line?  Date?  A person can guess from the context, but the parser is unlikely to be just as thoughtful.  Date type is not provided by the format.  To recognize it, you can use two approaches - to describe the data scheme, or use some kind of annotation hint, which could direct the parser in the right direction. <br><br>  JSON does not initially require a scheme, and it would be strange to require its presence just for the sake of being able to prompt the parser in which of the fields the date lies.  So let's go the second way.  You can think of many ways to add annotations for a date, but it would be nice to have a simple and at the same time universal way to designate any type of data.  Call notation is fine for this purpose. <br><br><h4><a name="call_notation"></a>  Call notation </h4><br>  Let's write our field like this: <br><br><pre> <code class="javascript hljs"> dateOfBirth: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-string"><span class="hljs-string">'1901-01-01'</span></span>),</code> </pre><br>  Now the data type looks obvious.  But what exactly should a parser do when it encounters a similar entry?  The approach is quite straightforward.  Having encountered a construction like <code>SomeName(args...)</code> parser should: <br><br><ul><li>  Find in your bins a predefined handler function named <code>SomeName</code> </li><li>  Execute this function on <code>args...</code> arguments <code>args...</code> </li><li>  Use the result of its execution in the processed data instead of the original construction </li></ul><br>  Thus, the result of the analysis depends entirely on the implementation of the handler function.  Our <code>Date('1901-01-01')</code> call <code>Date('1901-01-01')</code> will turn into a <code>Date</code> object in JavaScript, <code>date</code> or <code>datetime</code> in Python, and so on. <br><br>  In the case when the parser cannot find a handler with the specified name, it calls the default handler, which will either return something reasonable or throw an exception. <br><br>  It may seem that, processing the call notation, we simply execute an arbitrary piece of code contained in the data, but this is not so: <br><ul><li>  Data remains data and processing control is completely on our side. </li><li>  The parser cannot use any functions other than the explicitly defined handlers. </li><li>  Any handler function is defined by us and can perform any preliminary checks before performing active actions. </li></ul><br>  Next we look at these points in more detail.  In the meantime, note that the call notation gives us just amazing flexibility.  Adding new handlers we can easily expand the system: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlers = { <span class="hljs-attr"><span class="hljs-attr">Date</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(v); }, <span class="hljs-attr"><span class="hljs-attr">Complex</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, real, imag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Complex(real, imag); }, <span class="hljs-attr"><span class="hljs-attr">ArrayBuffer</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base64DecToArr(v).buffer; }, <span class="hljs-attr"><span class="hljs-attr">Person</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, personDataDict</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(personDataDict); } }; <span class="hljs-comment"><span class="hljs-comment">//    ,        var person = new JsonexParser(handlers).parse( "Person({"+ " name: 'John',"+ " dateOfBirth: Date('1901-01-01'),"+ " i: Complex(0, 1),"+ " song: ArrayBuffer('Q2FsbCBub3RhdGlvbiBpcyBjb29sIQ=='),"+ "})" );</span></span></code> </pre><br>  Here we added the possibility of parsing dates, complex numbers, binary data in the base64 representation - all this is literally a few lines of code and without changing the structure of our hypothetical parser. <br><br><h4><a name="context"></a>  Context </h4><br>  As you can see, each handler, in addition to its own arguments, takes the <code>ctx</code> parameter.  This parameter passes the processing context.  At this stage, we assume that <code>ctx</code> is initially empty dictionary.  Thanks to the context, we can: <br><br><ul><li>  Allow handlers to "communicate" with each other </li><li>  Passing some settings to handlers </li><li>  Pass additional data to the handlers from the external environment </li><li>  Save additional information received during parsing </li></ul><br>  For example, using the context, it is easy to create <code>get</code> and <code>set</code> handlers that allow using previously computed objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlers = { <span class="hljs-comment"><span class="hljs-comment">//         set: function (ctx, key, data) { ctx.box = ctx.box || {}; ctx.box[key] = data; return data; }, //  ,    get: function (ctx, key) { return ctx.box ? ctx.box[key] : undefined; } }; var data = new JsonexParser(handlers).parse( "[ set('x', { a: 'a' }), get('x') ]" ); data[0].a = 5; //  data[0]  data[1]         console.log(JSON.stringify(data)); // [{"a":5},{"a":5}]</span></span></code> </pre><br><h4><a name="js"></a>  Communication jsonex and JS </h4><br>  Like JSON, jsonex is closely related to JS syntax.  It is a syntactically correct JS expression, and in the simplest cases, it can even be computed as a JS expression, provided that each call notation is defined in the context of evaluation.  For example, <br><br><pre> <code class="javascript hljs">[ foo(), bar.baz() <span class="hljs-comment"><span class="hljs-comment">// , jsonex      ]</span></span></code> </pre><br>  is a correct and, moreover, a computable JS-expression, provided that <code>foo</code> and <code>bar</code> are defined correctly. <br><br>  This, of course, does not mean that it is worth taking and calculating jsonex with <code>eval()</code> , defining the necessary variables in the corresponding closure.  In addition to potential security problems, this approach loses some of the flexibility that makes it possible to analyze data as data rather than as something performed.  However, in some cases jsonex can really be considered as a limited subset of JS and consider jsonex data as a JS expression. <br><br><h4><a name="callable_data"></a>  Callable data </h4><br>  The data in jsonex is a computable expression that can be easily analyzed before computing or directly in the calculation process.  Why not use such expressions as server requests?  For example, a query might look like this: <br><br><pre> <code class="javascript hljs">getUsers([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>])</code> </pre><br>  The server could calculate it using the appropriate handler: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlers = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, userIds</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfUsers = getUsersFromDbOrWhatever(userIds); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listOfUsers; } };</code> </pre><br>  Then serialize the result in jsonex and send a response to the client: <br><br><pre> <code class="javascript hljs">[ User({<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, ...}), ...]</code> </pre><br><br>  The client will receive data with honest objects, ready to use.  At the same time, the server turns into a simple calculator of jsonex expressions.  To extend the API, it‚Äôs enough to add a new handler - you don‚Äôt have to mess around with urls, parse arguments, bring them to the necessary types, distinguish between GET and POST, everything will work. <br><br><h4><a name="client"></a>  Customer perspective </h4><br>  Let's think about how to organize a call from the client.  It would be inconvenient to compile the jsonex representation manually as strings of the type <code>"getUsers([1, 15, 7])"</code> .  Therefore, an auxiliary object describing the call notation and understood by the serializer is useful to us.  This is how its use might look like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getUsers = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userIds</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> jsonex.Call(<span class="hljs-string"><span class="hljs-string">'getUsers'</span></span>, userIds); <span class="hljs-comment"><span class="hljs-comment">//   }; //     jsonex.stringify(getUsers([1, 15, 7])); // 'getUsers([1,15,7])'</span></span></code> </pre><br>  In this case, the request to the server might look like this: <br><br><pre> <code class="javascript hljs">server.ask( getUsers([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]), <span class="hljs-comment"><span class="hljs-comment">//  function (err, result) { //   ... } );</span></span></code> </pre><br>  <code>server.ask()</code> should do the following: <br><br><ul><li>  Turn the first argument to jsonex </li><li>  Send it as a request to the server </li><li>  Wait for the jsonex-response and parse it </li><li>  Give the result to the callback function </li></ul><br>  In our example, the first argument will be the value that <code>getUsers()</code> returns, that is, an object of type <code>jsonex.Call</code> , which is serialized to the string <code>'getUsers([1,15,7])'</code> <br><br>  Looks simple and pretty.  In terms of writing code, all actions are performed on ready-to-use objects, any transformations are hidden under the hood.  The example uses callback, but when using Promise, everything will look even nicer. <br><br>  If the result received from the server is a successor to the Error class, <code>server.ask()</code> assumes that the server returned an error and calls a callback with the appropriate arguments.  This approach is possible, since the result of parsing is a ready-to-use object of the desired class. <br><br>  Accordingly, in order to inform the client about the error, it is enough for the server to return an object of the required class using the appropriate call notation.  In this case, the client must implement a handler that replaces this notation with an object of the class inherited from Error. <br><br>  Example of server response with an error message: <br><br><pre> <code class="javascript hljs">UnexpectedError(<span class="hljs-string"><span class="hljs-string">'Error details message'</span></span>)</code> </pre><br>  Handler example: <br><br><pre> <code class="javascript hljs">handlers.UnexpectedError = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerError(msg); <span class="hljs-comment"><span class="hljs-comment">// ServerError    Error };</span></span></code> </pre><br><h4><a name="callable_data_advantages"></a>  Benefits of Computable Data </h4><br>  What computable data gives us: <br><br><ul><li>  The ability to specify the types of transmitted objects </li><li>  Standardized error handling - just return the object of the desired type. </li><li>  Batch requests are implemented elementarily </li><li>  Batch requests for steroids - the results of some calls can be used as arguments of others </li><li>  Easy to forward round-trip data </li><li>  Easily convey additional information - any headers and metadata that should be taken into account when processing, but should not be mixed with other data </li></ul><br>  A batch request, for example, might look like this: <br><br><pre> <code class="javascript hljs">[ getFoo(), getBar(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), ]</code> </pre><br>  In response, an array with the results of <code>getFoo()</code> and <code>getBar()</code> calls will come. <br><br>  Use the result of one calculation in another: <br><br><pre> <code class="javascript hljs">[ set(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, getUserBooks(<span class="hljs-number"><span class="hljs-number">17</span></span>)), <span class="hljs-comment"><span class="hljs-comment">//    17 getAuthors( //    getProps( //   'authorId'     get('x') get('x'), 'authorId' ) ), ]</span></span></code> </pre><br>  The answer will be an array with a list of books and a list of authors of these books. <br>  <i>Note:</i> In this example, a call to <code>getProps()</code> can be potentially dangerous, presenting the possibility of reaching out to properties that you might not want to disclose - be careful with implementing such handlers. <br><br>  Transfer round-trip data: <br><br><pre> <code class="javascript hljs">[ <span class="hljs-number"><span class="hljs-number">137</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ,  , , id  someRequest(...) ]</span></span></code> </pre><br>  The response will be an array with the number 137 and the result of the call to <code>someRequest()</code> . <br>  <i>Note:</i> In reality, we would have to use a more complex structure to ensure that round-trip data is returned, even if an exception is thrown during processing of <code>someRequest()</code> . <br><br>  Transfer of additional data: <br><br><pre> <code class="javascript hljs">last( <span class="hljs-comment"><span class="hljs-comment">//    metaInfo('   ', 1, 3, 4), someRequest(...) )</span></span></code> </pre><br>  Here, the <code>metaInfo()</code> call can change something in the context, trigger additional actions, or somehow affect processing, but its return value will not be returned, since <code>last()</code> will return only its last argument. <br><br><h4><a name="http"></a>  Work with HTTP and web sockets </h4><br>  An HTTP request, in addition to the main data (the request body), contains the path, method, and headers.  The HTTP response contains a return code.  When using jsonex, it is convenient to use a single path for all requests, just as is usually done for batch requests and when interacting with web sockets.  You can scatter API in different ways, but it rarely makes sense. <br><br>  We do not need the HTTP method, since each request can include any calls, both receiving data and changing them.  However, support for various HTTP methods can be useful or even necessary to ensure proper operation with browsers, proxy servers and the rest of the HTTP world.  It is easy to implement; it is enough to add request and response objects to the evaluation context, and our handlers can take into account the subtleties of the HTTP protocol.  The same applies to the return code.  It is not needed as part of jsonex computing, but for proper interaction with the HTTP environment, it is worth exposing it correctly. <br><br>  As for the transfer of the data themselves, everything is fine when they are transmitted in the body of the HTTP request.  In most cases, it will be so, since using the POST method for jsonex requests looks reasonable.  But if GET, HEAD or DELETE is used for some purposes, you will have to pass data as part of the URL, since according to the standard, the body of these requests should be ignored.  There is a simple and cheap way to do this - pass jsonex in a single parameter query string, for example, <code>query</code> .  Thus, the <code>getUsers([1,2,3])</code> request <code>getUsers([1,2,3])</code> will turn into a call to <code><a href="http://example.com/api%3Fquery%3DgetUsers%2528%255B1%252C2%252C3%255D%2529"></a> example.com/api?query=getUsers%28%5B1%2C2%2C3%5D%29</code> <br> <br>  It looks awful, but since this is an internal API call, only programmers will see it during the debugging process.  This approach is often used to transfer data in JSON-format, since it greatly facilitates both the packaging on the client side and unpacking on the server side.  If the scary addresses are still confusing, it‚Äôs easy to write tools that will hide them under the hood. <br><br>  To transfer metadata, you can use both HTTP headers and jsonex features: <br><br><pre> <code class="javascript hljs">last( authToken(<span class="hljs-string"><span class="hljs-string">'myAuthToken'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//   ,   someOtherHeader('blah blah'), getUsers([1, 15]) )</span></span></code> </pre><br>  Since there is no regular way for web sockets to transfer headers with each message, the ability to integrate such data into the request itself is very convenient.  For web sockets it is also important to have round-trip data and no need to specify the path and method for each request. <br><br>  For HTTP, the idempotency of requests is also important.  This property is determined by the HTTP method: some methods must be idempotent, others are not.  Since a jsonex request can be a mixture of idempotent and nonidempotent calls, we need a mechanism to do something about it.  For example, you can cock a flag that requires idempotency and check it in calls: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlers = { <span class="hljs-attr"><span class="hljs-attr">idempotent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ ctx.mustBeIdempotent = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, updateUser(ctx, userData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.mustBeIdempotent) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NonIdempotentCallError(<span class="hljs-string"><span class="hljs-string">'updateUser'</span></span>); } ... } };</code> </pre><br>  Request example: <br><br><pre> <code class="javascript hljs">last( idempotent(), [ getUsers([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]), updateUser({<span class="hljs-attr"><span class="hljs-attr">id</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, ...}) <span class="hljs-comment"><span class="hljs-comment">//   ] )</span></span></code> </pre><br>  Which of the calls are idempotent should be clear from the API documentation, and the call <code>idempotent()</code> will give us confidence that nothing dangerous is used in a complex query. <br><br><h4><a name="security"></a>  Safety considerations </h4><br>  When creating handlers, you need to remember that in the request they can be called with any arguments and in any combinations.  So that this does not lead to security problems, you should adhere to some restrictions: <br><br><ul><li>  Handlers must not perform potentially dangerous system actions. </li><li>  Handlers are required to check their arguments and avoid unintended use. </li><li>  Handlers are required to check the amount of data in their arguments, limiting the size of the processing package to a reasonable value. </li><li>  Handlers should check access rights if this is provided by the system. </li><li>  Total computational complex query should be limited </li></ul><br>  The last point imposes a restriction on the request as a whole and deserves separate consideration.  The easiest way to control the complexity of a query is to calculate it as it is calculated and stop if a certain threshold is exceeded: <br><br><pre> <code class="javascript hljs">handlers.expesiveCall = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, args...</span></span></span><span class="hljs-function">) </span></span>{ ctx.cost += calcCost(args...); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.cost &gt; ctx.costThreshold) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TooExpensiveError(); } ... } };</code> </pre><br>  When calculating the cost, arguments must be taken into account, since the nature and amount of the data transferred to them can greatly influence the computational complexity. <br><br>  Another option may be a preliminary analysis of the request as a whole.  This is possible because the request is just data.  But analyzing complex queries can in itself be a daunting task, the computational complexity of which also has to be monitored. <br><br>  Another approach is to run calculations in a sandbox with artificially limited access to resources.  If the environment allows you to do it easily and cheaply, this can be a good option. <br><br>  It is important to remember that a combination of handlers can potentially have an effect that cannot be achieved using the same handlers separately.  This fact may conceal new threats, but they are easy to avoid.  If a subset of handlers gives rise to fear in terms of unexpected combinations with others, they can always be put into a separate, isolated set.  This set can be accessed at a specific address, or activated by adding special metadata to the request, imposing the necessary restrictions. <br><br>  In the extreme case, a number of handlers can be allowed to be used only one by one, or in combination with very primitive calls such as <code>Date()</code> .  These handlers will essentially return to the familiar model, which does not allow more than one call in the request.  Computable data provide ample opportunities, but if necessary they are easy to limit. <br><br><h4><a name="json"></a>  JSON representation </h4><br>  If you want to use jsonex right now, you will encounter one problem - unlike JSON, high-performance parsing and serialization libraries jsonex, to put it mildly, are not yet so widely available) But there is a solution - you can use jsonex based on its JSON representation.  jsonex turns into JSON using three simple rules: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   f(...) =&gt; {"?": ["f", ...]} //   '?' {'?': value, ...} =&gt; {"?": ["?", value], ...} //  ,    f({...}) =&gt; {"?": "f", ...}</span></span></code> </pre><br>  The first rule shows how to write a call notation in the JSON representation.  At the same time, the dictionary has the property '?'  acquires special significance.  The second rule answers the question of how to write an ordinary dictionary with the property '?'  so as not to confuse it with the call notation.  And the third is syntactic sugar, a special form of recording call notation for cases when it has a single argument and this argument is a dictionary.  Here is an example of the data in jsonex and theirs in the JSON representation: <br><br><pre> <code class="javascript hljs">Person({ <span class="hljs-comment"><span class="hljs-comment">//  Person name: 'John', dateOfBirth: Date('1901-01-01'), i: Complex(0, 1), d: { '?': 123 } })</span></span></code> </pre><br>  JSON representation: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"?"</span></span>: <span class="hljs-string"><span class="hljs-string">"Person"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"dateOfBirth"</span></span>: {<span class="hljs-string"><span class="hljs-string">"?"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Date"</span></span>, <span class="hljs-string"><span class="hljs-string">"1901-01-01"</span></span>]}, <span class="hljs-string"><span class="hljs-string">"i"</span></span>: {<span class="hljs-string"><span class="hljs-string">"?"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Complex"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]}, <span class="hljs-string"><span class="hljs-string">"d"</span></span>: {<span class="hljs-string"><span class="hljs-string">"?"</span></span>: [<span class="hljs-string"><span class="hljs-string">"?"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>]} }</code> </pre><br><br>  JSON representation looks more complicated, but it means the same thing.  It can be <code>JSON.parse()</code> standard <code>JSON.parse()</code> , and then doiscalculate with the second pass.  Or, in some simple cases, it can be calculated directly during parsing using the reviver function passed to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse ()</a> .  The same goes for serialization to the JSON representation ‚Äî it is easy to do with the help of the replacer function passed to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify ()</a> . <br><br>  Generally speaking, the concept of computable data can be added as an extension to almost any data format. <br><br><h4><a name="async"></a>  Asynchronous calls </h4><br>  In the examples shown earlier, it was implicitly assumed that all calls are synchronous.  Consider one of them more closely: <br><br><pre> <code class="javascript hljs">[ set(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, getUserBooks(<span class="hljs-number"><span class="hljs-number">17</span></span>)), getAuthors(getProps(get(<span class="hljs-string"><span class="hljs-string">'x'</span></span>), <span class="hljs-string"><span class="hljs-string">'authorId'</span></span>)), ]</code> </pre><br>  <code>getUserBooks()</code> and <code>getAuthors()</code> should probably go to some kind of data storage, enable I / O and, accordingly, be asynchronous.  So we can not calculate them on the spot.  And even if we can (for example, using <a href="https://github.com/laverdet/node-fibers/">fibers</a> ), I would still like to be able to make independent asynchronous calls in parallel, and not one after the other. <br><br>  The solution could be a computational engine that would place asynchronous calls in a queue for execution, and then substitute the results in the right places.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, having calculated all the synchronous parts, we would wait for the asynchronous execution and after that we considered that the calculation is ready. You can use something like </font></font><a href="https://github.com/caolan/async"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async.queue ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as a queue for execution </font><font style="vertical-align: inherit;">, performing tasks with a given level of parallelism. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in fact, the task is more difficult. In our example, the calculation of some calls depends on others; we cannot calculate </font></font><code>set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until we calculate </font></font><code>getUserBooks()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Therefore, when we try to call </font></font><code>set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we must postpone this calculation, indicating to all the calculations on which it depends, that, once they are ready, it is necessary to do the computation </font></font><code>set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Here we depend on exactly one deferred calculation </font></font><code>getUserBooks()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but more complex dependencies are possible.</font></font><br><br>  But that's not all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The call is </font></font><code>get()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not able to return anything useful until it is completed </font></font><code>set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Therefore, </font></font><code>get()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it should also be a pending calculation, this time waiting for a signal from </font></font><code>set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In turn, </font></font><code>getProps()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depends on </font></font><code>get()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>getAuthors()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depends on </font></font><code>getProps()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our computational engine will have to take into account all these dependencies and perform all pending calculations in the right order. </font><font style="vertical-align: inherit;">This seems to be not a very simple task, so I would like to have an implementation that proves the efficiency of the approach.</font></font><br><br><h4><a name="arc"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arc </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="https://github.com/dimsmol/arc_jsonex_js"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">was created to show that the concept of computable data is viable, including in the case of asynchronous handlers and dependent calls. The engine itself is very simple, it consists of several hundred lines of code and at the moment does not contain any clever optimizations, which makes it very understandable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source data for the engine is a stream of tokens. Currently, tokenization is only available for JSON representation, but working with jsonex is not far off the line. Arc can be used both in node.js and in a browser using </font></font><a href="http://browserify.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">browserify</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Writing asynchronous handlers for arc looks very simple, just wrap an asynchronous call into the appropriate directive, and the engine will do all the hard work under the hood:</font></font><br><br><pre> <code class="javascript hljs">handlers.getUserBooks = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, userId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb</span></span></span><span class="hljs-function">) </span></span>{ doSomethingAsync(...args, cb); }); };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While only callbacks are supported, Promise support is scheduled. Examples of using the engine, as well as serialization in jsonex and JSON representation can be seen in the </font></font><a href="https://github.com/dimsmol/arc_jsonex_js/tree/master/example"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponding section</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Surprisingly, after just a few hours from the moment the article was laid out, arc had </font></font><a href="https://github.com/mayorovp/jsonex"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an alternative</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The hacker user </font></font><a href="https://habrahabr.ru/users/mayorovp/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayorovp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> presented his version of the jsonex parsing library in a JSON representation. This library version consists of a single file, has no dependencies, uses the standard one </font></font><code>JSON.parse()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and supports </font></font><a href="http://promises-aplus.github.io/promises-spec/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A + promise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Unfortunately due to limitations</font></font><code>JSON.parse()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in this implementation, the processing of asynchronous calls will not be as effective, so it is made disconnected. </font><font style="vertical-align: inherit;">Here is an example of using an alternative library with jQuery:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONEX.parser({ <span class="hljs-attr"><span class="hljs-attr">allow_async</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">functions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">Foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = $.Deferred(); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ result.resolve(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.promise(); } }}); $.when(parser.parse(<span class="hljs-string"><span class="hljs-string">'[{"?": ["Foo"]}]'</span></span>)) .done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); });</code> </pre><br><h4><a name="final"></a>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both jsonex and arc are currently under development. </font><font style="vertical-align: inherit;">The jsonex features mentioned in this article probably won't change, but new ones will be added, such as namespaces, binary parts (binary chunks), streaming data (streams), and scopes. </font><font style="vertical-align: inherit;">Arc is likely to change quite a bit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By virtue of the novelty and nekatannosti presented ideas, I would recommend using them with some caution. </font><font style="vertical-align: inherit;">Nevertheless, I will be very happy if you like some of them and will be useful in your projects and experiments. </font><font style="vertical-align: inherit;">I would also appreciate it if you share your impressions, experiences and discoveries.</font></font></div><p>Source: <a href="https://habr.com/ru/post/224261/">https://habr.com/ru/post/224261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224249/index.html">What awaits us in Django 1.7</a></li>
<li><a href="../224251/index.html">Captain Obvious: How We Invented Google Analytics For Witget</a></li>
<li><a href="../224253/index.html">Competition of flying robots, stage number 2: now not a million, but 5 times 200 thousand times</a></li>
<li><a href="../224255/index.html">Short post about the benefits of search engine optimization</a></li>
<li><a href="../22426/index.html">Terry White answered the questions of the masters.</a></li>
<li><a href="../224263/index.html">How I coped with the password-protected RAR-archive</a></li>
<li><a href="../224273/index.html">See you at DevCon 2014!</a></li>
<li><a href="../224275/index.html">Redmine warning plugin</a></li>
<li><a href="../224279/index.html">High-frequency trading and everything you need to know about it. Part 1</a></li>
<li><a href="../224281/index.html">String.Intern makes strings more interesting.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>