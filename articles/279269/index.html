<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Custom floating point format on FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 This article will discuss floating-point numbers and, in particular, the implementation of the FP23 specialized format on programmable logic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Custom floating point format on FPGA</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  This article will discuss floating-point numbers and, in particular, the implementation of the FP23 specialized format on programmable logic integrated circuits (FPGAs).  As part of a specific project, I had the idea to implement the floating-point data format that is optimal for certain needs.  As a result, this idea grew into a real project, which later found application in some interesting problems of digital signal processing.  The article discusses the main difficulties in implementing the floating point data format on the Xilinx FPGA, describes the basic mathematical operations in the FP23 format.  Also at the end of the article you can find the source code of the project, which can be used freely in your tasks or on its basis implement similar data formats. <br><br><img src="https://habrastorage.org/files/60f/91e/6b7/60f91e6b77404332b23fb29db343277c.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Data format </h4><br>  Numbers with a floating point are actively used in modern signal processors, video cards and even in FPGA.  In accordance with the <b>IEEE 754</b> standard, they are represented as a set of exponents (exponent), mantissa and sign.  Numbers in the IEEE 754 standard have 32 bits ( <i>float</i> ).  For the sake of unambiguity, the numbers written in float are written in normal form or reduced to normalized form after mathematical operations and conversions on numbers.  The range of possible values ‚Äã‚Äãdepends on the number of bits of the mantissa and the exponent.  Float has a fixed relative accuracy and variable absolute accuracy.  The main advantages and disadvantages of numbers in float format: <br><ul><li>  + A very wide range of possible values ‚Äã‚Äãis provided; </li><li>  + High accuracy is achieved; </li><li>  - Rounding of very large numbers to the values ‚Äã‚Äãpossible from the grid; </li><li>  - Loss of accuracy when summing numbers that are different from each other many times; </li><li>  - The complexity of implementation and application on the FPGA. </li></ul><br>  For modern FPGA chips, the implementation of floating-point numbers is easy.  For the leading manufacturers - Xilinx and Altera there are ready-made SOFT IP-cores that implement float according to the standard.  For Altera, the latest families feature HARD IP cores that implement the IEEE 754 format on DSP blocks. <br><br><h4>  Digital part </h4><br>  The main element base for performing mathematical operations and digital signal processing tasks is the advanced FPGA families.  The work is carried out on the FPGA company Xilinx, which contain blocks of vectors of configurable cells.  First of all, these are universal blocks of digital processing and mathematics - DSP48E1 (for the FPGA of the Virtex-6 and 7 series of the family) and DSP48E2 (for the FPGA of the UltraScale family).  These blocks allow you to perform the functions of addition and subtraction of numbers, shift and transfer, high-speed multiplication, multiplication with accumulation (MACC), search for checksum, etc.  The DSP48 cells in modern FPGAs perform many tasks ‚Äî developing CIC and FIR filters, speeding up FFT / IFFT, implementing digital frequency synthesizers (DDS and CORDIC), creating various data presentation formats and a set of operations for them. <br><br>  The second basic component of the FPGA is block memory.  For the Xilinx FPGA, these are RAMB36E1 (or RAMB18E1) cells.  These are elements of two-port memory, implemented inside the crystals in the form of columns of identical blocks.  The number of columns of internal memory depends on the volume of the crystal.  The maximum memory block size is 36Kbps, and it can be configured as two independent blocks of 18Kbps each.  Memory can be used with data widths from 1 to 72 bits.  In the absence of free resources of the block memory FPGA, you can use the distributed memory in special cells SLICEM.  For Ultrascale FPGAs, the amount of such memory is up to 512x1, with the ability to reconfigure the depth and bitness of the bus. <br><br><h4>  Formulation of the problem </h4><br>  Taking into account the listed features for the implementation of the analog and digital parts, the task is formed as follows.  Let the bit width of the data arriving in the FPGA chip with ADC microcircuits is 16 bits.  The smallest Kintex-7 chip is chosen as the FPGA.  The task is to translate the 16-bit signed integer number FIX16 into a specialized floating-point format FP23 and vice versa, while ensuring <b>maximum processing speed</b> inside the FPGA with <b>minimal expenditure of</b> crystal <b>resources</b> .  In addition, it is necessary to designate and implement a set of basic mathematical operations - addition, subtraction and multiplication. <br><br><h4>  FP format implementation </h4><br>  FP23 is a special floating point representation format.  Unlike the IEEE 754 standard, the word length in the FP23 format is not 32 bits, but only 23 bits.  The following formula in a simplified form reflects the representation of the number "A" in FP format: <br><img src="https://habrastorage.org/files/a67/31f/4fe/a6731f4fee184e2e85d3648fbf63fd10.png"><br><br>  The <i>mantissa</i> ( <i>mantissa</i> ) in FP23 format is a 17-bit positive number.  It is always displayed in normalized form as a result of all transformations, i.e.  the highest bit of the mantissa is always ‚Äú1‚Äù.  To conserve crystal resources and simplify writing, the 17th bit of the mantissa is never displayed in the packed 23-bit resulting word (see figure).  Therefore, when calculating mathematical operations and transferring from one format to another, it must be remembered that the mantissa is normalized, and a 16-bit nonzero number must be added to 216. The exponent or <i>exponent</i> in FP23 format is a 6-bit positive number that determines how much the mantissa is multiplied.  Under the sign ( <i>sign</i> ), the remaining one bit is allocated, the zero value of the bit corresponds to positive numbers, and the single value determines negative numbers.  Thus, the number A in the FP23 format is described by three bit fields: the ‚Äúexponent‚Äù <b>(EXP (A))</b> , the ‚Äúsign‚Äù <b>(SIGN (A))</b> and the ‚Äúmantissa‚Äù <b>(MAN (A))</b> . <br><img src="https://habrastorage.org/files/0c0/905/403/0c0905403a764b24aa05832ebf6ea71d.png"><br><br>  Table 1 shows the data width, the range of possible values ‚Äã‚Äãof mantissa and exponent, etc. <br><img src="https://habrastorage.org/files/183/934/8f4/1839348f4ad34026a46bcf4a607e6c32.png"><br><br>  So, the first step in developing a floating-point data format on the FPGA consists in translating the signed integer number of a fixed width into the FP23 floating-point format, while ensuring the maximum processing speed inside the FPGA.  The second stage consists in the inverse transformation of numbers from the FP23 format to the fixed-point format with the possibility of scaling the output data to a certain division factor.  And finally, at the third stage, in order to fully utilize the full power of the FP23 format, it is necessary to implement mathematical operations - addition, subtraction and multiplication. <br><br>  Before describing the FP23 modules, you must answer the legitimate question: ‚ÄúWhy is the data width in the format of exactly 23 bits?‚Äù The answer consists of several components.  First, one bit is used for the sign and the 15 bits remaining for the whole part, so the mantissa and the sign occupy at least 16 bits.  For an exponent with a shift in the formula, a minimum of 5 bits is required.  The more bits allocated to the exponent, the greater the result (the range of possible values ‚Äã‚Äãis expanded).  Let the exponent have 6 digits, and the mantissa is represented as a 16-bit number, 1 digit is assigned to the sign.  Then, 23 bits are used to represent numbers in the FP23 format.  If you use the hidden bit of the mantissa, which is 1 for non-zero values ‚Äã‚Äãand 0 for zero values ‚Äã‚Äãof a binary number, then the bit depth is 24. <br><br>  In addition, the value "23" was not chosen randomly, because  in future, the storage of the vector of complex values ‚Äã‚Äãwill require FPGA memory.  A pair of values ‚Äã‚Äãwithout displaying a hidden bit has a total bit width of 46, with a hidden bit - 48, which is exactly three RAMB18E1 blocks of data width.  Also, for a pair of values, you can use the additional functions of the DSP48E1 ¬¨ block ‚Äî a quick comparison of two numbers, a parity check, and a fast summation in SIMD mode. <br><br><h4>  FIX16-to-FP23 conversion </h4><br>  To convert data from the integer signed type FIX16 to the FP23 format, it is necessary to use the FPGA chip logic and the built-in multipliers of DSP48E1.  The figure shows a block diagram of the data conversion in FP23 format. <br><img src="https://habrastorage.org/files/570/91e/e4f/57091ee4f1e34282a5d5b23b2f5c5e50.png"><br><br>  The maximum bit depth of the multipliers of the DSP48E1 blocks is 25 and 18, respectively, where the most significant bit is sign.  To multiply numbers without a sign in the DSP48E1 module, the effective width of the input data is reduced by 1 bit.  RAMB18E1 block memory is not used by the converter. <br>  Accordingly, in order to find the sign of a number, it is necessary to take the most significant (sign) bit of the input data.  The algorithm for searching for the MAN (A) mantissa based on FPGA primitives is as follows: <br><ul><li>  take the input number module (XOR operation), </li><li>  search for the most significant bit (MSB SEEKER), </li><li>  on the most significant bit to form the magnitude of the shift of the mantissa, </li><li>  multiply the modulus of the number and the shift value, resulting in a normalized mantissa (FRAC SHIFTER). </li></ul><br>  To search for exponent exp (a) you need: <br><ul><li>  take the input number module (XOR operation), </li><li>  search for the most significant bit (MSB SEEKER), </li><li>  subtract from the number ‚Äú32‚Äù the inverted index of the significant bit, </li><li>  add 1 to the result, taking into account the logic of finding a non-zero input value (LUT ZERO FORMER). </li></ul><br>  Since the mantissa is obtained by multiplying the modulus of a real number by a certain ‚Äúmask‚Äù on which the shift of the input number depends on an unsigned number, the DSP48E1 block is required to find it.  The procedure for searching and forming the mantissa occurs in the FRAC SHIFTER node and is shown in the figure. <br><img src="https://habrastorage.org/files/e58/94c/c42/e5894cc4221f49748bd37e6a38c52b6e.png"><br><br>  As can be seen, the mantissa is formed in two stages.  In the first stage, a factor of 2 <sup>16-MSB</sup> is created from the input number using logical LUT resources.  In the second stage, the input data is multiplied by the amount of shift in the DSP48E1 node.  At the output of the multiplier, a normalized mantissa is formed.  According to the description, for the multiplication of unsigned numbers, the maximum width of one of the factors of the DSP48E1 block is 17, therefore, the mantissa and the generated shift cannot have a greater bit depth.  This restriction once again causes the fact that the mantissa of numbers in the FP23 format has a bit depth of 17. The most significant bit of the mantissa for non-zero numbers is 1, reserved and used in the search for the resulting mantissa, but is not displayed in the output representation of the number for the normalized form.  This bit can be output and used in the general representation of the word, then the word length of the output word is 24 bits. <br><br>  To reduce the amount of crystal resources occupied, the DSP48E1 unit can be eliminated.  Then the mantissa search node is converted to a fast shift register (Barrel shifter).  For some FPGA crystals, the number of DSP48E1 is small, and unnecessary waste of resources is critical, so when using FP23 blocks, it is possible to choose one or another option.  In addition, for the case of using the fast shift, the total delay for the complete execution of the conversion operation is reduced by one cycle. <br><br>  Summation nodes for search exponents are made in the form of full binary adders, for the implementation of which the logical components MUXCY, XORCY and CARRY CHAIN ‚Äã‚Äãare used, which are included in the basic SLICEL and SLICEM cells.  A detailed description can be found in any literature on programmable logic. <br><br><div class="spoiler">  <b class="spoiler_title">Sample time diagrams</b> <div class="spoiler_text">  Converting data from FIX to FLOAT FP23: <br><img src="https://habrastorage.org/files/e04/315/ed8/e04315ed86964b5abd1d8b7cfb3eb37e.png"><br>  DIN - input data, 16 bits.  DOUT - a number in the FP23 format, divided into three fields: <i>{EXP, SIGN, MANT}</i> . <br></div></div><br><h4>  Convert FP23-to-FIX16 </h4><br>  Converting data from FP23 format to FIX16 is done in four steps. <br><img src="https://habrastorage.org/files/440/ed9/ed5/440ed9ed5e6e4e11b7c3ba9a48bf494b.png"><br><br>  The binary sign A search algorithm consists of several sequential actions: <br><ul><li>  from exponent EXP (A) subtract the value of SCALE (output scaling), </li><li>  create a shear mask 2 (EXP (A) -SCALE), </li><li>  add the hidden IMPL bit (A) to the mantissa and multiply the result by the amount of shift, </li><li>  take into account the sign of the number of SIGN (A) by taking the operation "exclusive OR". </li></ul><br>  As for the direct conversion node to the FP23 format, in this scheme, to save FPGA resources, the DSP48E1 block can be replaced with a fast shift register executed on SLICEM cells. <br><br><h4>  Multiplication </h4><br>  Multiplication of numbers in the FP23 format is one of the most simple and logical operations.  The hardware multiplication algorithm is implemented as follows (see figure). <br><ul><li>  multiplication mantis in the node DSP48E1, </li><li>  normalization of the mantissa (taking as a mantissa of bits [32 ... 17] or [31 ... 16], depending on the value of the most significant bit), </li><li>  addition of exhibitors </li><li>  subtracting from the sum of the exponent of the number 16, </li><li>  if the 33rd bit of the mantissa is ‚Äú0‚Äù, then 1 is subtracted from the result exponent, </li><li>  definition of the mark of the work using the XOR operation. </li></ul><br><img src="https://habrastorage.org/files/c3d/cf4/57e/c3dcf457e658406b9729a2a763ecb022.png"><br><br>  The scheme does not reflect the logic of multiplying by zero, but algorithmically it boils down to the fact that if the exponent of any input number is zero, then the result at the output is also zero.  On the FPGA, the search for zero is organized using the logical functions AND and OR on the base blocks of the LUT. <br><br>  The number 16 is subtracted from the sum of the exponents to account for the hidden bits in the mantissa of the input numbers, which give an increase to the exponents.  Adders and subtractors in the node multiplying numbers in a floating point are also implemented according to the scheme of a binary full adder. <br><br><h4>  Addition and subtraction </h4><br>  Adding and subtracting numbers in the FP23 format is the most resource-consuming operation (see figure).  Adding numbers in the FP23 format consists of the following fundamental stages: <br><ul><li>  casting operands to one exponent (alignment), </li><li>  addition of mantis, </li><li>  normalization of the result (selection of such an exponent so that the 16 bits of the mantissa is equal to "1"). </li></ul><br><img src="https://habrastorage.org/files/c58/6b1/3e4/c586b13e47c746ca827fdc624e44ca30.png"><br><br>  Hardware addition algorithm is implemented as follows: <br><ul><li>  operands ‚ÄúA‚Äù and ‚ÄúB‚Äù are compared in absolute value if | A | &lt;| B |, the numbers are swapped, </li><li>  the difference between the exponents of the operands is calculated, and the result determines how many digits you need to move the mantissa of the number ‚ÄúB‚Äù to the right to bring the numbers to one exponent, </li><li>  by the difference of the exponent, the number is generated by which the mantissa of the number "B" is multiplied </li><li>  the result of multiplication is added to the mantissa of the number ‚ÄúA‚Äù, </li><li>  in the resulting number is determined by the number of the most significant bit of the MSB, the number is formed, </li><li>  normalization of the mantissa by multiplying the sum of the mantissas by the number, </li><li>  exponent of the number EXP ¬© = EXP (A) - MSB + 1. </li></ul><br>  Subtraction is implemented similar to addition.  The only difference is that the sign <b>SIGN (B) is</b> inverted in the subtracted operand.  DSP48E1 blocks can also be replaced with a fast shift register. <br><br><h4>  Resources </h4><br>  The results of the synthesis and the propagation delay for the operation for each node are summarized in Table 2. The table shows that the simplest and fastest operation is to multiply two numbers in the FP23 format. <br><img src="https://habrastorage.org/files/9f1/b49/0ca/9f1b490ca53944d3b867eaa97139e9a9.png"><br><br>  The volume of resources occupied after synthesis for all nodes is given in a common log file.  An example of the results of the synthesis for the multiplier fp23: <br><br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Top</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Level</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Output</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">File</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Name</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">fp23_mult_m1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ngc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Primitive</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">and</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Black</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Box</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Usage</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">------------------------------</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">BELS</span></span> : 106 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">GND</span></span> : 15 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">INV</span></span> : 1 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUT2</span></span> : 25 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUT3</span></span> : 16 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUT4</span></span> : 6 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUT6</span></span> : 14 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">MUXCY</span></span> : 14 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">VCC</span></span> : 1 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">XORCY</span></span> : 14 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">FlipFlops</span></span>/<span class="hljs-selector-tag"><span class="hljs-selector-tag">Latches</span></span> : 75 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Shift</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Registers</span></span> : 8 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">SRLC16E</span></span> : 8 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">DSPs</span></span> : 1 # <span class="hljs-selector-tag"><span class="hljs-selector-tag">DSP48E1</span></span> : 1</code> </pre> <br><br><h4>  Source </h4><br>  All FP23 format nodes are written in VHDL.  For convenience and testing in C ++, a small program is written that contains the functions of the implemented operations in a floating point on the FPGA.  With its help, you can debug and implement other formats with a floating point with different dimensions of the exponent and the mantissa. <br><br>  For the convenience of reading data on VHDL, a type is created that defines a number in floating-point format.  All components and types of FP23 are collected in the file <i>fp_m1_pkg.vhd</i> <br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> fp23_data <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> exp : <span class="hljs-built_in"><span class="hljs-built_in">std_logic_vector</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); sig : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span>; man : <span class="hljs-built_in"><span class="hljs-built_in">std_logic_vector</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span>;</code> </pre><br>  The source code of the RTL descriptions, the testing program and the results of the synthesis can be found at the link to <a href="https://github.com/capitanov/fp23_logic"><b>github</b></a> . <br><br><h4>  Test case </h4><br>  To test all the developed nodes, I came up with a small circuit.  This is a complex multiplier, at the input and output of which data is presented in integer form, and intermediate results in a floating point.  That is, the input data is converted to FP23 format.  In this format, complex multiplication is implemented, and the result is transferred back from FP23 to a fixed point.  The block diagram in the RTL Viewer is as follows: <br><img src="https://habrastorage.org/files/189/6e6/2c5/1896e62c55ac4cd3b28f0e6882cc3b09.png"><br><br>  In PlanAhead, the location of the complex multiplier is shown in the following figure.  FPGA Kintex-7, <b>XC7K70TFBG484-1C</b> . <br><img src="https://habrastorage.org/files/b55/29f/bc7/b5529fbc7eb0432f8e524114ab504b5f.png"><br><br>  It is seen that as a result of the complete project tracing, a processing frequency of about <b>300 MHz is reached</b> .  In practice, this figure is <b>~ 30%</b> higher. <br><br>  In the FPGA Editor, the regular multiplier block in the FP23 format looks like this: <br><img src="https://habrastorage.org/files/f9a/e10/20e/f9ae1020eb50456b93f360d96ca2a5c3.png"><br><br><h4>  Conclusion </h4><br>  As a result of the work, a specialized data format for floating point FP23 on the FPGA was developed.  It differs from the traditional IEEE 754 format and is sharpened for processing on the FPGA at maximum speeds.  Unlike standard solutions from Xilinx and Altera, nodes in the FP23 format occupy significantly less crystal resources.  The operations of addition and multiplication in FP23 have been used to implement FIR filters and an FFT / OBPF node on FPGAs. <br><br>  If you wish, you can create your own data format " <b>FP_X</b> " for specific tasks with an arbitrary bit depth of mantissa and exponent.  In this case, it is necessary to take into account the features and structure of specific FPGAs. <br><br>  My articles on similar topics: <br><ul><li>  <a href="http://geektimes.ru/post/266888/">Digital filtering on FPGA - 1 (CIC filters)</a> </li><li>  <a href="http://geektimes.ru/post/267098/">Digital filtering on FPGA - 2 (FIR filters)</a> </li></ul><br><h4>  Literature </h4><br><ul><li>  <a href="http://www.xilinx.com/">Xilinx datasheets</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Floating_point">IEEE 754 Floating-point</a> </li></ul><br>  <i>Thanks for attention!</i>  <i>To be continued...</i> </div><p>Source: <a href="https://habr.com/ru/post/279269/">https://habr.com/ru/post/279269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279255/index.html">Explaining the inexplicable. Part 3</a></li>
<li><a href="../279257/index.html">Yandex is killing a business, or be careful with the #main block</a></li>
<li><a href="../279261/index.html">No one wants to use your product.</a></li>
<li><a href="../279263/index.html">Welcome to Android Devs Meetup March 17</a></li>
<li><a href="../279267/index.html">Android client for rutracker: bypass the blocking using Google Compression proxy</a></li>
<li><a href="../279275/index.html">CLRium # 3. Announcement of speakers</a></li>
<li><a href="../279277/index.html">Connect to the Jump Start online event March 15: "Infrastructure as an Azure Resource Manager-based service"</a></li>
<li><a href="../279279/index.html">1.5 Compiling SFML with CMake</a></li>
<li><a href="../279281/index.html">Containerization mechanisms: namespaces</a></li>
<li><a href="../279283/index.html">What is Cisco ONE?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>