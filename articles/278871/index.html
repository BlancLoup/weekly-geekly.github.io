<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit for node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GitHub and NPM libraries. 


 some unknown aggregate that is not related to node.js. But on Habr√© is considered a good form to attach a picture 

 Som...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit for node.js</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://github.com/jabher/agregate">GitHub</a> and <a href="https://www.npmjs.com/package/agregate">NPM</a> libraries. <br><br><img src="https://habrastorage.org/files/143/80b/c5e/14380bc5e2164333bd59da1f987c3adb.jpg"><br>  <em>some unknown aggregate that is not related to node.js.</em>  <em>But on Habr√© is considered a good form to attach a picture</em> <br><br>  Some time ago I wondered why, in node.js, working with relational databases, such as * SQL, and some noSQL type Mongo, is difficult, and made an alternative solution, tailored to the speed of the programmer‚Äôs work (compared to the classic solutions, work with the database) and the straightness and compactness of the API for the minimum threshold of entry.  The first source of inspiration was the report <a href="http://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html">"minimal surface API"</a> , the second - the famous <a href="http://c2.com/cgi/wiki%3FPrematureOptimization">quote by</a> Donald Kruta: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Programmers spend an abnormal amount of time worrying about the speed of non-critical parts of applications, and these attempts to improve efficiency seriously negatively affect the debugging and support of these applications.  <strong>Premature optimization is the root of all evil</strong> . </blockquote><a name="habracut"></a><br>  <em>Dixler 1: The library described here is in the early beta stage.</em>  <em>So far you should not use it for commercial or critical projects for your life.</em> <br><br>  <em>Disclaimer 2: complex terms can be found in the text, and in the code examples there are many ES6 features.</em>  <em>If something seems incomprehensible - please write in the comments, I will try to simplify the text and add comments to the code.</em> <br><br>  When I used sequelize - do not hope, other libraries are not better - I could not help wondering why working with it is so difficult.  Not in terms of understanding how it works from the inside, no - I was digging into the library interface.  Either the hands are not growing from there, or the developers are hardened DBAs, not like me. <br><br>  Now I know what they were trying to put in the toolkit that they could.  The output is the 15th standard, combining the previous 14. Indicative in this regard is the hellish juggling combine, which is able to make an extremely diverse list of databases - MySQL, SQlite3, Postgres, CouchDB, Mongo, Redis, Neo4j. <br><br>  But for me for small projects - all sorts of telegram bots, server devs and SPAs - there was no need for a complex part of the functionality, which is under the hood of complex ORM-ok.  The basic required functional is the saving and searching of records, sampling by conditions and relationships.  I do not need <strong>premature optimizations</strong> : sampling parts of fields from the database, tricky query optimizations, stored functions.  Sampling with respect to (get the object and all the links) can be made a transaction.  Due to the loss in speed, we get the absence of a heap of additional entities of declarative syntax.  Occam's razor in its purest form. <br><br>  <em>Lyrical digression: if you look at the history of the development of projects with tens and hundreds of thousands of users - after a certain time, developers run into speed.</em>  <em>They change queries, database, languages, platforms, so that it works.</em>  <em>If the project shoots out - he will have to replace parts, and the first one will work with the base under the knife - if not enough effort was spent initially ‚Äúfor the future‚Äù.</em>  <em>At the same time, the heavy, complex ORM syntax complicates the replacement.</em>  <em>The conclusion is obvious - if you evaluate the choice of ORM as an uncontested future technical debt, the correct choice may be a solution with less efficiency, but ensuring the speed of the developer and providing a minimal API, which simplifies the transition to another solution.</em> <br><br><h4>  I made an assembly </h4><br>  Not a DB, but a JS-centric ActiveRecord - however, in some places I have moved away from the classic pattern. <br><br>  It is important to understand that since it is not DB-centric - the database was selected for solution requests, and not the decision was made for a specific database.  Storage was chosen Neo4j.  This solution has pros and cons, but for now there are more pros. <br><br>  <em>If you are not familiar with neo4j, this is a popular graph database with a much more comprehensible for the outsider than SQL, a language, a convenient web client and full-text out-of-box indexes (using lucene), and a slightly lower (linear) speed compared to Postgres / Mysql.</em>  <em>All installation instructions are here: <a href="http://neo4j.com/download-thanks/%3Fedition%3Dcommunity">http://neo4j.com/download-thanks/?edition=community</a> .</em>  <em>On the mac it is installed via brew install neo4j</em> <br><br>  Let's start with a simple connection and entries: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {Connection, Record} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'agregate'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbPath = <span class="hljs-string"><span class="hljs-string">'http://neo4j:password@localhost:7474'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectedRecord</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Record</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Connection(dbPath); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectedRecord</span></span></span><span class="hljs-class"> </span></span>{} User.register() <span class="hljs-comment"><span class="hljs-comment">//  ,     const user = new User({name: 'foo'}) user.surname = 'bar' user.save() .then(() =&gt; User.where({name: 'foo'})) .then(([user]) =&gt; console.log(user)) //=&gt; User {name: 'foo', surname: 'bar'}</span></span></code> </pre> <br>  The only thing that stands out from the clarity of the code - call User.register ().  In JS, it is impossible to hang up a handler (and thank the developers of the language for this) to create a class, so you have to do it for the language. <br><br>  The Record.register method does 3 things: <br><br><ol><li>  registers this class for an existing connection to the database.  Simply put - in the Map inside the connection the association "label" - "class" is inserted.  When resolving associations (about them later), it is this map that is used to turn database objects into JS objects. <br><br></li><li>  runs internal library processes (indexing and uuid uniqueness for security reasons) <br><br></li><li>  starts the indexing of user indices (if they have been defined for this class). </li></ol><br>  For abstract classes, this method does not need to be called. <br><br>  In ES2015, static properties are inherited in the same way as properties of an entity ‚Äî connecton is declared once, in the parent class, as shown.  If you have one database, you can assign a connection to Record.connection, although this is incorrect from the development point of view. <br><br><h4>  Relations and Connections </h4><br>  Let's complicate the example.  Imagine that we are doing an ACL, and we need a relationship: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {Connection, Record, Relation} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'agregate'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  Role  Permission     const Role = require('./role'); const Permission = require('./permission'); export default class User extends ConnectedRecord { roles = new Relation(this, 'has_role', {target: Role}); permissions = new Relation(this.roles, 'has_permission', {target: Permission}); hasPermission = ::this.permissions.has }</span></span></code> </pre> <br>  If you do not look closely - do not immediately see that in fact this.permissions - many-to-many through the relationship.  This kind of syntax allows you to build long chains of relationships for which full-fledged queries are available - search, delete, check for availability, everything, except for obvious reasons not working Relation # add. <br><br>  Relation emulates the Set object built into ES6.  The API is different, but immediately familiar and understandable.  The difference is that methods return a Promise, which already returns data, and size () a method, not a property.  Additionally, there were methods #intersect, which returns the intersection of the transferred array of elements with the related elements, and #where, which does the obvious, but about it below. <br><br><h4>  Search by database </h4><br>  Methods with an identical API are available for this: the class method Record.where () and the instance method of the class Relation # where ().  Available are offset, limit, order by, search by value, the contents of the array and entry into the array (yes, the typed array is one of the primitives in neo4j) and the substring.  There are many possibilities for searching.  They cover all the main tasks.  Enumerating all the options is quite difficult, so it‚Äôs easier to look at the formal description in a typescript-like syntax: <br><br><pre> <code class="hljs cmake">var dbPrimitiveType = bool | <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | number | Array&lt;bool&gt; | Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; | Array&lt;number&gt; async <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> where( params?: { [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: queryKey]: dbPrimitiveType | { $gt?: number //<span class="hljs-keyword"><span class="hljs-keyword">greater</span></span> than -  $gte?: number //<span class="hljs-keyword"><span class="hljs-keyword">greater</span></span> than <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">equal</span></span> -    $lt?: number //<span class="hljs-keyword"><span class="hljs-keyword">less</span></span> than -  $lte?: number //<span class="hljs-keyword"><span class="hljs-keyword">less</span></span> than <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">equal</span></span> -    $<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>?: bool //   $startsWith?: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; | <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> //  $endsWith?: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; | <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> //  $contains?: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; | <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> //  $has?: Array&lt;dbPrimitiveType&gt; | dbPrimitiveType //   $in?: Array&lt;dbPrimitiveType&gt; | dbPrimitiveType //   } }, opts?: { order?: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;; //  -  key  key DESC  key ASC,  ['created_at', 'friends DESC'] offset?: number; limit?: number; }, transaction?: Queryable): Array&lt;Record&gt;</code> </pre> <br><h3>  Transactions </h3><br>  The API described above already allows you to work.  Only the question of atomicity remains, which is classically solved with the help of transactions. <br><br>  In an aggregate, you can work with transactions in two ways - simple or understandable. <br><br>  The clear way is to use head-on transactions.  To do this, pass it with the last argument (among others).  All standard database methods support this notation. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Record</span></span></span><span class="hljs-class"> </span></span>{ author = ::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Relation(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'created'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">direction</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>}).only <span class="hljs-comment"><span class="hljs-comment">//    only,      .      ,    . async static createAndAssign(text, user) { const transaction = this.connection.transaction() const post = await new this({text}).save(transaction) await post.author(user, transaction) await transaction.commit() return post } //  ,  -     async static createAndAssign(text, user) { const transaction = this.connection.transaction() try { const post = await new this({text}).save(transaction) await post.author(user, transaction) await transaction.commit() return post } catch (e) { await transaction.rollback() throw e } } }</span></span></code> </pre> <br>  The connection object (which is available for both the class and the class instance) can be a connection, transaction, or sub-transaction.  There is no difference for use in life, because all three entities provide the same interface with small internal differences.  If you call connection.transaction (), the connection returns a transaction, the transaction returns a sub-transaction, the sub-transaction returns another sub-transaction. <br><br>  The internal difference is the following: the commit and rollback methods for connection will send an error, for a transaction, it will work as expected, for a sub-transaction - commit will do nothing, and rollback will roll back the parent transaction. <br><br>  This is done because some methods about generate a transaction for themselves and close at the end - for example, Record # save ().  To ensure that such methods work correctly within a transaction, the infinite nesting of sub-transactions is implemented. <br><br>  For the second method - simple - decorator is used: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Record, acceptsTransaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'agregate'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Record</span></span></span><span class="hljs-class"> </span></span>{ @acceptsTransaction <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> create(text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>({text}).save(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connection) } }</code> </pre> <br>  It turns the code into something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Record, acceptsTransaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'agregate'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Record</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> create(text, transaction) { <span class="hljs-comment"><span class="hljs-comment">//Queryable -  ,    Connection, Transaction, SubTransaction if (transaction instanceof Queryable) this.connection = transaction try { const result = await new this({text}).save(this.connection) if (transaction) await transaction.commit() return result } catch (e) { if (transaction) await transaction.rollback() throw e } } }</span></span></code> </pre> <br>  The decorator can be used both directly, as in the example above, and configuring.  For the configuration so far, only one flag is available - force, which forcibly creates a transaction - if a transaction is not transferred, it will create it.  You need to use this: <code>@acceptsTransaction({force: true}) ...</code> <br><br>  Note that now this.connection has become a transaction.  When the function runs, the property will return to its previous state, but now it allows you to call other methods of the class, without worrying about committing the transaction.  This magic works only within this (which is predictable). <br><br>  Since transactions are processed in turn, i.e.  until one is completed, another is not started, the object is not cloned, so consider: if you wrap the static method in this decorator, you can accidentally ‚Äúfumble‚Äù the transaction.  For class instances, this is not a problem because if you work correctly with JS, they are in their field of view, and from other execution threads (such as promises, async, etc.) you cannot access them at the same time. unavailability of the object. <br><br><h3>  That's the whole unit </h3><br>  The description of the API and the reasons why it was done this way and not otherwise, is complete. <br><br>  Probably the only thing worth adding is that I already use it in small projects for myself and friends.  I haven‚Äôt experienced such a pleasure when working with a database for a long time - I felt such a feeling of "transparency" and clarity of the working mechanisms only when working in Ruby / Rails, and even there I had to suffer from CLI in places. <br><br>  The unit may lack some capabilities or speed, but if you want this - connect to the project.  Now the <a href="https://github.com/Jabher/agregate">aggregate</a> is only 608 lines (in shock itself) of fairly well-organized code, and it is very easy to make edits, additions, updates, and do additional tests.  I would like to see it uniquely usable in a big production, and if you like it too, connect to the development! <br></div><p>Source: <a href="https://habr.com/ru/post/278871/">https://habr.com/ru/post/278871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278859/index.html">Asterisk and information about incoming calls in the browser via Notifications</a></li>
<li><a href="../278863/index.html">An example of game development based on Google Analytics data</a></li>
<li><a href="../278865/index.html">Certificate Authority Let's Encrypt has issued a million free certificates</a></li>
<li><a href="../278867/index.html">FizzBuzz problem solution</a></li>
<li><a href="../278869/index.html">We are looking for you to help you earn $ 5000 this summer</a></li>
<li><a href="../278877/index.html">Problems after migration from openvz to lxc in Proxmox 4.x</a></li>
<li><a href="../278879/index.html">Windows 10 IoT: Evolution of Development Tools</a></li>
<li><a href="../278881/index.html">We are looking for errors in the game engine Xenko</a></li>
<li><a href="../278883/index.html">Umbrella monitoring of IT resources</a></li>
<li><a href="../278885/index.html">Error in Linux kernel sends damaged TCP / IP packets to Mesos, Kubernetes and Docker containers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>