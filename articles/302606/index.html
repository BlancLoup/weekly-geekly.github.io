<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the three-dimensional Z-order put in a word</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúOnce upon a time, it seems, last Friday,‚Äù the author was struck by an article that compared various popular methods of indexing celestial objects. Du...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the three-dimensional Z-order put in a word</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/87d/9d8/410/87d9d8410fee4c34ab060ffbb051cc35.png"><br>  ‚ÄúOnce upon a time, it seems, last Friday,‚Äù the author was struck by <a href="http://skyview.gsfc.nasa.gov/xaminblog/index.php/tag/pgsphere/">an article</a> that compared various popular methods of indexing celestial objects.  Due to uneven breathing, this topic had to be understood in its intricacies and draw conclusions. <br><br>  You ask: ‚ÄúWho cares about these celestial objects?‚Äù And even: ‚ÄúWell, what does 2GIS have to do with it?‚Äù And you will be partly right.  After all, spatial indexing methods are universal value. <br><br>  Usually, when dealing with geodata, we work with a local projection onto a plane and thereby dismiss distortion.  On the scale of the planet, it is more difficult to do this - astronomical problems begin to bulge. <br>  As for data volumes, now in OSM there are more than 4 billion points and 300 million roads.  This is commensurate with the scale characteristic of stellar objects.  And among other things, star atlases are an excellent stand for developing and debugging spatial algorithms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The promised subtleties and conclusions under the cut. <br><a name="habracut"></a><br><h3>  Prelude </h3><br>  The problems of indexing celestial objects is a struggle against polar coordinates. <br>  Since objects traditionally have the coordinates RA / DEC (latitude / longitude), the length of the degree of longitude depends on the latitude, and singularities appear at the poles.  Therefore, when searching in the vicinity of a certain point, it is necessary to take into account the latitude of this point when building the search extent.  And I would like to hide these details inside the index. <br>  In the case of a spatial join, again, I do not want to load the SQL processor with various intimate details. <br><br>  So, the main external requirements for the indexing method ("pixelization") of celestial objects <a href="http://www.sai.msu.su/~megera/wiki/SkyPixelization">are as follows</a> : <br><ol><li>  Hierarchical structure. </li><li>  Equal areas.  This means that the area under the ‚Äúelementary pixel‚Äù should not (ideally) depend on the latitude and longitude. </li><li>  Isolatal distribution of data.  A good indexing method leads to the fact that at any latitude on the "elementary pixel", on average, there are the same number of objects.  For geo-objects this is not the case, by the way. </li></ol><br>  Of course, the use of a DBMS imposes its own limitations: the ‚Äúpixel‚Äù number should be easily calculated, the index should be compact, the search query should generate a moderate number of subqueries. <br><br>  There are quite a few <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2584%25D0%25B5%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B8%25D0%25BA">spherical polyhedra</a> , related methods ( <a href="https://en.wikipedia.org/wiki/HEALPix">HEALPix</a> , <a href="https://msdn.microsoft.com/en-us/library/aa964138(v%3Dsql.90).aspx">HTM</a> ).  It is possible, moreover, to undertake the paving of the sphere by such a method here (or by a similar): <br><img src="https://habrastorage.org/files/c8a/677/caa/c8a677caae3d4f70ba815e490b4afe7e.png" width="500"><br>  (The <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25BA%25D0%25B5%25D1%2582_(%25D0%25B3%25D0%25B5%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%258F)">correct heptagonal parquet of order 3 in the Poincare model on the disk</a> ) <br>  But the one who comes up with a cheap way to translate the coordinates into a pixel number for this variant and get a set of pixels along the cone risks invoking the devil. <br><br><h3>  Let's get started </h3><br>  The article mentioned compares various popular indexing methods implemented in Postgres. <br><ol><li>  <a href="https://en.wikipedia.org/wiki/Haversine_formula">HAVERSINE</a> - the DEC (declination, longitude) field is indexed, then the data is filtered; </li><li>  UNIT VECTOR - the DEC field is indexed; during filtering, the scalar product of the vector of the test point and the axis of the request cone is calculated.  The cosine of the deviation must not be less than the specified (cone query); <br></li><li>  POSTGIS - r-tree in RA (right ascension, latitude) / DEC coordinates; </li><li>  <a href="https://github.com/segasai/q3c">Q3C</a> - <br><ul><li>  when indexing <br><ol><li>  the points are projected on the faces of the cube, </li><li>  the number of the face falls into the high bits (3 bits for 6 faces) of the index value, </li><li>  The low <a href="https://en.wikipedia.org/wiki/Z-order_curve">-order</a> bits are encoded using a <a href="https://en.wikipedia.org/wiki/Z-order_curve">Z-order</a> , which turns the coordinates on the face, </li><li>  for a 32-bit value, the maximum depth level is 14 (14 * 2 + 3 = 31).  For a 64-bit value, a depth of 30 is available, but in fact 16 (see the constant Q3C_INTERLEAVED_NBITS), <br></li><li>  the calculated values ‚Äã‚Äãare placed in a regular B-tree; </li></ol></li><li>  when searching <br><ol><li>  the cone of inquiry is projected on the verge lip and forms an ellipse, </li><li>  at worst (angle) it can be three ellipses and three subqueries, </li><li>  the ellipse is rasterized on the face lattice, the result is a list of pixels covered by it, </li><li>  the pixels are translated into a Z-order and thus a list of index intervals is obtained, potentially containing the necessary data, </li><li>  then the search by index and (possibly) finer filtering takes place; </li></ol></li><li>  pros <br><ol><li>  simplicity </li><li>  regular compact index </li><li>  relatively small unequal pixel areas, </li><li>  high search speed on small queries; </li></ol></li><li>  minuses <br><ol><li>  it is still a block index.  The maximum index depth is 16 bits + 2 bits on 4 faces at the equator.  In <a href="https://ru.wikipedia.org/wiki/2MASS">2MASS, the</a> resolution of the telescope is the fractions of angular seconds, even 0.5.  We have 2 * 60 * 60 * 360 = ~ 2 ** 21, </li><li>  The index is intended for small queries.  Otherwise, the ellipse will cover a large number of intervals of the index and this will become a problem, because at this moment we do not know which of them are not empty, we‚Äôll have to check everything.  However, this is not a Z-order problem, the index with the lower-case scan would behave no better.  This problem is caused by the fact that we have no idea from the outside how the tree is actually (filled).  On the other hand, this deficiency is compensated for by the blockiness of the index, perhaps, problematic in size queries rarely occur in astronomy, </li><li>  The two moments described balance each other.  We cannot just take and increase the resolution of the index, as there will be an explosion in the number of intervals.  And we cannot reduce it, since the load on post-filtering will increase due to the coarseness of pixels; </li></ol></li></ul></li><li>  <a href="https://github.com/akorotkov/pgsphere">PGSPHERE</a> - the points are placed on a sphere of unit radius and their three-dimensional coordinates are indexed in the r-tree. <br><ul><li>  pros <br><ol><li>  great idea, </li><li>  exact index, it does not require post-filtering, </li><li>  staff index for the database; </li></ol></li><li>  minuses <br><ol><li>  r-tree is quite ‚Äúthick‚Äù, <a href="http://www.sai.msu.su/~megera/wiki/SkyPixelization">rating</a> : 4 times, </li><li>  and, therefore, page cache efficiency drops, </li><li>  the behavior of the r-tree is highly dependent on page splitting heuristics, for such specific data it would be good to choose the optimal heuristics, </li><li>  Depending on the chosen heuristic, the r-tree may begin to degrade if the data changes intensively, for a B-tree, by the way, such degradation does not occur. </li></ol></li></ul></li></ol><br><br><h3>  Actually, the results </h3><br>  Details of the comparison: <br><ul><li>  the first 2 columns - search (first and subsequent) in HEASARC dataset (36,000,000 lines) with an accuracy of 1 degree, used a series of 162 search points; </li><li>  3 and 4 columns - spatial join (with a radius of 0.01 degrees) between Swift (76.301 lines) and XMM (2,880,728 lines), the first and subsequent runs. </li></ul><br>  The relative results are as follows: <br><img src="https://habrastorage.org/files/62c/ef3/c45/62cef3c4512c467eba76421a96c6ab03.png"><br>  What should I look for? <br><ol><li>  PGSphere is far ahead of all other methods in the search.  Potentially, Q3C could be faster than PGSphere, but apparently, the shortcomings of high-level Z-order are already beginning to manifest themselves on requests with a radius of 1 degree, the number of subintervals is too large. </li><li>  PGSphere is faster than PostGIS, although a more complex three-dimensional tree is used.  This can be explained by the struggle with distortions at the poles, which do not allow to use the index at full power. </li><li>  PGSphere is slower in Q3C in spatial join'e twice.  What are the explanations? <br><ol><li>  Spatial join - a series of searches with small radii, where search queries are taken from the master table (Swift) and performed on the slave (XMM). </li><li>  In this case, the request radius is significantly less - 0.01 degrees.  At this radius, all the advantages of the Z-order are preserved and its drawbacks do not yet appear. </li><li>  The PGSphere slowdown is most likely caused by a less efficient page cache. </li></ol></li><li>  Q3C at least twice as fast as PostGIS. </li></ol><br>  It's time to ask a question from the category of "what if ...". <br><br><h3>  What if? </h3><br>  If you make a hybrid PGSphere and Q3C, where instead of the R-tree uses a three-dimensional low-level Z-order.  Why Z-order, what's good about it?  At a minimum, this indexing method automatically satisfies the three primary external requirements that are formulated at the beginning of the article.  There are "internal" advantages. <br><br><h3>  Z-order </h3><br>  One of the most famous examples of a self-similar curve sweeping a square is the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2593%25D0%25B8%25D0%25BB%25D1%258C%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582%25D0%25B0">Hilbert curve</a> .  Another slightly less well-known example is <a href="https://en.wikipedia.org/wiki/Z-order_curve">z-order</a> . <br>  Our order of detour is somewhat different from the canonical, but it does not matter. <br>  Each pair of x-bit numbers (x, y) is assigned a 2x-bit z by the following simple rule.  Bits of numbers x, y are connected into one number, just alternating with each other.  In this case, the bits of the number x occupy even positions (if one starts counting from 0), and the bits of the number y are odd. <br><br>  For a 64x64 square, it looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/f98/5e9/749/f985e9749f92e43488df5f5481e17f32.jpg" alt="image"><br>  Z-order is very useful for indexing, as it can be implemented as a regular B-tree with an integer key.  However, there are problems with effective search for it. <br><br>  The blue box in the picture is a search query.  Each time it crosses a curve, a continuous interval of key values ‚Äã‚Äãis generated (or ends). <br>  Therefore, if we process each such interval in a separate subquery, we get significant overhead, since a large part of these intervals are empty, and each subquery is a passage through the index tree. <br><br>  If we search in one interval from the beginning to the end of the extent, this is equivalent to as if we indexed one Y-coordinate and filtered it. To query 1/10 from the extent of the layer by x &amp; y (1/100 of the layer) it will be viewed 1/10 of the index - Efficiency 10%, for a request to 1/100 of the extent of the layer by x &amp; y (1/10000 of the layer) 1/100 of the index will be viewed - Efficiency 1%. <br><br>  This explains why this method is rarely used in a DBMS.  So in Q3C it is in block version.  Although self-similarity gives it a wonderful feature - adaptation to unevenly distributed data.  In addition, continuous segments of the curve can cover large areas of space, which is useful if you are able to use it. <br>  There is an effective (but very low-level) way to work with Z-order, but more on that, perhaps later.  This method also applies to the three-dimensional index. <br><br>  However, the behavior of Z-order in three-dimensional space is poorly understood and requires careful verification.  What we do. <br><br><h3>  Z-order in 3D </h3><br>  What do we want to see? <br>  How do you generally evaluate the suitability of the indexing method for processing spatial data? <br><br>  As already <a href="https://habrahabr.ru/post/186564/">mentioned</a> , no matter what we do, the index file on the physical medium (pagination) is one-dimensional, and it is impossible to arrange two (multi) dimensional data without gaps. <br>  Self-similar curves give us the ability to minimally observe the locality of the links, that is, spatially close objects and on the disk will often be close.  The most pleasant in this respect is the Hilbert curve, but it is expensive from a computational point of view.  Z-order is just a compromise between the requirements for computational simplicity and data locality. <br>  But still very often close points will be far from each other.  How to evaluate the degree of "imperfection" of indexation? <br><br>  <b>First</b> , we will proceed from the fact that the spatial index is located on the pages of the tree.  And if two points hit one page, then they are physically close, even if the corresponding Z-values ‚Äã‚Äãare very different. <br>  <b>Secondly</b> , spatial search is performed in a certain extent, therefore, the smaller the number of pages that fall into this extent, the higher the request processing speed. <br>  <b>Thirdly</b> , if the search query is smaller than the typical page size, the index is ‚Äúbetter‚Äù, the more likely it is that the search will be limited to one page. <br><br>  So, we can formulate a general rule: <br>  <b>A ‚Äúgood‚Äù indexing method minimizes the total perimeter of index pages</b> . <br>  It would be worthwhile to come up with a formal criterion for assessing quality, but sometimes it is better to see everything once with your eyes than to juggle with numbers.  And getting a general understanding of the situation can be addressed and formalization. <br><br><h3>  Numerical experiment </h3><br><div class="spoiler">  <b class="spoiler_title">Index value calculation function:</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> key3ToBits[<span class="hljs-number"><span class="hljs-number">8</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> | (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span> | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>), }; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> xy2zv(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> z) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tmp = (key3ToBits[x &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) | (key3ToBits[y &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | (key3ToBits[z &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>]); ret |= tmp &lt;&lt; (i * <span class="hljs-number"><span class="hljs-number">9</span></span>); x &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; y &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; z &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br></div></div><br>  In order to fit in 64 bits, we allow a resolution of 21 bits for the original coordinates. <br><br>  For the first series we will place on the upper hemisphere of a unit radius a point with a step of half a degree in latitude and longitude. <br>  The central part of the hemisphere looks like this (in the order of generation, the gnuplot command: 'splot' data 'wl;'): <br><img src="https://habrastorage.org/files/6e4/6d3/b16/6e46d3b16fa04ed2b8c4be5379f2e938.png"><br><br>  Now we will build Z-values ‚Äã‚Äãfor each point and sort them according to these values.  Values ‚Äã‚Äãare planted on the grid in the intervals of 0 ... 2 000 000 (ie, 21 bits).  For control, we will also build a picture for a 2-dimensional z-order (only x &amp; y, without z). <br><img src="https://habrastorage.org/files/c7e/8f1/cd1/c7e8f1cd1e7a4330bf45c00143fe7b3a.png"><br>  Fragment 3d, a general view of the crawl from above.  In addition to the "lumbago" (from transitions through the degree of 2-ki) along x &amp; y are also visible annular "lumbago" in z. <br><br><img src="https://habrastorage.org/files/23b/6f6/ea8/23b6f6ea824746e6a9a957500be5bd60.png"><br>  Same for 2d. <br><br>  Now we will simulate the distribution of data on pages on the disk.  Suppose 1000 elements fall on a page.  Then the first 1000 elements in the sorted array will go to the first page, etc.  For clarity, presented bypassing the page, but it is not important - as we have already found out, the perimeter is important. <br><table><tbody><tr><td><img src="https://habrastorage.org/files/0af/676/f87/0af676f872dd4f4bbe272482097d4b5b.png"><br>  The first 1000 values. <br></td></tr><tr><td><img src="https://habrastorage.org/files/99b/1c0/cc8/99b1c0cc8e2247d2975ca287b6a4972b.png"><br>  Values ‚Äã‚Äãfrom 9000 to 10,000. <br></td></tr><tr><td><img src="https://habrastorage.org/files/6b0/b1f/d8a/6b0b1fd8a5694afb9f1f4ba014dd60a6.png"><br>  Values ‚Äã‚Äãfrom 19,000 to 20,000. <br></td></tr><tr><td><img src="https://habrastorage.org/files/4a5/747/c35/4a5747c35274456791fd141988a938fc.png"><br>  The values ‚Äã‚Äãare from 60000 to 61000. Since the sphere in this place has practically expanded, 2d and 3d coincide. <br></td></tr><tr><td><img src="https://habrastorage.org/files/d05/edd/02f/d05edd02f4d74e8ea3043b005e221500.png"><br>  Values ‚Äã‚Äãfrom 120,000 to 121,000. Hit the node. <br></td></tr></tbody></table><br><br>  Now we prepare 150,000 random points on the sphere and do the same with them. <br>  A general view of the bypass on top is now this: <br><img src="https://habrastorage.org/files/6d6/526/e2d/6d6526e2d2554fbeb7970fe3a2709401.png"><br>  The polar region does not stand out, and it pleases. <br><img src="https://habrastorage.org/files/5e6/4ea/164/5e64ea1642ee4044a51b4ea0d0a4b1cc.png"><br>  It is almost the same for both cases. <br><br><table><tbody><tr><td><img src="https://habrastorage.org/files/fa3/988/c35/fa3988c35c054946a473ccaff8df3e4c.png"><br>  The first 1000 values. <br></td></tr><tr><td><img src="https://habrastorage.org/files/600/286/d6f/600286d6fb0f48ab924b505008946822.png"><br>  Values ‚Äã‚Äãfrom 9000 to 10,000. <br></td></tr><tr><td><img src="https://habrastorage.org/files/94a/2bb/eeb/94a2bbeeb1e84cf0892de0028c083604.png"><br>  Values ‚Äã‚Äãfrom 19,000 to 20,000. <br></td></tr><tr><td><img src="https://habrastorage.org/files/ef3/eef/b7b/ef3eefb7bed74c2abd7375b10039ed7e.png"><br>  Values ‚Äã‚Äãfrom 60,000 to 61,000. <br></td></tr><tr><td><img src="https://habrastorage.org/files/4cd/8af/eb2/4cd8afeb236d4acca6c3ddfbdb20fbde.png"><br>  Values ‚Äã‚Äãare from 120,000 to 121,000. <br></td></tr></tbody></table><br><br><h3>  findings </h3><br><ol><li>  As expected, the pseudo-three-dimensional (on the sphere) spatial index, based on the sweeping curve, behaves very much like its two-dimensional version. </li><li>  It is still easy to calculate. </li><li>  The index itself is implemented in the form of a tree structure, which is very convenient for a DBMS. </li><li>  It has all the necessary qualities for indexing celestial objects. </li></ol><br>  However, apart from the merits, he also has all the flaws of his two-dimensional version, and in a hypertrophied form.  If we try to look in the index in the forehead, looking for continuous intervals of values, we will be disappointed, these intervals have become even more.  In essence, head-on can only be searched in very small extents. <br><br>  As already mentioned, there is a method for working with such an index.  But that's another story. <br><br><h3>  PS </h3><br>  I would like to express special thanks to Sasha Artyushin from <a href="http://dataeast.ru/">DataEast</a> for conceptual participation. </div><p>Source: <a href="https://habr.com/ru/post/302606/">https://habr.com/ru/post/302606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302590/index.html">Launch queues and the Laravel scheduler in the Elastic Beanstalk environment</a></li>
<li><a href="../302594/index.html">Client-side Linq to NHibernate</a></li>
<li><a href="../302598/index.html">SMS as a secret weapon</a></li>
<li><a href="../302600/index.html">BGP Inter-AS</a></li>
<li><a href="../302602/index.html">Creating a blog on symfony 2.8 lts [Part 4]</a></li>
<li><a href="../302608/index.html">Create a secure IP messenger with Virgil and Twilio in 30 minutes</a></li>
<li><a href="../302610/index.html">How have the career ladders and elevators in the IT industry changed over the past week?</a></li>
<li><a href="../302612/index.html">A simple and free way to make payments with Payoneer</a></li>
<li><a href="../302614/index.html">The fight for the regions: How to online store to win against an offline retailer</a></li>
<li><a href="../302616/index.html">The digest of interesting materials for the mobile developer # 156 (May 30 - June 5)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>