<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Spaghetti Automatic Machines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúI love spaghetti westerns, I hate spaghetti code‚Äù 

 ‚ÄúSpaghetti code‚Äù is an ideal expression for describing software that represents smoking chaos fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Spaghetti Automatic Machines</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>‚ÄúI love spaghetti westerns, I hate spaghetti code‚Äù</i> <br><br>  ‚ÄúSpaghetti code‚Äù is an ideal expression for describing software that represents smoking chaos from both a cognitive and aesthetic point of view.  In this article I will talk about a three-point plan for the destruction of spaghetti code: <br><br><ul><li>  We discuss why spaghetti code is not so tasty. </li><li>  Introducing the new look at what the code actually does. </li><li>  We discuss the <a href="https://github.com/frame-lang/frame-machine-notation" rel="nofollow noopener">Frame Machine Notation (FMN)</a> , which helps developers unravel a tangle of pasta. </li></ul><br>  We all know how hard it is to read someone else's code.  This may be due to the fact that the task itself is complex or because the structure of the code is too ... "creative."  Often these two problems go hand in hand. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Difficult tasks are complex tasks, and usually nothing but a revolutionary discovery can simplify them.  However, it happens that the software structure itself adds unnecessary complexity, and this problem is <em>worth</em> solving. <br><br>  The ugliness of spaghetti code lies in its complex conditional logic.  And although life can be difficult to imagine without a lot of clever if-then-else constructions, this article will show you a better solution. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br>  To illustrate the situation with spaghetti code, we need to first turn it: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>Crispy Pasta</i> <br><br>  In it: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al Dente!</i> <br><br>  Let's get down to cooking. <br><br><h3>  Implicit state </h3><br>  To cook pasta, we definitely need water for cooking.  However, even such a seemingly simple element with the participation of spaghetti code can be very confusing. <br><br>  Here is a simple example: <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  What does this check actually do?  Obviously, it divides the number line into two parts, but what <em>do</em> these parts <em>mean</em> ?  I think you can make a logical assumption, but the problem is that the code does not actually communicate this <em>explicitly</em> . <br><br>  If I really confirm that it checks whether water is FIRM <i>[approx.</i>  <i>lane: Fahrenheit water freezes at +32 degrees]</i> , what would logically mean returning false? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br>  Although the check divided the numbers into two groups, in fact there are three logical states - solid, liquid and gas (SOLID, LIQUID, GAS)! <br><br>  That is, this number line: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br>  divided by the condition check as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Notice what happened, because it is very important to understand the nature of spaghetti code.  The Boolean test divided the numerical space into two parts, but did NOT categorize the system as a real logical structure from (SOLID, LIQUID, GAS).  Instead, the test divided the space into (SOLID, everything else). <br><br>  Here is a similar check: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Visually, it will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Notice that: <br><br><ol><li>  the full set of possible states is not declared anywhere </li><li>  nowhere in conditional constructions verifiable logical states or groups of states are declared </li><li>  some states are indirectly grouped by the structure of conditional logic and branching </li></ol><br>  Such code is fragile, but very common, and not large enough to cause problems with its support.  So let's make the situation worse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>I never liked your code anyway</i> <br><br>  The code shown above implies the existence of three states of matter - SOLID, LIQUID, GAS.  However, according to scientific data, there are actually <strong><em>four</em></strong> observable states in which plasma is switched on (PLASMA) (in fact there are many others, but this will be enough for us).  Although no one is preparing a plasma paste, if this code is published on Github, and then some graduate student who studies high-energy physics will fork it, we will have to maintain this state too. <br><br>  However, when adding plasma, the above code will naively do the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  It is likely that the old code, when added to the set of plasma states, will break in the branching else.  Unfortunately, nothing in the code structure helps to inform about the existence of a new state or to influence changes.  In addition, any bugs are likely to be barely noticeable, that is, they will be the most difficult to find.  Just say no to insects in spaghetti. <br><br>  In short, the problem is the following - Boolean checks are used to determine the state <em>indirectly</em> .  Logical states are often not declared and not visible in the code.  As we saw above, when the system adds new logical states, the existing code may break.  To avoid this, <strong>developers must re-examine every single conditional check and branch</strong> to make sure that the code paths are still valid for <em>all the</em> corresponding logical states!  This is the main reason for the degradation of large code fragments with their complexity. <br><br>  Although there are no ways to completely get rid of conditional data checks, any technique that minimizes them will reduce the complexity of the code. <br><br>  Let's now look at a typical object-oriented implementation of a class that creates a <em>very</em> simple model for the volume of water.  The class will manage changes in the state of the water substance.  Having studied the problems of the classical solution of this problem, we will then discuss the new notation called <strong>Frame</strong> and show how it can cope with the difficulties we found. <br><br><h3>  First bring the water to a boil ... </h3><br>  Science has given names to all possible transitions that a substance can make when temperature changes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br>  Our class is very simple (and not very useful).  It responds to calls to perform state transitions and changes the temperature until it becomes suitable for the desired target state: <br><br>  (Note: I wrote this pseudocode. Use it at work only at your own peril and risk.) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br>  Compared to the first example, this code has certain improvements.  First, the hard-coded ‚Äúmagic‚Äù numbers (32, 212) are replaced by constants of the boundaries of the temperature of the states (WATER_SOLID_TEMP, WATER_GAS_TEMP).  This change begins to make states more pronounced, albeit indirectly. <br><br>  This code also contains ‚Äúdefensive programming‚Äù checks that limit the method call if it is in the wrong state for an operation.  For example, water cannot freeze if it is not a liquid - it violates the law (of nature).  But adding watchdog conditions complicates understanding the purpose of the code.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br>  This conditional check does the following: <br><br><ol><li>  Checks if <code>temp</code> lower than GAS boundary temperature </li><li>  Checks if <code>temp</code> greater than SOLID limit temperature </li><li>  Returns an error if any of these checks were not true. </li></ol><br>  This logic is confusing.  First, being in a liquid state is determined by what a substance is <strong>not</strong> - a solid or gas. <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br>  Secondly, the code checks whether the water is liquid, to see if it is necessary to return an error. <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br>  From the first time to understand this double negation of states is not at all easy.  Here is a simplification that slightly reduces the complexity of the expression: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br>  This code is easier to understand, because the <strong>isLiquidWater</strong> state is <strong>explicitly</strong> expressed. <br><br>  Now we investigate techniques that fix an <strong>explicit state</strong> as the best way to solve problems.  With this approach, the logical states of the system become the physical structure of the software, which improves the code and simplifies its understanding. <br><br><h3>  Frame Machine Notation </h3><br>  <strong>Frame Machine Notation (FMN)</strong> is a domain-specific language (Domain Specific Language, DSL), defining a categorical, methodological and simple approach to defining and implementing various types of <em>automata</em> .  For simplicity, I will call the Frame automata simply ‚Äúmachines‚Äù, because this notation can define theoretical criteria for any different types (state machines, store automats, and the top of the evolution of automata ‚Äî Turing machines).  To know about the various types of machines and their application, I recommend to explore the page in <a href="https://en.wikipedia.org/wiki/Automata_theory" rel="nofollow noopener">Wikipedia</a> . <br><br>  Although automaton theory may be interesting (a VERY dubious statement), in this article we will focus on the practical application of these powerful concepts for creating systems and writing code. <br><br>  To solve this problem, Frame introduces a standardized notation that works on three integrated levels: <br><br><ol><li>  Text DSL for specifying Frame controllers using elegant and concise syntax </li><li>  A set of reference coding patterns for implementing object-oriented classes in the form of machines, which Frame calls "controllers" </li><li>  Visual notation in which FMN is used to express complex operations that are difficult to visualize graphically - <strong>Frame Visual Notation (FVN)</strong> </li></ol><br>  In this article I will look at the first two points: FMN and reference patterns, and leave the discussion for FVN for future articles. <br><br>  Frame is a notation, distinguished by some important aspects: <br><br><ol><li>  FMN has first-level objects related to the concept of automata, which are absent from object-oriented languages. </li><li>  The FMN specification defines standard implementation patterns in pseudocode that demonstrate how FMN notation can be implemented. </li><li>  FMN will soon be able to compile (work in progress) in any object-oriented language. </li></ol><br>  Note: The reference implementation is used to demonstrate the absolute equivalence of FMN notation and a simple way to implement it in any object-oriented language.  You can choose any method. <br><br>  Now I will introduce you to the two most important objects of the first level in Frame - <strong>Frame Events</strong> and <strong>Frame Controllers</strong> . <br><br><h3>  Frame events </h3><br>  FrameEvents are an integral part of the simplicity of FMN notation.  FrameEvent is implemented as a structure or class that at least has the following member variables: <br><br><ul><li>  message id </li><li>  dictionary or parameter list </li><li>  return object </li></ul><br>  Here is the pseudocode of the FrameEvent class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br>  The Frame notation uses the <strong>@</strong> symbol to identify the FrameEvent object.  Each of the required attributes of FrameEvent has a special token to access it: <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br>  Often we don‚Äôt have to specify what the FrameEvent works with.  Since most contexts work with only one FrameEvent at a time, the notation can be unambiguously simplified so that it uses only attribute selectors.  Therefore, we can simplify access: <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br>  Such a notation may seem strange at first, but we will soon see how such a simple syntax for events greatly simplifies the understanding of the FMN code. <br><br><h3>  Frame controllers </h3><br>  Frame Controller is an object-oriented class, ordered in a well-defined way for the implementation of the Frame machine.  Controller types are identified by the <strong>#</strong> prefix: <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  this is equivalent to the following object-oriented pseudocode: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br>  Obviously, this class is not particularly useful.  So that he can do something, the controller needs at least one state to respond to events. <br><br>  The controllers are structured in such a way as to contain blocks of various types, which are identified by a dash surrounding the type name of the block: <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br>  A controller can have no more than one instance of each block, and block types can contain only certain types of subcomponents.  In this article, we examine only the block- <strong>machine-</strong> , which can contain only states.  States are identified by the <strong>$</strong> prefix token. <br><br>  Here we see FMN for a controller containing a machine with only one state: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br>  Here is the implementation of the above FMN code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br>  The implementation of the machine block consists of the following elements: <br><br><ol><li>  <strong>_state</strong> variable that refers to the current state function.  It is initialized with the first state function in the controller. </li><li>  one or more state methods </li></ol><br>  The frame state method is defined as a function with the following signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br>  After setting these fundamentals to the implementation of the machine block, we can see how well the FrameEvent object interacts with the machine. <br><br><h3>  Interface block </h3><br>  The interaction of FrameEvents controlling the operation of a machine is the very essence of the simplicity and power of Frame notation.  However, we have not yet answered the question, where do FrameEvents come from - how do they get into the controller to control it?  One option: external clients themselves can create and initialize FrameEvents, and then directly call the method pointed to by the _state member variable: <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  A much better alternative would be to create a common interface that wraps a direct call to the _state member variable: <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  However, the most hassle-free way, corresponding to the usual way of creating object-oriented software, is creating general methods that send an event on behalf of a client to an internal machine: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  Frame defines the syntax for <strong>an interface block</strong> that contains methods that turn calls into a common interface for FrameEvents. <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  The <code>interface</code> block has many other features, but this example gives us a general idea of ‚Äã‚Äãhow this works.  I will give a further explanation in the following articles of the series. <br><br>  Now let's continue studying the work of the Frame machine. <br><br><h3>  Event handlers </h3><br>  Although we have shown how to define a car, we do not yet have a notation with which <em>to do</em> anything.  To handle events, we need to 1) be able to select the event that needs to be processed and 2) bind it to the behavior being performed. <br><br>  Here is a simple Frame controller that provides the infrastructure for handling events: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br>  As mentioned above, to access the <code>_msg</code> attribute of a <code>_msg</code> event, the FMN notation uses brackets of vertical lines: <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  FMN also uses an exponent mark token that denotes a return statement.  The controller shown above will be implemented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br>  Here we see how clearly the FMN notation corresponds to the implementation pattern, which is easy to understand and coding. <br><br>  Having set these basic aspects of events, controllers, machines, states, and event handlers, we can proceed to solving real problems with their help. <br><br><h3>  Single-focus machines </h3><br>  Above, we looked at a stateless controller, which was rather useless. <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  One step higher in the food chain of utility is a class with a single state, which, although not useless, is simply boring.  But at least he does at least <em>something</em> . <br><br>  First, let's see how a class with only one (implied) state will be implemented: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br>  No state is declared or even implied here, but let's assume that if the code does something, the system is in the ‚ÄúWorking‚Äù state. <br><br>  We will also introduce an important idea: the interface calls will be considered similar to sending an event to an object.  Therefore, the above code can be viewed as a way to send the | status |  the Mono class, which is always in the $ Working state. <br><br>  You can visualize this situation using the event bindings table: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br>  Now let's look at FMN, which demonstrates the same functionality and corresponds to the same table of bindings: <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br>  Here is the implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br>  You can see that we also introduced a new notation for the operator <strong>return</strong> , which means the calculation of the expression and the return of the result to the interface: <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br>  This statement is equivalent to <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br>  or simply <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br>  All these operators are functionally equivalent and you can use any of them, but <code>^(return_expr)</code> looks the most expressive. <br><br><h3>  Turn on the stove </h3><br>  So far we have seen a controller with 0 states and a controller with 1 state.  They are not very useful yet, but we are already on the verge of something interesting. <br><br>  To cook our pasta, you need to first turn on the stove.  The following is a simple Switch class with a single boolean variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br>  Although not obvious at first glance, the code shown above implements the following event binding table: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br>  For comparison, here is the FMN for the same behavior: <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Now we see how exactly the Frame notation corresponds to the purpose of our code ‚Äî to bind an event (method call) to behavior based on the state in which the controller is located.  In addition, the implementation structure also corresponds to the binding table: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  The table allows you to quickly understand the purpose of the controller in its various states.  Both the Frame notation structure and the implementation pattern have similar advantages. <br><br>  However, our switch has a noticeable functional issue.  It is initialized in the $ Off state, but cannot switch to the $ On state!  To do this, we need to enter a <strong>state change</strong> operator. <br><br><h3>  We change a state </h3><br>  <strong>The state change statement is</strong> as follows: <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br>  Now we can use this operator to switch between $ Off and $ On: <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  And here is the corresponding event binding table: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br>  New Event | toggle |  now triggers a change that simply cycles between two states.  How can you implement a state change operation? <br><br>  There is simply no place.  Here is the implementation of Switch2: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  You can also make the latest enhancement in Switch2 so that it not only allows you to switch between states, but also explicitly sets the state: <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Unlike the | toggle | event, if | turnOn |  transmitted when Switch3 is already on or | turnOff |, when it is already off, the message is ignored and nothing happens.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This small improvement allows the client to explicitly indicate the state in which the switch should be: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last stage in the evolution of our switch shows how easy it will be to understand the purpose of the FMN controller. </font><font style="vertical-align: inherit;">The relevant code demonstrates how easy it is to implement using Frame mechanisms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having created the Switch machine, we can turn on the fire and start cooking!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We probe the state </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A key, albeit subtle, aspect of automata is that the current state of the machine is the result of either the situation (for example, switching on) or some kind of data analysis or environment. </font><font style="vertical-align: inherit;">When the machine has switched to the desired state, it is implied. </font><font style="vertical-align: inherit;">that the situation will not change without the knowledge of the machine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this assumption is not always true. </font><font style="vertical-align: inherit;">In some situations, validation (or ‚Äúprobing‚Äù) of data is required to determine the current logical state:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original restored state</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - when the machine is restored from a permanent state</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">external state</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - determines the "actual situation" that exists in the environment at the time of creation, restoration or operation of the machine</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changeable internal state</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - when part of the internal data managed by a running machine may change outside the control of the machine</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all these cases, the data, the environment, or both must be ‚Äúprobed‚Äù in order to determine the situation and set the state of the machine accordingly. </font><font style="vertical-align: inherit;">Ideally, this boolean logic can be implemented in a single function that determines the correct logical state. </font><font style="vertical-align: inherit;">To support this pattern, the Frame notation has a special type of function that probes the universe and determines the situation at the current time. </font><font style="vertical-align: inherit;">Such functions are indicated by the prefix </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> before the name of the method that returns a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reference to the state</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In our situation, this method can be implemented as follows: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we see, the method simply returns a reference to the state function corresponding to the correct logical state. </font><font style="vertical-align: inherit;">This probe function can then be used to go to the right state:</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The implementation mechanism looks like this: </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The state sensing method is an example of Frame notation for managing a state in a specified way. </font><font style="vertical-align: inherit;">Further we will also study the important notation for managing FrameEvents.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Behavior Inheritance and Dispatcher </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behavior inheritance and dispatcher</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a powerful programming paradigm and the last topic about Frame notation in this article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame uses inheritance </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">behaviors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , not inheritance of data or other attributes. </font><font style="vertical-align: inherit;">For this state, FrameEvents is sent to other states if the initial state does not handle the event (or, as we will see in the following articles, just wants to pass it on). </font><font style="vertical-align: inherit;">This chain of event transmission can go to any desired depth. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this machine can be implemented using a technique called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method chaining</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">FMN notation for sending an event from one state to another is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispatcher </font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This FMN operator can be implemented as follows: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we see how easy it is to chain the state methods. </font><font style="vertical-align: inherit;">Let's apply this technique to a rather difficult situation:</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the code shown above, we see that there are two basic states - $ Moving and $ Motionless - and the other five states inherit important functionality from them. </font><font style="vertical-align: inherit;">The event binding clearly shows us how the bindings in general will look like:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thanks to the techniques we studied, the implementation will be very simple: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Water machine </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have the basics of FMN knowledge, allowing us to understand how to reimplement the WaterSample class with states and in a much more intelligent way. </font><font style="vertical-align: inherit;">We will also make it useful for our graduate student physicist and add the new $ Plasma state to it:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is the full implementation of FMN: </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, we have the initial state of $ Begin, which responds to the message | create | and stores the value </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The probe function first checks the initial value </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to determine the logical state, and then performs the transition of the machine to this state. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All physical states ($ Solid, $ Liquid, $ Gas, $ Plasma) inherit protective behavior from the $ Default state. All events that are not valid for the current state are passed to the $ Default state, which gives an InvalidStateError error. This shows how simple defensive programming can be implemented using behavior inheritance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now the implementation:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automata is a basic concept of computer science, which has been used for too long only in specialized areas of software and hardware development. The main task of Frame is to create a notation for describing automata and setting simple patterns for writing code or ‚Äúmechanisms‚Äù for their implementation. I hope that the Frame notation will change the programmers' view of automata by providing an easy way to practice them in everyday programming tasks, and, of course, it will save them from spaghetti in the code.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminator eats pasta (photo by Suzuki san)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In future articles, based on the concepts studied, we will create even more power and expressiveness of FMN notation. </font><font style="vertical-align: inherit;">Over time, I will expand the discussion to the study of visual modeling, which includes FMN and solves the problem of uncertain behavior in modern approaches to software modeling.</font></font></div><p>Source: <a href="https://habr.com/ru/post/446330/">https://habr.com/ru/post/446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446320/index.html">How the 3D-scanner allowed to refuse the full-scale control assembly of the bridge</a></li>
<li><a href="../446322/index.html">Cryptography in Java. Keytool utility</a></li>
<li><a href="../446324/index.html">Navigating DataGrip with Yandex.Navigator</a></li>
<li><a href="../446326/index.html">Solving problems with traffic rules</a></li>
<li><a href="../446328/index.html">Why do we need SMS reception services and what do they eat?</a></li>
<li><a href="../446332/index.html">IBM System i (aka AS / 400) - How we did auto tests for green screen applications</a></li>
<li><a href="../446334/index.html">Thinking about IT careers and tips for beginners</a></li>
<li><a href="../446336/index.html">How to disable standard passwords and make everyone hate you</a></li>
<li><a href="../446338/index.html">SVG 3D: create, rotate and animate</a></li>
<li><a href="../446340/index.html">Operating Systems: Three Easy Pieces. Part 1: Intro (translation)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>