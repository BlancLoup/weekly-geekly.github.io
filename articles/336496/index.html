<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architectural Pyramid Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programming is a rather young area of ‚Äã‚Äãknowledge, however, there already exist basic principles of ‚Äúgood code‚Äù, which are considered by most develope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architectural Pyramid Applications</h1><div class="post__text post__text-html js-mediator-article">  Programming is a rather young area of ‚Äã‚Äãknowledge, however, there already exist basic principles of ‚Äúgood code‚Äù, which are considered by most developers as axioms.  Everyone has heard of SOLID, KISS, YAGNI and other three or four-letter abbreviations that make your code cleaner.  These principles influence the architecture of your application, but in addition to them there are architectural styles, methodologies, frameworks, and much more. <br><br>  Dealing with all this separately, I was interested in the question - how are they interrelated?  Trying to build a hierarchy and inspired by <a href="https://en.wikipedia.org/wiki/Maslow%2527s_hierarchy_of_needs">Maslow</a> ‚Äôs infamous pyramid, I built my own ‚Äúapplication architecture‚Äù pyramid. <br><br>  About that from this left - read under a cat. <br><a name="habracut"></a><br><h2>  About the pyramid </h2> <a href=""><img alt="Architectural Pyramid" align="right" src="https://habrastorage.org/web/871/356/d86/871356d867f64073acad236a147c7ac9.jpg"><br></a>  The pyramid is just a convenient visualization for visual representation of the hierarchy of various principles, styles and methodologies.  The pyramid consists of levels, and levels of elements.  Each level additionally has its own generalizing name.  The pyramid should be read bottom-up, from the most basic and general concepts below, to the more specific and specific above.  The order of the elements located on the same level does not matter.  Elements of the same level are considered as "equal" or "equal". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Pyramid levels </h2><br>  Consider each of the levels of the pyramid, consistently rising from its base to the top.  Each of the principles mentioned in the article is described in detail many times in books and articles.  Therefore, I will not describe them in detail, giving only a brief quote and link.  Instead, I will try to explain why the levels are arranged exactly and how all this can be used. <br><br><h3>  Unconditional restrictions </h3><br>  The base of the pyramid are the objective (physical) restrictions for the application.  It can be anything: team size, budget, deadline, country legislation, and even the current level of technology development.  The main distinguishing feature of this kind of restrictions - you can not influence them. <br><br>  Obviously, such restrictions affect the entire project ‚Äî its architecture, choice of technologies, and the way the team is managed. <br><br><h3>  Business requirements </h3><br>  Above the unconditional restrictions are the business requirements: functional and / or technical specifications, customer wishes, explicit and implicit functions that the end user expects to receive. <br><br>  Business requirements introduce additional (and often basic) restrictions on the application architecture.  But they can not be contrary to <s>common sense</s> unconditional restrictions.  They only further narrow our freedom of choice and therefore are above the absolute requirements. <br><br><h3>  Difficulty: KISS, YAGNI </h3><br>  It is unlikely that anyone will argue that the complexity of the system is one of the most important factors affecting all other aspects and, ultimately, the success of the project. <br>  Principles to tackle the complexity of application development are <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a> ( <i>Keep it simple, stupid</i> ) and <a href="https://en.wikipedia.org/wiki/You_aren%2527t_gonna_need_it">YAGNI</a> ( <i>You are not gonna need it</i> ). <br><br>  The KISS principle calls for simplification: <blockquote>  most systems work best if they are simple and not complicated </blockquote>  And YAGNI does not design ahead of measure: <blockquote>  You won't need it. </blockquote>  Both are very abstract and suitable for any application, which makes them fundamental. <br><br>  These principles are very important, but at the same time, no one will pay you if, in pursuit of simplicity, you have ignored half of the client‚Äôs requirements.  Therefore, the principles relating to simplicity have taken pride of place right above the business requirements of the client. <br><br><h3>  Connectivity: DRY, SRP, ISP, high cohesion </h3><br>  An old joke about an elephant that needs to be eaten in parts is fully suitable for any complex task.  Including, for development of large applications.  Two principles are responsible for correctly separating <s>an elephant</s> into small, isolated, and accurately formulated subtasks: <a href="https://en.wikipedia.org/wiki/Don%2527t_repeat_yourself">DRY</a> ( <i>Don't repeat yourself</i> ) and <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> ( <i>The Single Responsibility Principle</i> ). <br><br>  DRY principle says: <blockquote>  Each piece of knowledge must have a single, consistent and authoritative representation within the system. </blockquote>  And the principle of SRP: <blockquote>  each object must have one responsibility </blockquote><br>  It may seem that both principles are one and the same, only in different words, but this is not so.  In fact, they complement each other.  For example, guided only by DRY, you can create one object that sends mail and calculates tax.  If there are no other objects anywhere else in the code, with similar functionality, the condition is satisfied.  SRP, on the other hand, will force you to share responsibilities by placing them on different objects. <br><br>  The <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">ISP</a> ( <i>Interface segregation principle</i> ) <i>principle</i> states that: <blockquote>  Clients should not depend on methods that they do not use. </blockquote>  Suddenly, with this principle I have the biggest problems.  It is somewhat similar to YAGNI - ‚Äúthe client may or may not need these interface methods.‚Äù  On the other hand, he has a lot and from SRP - ‚Äúone interface for one task‚Äù.  It could be attributed to the generalization ‚ÄúComplexity‚Äù and put on the same level as YAGNI and KISS, but these two principles are more abstract. <br><br>  SRP and ISP are part of another well-known principle - <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID,</a> and in the beginning I was worried that in my pyramid these principles were separated from the rest.  However, in the end, I decided that not all <s>yogurts are equally useful</s> principles are equal to each other.  This does not mean that other SOLID principles can be neglected.  Just SRP and ISP, in my opinion, a little more generalized than the rest. <br><br>  High cohesion is a metric that shows how well the code is grouped by functionality.  The implementation of the principles of DRY and SRP leads to a code with a strong connectivity, in which the parts performing the same task are located ‚Äúclose‚Äù to each other, and the different ones are isolated.  Performing an ISP also leads to strong connectivity, although this is not so obvious.  By dividing one interface into smaller parts, you group them by functionality, leaving only the most interconnected methods in each interface. <br><br><div class="spoiler">  <b class="spoiler_title">GRASP: high cohesion, loose / low coupling</b> <div class="spoiler_text">  Above, strong connectivity is called a ‚Äúmetric‚Äù, although it can be fully called a principle.  High cohesion, along with Low coupling are parts of the <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)">GRASP</a> ( <i>General responsibility assignment software patterns</i> ), which is not covered in this article. <br></div></div><br><h3>  Dependencies: IoC, DIP, loose coupling </h3><br>  After we have divided the system into fairly simple components, we can move on to the relationships between these components ‚Äî dependencies.  The complexity and the number of links between the various components of the application also largely affects its architecture.  To manage dependencies between components, there are also some principles. <br><br>  <a href="https://en.wikipedia.org/wiki/Inversion_of_control">IoC</a> ( <i>Inversion of control</i> ) assumes the presence of some framework that will transfer control to the components of our program at the right time.  In this case, the components may not know anything about each other. <br><br>  <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">DIP</a> ( <i>Dependency inversion principle</i> ) reads: <blockquote>  The modules of the upper levels should not depend on the modules of the lower levels.  Both types of modules must depend on abstractions.  Abstractions should not depend on the details.  Details must depend on abstractions. </blockquote>  Loose coupling is not a principle, but a metric that shows how independent the system components are.  Weakly coupled components are independent of external changes and can easily be reused.  IoC and DIP are the means to achieve weak connectivity of components in the system. <br><br><h3>  Extension: OCP, LSP </h3><br>  Requirements for the system being developed may change and be supplemented over time, so it is necessary to lay the possibility of expanding the functionality from the very beginning.  But at the same time we should not get too carried away, because we need to fulfill the basic principle of YAGNI.  That is, it is necessary to find some balance between the possibility of future expansion and the current complexity of implementation. <br><br>  The principles related to the extension of the functional are <a href="https://en.wikipedia.org/wiki/Open/closed_principle">OCP</a> ( <i>Open / closed principle</i> ) and <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">LSP</a> ( <i>Liskov substitution principle</i> ). <br><br>  OCP determines that <blockquote>  program entities (classes, modules, functions, etc.) should be open for expansion, but closed for changing </blockquote>  A LSP: <blockquote>  Functions that use the base type should be able to use subtypes of the base type without knowing it. </blockquote>  Competent implementation of these principles will allow in the future to change (expand) the functionality of the application without changing the already written code, but creating a new one. <br><br><h3>  Methodologies: TDD, DDD, BDD </h3><br>  In addition to the principles, there is also a fairly large set of methodologies, for example, BDD ( <i>Behavior-driven development</i> ) and TDD ( <i>Test-driven development</i> ).  In the general case, the methodology, in contrast to the principle, determines some process applied to the development of an application. <br>  Methodologies are very diverse, they solve different problems and often, when developing an application, their combination is used.  But whichever one you choose, you will have serious problems if you try to apply them to code that violates previous principles.  For example: is it easy to apply TDD and write tests for code that violates DIP and contains references to specific implementations? <br><br>
<h3>  Architectural styles and frameworks </h3><br>  To make it clear what this is about, a good, but far from exhaustive list of architectural styles can be found in the <a href="https://msdn.microsoft.com/en-us/library/ee658117.aspx">Microsoft documentation</a> .  Often they are rather orthogonal to each other and can be used together.  Each of them usually represents a time-tested and successfully implemented approach to building architecture many times. <br><br>  The frameworks are mentioned here because they force you to use a particular architectural style, whether you like it or not.  Actually, this is what distinguishes the framework from the application library.  Many good frameworks are built on the principles of IoC, simplify testing and contain opportunities to expand your own functionality.  That is, in fact, they are located "on top" of all previous levels and must support and correspond to them. <br><br><h3>  Libraries and Tools </h3><br>  At the very top of the pyramid are specific application libraries and tools that you use every day for logging, matrix operations, and displaying beautiful pop-up windows.  These libraries solve specific subtasks and should not affect the architecture as a whole.  The choice of a library should be based on previous levels of the pyramid, and not vice versa. <br><br>  Purely geometrically, this level is the smallest in size, but ironically it is he who often causes the most controversy, discussion and articles. <br><br><h2>  Why is all this necessary? </h2><br>  In my opinion, the pyramid can help when designing a system from scratch or making changes to an existing one.  For myself, I present this in the form of a check-list with questions for each level of the pyramid, which must be answered consistently. <br><br>  If changes are made to the existing system, then it is approximately like this: <br><br>  1. Are my changes realizable given my budget, time and other objective restrictions? <br>  2. Do they conflict with business requirements? <br>  3. Is it enough just what I'm going to do?  Are there any easier ways to do this? <br>  4. How can I divide my task into components (subtasks) so that each of the components performs only one action?  Do I not duplicate the existing functionality? <br>  5. How will my components relate to the rest of the program?  How to reduce the number of connections?  Will I be able to reuse my components or replace one component with another in the future? <br>  6. Will I be able to extend the functionality of my components without changing them?  Have I laid the possibility of expanding into those components, the probability of which changes are especially great in the future? <br>  7. Do my changes contradict my chosen methodology? <br>  8. Do my changes relate to the best practices of the framework I use?  Do they violate the overall architectural style of my code? <br>  9. Can the libraries I use solve the subtask I have set? <br><br>  Each item in the list corresponds to a certain level of the pyramid.  At the same time, the choice made at each level should not contradict the choice made at the previous levels.  This is especially important when designing a system from scratch, when the ‚Äúuncertainty‚Äù in terms of future architecture is much higher and wider choice. <br><br>  For example, the library you choose should not conflict with the framework used.  If this happens, you are changing the library, not the framework.  The framework should support (or at least make it possible) the use of the methodology chosen at the previous stage, and so on. <br><br>  In general, understanding the hierarchy focuses you on more basic principles (lower steps).  In addition, the study of the links between the elements of the pyramid allows you to better understand the picture ‚Äúas a whole‚Äù, to generalize and systematize your knowledge.  For a deeper understanding of any new principle, it will be useful to try to incorporate it into this system, to understand at what level it should be located. <br><br><h2>  Conclusion </h2><br>  This article is quite subjective and does not pretend to a comprehensive description of all existing principles and methodologies.  Moreover, already at the time of writing the first draft, a couple of principles moved from their familiar places to other levels.  Perhaps, over time, the pyramid will be supplemented with new elements or even levels.  If it seems to you that something is out of place in it or you want to supplement it, I will be glad for constructive criticism and suggestions in the comments. </div><p>Source: <a href="https://habr.com/ru/post/336496/">https://habr.com/ru/post/336496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336486/index.html">Inter-AS Option C Pitfalls on JunOS</a></li>
<li><a href="../336488/index.html">The digest of interesting materials for the mobile developer # 218 (August 21 - August 27)</a></li>
<li><a href="../336490/index.html">I'm too busy to do anything</a></li>
<li><a href="../336492/index.html">ggplot2: how to easily combine multiple graphs in one, part 1</a></li>
<li><a href="../336494/index.html">Quick registration of image focal points using big-vote</a></li>
<li><a href="../336498/index.html">Know your tool: Event Loop in libuv</a></li>
<li><a href="../336500/index.html">PHP Digest number 115 - the latest news, materials and tools (August 14 - 27, 2017)</a></li>
<li><a href="../336502/index.html">Revit API Vector Geometry for Developers</a></li>
<li><a href="../336504/index.html">Check dependency injection on Swift</a></li>
<li><a href="../336506/index.html">XBRL: just about the complex - Chapter 6. Immersion in XBRL - Part 5. New dimensions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>