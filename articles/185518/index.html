<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Porting to python 3. Bug fixes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note from the translator: 
 I present to you the translation of an interesting article by Armin Ronaker, the author of the web frameworks Flask and We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Porting to python 3. Bug fixes</h1><div class="post__text post__text-html js-mediator-article">  <i>Note from the translator:</i> <i><br></i>  <i>I present to you the translation of an interesting article by Armin Ronaker, the author of the web frameworks Flask and Werkzeug, the template engine Jinja2, and generally a well-known pythonist about current techniques and pitfalls he uses in his projects when adding support for the third python.</i>  <i>A small note about the title of this article.</i>  <i>It is a reference to Armin's article <a href="http://lucumr.pocoo.org/2010/2/11/porting-to-python-3-a-guide/">‚ÄúPorting to Python 3. Manual,‚Äù</a> in which he described the preparation of code for automatic porting through the <a href="http://docs.python.org/2/library/2to3.html">2to3</a> utility.</i>  <i>As practice shows, today such an approach is rather an anti-pattern, since</i>  <i>on the one hand, the quality of the code as a result of such operations deteriorates markedly, and in addition, such code is noticeably more difficult to maintain.</i> <br><br>  After the extremely painful experience of porting Jinja2 to the third python, I had to leave the project idle for a while, because  I was too afraid to break support for python version 3.  The approach I used was to write code for python version 2 and translate using 2to3 to the third python during package installation.  The most unpleasant side effect is that any change you make requires approximately a minute to translate, thereby killing the speed of your iterations.  Fortunately, it turned out that if you correctly specify the final version of python, the process goes significantly faster. <br><br>  Thomas Waldman from the MoinMoin project started by running Jinja2 through my <a href="https://github.com/mitsuhiko/python-modernize">python-modernize</a> with the correct parameters, and came to a single code that runs under 2.6, 2.7 and 3.3.  By means of small tools, we were able to arrive at a pleasant code base that works with all versions of python and at the same time, for the most part, looks like ordinary code on python. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Inspired by this result, I went through the code several times and began to translate some other code in order to experiment with the combined code base. <br><br>  In this article, I will selectively review some tips and tricks that I can share, in case they help someone in similar situations. <br><a name="habracut"></a><br><h3>  Throw out support 2.5, 3.1 and 3.2 </h3><br>  This is one of the most important tips.  The refusal to support Python 2.5 today is more than possible, since there are not too many people using it.  Rejecting 3.1 and 3.2 is a fairly simple solution, given the low popularity of the third python.  But what's the point to refuse to support these versions?  In short, 2.6 and 3.3 contain a large number of overlapping syntax and capabilities, which allow the same code to work normally in both cases: <br><br><ul><li> Compatible string literals.  2.6 and 3.3 support the same syntax for strings.  You can use both <code>'foo'</code> for native string types (byte strings in 2.x and unicode strings in 3.x), and <code>u'foo'</code> for unicode strings and <code>b'foo'</code> for byte strings or byte objects. </li><li>  Compatible <code>print</code> syntax.  In case you use <code>print</code> 's, you can add <code>from __future__ import print_function</code> and use <code>print</code> as a function, without the need to use a wrapper function and suffer from other incompatibilities. </li><li>  Compatible catching syntax.  In Python 2.6, the new syntax <code>except Exception as e</code> , which is used in 3.x, has appeared. </li><li>  Class decorators are available.  They are extremely useful for automatically correcting relocated interfaces, without the need to leave traces on the class structure.  For example, they can help automatically rename a method name from <code>next</code> to <code>__next__</code> , or <code>__str__</code> to <code>__unicode__</code> in python 2.x. </li><li>  The <code>next()</code> built-in function for calling <code>next</code> or <code>__next__</code> .  Convenient because  it works at about the same speed as a direct method call, so you do not have to pay performance compared to checks in runtime or adding your own wrapper function. </li><li>  In Python 2.6 a new type of <code>bytearray</code> was added with the same interface as in 3.3.  This is useful because  while Python 2.6 lacks a <code>bytes</code> object, it has a built-in object, which, having the same name, is a synonym for <code>str</code> and behaves completely differently. </li><li>  In Python 3.3, codecs from the bytes to bytes and from strings to strings that were broken in 3.1 and 3.2 reappeared.  Unfortunately, their interfaces have become more complicated, and there are no aliases, but this is all much closer to what was in 2.x than before.  This is especially important if you need stream-based encoding.  This functionality was completely absent from 3.0 to 3.3. </li></ul><br>  Yes, the <em>six</em> module will help you move forward, but do not underestimate the benefits of being able to see clean code.  I trivially lost interest in supporting the Jinja2 ported to the third python, since  I was horrified by her code.  At that time, the combined code looked ugly and suffered in terms of performance (constant <code>six.b('foo')</code> and <code>six.u('foo')</code> ), or it had a low iteration rate of 2to3.  Now, having dealt with this all, I get pleasure again.  The Jinja2 code looks very clean, and you have to search to find compatibility support for Python 2 and 3 versions.  Only a few pieces of code do something in the style of <code>if PY2:</code> <br><br>  The rest of the article assumes that you want to support these versions of python.  Also, attempts to support Python version 2.5 are very painful and I highly recommend that you refrain from them.  3.2 support is possible if you are ready to wrap all your lines in function calls, which I personally would not recommend doing for aesthetics and performance reasons. <br><br><h3>  Discard six </h3><br>  Six is ‚Äã‚Äãa pretty neat library, and Jinja2 started with her.  But in the end, if you calculate, then at six there will be not so many necessary things to start the port under the third python.  Of course, six is ‚Äã‚Äãnecessary if you are going to support Python 2.5, but starting from 2.6 and more, there are not too many reasons to use six.  Jinja2 has a <em>_compat</em> module, which contains some necessary helpers.  Including a few lines not on Python 3, the entire compatibility module contains less than 80 lines of code. <br><br>  This will help you avoid problems when users expect a different version of the six package due to a different library or adding another dependency to your project. <br><br><h3>  Start with Modernize </h3><br>  <a href="https://github.com/mitsuhiko/python-modernize">Python-modernize</a> is a good library to start porting.  This is version 2to3, which generates code that works in both versions of python.  Despite the fact that it has enough bugs, and the default options are not the most optimal, it can help you to seriously move forward, doing the boring work for you.  In this case, you still have to go over the code and clean up some imports and roughness. <br><br><h3>  Correct your tests </h3><br>  Before you start doing anything else, go over your tests and make sure that they still have not lost their meaning.  A large number of problems in the standard python library versions 3.0 and 3.1 appeared as a result of unarranged changes in test behavior as a result of porting. <br><br><h3>  Write compatibility module </h3><br>  So, if you decide to give up six, can you live without helpers?  The correct answer is no.  You still need a small compatibility module, but it should be small enough so that you can keep it in your package.  Here is a simple example of how a compatibility module might look like: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys PY2 = sys.version_info[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> PY2: text_type = str string_types = (str,) unichr = chr <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: text_type = unicode string_types = (str, unicode) unichr = unichr</code> </pre><br>  The code for this module will depend on how much has changed for you.  In the case of Jinja2, I put several functions there.  There, for example, there are functions <em>ifilter</em> , <em>imap</em> and other similar functions from itertools that became part of the standard library in 3.x (I use the function names from 2.x so that the reading code understands that the use of iterators here is deliberate and not an error ). <br><br><h3>  Check for 2.x, not for 3.x </h3><br>  At some point, you will have to check whether the code runs in 2.x or 3.x versions of python.  In this case, I would recommend that you check the second version first, and put the check on the third version in the else branch, and not vice versa.  In this case, you will get fewer unpleasant surprises when version 4 of python appears. <br><br>  Good: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PY2: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__unicode__().encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)</code> </pre><br>  Not so perfect: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> PY3: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__unicode__().encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)</code> </pre><br><h3>  Processing strings </h3><br>  The biggest change in the third python, no doubt, was the change in the unicode interface.  Unfortunately, these changes were quite painful in some places and inconsistently changed the standard library.  Most of the porting time will be spent at this stage.  In fact, this is a topic for a separate article, but here is a small list of items that Jinja2 and Werkzeug stick to: <br><br><ul><li>  <code>'foo'</code> always means what I call the native implementation of the string.  These are strings that are used in identifiers, source code, file names, and other low-level functions.  In addition, in 2.x it is permissible to use unicode strings as literals, but only if they contain only ASCII characters. <br><br>  This feature is very useful for a single code base, since  the general trend in the third python is to add support for unicode in interfaces that did not support it before, and never vice versa.  Since native string literals ‚Äúupgrade‚Äù to Unicode, but support Unicode 2.x, they can be very useful. <br><br>  For example, the <code>datetime.strftime</code> function does not support unicode in python in the second, but is only unicode in the third version.  Since in most cases the return value in 2.x was exclusively in ASCII, such things will work in both 2.x and 3.x: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">u'&lt;p&gt;Current time: %s'</span></span> % datetime.datetime.utcnow().strftime(<span class="hljs-string"><span class="hljs-string">'%H:%M'</span></span>) <span class="hljs-string"><span class="hljs-string">u'&lt;p&gt;Current time: 23:52'</span></span></code> </pre><br>  The string passed to <code>strftime</code> native (bytes in 2.x, unicode in 3.x).  The return value is again a native string and is exclusive to ASCII.  As a result, a correctly formatted Unicode string will be returned in both 2.x and 3.x. </li><li>  <code>u'foo'</code> always means a unicode string.  A large number of libraries already support Unicode 2.x perfectly, so Unicode literals are no surprise to anyone. </li><li>  <code>b'foo'</code> always means something that can store real bytes.  Since 2.6, in fact, does not have a <code>bytes</code> object, unlike Python 3.3, which in turn lacks real byte strings, the usefulness of this literal is somewhat limited.  But it again becomes useful if used in conjunction with a <code>bytearray</code> object, which has the same interface in 2.x and 3.x: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>bytearray(<span class="hljs-string"><span class="hljs-string">b' foo '</span></span>).strip() bytearray(<span class="hljs-string"><span class="hljs-string">b'foo'</span></span>)</code> </pre><br>  Since it is mutable, you can convert it into something more familiar from bytes directly by wrapping the result back into <code>bytes()</code> . <br></li></ul><br>  In addition to these simple rules, I added variables: <code>text_type</code> , <code>unichr</code> and <code>string_types</code> to my compatibility module, as shown above.  As a result, the following changes occur: <br><ul><li>  <code>isinstance(x, basestring)</code> becomes <code>isinstance(x, string_types)</code> </li><li>  <code>isinstance(x, unicode)</code> becomes <code>isinstance(x, text_type)</code> </li><li>  <code>isinstance(x, str)</code> if byte handling becomes <code>isinstance(x, bytes)</code> becomes <code>isinstance(x, bytes)</code> , or <code>isinstance(x, (bytes, bytearray))</code> </li></ul><br>  I also wrote a class <code>__unicode__</code> <code>implements_to_string</code> that helps implement classes with <code>__unicode__</code> or <code>__str__</code> : <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PY2: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">implements_to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> cls.__unicode__ = cls.__str__ cls.__str__ = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.__unicode__().encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: implements_to_string = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x</code> </pre><br>  The basic idea is to implement the <code>__str__</code> method in both 2.x and 3.x, allowing it to return unicode strings (yes, it looks somewhat clumsy in 2.x), and the decorator will automatically rename it <code>__unicode__</code> to 2.x , and adds <code>__str__</code> which calls <code>__unicode__</code> and encodes the result of its call in utf-8.  This approach has been quite widespread recently in modules for 2.x.  So do for example Jinja2 or Django. <br><br>  Here is an example of use: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@implements_to_string class User(object): def __init__(self, username): self.username = username def __str__(self): return self.username</span></span></code> </pre><br><h3>  Changes in metaclass syntax </h3><br>  Since in the third python, changes in the syntax for defining metaclasses are incompatible with the second, the porting process becomes a little more difficult.  In six, there is a <code>with_metaclass</code> function that is designed to solve this problem.  It creates an empty class, which is then visible in the inheritance tree.  I did not like this solution for Jinja2, so I changed it.  The external API remains the same, but the implementation uses a temporary class to add the metaclass.  The advantages of such a decision are that you do not need to pay performance for using it, while the inheritance tree remains clean. <br><br>  The solution code is somewhat confusing.  The basic idea relies on the ability of the metaclass to change the class during creation, which is used by the parent class.  My solution uses a metaclass to remove its parent from the inheritance tree when inheriting classes.  In the end, the function creates an empty class with an empty metaclass.  The metaclass of the inherited empty class has a constructor, which instantiates a new class from the correct parent and assigns the correct metaclass <i>(Note: I'm not sure that I translated everything correctly - the source below seems to me more eloquent)</i> .  Thus, empty class and metaclass are never visible. <br><br>  Here's what it looks like: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with_metaclass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(meta, *bases)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">metaclass</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(meta)</span></span></span><span class="hljs-class">:</span></span> __call__ = type.__call__ __init__ = type.__init__ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, name, this_bases, d)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> this_bases <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type.__new__(cls, name, (), d) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> meta(name, bases, d) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> metaclass(<span class="hljs-string"><span class="hljs-string">'temporary_class'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, {}) And here <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> how you use it: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseForm</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(type)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Form</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(with_metaclass</span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"><span class="hljs-params">(FormType, BaseForm)</span></span></span></span><span class="hljs-class"><span class="hljs-params">)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br><h3>  Dictionaries </h3><br>  One of the disruptive changes in the third python were changes to the protocols of dictionary iterators.  In Python, all dictionaries had methods: <code>keys()</code> , <code>values()</code> and <code>items()</code> , which returned lists, and <code>iterkeys()</code> , <code>itervalues()</code> and <code>iteritems()</code> , which returned iterators.  In the third python, none of them are present.  Instead, they were replaced by methods that return view objects. <br><br>  <code>keys()</code> returns a view object that behaves like an immutable set, <code>values()</code> returns an iterable container that can only be read (but not an iterator!), and <code>items()</code> returns something like an immutable set.  Unlike regular sets, they can also point to objects that can be changed, in which case some methods may fall while the program is running. <br><br>  Despite the fact that a large number of people miss the point that view-objects are not iterators, in most cases you can simply ignore this.  Werkzeug and Django implement several of their own dictionary-like objects, and in both cases the solution was to simply ignore the existence of the view-objects, and allow <code>keys()</code> and his friends to return iterators. <br><br>  At the moment, this is the only sensible solution given the limitations that the Python interpreter places.  There are problems with: <br><ul><li>  The fact that view objects are not iterators in themselves means that you create temporary objects for no particular reason. </li><li>  Behavior similar to sets of embedded view-objects of dictionaries cannot be reproduced on pure python, due to <a href="http://bugs.python.org/issue2226">interpreter restrictions</a> </li><li>  Implementing view objects for 3.x and iterators for 2.x would mean a lot of repetition of the code. </li></ul><br>  This is where Jinja2 stopped in terms of dictionary iteration: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PY2: iterkeys = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> d: d.iterkeys() itervalues = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> d: d.itervalues() iteritems = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> d: d.iteritems() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: iterkeys = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> d: iter(d.keys()) itervalues = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> d: iter(d.values()) iteritems = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> d: iter(d.items())</code> </pre><br>  To implement objects like dictionaries, the class decorator helps us again: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PY2: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">implements_dict_iteration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> cls.iterkeys = cls.keys cls.itervalues = cls.values cls.iteritems = cls.items cls.keys = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: list(x.iterkeys()) cls.values = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: list(x.itervalues()) cls.items = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: list(x.iteritems()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: implements_dict_iteration = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x</code> </pre><br>  In this case, all you have to do is implement the <code>keys()</code> method and its friends as iterators, everything else happens automatically. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@implements_dict_iteration class MyDict(object): ... def keys(self): for key, value in iteritems(self): yield key def values(self): for key, value in iteritems(self): yield value def items(self): ...</span></span></code> </pre><br><h3>  General iterator changes </h3><br>  Since the iterators have basically changed, a couple of helpers are needed to correct the situation.  In fact, the only change was the transition from <code>next()</code> to <code>__next__</code> .  Fortunately, this is already handled transparently.  The only thing you need to do is fix <code>x.next()</code> to <code>next(x)</code> , and the python takes care of the rest. <br><br>  If you plan to declare iterators, again, the class decorator will help: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PY2: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">implements_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> cls.next = cls.__next__ <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> cls.__next__ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: implements_iterator = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x</code> </pre><br>  To implement a class, just name the method of the next iteration step <code>__next__</code> : <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@implements_iterator class UppercasingIterator(object): def __init__(self, iterable): self._iter = iter(iterable) def __iter__(self): return self def __next__(self): return next(self._iter).upper()</span></span></code> </pre><br><br><h3>  Codec change </h3><br>  One of the great features of the encoding protocol in the second python was its type independence.  You could register the encoding that would translate the csv file into the numpy array, if you needed it.  This possibility, however, was not very well known, since during the demonstrations, the main objects of the encodings were string objects.  Starting from 3.x, they became more stringent, so most of the functionality was removed in version 3.0, and returned back to 3.3, because  proved its favor.  Simply put, codecs that would not deal with the encoding between unicode and bytes were unavailable until 3.3.  Among them, for example, hex and base64 codecs. <br><br>  Here are two examples of using these codecs: operations on strings and operations on data streams.  Good old <code>str.encode()</code> from 2.x is now mutated.  If you want to support 2.x and 3.x, subject to changes to the API string: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> codecs &gt;&gt;&gt; codecs.encode(<span class="hljs-string"><span class="hljs-string">b'Hey!'</span></span>, <span class="hljs-string"><span class="hljs-string">'base64_codec'</span></span>) <span class="hljs-string"><span class="hljs-string">'SGV5IQ==\n'</span></span></code> </pre><br>  You will also notice that the codecs in 3.3 have lost aliases, and you need to write explicitly <code>'base64_codec'</code> , instead of <code>'base64'</code> . <br><br>  The use of these codecs is preferable to using functions from the <em>binacsii</em> module, since  they support data stream operations through <a href="http://docs.python.org/3/library/codecs.html">support for incremental encoding and decoding</a> . <br><br><h3>  Other notes </h3><br>  There are also a few points for which I still do not have a good solution, or which are annoying, but are so rare that I don‚Äôt want to deal with them.  Some of them, unfortunately, are part of the third python API and are almost invisible until you consider the boundary cases. <br><br><ul><li>  The file system and file IO access continue to annoy on Linux, because  it is not based on unicode.  The <code>open()</code> function and the file system level can have dangerous default settings.  If I, for example, log in via SSH to a machine with the <code>en_US</code> locale from a machine with <code>de_AT</code> , the python likes to switch to ASCII encoding and to work with the file system and for file operations. <br><br>  In general, I consider the most reliable way to work with text in the third python, which also works fine in 2.x - just open files in binary mode and decode it explicitly.  Alternatively, you can also use the <code>codecs.open</code> or <code>io.open</code> in 2.x and the built-in <code>open</code> in 3.x with an explicit indication of the encoding. </li><li>  URLs in the standard library are displayed incorrectly in the form of unicode, which may prevent normal use of some URLs in 3.x. </li><li>  Throwing exceptions with a treysback object requires a helper function because  The syntax has been changed.  This is, in general, not a very common problem and is quite simply solved by a wrapper.  Since  the syntax has changed, here you have to put the code inside the exec block: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PY2: exec(<span class="hljs-string"><span class="hljs-string">'def reraise(tp, value, tb):\n raise tp, value, tb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reraise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tp, value, tb)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> value.with_traceback(tb)</code> </pre><br></li><li>  The previous <code>exec</code> hack is useful if you have code that depends on the syntax.  But since the syntax of exec itself has changed, you now have no opportunity to call anything with arbitrary namespace.  This is not too big a problem, because  <code>eval</code> and <code>compile</code> can be used as a replacement, which works in both versions.  You can also declare the <code>exec_</code> function, via <code>exec</code> itself. <br><pre> <code class="python hljs">exec_ = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s, *a: eval(compile(s, <span class="hljs-string"><span class="hljs-string">'&lt;string&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'exec'</span></span>), *a)</code> </pre></li><li>  If you have a C-module written over the Python C API, you can immediately shoot yourself.  At the moment I am not aware of the existence of any tools that could help here.  Use this opportunity to change the way you use to write modules and <a href="https://cffi.readthedocs.org/en/release-0.6/">rewrite</a> everything using <a href="https://cffi.readthedocs.org/en/release-0.6/">cffi</a> or <em>ctypes</em> .  If you do not consider this option because you have something like numpy, then all you have to do is humbly accept pain.  You can also try to write some abomination, on top of the C preprocessor, which will help make porting easier. </li><li>  Use <a href="https://bitbucket.org/hpk42/tox">tox</a> for local testing.  The ability to run tests under all the necessary versions of python at a time is a very cool thing that will help you avoid a lot of problems. </li></ul><br><h3>  Conclusion </h3><br>  A single code for 2.x and 3.x today is quite possible. ,        ,  ,   API             .   ,     ,       2.5,   3.0-3.2,      . </div><p>Source: <a href="https://habr.com/ru/post/185518/">https://habr.com/ru/post/185518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185498/index.html">Free distribution of Stellar Impact at GreenManGaming</a></li>
<li><a href="../185500/index.html">Self-made ergonomic CatBoard keyboard []</a></li>
<li><a href="../185510/index.html">Homemade tracking parcels, or there and back</a></li>
<li><a href="../185514/index.html">Douglas Engelbart, inventor of a computer mouse, died.</a></li>
<li><a href="../185516/index.html">Vulnerability in Android allows attackers to turn any application into a trojan</a></li>
<li><a href="../185522/index.html">Remote management of objects in Blender</a></li>
<li><a href="../185524/index.html">Happstack Lite: Haskell Web Framework</a></li>
<li><a href="../185526/index.html">Effective technical guidance</a></li>
<li><a href="../185528/index.html">Our vision of Opera 15 and its future</a></li>
<li><a href="../185530/index.html">Convert FLAC to MP3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>