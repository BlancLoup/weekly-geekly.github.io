<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Available methods to combat DDoS attacks for owners of vds / dedicated servers with Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We decided to begin our presence at Habr√© with the material prepared for the Ural Web Developers Conference , which describes tried and tested methods...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Available methods to combat DDoS attacks for owners of vds / dedicated servers with Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/cb4/890/f21/cb4890f218b7683d5ee3fe9bd3205dab.png" alt="image"><br><br>  We decided to begin our presence at Habr√© with the material prepared for <a href="http://uwdc.ru/program/presentation/web-development/obschedostupnyie_metodyi_borbyi_s_ddos-atakami.html">the Ural Web Developers Conference</a> , which describes tried and tested methods of dealing with DDoS attacks that turned out to be quite successful.  The target audience for this article is programmers who have vds or dedicated.  The article does not claim to be a full-fledged guide and many sysadminian nuances in it are intentionally omitted.  We consider only http flood DDoS as the most common type of DDoS and the cheapest for the customer. <br><br>  The target audience for this article is programmers who have VDS or Dedicated at their disposal. <br><a name="habracut"></a><br><h3>  A bunch of nginx - apache - fastcgi / wsgi.  Narrow places </h3><br>  A typical scheme for organizing the work of a web application consists of 3 levels: this is a reverse proxy server (for example, nginx), apache (web server) and some kind of fastcgi / wsgi / ... application.  In practice, there are degenerate cases when there is no apache or when using mod_php / mod_python, when there is no dedicated application (it is embedded in the web server), but the essence of the scheme does not change, only the number of levels in it changes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Fcgi server can run several dozen processes that process incoming requests in parallel.  This value can be increased only up to a certain limit, while the processes are located in memory.  A further increase will result in swapping.  During a DDoS attack or high attendance, when all current fcgi processes are already busy processing incoming requests, apache queues new incoming requests until either one of the fcgi processes is released or the queue timeout occurs (in this case an error occurs 503). <br><br>  Apache also has a limit on the number of connections, usually a few hundred (an order of magnitude more than fcgi).  After all connections to apache are exhausted, requests are already placed in the queue by nginx. <br>  Nginx, due to its asynchronous architecture, can easily keep several thousand connections with very modest memory consumption, so typical DDoS attacks do not reach the level when nginx is unable to accept new connections if nginx is configured accordingly. <br><br><h3>  Filtering traffic to nginx.  Parsing nginx logs </h3><br>  The method proposed by us is reduced to limiting the total number of requests to the site by a certain value (for example, 1500 per minute, depending on how many hits the site engine can withstand the current server capacity).  All that will exceed this value, we will initially filter using nginx (limit_req_zone $ host zone = hostreqlimit: 20m rate = 1500r / m;). <br>  Then we will look into the nginx logs and calculate those IP addresses there that were filtered more than a certain number of times in a certain period of time (for example, more than 100 times in 5 minutes) and deny access to these IP addresses using a firewall. <br><br>  Why we do not use the traditional and often recommended limit on connections from the same ip address (limit_req_zone $ binary_remote_addr ...)?  Firstly, customers of providers sitting at nat will get under this limit.  Secondly, it is impossible to establish a universal threshold value, because there are sites with ajax and a large number of js / css / pictures, which in principle can take several dozen hits to download one page, and such a threshold can be used only individually for each site.  Thirdly, for the so-called ‚Äúsluggish‚Äù DDoS attacks, bots will not fall under this threshold at all - there will be a lot of bots, but each of them alone will make few requests in a short period of time, as a result we will not be able to filter anything, and the site will not work. <br><br>  In order to use our method, the nginx configuration file, when nginx acts as a reverse proxy for apache, should look something like this: <br><pre><code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">http</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">limit_req_zone</span></span> <span class="hljs-variable"><span class="hljs-variable">$host</span></span> zone=hostreqlimit:<span class="hljs-number"><span class="hljs-number">20m</span></span> rate=1500r/m; ... <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">1.2.3.4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> domain.ru www.domain.ru; <span class="hljs-attribute"><span class="hljs-attribute">limit_req</span></span> zone=hostreqlimit burst=<span class="hljs-number"><span class="hljs-number">2500</span></span> nodelay; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1:80; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$proxy_add_x_forwarded_for</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; } } }</code> </pre> <br>  This config also means that we have apache on the loopback interface at 127.0.0.1:80, and nginx on the 80th port on our external ip address (1.2.3.4) and on port 8080 on 127.0.0.1. <br><br>  Hits filtered by nginx will be accompanied by the following entry in nginx's error.log: <br><pre> <code class="nginx hljs">2012/01/30 17:11:48 [error] 16862<span class="hljs-comment"><span class="hljs-comment">#0: *247484 limiting requests, excess: 2500.200 by zone "hostreqlimit", client: 92.255.185.237, server: domain.ru, request: "GET / HTTP/1.1", host: "domain.ru", referrer: "http://www.yahoo.com/"</span></span></code> </pre> <br>  To get from error.log a list of all blocked ip-addresses, we can do the following: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">cat</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log | awk <span class="hljs-string"><span class="hljs-string">'/hostreqlimit/ { gsub(", ", " "); print </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$14</span></span></span><span class="hljs-string">}'</span></span> | sort | uniq -c | sort -n</code> </pre> <br>  But we remember that in this case, we block all those who accessed the site after the count of hits counted 1500 times per minute, so not all blocked ones are bots.  Bots, on the other hand, can be distinguished by drawing a conditional line on the number of locks.  As a rule, a value is selected for the trait several hundred times in 5-15 minutes.  For example, we update the list of bots once every 5 minutes and consider that everyone whom nginx has blocked more than 200 times is bots. <br><br>  Now we face two problems: <br><ol><li>  How to select the ‚Äúlast 5 minutes‚Äù period from the log? </li><li>  How to sort only those who have been blocked more than N times? </li></ol><br>  We solve the first problem with tail -c + OFFSET.  The idea comes down to the fact that after parsing error.log we write its current size in bytes to the auxiliary file (stat -c '% s' error.log&gt; offset), and at the next parsing we rewind error.log to the last viewed position (tail -c + $ (cat offset)).  Thus, starting the analysis of logs every 5 minutes, we will view only the part of the log that belongs to the last 5 minutes. <br><br>  We solve the second problem with the awk script.  As a result, we get (THRESHOLD - this is the same limit for the number of locks, after which the corresponding IP address is considered to belong to the bot attacking us): <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">touch</span></span> offset; (<span class="hljs-attribute"><span class="hljs-attribute">test</span></span> $(stat -c <span class="hljs-string"><span class="hljs-string">'%s'</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log) -lt $(cat offset) <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;/dev/null &amp;&amp; echo <span class="hljs-number"><span class="hljs-number">0</span></span> &gt; offset) || echo <span class="hljs-number"><span class="hljs-number">0</span></span> &gt; offset; \ <span class="hljs-attribute"><span class="hljs-attribute">tail</span></span> -c +$(cat offset) <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log | awk -v THRESHOLD=<span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">'/hostreqlimit/ { gsub(", ", " "); a[</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$14</span></span></span><span class="hljs-string">]++; } \ END { for (i in a) if (a[i]&gt;THRESHOLD) printf "%s\n", i; }'</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">stat</span></span> -c <span class="hljs-string"><span class="hljs-string">'%s'</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log &gt; offset</code> </pre> <br>  It is assumed that this set of commands is executed in the directory where error.log is from nginx, that is, as a rule, this is / var / log / nginx.  The resulting list, we can send to the firewall to block (more on that below). <br><br><h3>  How easy it is to build a list of networks for a ban </h3><br>  Another task facing us with DDoS is to limit access to our site to those who are not its potential visitors as much as possible, because botnets can contain tens of thousands of computers and often cut off excess ip-addresses with whole subnets is much easier than catching each bot separately. <br><br>  The first thing that can help us is the list of Runet networks on the <a href="http://noc.masterhost.ru/allrunet/">NOC masterhost</a> website.  Currently, there are almost 5,000 networks on this list.  Most Russian sites are focused on visitors from Russia, so cutting off all foreign visitors, and with it all foreign bots, looks like a logical decision.  However, lately, more and more independent botnets have arisen within Russian networks, so this solution, although justified, very often does not protect against an attack. <br><br>  If the site has an established community (core), then we can select the list of IP addresses of regular visitors from the web server logs for the last 3-4 weeks.  Although new visitors will not be able to enter the site at the time of the attack, but old active users will most likely not even notice any attack.  In addition, among the regular visitors are unlikely to be bots, so this method can, in principle, by itself, stop the attack for a while. <br><br>  If the site is of local importance, then you can ban everything on the firewall except the networks of local providers and search engine networks (Yandex). <br><br><h3>  Introduction to iptables, an example of a simple firewall </h3><br>  On Linux, the firewall runs on iptables.  In fact, the essence of the work of iptables is to ensure that for each packet of traffic received outside or sent from the server, a certain set of rules are applied that can affect the fate of this packet.  In the simplest case, the rules simply say that the packet must either be accepted (ACCEPT) or discarded (DROP).  The rules are divided into chains.  For example, packets received by the server from the Internet fall into the INPUT chain, where for each packet from the very beginning of the rules in the chain it is checked whether the packet fits the conditions described in the rule and if so, this rule applies to the packet, and if not, the packet passed to the next rule.  If none of the rules for the package has been applied, then the default policy (policy) is applied to the package. <br><br>  As a simple example, let's write the firewall rules that allow connecting to the server via ssh only from our office (from the IP address 1.2.3.4), and for all others ssh access is blocked: <br><pre> <code class="nginx hljs">*<span class="hljs-attribute"><span class="hljs-attribute">filter</span></span> :INPUT ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :FORWARD ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :OUTPUT ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -s <span class="hljs-number"><span class="hljs-number">1.2.3.4</span></span>/<span class="hljs-number"><span class="hljs-number">32</span></span> -m comment --comment <span class="hljs-string"><span class="hljs-string">"our office"</span></span> -j ACCEPT -A INPUT -p tcp -m tcp --dport <span class="hljs-number"><span class="hljs-number">22</span></span> -j DROP COMMIT</code> </pre> <br>  These lines can be written to a text file and loaded into the firewall using: iptables-restore &lt;firewall.txt, and save the current state of the firewall to the file: iptables-save&gt; firewall.txt. <br><br>  These rules work as follows.  The first line - allow all traffic for all connections that are already open (the handshake procedure is passed).  The second line - allow any traffic from ip-address 1.2.3.4 and mark it with a comment that this is our office.  In fact, only packages that establish a connection can reach here, that is, packages of the syn and ack type, all other packages pass only the first line.  The third line - we prohibit all connections via tcp to port 22.  These are attempts to connect (syn, ack) via ssh from everyone except our office. <br><br>  Interestingly, the first line can be safely removed.  The advantage of having such a line is that for already open connections, the firewall will work out just one rule, and packages within already opened connections are the vast majority of the packets we receive, that is, the firewall with such a line will hardly introduce any additional delays at the very beginning into the server's network stack.  Minus - this line leads to the activation of the conntrack module, which keeps in memory a copy of the table of all established connections.  What is more expensive - to keep a copy of the connection table or the need to process several firewall rules for each packet?  This is an individual nuance of each server.  If the firewall contains only a few rules, in our opinion it is more correct to build its rules so that the conntrack module is not activated. <br><br>  In iptables, you can create additional user-defined chains.  In a sense, it looks like an analogue of a function call in programming languages.  New chains are created simply: iptables -N chain_name.  The chains thus created are used to separate the firewall into different logical blocks. <br><br><h3>  Recommended firewall structure for countering DDoS </h3><br>  The structure we recommend for countering DDoS consists of the following logical blocks: <br><ol><li>  Allow traffic on already established connections. </li><li>  We register permissions for "our" ip-addresses. </li><li>  The whitelist table is an exception. </li><li>  The DDoS table is the bots we identified. </li><li>  The friends table is the networks of RuNet that we allow access to if the packet has reached this level. </li><li>  All the rest - -j DROP. </li></ol><br>  In iptables terms, it looks like this: <br><pre> <code class="nginx hljs">*<span class="hljs-attribute"><span class="hljs-attribute">filter</span></span> :INPUT ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :FORWARD ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :OUTPUT ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :ddos - [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :friends - [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :whitelist - [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] -A INPUT -i lo -j ACCEPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -s <span class="hljs-number"><span class="hljs-number">1.2.3.4</span></span>/<span class="hljs-number"><span class="hljs-number">32</span></span> -m comment --comment <span class="hljs-string"><span class="hljs-string">"our office"</span></span> -j ACCEPT -A INPUT -p tcp -m tcp --dport <span class="hljs-number"><span class="hljs-number">22</span></span> -j DROP -A INPUT -j whitelist -A INPUT -j ddos -A INPUT -j friends -A INPUT -j DROP -A whitelist -s <span class="hljs-number"><span class="hljs-number">222.222.222.222</span></span> -j ACCEPT -A whitelist -s <span class="hljs-number"><span class="hljs-number">111.111.111.111</span></span> -j ACCEPT -A ddos -s <span class="hljs-number"><span class="hljs-number">4.3.2.0</span></span>/<span class="hljs-number"><span class="hljs-number">24</span></span> -j DROP -A friends -s <span class="hljs-number"><span class="hljs-number">91.201.52.0</span></span>/<span class="hljs-number"><span class="hljs-number">22</span></span> -j ACCEPT COMMIT</code> </pre> <br>  Again, the expediency of having the second row is questionable, and depending on the full size of the firewall, it can both speed up and slow down. <br><br>  Fill in the friends table: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">for</span></span> net in $(curl -s http://noc.masterhost.ru/allrunet/runet); <span class="hljs-attribute"><span class="hljs-attribute">do</span></span> iptables -A friends -s <span class="hljs-variable"><span class="hljs-variable">$net</span></span> -j ACCEPT; done</code> </pre> <br>  The problem of such a firewall in its monstrousness: the friends table in the case of the Runet will contain about 5000 rules.  The DDoS table in the case of more or less average DDoS will contain 1-2 thousand more records.  Total firewall will consist of 5-7 thousand lines.  In this case, all packets arriving from overseas senders, which should be simply discarded, will actually go through all 5-7 thousand rules until they reach the last: -A INPUT -j DROP.  By itself, such a firewall will eat off a huge amount of resources. <br><br><h3>  Ipset - solution for monstrous firewalls </h3><br>  Ipset completely solves the problem with a monstrous firewall, in which there are thousands of lines describing what to do with packets with different addresses of senders or recipients.  Ipset is a utility for managing special set'ami (sets of the same type of data), where for several predefined data types special hash-tables are made, allowing you to very quickly determine whether a particular key is in or out of this table.  In a sense, this is an analogue of memcached, but only much faster and allowing you to store only a few specific data types.  Let's create a new data set to store information about the ip-addresses of DDoS bots: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ipset</span></span> -N ddos iphash</code> </pre> <br>  Here, the last parameter indicates the type of table being created: nethash is set for the list of networks, iphash is for individual ip addresses.  There are different versions of the tables, details in the man ipset.  Accordingly, whitelist and friends are tables like nethash, and DDoS is iphash. <br>  To use the created ipset table in the firewall, one rule (firewall lines) is enough, for example: <br><pre> <code class="nginx hljs">-<span class="hljs-attribute"><span class="hljs-attribute">A</span></span> INPUT -m set --match-set whitelist src -j ACCEPT -A INPUT -m set --match-set ddos src -j DROP</code> </pre> <br>  You can add some ip-address to the newly created table like this: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ipset</span></span> -A ddos <span class="hljs-number"><span class="hljs-number">1.2.3.4</span></span></code> </pre> <br>  Thus, our entire firewall when using ipset comes down to: <br><pre> <code class="nginx hljs">*<span class="hljs-attribute"><span class="hljs-attribute">filter</span></span> :INPUT ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :FORWARD ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] :OUTPUT ACCEPT [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] -A INPUT -i lo -j ACCEPT -A INPUT -s <span class="hljs-number"><span class="hljs-number">1.2.3.4</span></span>/<span class="hljs-number"><span class="hljs-number">32</span></span> -m comment --comment <span class="hljs-string"><span class="hljs-string">"our office"</span></span> -j ACCEPT -A INPUT -p tcp -m tcp --dport <span class="hljs-number"><span class="hljs-number">22</span></span> -j DROP -A INPUT -m set --match-set whitelist src -j ACCEPT -A INPUT -m set --match-set ddos src -j DROP -A INPUT -m set --match-set friends src -j ACCEPT -A INPUT -j DROP COMMIT</code> </pre> <br>  Fill in set friends (nethash type): <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">for</span></span> net in $(curl -s http://noc.masterhost.ru/allrunet/runet); <span class="hljs-attribute"><span class="hljs-attribute">do</span></span> ipset -A friends <span class="hljs-variable"><span class="hljs-variable">$net</span></span>; done</code> </pre> <br>  Fill in the set ddos ‚Äã‚Äãfrom the command shown earlier: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">touch</span></span> offset; (<span class="hljs-attribute"><span class="hljs-attribute">test</span></span> $(stat -c <span class="hljs-string"><span class="hljs-string">'%s'</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log) -lt $(cat offset) <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;/dev/null &amp;&amp; echo <span class="hljs-number"><span class="hljs-number">0</span></span> &gt; offset) || echo <span class="hljs-number"><span class="hljs-number">0</span></span> &gt; offset; \ <span class="hljs-attribute"><span class="hljs-attribute">for</span></span> ip in $(tail -c +$(cat offset) <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log | awk -v THRESHOLD=<span class="hljs-number"><span class="hljs-number">300</span></span> \ <span class="hljs-string"><span class="hljs-string">'/hostreqlimit/ { gsub(", ", " "); a[</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$14</span></span></span><span class="hljs-string">]++; } END { for (i in a) if (a[i]&gt;THRESHOLD) printf "%s\n", i; }'</span></span> ; \ <span class="hljs-attribute"><span class="hljs-attribute">stat</span></span> -c <span class="hljs-string"><span class="hljs-string">'%s'</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span>.log &gt; offset); <span class="hljs-attribute"><span class="hljs-attribute">do</span></span> ipset -A ddos <span class="hljs-variable"><span class="hljs-variable">$ip</span></span>; done</code> </pre> <br><h3>  We use the TARPIT module </h3><br>  The iptables module called tarpit is a so-called ‚Äútrap‚Äù.  The principle of operation of tarpit is as follows: the client sends a syn-package to attempt to install handshake (the beginning of the installation of a tcp connection).  Tarpit responds with a syn / ack package, which is immediately forgotten.  However, no connection is actually opened and no resources are allocated.  When the final ACK packet arrives from the bot, the tarpit module sends a packet back, setting the window size for transmitting data to the server to zero.  After that, any attempts to close this connection from the side of the tarpit bot are ignored.  The client (bot) thinks that the connection is open, but ‚Äústuck‚Äù (window size is 0 bytes) and tries to close this connection, but he cannot do anything until the timeout expires, and the timeout, depending on the settings, is about 12-24 minutes <br><br>  You can use tarpit in a firewall as follows: <br><pre> <code class="nginx hljs">-<span class="hljs-attribute"><span class="hljs-attribute">A</span></span> INPUT -p tcp -m set --match-set ddos src -j TARPIT --tarpit -A INPUT -m set --match-set ddos src -j DROP</code> </pre> <br><h3>  We collect xtables-addons </h3><br>  Unfortunately, the ipset and tarpit modules are absent in the standard set of modern distributions.  They need to be installed additionally.  For more or less recent distributions of Debian and Ubuntu, this is done simply: <br><pre> <code class="nginx hljs">apt-<span class="hljs-attribute"><span class="hljs-attribute">get</span></span> install module-assistant xtables-addons-source ma ai xtables-addons</code> </pre> <br>  After that, the system itself will download everything needed to build software, it will collect everything and install everything itself.  For other Linux distributions, you need to take similar actions, but for specificity, we suggest referring to the reference guide. <br><br><h3>  Core tuning </h3><br>  As a rule, talk about combating DDoS attacks begins with recommendations on tuning the OS kernel.  However, in our opinion, if in principle there are not enough resources (for example, if there is less than one GB of memory), then the kernel tune-up does not make sense, since it will give almost nothing.  The maximum useful in this case will be - include the so-called.  syncookies  The inclusion of syncookies allows you to effectively deal with attacks of syn flood when the server is bombarded with a large number of syn-packets.  When receiving a syn-package, the server must allocate resources to open a new connection.  If the sync package is not followed by the continuation of the connection setup procedure, the server will allocate resources and wait until a timeout occurs (a few minutes).  Ultimately, without syncookies, with a sufficient number of syn packets sent to the server, it can no longer accept connections, because the system will spend all its resources on storing information about half-open connections. <br><br>  Kernel parameters, which will be discussed, are corrected using the sysctl command: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">sysctl</span></span> [-w] option</code> </pre> <br>  The option -w means that you want to write a new value to some parameter, and its absence means that you want to read the current value of this parameter.  It is recommended to correct the following parameters: <br><pre> <code class="nginx hljs">net.ipv4.tcp_syncookies=1 net.ipv4.<span class="hljs-attribute"><span class="hljs-attribute">ip_local_port_range</span></span> = <span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-number"><span class="hljs-number">65535</span></span> net.core.netdev_max_backlog = <span class="hljs-number"><span class="hljs-number">30000</span></span> net.ipv4.tcp_max_syn_backlog = <span class="hljs-number"><span class="hljs-number">4096</span></span> net.core.somaxconn = <span class="hljs-number"><span class="hljs-number">4096</span></span> net.core.rmem_default = <span class="hljs-number"><span class="hljs-number">124928</span></span> net.core.rmem_max = <span class="hljs-number"><span class="hljs-number">124928</span></span> net.core.wmem_max = <span class="hljs-number"><span class="hljs-number">124928</span></span></code> </pre><br><ul><li>  The net.ipv4.tcp_syncookies parameter is responsible for enabling the syncookies mechanism;  net.core.netdev_max_backlog determines the maximum number of packets in the processing queue if an interface receives packets faster than the kernel can process them. </li><li>  net.ipv4.tcp_max_syn_backlog determines the maximum number of remembered connection requests for which no confirmation has been received from the connecting client. </li><li>  net.core.somaxconn maximum number of open sockets waiting for connections. </li><li>  The last lines are different buffers for tcp connections. </li></ul><br>  We hope that this article will be useful for owners of VDS or Dedicated servers.  Please leave your comments and comments. </div><p>Source: <a href="https://habr.com/ru/post/149302/">https://habr.com/ru/post/149302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149297/index.html">Reader ithappens</a></li>
<li><a href="../149298/index.html">Creating Warcraft (Part 1)</a></li>
<li><a href="../149299/index.html">Interaction of processes (applications) on WinApi</a></li>
<li><a href="../149300/index.html">Steam will go beyond the gaming market</a></li>
<li><a href="../149301/index.html">Announcement. Online Workshop August 9: Infrastructure as a Service (IaaS) in Windows Azure</a></li>
<li><a href="../149303/index.html">A practical example of the introduction of code inspection</a></li>
<li><a href="../149305/index.html">IT Compote # 17 Programming and Technology Podcast</a></li>
<li><a href="../149306/index.html">The correct backup in the data center</a></li>
<li><a href="../149307/index.html">Creating a SQL 2012 virtual machine in Windows Azure and connecting to it</a></li>
<li><a href="../149309/index.html">Comparing Google Play and Samsung Apps Statistics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>