<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protocol-Oriented Programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At WWDC 2015, Apple announced that Swift is the first protocol-oriented programming language ( video session "Protocol-Oriented Programming in Swift" ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protocol-Oriented Programming</h1><div class="post__text post__text-html js-mediator-article">  At WWDC 2015, Apple announced that Swift is the first protocol-oriented programming language ( <a href="https://developer.apple.com/videos/play/wwdc2015/408/">video session "Protocol-Oriented Programming in Swift"</a> ). <br><br>  At this session and a number of others ( <a href="https://developer.apple.com/videos/play/wwdc2015/411/">Swift in Practice</a> , <a href="https://developer.apple.com/videos/play/wwdc2016/419/">Protocol and Value Oriented Programming in UIKit Apps</a> ) Apple demonstrates good examples of using protocols, but does not give a formal definition of what Protocol-Oriented Programming is. <br><br>  There are many articles on Protocol-Oriented Programming (POP) on the Internet that demonstrate examples of using protocols, but I haven‚Äôt found a clear definition of POP in them either. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I tried to analyze examples of using protocols and formulate principles that should be followed, so that the code could be called protocol-oriented. <br><a name="habracut"></a><br>  By looking at code examples demonstrating POP, you can determine that the key language features in POP are <b>protocol</b> , <b>extensions,</b> and <b>constraints</b> . <br>  Let's see what opportunities they give us. <br><br><h2>  Protocol </h2><br>  Using the protocol can be divided into several scenarios: <br><br><h3>  Protocol as a type </h3><br>  Similar to the concept of the <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D1%2584%25D0%25B5%25D0%25B9%25D1%2581_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">interface</a> of the PLO and the contract of <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">contract programming</a> .  Used to describe the functionality of the object.  It can be used as a property type, as a function result type, as an element of a heterogeneous collection.  Due to language restrictions, protocols having associated types or Self-requirements cannot be used as types. <br><br><h3>  Protocol as a type template </h3><br>  Similar to the <a href="https://en.wikipedia.org/wiki/Concept_(generic_programming)">concept</a> of a <a href="https://en.wikipedia.org/wiki/Concept_(generic_programming)">concept</a> of <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D0%25BE%25D0%25B1%25D1%2589%25D1%2591%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">generalized programming</a> . <br><br>  It also serves to describe the functionality of an object, but, unlike ‚Äúprotocol as a type,‚Äù it is used as a type requirement in generic functions.  May contain associated types. <br><blockquote>  <b>associated types</b> - auxiliary types that have some relevance to the concept-modeling type (definition from <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D0%25BE%25D0%25B1%25D1%2589%25D1%2591%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">wikipedia</a> ). <br></blockquote>  There is no clear line in which case to use the protocol as a type, and in which - as a restriction on the type, moreover - sometimes it is required to use the protocol in both scenarios.  You can try to isolate use cases: <br><br><ul><li>  classes that provide functionality for higher layers of the application and are passed to consumer classes as dependencies ‚Äî services, repositories, api-clients, user settings, and so on. <br><br>  In this case, it is more convenient to use the protocol as a type ‚Äî it can be registered in the IOC container, and without using it, it is not required in each function where this service is used to add the type-parameter. <br></li><li>  A protocol describing mathematical operations, such as comparison, addition, concatenation, and similar things.  In this case, it is convenient to use Self-requirement (when the pseudotype Self is used in a function or property of the protocol) to avoid dangerous reduction and use of different types, when the operation allows only one type of parameters (both Int and String in Swift correspond to the Equatable protocol, but if you try check them for equality between themselves, the compiler will generate an error, since the comparison operator requires that the parameters be of the same type).  Therefore, in this case, the protocol is used as a type template. <br></li><li>  sometimes it is required to save the protocol having associated types in a private property, but in this case we cannot use the protocol as a type.  There are different ways to solve this problem, for example, creating a similar protocol in which the use of associated types will be replaced with specific types;  use of <a href="http://robnapier.net/erasure">type erasure</a> technique - in this case, the associated types will move to generic parameters of type Any [YourProtocolName].  Another option is not to save the instance itself, but its functions.  Or grab the instance in the closure, which is stored in the property. <br></li></ul><br><h3>  Protocol as trait </h3><br>  <b>Trait (type)</b> - an entity that provides a set of implemented functionality.  Serves as a set of building blocks for classes / structures / enums. <br><br>  Description of the concept of traits can be found <a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">here</a> . <br><br>  This concept is designed to replace inheritance.  In OOP, one of the roles of classes is the unit of the code being reused.  The reuse itself is through inheritance. <br><br>  At the same time, the class is used to create instances, so its functionality must be complete.  These two class roles often conflict.  Plus, each class has a certain place in the class hierarchy, and the unit of code reuse can be used in an arbitrary place.  As a solution, it is proposed to use more lightweight entities, traits, in the role of code reuse units, while classes will be assigned the role of a connecting element to enable logic inherited from traits. <br><br>  In swift, this concept is implemented through protocols and protocol extensions.  In order to ‚Äúconnect‚Äù the necessary functions defined for the protocol, you need to add a correspondence to this protocol to the created type - there is no need to create a base class for inheriting functionality. <br><br>  What trait properties and protocol analogy has: <br><br><ul><li>  trait provides a set of methods that implement the behavior.  - Methods added using protocol extensions; <br></li><li>  trait requires a set of methods that serve as parameters for providing behavior.  - Methods contained in the protocol itself (Protocol requirements); <br></li><li>  traits do not set variables to store state.  The methods provided by trait do not have direct access to the class fields.  - Extension methods cannot add a stored property type.  Protocol cannot add the requirement of what the computed or stored property should be, so extension methods do not have direct access to the data ‚Äî it is done through property accessors; <br></li><li>  classes and traits can be made up of other traits.  Method conflicts must be explicitly resolved.  - Classes can be added to correspond to protocols, and protocols support inheritance to other protocols.  Conflicts can be resolved, for example, by using a cast to a specific type: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Protocol1</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Protocol2</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComposedProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Protocol1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Protocol2</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Protocol1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Protocol1 method"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Protocol2</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Protocol1 method"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComposedProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combinedWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Protocol1</span></span>).doWork() (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Protocol2</span></span>).doWork() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"ComposedProtocol method"</span></span>) } }</code> </pre> <br></li><li>  adding a trait does not affect the semantics of the class - there is no difference between whether the methods from the traits or methods defined directly in the class are used.  - True for protocols - looking at the code, we cannot determine where the method is defined - in the protocol extension or the type corresponding to the protocol; <br></li><li>  trait composition does not affect the trait semantics ‚Äî a composite trait is equivalent to a ‚Äúflat‚Äù trait containing the same methods.  - The use of the Foo protocol with the foo () method, which is inherited from the Bar protocols with the bar () method and the Baz method with the baz () method does not differ from the use of the protocol, with these 3 methods: foo (), bar (), baz (). <br></li></ul><br>  As we can see, the protocols fully comply with the concept of traits, described long before the advent of Swift. <br><br><h3>  Protocol as a marker </h3><br>  Used as an ‚Äúattribute‚Äù of a type, in this case the protocol does not contain any methods.  As an example, NSFetchRequestResult from CoreData.  They are labeled NSNumber, NSDictionary, NSManagedObject, NSManagedObjectID.  The protocol in this case does not describe the functionality of classes, but the fact that CoreData supports these classes as a type of query result.  If you specify a type unlabeled with the NSFetchRequestResult protocol as a result, then at the assembly stage you will get an error. <br><br>  Check for the presence of the protocol-marker can be used for branching logic: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> HighPrioritized { ... }</code> </pre><br><h2>  Extensions </h2><br>  Extension is a language tool that allows you to add functionality to an existing type or protocol. <br><br>  With the help of extensions we can do: <br><br><ul><li>  add a method to the protocol - this method will be available (within the scope) for use both within types that correspond to this protocol and for their customers; <br></li><li>  add a class / structure / enum to the protocol.  At the same time, we do not need access to the code of these types, they may be contained in a third-party library.  This feature is called Retroactive modeling. <br><br>  We cannot make the protocol comply with another protocol.  If this were possible, with the P1 protocol, which conforms to the P2 protocol, all types corresponding to the P1 protocol would automatically correspond to the P2 protocol.  As a workaround to this problem, we can use the following technique: write an extension for the P1 protocol, in which we write implementations of the P2 protocol methods, after which we can add a P2 correspondence to the types corresponding to P1, without implementations of the methods.  This idea is well demonstrated by an example from the <a href="https://developer.apple.com/videos/play/wwdc2015/408/%3Ftime%3D1995">presentation of POP</a> - Retroactive adoptation: <br><br><pre> <code class="hljs pgsql">protocol Ordered { func precedes(other: Self) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> Comparable { //  ,        Comparable,   : // <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> Ordered <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Self: Comparable //  // <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> Comparable <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Self: Ordered func precedes(other: Self) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self &lt; other } } <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> : Ordered {} <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> String : Ordered {}</code> </pre><br></li><li>  write the default implementation of the protocol method.  If the type contains an implementation of this method, then it will be used instead of the default one. <br></li></ul><br><h2>  Constraints </h2><br>  Restrictions on type.  The following are supported: protocol compliant, inherited from class, has type.  Constraints are used to determine the set of methods that a generic type has.  If you pass an unsatisfying type as an argument, the compiler will generate an error. <br><br>  Where are used: <br><br><ul><li>  restrictions on the types of parameters in the definition of a generalized function.  Example: the produce function takes a type argument that conforms to the Factory protocol, whose associative Product type should be Cola: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-function">&lt;F: Factory&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(factory: F)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">F</span></span>.<span class="hljs-type"><span class="hljs-type">Product</span></span> == <span class="hljs-type"><span class="hljs-type">Cola</span></span></code> </pre><br>  Another example: the argument must simultaneously comply with 2 protocols: Animal and Flying: <br><br><pre> <code class="hljs xml">//        : func fly<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>(f: T) where T: Flying, T: Animal { ... } func fly<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Flying</span></span></span><span class="hljs-tag"> &amp; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Animal</span></span></span><span class="hljs-tag">&gt;</span></span>(f: T) { ... } func fly<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Animal</span></span></span><span class="hljs-tag">&gt;</span></span>(f: T) where T: Flying { ... } func fly<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>(f: T) where T: Flying &amp; Animal { ... }</code> </pre><br></li><li>  restriction on associated type in the protocol definition.  An example - the associative type Identifier must comply with the Codable protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Identifier</span></span>: <span class="hljs-type"><span class="hljs-type">Codable</span></span> }</code> </pre><br>  We can make associated types associated types: <br><br><pre> <code class="hljs pgsql">protocol GenericProtocol { associatedtype <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>: RawRepresentable <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>.RawValue == <span class="hljs-type"><span class="hljs-type">Int</span></span> func getValue() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> } //       .      : protocol GenericProtocol <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>.RawValue == <span class="hljs-type"><span class="hljs-type">Int</span></span> { associatedtype <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>: RawRepresentable func getValue() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> } protocol GenericProtocol <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>: RawRepresentable, <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>.RawValue == <span class="hljs-type"><span class="hljs-type">Int</span></span> { associatedtype <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> func getValue() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> }</code> </pre><br></li><li>  restriction on the availability of extension methods.  Let's rewrite examples of functions from Animal and Factory to extension methods: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Flying</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cola</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre><br></li><li>  definition of conditional compliance protocol ( <a href="https://swift.org/blog/conditional-conformance/">Conditional Conformance</a> ).  Example: if the type of the array elements corresponds to the ObjectWithMass protocol, then the array itself will correspond to this protocol, and as the mass it will return the sum of the mass of elements: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectWithMass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mass: <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectWithMass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectWithMass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mass: <span class="hljs-type"><span class="hljs-type">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.mass }.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, +) } }</code> </pre><br></li></ul><br>  Since the associatedtypes collections can be specified both on the protocol itself and for the methods to which the protocol is transferred, and for the protocol extensions, the question arises where to add the constraints.  A few recommendations: <br><br><ol><li>  If the protocol is application specific and will have one implementation, it is worth considering the possibility of using specific types instead of associated ones. </li><li>  If the protocol is application-specific and will have several implementations (taking into account fake tests), it is more convenient to put them in the protocol itself so as not to duplicate to the places where this protocol is used. <br></li><li>  If there are plans to reuse the protocol, the protocol should contain only those frameworks without which the existence of the protocol does not make sense and on which the main logic is built.  All other constraints should be considered as a description of special cases and placed on methods and extensions. <br></li></ol><br><h2>  Principles </h2><br>  The best material on POP is the <a href="https://developer.apple.com/videos/play/wwdc2015/408/">‚ÄúProtocol-Oriented Programming in Swift‚Äù</a> session conducted by Dave Abrahams.  I strongly recommend it for viewing.  Most of the principles are shaped by examples from it. <br><br><ol><li>  ‚ÄúDon't start with a class.  Start with a protocol. ‚Äù  This is the statement of Dave Abrahams from the above session.  It can be interpreted in two ways: <br><br><ul><li>  start not with the implementation, but with the description of the contract (description of the functionality that the object will be required to provide to consumers) </li><li>  Describe reusable logic in protocols, not classes.  Use the protocol as a unit of code reuse, and the class as a place for unique logic.  <b>Otherwise,</b> you can describe this principle - <b>encapsulate what varies</b> . <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">The Template Method method</a> can be a good analogue.  His idea is to separate the general algorithm from the implementation details.  The base class contains the general algorithm, and the children override certain steps of the algorithm.  In POP, the general algorithm will be contained in the protocol extension, the protocol will determine the steps of the algorithm and the types used, and the implementation of the steps in the class. </li></ul></li><li>  Composition through extensions.  Many have heard the phrase <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">‚Äúprefer composition over inheritance‚Äù</a> .  In OOP, when a different set of functionality is required from an object (polymorphic behavior), this functionality can either be divided into parts and a hierarchy of classes is organized, where each class inherits the functionality from its ancestor and adds its own, or divided into unrelated classes by hierarchy, instances of which are used in a binder. classroom.  Using the ability to add conformance to the protocol through an extension, we can use composition without resorting to creating auxiliary classes.  Often used in this way when viewController is added to match various delegates.  The advantage over adding conformance to protocols in the class itself is better organized code: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTableViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    UITableViewDelegate } extension MyTableViewController: UITableViewDataSource { //    UITableViewDataSource } extension MyTableViewController: UITextFieldDelegate { //    UITextFieldDelegate }</span></span></code> </pre><br></li><li>  Instead of inheritance, use protocols.  Dave Abrahams compared the protocols with superclasses because they allow to achieve the similarity of multiple inheritance. <br>  If your class contains a lot of logic, you should try to break it up into separate sets of functionality that you can put into protocols. <br><br>  Of course, if third-party frameworks like Cocoa are used, inheritance cannot be avoided. <br></li><li>  Use Retroactive modeling. <br><br>  An interesting example from the same session ‚ÄúProtocol-Oriented Programming in Swift‚Äù.  Instead of writing a class that implements the Renderer protocol for rendering using CoreGraphics, the CGContext class via extension adds conformance to this protocol.  Before adding a new class that implements the protocol, it is worth considering whether there is a type (class / structure / enum) that can be adapted to match the protocol? <br></li><li>  Include protocols that you can override ( <a href="https://developer.apple.com/videos/play/wwdc2015/408/%3Ftime%3D1754">Requirements create customization points</a> ) in the logs. <br><br>  If you need to override the generic method defined in the protocol extension for a particular class, then transfer the signature of this method to protocol requirements.  Other classes do not have to edit, because  will continue to use the method from the extension.  The difference will be in the wording - now it is the <b>‚Äúdefault implementation method‚Äù</b> instead of the <b>‚Äúextension method‚Äù</b> . <br></li></ol><br><h2>  Differences POP from OOP </h2><br><h3>  Abstraction </h3><br>  In OOP, the role of an abstract data type is played by a class.  In the POP protocol. <br>  Advantages of the protocol as an abstraction, according to Apple (slide: <a href="https://developer.apple.com/videos/play/wwdc2015/408/%3Ftime%3D803">‚ÄúA Better Abstraction Mechanism‚Äù</a> ): <br><br><ul><li>  Supports value types (and classes) </li><li>  Supports static type relationships (and dynamic dispatch) </li><li>  Non-monolithic </li><li>  Supports retroactive modeling </li><li>  Doesn‚Äôt impose instance data on models </li><li>  Doesn't impose initialization weights on models </li><li>  Makes clear what to implement </li></ul><br><div class="spoiler">  <b class="spoiler_title">Transfer</b> <div class="spoiler_text"><ul><li>  Support for value types (and classes) </li><li>  Support static type relationships (and dynamic dispatch) </li><li>  Non monolithic </li><li>  Retroactive modeling support </li><li>  Does not impose object data (fields of the base class) </li><li>  Does not burden initialization (base class) </li><li>  Makes it clear what to implement </li></ul><br></div></div><br><h3>  Encapsulation </h3><br>  - the property of the system, allowing to combine data and methods working with them in the class. <br>  The protocol cannot contain the data itself; it can contain only the requirements for the properties that these data would provide.  As in OOP, the necessary data should be included in the class / structure, but functions can be defined both in the class and in extensions. <br><br><h3>  Polymorphism </h3><br>  POP / swift supports 2 types of polymorphism: <br><br><ul><li>  polymorphism of subtypes.  It is used in OOP: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: ServiceType)</span></span></span></span> { ... }</code> </pre><br></li><li>  parametric polymorphism.  Used in generic programming. <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-function">&lt;Service: ServiceType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: Service)</span></span></span></span> { ... }</code> </pre><br>  The set of functions of the received type and its associated types are determined by the restrictions.  We can not impose restrictions, but in this case the parameter will be similar to the Any type: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: T)</span></span></span></span> { ... }</code> </pre><br></li></ul><br>  In the case of polymorphism of subtypes, we do not know the specific type that is passed to the function - finding the implementation of methods of this type will be carried out at runtime ( <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">Dynamic dispatch</a> ).  When using parametric polymorphism - the type of the parameter is known at compile time, respectively, and its methods ( <a href="https://en.wikipedia.org/wiki/Static_dispatch">Static dispatch</a> ).  Due to the fact that at the assembly stage the types used are known, the compiler is able to better optimize the code ‚Äî first of all, through the use of substitution (inline) functions. <br><br><h3>  Inheritance </h3><br>  Inheritance in OOP is used to borrow functionality from the parent class. <br>  In POP, obtaining the necessary functionality occurs by adding correspondences to the protocols that provide functions via extensions.  At the same time, we are not limited to classes; we have the opportunity to expand structures and enums with protocols. <br><br>  Protocols can be inherited from other protocols - this means adding requirements from the parent protocols to your own requirements. <br><br>  Let's see how you can use POP in practice. <br><br><h2>  Example 1 </h2><br>  The first example is an upgraded version of SegueHandler, presented at <a href="https://developer.apple.com/videos/play/wwdc2015/411/%3Ftime%3D1609">WWDC 2015 - Session 411 Swift in Practice</a> . <br><br>  Imagine that we have a RootViewController and we need to do the processing of transitions to DetailViewController and AboutViewController.  A typical implementation of <b>prepare (for: sender :)</b> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segue.identifier { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"DetailViewController"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid destination view controller type."</span></span>) } <span class="hljs-comment"><span class="hljs-comment">// configure vc case "AboutViewController": guard let vc = segue.destination as? AboutViewController else { fatalError("Invalid destination view controller type.") } // configure vc default: fatalError("Invalid segue identifier.") } }</span></span></code> </pre><br>  We know that we can have only 2 transitions - with id DetailViewController and AboutViewController with the same controller classes, however, we have to do a check for the unknown seque.identifier and type conversion segue.destination. <br><br>  Let's try to improve the code of this method.  Let's start with a description of possible transitions - enum is perfect for this: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueDestination</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> detail(<span class="hljs-type"><span class="hljs-type">DetailViewController</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> about(<span class="hljs-type"><span class="hljs-type">AboutViewController</span></span>) }</code> </pre><br>  (Note: SegueDestination is declared inside the RootViewController) <br><br>  Our goal is to write a universal helper method for conversion processing.  To do this, we define the SegueHandlerType protocol with an associated type describing the transition.  The associated type requirement is that it must provide a failable initializer that returns nil in case of a non-valid combination of segue id and controller type: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandlerType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueDestination</span></span>: <span class="hljs-type"><span class="hljs-type">SegueDestinationType</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueDestinationType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(segueId: <span class="hljs-type"><span class="hljs-type">String</span></span>, controller: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>) }</code> </pre><br>  The protocol is defined, now we add the segueDestination (forSegue :) method for it that returns a transition instance: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandlerType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forSegue segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueDestination</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = segue.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"segue id should not be nil"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> destination = <span class="hljs-type"><span class="hljs-type">SegueDestination</span></span>(segueId: id, controller: segue.destination) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Wrong segue Id or destination controller type"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> destination } }</code> </pre><br>  Let's make RootViewController implement SegueHandlerType (we will put it into a separate file so that this trivial code will rarely catch the eye): <br><br><pre> <code class="hljs pgsql">// file RootViewController+SegueHandler.swift <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> RootViewController.SegueDestination: SegueDestinationType { init?(segueId: String, controller: UIViewController) { switch (segueId, controller) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ("DetailViewController", let vc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DetailViewController): self = .detail(vc) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ("AboutViewController", let vc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> AboutViewController): self = .about(vc) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nil } } } <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> RootViewController: SegueHandlerType { }</code> </pre><br>  I want to note that the associated type in SegueHandlerType and enum in RootViewController have the same name, so the implementation of SegueHandlerType for RootViewController is empty.  In the case of different names, and if our enum were not defined inside the RootViewController, we would need to specify the type associated with the protocol using typealias: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandlerType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">SegueDestination</span></span> = <span class="hljs-type"><span class="hljs-type">RootControllerSegueDestination</span></span> }</code> </pre><br>  The final part of the example - now we can refactor prepare (for: sender :): <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueDestination(forSegue: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .detail(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc): <span class="hljs-comment"><span class="hljs-comment">// configure vc case .about(let vc): // configure vc } }</span></span></code> </pre><br>  The code has become much cleaner, right? <br><br>  Of course, as a result, the code became more - but we managed to separate the main logic (the one that is hidden behind the comments "// configure vc") and the auxiliary code.  Pros - the code has become easier to read, and the auxiliary SegueHandlerType can be reused. <br><br><h2>  Example 2 </h2><br>  Consider a typical task to display a list of items in UITableView. <br>  As the source data we have the <b>Cat</b> model and <b>TestCatRepository</b> , which corresponds to the <b>CatRepository</b> protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photo: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Cat</span></span>] }</code> </pre><br>  Table and cell controller classes have been added to the project: <b>CatListTableViewController</b> , <b>CatTableViewCell</b> . <br><br>  Let's try to describe a generalized protocol list.  Imagine that we have plans to add other tables to the project, which, in particular, may contain several sections.  Protocol requirements: <br><br><ul><li>  we should be able to set the number of elements in the section; <br></li><li>  it must be possible to specify types for the section index and for the element index ‚Äî they can be any ‚Äî a number, enum, tuple, we do not impose any requirements on them; <br></li><li>  cell type - we also do not impose any requirements on it, maybe just a TableViewCell, it can be a more complex type to get a cell of a certain type, if the table uses different types of cells (different Cell Identifier) <br></li><li>  the ability to process a cell update request - the easiest way is to assign a handler as a function with 2 parameters - a cell and its index. <br></li></ul><br>  Taking into account the requirements made, we write our protocol: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListViewType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">CellView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SectionIndex</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">ItemIndex</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(section: SectionIndex, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Int)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updateItemCallback: (<span class="hljs-type"><span class="hljs-type">CellView</span></span>, <span class="hljs-type"><span class="hljs-type">ItemIndex</span></span>) -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } }</code> </pre><br>  Let's describe the cell requirements for displaying cat information: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatCellType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params">: String)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params">: UIImage?)</span></span></span></span> }</code> </pre><br>  Add compliance with this protocol to the CatTableViewCell class. <br><br>  Our main protocol, ListViewType, must be added to CatListTableViewController.  We use only one type of cell - CatTableViewCell, so we use it as the associatedtype CellView.  There is only one section in the table and the number of elements is not known in advance - we use Void and Int as SectionIndex and ItemIndex, respectively. <br><br>  Full implementation of CatListTableViewController: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatListTableViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListViewType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemsCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updateItemCallback: (<span class="hljs-type"><span class="hljs-type">CatTableViewCell</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; () = { <span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(section: Void, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Int)</span></span></span></span> { itemsCount = <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> tableView.reloadData() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, numberOfRowsInSection section: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> itemsCount } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-string"><span class="hljs-string">"CatCell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">CatTableViewCell</span></span> updateItemCallback(cell, indexPath.row) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } }</code> </pre><br>  Now our goal is to connect CatRepository and ListViewType.  However, I do not want to associate the algorithm with a specific Cat model.  To do this, we select generalized protocols, where the type of the model is in the associatedtype: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepositoryType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Model</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Model</span></span>] } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableViewType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Model</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(using model: Model)</span></span></span></span> }</code> </pre><br>  Add compliance with new protocols: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Cat</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getCats() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCatRepository</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepositoryType</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatCellType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableViewType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(using model: Cat)</span></span></span></span> { setName(model.name) setImage(model.photo) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatTableViewCell</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableViewType</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Everything is ready to implement the method of displaying objects provided by the RepositoryType in the ListViewType list.  The algorithm will not support multiple sections, but uses Int as an index.  Add restrictions on the extension: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListViewType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionIndex</span></span></span><span class="hljs-class"> == (), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemIndex</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre><br>  Our CatListTableViewController complies with these limitations. <br>  But these are not all limitations - ListViewType.CellView should be ConfigurableViewType, and its Model type should be RepositoryType.Model: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-function">&lt;Repository: RepositoryType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(repository: Repository)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">CellView</span></span>: <span class="hljs-type"><span class="hljs-type">ConfigurableViewType</span></span>, <span class="hljs-type"><span class="hljs-type">CellView</span></span>.<span class="hljs-type"><span class="hljs-type">Model</span></span> == <span class="hljs-type"><span class="hljs-type">Repository</span></span>.<span class="hljs-type"><span class="hljs-type">Model</span></span> { ... }</code> </pre><br>  And these restrictions correspond to our class. <br><br>  Full extension code: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListViewType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionIndex</span></span></span><span class="hljs-class"> == (), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemIndex</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-function">&lt;Repository: RepositoryType&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(repository: Repository)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">CellView</span></span>: <span class="hljs-type"><span class="hljs-type">ConfigurableViewType</span></span>, <span class="hljs-type"><span class="hljs-type">CellView</span></span>.<span class="hljs-type"><span class="hljs-type">Model</span></span> == <span class="hljs-type"><span class="hljs-type">Repository</span></span>.<span class="hljs-type"><span class="hljs-type">Model</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> items = repository.getItems() refresh(section: (), <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: items.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) updateItemCallback = { cell, index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = items[index] cell.configure(using: item) } } }</code> </pre><br>  The main logic is ready, we use this function in AppDelegate: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> catListTableView = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>!.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! CatListTableViewController <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> repository = TestCatRepository() catListTableView.setup(repository: repository)</code> </pre><br>      <a href="https://github.com/Gotyanov/POP_CatList"></a> . <br><br>          ,     . <br><br>       extensions,    ,     ,     . ,  :      ?      ListViewType.  CatListTableViewController   ,     .  CatListTableViewController ,    : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">catListTableView</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setup</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">repository</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">repository</span></span>)</code> </pre><br>   CatListTableViewController ‚Äî Controller  MVC.    ‚Äî MVC,      . <br><br><h2>  Conclusion </h2><br> Protocol-Oriented Programming   Generic Programming   Traits. <br>  POP   ,   ,   ,      ,    . <br><br>  Sources: <br><br><ol><li> <a href="https://developer.apple.com/videos/play/wwdc2015/408/">WWDC 2015 ¬´Protocol-Oriented Programming in Swift¬ª</a> </li><li> <a href="https://developer.apple.com/videos/play/wwdc2015/411/">WWDC 2015 ¬´Swift in Practice¬ª</a> </li><li> <a href="https://developer.apple.com/videos/play/wwdc2016/419/">WWDC 2016 ¬´Protocol and Value Oriented Programming in UIKit Apps¬ª</a> </li><li> <a href="http://robnapier.net/erasure">type erasure</a> </li><li> <a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: Composable Units of Behaviour</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/358804/">https://habr.com/ru/post/358804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358794/index.html">Mitapa in May: blockchain in Moscow and testing in St. Petersburg</a></li>
<li><a href="../358796/index.html">Remote control of the heating system</a></li>
<li><a href="../358798/index.html">Inverse kinematics in two-dimensional space</a></li>
<li><a href="../358800/index.html">White spots in work with SSH</a></li>
<li><a href="../358802/index.html">USB3Vision and GenICam. View from the inside. I</a></li>
<li><a href="../358806/index.html">Red Hat Summit: The best moments of the main open source conference in 30 minutes</a></li>
<li><a href="../358808/index.html">Promise guide for those who want to understand them</a></li>
<li><a href="../358810/index.html">‚ÄúLife after Java 10‚Äù: what changes Java 11 will bring</a></li>
<li><a href="../358814/index.html">Lead Dev New York: review of reports and review of the conference</a></li>
<li><a href="../358816/index.html">Neural network speech synthesis with their own hands</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>