<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Smart home" with their own hands. Part 3. Synthesis and voice recognition using Google</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, we were able to obtain images from our webcams as snapshots once a second. Now it's time to take on the promised - voice recognit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Smart home" with their own hands. Part 3. Synthesis and voice recognition using Google</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/blogs/hardware/129799/">last article,</a> we were able to obtain images from our webcams as snapshots once a second.  Now it's time to take on the promised - voice recognition and synthesis. <a name="habracut"></a><br><br><h4>  Small retreat </h4><br>  Starting from this article, I will begin to describe my software, which coordinates all the subsystems of the smart home.  I consider it necessary to note that it has already gone far enough away from the code described in this article, with newer and more functional versions available through the trac <a href="http://trac.opensvn.ru/ion/timeline">link</a> .  Distribution is licensed under the <b>GNU GPLv3</b> .  If someone wants to join the development - you are welcome;) <br><br><h4>  A little information </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Speech recognition </h5><br>  As I wrote in the <a href="http://habrahabr.ru/blogs/hardware/129743/">first article</a> , we will use Google services for voice synthesis and recognition.  I think many have come across mobile devices running Android with voice search.  As an additional feature, this very voice search was added to the Google Chrome browser.  It should be noted that the company has not yet announced the official API for this service, but thanks to the open source Chrome, craftsmen have found what is being sent and what is being sent in response.  It looks like this: <br><br><ol><li>  We write the wav-file with a sampling frequency of sound 16000 Hz, mono </li><li>  We recode the resulting file into <b>flac</b> format </li><li>  We‚Äôll send the file to <b>https://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium&amp;lang=ru-RU</b> , representing Google as a Chrome client </li><li>  We get the answer in <b>JSON format</b> </li></ol><br><br>  The answer is something like: <br><br> <code>{"status":0,"id":"84e03bf4efe17fa7856333560d6faba4-1","hypotheses":[{"utterance":"  ","confidence":0.85437811}]}</code> <br> <br>  We are interested in the answer only the last two fields - <b>utterance</b> and <b>confidence</b> .  The first is the desired recognized word / phrase, the second is the recognition accuracy.  If <b>confidence</b> is more than <b>0.5</b> , we can assume that the recognition is reliable. <br><br><h5>  Speech synthesis </h5><br>  Speech synthesis will also be carried out through the Google service and, as far as I know, the official API has not announced to it.  To get a sound phrase from the text, you need to make an entirely uncomplicated combination of actions: <br><br><ol><li>  Send a request of the form: http://translate.google.com/translate_tts?tl=ru&amp;q=text, presented by Google Chrome browser in the headers </li><li>  Get response stream in MP3 encoding </li></ol><br><br>  As you can see, everything is not difficult at all.  Now we implement this information programmatically. <br><br><h4>  Some code </h4><br>  As I wrote, centrally managed our ‚Äúsmart home‚Äù will be a specially written <b>perl</b> demon.  I ask in advance for the quality of the code not to kick, for your humble servant is just a sysadmin :) <br>  So, we define the range of tasks that this software should perform: <br><br><ol><li>  Accept requests for recognition of sound files </li><li>  Determine the status of devices, give them commands </li><li>  Perform some actions if a command sequence is found. </li><li>  React in a specified way to data from sensors and cameras </li><li>  Keep statistics, records and logs </li><li>  Have a convenient web-interface for viewing status, cameras, giving commands, etc. </li></ol><br><br>  Perhaps I have forgotten something or missed it, but, as it seems to me, these are the main tasks of the smart home software.  Now we start to implement all this. <br><br>  To create a TCP / IP daemon on Perl, use the <b>Net :: Server :: Fork</b> module.  I will assume that you already know the <b>perl</b> language. <pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -w package iON; use strict; use utf8; use base qw(Net::Server::Fork); sub process_request { my $self = shift; while (&lt;STDIN&gt;) { if (/text (\d+)/) { toText($1); next; } if (/quit/i) { print "+OK - Bye-bye ;)\n\n"; last; } print "-ERR - Command not found\n"; logSystem(" : $_", 0); } } iON-&gt;run(port =&gt; 16000, background =&gt; undef, log_level =&gt; 4, host =&gt; 'localhost'); 1;</span></span></code> </pre>  Briefly run over, according to what is written here.  We declare ourselves a module with the name <b>iON</b> based on the <b>Net :: Server :: Fork</b> module and start the server on port 16000 on localhost with the highest level of logging details and without the ‚Äúdemon‚Äù mode.  Next, overload the <b>process_request ()</b> function.  She is responsible for processing the received data from the client.  In our case, if the server sees the text of the text format <b>number</b> - the <b>toText</b> function is <b>executed</b> with the parameters as a number that the client sent us.  With the <b>quit</b> command, I think everything is clear. <br><br>  What does the <b>toText ()</b> function <b>do</b> ?  Yes, actually, speech recognition! <pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toText</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $num = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"+OK - Trying recognize text\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $curl = WWW::Curl::Easy-&gt;new; $curl-&gt;setopt(CURLOPT_HEADER,<span class="hljs-number"><span class="hljs-number">1</span></span>); $curl-&gt;setopt(CURLOPT_POST,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">#$curl-&gt;setopt(CURLOPT_VERBOSE, 1); my @myheaders=(); $myheaders[0] = "Content-Type: audio/x-flac; rate=16000"; $curl-&gt;setopt(CURLOPT_HTTPHEADER, \@myheaders); $curl-&gt;setopt(CURLOPT_URL, 'https://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium&amp;lang=ru-RU'); my $curlf = WWW::Curl::Form-&gt;new; $curlf-&gt;formaddfile("data/input-$num.flac", 'myfile', "audio/x-flac"); $curl-&gt;setopt(CURLOPT_HTTPPOST, $curlf); my $response_body; $curl-&gt;setopt(CURLOPT_WRITEDATA,\$response_body); # Starts the actual request my $retcode = $curl-&gt;perform; # Looking at the results... if ($retcode == 0) { $response_body =~ /\n\r\n(.*)/g; my $json = $1; my $json_xs = JSON::XS-&gt;new(); $json_xs-&gt;utf8(1); my @hypo = $json_xs-&gt;decode($json)-&gt;{'hypotheses'}; my $dost = $hypo[0][0]{'confidence'}; my $text = $hypo[0][0]{'utterance'}; $dost = 0.0 if !defined $dost; $text = "" if !defined $text; print "+OK - Text is: \"$text\", confidence is: $dost\n"; if($dost &gt; 0.5) { checkcmd($text); } { print "+ERR - Confidence is lower, then 0.5\n"; #sayText("  !"); } } else { # Error code, type of error, error message print("+ERR - $retcode ".$curl-&gt;strerror($retcode)." ".$curl-&gt;errbuf); } system("rm data/input-$num.flac"); }</span></span></code> </pre>  I will not describe in detail - it is exactly those actions that are needed for text recognition.  Google is fed a file from the <b>data</b> subdirectory named <b>input-number.flac</b> .  How it is formed there, a little later.  After - the answer is read, and if its accuracy is above 0.5, the recognized text is passed as a parameter to the function <b>checkcmd ()</b> .  At the end of everything, the sound file is deleted.  I note that it will be necessary to install the <b>curl</b> program and add more modules to the beginning of our script: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> WWW::Curl::Easy; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> WWW::Curl::Form; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> JSON::XS;</code> </pre>  Now about speech synthesis.  This will be handled by a function called <b>sayText ()</b> in the parameter quotation, which accepts the actual text that needs to be voiced.  But first, let's add some missing modules and global variables: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> Encode; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> URI::Escape; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> LWP::UserAgent; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $mp3_data;</code> </pre>  Now the code itself: <pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayText</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $text = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"+OK - Speaking \"$text\"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $url = <span class="hljs-string"><span class="hljs-string">"http://translate.google.com/translate_tts?tl=ru&amp;q="</span></span>.uri_escape_utf8($text); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $ua = LWP::UserAgent-&gt;new( <span class="hljs-string"><span class="hljs-string">agent =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.872.0 Safari/535.2"</span></span>); $ua-&gt;get($url, <span class="hljs-string"><span class="hljs-string">':content_cb'</span></span> =&gt; \&amp;callback); <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> (MP3, <span class="hljs-string"><span class="hljs-string">"|padsp splay -M"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"[err] Can't save: $!\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> MP3 $mp3_data; <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(MP3); $mp3_data = <span class="hljs-keyword"><span class="hljs-keyword">undef</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"+OK - Done!\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($data, $response, $protocol) = @_; $mp3_data .= $data; <span class="hljs-comment"><span class="hljs-comment"># }</span></span></code> </pre>  As you can see, the server‚Äôs response as a stream is handled by the <b>callback ()</b> function, which adds data to the <b>$ mp3_data</b> variable.  The data is transmitted via the pipe to the <b>splay</b> program which is launched via the <b>padsp</b> program, which is responsible for the OSS emulation (in Ubuntu, the OSS was drunk).  The <b>-M switch</b> causes the program to play data from the standard input. <br><br>  Now let's talk about where the mysterious files appear in <b>flac</b> in the <b>data</b> directory.  Everything is simple - a separate script deals with this: <pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use strict; use IO::Socket; while (1) { my $rnd = int(rand(1000)); `rec -q -c 1 -r 16000 ./data/input-$rnd.wav trim 0 4`; `flac -f -s ./data/input-$rnd.wav -o ./data/input-$rnd.flac`; `rm ./data/input-$rnd.wav`; my $sock = new IO::Socket::INET( PeerAddr =&gt; "localhost", PeerPort =&gt; 16000, Proto =&gt; 'tcp') || next; print $sock "text ".$rnd; undef $rnd; }</span></span></code> </pre>  As we can see, writing and format conversion perform several programs called from the script: <br><br><ol><li>  rec (from the distribution of the <b>sox</b> program) </li><li>  flac </li></ol><br><br>  The <b>rec</b> command makes short 4-second records with a random number in the name, which are clamped by the <b>flac</b> program.  After that, a connection is made to our main daemon and the command <b>text that_tour_random_number is transmitted</b> .  Why do I write 4 second short records?  The thing is how the computer will record our voice.  There are two possible solutions: <br><br><ol><li>  Permanent record </li><li>  Write file when exceeding a certain volume </li></ol><br><br>  The second option did not suit me for various reasons, including due to bad microphones;) Let us examine in more detail the first option with a permanent recording.  We break our record into many small pieces that are constantly sent to the Google server for recognition.  I found that all of my teams have entered a maximum of 3-4 seconds so far.  If we run several (suppose 5) copies of the script with an interval of 1 second, we get continuous voice recognition.  Add this functionality to our main program: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>(<span class="hljs-string"><span class="hljs-string">"perl mic.pl &amp;&gt;/dev/null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre>  Now we only need to implement the function <b>checkcmd ()</b> in order to test the operation of the whole complex.  We also need an address reversal to eliminate false positives. <pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkcmd</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $text = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($text =~ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>) { sayText(<span class="hljs-string"><span class="hljs-string">"  - $text"</span></span>); <span class="hljs-comment"><span class="hljs-comment"># if $text eq "  "; } }</span></span></code> </pre>  Now, put it all together.  We got two scripts, let's call them <b>srv.pl</b> and <b>mic.pl</b> , as well as the <b>data</b> subdirectory for storing our sound files. <br><br>  srv.pl <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -w package iON; use strict; use utf8; use WWW::Curl::Easy; use WWW::Curl::Form; use JSON::XS; use URI::Escape; use LWP::UserAgent; require Encode; use base qw(Net::Server::Fork); ##  ################################ $|=1; our $parent = $$; our $mp3_data; ################################ for(1..5) { system("perl mic.pl &amp;&gt;/dev/null"); sleep 1; } ##    ############################### iON-&gt;run(port =&gt; 16000, background =&gt; undef, log_level =&gt; 4, host =&gt; 'localhost'); ################################ ################################ sub DESTROY { if($$ == $parent) { system("killall perl"); system("rm data/*.flac &amp;&amp; rm data/*.wav"); } } ##    ################################ sub process_request { my $self = shift; while (&lt;STDIN&gt;) { if (/text (\d+)/) { toText($1); next; } if (/quit/i) { print "+OK - Bye-bye ;)\n\n"; last; } print "-ERR - Command not found\n"; } } ############################### ############################### sub toText { my $num = shift; print "+OK - Trying recognize text\n"; my $curl = WWW::Curl::Easy-&gt;new; $curl-&gt;setopt(CURLOPT_HEADER,1); $curl-&gt;setopt(CURLOPT_POST,1); #$curl-&gt;setopt(CURLOPT_VERBOSE, 1); my @myheaders=(); $myheaders[0] = "Content-Type: audio/x-flac; rate=16000"; $curl-&gt;setopt(CURLOPT_HTTPHEADER, \@myheaders); $curl-&gt;setopt(CURLOPT_URL, 'https://www.google.com/speech-api/v1/recognize?xjerr=1&amp;client=chromium&amp;lang=ru-RU'); my $curlf = WWW::Curl::Form-&gt;new; $curlf-&gt;formaddfile("data/input-$num.flac", 'myfile', "audio/x-flac"); $curl-&gt;setopt(CURLOPT_HTTPPOST, $curlf); my $response_body; $curl-&gt;setopt(CURLOPT_WRITEDATA,\$response_body); # Starts the actual request my $retcode = $curl-&gt;perform; # Looking at the results... if ($retcode == 0) { $response_body =~ /\n\r\n(.*)/g; my $json = $1; my $json_xs = JSON::XS-&gt;new(); $json_xs-&gt;utf8(1); my @hypo = $json_xs-&gt;decode($json)-&gt;{'hypotheses'}; my $dost = $hypo[0][0]{'confidence'}; my $text = $hypo[0][0]{'utterance'}; $dost = 0.0 if !defined $dost; $text = "" if !defined $text; print "+OK - Text is: \"$text\", confidence is: $dost\n"; if($dost &gt; 0.5) { checkcmd($text); } { print "+ERR - Confidence is lower, then 0.5\n"; } } else { # Error code, type of error, error message print("+ERR - $retcode ".$curl-&gt;strerror($retcode)." ".$curl-&gt;errbuf); } system("rm data/input-$num.flac"); } ############################### ##    ############################### sub checkcmd { my $text = shift; chomp $text; $text =~ s/ $//g; print "+OK - Got command \"$text\" (Length: ".length($text).")\n"; if($text =~ //) { sayText("  - $text"); } return; } ##  ############################### sub sayText { my $text = shift; print "+OK - Speaking \"$text\"\n"; my $url = "http://translate.google.com/translate_tts?tl=ru&amp;q=".uri_escape_utf8($text); my $ua = LWP::UserAgent-&gt;new( agent =&gt; "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.872.0 Safari/535.2"); $ua-&gt;get($url, ':content_cb' =&gt; \&amp;callback); open (MP3, "|padsp splay -M") or die "[err] Can't save: $!\n"; print MP3 $mp3_data; close(MP3); $mp3_data = undef; print "+OK - Done!\n"; return; } sub callback { my ($data, $response, $protocol) = @_; $mp3_data .= $data; # } ######################################## ######################################## 1;</span></span></code> </pre><br>  mic.pl <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use strict; use IO::Socket; while (1) { my $rnd = int(rand(1000)); `rec -q -c 1 -r 16000 ./data/input-$rnd.wav trim 0 3`; `flac -f -s ./data/input-$rnd.wav -o ./data/input-$rnd.flac`; `rm ./data/input-$rnd.wav`; my $sock = new IO::Socket::INET( PeerAddr =&gt; "localhost", PeerPort =&gt; 16000, Proto =&gt; 'tcp') || next; print $sock "text ".$rnd; undef $rnd; }</span></span></code> </pre><br><h4>  What happened </h4><br>  Give the right to run our scripts: <br><br> <code>chmod 755 srv.pl mic.pl</code> <br> <br>  Run the <b>srv.pl</b> script, wait for all processes to start, say, say, the phrase: ‚ÄúSystem!  One two Three!".  We hear in a few seconds: ‚ÄúYour team is two times three‚Äù.  It should be noted that our team will fall into several sound files and, accordingly, be executed several times.  To avoid this, you need to enter a check for the last command.  Add this functionality in the next section. <br><br><h4>  Total </h4><br>  In this article, we have implemented the base of our software for managing the ‚Äúsmart home‚Äù system.  So far it is not able to do anything except speech recognition and synthesis, but this is temporary;) <br><br>  In the next article I will tell you how to fasten a web-interface with some tasty buns and camera viewing to this whole thing. <br><br>  <b>UPD:</b> <a href="http://habrahabr.ru/blogs/hardware/130239/">Part 4</a> <br><br></div><p>Source: <a href="https://habr.com/ru/post/129936/">https://habr.com/ru/post/129936/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129926/index.html">Apple spends just over $ 200 on iPhone 4S components</a></li>
<li><a href="../129928/index.html">The basic architecture of a web application on Backbone.js</a></li>
<li><a href="../129932/index.html">QR code for lost keys</a></li>
<li><a href="../129933/index.html">Three Evernote for iOS fixes</a></li>
<li><a href="../129935/index.html">SPASIBOPUTINUZAETO</a></li>
<li><a href="../129937/index.html">Canobuvosti, 112th edition</a></li>
<li><a href="../129938/index.html">Nokia N9 Review</a></li>
<li><a href="../129939/index.html">Intellectual Ventures Motorola Mobility accused of violating its patents</a></li>
<li><a href="../129940/index.html">GMP: week before, week after</a></li>
<li><a href="../129941/index.html">The announcement of Google Nexus Prime postponed indefinitely</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>