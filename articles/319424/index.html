<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Graal and Truffle (Graal & Truffle)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A little-known research project that can significantly accelerate innovation in the design of programming languages. 

 From translator 


 I want to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Graal and Truffle (Graal & Truffle)</h1><div class="post__text post__text-html js-mediator-article">  <i>A little-known research project that can significantly accelerate innovation in the design of programming languages.</i> <br><br><h2>  From translator </h2><br><p>  <i>I want to immediately warn you that the article in some places resembles a presentation of a large company because of epithets in the spirit of ‚Äúchange the industry‚Äù, ‚Äúthe best on the market‚Äù, ‚Äúbreakthrough technologies‚Äù, etc. If you close your eyes to this emotional style of narration, you‚Äôll get New technologies compilers and virtual machines.</i> </p><br><h2>  Introduction </h2><br><p>  Since the heyday of the computer industry, many have been fascinated by the quest in search of the perfect programming language.  The quest is very difficult: the creation of a new language is not an easy task.  And very often, the process of fragmentation of the established programming ecosystem occurs and it becomes necessary to rebuild the basic tools for a new language: compiler, debugger, HTTP stack, IDE, libraries and an infinite number of basic blocks are written from scratch for each new language.  Excellence in the design of programming languages ‚Äã‚Äãis unattainable, and new ideas arise constantly.  We are like Sisyphus: sentenced by the gods to the eternal pushing of a stone into a mountain, in order to see how it rolls down again and again ... for ages. </p><br><p>  How can you break this vicious cycle?  Let's dream what we would like. </p><a name="habracut"></a><br><p>  We need something, a special tool that will do the following: </p><br><ol><li>  A way to create a new language in just a week </li><li>  And so that it automatically works as fast as other languages. </li><li>  So that he has the support of a quality debugger, automatically (ideally, without slowing down the program) </li><li>  Support profiling, automatically </li><li>  Having a quality garbage collector, automatically ... but only if we need it </li><li>  So that the language can use all the existing code, regardless of what it was written on </li><li>  That language supports any programming style from low-level C or FORTRAN to Java, Haskell and fully dynamic scripting languages ‚Äã‚Äãsuch as Python and Ruby. <br>  To support just-in-time and ahead-of-time compilation </li><li>  And finally, to support hot-swappable code (hotswap) in an already running program. </li></ol><br><p>  And yet, of course, we want to have the open source code of this magic tool.  And let there be ponies.  It seems to be all. </p><br><p>  A clever reader, of course, guessed that I would not begin this article if I did not have such a tool.  His name is a little strange - Graal &amp; Truffle.  And let the name rather fit the pretentious hipster restaurant, in fact it is a significant research project, in which more than 40 scientists from the IT industry and universities participate.  Together they build new compiler and virtual machine technologies that implement all the items on our list. </p><br><p>  They invented a new way to quickly create programming languages ‚Äã‚Äãwithout problems with libraries, optimizing compilers, debuggers, profilers, binding to C libraries and other attributes that are needed by the modern programming language.  This tool promises to cause a wave of innovations in programming languages ‚Äã‚Äãand - I hope - reformat the entire IT industry. </p><br><p>  That's about it and talk. </p><br><h2>  What is Graal and Truffle? </h2><br><p>  Graal is a research compiler.  And Truffle is ... it's such a thing that is difficult to compare with anything.  In short, the following comes to mind: Truffle is a framework for creating programming languages ‚Äã‚Äãby writing an interpreter for an abstract syntax tree. </p><br><p>  When creating a new programming language, the first thing is determined by the grammar.  Grammar is a description of the syntax rules of your language.  Using grammar and a tool like <a href="http://www.antlr.org/">ANTLR</a> you get a parser.  At the exit of the parser you will have a parsing tree </p><br><img src="https://habrastorage.org/files/858/323/86a/85832386a73c4ded92feb77551acb637.png"><br><p>  The picture shows a tree, which was obtained after the work of ANTLR for the following line of code: </p><br><br><pre><code class="hljs pgsql">Abishek <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (country = India <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> City = BLR) <span class="hljs-keyword"><span class="hljs-keyword">LOGIN</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span></code> </pre> <br><p>  A parsing tree and a derivative of it, called the <i>abstract syntax tree</i> (AST), is a natural way of expressing programs.  After building such a tree, there will be one simple step to a running program.  You will need to add the "execute" method to the tree node class.  When executing ‚Äúexecute,‚Äù each node can call child nodes and combine the results to get the value of an expression or execute an instruction.  And, in principle, that's all! </p><br><p>  Take for example dynamic programming languages ‚Äã‚Äãsuch as Python, JavaScript, PHP and Ruby.  For these languages, their dynamism was the result of moving along the path of least resistance.  If you create a language from scratch, complicating the language with a static type system or an optimizing compiler can slow down the development of a language greatly.  The consequences of such a choice result in poor performance.  But even worse, there is a temptation to quickly add features to the simple / slow interpreter AST.  After all, optimizing the performance of these features later will be very difficult. </p><br><p>  <a href="https://github.com/graalvm/truffle">Truffle</a> is a framework for writing interpreters using annotations and a small amount of additional code.  Truffle paired with Graal will allow you to convert such interpreters to JIT compiling virtual machines (VM) ... automatically.  The resulting execution environment at times of peak performance can compete with the best existing compilers (manually tuned and customized for a particular language).  For example, the implementation of a JavaScript language called TruffleJS obtained in this way can be frustrated with V8 in performance tests. </p><br><p>  The RubyTruffle engine is faster than all other Ruby implementations.  The TruffleC engine is roughly competing with GCC.  There are already implementations of some languages ‚Äã‚Äã(different degrees of readiness) using Truffle: </p><br><ul><li>  Javascript </li><li>  Python 3 </li><li>  Ruby </li><li>  LLVM bitcode - allows you to run programs in C / C ++ / Objective-C / Swift </li><li>  Another engine for interpreting C source code without compiling it in LLVM (read below for the advantages of this approach) </li><li>  R </li><li>  Smalltalk </li><li>  Lua </li><li>  Many small experimental languages </li></ul><br><p>  To make it clear how easy it is to create these engines, the source code for TruffleJS is only about 80,000 lines, compared to 1.7 million lines of code in V8. </p><br><h2>  To hell with the details, how can I play with all this? </h2><br><p>  Graal and Truffle are the result of Oracle Labs, a part of the Java team working on virtual machine research.  <a href="http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index.html"><b>GraalVM lies here</b></a> .  This is an advanced Java Development Kit, which contains some of the languages ‚Äã‚Äãfrom the above list, as well as substitutes for console utilities NodeJS, Ruby and R. The package also includes the training language ‚ÄúSimpleLanguage‚Äù, from which you can start your introduction to Graal and Truffle. </p><br><h2>  What is Graal for? </h2><br><p>  If Truffle is a framework for creating AST interpreters, then Graal is a thing to speed up such interpreters.  Graal is a work of art in the field of optimizing compilers.  It supports the following features: </p><br><ul><li>  Can be run in just-in-time and ahead-of-time modes. </li><li>  Very advanced optimizations that include <i>partial escape analysis</i> .  Escape analysis allows you to avoid allocation of objects in the heap, if it is not really necessary.  The popularity of EA is due to the development of the JVM, but this optimization is very complex and is supported by a small number of virtual machines.  The JavaScript compiler ‚ÄúTurbofan‚Äù used in the Chrome browser began to receive escape analysis optimization only at the end of 2015.  Graal has advanced optimizations for a wider range of cases. </li><li>  Works in conjunction with Truffle-based languages ‚Äã‚Äãand allows you to convert Truffle AST into optimized native code due to <i>partial computation</i> .  The partial computation of a specialized interpreter is called the ‚Äúfirst projection of Futamura‚Äù ( <a href="https://en.wikipedia.org/wiki/Partial_evaluation">‚Äúfirst Futamura projection‚Äù</a> ).  <i>[As far as I understand from Wikipedia, the first projection of Futamura allows the interpreter to be customized for the source code.</i>  <i>That is, if some features of the language are not used in the code, then these features are ‚Äúcut out‚Äù from the interpreter.</i>  <i>And then the interpreter ‚Äúturns‚Äù into a compiler that generates native code.</i>  <i>Correct if I messed up.]</i> </li><li>  Contains advanced visualization tools that allow you to study the intermediate representation of the compiler at each stage of optimization. </li><li>  Written in Java.  So it is much easier to study and experiment than traditional compilers written in C or C ++. </li><li>  Starting with Java 9, Graal can be used as a JVM plugin. </li></ul><br><img src="https://habrastorage.org/files/3e6/943/cf7/3e6943cf70414492994b6477129e1cab.png"><br>  <i>IGV visualization</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  From the very beginning, Graal was designed as a multilanguage compiler.  But its optimizations are particularly well suited for high-level languages ‚Äã‚Äãof abstraction and dynamism.  Java programs work in this virtual machine in the same way as in existing JVM compilers.  While Scala programs run about 20% faster.  Ruby programs get a gain of 400% compared to the <i>best</i> implementation to date (and this is not MRI). </p><br><h2>  Polyglot </h2><br><p>  Not tired yet?  But this is only the beginning. </p><br><p>  Truffle contains a special interlanguage framework called Polyglot.  It allows Truffle-languages ‚Äã‚Äãto call each other.  And there is the <i>Truffle Object Storage Model</i> , which standardizes and optimizes most of the behavior of objects in dynamically typed languages.  And at the same time allows you to share such objects.  Do not forget that Graal and Truffle are built on Java technology and can communicate with JVM languages ‚Äã‚Äãsuch as Java, Scala and even Kotlin.  Moreover, this communication is two-way: Graal-Truffle code can call Java libraries, and Java code can call Graal-Truffle libraries. </p><br><p>  Polyglot works in a very unusual way.  As you remember, Truffle is a framework for describing abstract syntax tree (AST) nodes.  As a result, access to other languages ‚Äã‚Äãdoes not occur through an additional layer of abstractions and wrappers, but by merging two AST trees into one.  As a result, the resulting syntax tree is compiled (and optimized) within Graal as a whole.  So any difficulties that may appear at the junction of two programming languages ‚Äã‚Äãcan be analyzed and simplified. </p><br><p>  For this reason, the researchers decided to implement the C interpreter through Truffle.  Usually we take C as a compiled language.  But there is no real reason for this.  History knows cases where the C interpreter was used in real programs.  For example, the video editor <a href="https://en.wikipedia.org/wiki/Shake_%2528software%2529">Shake special effect</a> gave users the ability to write scripts in C. </p><br><p>  Due to known performance problems with scripting languages, critical program sections are often rewritten in C using the internal interpreter APIs.  As a result, such an approach significantly complicates the task of accelerating the language, because besides the interpreter itself, it is necessary to launch extensions to C. The global optimization task is complicated by the fact that these extensions are based on assumptions about the internal implementation of the language. </p><br><p>  When the authors of RubyTruffle encountered this problem, they came up with an elegant solution: let's write a special C interpreter that will not only understand simple C, but also macros and other constructions that are specific to Ruby extensions.  Then after the merger of the Ruby and C interpreters through Truffle, a single code will be obtained, and the costs of interlanguage communication will be leveled by the optimizer.  The result is TriffleC. </p><br><p>  You can read a great explanation of how it all works in an <a href="http://chrisseaton.com/rubytruffle/cext/">article by one of the researchers of this project, Chris Seaton</a> .  Or you can study a <a href="http://chrisseaton.com/rubytruffle/dls15-interop/dls15-interop.pdf">scientific article with a detailed description</a> . </p><br><h2>  Let's do secure memory management in C </h2><br><p>  C programs run fast.  But there is a downside - hackers love them very much, because it's too easy to shoot yourself in the foot while working with memory. </p><br><p>  The ManagedC language appeared as a continuation of TruffleC and replaces standard memory management with controlled allocations with the garbage collector.  ManagedC supports pointer arithmetic and other low-level constructions while avoiding heaps of errors.  The price of reliability is 15% sagging performance compared to GCC, as well as the active use of ‚Äúindefinite behavior‚Äù that many C compilers love so much. This means that if your program works with GCC, it does not guarantee that it will run under ManagedC.  At the same time, ManagedC itself fully implements the C99 standard. </p><br><p>  You can find more information from the article <a href="http://chrisseaton.com/plas15/safec.pdf">‚ÄúMemory safe execution of C on a Java VM‚Äù</a> . </p><br><h2>  Debugging and profiling for free </h2><br><p>  All developers of programming languages ‚Äã‚Äãare faced with the problem of lack of quality tools.  Take for example GoLang.  The GoLang ecosystem has suffered for many years from a bad, primitive, and poorly portable ported debugger and profiler. </p><br><p>  Another problem is to add debugger support to the interpreter.  That is, the native code must be close to the source code in order to be able to establish a one-to-one correspondence between the current state of the virtual machine and the code that the developer wrote.  This usually leads to the abandonment of compiler optimizations and a general slowdown in debugging. </p><br><p>  This is where Truffle comes to the rescue, which offers a simple API that allows you to embed an advanced debugger into the interpreter ... without slowing down the program.  The compiler still applies optimization, and the state of the program during debugging remains the same as expected by the programmer.  All thanks to the metadata that Graal and Truffle generate during the compilation process into native code.  The resulting metadata is then used to <i>de-optimize the</i> parts of the running program to get the initial state of the interpreter.  When using a breakpoint, watchpoint, profiling point, or other debugging mechanism, the virtual machine rolls back the program to its slow form, adds nodes to the AST to implement the necessary functionality and recompiles everything back to the native code, which replaced on the fly. </p><br><p>  Of course, the debugger is not only a feature of the execution environment.  Need more UI for users.  Therefore, there is a <a href="http://plugins.netbeans.org/plugin/61687/truffle-debugging-support">plugin for NetBeans IDE</a> with support for any Truffle language. </p><br><p>  For details, I send you to the article <a href="http://www.labri.fr/perso/fmoranda/icooolps15/p1.pdf">‚ÄúBuilding debuggers and other tools: we can have it all‚Äù</a> . </p><br><h2>  LLVM support </h2><br><p>  Truffle is mainly used to create source interpreters.  But nothing prevents to use this framework for other purposes.  The <a href="https://github.com/graalvm/sulong/">Sulong</a> project is a Truffle interpreter for LLVM bytecode. </p><br><p>  The Sulong project is still at an early stage of development and contains a number of limitations.  But theoretically, launching bytecode using Graal and Truffle will allow you to work not only with C, but also C ++, Objective-C, FORTRAN, Swift and maybe even Rust. </p><br><p>  Sulong also contains a <a href="">simple C API for interacting with other Truffle languages ‚Äã‚Äãvia Polyglot</a> .  Again, thanks to the independence of the programming language and the completely dynamic nature of this API, the resulting code will be aggressively optimized, and the overhead will be minimized. </p><br><h2>  Hot Swap (HotSwap) </h2><br><p>  Hot swap is the ability to change the program code in the process of its work without restarting.  This is one of the main advantages of dynamic programming languages, allowing to achieve high performance programmers.  There is a <a href="https://comserv.cs.ut.ee/home/files/Pool_ComputerScience_2016.pdf%3Fstudy%3DATILoputoo%26reference%3D6319668E7151D556131810BC3F4A627D7FEF5F3B">scientific article dedicated to the implementation of hot-swap in the Truffle framework</a> (not sure that support has already been added to Truffle itself).  As with the debugger, profiler, and optimizers, developers of languages ‚Äã‚Äãon Truffle will just need to use the new APIs to support hot-swap.  This API is much more convenient than your own bikes. </p><br><h2>  Where is the catch? </h2><br><p>  As you know, in life there is nothing perfect.  Graal and Truffle offer a solution for almost all of our desires from the original list.  Developers of programming languages ‚Äã‚Äãshould be just happy.  But there is a price for this convenience: </p><br><ul><li>  Warm up time </li><li>  Memory consumption </li></ul><br><p>  The process of converting an interpreter into an optimized native code requires studying how the program works in real conditions.  This, of course, is not news.  The term ‚Äúwarm-up‚Äù (i.e., acceleration as you work) is known to everyone who uses modern virtual machines, such as HotSpot or V8.  But Graal is also driving progress, taking profiling optimization to a higher level.  As a result, GraalVM very much depends on the profiling information. </p><br><p>  It is for this reason that researchers measure only peak performance, that is, they give the program some time to work.  It does not take into account the time required for such heating.  For server applications, this is not a big problem, since only peak performance is important in this area.  But in other applications, a long warm-up can put an end to the use of Graal.  In practice, this picture can be seen when working with the Octane performance test (you can find it in the JDK technical preview): the final score is slightly lower than that of Chrome, even considering the rather long Graal warm-up (15-60 seconds), which is not taken into account evaluation. </p><br><p>  The second problem: memory consumption.  If the program is highly dependent on speculative optimizations, it needs to store tables with compiler's meta-information for deoptimization ‚Äî the inverse transformation from the state of the machine to an abstract interpreter.  And this meta-information occupies as much space as the final code, even with all the seals and compressions.  Do not forget that you need to store the original AST or bytecode in case of violation of the heuristic assumptions in the native code.  All this mercilessly clutters RAM. </p><br><p>  Add to this the fact that Graal, Truffle and Truffle-based languages ‚Äã‚Äãare themselves written in Java.  This means that the compiler also needs time for its warming up in order to work in full force.  And of course, memory consumption for basic data structures will grow, and these basic compiler structures fall under garbage collection. </p><br><p>  The people behind Graal and Truffle, of course, are aware of these problems and are already thinking about solutions.  One of them is called SubstrateVM.  This is a virtual machine written entirely in Java and compiled ahead (ahead-of-time) using the appropriate compiler Graal and Truffle.  Functionally, SubstrateVM is not as advanced as HotSpot: it cannot dynamically load code from the Internet, and the garbage collector is pretty simple.  But having compiled this virtual machine once you can save a lot on warm-up time in the future. </p><br><p>  And one more subtlety, which can not be silent.  In our initial list of women, there is an item about the openness of the source code.  Graal and Trulle are large and very expensive projects written by experienced people.  Therefore, their development can not be cheap.  To date, only some parts of the above are distributed with open source. </p><br><p>  All code can be found on GitHub or other mirrors: </p><br><ul><li>  <a href="https://github.com/graalvm/graal-core">Graal</a> &amp; <a href="https://github.com/graalvm/truffle">Truffle</a> . </li><li>  Expandable version of HotSpot (project basis). </li><li>  <a href="https://github.com/graalvm/rubytruffle">Rubyruffle</a> </li><li>  <a href="https://github.com/graalvm/sulong">Sulong</a> (support LLVM bitcode) </li><li>  <a href="https://github.com/graalvm/fastr">R</a> , Python 3 and Lua implementations (some of them are created as hobby / research projects). </li></ul><br><p>  And the following parts do not apply to OpenSource </p><br><ul><li>  TruffleC / ManagedC </li><li>  TruffleJS / NodeJS API </li><li>  SubstrateVM </li><li>  AOT support </li></ul><br><p>  TruffleJS can be downloaded for free as part of the GraalVM preview release.  I do not know how to play around with TruffleC or ManagedC.  The Sulong project covers some of this functionality. </p><br><h2>  What to read </h2><br><p>  A canonical, full-scale, all-in-one tutorial across Graal and Truffle in this report: <a href="https://www.youtube.com/watch%3Fv%3DFJY96_6Y3a4">"One VM to rule them</a> . <a href="https://www.youtube.com/watch%3Fv%3DFJY96_6Y3a4">"</a>  It takes three hours, I warned you.  Only for real enthusiasts. </p><br><p>  There are more tutorials on using Truffle: </p><br><ul><li>  <a href="http://stefan-marr.de/2015/11/add-graal-jit-compilation-to-your-jvm-language-in-5-easy-steps-step-1/">A tutorial by Stefan Marr</a> </li><li>  <a href="http://cesquivias.github.io/tags/truffle.html">A tutorial by Cristian Esquivas</a> </li></ul><br><h2>  What's next? </h2><br><p>  In the beginning, I mentioned that we can remove the barriers to creating new programming languages.  This will open the door to a new wave of innovation in languages.  Here is a short <a href="https://gist.github.com/smarr/d1f8f2101b5cc8e14e12">list of experimental languages</a> .  I hope this list will be updated in the future. </p><br><p>  If you try the new ideas offered in Graal and Truffle, then you will discover the opportunity to really work with your own language from the first days of its existence.  As a result, there will be a growing community of participants who can deploy your language in their projects.  This will create a magic cycle: the community leaves its feedback and ideas, you implement improvements.  In general, this will accelerate the path from experiments to the final implementation.  This is exactly what I expect. </p></div><p>Source: <a href="https://habr.com/ru/post/319424/">https://habr.com/ru/post/319424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319410/index.html">Dynamic network traffic redirection</a></li>
<li><a href="../319414/index.html">Training acid battery somehow and do it yourself</a></li>
<li><a href="../319416/index.html">Juniper firewall update unauthorized root access to devices</a></li>
<li><a href="../319418/index.html">How to create your file system based on blob fields in the database. Why is it convenient? Efficiency issues</a></li>
<li><a href="../319422/index.html">Cooking ORM, without departing from the plate. We generate SQL - query based on binary expression trees</a></li>
<li><a href="../319426/index.html">Who posted the 10 millionth comment? Secrets of numerology</a></li>
<li><a href="../319430/index.html">HPE Synergy Pro - Part V. Control</a></li>
<li><a href="../319436/index.html">tiny-dnn - library announcement</a></li>
<li><a href="../319438/index.html">Where to place containers: on a dedicated server or a virtual machine?</a></li>
<li><a href="../319440/index.html">About Haskell for the smallest on the example of the problem with codefights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>