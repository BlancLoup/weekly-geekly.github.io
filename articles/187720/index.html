<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Raytracing render on C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having experience in developing one of the high-level programming languages, as well as interest in tasks from various computer science fields, I fina...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Raytracing render on C</h1><div class="post__text post__text-html js-mediator-article">  Having experience in developing one of the high-level programming languages, as well as interest in tasks from various computer science fields, I finally found the opportunity to master another tool ‚Äî the C programming language.  Therefore, it was decided to implement a Ray tracing render from scratch (since I am fond of computer graphics since school times). <br><br>  In this article I want to share my own approach and the results obtained. <br><br><img src="https://habrastorage.org/storage2/aa8/5f7/2d1/aa85f72d11a4f3bce1ee1e89210b3313.jpg"><br><a name="habracut"></a><br><h4>  Some words about raytracing </h4><br>  Imagine that we have a camera (for simplicity, we assume that our camera is a material point).  We also have a design plane, which is a set of pixels.  Now, from the camera, to each pixel of the design plane, we will conduct vectors ( <i>primary rays</i> ) and for each beam find the nearest object of the scene that it intersects.  Color that corresponds to the intersection point, you can paint the corresponding pixel on the design plane.  Repeating this procedure for all points of the design plane - we will get an image of a three-dimensional scene.  If we confine ourselves only to these operations, then the resulting algorithm will be called <a href="http://ru.wikipedia.org/wiki/Ray_casting">Ray casting</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Recursive Ray casting == Ray tracing </h5><br><ul><li>  From the point of intersection of the primary beam with the object of the scene, you can release a secondary beam - directed to the light source.  If it intersects any object of the scene, then this point of the object is in the shadow.  This technique allows to obtain <b>geometrically correct shadows</b> . <br><br></li><li>  If an object has a mirror surface, then according to the laws of geometric optics, it is possible to calculate the reflected beam - and start the ray tracing procedure for it (recursively).  Then mix the resulting color from the specular color with its own surface color.  This technique allows you to simulate <b>mirror surfaces</b> (in this way you can simulate <b>transparent surfaces</b> ). <br><br></li><li>  You can calculate the distance from the camera to the point of intersection of the beam with the object of the scene.  The distance value can be used to <b>simulate fog</b> : the farther the object is from the camera, the lower the intensity of its color (for calculations, you can use, for example, the exponential function of decreasing intensity). <br></li></ul><br><img src="https://habrastorage.org/storage2/a14/8bb/081/a148bb0811fe7b3da2aaca67e876c061.jpg"><br>  The combination of the above techniques allows you to get quite realistic images.  I also want to focus on the following features of the algorithm: <br><br><ul><li>  The color of each pixel can be calculated independently of the others (since the rays emitted from the camera have no effect on each other - they can be processed in parallel) <br><br></li><li>  The algorithm does not contain restrictions on the geometry of objects (you can use a rich set of primitives: planes, spheres, cylinders, etc.) <br></li></ul><br><br><h4>  Render architecture </h4><br>  All objects are stored in a heap.  Render operates with an array of pointers to 3D objects (in fact, all objects are still packed in a kd-tree, but for now we will assume that the tree is missing).  At the moment there are 2 types of primitives: triangles and spheres. <br><br><h5>  How to teach render to operate with different primitives? </h5><br>  The raytracing algorithm is independent of the geometry of the objects: the object structure is not important for the renderer, in fact only functions are needed to calculate the intersections of the figure with the ray. <br><br>  In terms of OOP, this can be implemented using the concept of an <i>interface</i> : each object provides implementations of the corresponding methods, which allows processing various primitives in a unified way. <br><br>  The C programming language has no syntactic constructs for programming in the OOP paradigm, <i>but in this case structures and function pointers come to the rescue</i> . <br><br>  Render operates with generalized structures (Object3d) containing a pointer to the data area in which the actual parameters of the 3D object are stored, as well as pointers to functions that can correctly handle this data area. <br><br><div class="spoiler">  <b class="spoiler_title">Description of the structure of Object3d from the source of the render</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ,     //   :  ,  (   ),   //   :  , ,  .. void * data; //   ,    , //     data Boolean (*intersect)(const void * data, const Point3d ray_start_point, const Vector3d ray, //         Point3d * const intersection_point); //      //       //      //       :) Color (*get_color)(const void * data, const Point3d intersection_point); //       (   ) //      -      //  ,    -      Vector3d (*get_normal_vector)(const void * data, const Point3d intersection_point); //     Object3d //    ,    // ,   void (*release_data)(void * data); } Object3d;</span></span></code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/storage2/5fe/d67/5ce/5fed675ce93130c51e6e53ca556a1a30.jpg"><br><br>  This approach allows you to localize the code relating to each 3D primitive in a separate file.  Consequently, it is quite easy to make changes to the structures of 3D objects (for example, add support for textures or normal maps), or even add new 3D primitives.  At the same time - no need to make changes to the render code.  It turned out something like <i>encapsulation</i> . <br><br><div class="spoiler">  <b class="spoiler_title">As an example: the sphere code from the source of the render</b> <div class="spoiler_text">  <b>sphere.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ...  typedef struct { Point3d center; Float radius; Color color; } Sphere; // ...   // ""  Object3d * new_sphere(const Point3d center, const Float radius, const Color color) { Sphere * sphere = malloc(sizeof(Sphere)); sphere-&gt;center = center; sphere-&gt;radius = radius; sphere-&gt;color = color; //      3D  Object3d * obj = malloc(sizeof(Object3d)); obj-&gt;data = sphere; //  ,      Sphere obj-&gt;get_color = get_sphere_color; obj-&gt;get_normal_vector = get_sphere_normal_vector; obj-&gt;intersect = intersect_sphere; obj-&gt;release_data = release_sphere_data; return obj; } //     //        static Color get_sphere_color(const void * data, const Point3d intersection_point) { const Sphere * sphere = data; return sphere-&gt;color; } //          //    Bump Mapping static Vector3d get_sphere_normal_vector(const void * data, const Point3d intersection_point) { const Sphere * sphere = data; // vector3dp -  ,       Vector3d n = vector3dp(sphere-&gt;center, intersection_point); normalize_vector(&amp;n); return n; } //     static Boolean intersect_sphere(const void * data, const Point3d ray_start_point, const Vector3d ray, Point3d * const intersection_point) { const Sphere * sphere = data; //        -     //         GitHub } // ""  void release_sphere_data(void * data) { Sphere * sphere = data; //      -       free(sphere); }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">An example of how to operate with different primitives, regardless of their implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Object3d * objects[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  ,     (10, 20, 30)   100 objects[0] = new_sphere(point3d(10, 20, 30), 100, rgb(255, 0, 0)); //     (0, 0, 0), (100, 0, 0)  (0, 100, 0) objects[1] = new_triangle(point3d(0, 0, 0), point3d(100, 0, 0), point3d(0, 100, 0), rgb(0, 255, 0)); Point3d camera = point3d(0, 0, -100); Vector3d ray = vector3df(0, -1, 0); int i; for(i = 0; i &lt; 2; i++) { Object3d * obj = objects[i]; Point3d intersection_point; if(obj-&gt;intersect(obj-&gt;data, camera, ray, &amp;intersection_point)) { //            Color c = obj-&gt;get_color(obj-&gt;data, intersection_point); //  -  :-) // ,      //     ,      objects! } } }</span></span></code> </pre><br></div></div><br>  For the sake of justice, it is worth noting that such an architecture entails a lot of pointer juggling. <br><br><h4>  Rendering speed </h4><br>  As a test case, I decided to visualize the scene with the ‚ÄúSierpinski Pyramid‚Äù fractal, a mirror sphere and a stand with a texture.  It is rather convenient to use the Sierpinski pyramid to test the rendering speed.  By setting different levels of recursion, you can generate a different number of triangles: <br><br><img src="https://habrastorage.org/storage2/bbf/51e/06f/bbf51e06f94d9d6e77ea0a6d55c18338.jpg"><br><br>  Initially, the rendering speed was satisfactory only for those scenes that contained less than a thousand polygons.  Since I have a 4-core processor - it was decided to speed up the rendering by paralleling. <br><br><h5>  Posix threads </h5><br>  First impression: Java Threads semantics is very close to pthreads.  Therefore, there were no particular problems with understanding the POSIX model.  It was decided to sip your Thread Pool :-) <br><br>  Thread Pool contained a queue for the task.  Each task was a structure containing a link to the function to be executed, as well as a link to the list of arguments.  Access to the queue of tasks was regulated by means of mutex and condition variable.  For convenience, the entire rendering is encapsulated in a separate function, one of whose arguments is the number of threads: <br><br><div class="spoiler">  <b class="spoiler_title">The signature of the encapsulating rendering function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scene * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scene, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Camera * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> camera, Canvas * canvas, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num_threads)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Scene  3D ,  ,      //  Camera  ,      //  Canvas  2   -      </span></span></code> </pre><br></div></div><br>  This function contained a code, a rendering rendering loop and a thread pool, whose duties included: <br><ul><li>  split the canvas into several pieces </li><li>  for each part of the canvas to form a separate task for rendering </li><li>  send all tasks to pool and wait for completion </li></ul><br>  But, unfortunately, on a 2-core nuclear, the render periodically hung up or fell with an Abort trap 6 error (and on a 4-core nuclear, this has never been reproduced).  I tried to fix this sad bug, but soon I found a more attractive solution. <br><br><h5>  Openmp </h5><br>  OpenMP takes all the care of creating and distributing tasks, and also organizes a barrier to wait for the rendering to complete.  Just add a few directives to parallelize the single-threaded code, and the hang bugs disappeared :-) <br><br><div class="spoiler">  <b class="spoiler_title">Source Rendering Function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scene * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scene, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Camera * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> camera, Canvas * canvas, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num_threads)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = canvas-&gt;width; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = canvas-&gt;height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float focus = camera-&gt;focus; <span class="hljs-comment"><span class="hljs-comment">//    omp_set_num_threads(num_threads); int x; int y; //   ,      :-) #pragma omp parallel private(x, y) #pragma omp for collapse(2) schedule(dynamic, CHUNK) for(x = 0; x &lt; width; x++) { for(y = 0; y &lt; height; y++) { const Vector3d ray = vector3df(x, y, focus); const Color col = trace(scene, camera, ray); set_pixel(i, j, col, canvas); } } }</span></span></code> </pre><br></div></div><br><br>  The rendering accelerated a bit, but, alas, scenes containing more than a thousand primitives were still rendered very slowly. <br><br>  Calculating the intersection of a ray with primitives is a relatively resource-intensive procedure.  The problem is that for each ray, the intersections with <b>all</b> primitives of the scene are checked (the closest primitive is searched for, crossed by the ray).  Is it possible to somehow exclude those objects with which the ray does not exactly intersect? <br><br><h4>  Kd-tree </h4><br>  Let's break the stage with the objects into two parts: ‚Äúleft‚Äù and ‚Äúright‚Äù (we denote them as L and R, respectively): <br><img src="https://habrastorage.org/storage2/905/46d/b81/90546db81a73d4025046e3c11ce7ef0e.jpg"><br>  Since we divide the scene into parts parallel to the coordinate axes, it is relatively quick to calculate which part of the scene the ray crosses.  The following options are possible: <br><br><ul><li>  The beam crosses only part of the scene L <br>  You can not view the objects contained in part R <br>  <i>(ray 1 in the picture)</i> <br><br></li><li>  The beam crosses only part of the scene R <br>  Can not view objects contained in part L <br>  <i>(ray 3 in the picture)</i> <br><br></li><li>  The beam first crosses part of scene L, and then part of scene R <br>  First we look at the objects belonging to the parts of the scene L - if the intersection was found, then the objects belonging to the parts of the scene R can be not viewed.  If the beam does not intersect any object from part L - you will have to look at objects from part R <br>  <i>(ray 2 in the picture)</i> <br><br></li><li>  The beam first crosses part of scene R, and then part of scene L <br>  The same logic of the search for intersections, as in the previous version (only first consider the part of the scene R) <br></li></ul><br>  But, in exactly the same way, in order to reduce the number of viewed polygons - you can continue to recursively split the scene into smaller sections.  The resulting hierarchical structure containing the segments of the scene, with primitives attached to them is called the <b>kd-tree</b> . <br><br>  Let's, for example, consider the process of ray tracing <i>2</i> : <br><img src="https://habrastorage.org/storage2/176/844/ed5/176844ed55cc55e3e583ff8aabccc139.jpg"><br><ol><li>  The beam first crosses the left segment of the scene (L), then the right - R <br></li><li>  From part L - the beam intersects only the LL segment <br></li><li>  LL segment contains no objects. <br></li><li>  Go to the right half of the scene - R <br></li><li>  In the right half of the scene, the beam first crosses the RL segment, and then the RR <br></li><li>  In part of the RL scene, the intersection of the beam with the object was found <br></li><li>  Tracing completed <br></li></ol><br>  Thanks to the organization of the tree data structure, we have excluded those objects that are not necessarily intersected by a ray.  But there is still a very important nuance - the effectiveness of a kd-tree depends on how we break the stage into parts.  How to choose the right scene splitting sites? <br><br><h5>  Surface Area Heuristic </h5><br>  The probability of hitting the beam in any segment of the scene is proportional to the area of ‚Äã‚Äãthis segment.  The more primitives are contained in the part of the scene - the more intersections will need to be calculated when the beam hits this segment.  Thus, it is possible to formulate a partitioning criterion: it is necessary to minimize the product of the number of primitives and the area of ‚Äã‚Äãthe segment in which they are contained.  This criterion is called <b>Surface Area Heuristic</b> (SAH): <br><br><img src="https://habrastorage.org/storage2/61b/941/889/61b941889d7738937c6bdb06fe637812.jpg"><br><br>  Let's take a simple example, consider heuristics in action: <br><br><img src="https://habrastorage.org/storage2/042/a7d/e6d/042a7de6dd7783cb6f2dd8ad50dce59d.jpg"><br><br>  Thus, the use of SAH allows you to effectively separate the empty space and 3D objects - which has a very positive effect on the performance of the render. <br><br><h5>  Observations </h5><br>  The renderer has the ability to calculate the average number of intersections per 1 pixel of the image: every time the intersection of a ray with an object is calculated, the counter value increases, after the rendering is completed, the counter value is divided by the number of pixels in the image. <br><br>  The results obtained vary for different scenes (since the construction of a kd-tree depends on the relative position of the primitives).  The graphs show the dependence of the average number of intersections per 1 pixel of the image on the number of primitives: <br><img src="https://habrastorage.org/storage2/d40/2ea/227/d402ea22748c0a1432b4841d207e4e44.jpg"><br>  It can be noted that this value is significantly less than the number of primitives contained in the scene (if there were no kd-tree, then a linear relationship would be obtained, since for each ray we would have to look for an intersection with all N primitives).  In fact, using the kd-tree, we reduced the complexity of the raytracing algorithm from O (N) to O (log (N)). <br><br>  For the sake of justice, it is worth noting that one of the drawbacks of this solution is the resource-intensive construction of the kd-tree.  But for static scenes, this is not critical: we loaded the scene, waited until a tree was built - and you can go traveling with a camera around the scene :-) <br><br>  <i>Scene containing 16386 triangles:</i> <br><img src="https://habrastorage.org/storage2/fac/ae2/f11/facae2f112bee54a0c792a0aac3aea47.jpg"><br><br><h5>  Loading models </h5><br>  Having learned to render a large number of primitives - there was a desire to load 3D models.  A rather simple and widespread format was chosen - <a href="http://ru.wikipedia.org/wiki/Obj">OBJ</a> : the model is stored in a text file that contains a list of vertices and a list of polygons (each polygon is defined by points from the list of vertices). <br><br><div class="spoiler">  <b class="spoiler_title">An example of a very simple model: tetrahedron.obj</b> <div class="spoiler_text">  # tetrahedron <br><br>  # vertexes: <br>  v 1.00 1.00 1.00 <br>  v 2.00 1.00 1.00 <br>  v 1.00 2.00 1.00 <br>  v 1.00 1.00 2.00 <br><br>  # triangles: <br>  f 1 3 2 <br>  f 1 4 3 <br>  f 1 2 4 <br>  f 2 3 4 <br></div></div><br>  In the process of writing the parser OBJ format, it was noted that many models also contain a list of normals for each vertex of the polygon.  Vertex normal vectors can be interpolated to obtain a normal vector at any point of the polygon ‚Äî this technique allows you to simulate smooth surfaces (see <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%25A4%25D0%25BE%25D0%25BD%25D0%25B3%25D1%2583">Phong shading</a> ).  This feature was fairly easy to implement within the current render architecture (you just needed to add normal vectors to the Triangle3d structure, and write a function that interpolates them for any point of the polygon). <br><br><div class="spoiler">  <b class="spoiler_title">Triangle3d structure from render sources</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   Point3d p1; Point3d p2; Point3d p3; //  ,     //      -       Vector3d norm; Color color; Material material; //    -   ,    color Canvas * texture; //   //   ,    Point2d t1; Point2d t2; Point2d t3; //     //        Vector3d n1; Vector3d n2; Vector3d n3; //      //      } Triangle3d;</span></span></code> </pre><br></div></div><br>  <i>An example of a scene renderer containing about 19,000 polygons:</i> <br><img src="https://habrastorage.org/storage2/599/389/9f2/5993899f212ec73aefac60a4126e952a.jpg"><br><br>  <i>An example of a scene renderer containing approximately 22,000 polygons:</i> <br><img src="https://habrastorage.org/storage2/668/955/91f/66895591f17671d8c1d8b7291471efc4.jpg"><br><br>  For the sake of interest, I decided to add a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25B0%25D0%25B9%25D0%25B1%25D0%25BE%25D0%25BA%25D1%2581">skybox</a> and upload car models: <br><div class="spoiler">  <b class="spoiler_title">The scene contains about 100,000 polygons (kd-tree was built a few minutes)</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/87b/cdc/c8f/87bcdcc8f7520e995b1909083bee3216.jpg"><br></div></div><br><br><h4>  Conclusion </h4><br>  I am glad that I chose this task during the study of C - because, it allowed to learn various aspects of the language ecosystem, and get beautiful results. <br><br>  Sources of render on githaba: <a href="https://github.com/lagodiuk/raytracing-render">github.com/lagodiuk/raytracing-render</a> (in the project description - how to run the demo). <br><br>  In the process of studying C, 2 books helped me a lot: <br><br><ol><li>  <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">Brian Kernigan, Dennis Ritchie - C Programming Language</a> - initially had some difficulty reading this book.  But after reading Head First C - I returned to this book again.  In this book there are many examples and tasks that helped in the study <br><br></li><li>  <a href="http://shop.oreilly.com/product/0636920015482.do">David Griffiths, Dawn Griffiths - Head First C</a> - I liked this book very much because it gives a general vision of the ecosystem of the C language (how memory is organized, how it works at the OS level, make, valgrind, POSIX streams, unit testing, described in general terms and there are even a few pages about Arduino) </li></ol><br>  Also, I want to thank <a href="http://habrahabr.ru/users/dmytrish/" class="user_link">dmytrish</a> for consultations on some of the nuances of C, and for the written frontend for rendering (using GLUT) - in order to display the scene in the window, and using the keyboard to move and rotate the camera. <br><br>  I also want to recommend a very useful resource: <a href="http://ray-tracing.ru/">ray-tracing.ru</a> - here, in an accessible form, various algorithms used for photorealistic rendering are described (in particular, kd-trees and SAH). <br><br>  <b>PS</b> <br>  Several videos created during the rendering process: <br><br><div class="spoiler">  <b class="spoiler_title">Sierpinski Pyramid in the Fog</b> <div class="spoiler_text"><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/SCuTbXtu1Do%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700190,15700253&amp;usg=ALkJrhhwMUTUUXQ74H6QnqqzKZX9CoR0RQ" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Cube, man, lantern, teapot and Sierpinski pyramid :-)</b> <div class="spoiler_text"><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/zApzx4jKg40%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700190,15700253&amp;usg=ALkJrhgibYue9Q2yUn9OugESs7HaIxe1lw" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><br>  <b>UPD:</b> <br>  It turned out to speed up the construction of the tree.  Details in the comments branch: <a href="http://habrahabr.ru/post/187720/">habrahabr.ru/post/187720/#comment_6580722</a> <br><br>  <b>UPD 2:</b> <br>  After discussion in this thread of comments: <a href="http://habrahabr.ru/post/187720/">habrahabr.ru/post/187720/#comment_6579384</a> - anti-aliasing was implemented.  Thank you all for the ideas.  Now rendered images look more beautiful :) <br><img src="https://habrastorage.org/storage2/48e/73d/ef5/48e73def56da60d690c3dd93fcf0ae03.jpg"></div><p>Source: <a href="https://habr.com/ru/post/187720/">https://habr.com/ru/post/187720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187702/index.html">How-To: Connect Pfsense with Huawei E392 Modem to Yota Provider</a></li>
<li><a href="../187704/index.html">NASA has published a photo of the Earth, view from the rings of Saturn</a></li>
<li><a href="../187706/index.html">Meet Tizen</a></li>
<li><a href="../187708/index.html">Unusual site navigation</a></li>
<li><a href="../187716/index.html">Yandex Islands Beta: "We want to give meaning to any element on the search results page"</a></li>
<li><a href="../187722/index.html">L-series 2013: what LG state employees are capable of</a></li>
<li><a href="../187724/index.html">3 stories of Ethic Hack. How hackers help QIWI eliminate bugs</a></li>
<li><a href="../187728/index.html">Your programming level and not only</a></li>
<li><a href="../187734/index.html">Review of the smartphone Lenovo P780</a></li>
<li><a href="../187738/index.html">Create products that do not scale.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>