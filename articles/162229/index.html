<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIPS system calls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This summer appplemac has published an article dedicated to the study of the MIPS assembler . In it, in particular, the syscall command generating a s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIPS system calls</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/7d0/c79/181/7d0c7918139896b20fa869b27943a7bb.jpg" align="left">  This summer <a href="https://habrahabr.ru/users/appplemac/" class="user_link">appplemac has</a> published an article dedicated to the study of the <a href="http://habrahabr.ru/post/147685/">MIPS assembler</a> .  In it, in particular, the syscall command generating a system call was considered.  The author focused on explaining the MIPS assembler, and in my opinion, he didn‚Äôt say in sufficient detail what a system call is.  At that moment I was engaged in the transfer of the project under the MIPS architecture, I dealt with interrupts, exceptions and system calls. <br><br>  Now that the code has already been written and debugged, I decided to write an article that would reveal in more detail how the system calls mechanism works in MIPS.  You can consider it as a supplement to that article about the assembler. <br><a name="habracut"></a><br><h5>  Introduction </h5><br>  First of all, you need to understand what system calls are and why they are needed. <br>  Wikipedia gives the following definition: <br><blockquote>  System Call (English system call) in programming and computing - the application program to the core of the operating system to perform any operation. <br>  From the programmer‚Äôs point of view, a system call usually looks like a subroutine or function call from the system library.  However, a system call as a special case of calling such a function or subroutine should be distinguished from a more general reference to the system library, since the latter may not require performing privileged operations. </blockquote><br><img src="https://habrastorage.org/storage2/28f/3f6/5fa/28f3f65fa823753fc67daabd4b4d3551.png" align="left"><br>  In other words, a system call is a function call with a pre-known address and simultaneous transfer of the processor from the privileged mode (kernel mode).  Switching to kernel mode allows you to execute privileged commands, such as managing virtual memory tables, disabling / enabling interrupts, and accessing data stored in the kernel. <br>  A previously known address means that all processing functions can be represented by an array of pointers, and this handler will correspond to an index in this array.  The difference between the system call and the function call is that the control to the base address + offset is transferred by the hardware, by the processor itself. <br><br>  That is, the processor, having encountered an instruction that generates a system call, interrupts the sequential execution of user program commands and transfers control to the desired address while preserving the necessary information to return to the main program.  This is very similar to the behavior of the processor when an exception or an external interrupt occurs, therefore, usually these subsystems are implemented in a similar way and are considered together. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  MIPS Architecture </h5><br>  Let us turn to a specific implementation of these subsystems in the MIPS architecture. <br><br>  In the MIPS version 2 architecture, there are several modes of operation for interrupts.  They differ in the base addresses and the structures of the interrupt tables themselves. <br>  For the base address there are two modes: <br><ol><li>  In the first processor, faced with any type of exceptions, transfers control to the address a fixed address (0x80000180), the size of the handler is 128 bytes. </li><li>  In the second, the processor transfers control to the address specified in the CP0_EBASE register, the handler size is 256 bytes. </li></ol><br>  There are also two operation modes for the structure of the interrupt table: normal, when one handler is called in response to all exceptions, and vector mode, in which each interrupt number is assigned its own space for the handler. <br><br>  These modes are set in special registers of the MIPS processor.  Special registers, unlike general registers, are used by the program to control the processor itself. <br><br>  In MIPS, such registers are moved to coprocessor 0. And they are accessed by special assembler commands: mfc0 - to read registers, and mtc0 - to write to the register. <br>  Registers are addressed by the index and selector of the coprocessor.  Here are some important registers for handling system calls: <br><table><tbody><tr><th>  Title </th><th>  Index </th><th>  Selector </th><th>  Description </th></tr><tr><td>  CP0_STATUS </td><td>  12 </td><td>  0 </td><td>  control flags for the processor </td></tr><tr><td>  CP0_CAUSE </td><td>  13 </td><td>  0 </td><td>  interrupt reason information </td></tr><tr><td>  CP0_EPC </td><td>  14 </td><td>  0 </td><td>  address of the command that was executed at the time of the interruption </td></tr><tr><td>  CP0_EBASE </td><td>  15 </td><td>  one </td><td>  base address of the exception handling procedure </td></tr></tbody></table><br>  Returning to setting the exception handling modes, they are set in two registers: CP0_STATUS and P0_CAUSE, having the following format. <br><br>  <b>P0_STATUS</b> <table><tbody><tr><th>  31-28 </th><th>  27 </th><th>  26 </th><th>  25 </th><th>  24 </th><th>  23 </th><th>  22 </th><th>  21 </th><th>  20 </th><th>  nineteen </th><th>  18-16 </th><th>  15-8 </th><th>  7 </th><th>  6 </th><th>  five </th><th>  4-3 </th><th>  2 </th><th>  one </th><th>  0 </th></tr><tr><td>  CU3..CU0 </td><td>  RP </td><td>  FR </td><td>  RE </td><td>  MX </td><td>  PX </td><td>  BEV </td><td>  TS </td><td>  SR </td><td>  NMI </td><td>  Impl </td><td>  IM7..IM0 </td><td>  KX </td><td>  SX </td><td>  Ux </td><td>  KSU </td><td>  ERL </td><td>  EXL </td><td>  IE </td></tr></tbody></table><br>  <b>CP0_CAUSE</b> <table><tbody><tr><th>  31 </th><th>  thirty </th><th>  29-28 </th><th>  27 </th><th>  26 </th><th>  25-24 </th><th>  23 </th><th>  22 </th><th>  21-16 </th><th>  15-10 </th><th>  9-8 </th><th>  7 </th><th>  6-2 </th><th>  1-0 </th></tr><tr><td>  Bd </td><td>  Ti </td><td>  CE </td><td>  DC </td><td>  PCI </td><td>  0 </td><td>  IV </td><td>  WP </td><td>  0 </td><td>  IP </td><td>  IP </td><td>  0 </td><td>  exCode </td><td>  0 </td></tr></tbody></table><br><h5>  CPU Initialization </h5><br>  I will consider only the first mode of operation, as the most simple and compatible with all MIPS processors.  All other modes are done in a similar way. <br><br>  To transfer the processor to this mode, you need to reset the BEV bit in the status register and the IV bit in the cause register. <br><br>  C-shny code from the project <br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup a proper exception table and enable exceptions. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mips_exception_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reg; <span class="hljs-comment"><span class="hljs-comment">/* clear BEV bit */</span></span> reg = mips_read_c0_status(); reg &amp;= ~(ST0_BEV); mips_write_c0_status(reg); <span class="hljs-comment"><span class="hljs-comment">/* clear CauseIV bit */</span></span> reg = mips_read_c0_cause(); reg &amp;= ~(CAUSE_IV); mips_write_c0_cause(reg); <span class="hljs-comment"><span class="hljs-comment">/* copy the first exception handler */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(EBASE + <span class="hljs-number"><span class="hljs-number">0x180</span></span>), &amp;mips_first_exception_handler, <span class="hljs-number"><span class="hljs-number">0x80</span></span>); mips_setup_exc_table(); <span class="hljs-comment"><span class="hljs-comment">/* clear EXL bit */</span></span> reg = mips_read_c0_status(); reg &amp;= ~(ST0_ERL); mips_write_c0_status(reg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br>  After clearing these bits when an interrupt, exception or system call occurs, the processor interrupts the sequential execution of instructions and transfers control to the address 0x80000180, where the primary processing code that we copied to this address is located.  At the same time, the processor switches to the privileged mode, stores the return address in the CP0_EPC register, and writes the reason (type) for the exception to the CP0_CAUSE register (in the exception code field). <br><br>  About the exception code field is to tell a little more.  As mentioned above, in MIPS, as, indeed, in other architectures, interrupts, system calls and hardware exceptions are usually implemented in a similar way, in the same subsystem.  That is, the first thing that the handler code should do is to save information about what happened.  It is this information that is entered in the exception code field.  In MIPS, this field can take the following values: <table><tbody><tr><th>  Code </th><th>  Designation </th><th>  Description </th></tr><tr><td>  0 </td><td>  Int </td><td>  External interrupt </td></tr><tr><td>  1-3 </td><td></td><td>  Work with virtual memory </td></tr><tr><td>  four </td><td>  ADDRL </td><td>  Reading from an unaligned address </td></tr><tr><td>  five </td><td>  ADDRS </td><td>  Record at unaligned address </td></tr><tr><td>  6 </td><td>  IBUS </td><td>  Error reading instructions </td></tr><tr><td>  7 </td><td>  DBUS </td><td>  Error on the data bus </td></tr><tr><td>  eight </td><td>  Syscall </td><td>  System call </td></tr><tr><td>  9 </td><td>  BKPT </td><td>  Breakpoint </td></tr><tr><td>  ten </td><td>  RI </td><td>  Reserved instruction </td></tr><tr><td>  eleven </td><td></td><td>  Coprocessor error </td></tr><tr><td>  12 </td><td>  Ovf </td><td>  Arithmetic overflow </td></tr><tr><td>  13 and above </td><td></td><td>  Floating point operations </td></tr></tbody></table><br><h5>  Handling system calls </h5><br><h6>  First level handler </h6><br>  The primary handler is written in assembler. <br><pre> <code class="cpp hljs">NESTED(mips_first_exception_handler, <span class="hljs-number"><span class="hljs-number">0</span></span>, $sp) .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> push <span class="hljs-comment"><span class="hljs-comment">/* save the current status of flags */</span></span> mfc0 $k1, $CP0_CAUSE andi $k1, $k1, <span class="hljs-number"><span class="hljs-number">0x7c</span></span> <span class="hljs-comment"><span class="hljs-comment">/* read exception number */</span></span> j mips_second_exception_handler <span class="hljs-comment"><span class="hljs-comment">/* jump to real exception handler */</span></span> nop .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> pop <span class="hljs-comment"><span class="hljs-comment">/* restore the previous status of flags */</span></span> END(mips_first_exception_handler)</code> </pre><br>  It only remembers the type of the exception in the register $ k1 and calls the second-level handler, which is no longer limited in size.  The call is made with the command ‚Äúj‚Äù, not ‚Äújar‚Äù, ‚Äã‚Äãbecause the handler code is placed during the program operation (we copied it in the initialization function), and we need to have the absolute, not the relative address of the called procedure. <br><br>  Another feature worth mentioning here is the k1 register. <br>  In the MIPS architecture, there are 32 general purpose registers r0 - r31.  And by convention, some registers are used in a special way, for example, the register r31 is used as a pointer to the stack, and it can be accessed by the special name sp.  The same with the registers k0 (r26) and k1 (r27), the compiler does not use them, they are reserved for use in the OS kernel, and interrupt handling is just such a case of special use. <br><br><h6>  Second level handler </h6><br>  Let us turn to the second level handler.  Its main purpose is to prepare for calling a S-function, that is, first of all, to save the remaining registers that can be used in this function itself.  It is also written in assembly language. <br><pre> <code class="cpp hljs"> LEAF(mips_second_exception_handler) SAVE_ALL <span class="hljs-comment"><span class="hljs-comment">/* save all needed registers */</span></span> PTR_L $k0, exception_handlers($k1) <span class="hljs-comment"><span class="hljs-comment">/* exception number is an offset in array */</span></span> PTR_LA $ra, restore_from_exception <span class="hljs-comment"><span class="hljs-comment">/* return address for exit from exception */</span></span> move $a0, $sp <span class="hljs-comment"><span class="hljs-comment">/* Arg 0: saved regs. */</span></span> jr $k0 <span class="hljs-comment"><span class="hljs-comment">/* Call C code. */</span></span> nop restore_from_exception: <span class="hljs-comment"><span class="hljs-comment">/* label for exception return address */</span></span> RESTORE_ALL <span class="hljs-comment"><span class="hljs-comment">/* restore all registers and return from exception */</span></span> END(mips_second_exception_handler)</code> </pre><br><br>  <i>SAVE_ALL</i> is an assembler macro.  It looks like this. <br><pre> <code class="cpp hljs"> .macro SAVE_ALL LONG_ADDI $sp, -PT_SIZE SAVE_SOME SAVE_AT SAVE_TEMP SAVE_STATIC .endm</code> </pre><br>  I will not give the source code of all nested macros.  Let me just say that in the first line the stack of the interrupt frame is reserved, where all the necessary registers are saved sequentially. <br>  <i>SAVE_AT</i> - the register at (r1) is reserved for use by the assembler and work with it must be separated by the directives <i>".set noat"</i> and <i>".set at"</i> (so that there are no compiler warnings) <br>  <i>SAVE_TEMP</i> - saves temporary registers (r8-r15) and (r24-r25) <br>  <i>SAVE_STATIC</i> - registers s0-s7 <br>  <i>SAVE_SOME</i> - the necessary service registers, for example, a pointer to the stack and special registers of the coprocessor (for example, the status register), so this macro should be the first. <br><br>  Then there is a choice of the correct third level handler.  Pointers to third-level handlers in our project are stored in a regular array, the type of exception sets the offset.  It is an offset, not an index, since the MIPS creators place in the CAUSE register an exception number with a shift of two bits to the left, so we can directly call a function from the array of pointers without performing additional arithmetic. <br>  Then, before calling the function, we want to write the return address (ra).  Finally, we pass to the handler function information about the state in which we entered the interrupt, for this we pass a pointer to the stack, and in the signature of the C-function we will specify the description (structure) of the frame. <br><br>  Here is a description of this structure. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pt_regs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reg[<span class="hljs-number"><span class="hljs-number">25</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gp; <span class="hljs-comment"><span class="hljs-comment">/* global pointer r28 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sp; <span class="hljs-comment"><span class="hljs-comment">/* stack pointer r29 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fp; <span class="hljs-comment"><span class="hljs-comment">/* frame pointer r30 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ra; <span class="hljs-comment"><span class="hljs-comment">/* return address 31*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lo; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hi; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cp0_status; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc; }<span class="hljs-keyword"><span class="hljs-keyword">pt_regs_t</span></span>;</code> </pre><br><h6>  Level 3 handler (C code) </h6><br>  The code of the s-shnogo handler is the following <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mips_c_syscall_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pt_regs_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result; <span class="hljs-comment"><span class="hljs-comment">/* v0 contains syscall number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> (*sys_func)(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>) = SYSCALL_TABLE[regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-comment"><span class="hljs-comment">/* a0, a1, a2, a3, s0 contain arguments */</span></span> result = sys_func(regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">3</span></span>], regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">4</span></span>], regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">5</span></span>], regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">6</span></span>], regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">15</span></span>]); <span class="hljs-comment"><span class="hljs-comment">/* v0 set equal to result */</span></span> regs-&gt;reg[<span class="hljs-number"><span class="hljs-number">1</span></span>] = result; regs-&gt;pc += <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* skip comand generated syscall */</span></span> }</code> </pre><br>  I hope that everything is clear from the code: <br><ul><li>  First we get the number of the system call handler with the desired number. </li><li>  Then we call this handler, passing there all the parameters that can be when calling the system call. </li><li>  In the register v0 we stack the result of the call. </li><li>  And, finally, skip the command that generated the system call, otherwise we will return to the same address where it happened, and the call will occur again. </li></ul><br><br><h5>  Receive a system call </h5><br>  Now you need to talk about how to make a system call. <br>  The system call is generated by a special assembler command: for example, in x86 it is <i>int</i> , in SPARC it is <i>ta</i> , and in MIPS it is <i>syscall</i> . <br><br>  As it probably became clear from the previous section, at the time of the system call in the register v0 the call number should be stored, and in the registers a0, a1, a2, a3 the transmitted parameters.  Here, for example, the code of a function that puts one argument in the register a0 and makes a system call 0x11.  I assume the reader is familiar with gcc inline assembler <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syscall_demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> __res; __<span class="hljs-function"><span class="hljs-function">asm__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"move $a0, %2\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"li $v0, %1\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"syscall\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"move %0, $v0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (__res) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"I"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x11</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ((</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)(arg1)))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __res; }</code> </pre><br>  Of course, it is not convenient to write functions for each type, therefore macros are used.  Below is the macro code that declares a single-parameter system call function. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __SYSCALL1(NR,type,name,type1,arg1) \ static inline type name(type1 arg1) \ { \ long __res; \ __asm__ volatile ( \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"move $a0, %2\n\t"</span></span></span><span class="hljs-meta"> \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"li $v0, %1\n\t"</span></span></span><span class="hljs-meta"> \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"syscall\n\t"</span></span></span><span class="hljs-meta"> \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"move %0, $v0"</span></span></span><span class="hljs-meta"> \ \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=r"</span></span></span><span class="hljs-meta"> (__res) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"I"</span></span></span><span class="hljs-meta"> (NR), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> ((long)(arg1))); \ return __res; \ }</span></span></code> </pre><br>  The code for system calls with a different number of parameters is similar to the one given. <br><br>  Putting it all together.  We use several tests in the project, among which is the one located below. <br><br><pre> <code class="cpp hljs">SYSCALL1(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,syscall_1,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,arg1); TEST_CASE(<span class="hljs-string"><span class="hljs-string">"calling syscall with one argument"</span></span>) { test_assert_equal(syscall_1(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>  The <i>SYSCALL</i> macro <i>is</i> expanded into the above code with an inline assembler, its number is 1 (the first macro argument) is substituted for the syscall_1 call name (the third parameter), the return type is int (the second macro parameter), and the type of the variable is also int (the fourth macro parameter ). <br>  In the test itself, it is checked that the result of the syscall_1 (1) call will be equal to one. <br><br><h5>  Related Links </h5><br><ol><li>  <a href="https://www.ibm.com/developerworks/mydeveloperworks/blogs/ddou/entry/implementing_mips_interrupts_for_u_boot28">Implementing interrupts for MIPS in the Das U-boot bootloader</a> </li><li>  <a href="http://winfred-lu.blogspot.com/2011/04/mips-exceptions-initialization-and.html">Implementing interrupts for MIPS in the Linux kernel</a> </li><li>  <a href="http://code.google.com/p/embox/">The code of our project</a> </li></ol><br><br><h5>  Conclusion </h5><br>  In conclusion, for those who are interested in a more detailed understanding of this topic, I recommend taking the project code and playing qemu (the wiki pages describe how to run it).  Understanding how things work is much easier if you walk along breakpoints with all the amenities of Eclipse. <br><br>  Thanks to everyone who read to the end!  I will be glad to hear comments, recommendations and suggestions. </div><p>Source: <a href="https://habr.com/ru/post/162229/">https://habr.com/ru/post/162229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162209/index.html">In search of the perfect post, or the riddle of Habr</a></li>
<li><a href="../162217/index.html">Project Architecture Planning</a></li>
<li><a href="../162219/index.html">Allow direct SIP calls</a></li>
<li><a href="../162223/index.html">NetWrix Password Manager Self-Password Manager Review</a></li>
<li><a href="../162227/index.html">Copyright history. Part 5: Moral Rights</a></li>
<li><a href="../162233/index.html">Video digest of the latest gaming industry news | Geek Week # 4</a></li>
<li><a href="../162235/index.html">Observer Pattern with strong typing or why do we need Objective-C ++</a></li>
<li><a href="../162237/index.html">Nginx-based online broadcast server</a></li>
<li><a href="../162245/index.html">New Yandex Search Platform with Personal Results: ‚ÄúKaliningrad‚Äù</a></li>
<li><a href="../162251/index.html">How to make a product from a mobile application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>