<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MVC + Scenario vs. Fat Controllers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MVC + Scenario Versus Thick Controllers 


 Modern PHP frameworks (Symphony, Laravel, further everywhere) convincingly show that implementing the Mode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MVC + Scenario vs. Fat Controllers</h1><div class="post__text post__text-html js-mediator-article"><h1 id="mvc--scenario-protiv-tolstyh-kontrollerov">  MVC + Scenario Versus Thick Controllers </h1><br><p> Modern PHP frameworks (Symphony, Laravel, further everywhere) convincingly show that implementing the Model-View-Controller pattern is not so easy.  All implementations are for some reason inclined to Fat Controllers ( <code>fat controllers</code> ), condemned by all, and developers, and the frameworks themselves. </p><br><p>  Why is that so?  And is it possible to cope with this somehow?  Let's figure it out. </p><a name="habracut"></a><br><h2 id="terminologiya">  Terminology </h2><br><ul><li>  Model - a model (driver of the requested data) </li><li>  View - view (model data designer) </li><li>  Controller - controller (model-presentation coordinator as requested) </li><li>  Template - presentation template </li><li>  Rendering - rendering (formation, design of the image of the presentation) </li><li>  Renderer - renderer (shaper, designer of the presentation image) </li></ul><br><h2 id="tolstyy-kontroller">  Thick controller </h2><br><p>  Here is a typical Fat Controller: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   *      ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionUserHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ( ) $user = UserModel::find($userId); //       -   $name = $user-&gt;firstName.' '.$user-&gt;lastName; //         $view = new View('hello', ['name' =&gt; $name]); //  ( )     return $view-&gt;render(); } }</span></span></code> </pre> <br><p>  What do we see?  We see a vinaigrette!  Everything that is possible is mixed in the controller - both the model and the presentation, and, actually, the controller itself! </p><br><p>  We see the names of the model and the template, tightly wired into the controller.  This is not good.  We see the manipulations with the data of the model in the controller - the formation of a full name from the name and surname.  And this is not good. </p><br><p>  And yet: we do not see this example explicitly, but it is implicitly.  Namely: there is only one way of rendering (image formation)!  Only one: the pattern in the php file!  And if I want a pdf?  And if I want not in the file, but in the php line?  I had projects with an elaborate design on a hundred small templates.  It was necessary to blunder a renderer for string patterns.  Not overheated of course, but the matter is in principle. </p><br><p>  Brief summary: </p><br><blockquote>  Modern frameworks have common for all the flaws in the implementation of MVC: <br><ol><li>  Narrow interpretation of MVC-views (View) <strong><em>only</em></strong> as <em>"View with a template in a PHP file"</em> instead of <em>"View with any renderer"</em> . </li><li>  Narrow interpretation of the MVC model is <strong><em>only</em></strong> as ‚ÄúDatabase Domain Model‚Äù instead of <em>‚ÄúAny data compiler for presentation‚Äù</em> . </li><li>  They provoke the use of so-called <em>"Fat Controllers"</em> containing simultaneously all the logic: business, presentation and interaction.  This completely destroys the main goal of MVC - the division of responsibilities between the components of the triad. </li></ol><br></blockquote><p>  To eliminate these shortcomings, it would be nice to take a closer look at the MVC components. </p><br><h2 id="predstavlenie---eto-renderer">  View is a renderer </h2><br><p>  Look at the first flaw: </p><br><blockquote><ol><li>  Narrow interpretation of MVC-views (View) <strong><em>only</em></strong> as <em>"View with a template in a PHP file"</em> instead of <em>"View with any renderer"</em> . </li></ol><br></blockquote><p>  Everything is quite simple here - the solution to the problem is already indicated in the problem statement itself.  We just have to say that any renderer can use the view.  To implement this, simply add the new <code>renderer</code> property to the View class: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $template, $data, $renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__costruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($template, $data, $renderer = NULL)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br><p>  So, we have defined a new <code>renderer</code> property for the view.  In the most general case, the value of this property can be any <code>callable</code> function that forms an image of the data passed to it using the passed template. </p><br><p>  Most applications use only one renderer, and even if they use several, one of them is preferred.  Therefore, the <code>renderer</code> argument is defined as optional, assuming the presence of some default renderer. </p><br><p>  Simply?  Simply.  In fact, not so easy.  The fact is that the <code>View</code> , which in MVC is not quite that <code>View</code> , which is in frameworks.  The <code>View</code> , which is in frameworks, cannot live without a template.  But the <code>View</code> , which is in MVC, for some reason does not know anything about these same templates.  Why?  Yes, because for MVC <code>View</code> , this is <em>any data converter of the model into an image</em> , and not only and exclusively a template engine.  When we write something like this in the request handler: </p><br><pre> <code class="php hljs">$name = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, {$name}!"</span></span>;</code> </pre> <br><p>  or even: </p><br><pre> <code class="php hljs">$return json_encode($name); <span class="hljs-comment"><span class="hljs-comment">// Ajax response</span></span></code> </pre> <br><p>  then we really define the <code>View</code> that is in MVC, without touching any <code>View</code> that is in the frameworks! </p><br><p>  But now everything is really simple: those <code>View</code> , which in frameworks are a subset of those <code>View</code> , which are in MVC.  Moreover, a very narrow subset, namely, it is only template engines based on PHP files. </p><br><p>  Summary: it is the <code></code> , i.e.  any data image designer is the <code>View</code> in MVC.  And those <code>View</code> , which are in frameworks, are just a kind of <code></code> . </p><br><h2 id="model-domena--model-predstavleniya-viewmodel--domainmodel">  Domain Model / View Model (ViewModel / DomainModel) </h2><br><p>  And now we will look at the second lack: </p><br><blockquote><ol><li>  Narrow interpretation of the MVC model is <strong><em>only</em></strong> as ‚ÄúDatabase Domain Model‚Äù instead of <em>‚ÄúAny data compiler for presentation‚Äù</em> . </li></ol><br></blockquote><p>  It is obvious to all that the MVC model is a complex thing that consists of other pieces.  In the community there is agreement on the decomposition of the model into two components: a domain model (DomainModel) and a view model (ViewModel). </p><br><p>  A domain model is what is stored in databases, i.e.  normalized model data.  Type, 'name' and 'last name' in different fields.  The frameworks are occupied precisely with this part of the model simply because data storage is its own universe, well studied. </p><br><p>  However, the application needs aggregated, not normalized data.  Domain data must be compiled into images of the type: "Hello, Ivan!", Or "Dear Ivan Petrov!", Or even "For Ivan <strong>a</strong> Petrov <strong>and</strong> !".  These converted data are attributed to another model - the representation model.  So, this part of the model is so far ignored by modern frameworks.  Ignored because there is no agreement on how to deal with it.  And if the frameworks do not provide solutions, then programmers follow the simplest path - they throw the presentation model into the controller.  And get the hated, but the inevitable Thick Controllers! </p><br><p>  Total: to implement MVC, you must implement a view model.  No other options.  Considering that representations and their data can be any, we state that we have a problem. </p><br><h2 id="scenariy-protiv-tolstyh-kontrollerov">  Scenario vs Fat Controllers </h2><br><p>  The last flaw of frameworks remains: </p><br><blockquote><ol><li>  They provoke the use of so-called <em>"Fat Controllers"</em> containing simultaneously all the logic: business, presentation and interaction.  This completely destroys the main goal of MVC - the division of responsibilities between the components of the triad. </li></ol><br></blockquote><p>  Here we get to the basics of MVC.  Let's bring clarity.  So, MVC assumes such a distribution of responsibilities between the components of the triad: </p><br><ul><li>  The controller is the <em>interaction logic</em> , i.e.  interactions with both the outside world (request - response) and the internal one (Model - Presentation), </li><li>  Model - <em>business logic</em> , i.e.  generating data for a specific query, </li><li>  Presentation is <em>presentation logic</em> , i.e.  decoration of data generated by the Model. </li></ul><br><p>  Go ahead.  Two levels of responsibility are clearly visible: </p><br><ul><li>  The organizational level is the Controller, </li><li>  The executive level is Model and View. </li></ul><br><p>  In simple terms, the Controller rules, Model and View plow.  This is if in a simple way.  And if not in a simple way, but more specifically?  How exactly does a controller go?  And how exactly do they plow Model and Presentation? </p><br><p>  The controller steers so: </p><br><ul><li>  Receives a request from the application, </li><li>  Decides which Model and which View to use for this request, </li><li>  Calls the selected Model and receives data from it, </li><li>  Calls the selected View with the data received from the Model, </li><li>  Returns the data decorated by the View back to the application. </li></ul><br><p>  Something like that.  Essential in this scheme is that the Model and Presentation are links in the query execution chain.  Moreover, by successive links: first, the Model converts the request into some data, then this data of the Model is converted by the Presentation into an answer, decorated in the way a particular request is needed.  Like, the humanoid request is decorated with visual templates, the android request is decorated with JSON encoders. </p><br><p>  Now let's try to figure out how exactly the performers are plowing - Model and Presentation.  Above, we said that there is a consensus about the decomposition of the Model into two sub-components: the Domain Model and the Presentation Model.  This means that there can be more performers - not two, but three.  Instead of the execution chain </p><br><blockquote>  <code></code> &gt;&gt; <code></code> </blockquote><p>  may well be a chain </p><br><blockquote>  <code> </code> <code> </code> &gt;&gt; <code></code> <code> </code> &gt;&gt; <code></code> </blockquote><p>  By itself, the question arises: why only two or three?  And if you need more?  The natural answer is - for God's sake, how much is necessary, take as much! </p><br><p>  Other useful artists can be seen right away: validators, redirectors, various renderers, and in general everything that is unpredictable, but anything. </p><br><p>  Let's recap: </p><br><blockquote><ul><li>  The MVC Executive Level ( <code></code> - <code></code> ) can be implemented as a chain of links, where each link converts the output of the previous link to the input for the next. </li><li>  The input of the first link is the application request. </li><li>  The output of the last link is the application's response to the request. </li></ul><br></blockquote><p>  I called this chain <code>Scenario</code> , and for the links of the chain I have not yet decided on the name of the chain.  The current options are the scene (as part of the script), the filter (as the data converter), the action of the script.  Generally speaking, the name for the link is not so important, there is a more significant thing. </p><br><p>  The consequences of the Script are significant.  Namely: The script assumed the main responsibility of the Controller - to determine the Model and Presentation required for the request and to launch them.  Thus, the controller has only two responsibilities: interaction with the outside world (request-response) and the launch of the script.  And this is good in the sense that all the components of the MVC triad are successively decomposed and become more specific and manageable.  And another good thing is that the MVCS controller becomes a purely internal immutable class, and therefore, even in principle, it cannot become fat. </p><br><p>  Using Scenarios leads to another variation of the MVC pattern; I called this variation <strong><code>MVCS</code></strong> - <code>Model-View-Controller-Scenario</code> . </p><br><p>  And a couple of lines about MVC decomposition.  Modern frameworks, where all typical functions are decomposed to the limit, quite naturally took from the conceptual MVC some of the responsibilities for interacting with the outside world.  Thus, the processing of the user's request is done by specially trained classes like <code>HTTP </code> and <code></code> .  As a result, the Controller does not receive the user's initial request, but some refined <code></code> , and this allows the controller to be isolated from the specifics of the request.  Similarly, isolation from the HTTP response is done, allowing the MVC module to define its own type of response.  In addition, the frameworks fully implemented the two components of MVC - Domain Model and View Template, however, we have already discussed this.  All this means that the specification and specification of MVC is constantly and continuously, and this is good. </p><br><h2 id="primer-ispolzovaniya-mvcs">  MVCS example </h2><br><p>  And now let's see how the example of the <em>Fat Corroller</em> at the beginning of this article can be implemented in MVCS. </p><br><p>  We start by creating the MVCS controller: </p><br><pre> <code class="php hljs">$mvcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MvcsController();</code> </pre> <br><p>  The MVCS controller receives a request from an external router.  Let the router convert the URI of the form 'user / hello / XXX' into such an action and request parameters: </p><br><pre> <code class="php hljs">$requestAction = <span class="hljs-string"><span class="hljs-string">'user/hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   $requestParams = ['XXX']; //   -  </span></span></code> </pre> <br><p>  Considering that the MVCS controller accepts not URIs, but scripts, we need to match a certain script to the request action.  This is best done in the MVCS container: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   MVCS  URI  $mvcs-&gt;set('scenarios', [ 'user/hello' =&gt; 'UserModel &gt; UserViewModel &gt; view, hello', ..., ]);</span></span></code> </pre> <br><p>  Let's take a closer look at this scenario.  This is a chain of three data converters separated by '&gt;': </p><br><ul><li>  'UserModel' is the name of the 'User' Domain Model, the model input will be the query parameters, the output is the model data itself, </li><li>  'UserViewModel' is the name of the View Model, which converts the domain data into view data, </li><li>  'view, hello' is the system view 'template' for a PHP template with the name 'hello'. </li></ul><br><p>  Now we just need to add two converter involved in the script as a function-circuit to the MVCS container: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   UserModel $mvcs-&gt;set('UserModel', function($id) { $users = [ 1 =&gt; ['first' =&gt; '', 'last' =&gt; ''], 2 =&gt; ['first' =&gt; '', 'last' =&gt; ''], ]; return isset($users[$id]) ? $users[$id] : NULL; }); //   UserViewModel $mvcs-&gt;set('UserViewModel', function($user) { //    PHP  : 'echo "Hello, $name!"'; return ['name' =&gt; $user['first'].' '.$user['last']]; });</span></span></code> </pre> <br><p>  And it's all!  For each request, it is necessary to determine the corresponding script and all its scenes (except for the system ones, such as 'view').  And nothing more. </p><br><p>  And now we are ready to test MVCS for different requests: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//        $scenarios = $mvcs-&gt;get('scenarios'); $scenario = $scenarios[$requestAction]; //      ... //   'user/hello/1'  ' '   'hello' $requestParams = ['1']; $response = $mvcs-&gt;play($scenario, $requestParams); //   'user/hello/2'  ' '   'hello' $requestParams = ['2']; $response = $mvcs-&gt;play($scenario, $requestParams);</span></span></code> </pre> <br><blockquote>  <em>The PHP MVC implementation is hosted at <a href="https://github.com/svratenkov/mvcs">github.com</a> .</em> <br>  <em>This example is located in the MVCS <code>example</code> directory.</em> </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424595/">https://habr.com/ru/post/424595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424585/index.html">The release of CryEngine 5.5 from Crytek</a></li>
<li><a href="../424587/index.html">Summary of the book "Sales to large companies"</a></li>
<li><a href="../424589/index.html">How to enroll in a PhD machine learning program</a></li>
<li><a href="../424591/index.html">There is no ideal: as I was looking for a programming language for myself</a></li>
<li><a href="../424593/index.html">C ++ 11 and event handling</a></li>
<li><a href="../424597/index.html">Interview with Markus Schirp, RubyRussia Conference Speaker</a></li>
<li><a href="../424599/index.html">You have to choose which software you need: written on time or in quality</a></li>
<li><a href="../424601/index.html">Information architecture on the Internet, part 1</a></li>
<li><a href="../424603/index.html">The book "Why we are wrong. Traps thinking in action. " Excerpts part 1</a></li>
<li><a href="../424605/index.html">Zuckerberg funds: Collaboration + Technology + Open Science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>