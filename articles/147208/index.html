<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Life" of John Conway on Qt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, {{username}}! 



 Today I want to show you how to implement everyone's favorite game of John Conway's Game Of Life on Qt. We will write on widget...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Life" of John Conway on Qt</h1><div class="post__text post__text-html js-mediator-article">  Hi, {{username}}! <br><br><img src="http://habrastorage.org/storage2/c1c/72e/210/c1c72e210b2fbe06cb8c39035c14ba80.png"><br><br>  Today I want to show you how to implement everyone's favorite game of John Conway's <a href="http://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Game Of Life</a> on Qt.  We will write on widgets.  Using this project as an example, I will show how to work with QPainter, several classes from core, layouts, and generally graphics in Qt Widgets.  Anyone who is interested in this game or work with graphics on Qt, please read further.  In general, the article is focused on beginners, but advanced guys will also have something to read :). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To whom laziness - <a href="https://github.com/tucnak/conway">here</a> lies the source of the project.  You can collect immediately, dependencies on core, gui. <br><a name="habracut"></a><br><br><h1>  Idea </h1><br>  We want to implement Conway's Game Of Life with all the rules for Qt GUI.  It should be beautiful, scalable.  It should be possible to set the size of the field, the interval between generations, the choice of color for the cells.  Still need buttons Start, Stop, Clear.  You need to be able to save and load the game with all configs. <br><br><h1>  Architecture </h1><br>  We will do so.  on QPaintEvent, we will recalculate the width of the cell depending on the width of the window, draw a grid and cells.  We'll keep everything pretty in the layouts, at the Design stage, we'll figure it out.  As part of the settings - all very neatly put in a small socket. <br><br><h1>  Design </h1><br>  In general, I decided not to particularly dwell on this point.  I will not teach anyone how to do trivial things in the UI Designer.  Just sign for the architecture.  Create a horizontal layout manager.  Layout under it centralWidget.  Then we insert there (in horizontal) two vertical managers.  In the left there will be a window with the game, in the right - the settings.  In the designer, they look like the same size, but we will specify the stretch factor (the width factor relative to the neighboring layout) in the code.  Insert the QWidget into the game's layout - which, by the way, we will then promote to our game widget, and the settings-layout)).  You can talk for a long time, but it is better to show: <br><img src="https://habrastorage.org/storage2/d67/344/85b/d6734485bfa0e43604fab003ed669ba0.png"><br><br><h1>  Start thinking </h1><br>  Let's start with the algorithm.  I apologize, but I was too lazy to think and I decided to implement the simplest algorithm for simulating "Life" - with full calculation.  The essence of the algorithm is extremely simple.  For each cell, we consider its fate based on the previous generation and its neighbors.  Advantages of the algorithm - it is as simple as a mineral water cap.  Cons - quite expensive.  But, as it happens with everyone - laziness won.  I already came up with a few points.  We will store two matrices (universe, next) for the current and next generation.  We also need the m_masterColor variable to store the color of the cell, the timer for the timer, universeSize is the size of the matrix.  We will simply do: <br><ol><li>  Called startGame () </li><li>  The timer starts spinning at a specified interval. </li><li>  On timeout (), run newGeneration () </li><li>  Here we fill the next matrix based on bool isAlive (row, col) </li><li>  Redirecting next to universe </li><li>  Redraw the widget via update () </li><li>  paintEvent () calls grid and cell drawing methods </li><li>  And so long and tedious, while the timer is running. </li><li>  And the timer works until the moment when universe == next or stopGame () is not called </li></ol><br><br>  I will not dwell on the implementation of this whole algorithm, but only on a small part of it - drawing.  A bit of theory.  In Qt, for graphics, QPainter is primarily responsible, it contains methods for working with graphics.  You can draw with it on the widget only in paintEvent ().  By the way, here's what it looks like: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GameWidget::paintEvent(QPaintEvent *) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; paintGrid(p); paintUniverse(p); }</code> </pre> <br><br>  We will go deeper.  Here we have created an instance of QPainter and pass its reference to the paintGrid () and paintUniverse () methods.  They are engaged exclusively in drawing the model (matrix universe).  Everything is just like a clock.  Now consider paintGrid (): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GameWidget::paintGrid(QPainter &amp;p) { <span class="hljs-function"><span class="hljs-function">QRect </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">borders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, width()</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, height()</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// borders of the universe QColor gridColor = m_masterColor; // color of the grid gridColor.setAlpha(10); // must be lighter than main color p.setPen(gridColor); double cellWidth = (double)width()/universeSize; // width of the widget / number of cells at one row for(double k = cellWidth; k &lt;= width(); k += cellWidth) p.drawLine(k, 0, k, height()); double cellHeight = (double)height()/universeSize; // height of the widget / number of cells at one row for(double k = cellHeight; k &lt;= height(); k += cellHeight) p.drawLine(0, k, width(), k); p.drawRect(borders); }</span></span></code> </pre><br><br>  In the comments all the points that may not be clear - painted.  Now we will see how our "universe" is drawn: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GameWidget::paintUniverse(QPainter &amp;p) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> cellWidth = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)width()/universeSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> cellHeight = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)height()/universeSize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt;= universeSize; k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= universeSize; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(universe[k][j] == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if there is any sense to paint it qreal left = (qreal)(cellWidth*j-cellWidth); // margin from left qreal top = (qreal)(cellHeight*k-cellHeight); // margin from top QRectF r(left, top, (qreal)cellWidth, (qreal)cellHeight); p.fillRect(r, QBrush(m_masterColor)); // fill cell with brush of main color } } } }</span></span></code> </pre><br><br>  That's fine.  We can assume that we have learned to draw.  I'm still not going to particularly dwell on QPainter - it is even very well described in the documentation, but I will say that it is based on three elephants - a pen (pen), a brush (brush) and a figure (QRect, QCircle ...).  The pen draws the outline of the shape, the brush draws its fill.  In the last listing, we didn‚Äôt set the pen, because we don‚Äôt want a small square to outline, but we set a brush to fill. <br><br>  But how do we give the user the ability to mark cells?  Obviously, we will re-implement the keyPressEvent () method and will do something about it.  Here is the way of its listing: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GameWidget::mousePressEvent(QMouseEvent *e) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> cellWidth = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)width()/universeSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> cellHeight = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)height()/universeSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(e-&gt;y()/cellHeight)+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(e-&gt;x()/cellWidth)+<span class="hljs-number"><span class="hljs-number">1</span></span>; universe[k][j] = !universe[k][j]; update(); }</code> </pre><br><br><h1>  Save / Open Map </h1><br>  This functionality is implemented by two buttons - Save / Load.  Their task is to open and save files with game cards.  The file is stored: <br><ul><li>  Card size </li><li>  Card dump </li><li>  Color live cells </li><li>  Intergenerational Interval </li></ul><br><br>  Sample format: <br><pre> <code class="hljs json">[size] [dump] [red] [green] [blue] [interval]</code> </pre><br><br>  Size maps implement GameWidget :: cellNumber () and GameWidget :: setCellNumber () <br>  Dump - GameWidget :: dump () and GameWidget :: setDump (). <br>  The color is GameWidget :: masterColor () and GameWidget :: setMasterColor (). <br>  The interval is GameWidget :: interval () and GameWidget :: setInterval (). <br><br>  On the shoulders of MainWindow, it remains only to write and read correctly.  I will list the loadGame () function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::loadGame() { QString filename = QFileDialog::getOpenFileName(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, tr(<span class="hljs-string"><span class="hljs-string">"Open saved game"</span></span>), QDir::homePath(), tr(<span class="hljs-string"><span class="hljs-string">"Conway's Game Of Life File (*.life)"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(filename.length() &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-function"><span class="hljs-function">QFile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!file.open(QIODevice::ReadOnly)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-function"><span class="hljs-function">QTextStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;file)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sv; in &gt;&gt; sv; ui-&gt;cellsControl-&gt;setValue(sv); game-&gt;setCellNumber(sv); QString dump=<span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k != sv; k++) { QString t; in &gt;&gt; t; dump.append(t+<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } game-&gt;setDump(dump); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r,g,b; <span class="hljs-comment"><span class="hljs-comment">// RGB color in &gt;&gt; r &gt;&gt; g &gt;&gt; b; currentColor = QColor(r,g,b); game-&gt;setMasterColor(currentColor); // sets color of the dots QPixmap icon(16, 16); // icon on the button icon.fill(currentColor); // fill with new color ui-&gt;colorButton-&gt;setIcon( QIcon(icon) ); // set icon for button in &gt;&gt; r; // r will be interval number ui-&gt;iterInterval-&gt;setValue(r); game-&gt;setInterval(r); }</span></span></code> </pre><br><br><h1>  Color selection </h1><br>  I will not tell much here - it is implemented through QColorDialog and methods (mentioned above) of the GameWidget class.  By the way, to the left of the button text there is a square filled with the color that was selected.  This is done through QIcon, which receives a QPixmap of 16x16 size - filled with masterColor. <br><br><h1>  What I don't want to pay attention to </h1><br>  I will not tell you how to start a timer (timer-&gt; start ()) or redraw the widget (update ()) - I hope this is clear, in the end, Qt has, I‚Äôm not afraid to say, one of the best documentation in the world. <br><br>  Please do not write in the comments that the cells turned out to be rectangular, not square.  This is really my joint - I should have wrapped it all in QAbstractScrollArea - but it turned out that I did not.  In the end, forks and pull requests are welcome - it's not for nothing that I hosted GitHub)). <br><br><h1>  Photos and examples </h1><br><img src="http://habrastorage.org/storage2/07c/1ad/cc9/07c1adcc96a539d7065bdae4e65a6b10.png"><br>  "Machine gun" gliders on the field 50x50 with blue color. <br><br><img src="http://habrastorage.org/storage2/d08/06e/fe8/d0806efe8bbe5ddf0799ae4060c5260f.png"><br>  "Machine gun" gliders on the field 100x100 <br><br><img src="http://habrastorage.org/storage2/c1c/72e/210/c1c72e210b2fbe06cb8c39035c14ba80.png"><br>  The same machine gun, only with orange color. <br><br><h1>  Thanks for reading </h1><br>  Thank you all for taking the time to read this article. <br><br>  Once again source on <a href="https://github.com/tucnak/conway">github</a> . <br>  Map with machine gun on github: <a href="https://gist.github.com/3053366">gist</a> . <br><br>  Successes to you, and the main thing - the successful maiden, <br>  Ilya. </div><p>Source: <a href="https://habr.com/ru/post/147208/">https://habr.com/ru/post/147208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147201/index.html">What pay for the success of IT-specialists</a></li>
<li><a href="../147204/index.html">Quick start of the first project in Windows Azure. Web sites</a></li>
<li><a href="../147205/index.html">Yandex.Search for a site: good news for site owners based on CMS</a></li>
<li><a href="../147206/index.html">"Lefty" came out with solid-state disks</a></li>
<li><a href="../147207/index.html">What you need to control the business?</a></li>
<li><a href="../147209/index.html">Windows Windows: Metro Design School</a></li>
<li><a href="../147213/index.html">ASUS N46: the inevitability of change</a></li>
<li><a href="../147214/index.html">Upgrade to Windows 8 will be possible with the release version of the release for $ 39.99</a></li>
<li><a href="../147215/index.html">What will happen after the entry into force of the law ‚ÄúOn protection of children from information?‚Äù</a></li>
<li><a href="../147217/index.html">Video tutorials on creating components on Joomla 1.5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>