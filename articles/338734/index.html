<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dump memory and write maphack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One evening of school summer, I had a need for a maphack for DayZ Mod (Arma 2 OA). Looking for information on the topic, I realized that contacting th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dump memory and write maphack</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/511/d54/1a9/511d541a9c7c40a3aaa64ceb75b24622.jpg" alt="image"></p><br><p>  One evening of school summer, I had a need for a maphack for DayZ Mod (Arma 2 OA).  Looking for information on the topic, I realized that contacting the Battleye anti-cheat is not worth it, because there is neither the knowledge nor the experience to bypass the defensive kernel driver, which politely placed a bunch of hooks to access the game process. </p><br><p>  DayZ is one of the few games where the location of important objects for the gameplay does not change often and persists after a restart (the bases do not move, most of the equipment also remains in place for a long time).  This fact opens up the possibility of an attack through a RAM dump. <a name="habracut"></a></p><br><p>  All links at the end. </p><br><h3 id="glava-1-dampim">  Chapter 1. Dampy </h3><br><p>  To get a snapshot of memory in runtime without bypassing anti-cheat will hardly work.  Therefore, we are looking for other tactics.  The first that we find it <a href="https://habrahabr.ru/post/211749/">habrasatya</a> from which it becomes clear where to dig. </p><br><h4 id="popytka-1">  Attempt 1 </h4><br><p>  I did not manage to get the memory image through the hot crack described in the article, booting from Ubuntu CyberPack (IRF) and getting the image via fmem, for unexplained reasons, fmem hung. <br>  A little googling we find an alternative tool, with the same LiME ~ Linux Memory Extractor functionality.  Now it had to be assembled and run on livecd. <br>  The choice of the distribution fell on TinyCore (TinyCorePure64, if you need more than 3 GB of sdampit).  Having downloaded from it we swing and install packages. </p><br><pre><code class="hljs mel">tce-load -iw linux-kernel-sources-<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>.tcz cliorx linux-kernel-sources-<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>.sh</code> </pre> <br><p>  Next, we mount the flash drive with the sorts, where we will also dump the dump, collect it via make and get the image </p><br><pre> <code class="hljs dos">insmod ./lime.ko "<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>=/<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>/mem-image.lime <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>=lime"</code> </pre> <br><p>  Now this file needs to be fed to someone in order to get the memory of the process we need at the output.  For this we had to approach the Volatility Framework with the plugin memdump. </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">vol</span></span>.py -f F:\mem-image.lime <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>=lime pslist <span class="hljs-built_in"><span class="hljs-built_in">vol</span></span>.py -f F:\mem-image.lime <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>=lime memdump ‚Äìdump-<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> ./output ‚Äìp <span class="hljs-number"><span class="hljs-number">868</span></span></code> </pre> <br><p>  Or Rekall Framework, which is its fork and is actively developing, in contrast to the volatility itself </p><br><pre> <code class="hljs mel">rekal -f F:\mem-<span class="hljs-keyword"><span class="hljs-keyword">image</span></span>.lime pslist rekal -f F:\mem-<span class="hljs-keyword"><span class="hljs-keyword">image</span></span>.lime memdump dump_dir=<span class="hljs-string"><span class="hljs-string">"./output"</span></span>, pids=<span class="hljs-number"><span class="hljs-number">868</span></span></code> </pre> <br><p>  However, what I would not do, he did not want to wind up, and I continued to dig. </p><br><p>  When working with Rekall on windows 10, when you first search for something on the dump, you may receive a message like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">WARNING</span></span>:rekall<span class="hljs-number"><span class="hljs-number">.1</span></span>:Profile nt/GUID/F6F4895554894B24B4DF942361F0730D1 fetched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> built. Please consider reporting this profile <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the Rekall team so we may <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> profile repository.</code> </pre> <br><p>  And next time, it may fall with such an error: </p><br><pre> <code class="hljs pgsql">CRITICAL:rekall<span class="hljs-number"><span class="hljs-number">.1</span></span>:A DTB <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> was <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> but failed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> verify. See logging messages <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information.</code> </pre> <br><p>  If this happens, at startup you need to specify the --profile parameter with the profile value that you displayed for the first time. </p><br><h4 id="popytka-2">  Attempt 2 </h4><br><p>  To get the most complete snapshot of memory, you can use the hiberfil.sys file, in which all the memory is saved when the Windows go into hibernation. </p><br><p>  It's still easier here, go to hibernation mode, boot from any livecd (in my case, all the same TinyCore), mount the system disk (Read-Only) and the USB flash drive, copy the desired file. </p><br><p>  For TinyCore, do not forget to install the package for ntfs support. </p><br><pre> <code class="hljs pgsql">tce-<span class="hljs-keyword"><span class="hljs-keyword">load</span></span> -iw ntfs<span class="hljs-number"><span class="hljs-number">-3</span></span>g</code> </pre> <br><p>  Through fdisk -l, we find the logical partitions we need and mount them </p><br><pre> <code class="hljs pgsql">sudo ntfs<span class="hljs-number"><span class="hljs-number">-3</span></span>g -o ro /dev/sda2 /tmp/a1 //   <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Only</span></span> sudo ntfs<span class="hljs-number"><span class="hljs-number">-3</span></span>g /dev/sdc1 /tmp/a2</code> </pre> <br><p>  We copy </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">cp</span></span> /tmp/a1/hiberfil.sys /tmp/a2</code> </pre> <br><p>  Then this file could be fed volatility (supports hibernation file with win7 or earlier). </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">vol</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.py</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">imagecopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hiberfil</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sys</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">win7</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.img</span></span></code> </pre> <br><p>  Since I have win10, this option did not suit me. <br>  I tried to give the file to the Hibr2bin program, which used to be the Sandman Framework. </p><br><pre> <code class="hljs pgsql">HIBR2BIN /PLATFORM X64 /MAJOR <span class="hljs-number"><span class="hljs-number">10</span></span> /MINOR <span class="hljs-number"><span class="hljs-number">0</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">INPUT</span></span> hiberfil.sys /OUTPUT uncompressed.bin</code> </pre> <br><p>  But she gave an incomprehensible output, which frameworks for analysis refused to work with. <br>  Hibernation Recon came to the rescue with the Free version, which gave an exhaust readable for the frameworks without any problems. <br>  At the output from memdump we get a file with the process memory itself and a file with the ratio of virtual addresses to addresses in the file. </p><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">File</span></span> Address Length Virtual Addr <span class="hljs-comment"><span class="hljs-comment">-------------- -------------- -------------- 0x000000000000 0x000000001000 0x000000010000 0x000000001000 0x000000001000 0x000000020000 0x000000002000 0x000000001000 0x000000021000 0x000000003000 0x000000001000 0x00000002f000 0x000000004000 0x000000001000 0x000000040000 0x000000005000 0x000000001000 0x000000050000 0x000000006000 0x000000001000 0x000000051000</span></span></code> </pre> <br><h3 id="glava-2-pishem-maphak">  Chapter 2. We write maphak. </h3><br><p>  For the GUI, I chose Qt. </p><br><p>  To begin with, we write a convenient wrapper for accessing virtual memory in a file through a table. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemoryAPI</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MemoryAPI(){} MemoryAPI(QString pathDump, QString pathIDX); <span class="hljs-comment"><span class="hljs-comment">//      quint32 readPtr (const quint32 offset); qint32 readInt (const quint32 offset); float readFloat (const quint32 offset); QString readStringAscii(const quint32 offset, const quint32 size); QString readArmaString(quint32 offset); //  void loadIDX (QString path); void loadDump (QString path); private: //       QVector &lt;MemoryRange&gt; memoryRelations; quint32 convertVirtToPhys(const quint32 virt) const; QByteArray readVirtMem(const quint32 baseAddr, const quint32 size); QFile dumpFile; };</span></span></code> </pre> <br><p>  We present each line of the idx file as a simple structure. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemoryRange</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: quint32 baseVirtualAddress; quint32 basePhysicalAddress; quint32 size; };</code> </pre> <br><p>  All functions of reading data by virtual addresses are reduced to calling this function with the necessary parameters. </p><br><pre> <code class="cpp hljs">QByteArray MemoryAPI::readVirtMem(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint32 baseAddr, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint32 size) { QByteArray result; <span class="hljs-comment"><span class="hljs-comment">//  quint32 addr = convertVirtToPhys(baseAddr); dumpFile.seek(addr); result = dumpFile.read(size); return result; }</span></span></code> </pre> <br><p>  The address conversion is performed by simply searching for the desired offset in the array (a binary search could be used, but not). </p><br><pre> <code class="cpp hljs">quint32 MemoryAPI::convertVirtToPhys(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint32 virt) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = memoryRelations.begin(); it != memoryRelations.end(); ++it) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*it).inRange(virt)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint32&amp; phBase = (*it).getPhysicalAddress(), vrBase = (*it).getVirtualAddress(); <span class="hljs-comment"><span class="hljs-comment">//   if(phBase&gt;vrBase) return virt + (phBase - vrBase); else return virt - (vrBase - phBase); } } //       throw 1; }</span></span></code> </pre> <br><p>  Now we will make a structure in which we will store the data of each object in the game. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorldState</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//      enum class type {airplane, car, motorcycle, ship, helicopter, parachute, tank, tent, stash, fence, ammoBox, campFire, crashSite, animals, players, zombies, stuff, hedgehog, invalid}; type entityType; EntityData(); EntityData(QString n, QPointF c, type t = type::stuff); QString shortDescription()const; QString fullDescription()const; QPointF getCoords() const {return coords;} private: //  QString name; //  QPointF coords; //    ( ) QMap&lt;QString, QString&gt; additionalFields; };</span></span></code> </pre> <br><p>  Next, we write a class in which we will store the state of the world (all objects). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorldState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//    ,     WorldState(const QString&amp; dumpFile, const QString&amp; idxFile); //  xml-    WorldState(const QString&amp; stateFile); // xml-,      void saveState(const QString&amp; stateFile); // ,          ( ) QMap &lt;EntityData::type, EntityRange&gt; entityRanges; QString worldName; private: //    QVector &lt;EntityData&gt; entityArray; //     QVector&lt;quint32&gt; masterOffsets; QVector&lt;quint32&gt; tableOffsets; quint32 objTableAddress; void handleEntity (quint32 entityAddress, MemoryAPI&amp; mem); // void initRanges(); void initOffsets(); QDomElement makeElement(QDomDocument&amp; domDoc, const QString&amp; name, const QString&amp; strData = QString()); };</span></span></code> </pre> <br><p>  Here all the work with the memory dump and loading of information about all objects takes place. </p><br><pre> <code class="cpp hljs">WorldState::WorldState(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; dumpFile, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; idxFile) { <span class="hljs-comment"><span class="hljs-comment">//  initOffsets(); //      QProgressDialog progress; progress.setCancelButton(nullptr); progress.setLabelText("Loading dump..."); progress.setModal(true); progress.setMinimum(0); progress.setMaximum(masterOffsets.length()+2); progress.show(); MemoryAPI mem(dumpFile,idxFile); progress.setValue(1); for(auto mO = masterOffsets.begin(); mO != masterOffsets.end(); ++mO) { quint32 entityTableBasePtr = mem.readPtr(objTableAddress) + (*mO); for(auto tO = tableOffsets.begin(); tO != tableOffsets.end(); ++tO) { qint32 size = mem.readInt(entityTableBasePtr + 0x4 +(*tO)); for(qint32 i = 0; i!=size; ++i) { quint32 fPtr = mem.readPtr(entityTableBasePtr + (*tO)); quint32 entityAddress = mem.readPtr(fPtr + 4 * i); //  handleEntity(entityAddress, mem); //   ,       QCoreApplication::processEvents(); } } progress.setValue(progress.value()+1); } initRanges(); worldName = "chernarus"; progress.setValue(progress.value()+1); }</span></span></code> </pre> <br><p>  Initialize Offsets </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorldState::initOffsets() { masterOffsets.append(<span class="hljs-number"><span class="hljs-number">0x880</span></span>); masterOffsets.append(<span class="hljs-number"><span class="hljs-number">0xb24</span></span>); masterOffsets.append(<span class="hljs-number"><span class="hljs-number">0xdc8</span></span>); tableOffsets.append(<span class="hljs-number"><span class="hljs-number">0x8</span></span>); tableOffsets.append(<span class="hljs-number"><span class="hljs-number">0xb0</span></span>); tableOffsets.append(<span class="hljs-number"><span class="hljs-number">0x158</span></span>); tableOffsets.append(<span class="hljs-number"><span class="hljs-number">0x200</span></span>); objTableAddress = <span class="hljs-number"><span class="hljs-number">0xDAD8C0</span></span>; }</code> </pre> <br><p>  We will stop here in more detail.  All information about the game world is stored in approximately such a structure (Based on a dump found on the forum). </p><br><div class="spoiler">  <b class="spoiler_title">World structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _0x0000[<span class="hljs-number"><span class="hljs-number">8</span></span>]; InGameUI* inGameUI; <span class="hljs-comment"><span class="hljs-comment">//0x0008 char _0x000C[1520]; EntityTablePointer* entityTablePointer; //0x05FC VariableTableInfo* variableTableInfo; //0x0600 char _0x0604[428]; __int32 gameMode; //0x07B0 char _0x07B4[4]; float speedMultiplier; //0x07B8 char _0x07BC[196]; EntitiesDistributed table1; //0x0880 char _0x0B00[36]; EntitiesDistributed table2; //0x0B24 char _0x0DA4[36]; EntitiesDistributed table3; //0x0DC8 char _0x1048[849]; BYTE artilleryEnabled; //0x1399 BYTE enableItemsDropping; //0x139A char _0x139B[13]; UnitInfo* cameraOn; //0x13A8 char _0x13AC[4]; UnitInfo* cplayerOn; //0x13B0 UnitInfo* realPlayer; //0x13B4 char _0x13B8[48]; float actualOvercast; //0x13E8 float wantedOvercast; //0x13EC __int32 nextWeatherChange; //0x13F0 float currentFogLevel; //0x13F4 float fogTarget; //0x13F8 char _0x13FC[32]; __int32 weatherTime; //0x141C char _0x1420[8]; BYTE playerManual; //0x1428 BYTE playerSuspended; //0x1429 char _0x142A[30]; __int32 N0D09AD19; //0x1448 char _0x144C[92]; ArmaString* currentCampaign; //0x14A8 char _0x14AC[4]; __int32 N0D09B79F; //0x14B0 char _0x14B4[52]; float viewDistanceHard; //0x14E8 float viewDistanceMin; //0x14EC float grass; //0x14F0 char _0x14F4[36]; __int32 initTableCount; //0x1518 __int32 initTableMaxCount; //0x151C char _0x1520[4]; };//Size=0x1524</span></span></code> </pre> </div></div><br><p>  You can get access to this structure by a pointer, which lies in a static offset for each version of the game (the offset can be zoomed or you can find it yourself through reverse, but this is a completely different story).  This offset is stored in the variable objTableAddress.  In masterOffsets, we store offsets by 3 tables, relative to this structure. </p><br><div class="spoiler">  <b class="spoiler_title">Table with tables</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntitiesDistributed</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _0x0000[<span class="hljs-number"><span class="hljs-number">8</span></span>]; Entity* table1; <span class="hljs-comment"><span class="hljs-comment">//0x0008 __int32 table1Size; //0x000C char _0x0010[160]; Entity* table2; //0x00B0 __int32 table2Size; //0x00B4 char _0x00B8[160]; Entity* table3; //0x0158 __int32 table3Size; //0x015C char _0x0160[160]; Entity* table4; //0x0200 __int32 table4Size; //0x0204 char _0x0208[120]; };//Size=0x0280</span></span></code> </pre> </div></div><br><p>  In turn, each table stores 4 more tables with a length (we store offsets for these tables in tableOffsets). <br>  Now we can iterate over all objects in the game.  Let us analyze the function that processes each entity. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorldState::handleEntity(quint32 entityAddress, MemoryAPI &amp;mem) { QString objType; QString objName; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> coordX; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> coordY; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ quint32 obj1 = entityAddress; quint32 pCfgVehicle = mem.readPtr(obj1 + <span class="hljs-number"><span class="hljs-number">0x3C</span></span>); quint32 obj3 = mem.readPtr(pCfgVehicle + <span class="hljs-number"><span class="hljs-number">0x30</span></span>); quint32 pObjType = mem.readPtr(pCfgVehicle + <span class="hljs-number"><span class="hljs-number">0x6C</span></span>); objType = mem.readArmaString(pObjType); objName = mem.readStringAscii(obj3 + <span class="hljs-number"><span class="hljs-number">0x8</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); quint32 pEntityVisualState = mem.readPtr(obj1 + <span class="hljs-number"><span class="hljs-number">0x18</span></span>); coordX = mem.readFloat(pEntityVisualState + <span class="hljs-number"><span class="hljs-number">0x28</span></span>); coordY = mem.readFloat(pEntityVisualState + <span class="hljs-number"><span class="hljs-number">0x30</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) { qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    ."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   EntityData ed(objName, QPointF(coordX, coordY)); //    if(objType == "car") ed.entityType = EntityData::type::car; else if(objType == "motorcycle") ed.entityType = EntityData::type::motorcycle; else if(objType == "airplane") ed.entityType = EntityData::type::airplane; else if(objType == "helicopter") ed.entityType = EntityData::type::helicopter; else if(objType == "ship") ed.entityType = EntityData::type::ship; else if(objType == "tank") ed.entityType = EntityData::type::tank; else if(objType == "parachute") ed.entityType = EntityData::type::parachute; else if(objName.indexOf("TentStorage")!=-1) ed.entityType = EntityData::type::tent; else if(objName.indexOf("Stash")!=-1) ed.entityType = EntityData::type::stash; else if(objName.indexOf("WoodenGate")!=-1 || objName.indexOf("WoodenFence")!=-1) ed.entityType = EntityData::type::fence; else if(objName.indexOf("DZ_MedBox")!=-1 || objName.indexOf("DZ_AmmoBox")!=-1) ed.entityType = EntityData::type::ammoBox; else if(objName.indexOf("Hedgehog_DZ")!=-1) ed.entityType = EntityData::type::hedgehog; else if(objName.indexOf("Land_Camp_Fire_DZ")!= -1) ed.entityType = EntityData::type::campFire; else if(objName.indexOf("CrashSite")!= -1) ed.entityType = EntityData::type::crashSite; else if(objName.indexOf("WildBoar")== 0 || objName.indexOf("Rabbit")== 0 || objName.indexOf("Cow")== 0 || objName.indexOf("Sheep")== 0 || objName.indexOf("Goat")== 0 || objName.indexOf("Hen")== 0) ed.entityType = EntityData::type::animals; else if(objName.indexOf("Survivor2_DZ")!= -1 || objName.indexOf("Sniper1_DZ")!=-1 || objName.indexOf("Camo1_DZ")!=-1 || objName.indexOf("Survivor3_DZ")!=-1 || objName.indexOf("Bandit1_DZ")!= -1 || objName.indexOf("Soldier1_DZ")!= -1) ed.entityType = EntityData::type::players; else ed.entityType = EntityData::type::stuff; entityArray.append(ed); }</span></span></code> </pre> <br><p>  Each entity represents something like this. </p><br><div class="spoiler">  <b class="spoiler_title">Entity structure</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _0x0000[<span class="hljs-number"><span class="hljs-number">24</span></span>]; EntityVisualState* entityVisualState; <span class="hljs-comment"><span class="hljs-comment">//0x0018 char _0x001C[32]; CfgVehicle* cfgVehicle; //0x003C char _0x0040[476]; EntityInventory* entityInventory; //0x021C };//Size=0x0220</span></span></code> </pre> </div></div><br><p>  Here we are interested in all three pointers. </p><br><ul><li>  EntityVisualState - location information. </li><li>  CfgVehicle - characteristics (name, type, maximum speed, etc.). </li><li>  EntityInventory - inventory (inventory reading is not implemented, because for my purposes it is unnecessary). <br><br></li></ul><br><p>  From CfgVehicle we read the name and type. </p><br><pre> <code class="cpp hljs">ArmaString* entityName; <span class="hljs-comment"><span class="hljs-comment">//0x0030 ArmaString* objectType; //0x006C</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">EntityVisualState</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityVisualState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _0x0000[<span class="hljs-number"><span class="hljs-number">4</span></span>]; D3DXVECTOR3 dimension; <span class="hljs-comment"><span class="hljs-comment">//0x0004 D3DXVECTOR3 rotation1; //0x0010 D3DXVECTOR3 direction; //0x001C D3DXVECTOR3 coordinates; //0x0028 char _0x0034[20]; D3DXVECTOR3 velocity; //0x0048 float angularVelocity; //0x0054 float zVelocity2; //0x0058 float Speed; //0x005C D3DXVECTOR3 acceleration; //0x0060 char _0x006C[16]; D3DXVECTOR3 direction2; //0x007C D3DXVECTOR3 rotation2; //0x0088 D3DXVECTOR3 direction3; //0x0094 char _0x00A0[12]; float fuelLevel; //0x00AC char _0x00B0[92]; D3DXVECTOR3 headCoordinates; //0x010C D3DXVECTOR3 torsoCoordinates; //0x0118 char _0x0124[244]; float N047F1D6C; //0x0218 char _0x021C[200]; };//Size=0x02E4</span></span></code> </pre> </div></div><br><p>  From EntityVisualState we read the vector of coordinates, which is a structure of three variables. </p><br><pre> <code class="cpp hljs">D3DXVECTOR3 coordinates;</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D3DXVECTOR3</span></span></span><span class="hljs-class"> {</span></span> FLOAT x; FLOAT y; FLOAT z; };</code> </pre> <br><p>  Here we need only x and y (in fact, z), so we read them like this: </p><br><pre> <code class="cpp hljs">coordX = mem.readFloat(pEntityVisualState + <span class="hljs-number"><span class="hljs-number">0x28</span></span>); coordY = mem.readFloat(pEntityVisualState + <span class="hljs-number"><span class="hljs-number">0x30</span></span>);</code> </pre> <br><p>  By the way, in the additionalFields map, which is in EntityData, at this stage you can record any additional information.  For example, the contents of the inventory or the speed of movement. </p><br><p>  Now we have received and classified information about all the entities in the game world, now we need to somehow display it, for this I used QPainter. </p><br><p>  Create a widget class for drawing. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InteractiveMap</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QWidget { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: InteractiveMap(QWidget* pwgt = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~InteractiveMap(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QPaintEvent* pe)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// (  ) const float minScale = 1.0f; const float maxScale = 8.0f; const float scaleStep= 2.0f; void updateScale(const qreal value, const QPointF&amp; dpos); void updateTranslate(const QPointF&amp; value); bool getFilterValue(EntityData::type t); bool getFilterValue(QString t); void mousePressEvent (QMouseEvent* pe); void mouseMoveEvent (QMouseEvent* pe); void wheelEvent (QWheelEvent *pe); void findCloseObjects(QPointF coords); QVector&lt;CloseObjects&gt;* input; QPainter* painter; QPixmap* image; WorldState* worldState; qreal scale; QPointF translate; QPoint startMove; //  QPixmap cache; QMutex renderMutex; //  ,    QFutureWatcher&lt;QString&gt; closeObjWatcher; QFuture&lt;QString&gt; closeObjFuture; public slots: //  void loadState(QString stateFile); void loadDump(QString dumpFile, QString idxFile); void closeState(); void saveState(QString stateFile); void updateCache(); void sendCloseObjects(); signals: void showCloseObjects(QString str); void saveStateChanged(bool state); };</span></span></code> </pre> <br><p>  I draw tags with the technique over the picture with the map.  Labels on the map for the current scale I cache in QPixmap (it is expensive to re-draw a few hundred or thousands of objects with each camera shift). </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InteractiveMap::paintEvent(QPaintEvent *pe) { renderMutex.lock(); painter-&gt;begin(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">////////////////////////////////////////////////// QTransform mat; painter-&gt;setTransform(mat); painter-&gt;scale(scale, scale); painter-&gt;translate(translate); painter-&gt;drawPixmap(0,0, *image); if(cache.isNull()) { //  DPR,        cache = QPixmap(image-&gt;size()*4); cache.setDevicePixelRatio(4); cache.fill(Qt::transparent); QPainter cachePaint(&amp;cache); //     for(QMap&lt;EntityData::type, EntityRange&gt;::const_iterator it = worldState-&gt;entityRanges.cbegin(); it!=worldState-&gt;entityRanges.cend();++it) { //      if(getFilterValue(it.key())) { for(QVector&lt;EntityData&gt;::const_iterator i = it.value().start; i!= it.value().end; ++i) { float x = i-&gt;getCoords().x(); float y = i-&gt;getCoords().y(); //     x = (((x) / (15360.0f / 975.0f))); y = (((15360.0f - y) / (15360.0f / 970.0f)) - 4.0f); //  QFont font("Arial"); QPen pen; pen.setWidthF(4.0f/scale); pen.setStyle(Qt::SolidLine); font.setPointSizeF(qMax(float(8.0f*1.0f/scale),2.0f)); cachePaint.setFont(font); cachePaint.setPen(pen); cachePaint.drawPoint(x,y); //  ,   if(getFilterValue(QString("name"))) cachePaint.drawText(x,y,i-&gt;shortDescription()); } } } } painter-&gt;drawPixmap(0,0,cache); ////////////////////////////////////////////////// painter-&gt;end(); renderMutex.unlock(); }</span></span></code> </pre> <br><p>  To select the types of entities that need to be displayed and other settings, I use QCheckBoxes on the sidebar (you can look at their implementation on the github).  To associate the draw with the settings, I first used bare QSettings, but it turned out that it does not cache the settings in memory, but works directly with the registry, so I had to write a wrapper singleton with a cache, which also sends a redraw signal when updating parameters. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SettingsManager</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SettingsManager(); ~SettingsManager(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SettingsManager&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">QVariant </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QVariant &amp;defaultValue = QVariant())</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QVariant &amp;value)</span></span></span></span>; SettingsManager(SettingsManager <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; SettingsManager&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (SettingsManager <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QMap&lt;QString, QVariant&gt; data; QSettings settings; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br><p>  For easy viewing of the map, I implemented the scaling on the cursor (on the mouse wheel) and the shift (with the latch pressed).  Another important feature is the viewing of the full characteristics and game coordinates of the entities (when you click SCM to the area of ‚Äã‚Äãthe desired objects). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void InteractiveMap::updateScale(qreal value, const QPointF&amp; dpos) { qreal newScale = scale * value; if(newScale &gt;= minScale &amp;&amp; newScale &lt;= maxScale) { scale = newScale; //       translate += dpos/scale; updateCache(); } } //   void InteractiveMap::updateTranslate(const QPointF&amp; value) { QPointF newV = translate + (value * 1/scale); translate = newV; update(); } //    void InteractiveMap::mousePressEvent(QMouseEvent *pe) { //    if(pe-&gt;buttons() &amp; Qt::LeftButton) startMove = pe-&gt;pos(); //       else if(pe-&gt;buttons() &amp; Qt::MidButton) { if(worldState) { //   ,    QPointF pos = pe-&gt;pos()/scale - translate; if(pos.x() &gt;= 0.0f &amp;&amp; pos.x() &lt;= image-&gt;width() &amp;&amp; pos.y() &gt;= 0.0f &amp;&amp; pos.y() &lt;= image-&gt;height()) { //     pos.rx() = pos.x() * (15360.0f / 975.0f); pos.ry() = -((15360.0f/970.0f)*(pos.y()+4.0f)-15360.0f); //   findCloseObjects(pos); } } } } void InteractiveMap::mouseMoveEvent(QMouseEvent *pe) { //    if(pe-&gt;buttons() &amp; Qt::LeftButton) { updateTranslate(pe-&gt;pos() - startMove); startMove = pe-&gt;pos(); } } void InteractiveMap::wheelEvent(QWheelEvent *pe) { //  float dScale = (pe-&gt;angleDelta().y() &lt; 0) ? 1/scaleStep : scaleStep; QPointF nPos = pe-&gt;pos() * (dScale); QPointF dPos = pe-&gt;pos() - nPos; updateScale(dScale,dPos); }</span></span></code> </pre> <br><p>  Characterization is implemented using the QtConcurrent framework, through the MapReduce model. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Reduce  void addToAnswer(QString&amp; result, const QString&amp; interm) { if(!interm.isEmpty()) result += interm; } void InteractiveMap::findCloseObjects(QPointF coords) { if(!closeObjWatcher.isRunning()) { //   input = new QVector&lt;CloseObjects&gt;; for(QMap&lt;EntityData::type, EntityRange&gt;::iterator it = worldState-&gt;entityRanges.begin(); it!=worldState-&gt;entityRanges.end();++it) { if(getFilterValue(it.key())) { //   CloseObjects obj(&amp;it.value(), coords); input-&gt;append(obj); } } closeObjFuture = QtConcurrent::mappedReduced(*input, &amp;CloseObjects::findCloseObjects, addToAnswer); //     connect(&amp;closeObjWatcher, &amp;QFutureWatcher&lt;QString&gt;::finished, this, &amp;InteractiveMap::sendCloseObjects); //  closeObjWatcher.setFuture(closeObjFuture); } } void InteractiveMap::sendCloseObjects() { //    emit showCloseObjects(closeObjWatcher.result()); //     delete input; input = nullptr; }</span></span></code> </pre> <br><p>  The input class consists of a pointer to the category of entities and points to search. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseObjects</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CloseObjects() {} CloseObjects(EntityRange *r, QPointF p): range(r), coords(p) {} <span class="hljs-function"><span class="hljs-function">QString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findCloseObjects</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EntityRange* range; QPointF coords; };</code> </pre> <br><p>  In the Map function, we go through all the objects in the category, if the entity is in a constant radius from the cursor position, then we return a full description of the object (name + additional fields) and game coordinates. </p><br><pre> <code class="cpp hljs">QString CloseObjects::findCloseObjects() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QString result; <span class="hljs-function"><span class="hljs-function">QTextStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;result)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     2    stream.setRealNumberNotation(QTextStream::FixedNotation); stream.setRealNumberPrecision(2); for(QVector&lt;EntityData&gt;::const_iterator it = range-&gt;start; it != range-&gt;end; ++it) { float len = qSqrt(qPow((it-&gt;getCoords().x() - coords.x()),2) + qPow((it-&gt;getCoords().y() - coords.y()),2)); if(len &lt;= 350) { stream &lt;&lt; it-&gt;fullDescription() &lt;&lt; "\n" &lt;&lt; QVariant(it-&gt;getCoords().x()/100).toFloat() &lt;&lt; " " &lt;&lt; QVariant((15360 - it-&gt;getCoords().y())/100).toFloat() &lt;&lt; "\n"; } } return result; }</span></span></code> </pre> <br><p>  On this I finish my story.  Who is not difficult, look at the code, point out possible jambs. <br>  Interested parties can add additional characteristics of the objects and throw a pull-request. </p><br><p>  References: </p><br><ul><li>  <a href="https://arsenalrecon.com/weapons/hibernation-recon/">Hibernation recon</a> </li><li>  <a href="https://github.com/504ensicsLabs/LiME">LiME ~ Linux Memory Extractor</a> </li><li>  <a href="https://github.com/volatilityfoundation/volatility">Volatility Framework</a> </li><li>  <a href="https://github.com/google/rekall">Rekall Framework</a> </li><li>  <a href="https://github.com/comaeio/Hibr2Bin">Hibr2bin</a> </li><li>  <a href="https://www.unknowncheats.me/forum/arma-2/111239-arma2-oa-offset-reclass-dump.html">Dump Offsets</a> </li><li>  <a href="https://github.com/3vilWind/DayzModDumpHack">Github sabzh</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338734/">https://habr.com/ru/post/338734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338720/index.html">Use PubNub: Emotional Talking Chat Do It Yourself</a></li>
<li><a href="../338722/index.html">The second version of the Air Quality Monitor</a></li>
<li><a href="../338724/index.html">How to build a self-managed business: formulating the ‚Äúlaws of robotics‚Äù Hamster Marketplace</a></li>
<li><a href="../338730/index.html">IT events digest for October</a></li>
<li><a href="../338732/index.html">Performance: what's in my name? - Alexey Shipilev about optimization in large projects</a></li>
<li><a href="../338736/index.html">How to solve the perennial conflict between development and operation?</a></li>
<li><a href="../338740/index.html">The results of the summer internship 2017 in Digital Security. Department of research</a></li>
<li><a href="../338742/index.html">Hackathon from ABBYY</a></li>
<li><a href="../338744/index.html">Reamp library: pain killer for your Android applications</a></li>
<li><a href="../338746/index.html">Hosting for a startup: designer, clouds or your own hardware?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>