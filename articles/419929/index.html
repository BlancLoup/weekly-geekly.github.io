<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[DotNetBook] Exception events and how to get StackOverflow and ExecutionEngineException from scratch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Exception Events 


 In general, we do not always know about the exceptions that will occur in our programs because we almost always use something tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[DotNetBook] Exception events and how to get StackOverflow and ExecutionEngineException from scratch</h1><div class="post__text post__text-html js-mediator-article"><img width="350" src="https://habrastorage.org/getpro/habr/post_images/7d3/f93/897/7d3f93897f300331c33c0ee5e9fa996f.jpg" align="left"><br><h2 id="sobytiya-ob-isklyuchitelnyh-situaciyah">  Exception Events </h2><br><p> In general, we do not always know about the exceptions that will occur in our programs because we almost always use something that is written by other people and that is in other subsystems and libraries.  Not only are various situations possible in your own code, in the code of other libraries, there are also many problems associated with the execution of code in isolated domains.  And just in this case it would be extremely useful to be able to obtain data on the operation of isolated code.  After all, the situation can be quite real when a third-party code intercepts all errors without exception, muffling their <code>fault</code> block: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } catch { // do nothing, just to make code call more safe }</span></span></code> </pre> <br><p>  In such a situation, it may turn out that code execution is no longer as safe as it looks, but we have no reports that any problems have occurred.  The second option is when the application suppresses some, even if legal, exception.  And the result - the following exception in a random place will cause the application to fall in some future from a seemingly random error.  Here I would like to have an idea what the background to this error was.  What the course of events has led to this situation.  And one of the ways to make this possible is to use additional events that relate to exceptional situations: <code>AppDomain.FirstChanceException</code> and <code>AppDomain.UnhandledException</code> . </p><br><blockquote>  This article is the second of four in a series of articles about exceptions.  Full cycle: <br>  - <a href="https://habr.com/post/419927/">Type system architecture</a> <br>  - <a href="https://habr.com/post/419929/">Events about exceptional situations</a> (this article) <br>  - Types of exceptional situations <br>  - Serialization and processing units <br></blockquote><br><blockquote><h3>  Note </h3><br>  The chapter published on Habr√© is not updated and it is possible that it is already somewhat outdated.  So, please ask for a more recent text to the original: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub, table of contents</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="">GitHub, chapter</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 of the book, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><a name="habracut"></a><br><p>  In fact, when you "throw an exception", the usual method of some internal subsystem, <code>Throw</code> , is called, which internally performs the following operations: </p><br><ul><li>  Causes the <code>AppDomain.FirstChanceException</code> </li><li>  Searches chained handlers in the chain </li><li>  Causes the handler to pre-roll the stack to the desired frame. </li><li>  If the handler was not found, <code>AppDomain.UnhandledException</code> is called, crashing the thread in which the exception occurred. </li></ul><br><p>  We should immediately make a reservation, answering the question that torments many minds: is it possible to somehow cancel an exception that has arisen in an uncontrolled code that is executed in an isolated domain, without thus unleashing the stream in which this exception was thrown?  The answer is laconic and simple: no.  If an exception is not caught on the whole range of methods called, it cannot be processed in principle.  Otherwise, a strange situation arises: if we use an <code>AppDomain.FirstChanceException</code> handle (some kind of synthetic <code>catch</code> ) an exception, then to which frame should the thread stack roll back?  How to set this in the framework of the .NET CLR rules?  No  It is simply not possible.  The only thing we can do is to record the information received for future research. </p><br><p>  The second thing that should be told "ashore" is why these events were not entered by <code>Thread</code> , but by <code>AppDomain</code> .  After all, if you follow the logic, exceptions occur where?  In the flow of command execution.  Those.  actually have a <code>Thread</code> .  So why do problems arise at the domain?  The answer is very simple: for what situations were <code>AppDomain.FirstChanceException</code> and <code>AppDomain.UnhandledException</code> ?  Among other things - to create a sandbox for plug-ins.  Those.  for situations where there is a certain <code>AppDomain</code> that is configured for PartialTrust.  Inside this AppDomain, anything can happen: there at any moment threads can be created, or existing ones from ThreadPool can be used.  Then it turns out that we, being outside of this process (we did not write that code) cannot subscribe to events of internal streams in any way.  Just because we have no idea what kind of threads were created there.  But we are guaranteed to have <code>AppDomain</code> , which organizes the sandbox and the link to which we have. </p><br><p>  So, in fact, we are provided with two boundary events: something happened, which was not supposed ( <code>FirstChanceExecption</code> ) and ‚Äúall bad‚Äù, no one handled the exceptional situation: it turned out to be not provided.  And because the flow of execution of commands does not make sense and he ( <code>Thread</code> ) will be shipped. </p><br><p>  What can be obtained by having these events and why is it bad for developers to bypass these events? </p><br><h3 id="appdomainfirstchanceexception">  AppDomain.FirstChanceException </h3><br><p>  This event is inherently purely informational in nature and cannot be "processed."  Its task is to notify you that an exception has occurred within this domain and after processing the event it will begin to be processed by the application code.  Its execution carries with it a couple of features that need to be remembered during the design of the handler. </p><br><p>  But let's first take a look at a simple synthetic example of its processing: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Main() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; AppDomain.CurrentDomain.FirstChanceException += <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, args</span></span></span><span class="hljs-function">) =&gt;</span></span> { Console.WriteLine(args.Exception.Message); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(++counter == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(); } }; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); }</code> </pre> <br><p>  What is remarkable about this code?  Wherever a certain code generates an exception, the first thing that happens is its logging to the console.  Those.  even if you forget or cannot foresee handling some type of exception, it will still appear in the event log that you organize.  The second is a somewhat strange condition for the release of an internal exception.  The thing is that inside the <code>FirstChanceException</code> handler <code>FirstChanceException</code> you can't just pick up and throw another exception.  Rather, even this: inside the FirstChanceException handler, you are <em>not able</em> to throw at least some exception.  If you do, there are two possible events.  At first, if there were no <code>if(++counter == 1)</code> condition <code>if(++counter == 1)</code> , we would get an infinite <code>FirstChanceException</code> for all new and new <code>ArgumentOutOfRangeException</code> .  What does it mean?  This means that at a certain stage we would get a <code>StackOverflowException</code> : <code>throw new Exception("Hello!")</code> Calls the CLR method Throw, which throws a <code>FirstChanceException</code> , which calls <code>Throw</code> already for <code>ArgumentOutOfRangeException</code> and then on recursion.  The second option - we defended by the depth of recursion using the <code>counter</code> condition.  Those.  in this case, we throw an exception only once.  The result is more than unexpected: we get an exceptional situation, which actually runs inside the <code>Throw</code> instruction.  And what is most suitable for this type of error?  According to ECMA-335, if the instruction was entered in an exceptional position, <code>ExecutionEngineException</code> must be thrown!  And we are unable to handle this exceptional situation.  It leads to full departure from the application.  What options of safe processing do we have? </p><br><p>  The first thing that comes to mind is to <code>try-catch</code> block on the entire code of the <code>FirstChanceException</code> handler: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Main() { var fceStarted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; var sync = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); EventHandler&lt;FirstChanceExceptionEventArgs&gt; <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> EventHandler&lt;FirstChanceExceptionEventArgs&gt;((_, args) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (sync) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fceStarted) { //     - ,        -      , //   try  . Console.WriteLine($"FirstChanceException inside FirstChanceException ({args.Exception.GetType().FullName})"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fceStarted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; try { //     . ,   Console.WriteLine(args.<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>.Message); throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentOutOfRangeException(); } catch (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) { //       Console.WriteLine("Success"); } finally { fceStarted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } }); AppDomain.CurrentDomain.FirstChanceException += <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>; try { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("Hello!"); } finally { AppDomain.CurrentDomain.FirstChanceException -= <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>; } } OUTPUT: Hello! Specified argument was <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>. FirstChanceException inside FirstChanceException (<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.ArgumentOutOfRangeException) Success !<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>: Hello!</code> </pre> <br><p>  Those.  on the one hand, we have the <code>FirstChanceException</code> event handling code, and on the other hand, additional exception handling code in <code>FirstChanceException</code> itself.  However, the logging techniques for both situations should be different.  If the logging of event handling can go arbitrarily, then error handling of the processing logic of the <code>FirstChanceException</code> should go without exception situations in principle.  The second thing you probably noticed is the synchronization between the threads.  There may be a question: why is it here if any exception is born in any thread and therefore the <code>FirstChanceException</code> is supposed to be thread-safe.  However, everything is not so cheerful.  <code>FirstChanceException</code> occurs at AppDomain.  And this means that it occurs for any thread that is launched in a specific domain.  Those.  if we have a domain within which several threads have been started, then <code>FirstChanceException</code> can go in parallel.  And this means that we need to somehow protect ourselves with synchronization: for example, using <code>lock</code> . </p><br><p>  The second way is to try to divert processing to a neighboring stream belonging to another application domain.  However, it is worth making a reservation here that with such an implementation we have to build a dedicated domain just for this task so that it does not work out so that other threads that are working may put this domain: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (ApplicationLogger.Go(AppDomain.CurrentDomain)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ApplicationLogger</span></span> : <span class="hljs-title"><span class="hljs-title">MarshalByRefObject</span></span> { ConcurrentQueue&lt;Exception&gt; queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;Exception&gt;(); CancellationTokenSource cancellation; ManualResetEvent @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogFCE</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception message</span></span></span><span class="hljs-function">)</span></span> { queue.Enqueue(message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cancellation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cancellation.IsCancellationRequested) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queue.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exception)) { Console.WriteLine(exception.Message); } Thread.Yield(); } @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.Set(); }); thread.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopAndWait</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cancellation.Cancel(); @<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.WaitOne(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IDisposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AppDomain observable</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dom = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"ApplicationLogger"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory, }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> proxy = (ApplicationLogger)dom.CreateInstanceAndUnwrap(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ApplicationLogger).Assembly.FullName, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ApplicationLogger).FullName); proxy.StartThread(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler&lt;FirstChanceExceptionEventArgs&gt;((_, args) =&gt; { proxy.LogFCE(args.Exception); }); observable.FirstChanceException += subscription; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(() =&gt; { observable.FirstChanceException -= subscription; proxy.StopAndWait(); }); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Subscription</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { Action act; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscription</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action act</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.act = act; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { act(); } } }</code> </pre> <br><p>  In this case, the handling of <code>FirstChanceException</code> is as secure as possible: in a neighboring stream belonging to a neighboring domain.  Message processing errors cannot crash application workflows.  Plus, you can listen to the UnhandledException of the message logging domain separately: fatal errors during logging will not crash the entire application. </p><br><h3 id="appdomainunhandledexception">  AppDomain.UnhandledException </h3><br><p>  The second message that we can intercept and which deals with exception handling is <code>AppDomain.UnhandledException</code> .  This message is very bad news for us because it means that there was no one who could find a way to handle the error in some thread.  Also, if such a situation has occurred, all we can do is to ‚Äúunload‚Äù the consequences of such an error.  Those.  in any way, clean up the resources belonging only to this thread if any were created.  However, an even better situation is to handle exceptions, being in the "root" of the threads without closing the flow.  Those.  essentially set <code>try-catch</code> .  Let's try to consider the appropriateness of such behavior. </p><br><p>  Let us have a library that needs to create threads and implement some kind of logic in these threads.  We, as users of this library, are interested only in the guarantee of API calls and also in receiving error messages.  If the library destroys the streams without notifying them, this is of little help to us.  Moreover, a thread crash will result in an <code>AppDomain.UnhandledException</code> message, in which there is no information about which particular thread lay on its side.  If we are talking about our code, the collapsing stream will hardly be useful to us either.  In any case, I did not meet this need.  Our task is to process errors correctly, send information about their occurrence to the error log and exit the stream correctly.  Those.  essentially wrap the method from which the thread starts in <code>try-catch</code> : </p><br><pre> <code class="hljs javascript"> ThreadPool.QueueUserWorkitem(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { using(Disposables aggregator = ...){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// do work here, plus: aggregator.Add(subscriptions); aggregator.Add(dependantResources); } catch (Exception ex) { logger.Error(ex, "Unhandled exception"); } } });</span></span></code> </pre> <br><p>  In this scheme, we get what we need: on the one hand, we will not bring down the flow.  On the other hand, we will correctly clear local resources if they were created.  Well, in the appendage - organize the logging of the error.  But wait, you say.  Somehow you famously jumped off the question of the event <code>AppDomain.UnhandledException</code> .  Is it really not necessary?  Need to.  But just to let you know that we forgot to wrap some threads in a <code>try-catch</code> with all the necessary logic.  With everything: with logging and cleaning of resources.  Otherwise it will be completely wrong: to take and extinguish all exceptions, as if they were not there at all. </p><br><blockquote><h3>  Link to the whole book </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 books, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/419929/">https://habr.com/ru/post/419929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419919/index.html">Version Control Inside SQL Server</a></li>
<li><a href="../419921/index.html">How to drop 10 million packets per second</a></li>
<li><a href="../419923/index.html">My time creativity, clock from motherboards</a></li>
<li><a href="../419925/index.html">Version control of individual files using GitHub Gist</a></li>
<li><a href="../419927/index.html">[DotNetBook] Exceptions: type system architecture</a></li>
<li><a href="../419931/index.html">[DotNetBook] Time for entertaining stories: exceptionally exceptional situations</a></li>
<li><a href="../419933/index.html">How to do a search for users on Github using Angular</a></li>
<li><a href="../419935/index.html">Exactly once is NOT exactly the same: article analysis</a></li>
<li><a href="../419939/index.html">How I did navigation in React Native is not so terrible</a></li>
<li><a href="../419941/index.html">Photo tour of the office "Audiomania": Part One</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>