<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>All the same you will not manage! - Use of interfaces and dependency injection for durable design</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 We finally have a contract to update the book by Mark Siman " Dependency Injection in .NET " - the main thing is that he finish it as soon a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>All the same you will not manage! - Use of interfaces and dependency injection for durable design</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  We finally have a contract to update the book by Mark Siman " <a href="https://www.amazon.com/Dependency-Injection-NET-Mark-Seemann/dp/161729473X/">Dependency Injection in .NET</a> " - the main thing is that he finish it as soon as possible.  In addition, we have in the editorial <a href="https://www.amazon.com/Spring-Design-Patterns-application-development-dp-1788299450/dp/1788299450/">book of the</a> respected Dinesh Rajput on design patterns in Spring 5, where one of the chapters is also devoted to dependency injection. <br><br>  We have long been looking for interesting material that will remind you of the strengths of the DI paradigm and clarify our interest in it - and here it is.  True, the author chose to give examples in the Go language.  We hope this does not hurt you to follow the course of his thoughts and help to understand the general principles of inversion of control and work with interfaces, if this topic is close to you. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The emotional color of the original is slightly calmed down, the number of exclamation marks in translation is reduced.  Enjoy reading! <br><a name="habracut"></a><br>  The use of <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D1%2584%25D0%25B5%25D0%25B9%25D1%2581">interfaces</a> is a clear technique that allows you to create easy-to-test and easily extensible code.  I have repeatedly convinced myself that this is the most powerful design tool of all existing architectures. <br><br>  The purpose of this article is to explain what interfaces are, how they are used and how they provide extensibility and testability of the code.  Finally, the article should show how interfaces can help optimize software delivery management and simplify planning! <br><br>  <b>Interfaces</b> <br><br>  The interface describes the contract.  Depending on the language or framework, the use of interfaces may be dictated explicitly or implicitly.  So, in the Go language, <a href="https://play.golang.org/p/JYOGOe2va8h">interfaces are dictated explicitly</a> .  If you try to use an entity as an interface, but it does not fully comply with the rules of this interface, then a compile-time error will occur.  For example, by running the above example, we get the following error: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Interfaces are a tool to help detach a caller from a callee; this is done using a contract. <br><br>  Let's elaborate this problem on the example of the program for automatic exchange trading.  The trader program will be called with the set purchase price and ticker symbol.  Then the program will go to the exchange to find out the current quotation of this ticker.  Further, if the purchase price for this ticker does not exceed the specified one, the program will make a purchase. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  In a simplified way, the architecture of this program can be represented like this.  From the above example, it is clear that the operation of obtaining the actual price depends on the HTTP protocol, through which the program contacts the exchange service. <br><br>  <code>Action</code> state is also directly dependent on HTTP.  Thus, both states must fully understand how to use HTTP to retrieve stock data and / or conduct transactions. <br><br>  Here is what the implementation might look like: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Here the caller ( <code>analyze</code> ) has a direct hard dependency on HTTP.  She needs to know how HTTP requests are formulated.  How is their parsing.  How to handle retries, timeouts, authentication, etc.  She has a close <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">grip</a> on <code>http</code> .  <b>Every time we call analyze, we must also call the <code>http</code> library</b> . <br><br>  How can the interface help us here?  In the contract provided by the interface, you can describe the <b>behavior</b> , and not the specific <b>implementation</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  The above defines the concept of <code>StockExchange</code> .  It says here that <code>StockExchange</code> supports calling a single function <code>CurrentPrice</code> .  These three lines seem to me the most powerful architectural technique of all.  They help us to control application dependencies much more confidently.  Provide testing.  Provide extensibility. <br><br>  <b>Dependency injection</b> <br><br>  To fully understand the value of interfaces, you need to master the technique called "dependency injection". <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Dependency injection</a> means that the caller provides something the callee needs.  This usually looks like this: the caller configures the object and then passes it to the callee.  Then the called party abstracts from the configuration and implementation.  In this case, there is a known mediation.  Consider a request to the HTTP Rest service.  To implement the client, we will need to use an HTTP library that can formulate, send, and receive HTTP requests. <br><br>  If we placed the HTTP request behind the interface, then the caller could be detached, and it would be ‚Äúnot aware‚Äù that the HTTP request did indeed take place. <br><br>  The caller should only make a generic function call.  This may be a local call, remote call, HTTP call, RPC call, etc.  The caller is not aware of what is happening, and usually this suits her perfectly, as long as she gets the expected results.  The following shows what dependency injection might look like in our <code>analyze</code> method. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  I never cease to be surprised at what is happening here.  We completely turned on our dependency tree and became more in control of the whole program.  Moreover, even visually the whole implementation has become cleaner and clearer.  We clearly see that the analysis method should choose the current price, check whether this price is right for us, and if so, make a deal. <br><br>  Most importantly, in this case, we detach the caller from the callee.  Since the caller and the entire implementation are separated from the callee using the interface, you can extend the interface by creating many different implementations of it.  Interfaces allow you to create many different specific implementations, without the need to change the code of the called party! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  The state of "get current price" in this program depends only on the <code>StockExchange</code> interface.  This implementation <b>is</b> not aware of how to communicate with the exchange service, how prices are stored or how requests are made.  Real blissful ignorance.  And bilateral.  <code>HTTPStockExchange</code> implementations <code>HTTPStockExchange</code> also not aware of the analysis.  The context in which the analysis will be performed when it is executed - since calls occur indirectly. <br><br>  Since program fragments (those that depend on interfaces) do not need to be changed when changing / adding / deleting specific implementations, <b>such a design turns out to be durable</b> .  Suppose we find that the <code>StockService</code> very often unavailable. <br><br>  How does the above example differ from a function call?  When applying a function call, the implementation will also become cleaner.  The difference is that when calling a function, we still have to resort to HTTP.  The <code>analyze</code> method will simply delegate the task of the function that is supposed to call <code>http</code> , and will not call <code>http</code> itself directly.  The whole power of this technique lies in the ‚Äúinjection‚Äù, that is, that the caller provides the interface of the callee.  This is exactly how dependence inversion happens, where get prices depend only on the interface, and not on the implementation. <br><br>  <b>Multiple out-of-box implementations</b> <br><br>  At this stage, we have an <code>analyze</code> function and a <code>StockExchange</code> interface, but we can‚Äôt actually do something useful.  Just announced our program.  At the moment, it is impossible to call it, since we still do not have any specific implementation that would meet the requirements of our interface. <br><br>  The main focus of the following diagram is on the state of ‚Äúget current price‚Äù and its dependence on the <code>StockExchange</code> interface.  The following shows how two completely different implementations coexist, and get current price ‚Äúnot in the know‚Äù of this.  In addition, both implementations are not related to each other, each of them depends only on the <code>StockExchange</code> interface. <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Production <br><br>  The original HTTP implementation already exists in the initial implementation of <code>analyze</code> ;  we can only extract it and encapsulate it for a specific implementation of the interface. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  The code that we previously tied to the analyze function is now autonomous and satisfies the <code>StockExchange</code> interface, that is, we can now pass it to <code>analyze</code> .  As you remember from the above schemes, analyze is no longer dependent on HTTP.  When using the interface, <code>analyze</code> "does not represent" what happens behind the scenes.  He only knows that he is guaranteed to be given an object with which he can call <code>CurrentPrice</code> . <br><br>  Also here we use the typical advantages of encapsulation.  Before, when http-requests were tied to analyze, the only way to communicate with the exchange via http was indirect - through the <code>analyze</code> method.  Yes, we could encapsulate these calls in a function and perform the function independently, but the interfaces force us to detach the caller from the callee.  Now we can test <code>HTTPStockExchange</code> regardless of the caller.  This drastically affects the field of application of our tests and how we understand the failures of tests and react to them. <br><br>  <b>Testing</b> <br><br>  In the existing code, we have the <code>HTTPStockService</code> structure, which allows us to separately make sure that it can communicate with the exchange service and parse the responses received from it.  But now let's make sure that analyze can correctly process and respond from the <code>StockExchange</code> interface, and that this operation is reliable and reproducible. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  We WOULD LIKE to use the HTTP implementation, but it would have a lot of flaws.  Making network calls with unit testing could be slow, especially with external services.  Due to delays and unstable network connections, tests could be unreliable.  In addition, if we needed tests with the statement that we can complete the transaction, and tests with the statement that we can filter out such cases in which the transaction should NOT be concluded, it would be difficult to find real production data that reliably satisfy these two conditions.  One could choose <code>maxTradePrice</code> , artificially simulating in this way each of the conditions, for example, with <code>maxTradePrice := -100</code> transaction should not be made, and <code>maxTradePrice := 10000000</code> should obviously be completed with a transaction. <br><br>  But what happens if we are allocated a certain quota on the exchange service?  Or if we have to pay for access?  Will we really (and should) pay or spend our quota when it comes to just unit tests?  Ideally, tests should be run as often as possible, so they should be fast, cheap and reliable.  I think from this paragraph it is clear why it is irrational to use the version with pure HTTP from the point of view of testing! <br><br>  <b>There is a more optimal way, and it is associated with the use of interfaces!</b> <br><br>  Having an interface, you can neatly build a <code>StockExchange</code> implementation that allows us to perform an <code>analyze</code> quickly, safely, and securely. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Above, the exchange service stub is used, thanks to which the branch of interest in us is <code>analyze</code> .  Then, statements are made in each of the tests to make sure that analyze does the right thing.  Although this is a test program, my experience suggests that components / architecture, where interfaces are used in approximately the same way, are tested for durability and in the combat code in exactly this way !!!  Thanks to the interfaces, we can use memory-controlled <code>StockExchange</code> , which provides reliable, easily configurable, easy-to-understand, reproducible, lightning-fast tests !!! <br><br>  <b>Detachment ‚Äî Caller Configuration</b> <br><br>  Now, having discussed how to use interfaces to detach the caller from the callee, and how to do multiple implementations, we still haven't touched on a critical aspect.  How to configure and provide a specific implementation at a specific time?  You can directly call the analyze function, but what to do in production configuration? <br><br>  This is where dependency injection comes in handy. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Just like in our test case, the specific concrete implementation of StockExchange that will be used with <code>analyze</code> is configured by the caller outside analyze.  It is then passed (injected) into <code>analyze</code> .  This ensures that analyze ANYTHING is not aware of how <code>HTTPStockExchange</code> configured.  Perhaps, we would like to provide the http-domain that we are going to use in the form of a command line flag, and then the analyze will not have to change.  Or what to do if we would need to provide this or that authentication or token to access the <code>HTTPStockExchange</code> , which will be retrieved from the environment?  Again, analyze should not change. <br><br>  The configuration occurs at a level beyond <code>analyze</code> , thereby completely freeing up the analysis from having to configure its own dependencies.  This achieves a strict separation of duties. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>Postponing decisions</b> <br><br>  Perhaps the above examples are quite enough, but the interfaces and dependency injection still have many other advantages.  Interfaces allow you to postpone decisions on specific implementations.  Although decisions require us to decide what behavior we will support, they still allow us to make decisions about specific implementations later.  Suppose we knew that we wanted to make automated transactions, but we were not sure yet which quotes provider we would use.  A similar class of solutions is constantly dealt with when working with data warehouses.  What should our program use: mysql, postgres, redis, file system, cassandra?  Ultimately, all of this is implementation details, and the interfaces allow us to postpone final decisions on these issues.  They allow us to develop the business logic of our programs, and to go over to specific technological solutions at the last moment! <br><br>  While this technique in itself leaves a lot of possibilities, something magical happens at the project planning level.  Imagine what happens if we add another dependency to the exchange interface. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Here we will re-arrange our architecture in the form of a directed acyclic graph, so that as soon as we agree on the details of the exchange interface, we will be able to COMPETITIVELY continue to work with the pipeline, using <code>HTTPStockExchange</code> .  We created a situation in which the addition of a new person to a project helps us move faster.  Having corrected our architecture in this way, we can better see where, when, and for how long we can use additional people on the project to speed up the delivery of the entire project.  In addition, since the communication between our interfaces is weak, it is usually easy to get involved in work, starting with implementation interfaces.  You can develop, test and test <code>HTTPStockExchange</code> completely independently of our program! <br><br>  An analysis of architectural dependencies and planning according to these dependencies can radically speed up projects.  Using this particular technique, I was able to very quickly complete projects that were allotted for several months. <br><br>  <b>Reserve for the future</b> <br><br>  Now it should be clearer how the interfaces and dependency injection ensure the durability of the designed program.  Suppose we change our supplier of quotes, or start streaming quotas and saving them in real time;  there are plenty of other possibilities.  The analyze method in its current form will support any implementation suitable for combining with the <code>StockExchange</code> interface. <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  Thus, in many cases, you can do without changes.  Not in all, but in those predictable cases that we may encounter.  We are not only insured against the need to change the <code>analyze</code> code and recheck its key functionality, but we can easily offer new implementations or switch between suppliers.  We can also smoothly expand or update the concrete implementations that we already have without having to change or recheck the <code>analyze</code> ! <br><br>  I hope the examples above convincingly demonstrate how weakening the connection between entities in a program through the use of interfaces completely reorients dependencies and separates the caller from the callee.  Due to this detachment, the program does not depend on the specific implementation, but it strongly depends on the specific <b>behavior</b> .  This behavior can be provided by a wide variety of implementations.  This most important design principle is also called <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">duck typing</a> . <br><br>  The concept of interfaces and dependence on behavior, and not on the implementation is so powerful that I regard interfaces as a language primitive - yes, this is quite radical.  I hope that the examples discussed above turned out to be quite convincing, and you will agree that interfaces and dependency injection should be used from the very beginning of the project.  In almost all the projects I have worked on, not one, but at least two implementations were required: for production and for testing. </div><p>Source: <a href="https://habr.com/ru/post/428075/">https://habr.com/ru/post/428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428065/index.html">Less does not mean worse: skyrmions and domain walls in ferr-magnets</a></li>
<li><a href="../428067/index.html">AntiFuzzing: Security through obscurity !?</a></li>
<li><a href="../428069/index.html">Optimize load balancing in Veeam Backup & Replication infrastructure</a></li>
<li><a href="../428071/index.html">Sberbank lost the address book of 421,000 employees of the bank and its subsidiaries</a></li>
<li><a href="../428073/index.html">Rust 1.30 release</a></li>
<li><a href="../428077/index.html">React.js: an Intuitive Beginner Guide</a></li>
<li><a href="../428079/index.html">Application of SOLID principles in the development of React-applications</a></li>
<li><a href="../428081/index.html">Using RxJS in React Development to Manage Application State</a></li>
<li><a href="../428083/index.html">Web Analytics Influencing Matrix - Avinash Kosick's Strategic System</a></li>
<li><a href="../428085/index.html">Front-end strikes back: HolyJS 2018 Piter's top-10 (?) Reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>