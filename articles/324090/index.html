<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for the way in tower defense games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Approx. Per.: In the original article there are interactive demos that I duplicated using video. For greater clarity, I recommend to study the exampl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for the way in tower defense games</h1><div class="post__text post__text-html js-mediator-article">  <i>[Approx.</i>  <i>Per.: In the <a href="http://www.redblobgames.com/pathfinding/tower-defense/">original article</a> there are interactive demos that I duplicated using video.</i>  <i>For greater clarity, I recommend to study the examples in the original.]</i> <br><br>  In the games of the Tower Defense (TD) genre, many enemies strive to get to one point.  In many TD games, there is a predetermined path or several paths.  In some, including the classic <a href="http://armorgames.com/play/1128/desktop-tower-defense-15">Desktop Tower Defense,</a> you can place towers in arbitrary locations, and they become obstacles that affect the paths of enemies.  <strong>Launch the demo</strong> and <strong>click on the map</strong> to build or remove walls: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-Rqfq-jceBw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  How to implement it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To find the shortest path between two points, search algorithms on graphs are often used, for example, search A *.  You can use it for each enemy to find the path to the goal.  There are many different search algorithms for graphs that can be used in games of this genre.  Here are classic examples: <br><br><ol><li>  <strong>One starting point and one ending point</strong> : <ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25BF%25D0%25BE_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B2%25D0%25BE%25D0%25BC%25D1%2583_%25D0%25BD%25D0%25B0%25D0%25B8%25D0%25BB%25D1%2583%25D1%2587%25D1%2588%25D0%25B5%25D0%25BC%25D1%2583_%25D1%2581%25D0%25BE%25D0%25B2%25D0%25BF%25D0%25B0%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258E">Search for the first best match</a> </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_A*">A *</a> - widely used in games </li></ul></li><li>  <strong>One starting point and all end points</strong> or <strong>all starting points, one end point</strong> : <ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2580%25D0%25B8%25D0%25BD%25D1%2583">Search wide</a> - ribs without weights </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Dijkstra's Algorithm</a> - Adds Weight to Ribs </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0_%25E2%2580%2594_%25D0%25A4%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B0">Bellman-Ford algorithm</a> - has support for negative weights </li></ul></li><li>  <strong>All start and end points</strong> : <ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25A4%25D0%25BB%25D0%25BE%25D0%25B9%25D0%25B4%25D0%25B0_%25E2%2580%2594_%25D0%25A3%25D0%25BE%25D1%2580%25D1%2588%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25B0">Floyd-Warshall Algorithm</a> </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B6%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BE%25D0%25BD%25D0%25B0">Johnson's algorithm</a> </li></ul></li></ol><br>  In games like Desktop Tower Defense, there are many enemy positions (starting points) and one end point for all of them.  Therefore, they are in the category of <strong>all starting and one end points</strong> .  Instead of performing A * for each enemy, you can run the algorithm once, and it will calculate the path for all enemies.  Moreover, it will calculate the shortest path from any place, so when enemies bypass each other or new enemies are created their paths will already be calculated. <br><br>  Let's <strong>look at a wider search</strong> algorithm, sometimes called a fill (FIFO variation).  Although the <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">graph</a> search works for any <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">graph with nodes and edges</a> , in my examples I use a grid of squares.  Grids are a special case of graphs.  <a href="http://www.redblobgames.com/pathfinding/grids/graphs.html">Each cell of the grid is a node of the graph, and the boundaries between the cells of the grid are the edges of the graph</a> .  I am looking at graphs without grids in <a href="http://www.redblobgames.com/pathfinding/grids/algorithms.html">another article</a> . <br><br>  The search in width starts from one node and goes through all the neighboring ones in sequence.  The key concept here is the ‚Äúfrontier‚Äù - the boundary between the studied and unexplored areas.  The boundary extends outward from the source node until it examines the entire graph. <br><br>  The <strong>frontier</strong> queue is the boundary: a list / array of nodes of the graph (grid cells) that need to be analyzed.  At the beginning it contains only one element, the <strong>start</strong> node.  The <strong>visited</strong> flag of each node allows you to track whether we checked it.  At the beginning, for every node except <b>start,</b> it is False.  <strong>Drag the slider</strong> to observe the expansion of the border: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/M-6OsOqvf0o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  How does the algorithm work?  At each step, one element from the <b>frontier</b> is taken and called <strong>current</strong> .  It then searches each of its <b>current</b> neighbors, called <strong>next</strong> .  If they have not been visited ( <b>visited</b> ) before, they are added to the <b>frontier</b> queue.  Here is a sample Python code: <br><br><pre><code class="python hljs">frontier = Queue() frontier.put(start) visited = {} visited[start] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: frontier.put(next) visited[next] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  After reviewing the code, try <strong>step by step to study the animation above</strong> .  Notice the <b>frontier</b> queue, the <b>current</b> node, and the many nodes <b>next</b> .  At each stage, the border element becomes the current node, neighbors are marked, and all unvisited neighbors are added to the border.  Some neighbors have already been visited, so they are not added to the border. <br><br>  This is a fairly simple algorithm, and it is useful for many applications, <a href="http://www.roguebasin.com/index.php%3Ftitle%3DThe_Incredible_Power_of_Dijkstra_Maps">including artificial intelligence</a> .  I use it in three main ways: <br><br><ol><li>  <strong>Mark</strong> all the nodes that can be reached.  This is useful if the card is not fully connected, and you want to know which points you can reach.  This is what we did above using the <strong>visited</strong> field. </li><li>  I find <strong>paths</strong> from one node to all the others, or from all nodes to one.  This is the method I used for the animated demo at the beginning of the article. </li><li>  I measure the <strong>distance</strong> from one node to all the others.  This is useful to know what is within the walking distance of the monster. </li></ol><br>  If you generate paths, then you need to know in which direction to move from each node.  When visiting a neighbor, you need to remember where you came from.  Let's rename the <b>visited</b> table to <b>came_from</b> and use it to store the previous location: <br><br><pre> <code class="python hljs">frontier = Queue() frontier.put(start) came_from = {} came_from[start] = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> came_from: frontier.put(next) came_from[next] = current</code> </pre> <br>  Let's see what it looks like: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8jVuzZHzvvo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  If you need distances, you can start with a counter whose value is 0 at the start node and increase it each time you visit a neighbor.  Let's rename the <b>visited</b> table to <b>distance</b> and use it to store the counter: <br><br><pre> <code class="python hljs">frontier = Queue() frontier.put(start) distance = {} distance[start] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.neighbors(current): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> distance: frontier.put(next) distance[next] = <span class="hljs-number"><span class="hljs-number">1</span></span> + distance[current]</code> </pre> <br>  Let's see what we did: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Iz74q9CWd8Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  You can leave both variables if you need to calculate both paths and distances. <br><br>  So it was a search wide.  In the games of the Tower Defense genre, I used it to find paths from all points to the desired point instead of consistently using A * to search for the path of each enemy separately.  I used it to search for all points within the walking distance of the monster.  I also used it for procedural map generation.  In Minecraft, <a href="http://tomcc.github.io/2014/08/31/visibility-1.html">it is used for clipping the scope</a> .  This algorithm is worth knowing. <br><br>  Next steps: <br><br><ul><li>  I have <a href="http://www.redblobgames.com/pathfinding/a-star/implementation.html">implementation notes</a> with Python and C ++ code. </li><li>  If you need to limit the paths <em>from</em> one point, and not <em>to</em> one point, then turn the <code>came_from</code> pointers as you <code>came_from</code> along the paths. </li><li>  If you need paths to one of <em>several</em> points, and not to one point, you can add edges to the graphs from each end point to an additional end node.  The additional node will not be visible on the grid, but in the graph it will represent the end point. </li><li>  Early exit: if you are looking for a path to / from one point, you can interrupt the search immediately after this point is found.  I explain this in an <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">article on A *</a> . </li><li>  Ribs with weights: if you need to use different cost of passing points, then the search in width turns into Dijkstra's algorithm.  I describe this in an <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">article on A *</a> . </li><li>  Heuristic approach: if you add a way to direct the search towards the target, then the <em>wide</em> search turns into a search for the first <b>best</b> match.  Read more about this in the <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">article about A *</a> . </li><li>  If you start with a wide search and <strong>add an early exit, edges with weights and a heuristic approach, you get A *</strong> .  As you might guess, I describe this algorithm in an <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">article on A *</a> . </li></ul><br><h2>  Implementation </h2><br><h3>  Internal state </h3><br>  This article uses the <i>external</i> state of the visited / came_from / distance sets and hash tables.  You can also use the <i>internal</i> state in which data is stored within the data structure of the nodes of the graph.  Why use external, not internal data?  Although internal data is slightly faster (the implementation does not use a hash table), external ones are ‚Äúcleaner‚Äù because they do not change the data structure of the graph in the search.  In addition, they support multiple simultaneous search operations, either multi-threaded, or implemented through cororutine.  Here is an example of a node with the internal flag of the <code>visited</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name)</span></span></span><span class="hljs-function">:</span></span> self.visited = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> self.name = name self._neighbors = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._neighbors</code> </pre> <br>  Here is an example graph: <br><br><pre> <code class="python hljs">A = Node(<span class="hljs-string"><span class="hljs-string">"A"</span></span>) B = Node(<span class="hljs-string"><span class="hljs-string">"B"</span></span>) C = Node(<span class="hljs-string"><span class="hljs-string">"C"</span></span>) D = Node(<span class="hljs-string"><span class="hljs-string">"D"</span></span>) E = Node(<span class="hljs-string"><span class="hljs-string">"E"</span></span>) A._neighbors = [B] B._neighbors = [A, C] C._neighbors = [D] D._neighbors = [E] E._neighbors = [] start = A</code> </pre> <br>  If the internal state is used, then to re-execute the algorithm, the <code>visited</code> flag must be set to False again.  We can do this <i>before</i> executing the algorithm: <br><br><pre> <code class="python hljs">ALL_NODES = [A, B, C, D, E] frontier = Queue() frontier.put(start) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ALL_NODES: node.visited = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> start.visited = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() callback(current) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> current.neighbors(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> next.visited: next.visited = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> frontier.put(next)</code> </pre> <br>  <a href="http://www.redblobgames.com/pathfinding/tower-defense/sample-internal-a.py">Download the sample program</a> . <br><br>  Or we can set the value <i>after the</i> execution of the algorithm, keeping a list of all visited nodes: <br><br><pre> <code class="python hljs">frontier = Queue() frontier.put(start) start.visited = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> visited_nodes = [start] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> frontier.empty(): current = frontier.get() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> next <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> current.neighbors(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> next.visited: next.visited = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> visited_nodes.append(next) frontier.put(next) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited_nodes: node.visited = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  <a href="http://www.redblobgames.com/pathfinding/tower-defense/sample-internal-b.py">Download the sample program</a> . <br><br>  How to choose one or another approach?  In fact, this is not very important, because we visit all the nodes.  If all nodes are visited, the first approach is slightly faster.  However, if you use the <i>early exit</i> , then all nodes are not visited, and then the second approach will be much faster.  The first method each time passes through <i>all</i> nodes.  The second method passes only through the nodes that have been visited. <br><br><h3>  Node identifiers </h3><br>  (Note: in most cases, this optimization is not required.) For the hash table approach to work, the nodes must be hashed.  Or you can give each node an integer identifier.  After that, you can use a bitmap to store the <code>visited</code> and a regular <code>int</code> array to store the <code>distance</code> and <code>came_from</code> . <br><br>  If you are writing code in C or C ++, you can leave the <code>distance</code> and <code>came_from</code> uninitialized (potentially this is a great advantage!).  You only need to initialize the bitmap, compressing 64 identifiers into one <code>(long) int</code> .  The value in the <code>distance</code> or <code>came_from</code> initialized only if the bit is set.  You can either put distance / came_from arrays on the stack, if it has enough space, or use statically allocated arrays that are not initialized again after each search.  Carefully weigh the costs of initializing the visited bitmap and the costs of using a hash table.  If the part of the visited nodes is small during each search, it may be better to use a hash table. </div><p>Source: <a href="https://habr.com/ru/post/324090/">https://habr.com/ru/post/324090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324078/index.html">Report from Data Fest‚Å¥ February 11-12</a></li>
<li><a href="../324080/index.html">Atomic payments for parking fees in Lamoda</a></li>
<li><a href="../324082/index.html">Data Science Weekend. Speaker presentations</a></li>
<li><a href="../324086/index.html">Enterprise-class cloud storage based on NGINX Plus and Minio</a></li>
<li><a href="../324088/index.html">Create the perfect search string</a></li>
<li><a href="../324092/index.html">How dangerous shortened links and how to protect against it</a></li>
<li><a href="../324098/index.html">Common Bird Census, or bioinformatics in ornithology. Project in good hands</a></li>
<li><a href="../324100/index.html">Welcome to the new Hardaton</a></li>
<li><a href="../324104/index.html">DIY in telephony: simple API-based constructors</a></li>
<li><a href="../324106/index.html">How flexible are our knowledge of Rx operators?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>