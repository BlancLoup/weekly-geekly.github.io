<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of the process of deployment in the project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Denis Yakovlev ( 2GIS ) 
 My name is Denis, I work at 2GIS, for about a year and a half I have been working on continuous delivery for web-department ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of the process of deployment in the project</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/e1d/2e9/c2ae1d2e9c1c9c6296c85895b3973495.jpg"><br><br><h2>  Denis Yakovlev ( <a href="https://habrahabr.ru/company/2gis/">2GIS</a> ) </h2><br>  My name is Denis, I work at 2GIS, for about a year and a half I have been working on continuous delivery for web-department projects.  Prior to that, he worked at Parallels and there he went from being an engineer to a team lead. <br><br>  About deploy.  If you and I are not releasing a boxed product, but writing some service that works somewhere, as many call it in the wild, on servers where users go, then it‚Äôs not enough for us to develop this service and test it; it is somehow enclosed in this wild nature, i.e.  deliver the code there with everything necessary for its work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What does it consist of?  We need to deliver, first of all, the code - something we have been working on for a considerable amount of time, testing and so on. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/d5d/8ad/33cd5d8ad8abafc8ea8f68ba70ec0206.png"><br><br>  We can do it in many ways, generally accessible and not so much, we can flood it somehow, we can connect our servers to the version control system and just get out of it. <br><br>  Next, the data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/773/b65/faf/773b65faf742ef0863650ff223550324.png"><br><br>  If we have a database, i.e.  we use a database in our service, we periodically have a need to do something with this data.  We need to either change the database structure or change the data itself, i.e.  if we constantly write some new functionality, we develop, inevitably this happens with us.  This is mainly done through migration.  Probably everyone already knows this mechanism.  If we use some generally accepted framework in development, not written by us, but which exists, everyone knows it, there are built-in migrations, i.e.  we do all the usual commands.  For example, yii migrate, django-admin migrate. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4be/35b/892/4be35b892f9faeccf499ae34a847f030.png"><br><br>  Few services require configuration.  We added code, the data was updated, we had some changes, we have to configure.  We have a config file, there are some values ‚Äã‚Äãthere, we change them, and in the process of life, we also add new values ‚Äã‚Äãto these config files, or old ones are deprived, they are dropped.  After all of this has changed, we need to either restart any services or leave them as they are. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67d/764/298/67d764298d0150009bc58d8c3a842ac2.png"><br><br>  If we have not done without using third-party software, we need to take care that we need to somehow put this software on our servers, configure it in a certain way, which we need, and upgrade it in a timely manner.  Or do not upgrade, if suddenly in the new version of the software any bug came out so that everything would not have happened. <br><br>  What are the decisions "head on"? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bf/e93/41f/8bfe9341f1a3918a766eda1a8b097781.png"><br><br>  We have one servachok, we go and do it all with pens, because all the steps are known, everything is known how to do.  And we have, let's say, the development team and the operating team - some admin is sitting.  The development team writes documentation that now such a release and for its successful deployment you need to do this, this and that.  The admin looks at this documentation, goes via SSH to the server and it handles it.  So he went once, went twice, then he got tired of it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e09/5ad/abe/e095adabe9b0769dce2b73e515d5b3dc.png"><br><br>  He naturally takes what is generally available and at hand.  He takes Bash, Perl and all that automates, because why do it all with your hands, when you can automate it all and just run Bash. <br><br>  Pros: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4d/7fe/90f/e4d7fe90f254422fae73133bd74a252a.png"><br><br>  It's all simple, well, fast, we work, the code is divisible, we do not notice anything, but this is good only until a certain time, for simple projects.  We have, let's say, one servachok, there is a database on it, our code lies on it - this is quite a manager by one person, and he can cope with it completely. <br><br>  Minuses: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/3cc/e58/a423cce582be9fe8c9615d0c8d6e4f4d.png"><br><br>  But we want to develop, we develop.  Our service becomes complicated, we have new services, more users come, we no longer do with one server, we already have new components, i.e.  we no longer have one server with a code, but we already have a large combat circuit consisting of several servers, components, and so on.  And we have in connection with this increasing complexity, i.e.  with our development, there are problems that were not there before.  We are increasing the amount of documentation, i.e.  information on how a specially trained person to release.  Even if this person has long prepared scripts that, under certain conditions, performed their work well, the complexity of these scripts also increases, their number grows, now you need to upgrade more than one server, but you need to upgrade the database, upgrade the code, something else is needed do.  The difficulty increases.  Scripts - this is also the software in which there may be bugs, it also starts to bring a certain headache. <br><br>  Since we started all this very quickly, until we experienced any special problems, we have some amount of manual labor.  At first it is not very noticeable, and then it grows like a snowball, and manual labor is an additional source of human error.  Someone wrote something wrong and wrong there, or wrote it there, but not so, the second one copied incorrectly, and as a result we get a situation where there are a lot of errors and they all arise, and it‚Äôs not clear when they will end and from where come from.  As a result, we have this specially trained person who was responsible for the releases, all he does is release.  Those.  he has no time for any of his other tasks, no time for even eating.  He rolled out one release while he was rolling out, came the second release, during this release there were some errors, then another patch came for this release.  In general, this big, such smut, nervousness increases, and business comes to us and says: ‚ÄúWhat can't you deliver to customers?  This is simply and quickly, and here we still have a car of features going on, let's do something about it! ‚Äù <br><br>  For some time, there is such an approach in our industry as Infrastructure as a code, which tells us that we need to approach the description of the configuration of our application just as we approach the development of software.  So Keif Morris said: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b96/451/2ad/b964512ad7ff4eb7acea5211c91dd592.png"><br><br>  This is a little more than simple automation, because automation is what we just take and everything we do with pens, we drive into the script, and it works.  In the ‚ÄúInfrastructure as a code‚Äù approach, we use all practices, tools and approaches.  We take it from the software development of our service and apply to the description of the infrastructure.  Those.  if a new approach has emerged, respectively, tulses will appear over time, i.e.  software. <br><br>  What tools are there? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5af/1ee/01b/5af1ee01b85ad28c32a99fc8a1710bb9.png"><br><br>  There is such a class of products - Configuration Management System, i.e.  CMS (not to be confused with Content management system!).  Typical representatives - Ansible, Chef, SaltStack, Puppet.  They are designed to help us, as developers or companies, in infrastructure management.  And one of the tasks, one of the use cases of using such software is to bring our system into a certain state described by us.  Those.  if we have, we have been allocated an abstract server, there is nothing there or there is some bare axis, then with the help of such tools we bring the server to the state we need. <br><br>  Let's look at some of these tools.  I chose those that are used in our company to explain with examples.  First, Anisble. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a9/182/244/5a91822449a7d4b98d74663b0f881a76.png"><br><br>  This software is quite simple to understand, it is written in Python, modular, it is fairly easy to install and, as we noted for the company, the threshold of entry for using Ansible is quite low.  Those.  if we take a person, we say: here's Ansible for you, figure it out and start using it, by the end of the week he writes cheerfully, he understands it all. <br><br>  What do we need to do after we have installed Ansible? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/419/56d/507/41956d507e563daa4c71afc2268b1373.png"><br><br>  We first need to write, and what do we even have, with what we want to work?  Those.  we create a simple text file, and we write as an example above that we have the [webservers] group, we have two exams - <a href="http://www.example1.com/">www.example1.com</a> and <a href="http://www.example2.com/">www.example2.com</a> , the [dbservers] group, i.e.  db1, db2.  Roughly speaking, this is our battle circuit, and we want to work with it. <br><br>  Further, in Ansible there is such an entity - playbooks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df1/d9b/841/df1d9b84159479aff01392dcefff6408.png"><br><br>  A playbook is a set of instructions, i.e.  those steps that Ansible have to do to bring our servers into the state that we need.  Those.  playbooks consist of hosts (we specify which hosts we want to work with) and tasks ‚Äî we specify the steps Ansible needs to be taken.  And there is a command - we say: "Launch this playbook, get information about hosts from this file." <br><br>  Example playbook: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2a/f27/a4d/f2af27a4ddd947a0b4b635b593a7de31.png"><br><br>  We specify hosts (if anyone remembers - webservers).  This is the group of hosts that we have listed in the Ansible Inventor.  We say that we want to put nginx on the servers that we specified there. <br><br>  Tasks consist of two steps in this case: <br><br><ol><li>  we first declare the name so that we can later figure out what we are doing, i.e.  we write Install nginx - this step is responsible for installing nginx and we write in this case yum - this is the Ansible module, which is responsible for installing via yum.  We say: "yum, put us the latest version of nginx package." </li><li>  The next step is to configure nginx, so we say to the template module: ‚ÄúWe have default.conf file in this playbook, please put it along this path and after you have done it, i.e. .  notify, restart nginx ". </li></ol><br>  We run the ansible-playbook command with this playbook, and after doing this playbook, we have an installed nginx on our webservers group servers, configured as we need. <br><br>  The architecture looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/c26/27c/f49c2627c761d5e87a1440b3d3a1fc89.png"><br><br>  I took it from the Internet, this image can be freely google.  We have Host Inventory, Playbooks, Core Modules - these are modules that are written by the Ansible team itself, which is exactly what yum, apt, and so on;  Custom Modules - this is what is written there community or some other contributors;  Plugins.  Ansible starts, goes to the hosts and performs what it needs.  It is noteworthy that on those hosts with which we work, we do not need additional software, i.e.  how our servers stood-worked for us, so they work.  There should be, in my opinion, only Python, but Python is almost everywhere. <br><br>  With this in brief, let's see, for comparison, Chef. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/229/327/d75/229327d75f0e974cb467e4ce31687ae7.png"><br><br>  Chef is the same software class, but written by another company.  In my opinion, it is a bit more complicated, it may even be much more complicated than Ansible, because we have, if a person starts writing and understands Ansible by the end of the week, and begins to give out some kind of code, and with Chef several weeks to deal with it , how does it work, what chips to produce some kind of result. <br><br>  How do we use terms here? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/180/c79/7b4/180c797b4a7f68d95030b51e557caa99.png"><br><br><ul><li>  Cookbooks are recipes.  If, in the case of Ansible, everything is human-readable, well and understandable, then in the case of Chef cookbooks, this is Ruby here, it will take some time to learn, if not completely, but some basic level of this programming language. <br></li><li>  We also have Roles - ways to group Cookbooks.  Suppose we have a ‚Äúweb server‚Äù role to configure a web server.  We need to put nginx, configure, do something else, pop-up and so on.  We have divided it into several cookbooks, and we are doing a separate role - the ‚Äúweb server‚Äù, in which we say that these cookbooks are included there, and we assign this role to the servers we need.  And then we see that we have so many web servers, and in such ways we bring them to the desired state. <br></li><li>  We have Environment - a description of our environment, i.e.  if we have a development environment, a staging environment, there is a production environment, which differs in some settings, i.e.  we have here an opportunity, in my opinion, to describe in JSON, to declare a list of variables that distinguish our environments, respectively, to assign values ‚Äã‚Äãfor each environment. <br></li></ul><br>  Chef exists in several configurations, i.e.  how to install it. <br><br><ol><li>  Chef server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c65/29a/aab/c6529aaab70e79f6d2c701c7392cfbbf.png"><br><br>  We put a separate server somewhere in our environment, in which all our cookbooks, roles, environments, description nodes and so on are stored. <br><br>  On each node of ours there is a client software - Chef client, which is configured on this server.  And it goes there for the description of this node, i.e.  she comes and <br>  says: ‚ÄúI am such a node, please tell me what I have for roles, for some additional settings, for recipes that I need <br>  to do?  Chef server replies to her: ‚ÄúHere, please follow these recipes with these input parameters,‚Äù and the utility uses it all. <br><br>  If anyone noticed, the Ansible is a little different, i.e.  in the case of the Chef server, we, first, install additional software on our nodes, and we go <br>  on the nodes themselves, or somehow remotely have to call this Chef client.  In Ansible, we say Ansible playbook on our working wheelbarrow, and it goes on its own via SSH <br>  does everything on our servers. <br><br>  But this is one configuration Chef. <br><br></li><li>  Next we have Chef zero - this is a light version of Chef Server, i.e.  without gui, it is in memory, i.e.  we just lifted it up so lightly, loaded all our information there for testing, checked it all out, stopped it, killed Chef zero, and everything was free in us - everything is fine. <br></li><li>  There is also Chef solo - this is the open source version of the Chef client utility, which, unlike the first two cases, does not require connecting to some external server.  We don‚Äôt need a Chef server or Chef zero here, we simply say Chef solo in this case that: ‚ÄúWe have a path that our recipes lie on, please follow from here and there such recipes.‚Äù  In this configuration, we get that all our cookbooks, recipes should be at the right time for us on the same instance where we have Chef solo. <br></li></ol><br>  This is a simple example of what a nginx installation on Chef looks like in recipes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b64/aa6/248/b64aa6248680005cf61115c18b95f153.png"><br><br>  I want to point out that this is a very small part of the functionality of all these tools that I mentioned, i.e.  there are much more possibilities, use cases, components and so on.  These are big complex tools, they solve a wide range of tasks, but now in the framework of this report, we are talking only about one use case - how will we understand. <br><br>  Suppose we looked at something, decided, decided that some tool is suitable for us, and what awaits us besides any technical questions?  We work in a team.  We can say that from today we use, say, Ansible.  Well, what do we get next? <br><br>  We receive new process issues - this is a zone of responsibility, i.e.  I, as a team leader, decide that we now use Ansible, but I have a question, who should write my playbooks? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6b/bcc/c39/c6bbccc394ce8d49bb1335c1efe06f9f.png"><br><br>  Developers?  They come to me and say: "We will not write playbooks, because we do not know the combat configuration."  Well, I go to admins and say: "Now you write playbooks".  They say: ‚ÄúWe will not write playbooks, sorry, we will not, because we do not know the application.‚Äù  This is an example of air to understand.  And we have to somehow resolve this situation, because it turns out that the knowledge for writing playbooks and recipes is spread.  We have a part of knowledge in one team, a part - in another team. <br><br>  I will give an example of how such a thing we decided in our department.  We have a lot of products, services, and they are of varying degrees of complexity.  And one very complex, highly loaded our project is the Web API.  We did this: our admins took Chef, wrote the entire database.  We have 3 data centers for 18 servers, decentralization and more.  And such administrators took over the task, wrote all this configuration, got divided into all data centers, made sure that it all worked.  Then in the process of product life, when those parameters change which the admins do not know about, as I gave an example - i.e.  something changed in our kofig, we started to use other, some other utilities ... This is all that is decided during the product development process.  Admins have come, taught developers how to write playbooks, told what Chef is, what it is eaten with, how to cook, and then after this point the development team itself began to write these playbooks.  When our changes are critical or very complex, risky, the development team takes it, writes it itself and simply gives it to the administrators for a review, and they watch how it will fit into the current infrastructure and leave some comments. <br><br>  Other services are simpler.  They took and saw that Chef is too difficult, redundant and so on for us.  They took Ansible, wrote it themselves, quickly figured it out, wrote everything themselves, came to the admins and said: ‚ÄúLook, is it possible?‚Äù.  They looked and said: "Yes, no, I do not know, maybe." <br><br>  With the area of ‚Äã‚Äãresponsibility the question arises.  Silver bullets, like almost everywhere, no.  It is necessary so rezolvit, probably, in each project, in each service in its own way. <br><br>  And, of course, our workflow is changing.  We have new tasks, tools, and our workflow development is changing. <br><br>  If with writing, everything is clear - we looked at something, studied it, we were given an instance of this Chef server or something else, we took our favorite text editor, somehow got used to it, started writing ... But the next question arises - what we need - it's all testing, because we get exactly the same code as he behaves, we also need to understand.  And if, God forbid, at this moment, the developers deploy their services to themselves on the working wheelbarrow, here everything is bad and sad, and without virtualization you will not get by.  Because I need to raise a wheelbarrow, suddenly I wrote something bad there that everything broke, I need to quickly kill it all, redo it, fix it, redo it, see how it works ... I know, I saw such teams, I saw such companies which still do not use virtualization at all.  Maybe this is normal, permissible, but I personally do not understand how to live without virtualization.  If we deploy on our car and there is no virtualization, then in this moment it is simply necessary. <br><br>  Vagrant is not a testing tool, but it can help us see quickly.  What is this Vagrant?  This is a software for creating a virtual environment.  This is a wrapper over many virtualization providers, like virtual boxing, VM var, and so on.  And a plus - it still has integration with the above configuration systems, i.e.  with Chef, Ansible, with Puppet. <br><br>  To deploy my car, i.  I set myself a Vagrant and I just need to do a vagrant init - this is what I specify, what distribution I need. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd2/202/cf6/cd2202cf66ab4518a70c5d9261cf6cd7.png"><br><br>  In my current directory, a vagrant file appears - the configuration file of my future virtual machine.  And in the same directory I say: ‚Äúvagrant up‚Äù and after a while a virtual machine rises on my host, where I can do what I want, then bang it and something else, i.e.  do with it what I want. <br><br>  Here is a quick example about Chef solo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef5/1b6/969/ef51b6969ebcf0fb2d3ba7af5c2379ea.png"><br><br>  In the Vagrant file, I write that in my Chef Solo provision, my cookbooks are located there, and please add me a recipe for this machine, which is called apache and is responsible for installing apache. <br><br>  Then, when I say ‚Äúvagrant up‚Äù for this machine, it rises, and this recipe, which sets apache, is executed. <br><br>  Vagrant'a itself is not enough for testing.  I saw in the RootConf program there is a separate report on how to test the infrastructure.  They talk about test frameworks, which allow you to test the infrastructure.  I know that there is a test kitchen, which is based on Vagrant, and it allows me to write tests when we bring up a virtual machine, and you point out to him: tie me a system, virtualization ... Then you say: I have a set of tests that look simple enough, we need to check that everything was set up in our country, that the demons were running, the files we need are in a certain place.  Actually, we write tests of this kind, and after raising a virtual machine, it runs them and says ‚ÄúOK‚Äù or ‚Äúnot OK‚Äù. <br><br>  These are all the simplest options, i.e.  infrastructure testing is also a separate big topic.  We have slightly opened the door to this world, but there are still many questions, many techniques and so on. <br><br>  What would you like to recommend, where to start?  The tools are large, a lot of information, I want to take a try.  From myself I can say that the recommendations are as follows - if we have some small simple service, then take what is already known, i.e.  put nginx or postgres and stuff.  Try to start with a little, write a recipe, playbook, perform simple, well-known actions, then you can understand, you need it at this stage, or you are still satisfied with the bash scripts, or you do it with pens.  Understand whether you need this.  And understand that you are more comfortable. <br><br>  I gave a reference here: <br><br><ul><li>  <a href="https://galaxy.ansible.com/">https://galaxy.ansible.com</a> </li><li>  <a href="https://supermarket.chef.io/cookbooks">https://supermarket.chef.io/cookbooks</a> </li><li>  <a href="https://docs.ansible.com/playbooks_best_practices.html">https://docs.ansible.com/playbooks_best_practices.html</a> </li></ul><br>  Each tool has community, bestpractice, repositories with written cookbooks, i.e.  all known software that needs to be installed, configuration, and more.  As for this, all playbooks have already been written, best contracts have been worked out, and we go to these supermarkets or Galaxy and just take what we need - like cubes - and execute, build, so we have a ready infrastructure. <br><br>  Regarding such an important aspect as the cost, we can say that these products are mostly free.  hef started wanting money from the 12th version, so many are still sitting on the 11th version, and Ansible want money for the web-face, I think the Ansible tower is called.  And in other configurations, all this can be taken for free and quickly applied. <br><br><h3>  Contacts </h3><br>  ¬ª <a href="https://habrahabr.ru/company/2gis/">2GIS company blog</a> <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the training conference for developers of high-load systems <a href="http://junior.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad ++ Junior</a> .</font> <font color="gray"><br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> <font color="gray"><br><br></font>  <font color="gray">Well, the main news is that we have begun preparations for the spring festival " <a href="http://ritfest.ru/">Russian Internet Technologies</a> ", which includes eight conferences, including <strong>HighLoad ++ Junior</strong> .</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/319314/">https://habr.com/ru/post/319314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319298/index.html">Draw commits on Github</a></li>
<li><a href="../319300/index.html">Economy of ideas. Composable infrastructure. HPE Synergy</a></li>
<li><a href="../319302/index.html">FPS and let your code wait</a></li>
<li><a href="../319304/index.html">Iframe injection and self xss on more than 20,000 sites alexarank UA / RU</a></li>
<li><a href="../319310/index.html">Hack the future! PHDays again invites authors to a cyberpunk contest</a></li>
<li><a href="../319318/index.html">SCADA: in search of the ideal</a></li>
<li><a href="../319320/index.html">Working with DSL: creating your own analyzer using Python libraries</a></li>
<li><a href="../319322/index.html">How not to do protection against exploits for example Norton Security</a></li>
<li><a href="../319324/index.html">What is common between writing the Lord of the Rings and programming?</a></li>
<li><a href="../319326/index.html">A simple but effective Explorer extension (shell extension) for rendering files</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>