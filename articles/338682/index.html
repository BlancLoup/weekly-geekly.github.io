<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of one Russian RTOS, part 6. Thread synchronization tools</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, when developing real multi-threaded applications, it is impossible to simply write the code of all tasks, connect them to the scheduler...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of one Russian RTOS, part 6. Thread synchronization tools</h1><div class="post__text post__text-html js-mediator-article">  Unfortunately, when developing real multi-threaded applications, it is impossible to simply write the code of all tasks, connect them to the scheduler and simply launch them for execution. <br><br>  Let's start with banality - if there are a lot of tasks, then they will start wasting CPU time on execution in idle cycles.  As already noted in previous publications, all tasks that currently have nothing to do (data from the equipment did not come or for other organizational reasons) should be blocked.  Only those tasks should be set for execution, which now have something to do, since the microcontrollers are always short on processor cycles. <br><br>  Further, tasks may conflict with each other for certain resources (in particular, for equipment).  When considering the types of multitasking, we have already considered typical cases of conflicts over the SPI port (partially solved by switching to cooperative multitasking, but it is not always possible to switch to it). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And the worst case is task dependency.  Often the result of one task is used in another.  From the obvious examples, we can mention the following: it is useless to recalculate the data for the PID temperature controller output, until enough data from the thermal sensor is received and averaged, it makes no sense to change the effect on the engine speed, until we receive information about the current period of its rotation, there is no need to process the character string from the terminal until the terminating character (the end of line character) is received.  And besides the obvious, there are a lot of unobvious cases of dependencies and the races they generate.  Sometimes a novice developer takes more time to fight races than directly to implement the algorithms of the program. <br><br>  In all these cases, synchronization objects come to the aid of the developer.  Let us in the current publication consider what synchronization objects and functions are available in the MAKS RTOS. <a name="habracut"></a><br><br>  For those who have not seen the previous parts, links: <br><br>  <a href="https://habrahabr.ru/post/336308/">Part 1. General information</a> <br>  <a href="https://habrahabr.ru/post/336696/">Part 2. Core MAX MAX</a> <br>  <a href="https://habrahabr.ru/post/336944/">Part 3. The structure of the simplest program</a> <br>  <a href="https://habrahabr.ru/post/337476/">Part 4. Useful theory</a> <br>  <a href="https://habrahabr.ru/post/337974/">Part 5. The first application</a> <br>  Part 6. Thread synchronization tools (this article) <br>  <a href="https://habrahabr.ru/post/339498/">Part 7. Means of data exchange between tasks</a> <br>  <a href="https://habrahabr.ru/post/340032/">Part 8. Work with interruptions</a> <br><br><h2>  Critical section </h2><br>  To warm up, consider the CriticalSection class.  It is used to frame areas where context switching is not allowed. <br><br>  As soon as a class object appears in scope, all interrupts with MAX_SYSCALL_INTERRUPT_PRIORITY or lower are blocked.  Today, this constant is five, which blocks all interrupts from devices and from the system timer, but does not block exceptional situations. <br><br>  When an object goes out of scope, the interrupt level is restored to what it was before the entry.  The latter allows you not to care about the fact that nested critical sections are obtained - only the first one really works.  All, except for external - will perform unnecessary work.  First, to replace the high level of allowed interrupts with him, and when you exit - to restore the original one - all the same initially high.  Exiting the outermost of the nested critical sections will restore the low level.  Of course, nesting is most often obtained when a function is called that also has a critical section. <br><br>  <font color="ff0044"><b>Since the critical section changes the interrupt priorities, that is, it programs the NVIC, it should only be used in code running in privileged mode.</b></font> <br><br>  Consider an example (the area highlighted in pink is protected by a critical section, it is guaranteed that the task will not be taken out of control) <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee497433898447854.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ProfEye::Tune() { ProfData::m_empty_call_overhead = <span class="hljs-number"><span class="hljs-number">0</span></span>; ProfData::m_empty_constr_overhead = <span class="hljs-number"><span class="hljs-number">0</span></span>; ProfData::m_embrace_overhead = <span class="hljs-number"><span class="hljs-number">0</span></span>; CriticalSection _cs_; loop ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, i, <span class="hljs-number"><span class="hljs-number">1000</span></span> ) { PROF_DECL(PE_EMPTY_CALL, empty_call); PROF_START(empty_call); PROF_STOP(empty_call); { PROF_EYE(PE_EMBRACE, _embrace_); { PROF_EYE(PE_EMPTY_CONSTR, _empty_constr_); } } } ProfData::m_empty_call_overhead = prof_data[PE_EMPTY_CALL].TimeAvg(); ProfData::m_empty_constr_overhead = prof_data[PE_EMPTY_CONSTR].TimeAvg(); ProfData::m_embrace_overhead = prof_data[PE_EMBRACE].TimeAvg() + ProfData::ADJUSTMENT - <span class="hljs-number"><span class="hljs-number">2</span></span> * ProfData::m_empty_constr_overhead; }</code> </pre> <br></div></div><br>  Of course, the scope of an object can always be limited to curly braces. <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee497404904187559.png"><br><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ProfEye::ProfEye(PROF_EYE eye, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> run) { m_eye = eye; m_lost = <span class="hljs-number"><span class="hljs-number">0</span></span>; m_run = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( run ) { { CriticalSection _cs_; prof_data[m_eye].Lock(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); m_up_eye = m_cur_eye; m_cur_eye = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } Start(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_up_eye = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br></div></div><br>  What should be included in the critical section?  Well, for example, operations where several variables need to be atomically changed (the example above just does this).  Various lists and other things, where one task reads, and the second writes, may well require atomic access. <br><br>  But there are less obvious things.  Let there be a certain counter, which increases in one task, and decreases in another.  It would seem quite an atomic operation. <br><br>  cnt ++; <br><br>  But it is atomic at the level of high level language.  At the assembly level, it splits into read-modify-write operations <br><br> <code>26: cnt++; <br> 0x08004818 6B60 LDR r0,[r4,#0x34] <br> 0x0800481A 1C40 ADDS r0,r0,#1 <br> 0x0800481C 6360 STR r0,[r4,#0x34] <br></code> <br>  Suppose the value (for accuracy, say 10) has already fallen into the register r0, after which the scheduler will transfer control to another task.  It also considers the value 10 and reduces it, setting 9. Then, when the control returns to the current task, it adds one not to the variable, but to what has already entered the register r0 - to the top ten.  It turns out 11. The value of the counter will be distorted. <br><br>  That's just to protect against such situations, it is quite suitable critical section. <br><br><pre> <code class="cpp hljs">{ CriticalSection cs; cnt++ }</code> </pre><br>  Although, of course, the overhead of working with NVIC should also be kept in mind, since it will not be three, but many more assembly instructions <br><br> <code>27: CriticalSection cs; <br> 0x0800481A 4668 MOV r0,sp <br> 0x0800481C F7FEFCE8 BL.W _ZN4maks15CriticalSectionC2Ev (0x080031F0) <br> 28: cnt++; <br> 0x08004820 6B60 LDR r0,[r4,#0x34] <br> 0x08004822 1C40 ADDS r0,r0,#1 <br> 29: } <br> 0x08004824 6360 STR r0,[r4,#0x34] <br> 0x08004826 4668 MOV r0,sp <br> 0x08004828 F7FEFDA0 BL.W _ZN4maks19InterruptMaskSetterD2Ev (0x0800336C) <br></code> <br>  This is not counting the contents of the system routines ... We give only the first, so that the reader presents its complexity <br><br> <code>0x080031F0 B510 PUSH {r4,lr} <br> 0x080031F2 2150 MOVS r1,#0x50 <br> 0x080031F4 F000F8AE BL.W _ZN4maks19InterruptMaskSetterC2Ej (0x08003354) <br> 0x080031F8 4901 LDR r1,[pc,#4] ; @0x08003200 <br> 0x080031FA 6001 STR r1,[r0,#0x00] <br> 0x080031FC BD10 POP {r4,pc} <br></code> <br>  As you can see, this is not the maximum nesting ... On the other hand, this is still the lesser of the evils.  Just do not get involved in frequent entries and exits of the critical section. <br><br>  The critical section is a very powerful, but potentially dangerous tool, because until it goes out of scope, multitasking is disabled.  Ideally, locking should be done on only a few lines.  The presence of a cycle can significantly increase the delay time, the input to functions ‚Äî and even more so (if the programmer has little idea of ‚Äã‚Äãthe time spent in these functions), and working with certain types of equipment is a very potentially dangerous thing.  Let the programmer decide to assure himself that there is no context switch at the time of transmitting two bytes on the 10 MHz SPI bus.  One bit has a period of 100 ns.  16 bits - 1.6 ¬µs.  This is an acceptable result.  The next task will lose no more than this area (in general, this is comparable with the time of the scheduler).  But if you transmit a string of 20 characters on the UART at a speed of 250 kilobits per second, it will take 20 * 10 * 4 Œºs = 0.8 ms.  That is, start the process closer to the end of the time quantum of the task, it will ‚Äúeat‚Äù almost the entire quantum of the next task. <br><br>  In general, the critical sections mechanism is quite powerful, but the programmer using it is fully responsible for ensuring the system‚Äôs operation in real time. <br><br>  <font color="ff0044"><b>Again, do not put to sleep the task that is in the critical section, using functions that are waiting for other resources.</b></font> <br><br>  Consider the simplest example.  Already known task, changing the state of the port, periodically calling the delay function with blocking: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { GPIOE-&gt;BSRR = (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;nBit); Delay (<span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOE-&gt;BSRR = (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;(nBit+<span class="hljs-number"><span class="hljs-number">16</span></span>)); Delay (<span class="hljs-number"><span class="hljs-number">5</span></span>); } }</code> </pre><br>  It gives a normal meander: <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee52763b015403812.png"><br><br>  Add a critical section <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee4ec350063845077.png"><br><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CriticalSection cs; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { GPIOE-&gt;BSRR = (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;nBit); Delay (<span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOE-&gt;BSRR = (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;(nBit+<span class="hljs-number"><span class="hljs-number">16</span></span>)); Delay (<span class="hljs-number"><span class="hljs-number">5</span></span>); } }</code> </pre><br></div></div><br>  We get a completely different signal <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee57f43c566847331.png"><br><br>  Zoom in - the signal period is completely wrong ... <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee5a94d8961121787.png"><br><br>  In general, the critical section is a powerful tool, but it should be used only if you are aware of your actions (or, at least, controlling your every step). <br><br>  The warm-up somehow was delayed.  The simplest thing spread out on a bunch of sheets.  Well, let's move on to a slightly more complicated logic, but requiring less text, and a thing to do - a binary semaphore. <br><br><h2>  Binary Semaphore </h2><br>  Once upon a time, semaphores were actively used on the railway.  They had two states: raised - the train can move.  Omitted - the train must wait.  Well, and lifted and lowered it the dispatcher.  So here, some task (or tasks) pulls the string (acting as a dispatcher), and some task (or tasks) - waiting for the path to be opened.  At the same time, the pending tasks are blocked, that is, they do not spend time quanta. <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee5b766e515846936.png"><br><br>  Such a semaphore is implemented by the BinarySemaphore class. <br><br>  The class constructor contains a required argument that specifies the initial state of the semaphore. <br><br>  <b>explicit BinarySemaphore (bool is_empty = true)</b> <br><br>  Next we consider only the functions of the binary semaphore (the fact is that it is the heir of a simple semaphore, and we will consider all its functionality below). <br><br>  Tasks that need to go through the semaphore should call the <b>Wait ()</b> function.  The argument of this function is the timeout in milliseconds.  If the task has been unlocked within the specified time, the function will return the value <b>ResultOk</b> .  Accordingly, if the timeout is <b>reached</b> , the result of the function will be equal to <b>ResultTimeout</b> .  When the function must wait "until it stops", the timeout value should be passed to <b>INFINITE_TIMEOUT</b> . <br><br>  If the function is called with a zero timeout value, then it will return control instantly, but by the result ( <b>ResultOk</b> or <b>ResultTimeout</b> ) it will be clear whether the semaphore was open or closed. <br><br>  When called from an interrupt, the task lock is not possible, therefore with any non-zero timeout, the result of the function will be <b>ResultErrorInterruptNotSupported</b> .  However, with zero timeout, the function can also be called from the interrupt. <br><br>  If the function <b>returns the ResultOk</b> result, the semaphore will close automatically. <br><br>  As already noted, several tasks can wait for the semaphore at once.  In this case, the selection of the ‚Äúlucky one‚Äù, which will be skipped first, will be done as follows: Tasks in the waiting list are followed in order of decreasing priority, and with the same priority, in the order of calling the <b>Wait ()</b> function. <br><br>  To open the semaphore, use the <b>Signal ()</b> function.  If the semaphore is already open, it will return the result <b>ResultErrorInvalidState</b> , otherwise <b>ResultOk</b> .  A function cannot be called from an interrupt with a priority higher than MAX_SYSCALL_INTERRUPT_PRIORITY. <br><br><h2>  Semaphore </h2><br>  Frankly, I absolutely do not like this name.  It would be more correct to call this synchronization object ‚ÄúZavhoz‚Äù, but you will not try against the traditions.  Everywhere it is called a semaphore, the RTOS MAX is no exception.  The difference between a simple semaphore (or a supply manager) and a binary one is that it can count (put resources at the warehouse).  There is at least one resource - a task can pass (and the number of resources decreases).  No resources - the task will wait for at least one. <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee5ddbec856202115.png"><br><br>  Such semaphores come in handy when you need to allocate any resources.  For example, I made 4 buffers for outputting data to USB (this bus does not work with bytes, but with arrays of bytes, so it‚Äôs most convenient to prepare the data in buffers).  Accordingly, the work task can determine if there are free buffers.  If there is - fill them.  No - wait for the USB driver to transfer and free at least one.  In general, if not one, but several resources are allocated somewhere, it is most convenient to assign their distribution to the supply manager (or, according to traditional naming, the semaphore). <br><br>  Accordingly, this object is implemented in the Semaphore class.  Consider its difference from the binary semaphore.  First, he has a slightly different constructor. <br><br>  <b>Semaphore (size_t start_count, size_t max_count)</b> <br><br>  The first parameter is how many things are initially put in the box, the second is the dimension of this box.  Sometimes it is useful at the beginning of work to declare a complete lack of resources, and then to add them (calling, as we remember, the <b>Signal ()</b> function).  Sometimes - on the contrary, initially the resources are loaded to the maximum, and then - they are spent.  Other options are possible with incomplete initial loading, but readers will come up with this themselves when this is necessary. <br><br>  The <b>Signal ()</b> function, respectively, increases the resource counter.  If it has reached the maximum, it will return <b>ResultErrorInvalidState</b> .  Once again, we recall that a function cannot be called from interrupts with a priority higher than MAX_SYSCALL_INTERRUPT_PRIORITY. <br><br>  The <b>Wait ()</b> function will skip a task if the number of resources is not equal to zero, while reducing the counter.  And if there are no resources, the task will be blocked until they are returned via the Signal () function.  Once again, we recall that from interrupt this function can be called only with zero timeout. <br><br>  Now consider the functions that did not make sense in the binary case. <br><br>  <b>GetCurrentCount ()</b> will return the current value of the resource counter <br><br>  <b>GetMaxCount ()</b> will return the maximum possible counter value (if the semaphore was created by another task, it may be useful to determine its characteristics) <br><br><h2>  Mutex </h2><br>  The name of this object comes from the words <b>Mut</b> ualy <b>Ex</b> clusive.  That is, with its help the system provides mutually exclusive access to one resource.  While in semaphores, some tasks were awaiting destruction, while others opened a semaphore, then in this case, everyone tries to capture the resource, and the system provides it. <br><br>  Briefly, the essence of the mutex can be explained with the phrase ‚ÄúWhoever first stood up - that and sneakers‚Äù.  There is a protected object - "sneakers".  The husband woke up, asked for them - the system gave them to him for undivided use.  The wife and son requested - they were blocked.  As soon as the husband returned the slippers to the system, the wife received them.  She returned - got a son.  He returned - the object passed to the free state, the next requesting, will receive them again without waiting. <br><br>  In microcontrollers, a wonderful resource that needs to be protected in this way is the port (SPI, I2C, etc.), if several tasks are trying to work through it.  We have already considered that several dissimilar devices can be connected to the same physical channel, for example, in a classic TV: on a single I2C bus there can be a video processor, an audio processor, a teletext processor, a tuner - they can be served by different tasks.  Why waste processor time waiting for the BSY bit to be reset?  Moreover, all the same, collisions are possible.  Consider the work of three tasks, exclusively analyzing the port BSY bit, executing them step by step: <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee5f2b01878688129.png"><br><br>  As you can see, in step 7, two tasks immediately try to control the bus.  If she was protected by a mutex, this would not have happened.  In addition, at conditional step 1 (in fact, this is a mass of steps where task 2 and task 3 are blocked) tasks waste time quanta.  Mutex solves this problem too - all pending tasks are blocked. <br><br>  Sometimes it may happen that the developer is too carried away with mutexes, and the task can capture the mutex several times.  Of course, most likely, this will occur in nested functions.  Function 1 captures the mutex, then control is passed to function 2, from there to function 3, from there to function 4 (written a year ago), which also tries to capture the same mutex.  In order to prevent blocking, in such cases recursive mutexes should be created.  One task will be able to capture them many times.  It is only important to release as many times as he was captured.  In Windows, all mutexes are recursive, but such an approach on weak microcontrollers would lead to unnecessary expenditure of resources, so by default, in the MAX RTOS, mutexes are not recursive. <br><br>  Consider the basic functions of the class Mutex.  First of all - its designer <br><br>  <b>Mutex (boolrecursive = false);</b> <br><br>  The constructor argument specifies whether the type is recursive or not. <br><br>  The <b>lock ()</b> function captures the mutex.  The argument is the timeout value.  As always, you can set special values ‚Äã‚Äã- zero timeout (instant exit without waiting) or <b>INFINITE_TIMEOUT</b> (wait until victory).  If the mutex succeeded in capturing, the result ResultOk will be returned.  When the timeout expires, the result of the ResultTimeout will be returned.  When attempting to capture a non-recursive mutex, the result will be <b>ResultErrorInvalidState</b> .  <font color="ff0044">A mutex cannot be captured in an interrupt.</font>  If you try to do this, the result will be <b>ResultErrorInterruptNotSupported</b> . <br><br>  <b>Unlock ()</b> function - frees mutex.  Accordingly, it should be called at the end of the execution of the protected section. <br><br>  The <b>IsLocked ()</b> function allows you to determine if a mutex is captured or free without capturing it.  With preemptive multitasking, the result may lose relevance even before it is analyzed, but with cooperative multitasking, this function may well be useful. <br><br>  Now it is worth telling about such a thing as inheriting priorities.  Suppose the system has tasks A with normal priority, B with increased priority, and C with high priority.  Suppose that tasks B and C were blocked, and A at that time managed to capture the mutex.  Let's draw it graphically, placing the tasks one above the other (the higher the priority, the higher the task in the figure) <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee61cf71771522189.png"><br><br>  Now task C is unlocked.  Of course, having the highest priority, it began to execute.  And let's say she is also going to capture the same mutex. <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee636d47127351851.png"><br><br>  But the mutex is in the possession of task A!  According to the standard logic, once it is busy, task C is blocked until it is released.  And suddenly the task B was unblocked unexpectedly (even if she waited for some other resource, and he was freed).  Since its priority is higher than that of A, then it will be executed exactly (that is, task B) <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee667f43148476770.png"><br><br>  What we have?  High priority C cannot be executed because it is waiting for the mutex to be released.  And it cannot wait, because its current owner has been superseded by a higher priority task relative to the owner of the mutex, but a lower priority one is a relatively unfairly blocked task. <br><br>  <font color="ff0044">To prevent this, the owner of the mutex at the time of possession is assigned the priority of the highest task of those who now expect it.</font>  <font color="ff0044">Such a mechanism (inheritance of priorities) allows you to bring the moment of release of the mutex.</font> <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee66ad9a869287805.png"><br><br>  This fact is extremely important to remember, because if task A also interacts with any task E, which also has a normal priority, for the duration of the priority inheritance, it will lose this interaction.  Alas, nothing can be done with this (within the framework of the standard RTOS concept), this should be simply taken into account when designing programs. <br><br><h2>  Mutex Guard </h2><br>  Classical algorithmic programming involves one input and one output in any algorithm.  However, the practice is such that the fanatical provision of this principle leads to an unjustified complication of the text and reduced readability.  Let's consider the following pseudocode: <br><br><pre> <code class="cpp hljs">m_mutex.Lock(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (cond) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode1; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode2; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0a</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode3; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x15</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode4; } .... m_mutex.Unlock();</code> </pre><br>  In fact, here, before each exit from a function, you should methodically place mutex.Unlock ().  And there can be many such sections in a large algorithm.  And they can be added.  Sooner or later, the programmer will forget to unlock the mutex somewhere, and the program will ‚Äúhang‚Äù.  And this - despite the fact that mankind did not sleep at night, it invented the PLO in general and the destructors of classes in particular! <br><br>  Mutex-guard is just engaged in the use of destructors.  This class in the interface part has nothing but a constructor.  Copy its description from the Programmer‚Äôs Guide: <br>  explicit MutexGuard (Mutex &amp; mutex, bool only_unlock = false); <br><br>  Arguments: <br><br><ul><li>  mutex - link to mutex; </li><li>  only_unlock ‚Äì if the value is true, no mutex is captured in the constructor.  This implies that the mutex has already been captured by the previously explicit call to the Lock () method. </li></ul><br>  The constructor should be passed mutex.  He will be captured.  And it will be released at the moment when the mutex guard goes out of scope.  Thus, the previous example should be rewritten like this: <br><br><img src="https://habrastorage.org/webt/59/cd/4e/59cd4ee6c7365965230729.png"><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> { MutexGuard (m_mutex); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (cond) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode1; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x02</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode2; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0a</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode3; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x15</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResultCode4; } .... }</code> </pre><br></div></div><br><h2>  Event </h2><br>  Semaphores and mutexes are usually used to eliminate the competition of tasks when using certain resources, but sometimes you just need to block the task until some condition arises to unlock it.  Typical scenario - an interruption has occurred and the handler function signals the high-priority task of deferred processing, that you should wake up and perform some actions.  Events allow you to implement this mechanism. <br><br>  After reading the previous paragraph, it may seem that the event simply duplicates the semaphore.  But it is not.  Let's look at the differences. <br><br>  The first difference: The event affects only those who are waiting for him.  If the event currently has no recipient, it will go nowhere.  If a moment after the occurrence of the event, someone starts to wait for him - he will be blocked.  Unlocking will occur only on the next event.  Who did not have time - he was late.  As we remember, the semaphore, on the contrary, whether someone was waiting for him or not, will open anyway.  And the first one who will pass by the semaphore will be skipped. <br><br>  The second difference is that if several tasks are waiting for the semaphore to open, only one of them will be unlocked.  The rest will be waiting for the next discovery.  The event can be set to the mode when it unlocks everyone who was waiting for its occurrence.  That is, all pending tasks will be transferred from the ‚ÄúBlocked‚Äù state to someone to the ‚ÄúActive‚Äù state, and the luckiest task to the ‚ÄúExecuted‚Äù state. <br><br>  Otherwise, the logic of events resembles the logic of the binary semaphore. <br><br>  Constructor class: <br><br>  <b>Event (bool broadcast = true);</b> <br><br>  The broadcast parameter specifies the rule by which recipients are informed who are waiting for an event to occur.  true‚Äì all tasks waiting for it will be unlocked, false ‚Äì only one task that is first in the queue waiting for this event will be unlocked. <br><br>  The <b>Raise ()</b> function sends an event.  Cannot be called from interrupt, with priority higher than <b>MAX_SYSCALL_INTERRUPT_PRIORITY</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Wait () function is already familiar to us from the same function of the previously considered synchronization objects. </font><font style="vertical-align: inherit;">Similarly, it has a timeout argument. </font><font style="vertical-align: inherit;">Similarly, the timeout can be zero, or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INFINITE_TIMEOUT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This function cannot be called from interrupts.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Examples of working with sync objects </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, it is impossible to make simple and beautiful examples where sync objects are used. All simple will result in a demonstration of examples of function calls. Practically applicable things will take too much space. They will have to be described for a long time, and the reader will lose the thread on the second page, and the twenty-eight others will remain never read by anyone. Therefore, I will refrain from writing such a work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the planned third part, a description of the adaptation of a large program for a CNC machine should appear, leaving examples for it. And for those who crave practice, I can recommend unit tests for the OS. They are located in the directory ... \ maksRTOS \ Source \ Tests \ Unit tests. Here is a list of directories hosted there: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BinarySemaphore</font></font><br></b>  <b>Event</b> <b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MessageQueue </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutex </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MutexGuard </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheduler </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semaphore</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Best practical examples are hard to come up with. </font><font style="vertical-align: inherit;">Enjoyable learning (although it is believed that a rare reader will come to the end of the first quarter of the tests).</font></font></div><p>Source: <a href="https://habr.com/ru/post/338682/">https://habr.com/ru/post/338682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338672/index.html">Profiling project build</a></li>
<li><a href="../338674/index.html">Head, what should I do to get more money</a></li>
<li><a href="../338676/index.html">The final release of 3CX Call Flow Designer and 3CX courses in Belarus</a></li>
<li><a href="../338678/index.html">Moving to the cloud: 5 different stories</a></li>
<li><a href="../338680/index.html">FrontFest ‚ùÑÔ∏è From Siberia with love</a></li>
<li><a href="../338684/index.html">It is a fallacy that the technical director deals exclusively with technical issues.</a></li>
<li><a href="../338686/index.html">Endless capacity node for Kubernetes</a></li>
<li><a href="../338690/index.html">Blackmailing programs: a threat to the past or the future?</a></li>
<li><a href="../338692/index.html">MBLTdev 2017: amazing iOS track</a></li>
<li><a href="../338696/index.html">Trust assurance method in blockchains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>