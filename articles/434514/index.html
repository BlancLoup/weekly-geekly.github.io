<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Secrets" DPAPI or DPAPI for pentesters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The second article on the results of the performance of our team on OFFZONE-2018. This time we will review the report with MainTrack ‚ÄúWindows DPAPI‚Äú S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Secrets" DPAPI or DPAPI for pentesters</h1><div class="post__text post__text-html js-mediator-article">  The second article on the results of the performance of our team on OFFZONE-2018.  This time we will review the report with MainTrack ‚ÄúWindows DPAPI‚Äú Sekretiki ‚Äùor DPAPI for pentesters‚Äù. <br><br>  Attention!  A lot of beeches! <br><br>  When you run RedTeam campaigns, you want to give less reason for the BlueTeam reaction, but there may be a lot of them.  For example, running mimikatz to get user passwords or certificates.  Even if we managed to otmazat it from Kaspersky, BlueTeam has the ability to track using specialized tools such as Sysmon, Microsoft ATA, etc.  At the same time, I would like to get as much information as possible from the compromised user's machine.  In the course of the RedTeam campaigns that were held several times with opposition to the current BlueTeam teams, we came to the conclusion that it is necessary to avoid actions that can serve as indicators of the system being compromised as much as possible.  It is possible to achieve this goal by using legal mechanisms and actions provided by the operating system for the user. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of these legal tools is the DPAPI (Windows Data Protection API) mechanism, which is used by the operating system and various applications to encrypt sensitive user data (primarily passwords, cryptographic keys, etc.) For the end user and his applications, DPAPI looks extremely simple : there are only 2 functions - ‚Äúencrypt data‚Äù and ‚Äúdecrypt data‚Äù.  In this article, I would like to consider how such a mechanism is useful for pentesters when conducting RedTeam campaigns. <br><a name="habracut"></a><br><h3>  What is DPAPI?  Only briefly and in Russian </h3><br>  Since 2000, all Windows operating systems began to use the DPAPI mechanism to keep user data safe. <br><br>  If we skip all the cryptography we considered on the report, we need: master key, user SID, user password hash, and the DPAPI blob itself (DPAPI encrypted data) to decrypt the data encrypted via DPAPI. <br><br>  In general, the process looks like this: <br><br><img src="https://habrastorage.org/webt/n1/ex/ah/n1exahepzml5ykake_tcy_qaj6i.jpeg"><br><br>  Inside our ‚Äúcryptographic hat‚Äù there are many different crypto mechanisms that we will not discuss in this article, so as not to overload the reader.  We only note that the main part of DPAPI is the so-called Masterkey (master key).  To put it simply, the master key is 64 bytes of random data encrypted with prekey, which is generated from the user's password and his SID. <br><img src="https://habrastorage.org/webt/dr/gu/b2/drgub2ccge4pjhkz1czilfleveg.jpeg"><br><br>  Additional parameters also take part in the generation of prekey: the number of iterations (IterN), salt and HMAC, which may vary from case to case.  The values ‚Äã‚Äãof these parameters are stored with the master key in one file. <br><br>  Thus, knowing the user's password, his SID and reading the generation parameters (HMAC, Salt, InterN) from the master key file, we can generate a prekey and decrypt the master key, i.e.  get the same random 64 bytes that we will use to decrypt DPAPI blobs. <br><br><h3>  And if I change my password? </h3><br>  Usually, user passwords change at regular intervals.  What happens if the user has changed the password?  Where did the previous one go?  After all, to decrypt the master key, you need to know the user's password, and to re-encrypt all the user's master keys each time is too expensive.  In this case, with Windows, everything is thought out. <br><br>  There is a special file (CREDHIST) whose task is to store all previous user passwords.  It is also encrypted with the user's current password and saved to the stack.  If the system suddenly failed to decrypt the master key, then it proceeds as follows: using the current password, it decrypts the first entry in the CREDHIST.  The received password tries to decrypt the master key again and so on until the passwords in the chain run out or the master key is decrypted. <br><br><h3>  Some words about domain controller private keys </h3><br>  As you may have guessed, DPAPI is used for all users, including domain users.  In order to be able to reset the password to the user who successfully forgot it after some Friday party, you need a spare key that will be stored in a safe place.  According to Microsoft, such a reliable place is a domain controller. <br><br>  The essence of the mechanism for decrypting the master key after resetting the user's password is as follows: a pair of RSA keys is created on the domain controller ‚Äî a closed and an open one.  The private key is stored on a domain controller in the NTDS database and is called BCKUPKEY_xxxx (see figure below), and the public key is distributed to all domain systems and is used to create a duplicate master key when it is generated. <br><br>  After the master key is created, a duplicate machine is created on the domain machine (or rather, the master key material is its 64 bytes), which is stored together with the main master key in one file and is called the Domain Key.  If the master key is lost, i.e.  when a user password is reset, the system sends a duplicate of it to the domain controller and asks him to decrypt it.  The controller, authorizing the user, decrypts the duplicate and returns to the system, after which the material of the master key is already re-encrypted with a new password. <br><br><img src="https://habrastorage.org/webt/jj/7h/zr/jj7hzrqypjkdjwiaooxks9wcbj0.jpeg"><br><br>  Having the appropriate privileges in the domain (most often admin ones), you can get these private RSA keys from the domain controller through the replication mechanism and use them to further decrypt the master keys created on the domain machines.  This can be done using mimikatz or DSInternals.  Read more about this in the mimikatz wiki or the <a href="https://www.dsinternals.com/en/retrieving-dpapi-backup-keys-from-active-directory/">DSInternals</a> blog. <br><br><h3>  Where are the master keys stored and what are they? </h3><br>  The master key can be user and system, depending on whose secrets are encrypted.  The user master key is stored in the user profile along the following path: <br><br> <code>Users\%USER%\AppData\Roaming\Microsoft\Protect\%SID%\</code> <br> <br>  Just in case the system stores all master keys ever used by the user.  After all, she does not know in advance what master key will be necessary to decipher something.  The GUID of the currently used key is stored in the Preferred file. <br><br><img src="https://habrastorage.org/webt/xf/vm/dr/xfvmdrhqgsspxyznypourrwceh8.jpeg"><br><br>  System master keys are stored in the following way: <br> <code>windows\system32\Microsoft\Protect\S-1-5-18\</code> <br> <br>  Similarly with the user - one master key is used, the name of which can be found in the Preferred file, where all the keys that have ever been used are stored. <br><br><img src="https://habrastorage.org/webt/zt/xt/xj/ztxtxjcblhgk7ugrwxwgosbtmjw.jpeg"><br><br><h3>  Well, what can your DPAPI do for a pentester? </h3><br>  Since DPAPI is a legal and simple mechanism, various applications try to use it.  Because it is convenient and safe.  For the time being, of course. <br><br>  For example, DPAPI is used to encrypt private keys of client and system certificates, WIFI keys, Chrome (cookies, passwords), DropBox, Skype, RSA SecurID (a software application that generates one-time keys).  And this is far from an exhaustive list. <br><br>  The task of the pentester is to decrypt the necessary blobs and get passwords, cookies, etc. <br><br>  This can be done in several ways.  Anyway, they all boil down to two decoding - online and offline.  Online decryption is when on the user's machine we simply call the system functions for decrypting data and transfer it to the input of the DPAPI blob, and the system already does everything by itself ‚Äî looking for the master key with which the blob was encrypted, decrypts it using the user's SID and a password hash stored in LSASS memory. <br><br>  The figure below shows an example of calling DPAPI functions to encrypt and decrypt on powershell. <br><br><img src="https://habrastorage.org/webt/nj/h3/ko/njh3koyjpr5f1yft8o6zllkpjfw.jpeg"><br><br>  First, we encrypt our secret (in this case, the word ‚ÄúPassword‚Äù) by calling the function [Security.Cryptography.ProtectedData] :: Protect ().  And we do it twice - in the first case using the user's master key (CurrentUser parameter), and in the second case - the system master key (LocalMachine parameter).  Then we can decipher the received blobs through the call of the reverse function - [Security.Cryptography.ProtectedData] :: UnProtect (). <br><br>  In this case, the value of the CurrentUser or LocalMachine parameter is not important, since  the system itself finds the master key suitable for decoding the blob, and does everything necessary.  At the exit in both cases we get our initial secret - the word ‚ÄúPassword‚Äù (its byte-by-word representation). <br><br>  When decoding online, it is important to understand the context in which you call the UnProtect () function.  In order for decryption to succeed, it is necessary to be in a user session or to log in under a new session.  It's all about the password hash, which is stored in the LSASS memory.  If you make a call not in a user session (for example, you are logged in over the network via psexec or meterpreter), then you, respectively, do not have the password hash required to decrypt the master key.  Of course, he is in the next session, but LSASS will not give it to you, because  This is another session, even though it was created under the same user.  For successful online decryption, you need to either migrate to any process started by the user logged in through the GUI, or fully log in, for example, via RDP. <br><br>  An alternative to powershell for decrypting DPAPI blobs online is to call mimiktaz :: blob with the / unprotect option.  At the entrance, it is supplied with a binary file with a DPAPI blob, and at the output we get decrypted data.  More cases using mimikatz are described in the HarmJ0y <a href="https://www.harmj0y.net/blog/redteaming/operational-guidance-for-offensive-user-dpapi-abuse">blog</a> . <br><br><h3>  The cue ball fell.  Where to put my farm with vidyukhi? </h3><br>  Due to the fact that the DPAPI master keys are encrypted on the user's password, it is possible to try the reverse process - brute force the user's password by its master key.  For example, we received a reverse connection from our macro or DDE from the sent docx file.  We can take the user's master key and recover the user's password without any escalation of privileges and mimikatz launches. <br><br>  For brute force password can you use Hashcat or JohnTheRipper?  But before that, you need to get the parameters for bruteforce by the corresponding script from John: <br><br><pre> <code class="xml hljs">./DPAPImk2john.py ‚ÄìS <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sid</span></span></span><span class="hljs-tag">&gt;</span></span> -mk <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkey</span></span></span><span class="hljs-tag">&gt;</span></span> -c <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">domain|local</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Then we can send the result of the script to our farm with video cards and hope that the user has a weak password, because  the master key bruteforce speed is approximately comparable to the WPA2 brute force, i.e.  very really slow. <br><br>  It is worth noting here that, in the case where the master key is generated on a Windows 10 domain, then 10,000 rounds of PBKDF2 are added to the prekey generation.  But even worse is that neither Hashcat nor JohnTheRipper know about it (at least at the time of this writing), which means that they will not be able to clear the password from such a master key. <br><br><h3>  "Take away all that is bad, and then understand ..." </h3><br>  As we noted earlier, the execution of suspicious actions on the user's machine can provoke additional interest to us from the Blueteam team, and this, accordingly, is fraught with the fact that the whole RedTeam will end there.  An example is the launch of powershell on an accountant‚Äôs or secretary‚Äôs computer with subsequent investigation of the incident.  In order not to cause undue suspicion, it is better to use offline ways to decrypt DPAPI blobs.  To do this, you must first pick up everything you need from your car, namely: <br><br><ul><li>  User master keys; </li><li>  Master keys of the system; </li><li>  CREDHIST file (if it is not a domain machine); </li><li>  User password (or its sha1 / ntlm hash); </li><li>  User SID; </li><li>  DPAPI blobs that we want to decrypt. </li></ul><br>  To decrypt in offline mode, we can not do without specialized tools.  Such tools can be: <br><br><ul><li>  Mimikatz; </li><li>  Impacket (starting from the 18th version, it has DPAPI functionality); </li><li>  Dpapick framework </li></ul><br>  We‚Äôll talk about the dpapick framework in more detail. <br><br>  The python dpapick framework itself was made by researcher Jean-Michel Piccode back in 2014 and represents the implementation of DPAPI mechanisms in Python crypto libraries.  The use of python, as well as the structure of the framework, makes it quite easy to adapt it for various DPAPI mechanisms.  In its original version, dpapick did not know how to use the domain backup key to decrypt master keys, and there were no mechanisms for decrypting master keys created on Windows 10 in the domain machine mode. <br><br>  After correcting these flaws and expanding the functionality for decoding DPAPI blobs, dpapick has become a fairly good tool for offline decoding of DPAPI.  Below, as examples - we will show the options for using this framework to decrypt user-encrypted data through DPAPI. <br><br><h3>  Chrome - pick up and decrypt cookies and passwords </h3><br>  Chrome <code>%localappdata%\Google\Chrome\User Data\Default\Cookies</code> are stored in the <code>%localappdata%\Google\Chrome\User Data\Default\Cookies</code> file <br>  Login data is in the <code>%localappdata%\Google\Chrome\User Data\Default\Login Data</code> file <br><br>  Both files are sqlite3 databases in which sensitive data is stored as DPAPI blobs.  Dpapick contains a ready-made dissector (parser) of this data (examples / chrome.py).  For successful decryption, it needs to specify the directory with master keys, the user's sid, his password or the location of the controller-domain's private key, as well as the sqlite3 file from Chrome (cookie or login data). <br><br>  Offline Chrome cookie decryption with user password <br><br><pre> <code class="xml hljs">./chrome.py --cookie <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cookiefile</span></span></span><span class="hljs-tag">&gt;</span></span> --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SID</span></span></span><span class="hljs-tag">&gt;</span></span> --password <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Offline Chrome cookie decryption using user password hash <br><br><pre> <code class="xml hljs">./chrome.py --cookie <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cookiefile</span></span></span><span class="hljs-tag">&gt;</span></span> --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SID</span></span></span><span class="hljs-tag">&gt;</span></span> --hash <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Offline decryption of Chrome passwords using a private key from a domain controller <br><br><pre> <code class="xml hljs">./chrome.py --chrome <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">login</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">file</span></span></span><span class="hljs-tag">&gt;</span></span> --pkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rsa-priv.pem</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  DPAPI for client certificates </h3><br>  Client certificates are used a lot where - to generate OTP, EFS or authentication in VPN, Web-based applications, etc. <br><br>  The public key certificates themselves are stored in the user profile: <br> <code>%APPDATA%\Microsoft\SystemCertificates\My\Certificates\</code> <br>  And private keys, with the help of which the signature or other cryptographic operations are actually made, are encrypted via DPAPI and are also located in the user profile along the way: <br><br><pre> <code class="bash hljs">%APPDATA%\Roaming\Microsoft\Crypto\RSA\&lt;SID&gt;\</code> </pre> <br>  In order to successfully decrypt the private keys of the certificates and the subsequent reconstruction of the PFX files, we also need the user's master keys, as well as his SID and password (or the RSA private key from the controller) in addition to the above files. <br><br>  With the help of Dpapick and the user's password, we decipher it: <br><br><pre> <code class="xml hljs">./efs.py --certificates <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cert</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --rsakyes <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RSA</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --password <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/tx/kf/bp/txkfbp91hcb6pg_rq7wgh8w7v5u.jpeg"><br><br>  The optional rsaout parameter in the screenshot allows you to optionally export decrypted RSA keys in PEM format.  The result of the script is a recreated PFX file without a password, which you can already import to yourself and use for its intended purpose.  If there are several certificates and private keys in the above directories, then dpapick will try to decrypt each of them and make several pfx files. <br><br>  The same actions can be performed using the domain private key to decrypt the master key, specifying the appropriate parameter: <br><br><pre> <code class="xml hljs">./efs.py --certificates <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cert</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --rsakyes <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RSA</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dir</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">masterkeydir</span></span></span><span class="hljs-tag">&gt;</span></span> --pkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">domain</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bkp</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  A little more about the "phishing" domain </h3><br>  Speaking of the Active Directory domain, it is worth mentioning such a wonderful piece as Credentials Roaming - the domain function, when master keys, encrypted passwords and certificates ‚Äútravel‚Äù as a user throughout the Active Directory domain.  They are not tied to a specific machine and will ‚Äúarrive‚Äù on the computer on which the domain user will log in. <br><br>  When you enable this feature, all certificates that the user imports, as well as all his private keys and passwords, fly to AD and are stored in the corresponding account attributes: msPKIAccountCrdentailas and msPKIDPAPIMasterKeys. <br><br>  You can see how it looks inside AD, for example, via ldapsearch: <br><br><pre> <code class="xml hljs">ldapsearch -x -h dc1.lab.local -D ‚Äúuser1@lab.local" -s sub "samAccountname=user1" ldapsearch -x -h dc1.lab.local -D "admin@lab.local" -s sub "samAccountname=anyuser"</code> </pre> <br><img src="https://habrastorage.org/webt/vl/sh/01/vlsh019lykontfubtr-g5rx__dc.jpeg"><br><br>  By default, a user can get DPAPI attributes only for his account.  But with elevated privileges, this can be done for any account, including a computer account. <br><br>  Credential Roaming is a very convenient technology not only for admins, but also for pentesters.  Having gained access to the domain controller through ldap, you can merge all user certificates, his master keys and passwords encrypted with DPAPI (for example, passwords for connecting to network drives). <br><br>  And why not add such functionality to dpapick, we thought - and taught it to automatically extract certificates from a domain controller via ldap, decrypt them and generate pfx files. <br><br><pre> <code class="xml hljs">./efs.py ‚Äìldap-server <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --ldap-connect admin:Passw0rd@lab.local --ldap-user user1 --password Password1 ./efs.py ‚Äìldap-server <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --ldap-connect admin:Passw0rd@lab.local --ldap-user user1 --pkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rsa-priv.pem</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><img src="https://habrastorage.org/webt/an/_p/bi/an_pbimm2jjr-iuapm945q43rzs.jpeg"><br><br>  To execute the script, you need to specify the domain controller as an ldap server, connection details, the name of the account for which we receive certificates and a password to decrypt the master key (or a private backup controller key). <br><br><h3>  Dropbox.  Gone in 60 seconds ... </h3><br>  Dropbox is another example of using DPAPI to store user secrets.  Authorization tokens for dropbox are stored in files: <br><br><pre> <code class="bash hljs">c:\users\&lt;username&gt;\Appdata\Local\Dropbox\instance1\config.dbx c:\users\&lt;username&gt;\Appdata\Local\Dropbox\instance_db\instanse.dbx</code> </pre> <br>  These are encrypted sqlite3 databases containing data for connection.  For encryption, a symmetric key is used, which in turn is encrypted via DPAPI and stored in the registry: <br><br> <code>HKCU\SOFTWARE\Dropbox\ks <br> HKCU\SOFTWARE\Dropbox\ks1</code> <br> <br>  Thus, the general procedure for hijacking a dropbox is as follows: <br><br><ol><li>  pick up two database files from a computer; </li><li>  get the keys from the registry and decrypt them with dpapick; </li><li>  we encrypt the received keys using DPAPI already on our machine and put it into the registry; </li><li>  we replace the database files on our machine and launch Dropbox. </li></ol><br>  You should be aware that special permissions are set for the above registry branches.  Only the user can read them.  Neither the administrator nor the system can read them.  Thus, if you access the registry on behalf of another user (even the administrator), you must first set the appropriate permissions on the specified registry branches.  For example, so (powershell): <br><br><pre> <code class="xml hljs">$Sid="S-1-5-21-3463664321-2923530833-3546627382-1000"; $key=[Microsoft.Win32.Registry]::USERS.OpenSubKey("$sid\SOFTWARE\Dropbox\ks",[Microsoft.Win32.RegistryKeyPermissionCheck]::ReadWriteSubTree,[System.Security.AccessControl.RegistryRights]::ChangePermissions); $acl = $key.GetAccessControl(); $rule = New-Object System.Security.AccessControl.RegistryAccessRule ("administrator","FullControl","Allow"); $acl.SetAccessRule($rule); $key.SetAccessControl($acl); $key_path = "REGISTRY::HKEY_USERS\$Sid\SOFTWARE\Dropbox\ks"; (Get-ItemProperty -Path $key_path -Name Client).Client;</code> </pre> <br>  The keys ks and ks1 contain the header (8 bytes) of the dbx version before the DPAPI blob and md5 HMAC DPAPI blob (the last 16 bytes).  The DPAPI blob itself starts with the 9th byte 0x01000000D0 ... These bytes need to be copied in base64 format to a file, which can then be decrypted using dpapick: <br><br><pre> <code class="xml hljs">./filegeneric.py --sid <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --password <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --masterkey <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span> --base64file <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">..</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Then, on your machine, you need to encrypt the keys obtained at the last stage already by our master-key and put the result in the corresponding registry branches. <br><br>  For encryption, it is best to use powershell: <br><br><pre> <code class="xml hljs">$hdata="4efebbdf394d4003317fc5c357beac4b"; [Byte[]] $dv0_entropy = 0xd1,0x14,0xa5,0x52,0x12,0x65,0x5f,0x74,0xbd,0x77,0x2e,0x37,0xe6,0x4a,0xee,0x9b; $data = ($hdata -split "(?<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">=\G\w{2})(?=\w{2})"</span></span></span><span class="hljs-tag"> | %{ [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Convert</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">::ToByte</span></span></span><span class="hljs-tag">( $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">_</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">16</span></span></span><span class="hljs-tag"> ) }); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Add-Type</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-AssemblyName</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">System.Security</span></span></span><span class="hljs-tag">; $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">dk1</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[system.security.cryptography.protecteddata]::Protect($data,$dv0_entropy,[System.Security.Cryptography.DataProtectionScope]::CurrentUser);</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pr</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">([System.BitConverter]::ToString($dk1));$pr</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">OBJ_hmac</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">New-Object</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">System.Security.Cryptography.HMACMD5</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hmac</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">$OBJ_hmac.ComputeHash($dk1)</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pr</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">([System.BitConverter]::ToString($hmac));$pr</span></span></span></span></code> </pre> <br>  In this case, hdata is the key that was obtained at the decryption stage.  dv0_entropy is the entropy constant used by DBOX in DPAPI.  To the resulting blob you need to attach the front header 8 bytes 0x00000000F6000000, and behind - HMACMD5 + 0x00 <br>  After that, you can write data to the corresponding registry keys. <br><br><h3>  DPAPI and RSA SecurID </h3><br>  RSA SecurID is a client program that is used to generate a one-time password developed by RSA. <br><br>  It is quite a popular thing for large companies and also uses DPAPI, only a bit more complicated.  In this case, RSA engineers decided to get bogged down and applied more complex DPAPI schemes. <br><br>  Token data is stored in the <code>%LOCALAPPDATA%\RSA\SecurIDStorage</code> , which is a sqlite3 database.  The base for each token is recorded its encrypted EnTokenSid (initial initialization parameters of the code generation algorithm).  EnTokenSid is generated based on DBKey, the token SID and user SID, and DBKey is already generated by decoding DBKeyEnc in the following sequence by DPAPI: <br> <code>DBKeyEnc = DPAPI(CurrenUser, DPAPI(LocalSystem(DBKey))</code> <br> <br>  Those.  First, the DB Key is encrypted with the system master key, and then the resulting DPAPI blob is once again encrypted with the user master key. <br><br>  CryptoCheckSum from CheckSum is also present in the database: <br>  CryptoCheckSum = DPAPI blob (CurrenUser) <br><br>  Thus, in order for the merged SecurIDStorage to work on your machine, you must: <br><br><ol><li>  Due to the fact that the user's SID is involved in the formation of the EncTokenSid, it is necessary to set the current SID user in its virtual machine to the same value as the user SID from which the SecurIDStorage database is taken.  The NewSid utility from SysInternals will help us with this; </li><li>  Decrypt DBKeyEnc using the user's master key and his password or domain private key (in the case of a domain machine); </li><li>  Decrypt the result of the previous decryption using the system master key and the value of the parameter DPAPI_SYSTEM; </li><li>  Decrypt CryptoCheckSum using the user's master key </li><li>  Encrypt the received DBKey and CheckSum values ‚Äã‚Äãin the reverse order already on their virtual machine; </li><li>  In some versions, SecurID will also need to set the HDD size of the virtual machine to be the same as the HDD size of the source machine, since  the program compares it at startup. </li></ol><br>  As already mentioned above, in order to decrypt DBKeyEnc, in addition to the user's master key, we will also need the system master key, as well as the DPAPI_SYSTEM value, which is used to decrypt the system master keys.  DAPPI_SYSTEM is actually an already formed prekey involved in the generation of system master keys.  You can get it from LSASS memory (via mimikatz or by analyzing the process dump) or from the corresponding registry branches (HKLM \ SYSTEM, HKLM \ SECURITY), dumping them and analyzing with the same Impacket. <br><br>  Then we can use the resulting DPAPI_SYSTEM to decrypt the necessary blobs using dpapick (parser - examples / filegeneric.py), as shown in the following screenshots: <br><br>  1) Getting DPAPI_SYSTEM via mimikatz offline <br><br><img src="https://habrastorage.org/webt/ww/xi/ov/wwxiovhm-6gdcbn7tmmpr7-qsim.jpeg"><br><br>  2) Receive DPAPI_SYSTEM via Impacket offline <br><br><img src="https://habrastorage.org/webt/s7/9v/5g/s79v5gxvzjjccekaklg8gtefyfw.jpeg"><br><br>  3) Decryption of DPAPIck with user and system master keys <br><br><img src="https://habrastorage.org/webt/ip/th/qm/ipthqmqacvzvixntzgk_n1vsgvs.jpeg"><br><br><h3>  Crib </h3><br>  So that you do not forget the places of specific data - we put them in a separate section: <br><br>  <b>Custom master keys</b> <br><br><pre> <code class="bash hljs">%APPDATA%\Microsoft\Protect\&lt;SID&gt;\*</code> </pre> <br>  <b>System master keys</b> <br><br><pre> <code class="bash hljs">Windows\System32\Microsoft\Protect\*</code> </pre> <br>  <b>DPAPI_SYSTEM</b> <br><br><pre> <code class="bash hljs">LSASecrets ‚Äì online SYSTEM, SECURITY (reg save ‚Ä¶, system\backup, etc)</code> </pre> <br>  <b>User certificates</b> <br><br><pre> <code class="bash hljs">%APPDATA%\Microsoft\SystemCertificates\My\Certificates\ %APPDATA%\Microsoft\Crypto\RSA\&lt;SID&gt;\</code> </pre> <br>  <b>System certificates</b> <br><br><pre> <code class="bash hljs">HKLM:\SOFTWARE\Microsoft\SystemCertificates\MY\Certificates\* C:\Programdata\Microsoft\Crypto\RSA\MachineKeys\</code> </pre> <br>  <b>Chrome</b> <br><br><pre> <code class="bash hljs">%localappdata%\Google\Chrome\User Data\Default\Cookies %localappdata%\Google\Chrome\User Data\Default\Login Data</code> </pre> <br>  <b>Dropbox</b> <br><br><pre> <code class="bash hljs">HKCU\SOFTWARE\Dropbox\ks HKCU\SOFTWARE\Dropbox\ks1 %APPDATA%\Local\Dropbox\instance1\config.dbx %APPDATA%\Local\Dropbox\instance_db\instanse.dbx</code> </pre> <br>  <b>Rsa securid</b> <br><br><pre> <code class="bash hljs">%LOCALAPPDATA%\RSA\SecurIDStorage</code> </pre> <br><h3>  Small conclusion </h3><br>  DPAPI is a smart thing - the main thing is to understand how it can be used during pentest and RedTeam research. <br><br>  In this article, we looked at just a few examples where DPAPI decryption can be applied.  In fact, the scope of application is much broader.  For example, we did not consider RDP (* .rdg), Icloud (pList file), Skype (*. Xml), keys for connecting to Wi-Fi.  DPAPI is used everywhere and the corresponding parsers are included as part of the dpapick framework. <br><br>  A modified version of dpapick is posted on our <a href="https://github.com/mis-team/dpapick/">GitHub</a> .  We urge you to use this tool to decrypt DPAPI and will be grateful for the further refinement of dpapick. <br><br>  And some interesting information can be found in our channel in <a href="https://t.me/mis_team">telegrams</a> .  We are talking about security through the eyes of RedTeam. <br><br>  PS Thanks to the organizers of OFFZONE-2018 for a cool conference! <br><br>  PPS The second part of the article <a href="https://habr.com/ru/post/437390/">here</a> </div><p>Source: <a href="https://habr.com/ru/post/434514/">https://habr.com/ru/post/434514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434504/index.html">20 years of Fast Reports ‚ÄúThe product was created in one breath, just a thrill ...‚Äù</a></li>
<li><a href="../434506/index.html">The experience of publishing an application for video editing in the Microsoft Store</a></li>
<li><a href="../434508/index.html">The dark side of search engine marketing: how and why does Google collect our personal information</a></li>
<li><a href="../434510/index.html">Briefly about working with RabbitMQ from Python</a></li>
<li><a href="../434512/index.html">Corporate Corporate</a></li>
<li><a href="../434516/index.html">Easy way to deal with your career aspirations</a></li>
<li><a href="../434518/index.html">Applause and cheers: carefully managed drama in Apple stores</a></li>
<li><a href="../434522/index.html">Patterns and antipatterns of task justification</a></li>
<li><a href="../434524/index.html">Kubernetes Ingress through the eyes of a novice</a></li>
<li><a href="../434526/index.html">"Yandex" explained why deleted from the search results of the official site Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>