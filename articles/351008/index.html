<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Custom aggregate and window functions in PostgreSQL and Oracle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at how to create custom aggregate and window (in Oracle terminology - analytical) functions in two systems. Despite diff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Custom aggregate and window functions in PostgreSQL and Oracle</h1><div class="post__text post__text-html js-mediator-article"><br>  In this article, we will look at how to create custom aggregate and window (in Oracle terminology - analytical) functions in two systems.  Despite differences in syntax and in general in the approach to extensibility, the mechanism of these functions is very similar.  But there are differences too. <br><br>  It must be admitted that own aggregate and window functions are quite rare.  Window functions in general for some reason are traditionally classified as ‚Äúadvanced‚Äù SQL and are considered difficult to understand and master.  There would be to deal with those functions that are already available in the database! <br><br>  Why, then, to delve into this question at all?  I can name a few reasons: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Although window functions are objectively more complex than ordinary aggregate ones, there is nothing beyond them;  It is an absolutely essential tool for SQL developers.  And creating your own window function, even quite simple, allows you to better understand how standard ones work. <br></li><li>  Window and aggregate functions are a great way to combine procedural processing with declarative logic.  In some situations, it turns out to perform complex actions, remaining within the paradigm of solving the problem with a single SQL query. <br></li><li>  And just an interesting topic, and even more interesting to compare the two systems. <br></li></ul><br>  An example on which we will train is the calculation of the average, an analogue of the standard avg function for the type numeric (number in Oracle).  We will write such a function and see how it works in the aggregate and window modes and whether it can be calculated by several parallel processes.  And in conclusion, let's look at an example from real life. <br><a name="habracut"></a><br><h1>  Aggregate functions </h1><br>  Let's move from simple to complex, switching between PostgreSQL and Oracle. <br><br>  First, some general considerations.  Any aggregate function is called for each row of the table in turn and eventually processes them all.  Between calls, it needs to maintain an internal state that defines the context for its execution.  At the end of the work, it should return the total value. <br><br>  So, we need four components: <br><br><ul><li>  State (context) </li><li>  The processing function of the next line, </li><li>  The function of issuing the final result, </li><li>  Indication that the previous three points constitute an aggregate function. </li></ul><br><h3>  PostgreSQL </h3><br>  To store the state you need to select the appropriate data type.  You can take the standard, but you can define your own.  For the function that calculates the average, it is necessary to sum up the values ‚Äã‚Äãseparately and count their number separately.  Therefore, we will create our own composite type with two fields: <br><br> <code><strong>CREATE TYPE <font color="green">average_state</font> AS ( <br> accum numeric, <br> qty numeric <br> ); <br></strong></code> <br>  Now we define a function to process the next value.  In PostgreSQL, it is called a transition function: <br><br> <code><strong>CREATE OR REPLACE FUNCTION <font color="green">average_transition</font> ( <br> state average_state, <br> val numeric <br> ) RETURNS average_state AS $$ <br> BEGIN <br> RAISE NOTICE '%(%) + %', state.accum, state.qty, val; <br> RETURN ROW(state.accum+val, state.qty+1)::average_state; <br> END; <br> $$ LANGUAGE plpgsql; <br></strong></code> <br>  The function takes the current state and the next value, and returns the new state: the values ‚Äã‚Äãare added together, and the unit is added to the quantity. <br><br>  In addition, we derive (RAISE NOTICE) function parameters ‚Äî this will allow us to see how the work is done.  Good old debug PRINT, there is nothing better than you. <br><br>  The next function is to return the final value: <br><br> <code><strong>CREATE OR REPLACE FUNCTION <font color="green">average_final</font> ( <br> state average_state <br> ) RETURNS numeric AS $$ <br> BEGIN <br> RAISE NOTICE '= %(%)', state.accum, state.qty; <br> RETURN CASE WHEN state.qty &gt; 0 THEN <br> <font color="blue">trim(trailing '0' from (</font> state.accum/state.qty <font color="blue">)::text)::numeric</font> <br> END; <br> END; <br> $$ LANGUAGE plpgsql; <br></strong></code> <br>  The function takes a state and returns the resulting number.  To do this, simply divide the accumulated amount by the amount.  But at zero, we return NULL (so does avg). <br><br>  "Feint ears" with the trim function is needed solely for the accuracy of the output: this way we get rid of insignificant zeros that would otherwise clutter the screen and interfere with perception.  Like this: <br><br> <code><strong>SELECT 1::numeric / 2::numeric;</strong> <br> ?column? <br> ------------------------ <br> 0.50000000000000000000 <br> (1 row) <br></code> <br>  In real life, these tricks, of course, are not needed. <br><br>  And finally, we define the actual aggregate function.  To do this, use the special command CREATE AGGREGATE: <br><br> <code><strong>CREATE AGGREGATE average(numeric) ( <br> sfunc    = <font color="green">average_transition</font> , <br> stype    = <font color="green">average_state</font> , <br> finalfunc = <font color="green">average_final</font> , <br> initcond  = '(0,0)' <br> ); <br></strong></code> <br>  This command indicates the data type for the state (stype), our two functions (sfunc and finalfunc) and the initial state value (initcond) as a string constant. <br><br>  You can try.  Almost all the examples in this article will use a simple table with five rows: one, two, three, four, five.  The table is created on the fly by the function generate_series, an indispensable tool for generating test data: <br><br> <code><strong>SELECT average(gx) FROM generate_series(1,5) AS g(x);</strong> <br> NOTICE:  0(0) + 1 <br> NOTICE:  1(1) + 2 <br> NOTICE:  3(2) + 3 <br> NOTICE:  6(3) + 4 <br> NOTICE:  10(4) + 5 <br> NOTICE:  = 15(5) <br> average <br> --------- <br> 3 <br> (1 row) <br></code> <br>  The result is correct, and the output of functions allows you to track the progress of the execution: <br><br><ul><li>  The state was set to (0,0), </li><li>  The function average_transition was sequentially called five times, gradually changing its state, </li><li>  In the end, the function average_final was called, which got 3 = 15/5. </li></ul><br>  Another check is on the empty set: <br><br> <code><strong>SELECT average(gx) FROM generate_series(1,0) AS g(x);</strong> <br> NOTICE:  = 0(0) <br> average <br> --------- <br> <br> (1 row) <br></code> <br><h3>  Oracle </h3><br>  In Oracle, all extensibility is provided by the Data Cartridge mechanism.  In simple terms, we will need to create an object type that implements the interface necessary for aggregation.  The context is naturally represented by the attributes of this object. <br><br> <code><strong>CREATE OR REPLACE TYPE AverageImpl AS OBJECT( <br> accum number, <br> qty  number, <br> STATIC FUNCTION <font color="green">ODCIAggregateInitialize</font> (actx IN OUT AverageImpl) <br> RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateIterate</font> (self IN OUT AverageImpl, val IN number <br> RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateMerge</font> (self IN OUT AverageImpl, ctx2 IN AverageImpl) <br> RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateTerminate</font> (self IN OUT AverageImpl, returnValue OUT number, flags IN number) <br> RETURN number <br> ); <br> / <br></strong></code> <br>  The initial context value is determined here not by a constant, but by a separate (static, that is, not bound to a specific object instance) function ODCIAggregateInitialize. <br><br>  The function called for each line is ODCIAggregateIterate. <br><br>  The result is returned by the ODCIAggregateTerminate function, and note that certain flags are passed to it, which we will deal with a little later. <br><br>  The interface includes another mandatory function: ODCIAggregateMerge.  We will define it - where to go, - but let's talk about it for now. <br><br>  Now create an object body with the implementation of the listed methods. <br><br> <code><strong>CREATE OR REPLACE TYPE BODY AverageImpl IS <br> STATIC FUNCTION <font color="green">ODCIAggregateInitialize</font> (actx IN OUT AverageImpl) <br> RETURN number IS <br> BEGIN <br> actx := AverageImpl(0,0); <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateIterate</font> (self IN OUT AverageImpl, val IN number) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line(self.accum||'('||self.qty||') + '||val); <br> self.accum := self.accum + val; <br> self.qty := self.qty + 1; <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateMerge</font> (self IN OUT AverageImpl, ctx2 IN AverageImpl) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line(self.accum||'('||self.qty||') &amp; '||ctx2.accum||'('||ctx2.qty||')'); <br> self.accum := self.accum + ctx2.accum; <br> self.qty := self.qty + ctx2.qty; <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateTerminate</font> (self IN OUT AverageImpl, returnValue OUT number, flags IN number) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line('= '||self.accum||'('||self.qty||') flags:'||flags); <br> returnValue := CASE WHEN self.qty &gt; 0 THEN self.accum / self.qty END; <br> RETURN ODCIConst.Success; <br> END; <br> END; <br> / <br></strong></code> <br>  The implementation, for the most part, repeats everything we did for PostgreSQL, but in a slightly different syntax. <br><br>  Trim dances around the return value are not needed: Oracle automatically cuts off insignificant zeros during value output. <br><br>  Note that all functions return a success indicator (ODCIConst.Success value), and the semantic values ‚Äã‚Äãare passed through the OUT and IN OUT parameters (which are not connected in any way with the actual return value in PL / SQL).  In particular, any function, including ODCIAggregateTerminate, can change the attributes of its object, the link to which is passed to it in the first parameter (self). <br><br>  The definition of the aggregate function is as follows: <br><br> <code><strong>CREATE OR REPLACE FUNCTION average(val number) RETURN number <br> AGGREGATE USING AverageImpl; <br> / <br></strong></code> <br>  We are checking.  To generate values, use the idiomatic construct with the recursive CONNECT BY level query: <br><br> <code><strong>SELECT average(level) FROM dual CONNECT BY level &lt;= 5;</strong> <br> AVERAGE(LEVEL) <br> -------------- <br> 3 <br> 0(0) + 1 <br> 1(1) + 2 <br> 3(2) + 3 <br> 6(3) + 4 <br> 10(4) + 5 <br> = 15(5) flags:0 <br></code> <br>  You can pay attention to the fact that the output of messages in PostgreSQL appears before the result, and in Oracle - after.  This is because RAISE NOTICE works asynchronously, and the dbms_output package buffers the output. <br><br>  As we can see, the zero flag was passed to the ODCIAggregateTerminate function.  This means that the context is no longer required and, if desired, can be forgotten. <br><br>  And check on empty set: <br><br> <code><strong>SELECT average(rownum) FROM dual WHERE 1 = 0;</strong> <br> AVERAGE(ROWNUM) <br> --------------- <br> <br> = 0(0) flags:0 <br></code> <br><h1>  Window Functions: OVER () </h1><br>  The good news is that the aggregate function written by us can work without any changes as a window (analytical) one. <br><br>  The window function differs from the aggregate in that it does not fold the sample into one (aggregated) row, but is calculated as if separately for each row.  Syntactically, a window function call is characterized by the presence of an OVER construction with an indication of a <em>frame</em> that defines a set of lines to be processed.  In the simplest case, it is written like this: OVER (), and this means that the function must process all the strings.  The result is the same as if we considered the usual aggregate function and recorded the result (the same) opposite each row of the sample. <br><br>  In other words, the frame is static and covers all lines: <br><br><pre> 1. 2. 3. 4. 5.
 + --- + + --- + + --- + + --- + + --- +
 |  1 |  |  1 |  |  1 |  |  1 |  |  1 |
 |  2 |  |  2 |  |  2 |  |  2 |  |  2 |
 |  3 |  |  3 |  |  3 |  |  3 |  |  3 |
 |  4 |  |  4 |  |  4 |  |  4 |  |  4 |
 |  5 |  |  5 |  |  5 |  |  5 |  |  5 |
 + --- + + --- + + --- + + --- + + --- +
</pre><br><h3>  PostgreSQL </h3><br>  Let's try: <br><br> <code><strong>SELECT gx, average(gx) <font color="blue">OVER ()</font> <br> FROM generate_series(1,5) as g(x);</strong> <br> NOTICE:  0(0) + 1 <br> NOTICE:  1(1) + 2 <br> NOTICE:  3(2) + 3 <br> NOTICE:  6(3) + 4 <br> NOTICE:  10(4) + 5 <br> NOTICE:  = 15(5) <br> x | average <br> ---+--------- <br> 1 |      3 <br> 2 |      3 <br> 3 |      3 <br> 4 |      3 <br> 5 |      3 <br> (5 rows) <br></code> <br>  The NOTICE conclusion shows that everything happens in the same way as before when calculating the normal aggregate function.  After receiving the result from the function average_final, PostgreSQL puts it on each line. <br><br><h3>  Oracle </h3><br> <code><strong>SELECT average(level) <font color="blue">OVER()</font> average <br> FROM dual CONNECT BY level &lt;= 5;</strong> <br> LEVEL    AVERAGE <br> ---------- ----------- <br> 1          3 <br> 2          3 <br> 3          3 <br> 4          3 <br> 5          3 <br> 0(0) + 1 <br> 1(1) + 2 <br> 3(2) + 3 <br> 6(3) + 4 <br> 10(4) + 5 <br> = 15(5) flags:1 <br> = 15(5) flags:1 <br> = 15(5) flags:1 <br> = 15(5) flags:1 <br> = 15(5) flags:1 <br> = 15(5) flags:0 <br></code> <br>  Suddenly.  Instead of calculating the result once, Oracle calls the ODCIAggregateTerminate function N + 1 times: first for each row with flag 1 (which means that the context is still useful) and then one more time at the end.  The value received on the last call is simply ignored. <br><br>  The conclusion is this: if the computationally complex logic is used in the ODCIAggregateTerminate function, you need to think about not doing the same work several times. <br><br><h1>  Window Functions: OVER (PARTITION BY) </h1><br>  The PARTITION BY clause in the frame definition is similar to the usual GROUP BY aggregate construction.  The window function specifying PARTITION BY is calculated separately for each group of rows, and the result is assigned to each row of the sample. <br><br>  In this embodiment, the frame is also static, but for each group it is different.  For example, if two groups of lines are defined (from the first to the second and from the third to the fifth), then the frame can be represented as follows: <br><br><pre> 1. 2. 3. 4. 5.
 + --- + + --- +
 |  1 |  |  1 |
 |  2 |  |  2 |  + --- + + --- + + --- +
 + --- + + --- + |  3 |  |  3 |  |  3 |
                 |  4 |  |  4 |  |  4 |
                 |  5 |  |  5 |  |  5 |
                 + --- + + --- + + --- +
</pre><br><h3>  PostgreSQL </h3><br> <code><strong>SELECT gx/3 part, <br> gx, <br> average(gx) <font color="blue">OVER (PARTITION BY gx/3)</font> <br> FROM generate_series(1,5) as g(x);</strong> <br> NOTICE: <font color="blue">0(0)</font> + 1 <br> NOTICE:  1(1) + 2 <br> NOTICE:  = 3(2) <br> NOTICE: <font color="blue">0(0)</font> + 3 <br> NOTICE:  3(1) + 4 <br> NOTICE:  7(2) + 5 <br> NOTICE:  = 12(3) <br> part | x | average <br> ------+---+--------- <br> 0 | 1 |    1.5 <br> 0 | 2 |    1.5 <br> 1 | 3 |      4 <br> 1 | 4 |      4 <br> 1 | 5 |      4 <br> (5 rows) <br></code> <br>  The calculation again occurs sequentially, but now when moving to another group of rows, the state is reset to the initial value (initcond). <br><br><h3>  Oracle </h3><br> <code><strong>SELECT trunc(level/3) part, <br> level, <br> average(level) <font color="blue">OVER(PARTITION BY trunc(level/3))</font> average <br> FROM dual CONNECT BY level &lt;= 5;</strong> <br> PART      LEVEL    AVERAGE <br> ---------- ---------- ---------- <br> 0          2        1.5 <br> 0          1        1.5 <br> 1          4          4 <br> 1          5          4 <br> 1          3          4 <br> <font color="blue">0(0)</font> + 2 <br> 2(1) + 1 <br> = 3(2) flags:1 <br> = 3(2) flags:1 <br> <font color="blue">0(0)</font> + 4 <br> 4(1) + 5 <br> 9(2) + 3 <br> = 12(3) flags:1 <br> = 12(3) flags:1 <br> = 12(3) flags:1 <br> = 12(3) flags:0 <br></code> <br>  It is interesting that Oracle decided to rearrange the lines in some places.  This may say something about the implementation details, but in any case - it has the right. <br><br><h1>  Window Functions: OVER (ORDER BY) </h1><br>  If we add an ORDER BY clause to the definition of the frame, which indicates the sorting order, the function will start working in the <em>increment</em> mode (for the sum function, we would say so - with <em>progressive total</em> ). <br><br>  For the first line, the frame will consist of one line;  for the second - from the first and second;  for the third - from the first, second and third, and so on.  In other words, the frame will include lines from first to current. <br><br>  In fact, it can be written exactly this way: OVER (ORDER BY ... ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), but since this verbosity is implied by default, it is usually omitted. <br><br>  So, the frame ceases to be static: its head moves down, and the tail remains in place: <br><br><pre> 1. 2. 3. 4. 5.
 + --- + + --- + + --- + + --- + + --- +
 |  1 |  |  1 |  |  1 |  |  1 |  |  1 |
 + --- + |  2 |  |  2 |  |  2 |  |  2 |
         + --- + |  3 |  |  3 |  |  3 |
                 + --- + |  4 |  |  4 |
                         + --- + |  5 |
                                 + --- +
</pre><br><h3>  PostgreSQL </h3><br> <code><strong>SELECT gx, average(gx) <font color="blue">OVER (ORDER BY gx)</font> <br> FROM generate_series(1,5) as g(x);</strong> <br> NOTICE:  0(0) + 1 <br> NOTICE:  = 1(1) <br> NOTICE:  1(1) + 2 <br> NOTICE:  = 3(2) <br> NOTICE:  3(2) + 3 <br> NOTICE:  = 6(3) <br> NOTICE:  6(3) + 4 <br> NOTICE:  = 10(4) <br> NOTICE:  10(4) + 5 <br> NOTICE:  = 15(5) <br> x | average <br> ---+--------- <br> 1 |      1 <br> 2 |    1.5 <br> 3 |      2 <br> 4 |    2.5 <br> 5 |      3 <br> (5 rows) <br></code> <br>  As you can see, the lines are still added to the context one by one, but now the function average_final is called after each addition, producing an intermediate result. <br><br><h3>  Oracle </h3><br> <code><strong>SELECT level, average(level) <font color="blue">OVER(ORDER BY level)</font> average <br> FROM dual CONNECT BY level &lt;= 5;</strong> <br> LEVEL    AVERAGE <br> ---------- ---------- <br> 1          1 <br> 2        1.5 <br> 3          2 <br> 4        2.5 <br> 5          3 <br> 0(0) + 1 <br> = 1(1) flags:1 <br> 1(1) + 2 <br> = 3(2) flags:1 <br> 3(2) + 3 <br> = 6(3) flags:1 <br> 6(3) + 4 <br> = 10(4) flags:1 <br> 10(4) + 5 <br> = 15(5) flags:1 <br> = 15(5) flags:0 <br></code> <br>  This time both systems work in the same way. <br><br><h1>  Window Functions: OVER (PARTITION BY ORDER BY) </h1><br>  PARTITION BY and ORDER BY clauses can be combined.  Then, within each group of rows, the function will work in the increment mode, and when moving from group to group, the state will be reset to the initial state. <br><br><pre> 1. 2. 3. 4. 5.
 + --- + + --- +
 |  1 |  |  1 |
 + --- + |  2 |  + --- + + --- + + --- +
         + --- + |  3 |  |  3 |  |  3 |
                 + --- + |  4 |  |  4 |
                         + --- + |  5 |
                                 + --- +
</pre><br><h3>  PostgreSQL </h3><br> <code><strong>SELECT gx/3 part, <br> gx, <br> average(gx) <font color="blue">OVER (PARTITION BY gx/3 ORDER BY gx)</font> <br> FROM generate_series(1,5) as g(x);</strong> <br> NOTICE: <font color="blue">0(0)</font> + 1 <br> NOTICE:  = 1(1) <br> NOTICE:  1(1) + 2 <br> NOTICE:  = 3(2) <br> NOTICE: <font color="blue">0(0)</font> + 3 <br> NOTICE:  = 3(1) <br> NOTICE:  3(1) + 4 <br> NOTICE:  = 7(2) <br> NOTICE:  7(2) + 5 <br> NOTICE:  = 12(3) <br> part | x | average <br> ------+---+--------- <br> 0 | 1 |      1 <br> 0 | 2 |    1.5 <br> 1 | 3 |      3 <br> 1 | 4 |    3.5 <br> 1 | 5 |      4 <br> (5 rows) <br></code> <br><h3>  Oracle </h3><br> <code><strong>SELECT trunc(level/3) part, <br> level, <br> average(level) <font color="blue">OVER(PARTITION BY trunc(level/3) ORDER BY level)</font> average <br> FROM dual CONNECT BY level &lt;= 5;</strong> <br> PART    LEVEL    AVERAGE <br> ---------- ---------- ---------- <br> 0        1          1 <br> 0        2        1.5 <br> 1        3          3 <br> 1        4        3.5 <br> 1        5          4 <br> <font color="blue">0(0)</font> + 1 <br> = 1(1) flags:1 <br> 1(1) + 2 <br> = 3(2) flags:1 <br> <font color="blue">0(0)</font> + 3 <br> = 3(1) flags:1 <br> 3(1) + 4 <br> = 7(2) flags:1 <br> 7(2) + 5 <br> = 12(3) flags:1 <br> = 12(3) flags:0 <br></code> <br><h1>  Window functions with a sliding frame </h1><br>  In all the examples we looked at, the frame was either static or only its head moved (when using the ORDER BY clause).  This enabled us to calculate the state sequentially, adding line by line to the context. <br><br>  But the frame of the window function can be set in such a way that its tail will also shift.  In our example, this would be consistent with the notion of a <em>moving average.</em>  For example, the indication OVER (ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) says that for each row of the result the current and two previous values ‚Äã‚Äãwill be averaged. <br><br><pre> 1. 2. 3. 4. 5.
 + --- +
 |  |  + --- +
 |  |  |  |  + --- +
 |  1 |  |  1 |  |  1 |  + --- +
 + --- + |  2 |  |  2 |  |  2 |  + --- +
         + --- + |  3 |  |  3 |  |  3 |
                 + --- + |  4 |  |  4 |
                         + --- + |  5 |
                                 + --- +
</pre><br>  Can the window function be calculated in this case?  It turns out that it can, though ineffectively.  But by writing some more code, you can improve the situation. <br><br><h3>  PostgreSQL </h3><br>  We'll see: <br><br> <code><strong>SELECT gx, <br> average(gx) <font color="blue">OVER (ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)</font> <br> FROM generate_series(1,5) as g(x);</strong> <br> NOTICE:  0(0) + 1 <br> NOTICE:  = 1(1) <br> NOTICE:  1(1) + 2 <br> NOTICE:  = 3(2) <br> NOTICE:  3(2) + 3 <br> NOTICE:  = 6(3) <br> NOTICE: <font color="red">0(0) + 2</font> <br> NOTICE: <font color="red">2(1) + 3</font> <br> NOTICE: <font color="red">5(2) + 4</font> <br> NOTICE:  = 9(3) <br> NOTICE: <font color="red">0(0) + 3</font> <br> NOTICE: <font color="red">3(1) + 4</font> <br> NOTICE: <font color="red">7(2) + 5</font> <br> NOTICE:  = 12(3) <br> x | average <br> ---+--------- <br> 1 |      1 <br> 2 |    1.5 <br> 3 |      2 <br> 4 |      3 <br> 5 |      4 <br> (5 rows) <br></code> <br>  Up to the third line, everything goes well, because the tail does not actually move: we simply add another value to the existing context.  But, since we are not able to remove the value from the context, for the fourth and fifth lines everything has to be recounted completely, each time returning to the initial state. <br><br>  So, it would be great to have not only the function of <em>adding the</em> next value, but also the function of <em>removing the</em> value from the state.  And indeed, such a function can be created: <br><br> <code><strong>CREATE OR REPLACE FUNCTION <font color="green">average_inverse</font> (state average_state, val numeric) <br> RETURNS average_state AS $$ <br> BEGIN <br> RAISE NOTICE '%(%) - %', state.accum, state.qty, val; <br> RETURN ROW(state.accum-val, state.qty-1)::average_state; <br> END; <br> $$ LANGUAGE plpgsql; <br></strong></code> <br><br>  In order for the window function to be able to use it, you need to recreate the unit as follows: <br><br> <code><strong>DROP AGGREGATE average(numeric); <br> CREATE AGGREGATE average(numeric) ( <br> --   <br> sfunc      = <font color="green">average_transition</font> , <br> stype      = <font color="green">average_state</font> , <br> finalfunc  = <font color="green">average_final</font> , <br> initcond  = '(0,0)', <br> --   ‚Äú‚Äù  <br> msfunc    = <font color="green">average_transition</font> , <br> minvfunc  = <font color="green">average_inverse</font> , <br> mstype    = <font color="green">average_state</font> , <br> mfinalfunc = <font color="green">average_final</font> , <br> minitcond  = '(0,0)' <br> ); <br></strong></code> <br>  Check: <br><br> <code><strong>SELECT gx, <br> average(gx) <font color="blue">OVER (ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)</font> <br> FROM generate_series(1,5) as g(x);</strong> <br> NOTICE:  0(0) + 1 <br> NOTICE:  = 1(1) <br> NOTICE:  1(1) + 2 <br> NOTICE:  = 3(2) <br> NOTICE:  3(2) + 3 <br> NOTICE:  = 6(3) <br> NOTICE: <font color="blue">6(3) - 1</font> <br> NOTICE:  5(2) + 4 <br> NOTICE:  = 9(3) <br> NOTICE: <font color="blue">9(3) - 2</font> <br> NOTICE:  7(2) + 5 <br> NOTICE:  = 12(3) <br> x | average <br> ---+--------- <br> 1 |      1 <br> 2 |    1.5 <br> 3 |      2 <br> 4 |      3 <br> 5 |      4 <br> (5 rows) <br></code> <br>  Now everything is in order: for the fourth and fifth lines, we remove the tail value from the state and add a new one. <br><br><h3>  Oracle </h3><br>  Here the situation is similar.  The created version of the analytical function works, but is inefficient: <br><br> <code><strong>SELECT level, <br> average(level) <font color="blue">OVER(ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)</font> average <br> FROM dual CONNECT BY level &lt;= 5;</strong> <br> LEVEL    AVERAGE <br> ---------- ---------- <br> 1          1 <br> 2        1.5 <br> 3          2 <br> 4          3 <br> 5          4 <br> 0(0) + 1 <br> = 1(1) flags:1 <br> 1(1) + 2 <br> = 3(2) flags:1 <br> 3(2) + 3 <br> = 6(3) flags:1 <br> <font color="red">0(0) + 2</font> <br> <font color="red">2(1) + 3</font> <br> <font color="red">5(2) + 4</font> <br> = 9(3) flags:1 <br> <font color="red">0(0) + 3</font> <br> <font color="red">3(1) + 4</font> <br> <font color="red">7(2) + 5</font> <br> = 12(3) flags:1 <br> = 12(3) flags:0 <br></code> <br>  The function to remove a value from the context is defined as follows: <br><br> <code><strong>MEMBER FUNCTION <font color="green">ODCIAggregateDelete</font> (self IN OUT AverageImpl, val IN number) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line(self.accum||'('||self.qty||') - '||val); <br> self.accum := self.accum - val; <br> self.qty := self.qty - 1; <br> RETURN ODCIConst.Success; <br> END; <br></strong></code> <br><div class="spoiler">  <b class="spoiler_title">Full code for copy-paste</b> <div class="spoiler_text"> <code><strong>CREATE OR REPLACE TYPE AverageImpl AS OBJECT( <br> accum number, <br> qty  number, <br> STATIC FUNCTION <font color="green">ODCIAggregateInitialize</font> (actx IN OUT AverageImpl) RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateIterate</font> (self IN OUT AverageImpl, val IN number) RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateMerge</font> (self IN OUT AverageImpl, ctx2 IN AverageImpl) RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateTerminate</font> (self IN OUT AverageImpl, returnValue OUT number, flags IN number) RETURN number, <br> MEMBER FUNCTION <font color="green">ODCIAggregateDelete</font> (self IN OUT AverageImpl, val IN number) RETURN number <br> ); <br> / <br> CREATE OR REPLACE TYPE BODY AverageImpl IS <br> STATIC FUNCTION <font color="green">ODCIAggregateInitialize</font> (actx IN OUT AverageImpl) <br> RETURN number IS <br> BEGIN <br> actx := AverageImpl(0,0); <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateIterate</font> (self IN OUT AverageImpl, val IN number) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line(self.accum||'('||self.qty||') + '||val); <br> self.accum := self.accum + val; <br> self.qty := self.qty + 1; <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateMerge</font> (self IN OUT AverageImpl, ctx2 IN AverageImpl) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line(self.accum||'('||self.qty||') &amp; '||ctx2.accum||'('||ctx2.qty||')'); <br> self.accum := self.accum + ctx2.accum; <br> self.qty := self.qty + ctx2.qty; <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateTerminate</font> (self IN OUT AverageImpl, returnValue OUT number, flags IN number) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line('= '||self.accum||'('||self.qty||') flags:'||flags); <br> returnValue := CASE WHEN self.qty &gt; 0 THEN self.accum / self.qty END; <br> RETURN ODCIConst.Success; <br> END; <br> MEMBER FUNCTION <font color="green">ODCIAggregateDelete</font> (self IN OUT AverageImpl, val IN number) <br> RETURN number IS <br> BEGIN <br> dbms_output.put_line(self.accum||'('||self.qty||') - '||val); <br> self.accum := self.accum - val; <br> self.qty := self.qty - 1; <br> RETURN ODCIConst.Success; <br> END; <br> END; <br> / <br></strong></code> <br></div></div><br>  Recreate the function itself is not necessary.  Check: <br><br> <code><strong>SELECT level, <br> average(level) <font color="blue">OVER(ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)</font> average <br> FROM dual CONNECT BY level &lt;= 5;</strong> <br> LEVEL    AVERAGE <br> ---------- ---------- <br> 1          1 <br> 2        1.5 <br> 3          2 <br> 4          3 <br> 5          4 <br> 0(0) + 1 <br> = 1(1) flags:1 <br> 1(1) + 2 <br> = 3(2) flags:1 <br> 3(2) + 3 <br> = 6(3) flags:1 <br> <font color="blue">6(3) - 1</font> <br> 5(2) + 4 <br> = 9(3) flags:1 <br> <font color="blue">9(3) - 2</font> <br> 7(2) + 5 <br> = 12(3) flags:1 <br> = 12(3) flags:0 <br></code> <br><h1>  Parallelism </h1><br>  Both PostgreSQL and Oracle (Enterprise Edition) can calculate aggregate functions in parallel mode.  In addition, each of the parallel processes performs its part of the work, forming an intermediate state.  Then the main coordinating process receives these several states and must combine them into one final state. <br><br>  This requires another <em>join</em> function <em>,</em> which we will now write.  In our case, it simply adds both the amounts and the number of values. <br><br><h3>  PostgreSQL </h3><br>  The function is as follows: <br><br> <code><strong>CREATE OR REPLACE FUNCTION <font color="green">average_combine</font> (state1 average_state, state2 average_state) <br> RETURNS average_state AS $$ <br> BEGIN <br> RAISE NOTICE '%(%) &amp; %(%)', state1.accum, state1.qty, state2.accum, state2.qty; <br> RETURN ROW(state1.accum+state2.accum, state1.qty+state2.qty)::average_state; <br> END; <br> $$ LANGUAGE plpgsql; <br></strong></code> <br>  We will also remove our debug output from the function average_transition.  With parallel execution, we will summarize not five values, but more, so if this is not done, we will get too much useless information. <br><br>  Since we remove the output, there is no need to use a procedural language - we will write a function in pure SQL: <br><br> <code><strong>CREATE OR REPLACE FUNCTION <font color="green">average_transition</font> (state average_state, val numeric) <br> RETURNS average_state AS $$ <br> SELECT ROW(state.accum+val, state.qty+1)::average_state; <br> $$ LANGUAGE sql; <br></strong></code> <br>  It remains to recreate the unit with the new function and indicate that it can be safely used in parallel mode: <br><br> <code><strong>DROP AGGREGATE average(numeric); <br> CREATE AGGREGATE average(numeric) ( <br> --   <br> sfunc       = <font color="green">average_transition</font> , <br> stype       = <font color="green">average_state</font> , <br> finalfunc   = <font color="green">average_final</font> , <br> <font color="blue">combinefunc = average_combine</font> , <br> initcond   = '(0,0)', <br> --   ‚Äú‚Äù  <br> msfunc     = <font color="green">average_transition</font> , <br> minvfunc   = <font color="green">average_inverse</font> , <br> mstype     = <font color="green">average_state</font> , <br> mfinalfunc = <font color="green">average_final</font> , <br> minitcond   = '(0,0)', <br> --  <br> <font color="blue">parallel = safe</font> <br> ); <br></strong></code> <br>  Now create a table and fill it with data.  Thousands of lines will suffice. <br><br> <code><strong>CREATE TABLE t(n) AS SELECT generate_series(1,1000)::numeric; <br></strong></code> <br>  With the default settings, PostgreSQL does not build a parallel plan for such a table ‚Äî it‚Äôs too small ‚Äî but it‚Äôs easy to persuade: <br><br> <code><strong>SET parallel_setup_cost=0; <br> SET min_parallel_table_scan_size=0; <br></strong></code> <br> <code><strong>EXPLAIN(costs off) SELECT average(n) FROM t;</strong> <br> QUERY PLAN <br> ------------------------------------------ <br> Finalize Aggregate <br> -&gt;  Gather <br> Workers Planned: 2 <br> -&gt;  Partial Aggregate <br> -&gt;  Parallel Seq Scan on t <br></code> <br>  In terms of the request, we see: <br><br><ul><li>  two scheduled workflows that perform partial aggregation (Partial Aggregate), </li><li>  the Gather node collecting information </li><li>  and final state aggregation (Finalize Aggregate). </li></ul><br>  Check: <br><br> <code><strong>SELECT average(n) FROM t;</strong> <br> NOTICE:  0(0) &amp; 281257(678) <br> NOTICE:  281257(678) &amp; 127803(226) <br> NOTICE:  409060(904) &amp; 91440(96) <br> NOTICE:  = 500500(1000) <br> average <br> --------- <br> 500.5 <br> (1 row) <br></code> <br>  Why is the function average_combine called three times, not two?  The fact is that in PostgreSQL, the coordinating process also does some of the work.  Therefore, although two workflows were launched, the work was actually carried out in three.  One of them managed to process 678 lines, the other 226 and the third - 96 (although these figures mean nothing and may differ with another launch). <br><br><h3>  Oracle </h3><br>  If you remember, we already wrote the ODCIAggregateMerge function at the very beginning, since it is mandatory in Oracle.  Documentation insists that this function is necessary not only for parallel work, but also for sequential - although it is difficult for me to understand why (and in practice I did not have to deal with its execution during sequential processing). <br><br>  All that remains is to declare the function safe for parallel operation: <br><br> <code><strong>CREATE OR REPLACE FUNCTION average(val number) RETURN number <br> <font color="blue">PARALLEL_ENABLE</font> <br> AGGREGATE USING AverageImpl; <br> / <br></strong></code> <br>  Create a table: <br><br> <code><strong>CREATE TABLE t(n) AS SELECT to_number(level) FROM dual CONNECT BY level &lt;= 1000; <br></strong></code> <br>  To persuade Oracle is even easier than PostgreSQL - just write a hint.  Here is the plan that turns out (the output is heavily trimmed for simplicity): <br><br> <code><strong>EXPLAIN PLAN FOR SELECT /*+ PARALLEL(2) */ average(n) FROM t; <br> SELECT * FROM TABLE(dbms_xplan.display);</strong> <br> --------------------------------- <br> | Id  | Operation              | <br> --------------------------------- <br> |  0 | SELECT STATEMENT        | <br> |  1 |  SORT AGGREGATE        | <br> |  2 |  PX COORDINATOR        | <br> |  3 |    PX SEND QC (RANDOM)  | <br> |  4 |    SORT AGGREGATE      | <br> |  5 |      PX BLOCK ITERATOR  | <br> |  6 |      TABLE ACCESS FULL | <br> --------------------------------- <br></code> <br>  The plan also contains: <br><br><ul><li>  partial aggregation (4), </li><li>  coordinator receiving partial contexts (2), </li><li>  and the resulting union of contexts (1). </li></ul><br> <code><strong>SELECT /*+ PARALLEL(2) */ average(n) FROM t;</strong> <br> AVERAGE(N) <br> ---------- <br> 500.5 <br> 0(0) &amp; 216153(657) <br> 216153(657) &amp; 284347(343) <br> = 500500(1000) flags:0 <br></code> <br>  In Oracle, the coordinator does not participate in partial aggregation.  Therefore, only two contexts are combined, and for the same reason we see only the output of the ODCIAggregateMerge function. <br><br><h1>  Documentation </h1><br>  It's time to provide links to the documentation, including the aggregate and window functions already included in the DBMS.  There you can find a lot of interesting things. <br><br>  PostgreSQL: <br><br><ul><li>  <a href="https://postgrespro.ru/docs/postgresql/10/xaggr">Custom aggregate functions</a> </li><li>  <a href="https://postgrespro.ru/docs/postgresql/10/sql-createaggregate">CREATE AGGREGATE</a> </li><li>  Standard <a href="https://postgrespro.ru/docs/postgresql/10/functions-aggregate">aggregate</a> and <a href="https://postgrespro.ru/docs/postgresql/10/functions-window">window</a> functions </li></ul><br>  Oracle: <br><br><ul><li>  <a href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/addci/using-user-defined-aggregate-functions.html">Custom aggregate functions</a> </li><li>  <a href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/addci/user-defined-aggregate-functions-interface.html">Interface of aggregate functions</a> </li><li>  Standard <a href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/Aggregate-Functions.html">aggregate</a> and <a href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/Analytic-Functions.html">analytical</a> functions </li></ul><br><h1>  Example about rounding kopecks </h1><br>  And the promised example from life.  I came up with this function when I had to write reports for the accounting department working under RAS (the rules of Russian accounting). <br><br>  The simplest task in which the need for rounding arises is the distribution of total expenses (say, 100 rubles) into departments (say, 3 pieces) according to some principle (say, equally): <br><br> <code><strong>WITH depts(name) AS ( <br> VALUES ('A'), ('B'), ('C') <br> ), report(dept,amount) AS ( <br> SELECT name, 100.00 / count(*) OVER() FROM depts <br> ) <br> SELECT dept, round(amount,2) FROM report;</strong> <br> dept | round <br> ------+------- <br> A    | 33.33 <br> B    | 33.33 <br> C    | 33.33 <br> (3 rows) <br></code> <br>  This query shows the problem: the amount must be rounded, but a penny is lost.  But RAS does not forgive this. <br><br>  The task can be solved in different ways, but for my taste the most elegant way is the window function, which works in incremental mode and takes all the struggle with the pennies on itself: <br><br> <code><strong>WITH depts(name) AS ( <br> VALUES ('A'), ('B'), ('C') <br> ), report(dept,amount) AS ( <br> SELECT name, 100.00 / count(*) OVER() FROM depts <br> ) <br> SELECT dept, round2(amount) OVER (ORDER BY dept) FROM report;</strong> <br> dept | round2 <br> ------+-------- <br> A    |  33.33 <br> B    |  33.34 <br> C    |  33.33 <br> (3 rows) <br></code> <br>  The state of such a function includes a rounding error (r_error) and the current rounded value (amount).  The processing function of the next value increases the rounding error, and, if it already exceeds half a penny, adds a penny to the rounded amount: <br><br> <code><strong>state.r_error := state.r_error + val - round(val,2); <br> state.amount := round(val,2) + round(state.r_error,2); <br> state.r_error := state.r_error - round(state.r_error,2); <br></strong></code> <br>  And the function that produces the result simply returns the ready state.amount. <br><br>  I will not give the full code of the function: using the examples already given, it is not difficult to write it. <br><br>  If you have met some interesting examples of using your own aggregate or window functions - share them in the comments. </div><p>Source: <a href="https://habr.com/ru/post/351008/">https://habr.com/ru/post/351008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350996/index.html">Java and Project Reactor</a></li>
<li><a href="../351000/index.html">Find him if you can. How to select letters in the general stream</a></li>
<li><a href="../351002/index.html">Fantastic-Elasticsearch. How we "tamed" smart search through documents</a></li>
<li><a href="../351004/index.html">Organization of information systems production processes. Part 3. Implementation of the project solution</a></li>
<li><a href="../351006/index.html">How to notice DDOS in time: a monitoring service usage scenario for early detection</a></li>
<li><a href="../351012/index.html">Development of high-loaded WebSocket-service</a></li>
<li><a href="../351014/index.html">Batch image processing in Windows with ImageMagick. Part I</a></li>
<li><a href="../351016/index.html">Discover Nirvana - Yandex‚Äôs Universal Computing Platform</a></li>
<li><a href="../351018/index.html">JMeter 4.0. What's new?</a></li>
<li><a href="../351020/index.html">Why embedded developers should use static code analysis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>