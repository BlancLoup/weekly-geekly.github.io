<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular expression quantifiers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Regular expressions are arithmetic for algorithms. They are available in many programming languages, editors, and application settings. Like adding wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular expression quantifiers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/736/438/b06/736438b06bad0c1e0b42fb69e6ee71fb.png" alt="image" align="right">  Regular expressions are arithmetic for algorithms.  They are available in many programming languages, editors, and application settings.  Like adding with multiplication, they are easy to use. <br>  But for the proper and effective use of regexp-s, you need an understanding of how they work.  I will try to describe the principle of operation of regular expressions, show in what cases there are problems and how to solve them. <br><br>  In continuation of <a href="http://habrahabr.ru/blogs/regex/67158/">general advice</a> . <br><a name="habracut"></a><br>  I do not want to write a banal description of metacharacters or some kind of reference book.  I want to show those rakes that I remember.  To map their path to self-expression through regular structures.  And try to convey a certain way of thinking that naturally generates effective regexps. <br><br>  I repeat, but you can only learn from your own experience.  Therefore, if you have not written at least a dozen, it is better to have hundreds of regexps, I think that it is worth while just reading the documentation or books and experimenting. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For distinction and convenience, I have somewhat colored the regular expressions found in the text.  Blue - symbols, green - quantifiers, gray - brackets and other service symbols, chestnut - metacharacters, red - a point (so as not to be lost) and slashes that restrict the regular expression. <br><br><h3>  A bit of theory </h3><br>  I will not be a formalist and will try to describe the theoretical basis in simple words.  Those interested can find the exact <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">wiki</a> language. <br><br>  Regular expressions, in addition to the alphabet, have three properties: <ol><li><h5>  coupling, when two expressions a and b can concatenate to form an expression ab </h5>  In other words, the expression a is first executed, then, on the remaining line, the expression b.  We can say that between them as conditions, logical I. <br>  In the application, this gives us a very simple and basic method: we divide the search string into consecutive parts and for each we build our expression, and then we ‚Äúlink‚Äù - we simply write them in a row. <br></li><li><h5>  alternation, when two expressions a and b can, using the operator |  form the expression a | b </h5>  The difference with coupling is that between conditions a and b there is a logical OR, and the same string is used for testing. <br>  In the application, this allows us to easily add simple branches to the finished expression. <br></li><li><h5>  closure, when for the expression a * all variants are checked (empty), a, aa, aaa, ... and so on </h5>  In other words, we recursively try to apply the expression a, while it is applied.  In reality, the parser does just that and it causes performance problems, but this is discussed below, when, in fact, we will consider the work of quantifiers. <br></li></ol>  With its simplicity, regular expressions allow you to algorithmize a significant part of the tasks, primarily the text search.  It is only necessary to designate what we are looking for, add options and loop if necessary.  Clear? <br>  Fine!  But it is easy to make an expression that matches the template we need.  It is more difficult to modify it so that it would <u>not coincide</u> with the fact that we <u>do not need</u> . <br>  In this place the mentoring description should end with the words: Efficiency will come to you in time, young Padawan ... <br><br><h3>  Nothing like this ! </h3><br>  It is said that regular expressions appeared as the embodiment of the nervous system.  I do not know how true this is, but it is easy enough to learn how to think with regular expressions.  The key to this is hierarchy.  Imagine not just variants of the lines to be found, but a structure consisting of smaller elements.  And then the regular season is just a description of this structure. <br><br>  First you need to talk about the characters.  A character is a kind of minimal component of our structure, but a bare text consisting of <b>literal</b> characters must be distinguished and, for example, a string in some programming language: let the string be limited to quotes and escape using the special character is used to indicate the quotes inside the string or repetition.  Also, usually, it is possible to specify non-printing characters - line feed or tabulation.  All this extends literal characters to the character of a string.  And if it is necessary to disassemble a string, first of all it is necessary to climb this step - it is necessary to describe the characters of our alphabet. <br><br>  Let us have the escape character - "\".  Then the characters in the string are an alternation of ordinary characters "."  and screened "\.".  Here it must be said that in the alternation of expression are not equal, but have priority in the order of succession.  That is, if we write <font color="gray"><font color="red">.</font></font>  <font color="gray"><font color="maroon">|</font></font>  <font color="gray"><font color="blue">\.</font></font>  , then the point, like any character will always be, therefore we put it last: <font color="gray"><font color="blue">\.</font></font>  <font color="gray"><font color="maroon">|</font></font>  <font color="gray"><font color="red">.</font></font>  .  Having closed all this with the help of the quantifier * and concatenated with a quotation mark at the beginning and at the end, we get an expression to describe the string.  But there is another underwater stone - a point in the symbol sub-expression.  Although, given the priorities, the point is the last, the parser each time, seeing the options, put the so-called return points.  To which can return if the subsequent expression fails.  In some text, quotes can be unpaired and, not finding the last one, the parser will unscrew the expression backward at the return points.  If we encounter a screened quote, then the parser will break it down into two characters and, satisfied with this incorrect result, will continue to work.  From this we can draw a simple conclusion, true for all regulars, - the <b>uncertainty should be eliminated</b> .  In our case, it is simple - instead of a point, we put the character class <font color="gray">[ <font color="maroon">^</font> <font color="blue">\ "</font> ]</font> , removing all ambiguities. <br><br>  Do not forget that in the line that you give to the compiler or interpreter, some characters must also be escaped, so in the text of the program it will look like <blockquote><code><font color="red">/</font> <font color="gray"><font color="blue">"</font> <font color="gray">(</font> <font color="blue">\\</font> <font color="red">.</font> <font color="maroon">|</font> [ <font color="maroon">^</font> <font color="blue">\\</font> <font color="blue">"</font> ] <font color="gray">)</font> <font color="green">*</font> <font color="blue">"</font></font> <font color="red">/</font></code> </blockquote> <h3>  Make up the expression </h3><br>  Understanding and describing the characters, you can climb the hierarchy above, using a clutch or a closure and, if necessary, alternation. <br><br>  For example, to describe a URL, we must first break it apart: protocol, sometimes user and password, server name, file path, and so on.  After that, you need to divide the parts into elementary pieces, for example, the server name is the words, separated by a dot, while these words have their own allowed characters and the rightmost should be tld.  For each elementary part, you need to carefully write your alphabet of symbols and concatenate them into the expression for the structure of the next level. <br><br>  For example, the name consists of <font color="gray">[ <font color="blue">-</font> <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z0</font> <font color="maroon">-</font> <font color="blue">9</font> ] <font color="green">+</font></font> , separated by the point <font color="gray">[ <font color="blue">-</font> <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z0</font> <font color="maroon">-</font> <font color="blue">9</font> ] <font color="green">+</font> <font color="blue">\.</font></font>  <font color="gray">[ <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z</font> ] <font color="green">{2,4}</font></font> (in a more stringent case, the allowed tlds can be described on the right side: <font color="gray"><font color="blue">c</font> <font color="blue">o</font> <font color="blue">m</font> <font color="maroon">|</font> <font color="blue">n</font> <font color="blue">e</font> <font color="blue">t</font> <font color="maroon">|</font> <font color="blue">o</font> <font color="blue">r</font> <font color="blue">g</font> <font color="maroon">|</font> <font color="blue">r</font> <font color="blue">u</font> <font color="maroon">|</font> <font color="blue">i</font> <font color="blue">n</font> <font color="blue">f</font> <font color="blue">o</font></font> ), while on the left side be several levels of names through the point <font color="gray"><font color="gray">(</font> [ <font color="blue">-</font> <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z0</font> <font color="maroon">-</font> <font color="blue">9</font> ] <font color="green">+</font> <font color="blue">\.</font> <font color="gray">)</font> <font color="green">+</font> [ <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z</font> ] <font color="green">{2,4}</font></font> <br><br>  Protocol can be <font color="gray"><font color="blue">h</font> <font color="blue">t</font> <font color="blue">t</font> <font color="blue">p</font> <font color="blue">s</font> <font color="green">?</font></font>  <font color="gray"><font color="blue">:</font> <font color="blue">/</font> <font color="blue">/</font></font> or <font color="gray"><font color="blue">f</font> <font color="blue">t</font> <font color="blue">p</font> <font color="blue">:</font> <font color="blue">/</font> <font color="blue">/</font></font> , followed by the name <font color="maroon">\ w</font> <font color="green">+</font> and password <font color="red">.</font>  <font color="green">+?</font> <br><br>  together <blockquote> <code><font color="red">/</font> <font color="gray"><font color="gray">(</font> <font color="blue">h</font> <font color="blue">t</font> <font color="blue">t</font> <font color="blue">p</font> <font color="blue">s</font> <font color="green">?</font> <font color="blue">:</font> <font color="blue">\/</font> <font color="blue">\/</font> <font color="maroon">|</font> <font color="blue">f</font> <font color="blue">t</font> <font color="blue">p</font> <font color="blue">:</font> <font color="blue">\/</font> <font color="blue">\/</font> <font color="gray">(</font> <font color="maroon">\w</font> <font color="green">+</font> <font color="gray">(</font> <font color="blue">:</font> <font color="red">.</font> <font color="green">+?</font> <font color="gray">)</font> <font color="green">?</font> <font color="blue">@</font> <font color="gray">)</font> <font color="green">?</font> <font color="gray">)</font> <font color="gray">(</font> [ <font color="blue">-</font> <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z0</font> <font color="maroon">-</font> <font color="blue">9</font> ] <font color="green">+</font> <font color="blue">\.</font> <font color="gray">)</font> <font color="green">+</font> [ <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z</font> ] <font color="green">{2,4}</font></font> <font color="red">/</font></code> </blockquote>  and so on... <br><br>  in general, it is easy to describe the formal structures, since all the work has already been done before us, clearly specifying the fields, separators, and providing for variability.  The main thing is not to be mistaken with the necessary symbol :) <br><br>  I want to repeat the visiting truth - <b>premature optimization is harmful</b> .  Do not be lazy and repeat the block alternating, if you need a slightly different option.  Optional or duplicate parts must have ‚Äúanchors‚Äù - literal characters at the beginning or at the end.  If you add something - do not be lazy - disassemble the structure again, add the necessary and collect back.  An incomprehensible jumble inside an expression is the right path to error.  Check both for coverage and for ignoring unnecessary options.  And only then optimize.  And the best is not necessary - the expression is well structured and works quickly, although sometimes it looks scary and seemingly confusing. <br><br><h3>  Greedy quantifiers </h3><br>  There are several types of closures in modern regular expressions.  <i>Stephen Cole Kleene</i> , who introduced this concept, described two such: * and +.  As described above, their behavior is ‚Äúgreedy‚Äù - they are trying to cover all that is possible - to the end of the line.  But further in our expression is the next statement or symbol, and we are already at the end of the line.  Here the parser unscrews our quantifier back to the return points, until the condition of the subsequent subexpression is met. <br><br>  Obviously, this behavior easily causes performance problems.  Here are the lead times for several options: <br><img src="https://habrastorage.org/getpro/habr/post_images/a33/cd4/e4c/a33cd4e4c6ecfbf7bde21dfd474c772b.png" alt="image"><br><br>  The last case with two asterisks actually works an order of magnitude slower.  This is due to the feature of the parser.  As it was said, the expression ‚Äúany character many times‚Äù is performed verbatim and in fact the parser first covers the entire line with this expression, keeping a return point on each character.  Having seen that our expression is not finished, the parser returns back until it finds a match.  The presence of two asterisks increases the number of cusps by an order of magnitude, and three more by an order of magnitude.  It is easy to see that such a path can make ‚Äúsimple expression‚Äù noticeably slow. <br><br>  but there are several ways to improve efficiency: <ul><li><h5>  spacing with stop symbol </h5>  For example, if we are looking for tags from '&lt;' to '&gt;', then we can specify an interval instead of an arbitrary character: <blockquote> <code><font color="red">/</font> <font color="gray"><font color="blue">&lt;</font> [ <font color="maroon">^</font> <font color="blue">&gt;</font> ] <font color="green">+</font> <font color="blue">&gt;</font></font> <font color="red">/</font></code> </blockquote>  The parser will stop when it sees a character out of range and the subsequent literal character '&gt;' will immediately work. <br></li><li><h5>  use repetition interval {min, max} </h5>  It works well if we know how many characters there should be, for example during the initial verification of a uid or md5 signatures. </li></ul><h3>  Non-greedy or lazy quantifiers </h3><br>  At one time, Perl introduced this concept.  Such a quantifier acts the other way around - it covers the minimum set of characters and expands it if subsequent concatenated expressions are not executed. <br><br>  From a performance point of view, it works very well for nested optional expressions, but also like a greedy quantifier can cause a significant slowdown, because if in a good case (when our expression is executed) more or less quickly, in a bad case the parser tries to increase coverage for the non-greedy quantifier until it comes to an obvious end.  In order to avoid this, it is advisable to narrow down the covered symbols as much as possible at intervals and immediately after it put a simple expression - fixed symbols, for example. <br><br>  As I said, expressions with lazy quantifiers cover the smallest possible substring.  This allows you to simply avoid problems with excessive coverage, for example <blockquote> <code><font color="red">/</font> <font color="gray"><font color="blue">\(</font> <font color="red">.</font> <font color="green">+</font> <font color="blue">\)</font></font> <font color="red">/</font></code> </blockquote>  scoops up everything from the first to the last bracket in the text.  In the same time <blockquote> <code><font color="red">/</font> <font color="gray"><font color="blue">\(</font> <font color="red">.</font> <font color="green">+?</font> <font color="blue">\)</font></font> <font color="red">/</font></code> </blockquote>  stop at the first closing bracket. <br><br>  Why not a stop symbol?  Because it is not always possible to apply.  The next character can be complex or be part of a subexpression with a list or it is not possible to clearly define the border at all.  Also a lazy quantifier is effective if we know that there will be few characters.  I highly recommend putting lazy + and * after a point that matches an arbitrary character, otherwise the parser will walk to the end of the line.  But remember that the parser must specify where to stay. <br><br>  Compare the speed: <br><img src="https://habrastorage.org/getpro/habr/post_images/685/c28/904/685c2890432fadc97b82e7da1ff09cba.png" alt="image"><br><br>  Lazy "asterisks" and "pluses" have another drawback - they can and very often cover too few characters, unless the border is marked with a subsequent subexpression.  For example, if you make out words like this: <code><font color="maroon">\w</font> <font color="green">+?</font></code>  you may find that without a subsequent literal character (at the end of a large expression), this combination will cover only one letter and in this case the greedy option is more effective.  Also greedy is more effective if it is clearly known that the next character will be another <font color="gray"><font color="maroon">\ w</font> <font color="green">+</font></font> so you can describe a word or parameter, lazy here is just less effective. <br><br>  In addition to the lazy and greedy there are still <h3>  super greedy or jealous quantifiers </h3><br>  Their significant difference is that they do not roll back.  This property can be used if there is ambiguity.  True, again, ambiguity is the enemy of an effective regular expression.  I personally did not use them, although I have the opinion that you can safely put a jealous one in good expression instead of a greedy one.  A good, though not very vital example of applying a jealous quantifier is <a href="http://habrahabr.ru/blogs/regex/55863/">described in detail here</a> . <br><br><h3>  Finally </h3><br>  I will show a few bad cases from the code: <br><br>  <font color="gray"><font color="gray">(</font> <font color="maroon">\ w</font> <font color="green">*</font> <font color="gray">)</font> <font color="green">*</font></font> - the external greedy asterisk will simply not work. <br><br>  The most remarkable thing is that some parsers simply ignore such an expression - the loop protection will work. <br><br>  <font color="gray"><font color="gray">(</font> [ <font color="maroon">^</font> <font color="blue">&gt;</font> ] <font color="green">+</font> <font color="gray">)</font> <font color="green">*</font></font> - almost the same. <br><br>  According to the meaning, these are the insides of the tag after its name and they are not mandatory.  So + change to * and just remove the external <br><br>  <font color="gray"><font color="red">.</font></font>  <font color="gray"><font color="green">*</font> <font color="blue">;</font></font>  <font color="gray"><font color="green">?</font></font>  <font color="gray"><font color="red">.</font></font>  <font color="gray"><font color="green">*?</font></font>  <font color="gray"><font color="maroon">\ r</font> <font color="green">?</font></font>  - After the greedy * there are a number of optional characters. <br><br>  They will never matter, because the optional expressions for the parser are no reason to return and reduce the coverage of the greedy quantifier.  Most likely a victim of change.  After the first star, the rest can be simply removed. <br><br>  <font color="gray"><font color="blue">\.</font></font>  <font color="gray"><font color="gray">(</font> [ <font color="blue">a</font> <font color="maroon">-</font> <font color="blue">z</font> <font color="blue">\.</font> ] <font color="green">{2,6}</font> <font color="gray">)</font></font> - separator inside the structure. <br><br>  Just saying that it will cover for example a few points instead of tld, as intended. <br><br><h3>  In continuation </h3><ul><li>  metacharacters \ s \ d \ w \ b and unicode </li><li>  subtleties multiline </li><li>  positioning and preview </li><li>  ... and other </li></ul></div><p>Source: <a href="https://habr.com/ru/post/68345/">https://habr.com/ru/post/68345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../68334/index.html">Architectural tools in Visual Studio 2010</a></li>
<li><a href="../68335/index.html">ngxv8</a></li>
<li><a href="../68337/index.html">Creeping muck, or about problems with a single database of a single application</a></li>
<li><a href="../68338/index.html">Airsoft: A little bit about everything</a></li>
<li><a href="../68341/index.html">Git on fingers (for transferring from SVN)</a></li>
<li><a href="../68347/index.html">Time to envy Australian students (Digital Education Revolution - a laptop for learning)</a></li>
<li><a href="../68348/index.html">Full review of Snow Leopard. Part 1</a></li>
<li><a href="../68349/index.html">Full review of Snow Leopard. Part 2</a></li>
<li><a href="../68350/index.html">Setting up a DNS server on FreeBSD</a></li>
<li><a href="../68352/index.html">Intel predicts netbook sales boom</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>