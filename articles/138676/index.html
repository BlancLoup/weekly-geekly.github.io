<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monads in Python in detail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 In the past topic, I tried to portray the Maybe monad using Python tools. In general, the task was achieved, it seems to me, but it would...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monads in Python in detail</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br>  In the <a href="http://habrahabr.ru/blogs/python/138546/">past topic,</a> I tried to portray the Maybe monad using Python tools.  In general, the task was achieved, it seems to me, but it would be difficult for a person completely unfamiliar with the subject to understand what was happening, and most importantly - why.  This time I will try to dwell on the monads in more detail, including to consolidate my own understanding. <br><a name="habracut"></a><br><br>  The material will largely repeat the individual chapters of the book <a href="http://learnyouahaskell.com/">Learn you a Haskell for great Good</a> , but through the lens of my understanding and within the framework of the Python language.  I highly recommend the book itself for reading, even if you don‚Äôt have such a task in your plans - write in Haskell: it will broaden the horizons considerably.  I'll start, perhaps. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Context </h4><br>  Quite often, data that is processed by programs is in some context.  For simplicity, you can imagine it in the form of a box in which data is stored (although the ‚Äúboxed‚Äù analogy is not entirely accurate, and <i>sometimes</i> even inapplicable, but for now we will try to stick to it).  For example, the list is quite similar to the box in which the elements lie.  And the list forms a certain context - many operations designed to work with list items work with elements as if they are obsessed with boxes, and not just as they are with data.  The box for the data stored in the fields is the object to which these fields belong.  A tree built on related objects is a container for data stored in its branches / leaves. <br>  In OOP, it is customary to encapsulate data of an object inside it, and access is recommended to be provided through object methods.  Methods of working with data objects are difficult to unify for objects of different classes, at least in the general case, but for objects that can be speculatively presented in the form of a context (‚Äúbox‚Äù) in which the data are located, this is quite feasible. <br>  Sometimes you need to apply a simple function to the data, which can be quite versatile to work with simple data types, but is unable to work with the data inside the ‚Äúbox‚Äù. <br>  Example: there is a felt-tip pen and a box with paper on it, to put the marker into the box through the hole and there is no point in trying to draw something there.  The logical solution: get the data out of the box, apply a function to it, and put it back. <br>  So, if the box has a mechanism for applying the function to the content, our ‚Äúbox‚Äù becomes a <b>functor</b> . <br><br><h4>  Functors </h4><br>  So a functor is an implementation of a certain context in which the data is located, and you can get to this data, apply a function to it, and put it back into the context.  Moreover, the function requires only the ability to work with the data itself, but not with the context. <br><br>  We implement the following prototype class: <br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Infixable)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">''' '''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError() <span class="hljs-comment"><span class="hljs-comment">#    - </span></span></code> </pre> <br>  While you do not need to pay attention to the ancestor (Infixable), you can still be considered the ancestor of object. <br>  The mechanism for applying a function to data inside a functor is the fmap method. <br><br>  By the way, the list in Python is the most that is not a functor, and the mechanism for applying a function to the contents of a list is map ().  map (abs, [-2, -1,0,1,2]) is the extraction of list items, applying a function to each, and putting it back into the list. <br>  Imagine the list as a functor: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Functor)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *items)</span></span></span><span class="hljs-function">:</span></span> super(List, self).__init__() self._items = items <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, func)</span></span></span><span class="hljs-function">:</span></span> self._items = map(func, self._items) <span class="hljs-comment"><span class="hljs-comment">#     - , .. map() return self @property def result(self): return self._items</span></span></code> </pre><br>  Now you can do this: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> List(<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>).fmap(abs).fmap(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x*<span class="hljs-number"><span class="hljs-number">2</span></span>).fmap(str).result [<span class="hljs-string"><span class="hljs-string">'4'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'4'</span></span>]</code> </pre><br><br>  In Haskell, the type system allows you to implement the Functor type class, and all data types belonging to this class (and they can belong to and usually belong to several type classes).  The type class method in use looks like a regular function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> abs [<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br>  This is a bit more aesthetic, but the Python version is applicable. <br><br>  Now we can apply the normal function to the data in the context.  But we may want to apply a function to the data in the context, which is also in the context (in the same way as the data).  Those.  and the function above the data and the data are in context: both the pen and the pieces of paper in one box.  You need to get a marker, get a piece of paper, draw, put the result back.  If our box can do this, it is an <b>applicative functor</b> . <br><br>  Here we digress and implement one auxiliary class, namely Infixable (the one that stands in the ancestors of the Functor).  And he needs to implement the possibility of using infix notation.  so <br><br><h4>  Infix notation </h4><br>  Normal Python infix notation for user-defined functions cannot be obtained - the syntax is frozen.  And sometimes you really want to implement something like: <br><pre> <code class="python hljs">(/*/) = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: (x + y) * (x - y) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> /*/ <span class="hljs-number"><span class="hljs-number">4</span></span> /*/ <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Alas, no way.  I wrote a class that allows you to use infix notation for object methods.  The class itself: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Infixable</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> INFIX_OPS = [{}] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._last_is_opcode = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> self._op = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> table = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sub_table <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.INFIX_OPS: table.update(sub_table) self._op_table = table <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__add__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._last_is_opcode: method = getattr(self, self._op_table[self._op]) method(val) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self._op = val self._last_is_opcode = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._last_is_opcode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self</code> </pre><br>  In this class, the "+" operator is overloaded, and the whole salt is contained in the INFIX_OPS class attribute.  If a certain MyObj, a descendant of Infixable, implements the mmm (self, value) method and complements INFIX_OPS with a dictionary like {'/ * /': 'mmm', ...}, this form of writing a sequence of operations on an instance will be possible: <br><pre> <code class="python hljs">obj = MyObj() +<span class="hljs-string"><span class="hljs-string">'/*/+ 1 +'</span></span>/*/<span class="hljs-string"><span class="hljs-string">'+ 2 +'</span></span>/*/<span class="hljs-string"><span class="hljs-string">'+ 3</span></span></code> </pre><br>  Not very nice, but it works.  Can then find an alternative. <br><br><h4>  Applicative Functors </h4><br>  So, we need to implement taking functions and data out of the box, applying the function to the data and putting them back, and we get an applicative functor.  We implement a suitable class.  Moreover, our ancestor will have an ordinary functor, because it is not bad to be able to draw on our pieces of paper and with an external felt-tip pen.  So, the class: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Applicative</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Functor)</span></span></span><span class="hljs-class">:</span></span> INFIX_OPS = Functor.INFIX_OPS + [{ <span class="hljs-string"><span class="hljs-string">'&lt;*&gt;'</span></span>: <span class="hljs-string"><span class="hljs-string">'applicate'</span></span> }] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError()</code> </pre><br>  The descendants of this class will receive the applicate method (value) and the infix operator for it '&lt;*&gt;'. <br>  Replace the ancestor of Applicant with the above described <b>List</b> class and add the implementation of the new method.  This will require the auxiliary function of lowering the list nesting level ([[a, b], [c, d]] -&gt; [a, b, c, d]).  Function and class: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lists)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x + y, lists, []) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Applicative)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-comment"><span class="hljs-comment">#      List,  Functor def applicate(self, value): # value -    ( -  ) self._items = _concat([ map(fn, value._items) for fn in self._items ]) return self</span></span></code> </pre><br>  Now you can do this: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>List(str).applicate(List(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>)).result [<span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3'</span></span>, <span class="hljs-string"><span class="hljs-string">'4'</span></span>, <span class="hljs-string"><span class="hljs-string">'5'</span></span>]</code> </pre><br>  Here we have in context a function that we apply to data in the context of the same (listed). <br>  But, and this is the most interesting, you can do this (at the same time we apply infix notation): <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ( ... List(str, abs) +<span class="hljs-string"><span class="hljs-string">'&lt;*&gt;'</span></span>+ List(<span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">-20</span></span>) ... ).result [<span class="hljs-string"><span class="hljs-string">'-10'</span></span>, <span class="hljs-string"><span class="hljs-string">'-20'</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>]</code> </pre><br>  We obtained the results of applying all functions to all parameters.  And it is possible and so: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> y: x + y <span class="hljs-comment"><span class="hljs-comment">#   &gt;&gt;&gt; mul = lambda x: lambda y: x * y #   &gt;&gt;&gt; print ( ... List(add, mul) +'&lt;*&gt;'+ List(1, 2) +'&lt;*&gt;'+ List(10, 100) ... ).result [11, 101, 12, 102, 10, 100, 20, 200]</span></span></code> </pre><br>  First, all functions of the two arguments are applied to all first arguments.  Functions are curried and return functions of the second argument that apply to all second arguments! <br><br>  Now we are able to put functions in context and apply to values ‚Äã‚Äãin context: on each piece of paper in a box we draw each felt-tip pen out of the box, alternately taking out markers that are removed only after we draw on each piece of paper. <br><br>  Now imagine a situation: we want to implement streaming production of drawings.  Suppose we have input sheets, they are placed in a box to get the initial context.  Further, each workplace on the line is a function that can take an object, previously taken out of the box, do something with it and put it in a new box (context).  The function itself does not take data from the box, because  He does not know how to choose them correctly, and it is simpler to do that - they have given it and process it, but to put it in a new empty box - you don‚Äôt need a lot of mind. <br>  It turns out that each operation is interface-standardized: the extracted data -&gt; processing -&gt; box with the results.  We only need to implement the retrieval of data from the previous box and apply functions to it to get a new box. <br>  A function that takes a normal value and returns the result in a context ( <b>monadic value</b> ) is called a <b>monadic function</b> .  And an applicative functor that can take a simple value and pass through a chain of monadic functions is a <b>monad</b> . <br><br><h4>  Monads </h4><br>  Prototype monad class: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Applicative)</span></span></span><span class="hljs-class">:</span></span> INFIX_OPS = Applicative.INFIX_OPS + [{ <span class="hljs-string"><span class="hljs-string">'&gt;&gt;='</span></span>: <span class="hljs-string"><span class="hljs-string">'bind'</span></span>, <span class="hljs-string"><span class="hljs-string">'&gt;&gt;'</span></span>: <span class="hljs-string"><span class="hljs-string">'then'</span></span>, }] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError() @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError()</code> </pre><br>  Monad provides 2 methods bind (&gt;&gt; =) and then (&gt;&gt;). <br>  bind () takes a value out of context, passes a monad function, which returns the next value in the context (monad value). <br>  then () discards the previous monad value, calls the function with no arguments, which returns the new monad value. <br><br><h4>  Monad List </h4><br>  Now we see the complete implementation of the <b>List monad</b> : <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lists)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x + y, lists, []) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Monad)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *items)</span></span></span><span class="hljs-function">:</span></span> super(List, self).__init__() self._items = items <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, func)</span></span></span><span class="hljs-function">:</span></span> self._items = map(func, self._items) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_value)</span></span></span><span class="hljs-function">:</span></span> self._items = _concat([ map(fn, monad_value._items) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fn <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self._items ]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_func)</span></span></span><span class="hljs-function">:</span></span> self._items = _concat(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: monad_func(x)._items, self._items)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_func)</span></span></span><span class="hljs-function">:</span></span> self._items = monad_func()._items <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._items liftList = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> fn: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: List( *(fn(x)) )</code> </pre><br>  liftList ‚Äúpulls in‚Äù a normal function into context: a ‚Äúpulled in‚Äù function returns a monad value <br><br>  And here is an example of using the list as a monad: the task is to check whether it is possible to reach the second specified point from exactly one point on the chess board in exactly 3 knight moves. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  ,       raw_jumps = lambda (x, y): List( (x + 1, y + 2), (x + 1, y - 2), (x - 1, y + 2), (x - 1, y - 2), (x + 2, y + 1), (x + 2, y - 1), (x - 2, y + 1), (x - 2, y - 1), ) #  ,     if_valid = lambda (x, y): List( (x, y) ) if 1 &lt;= x &lt;= 8 and 1 &lt;= y &lt;= 8 else List() #          jump = lambda pos: List(pos) +'&gt;&gt;='+ raw_jumps +'&gt;&gt;='+ if_valid # ,        #     3   in3jumps = lambda pos_from, pos_to: pos_to in ( List(pos_from) +'&gt;&gt;='+ jump +'&gt;&gt;='+ jump +'&gt;&gt;='+ jump ).result print in3jumps((3,3), (5,1)) #  print in3jumps((3,3), (5,2)) # </span></span></code> </pre><br><br><h4>  Monad Maybe </h4><br>  The Maybe monad implements a context in which a monadic value characterizes one of two states: <br>  - the previous step was completed successfully, with some value (just x) <br>  - the previous step failed (nothing) <br><br>  In this case, the sequence of calculations in the context of the monad. Maybe is a sequence of steps, each of which is based on the result of the previous one, and any step can fail unsuccessfully, which means that the entire sequence has failed.  In the context of Maybe, if at any step an unfortunate result is obtained, the subsequent steps are skipped as meaningless. <br>  As a functor, Maybe, using fmap, will apply a function to a value, if there is a value, there is no value (bad result) - there‚Äôs nothing to apply the function to, well, it doesn‚Äôt apply! <br><br>  If the function is inside the Maybe context and the arguments are inside Maybe (Maybe, as an applicative functor), then the function will be applied if it is and is all the arguments, otherwise the result will immediately fail. <br><br>  Maybe monad class: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Maybe</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Monad)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, just=None, nothing=False)</span></span></span><span class="hljs-function">:</span></span> super(Maybe, self).__init__() self._just = just self._nothing = nothing <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._nothing: self._just = func(self._just) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._nothing: <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> isinstance(monad_value, Maybe) app_nothing, just = monad_value.result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> app_nothing: self._nothing = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self._just = self._just(just) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._nothing: monad_value = monad_func(self._just) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> isinstance(monad_value, Maybe) nothing, just = monad_value.result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nothing: self._nothing = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self._just = just <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, monad_func)</span></span></span><span class="hljs-function">:</span></span> monad_value = monad_func() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> isinstance(monad_value, Maybe) self._nothing, just = monad_value.result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._nothing: self._just = just <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (self._nothing, self._just) just = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: Maybe(just=x) nothing = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: Maybe(nothing=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) liftMaybe = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> fn: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: just(fn(x))</code> </pre><br><br>  just (x) and nothing () are just abbreviations for easier creation of the corresponding monadic values.  liftMaybe - ‚Äúpulling in‚Äù the context of Maybe. <br><br>  Examples of use as a functor and applicative functor: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(maybe)</span></span></span><span class="hljs-function">:</span></span> nothing, just = maybe.result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nothing: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Nothing!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Just: %s"</span></span> % just <span class="hljs-comment"><span class="hljs-comment"># ==== Maybe as functor ==== showMaybe( just(-3).fmap(abs) ) # ==== Maybe as applicative functor ==== add = lambda x: lambda y: x+y #   -   showMaybe( nothing() +'&lt;*&gt;'+ just(1) +'&lt;*&gt;'+ just(2) ) #      -   showMaybe( just(add) +'&lt;*&gt;'+ nothing() +'&lt;*&gt;'+ just(2) ) showMaybe( just(add) +'&lt;*&gt;'+ just(1) +'&lt;*&gt;'+ nothing() ) #    -    showMaybe( just(add) +'&lt;*&gt;'+ just(1) +'&lt;*&gt;'+ just(2) )</span></span></code> </pre><br><br>  I will give an example of using Maybe as a monad.  A ropewalker walks a rope with a pole, but birds like to sit on a pole, and then they can fly away.  A tightrope walker can keep balance if the difference in the number of birds on the sides of a pole is no more than 4. Well, the tightrope walker can simply fall off slipping on a banana peel.  It is necessary to simulate a simulation of a sequence of events with the output of the result in the form of "fell" / "did not fall."  Code: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      to_left = lambda num: lambda (l, r): ( nothing() if abs((l + num) - r) &gt; 4 else just((l + num, r)) ) #      to_right = lambda num: lambda (l, r): ( nothing() if abs((r + num) - l) &gt; 4 else just((l, r + num)) ) #   banana = lambda x: nothing() #   def show(maybe): falled, pole = maybe.result print not falled #   begin = lambda: just( (0,0) ) show( begin() +'&gt;&gt;='+ to_left(2) +'&gt;&gt;='+ to_right(5) +'&gt;&gt;='+ to_left(-2) #    ) show( begin() +'&gt;&gt;='+ to_left(2) +'&gt;&gt;='+ to_right(5) +'&gt;&gt;='+ to_left(-1) ) #      show( begin() +'&gt;&gt;='+ to_left(2) +'&gt;&gt;='+ banana #    +'&gt;&gt;='+ to_right(5) +'&gt;&gt;='+ to_left(-1) )</span></span></code> </pre><br><br><h5>  Instead of epilogue </h5><br>  Similarly, you can implement other known monads, or some of their own. <br>  You can only make a functor, but, for example, for a tree on related objects. <br><br><h5>  Note </h5><br>  I deliberately did not touch on the topic of monad laws, it is important, but the topic is already voluminous.  There will be something to tell next time. <br><br><h5>  Changed </h5><br>  Thanks to the <a href="http://habrahabr.ru/blogs/python/138676/%3Freply_to%3D4634118">comment</a> (thanks, funca), I resolved the contradiction regarding the values ‚Äã‚Äãreturned by monad functions in the context of the List monad.  Now they must return exactly the List instance as a result. <br><br><h5>  A new version </h5><br>  <a href="https://bitbucket.org/astynax84/python/src/36c7224d8d4ac8a3ca6121fea1d3d51fad1457c4/monads.py">Lies here</a> . <br>  Description of the changes: <br>  - The possibility of infix notation is removed - it looks very bad <br>  - Functors and monads methods now return new context values, rather than changing the inplace context. <br>  - Monad List is now a list heir.  So the monad result is also a list.  So  it is possible to write changing monad functions returning a list.  Only one generating function at the beginning of the monad sequence is necessary and sufficient. </div><p>Source: <a href="https://habr.com/ru/post/138676/">https://habr.com/ru/post/138676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138670/index.html">Wireless HD-video and sound transmission over Wi-Fi, digest - spring'12</a></li>
<li><a href="../138672/index.html">Canonical introduced Ubuntu for Android (UPD)</a></li>
<li><a href="../138673/index.html">Simple productivity methods for freelancer</a></li>
<li><a href="../138674/index.html">Page Object - the path to perfect autotests</a></li>
<li><a href="../138675/index.html">Rating increase in wages in the IT-sphere</a></li>
<li><a href="../138678/index.html">Using bat files to create scheduled tasks</a></li>
<li><a href="../138679/index.html">AirPush Phishing: Security Tips</a></li>
<li><a href="../138680/index.html">LTE from Yota in Moscow since April 15</a></li>
<li><a href="../138682/index.html">What's wrong with GNU make?</a></li>
<li><a href="../138684/index.html">Virtual functions in C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>