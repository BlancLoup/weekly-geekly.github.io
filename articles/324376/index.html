<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exceptions in Windows x64. How it works. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Based on the material described in the first and second parts of this article, we will continue to discuss the topic of exception handling in Windows ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exceptions in Windows x64. How it works. Part 3</h1><div class="post__text post__text-html js-mediator-article">  Based on the material described in the <a href="https://habrahabr.ru/company/aladdinrd/blog/321868/">first</a> and <a href="https://habrahabr.ru/company/aladdinrd/blog/322956/">second</a> parts of this article, we will continue to discuss the topic of exception handling in Windows x64. <br><br>  The described material requires knowledge of basic concepts, such as the prologue, epilogue, frame functions and understanding of basic processes, such as the actions of the prologue and epilogue, the transfer of function parameters and the return of the result of the function.  If the reader is not familiar with the above, then before reading it is recommended to read the material from the first part of this article.  Also, if the reader is not familiar with the PE image structures that are involved in the processing of an exception, then before reading it is also recommended to get acquainted with the material from the second part of this article. <br><a name="habracut"></a><br>  The given description refers to the implementation in Windows, and, therefore, one should not assume that the implementation of this mechanism attached to the article will exactly coincide with it, although there is no conceptual difference.  Details of the attached implementation in the article will not be considered, if this is not stated explicitly.  Therefore, it is assumed that these details, if necessary, should be studied independently. <br><br>  The article is accompanied by the implementation of the mechanism, which is located in the exceptions folder of the git repository at <a href="">this address</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  1. Exceptions and their processing </h2><br>  In the following subsections, the handling of the exception and everything that underlies it will be discussed in detail.  The given description refers to the implementation in Windows, and, therefore, one should not assume that the implementation of this mechanism attached to the article will exactly coincide with it, although there is no conceptual difference.  Details of the attached implementation in the article will not be considered, if this is not stated explicitly.  Therefore, it is assumed that these details, if necessary, should be studied independently. <br><br><h3>  1.1.  Secondary functions </h3><br>  Before starting to discuss the exception handling process, consider the RtlLookupFunctionEntry and RtlVirtualUnwind functions that are exported by the ntoskrnl.exe module in kernel space and the ntdll.dll library in user space. <br><br>  The RtlLookupFunctionEntry function, whose prototype is shown in Figure 1, returns a pointer to the RUNTIME_FUNCTION structure and the address of the beginning of the PE image corresponding to the code whose address is passed in the ControlPc parameter. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/191/13d/1df/19113d1dfd66499ebf84dbd067e59f05.png"></div><br>  <i>Picture 1</i> <br><br>  The ImageBase parameter accepts a pointer to the variable where the function returns the address of the beginning of the PE image, and the HistoryTable parameter, which is optional, accepts a pointer to the structure that is used to cache the search.  The format of the structure of the last parameter can be found in winnt.h.  If the function returns NULL, either the corresponding PE image could not be found by the passed code pointer, or no corresponding record was found in the function table, which may mean that the function does not have a frame. <br><br>  The RtlVirtualUnwind function, the prototype of which is shown in Figure 2, performs a virtual promotion function. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/188/914/37f/18891437f6884fd79b0fa50191074936.png"></div><br>  <i>Figure 2</i> <br><br>  It is called virtual because the function does not change the state of the physical processor, and instead takes in the ContextRecord parameter a pointer to a structure that describes the context of the processor at a particular point in time.  The context of the processor after the promotion returns to the same structure.  The CONTEXT structure itself is depicted below in Figure 3. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/d17/394/3a8/d173943a86e94d5e9679ae554d0bcd04.png"></div><br>  <i>Figure 3</i> <br><br>  The P1Home-P6Home fields are introduced for ease of use of the structure, for example, they can be used as a region of register and stack parameters.  The ContextFlags field is bit-wise and describes the state of the entire structure, i.e.  which fields reflect the state of the corresponding processor registers, and which ones do not.  The field may contain the following flags: <br><br><ul><li>  CONTEXT_CONTROL - if set, the SegSs, Rsp, SegCs, Rip, and EFlags fields reflect the state of the corresponding processor registers; <br></li><li>  CONTEXT_INTEGER - if set, the Rax, Rcx, Rdx, Rbx, Rbp, Rsi, Rdi, and R8-R15 fields reflect the state of the corresponding processor registers; <br></li><li>  CONTEXT_SEGMENTS - if set, the fields SegDs, SegEs, SegFs and SegGs reflect the state of the corresponding processor registers; <br></li><li>  CONTEXT_FLOATING_POINT - if set, the fields Xmm0-Xmm15 and MxCsr reflect the state of the corresponding processor registers; <br></li><li>  CONTEXT_DEBUG_REGISTERS - if set, the fields Dr0-Dr3 and Dr6-Dr7 reflect the state of the corresponding processor registers. </li></ul><br>  It should be noted that the ContextFlags field is not interpreted in any way by the RtlVirtualUnwind function, and it always assumes that the structure contains the actual state of the processor at a particular point in time.  Since the VectorRegister, VectorControl, DebugControl, LastBranchToRip, LastBranchFromRip, LastExceptionToRip, and LastExceptionFromRip fields are not directly related to the topic under discussion, their purpose will not be described here.  The FltSave field is used when it is necessary to save the state of the full XMM context, including the state of the FPU. <br><br>  The ImageBase parameter takes the address of the PE image whose code was executed.  The ControlPc parameter carries the address of the instruction where execution was interrupted, and the FunctionEntry parameter accepts the address of the RUNTIME_FUNCTION structure corresponding to the address of the instruction. <br><br>  The HandlerType parameter takes the type of handler expected.  If the value is UNW_FLAG_EHANDLER and the function being spun has an exception handler, the function returns the address of this exception handler.  If the value is UNW_FLAG_UHANDLER and the function being spun has a spinup handler, the function returns the address of this spinup handler.  In all other cases, the function returns NULL.  It should also be noted that if the execution of the unwind function was interrupted at the moment of execution of the prolog code or the epilog code, the function returns NULL.  The philosophy here is that the exception and / or promotion handler is attached to the function body.  If the function returns the address of one of the handlers, then it also returns the address of the data associated with this handler by the compiler of the corresponding programming language.  The address is returned by the pointer passed in the HandlerData parameter.  As described in Section 3 of the second part of this article, the address of the exception handler and / or unwind handler is stored in the ExceptionHandlerAddress field of the EXCEPTION_HANDLER structure when data associated with the handler is stored in the LanguageSpecificData field of the same structure. <br><br>  The EstablisherFrame parameter takes a pointer to a variable where the function returns the frame pointer before the function is unwound.  The ContextPointers parameter is optional and, if used, contains the address of the structure that repeats the contents of general registers and XMM registers after promotion.  It should be noted that only the registers that participated in the promotion fall into the structure. <br><br>  Below, in Figure 4, an example of how the function works. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/393/e3f/3e6/393e3f3e6f034873828f913e6b9f3f44.png"></div><br>  <i>Figure 4</i> <br><br>  On the left is an example of an image that contains three functions: wmain, func2, and func1.  The wmain function calls the func2 function, which in turn calls func1.  The middle shows the assembler views of each of the functions, where the left shows the absolute address of the instruction in memory, the middle value of the RSP before executing the instruction, when the assembler mnemonic of the instruction itself is to the right.  The RSP values ‚Äã‚Äãare not depicted for all instructions, but only for those that were executed or for an instruction whose execution of the thread was interrupted.  To the right of assembler representations of functions, the value of processor registers is shown before calling the corresponding functions, for brevity, only general registers and the instruction pointer register (RIP) are given.  Labels indicate the values ‚Äã‚Äãof the parameters that are passed to the function or returned by it. <br><br>  The RtlVirtualUnwind function spins exactly one function, i.e.  the contents of the CONTEXT structure after executing the function will become such that the function being spun is not called, with the exception that the values ‚Äã‚Äãof the non-permanent registers will not be restored, and the RIP will contain a pointer not to the instruction to call the corresponding function, but to the instruction immediately after it.  Also, the function RtlVirtualUnwind will return the frame pointer of the untwisted function, and, if required, a pointer to its handler and a pointer to the data of this handler. <br><br>  As reflected in the example, the ImageBase parameter will be 0x7FF6AEAF000 (label 1);  ControlPc will be equal to 0x7FF6AEAF104E (label 2);  the FunctionEntry parameter will contain the address of the RUNTIME_FUNCTION structure (label 3) corresponding to the address of the instruction whose value is passed in the ControlPc parameter;  The ContextRecord parameter will contain the register values ‚Äã‚Äãof the interrupted function (label 4).  A pointer to the RUNTIME_FUNCTION structure can be obtained using the RtlLookupFunctionEntry function.  The function RtlVirtualUnwind after execution returns: the values ‚Äã‚Äãof the registers after promotion (label 5);  from the EXCEPTION_HANDLER structure, returns the address in the LanguageSpecificData field to the HandlerData parameter and returns a pointer to the handler that is extracted from the ExceptionHandlerAddress field of the same structure (label 6);  the function will also return the frame pointer of the untwisted function to the EstablisherFrame parameter and its value will be 0x9C5DBCF900. <br><br>  The function RtlVirtualUnwind, before unwinding, determines whether the processor performed a prologue, epilogue, or body of an unwound function.  If it was a body, then spin is performed using the UNWIND_INFO structure.  If it was a prologue, the spinup is also performed, with the exception that the function first determines in which place the execution of the prologue was interrupted, and it is from this point that the spinup is performed.  If it was an epilogue, then for version 2 of the UNWIND_INFO structure, promotion is performed from it.  Also, as in the case of the prologue, before promotion, the function determines in which place the execution of the epilogue was interrupted, and the promotion is performed from this place.  For version 1 of the UNWIND_INFO structure, unwinding is performed by analyzing the subsequent instructions of the epilogue, since  The UNWIND_INFO structure of this version does not contain any information about the epilogue.  Section 1 of the first part of this article mentioned that the beginning of the epilogue of functions described by the structures of UNWIND_INFO version 1 are considered <font color="green">add rsp, constant</font> or <font color="green">lea rsp, [frame pointer + constant]</font> instructions.  The fact is that XMM instruction analysis complicates the code of the spin function, and if an exception occurs before the conditional epilogue, then their values ‚Äã‚Äãwill be restored from the UNWIND_INFO structure, therefore the integrity of these registers is not damaged after unwinding.  The only side effect is when an exception occurs at the time the XMM registers are restored, in which case the RtlVirtualUnwind function will return a pointer to the exception handler, which will therefore be called when the exception is processed.  For the functions described by the UNWIND_INFO version 2 structures, this philosophy has slightly changed, and the instructions for pushing general registers out of the stack have been considered the beginning of the epilog, since  instructions <font color="green">add rsp, constant and lea rsp, [frame pointer + constant]</font> cannot raise exceptions in principle.  Figure 5 shows an example of a code, to the right of which an assembler representation of its two functions is shown: func1 and func2.  The instruction addresses are absolute, and for compactness, their hexadecimal representation is missing.  As an example, consider the promotion of the stack function func1.  The figure shows three cases: A, B, C. Each of them represents the state of performance of the function: A - prologue, B - body, C - epilogue. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/315/7aa/319/3157aa3197364aa383d1727d5ce3797c.png"></div><br>  <i>Figure 5</i> <br><br>  Below, in Figures 6-8, each case is considered separately.  On the left, the processor registers are shown before promotion, and on the right, after.  For compactness, only general registers and the instruction pointer register (RIP) are shown, since  in the cases described, only these registers are subject to change. <br><br>  Figure 6 shows Case A. In this case, the processor performed the prolog of the function func1, whose execution was interrupted with the RDI register pushing instruction.  Promotion of the stack in this case will be performed using the data structure UNWIND_INFO.  First, the RSI register value is restored, then the return address is restored.  Therefore, the RSI, RSP, RIP registers will be changed. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/8ee/b19/27b/8eeb1927b93f491eb0101a216973e502.png"></div><br>  <i>Figure 6</i> <br><br>  Figure 7 shows Case B. In this case, the processor executed the body of the function func1, whose execution was interrupted by an 8-byte read instruction from the top of the stack to the RAX register.  Promotion of the stack in this case will be performed using the data structure UNWIND_INFO.  First, the stack memory allocated by the prologue for the local variables of the function will be released, then the values ‚Äã‚Äãof the RDI and RSI registers will be restored, then the return address will be restored.  Therefore, the RSI, RDI, RSP, RIP registers will be changed. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/cc9/28c/d04/cc928cd040af4f6c9deb2172c98c4361.png"></div><br>  <i>Figure 7</i> <br><br>  Figure 8 shows case C. In this case, the processor executed the epilog of func1, the execution of which was interrupted on the instruction to eject the RDI register.  Depending on the version of the UNWIND_INFO structure, spinning will be performed either by using the structure itself, if it is a version 2 structure, or by analyzing the epilogue code, if it is a structure of version 1. First, the values ‚Äã‚Äãof the RDI and RSI registers will be restored, then the return address will be restored.  Therefore, the RSI, RDI, RSP, RIP registers will be changed. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/111/2a6/b84/1112a6b849d94bd3ae949c5df3a12ce6.png"></div><br>  <i>Figure 8</i> <br><br>  The ControlPc parameter for case A will be equal to 0x7FF70C131036, for case B, 0x7FF70C13104E, for case C, 0x7FF70C131078.  The ImageBase parameter for all three cases will be equal to 0x7FF70C130000. <br><br>  The EstablisherFrame parameter for case A will take the value 0x6DE73AF6E0, for case B, 0x7E68EFF860, for case C, 0x979BB9FAD8.  In all three cases, this will be the value of the RSP register before unwinding.  Consider separately the values ‚Äã‚ÄãEstablisherFrame for a function that has a frame pointer.  Figure 9 shows an example of such a function, where the addresses of instructions are absolute, and instead of their hexadecimal representation, the stack pointer (RSP) is shown before the instruction is executed. <br><br><div style="text-align:center;"><img hspace="5" src="https://habrastorage.org/files/20c/6a7/3c6/20c6a73c6bf3406a9017a577764647c8.png"></div><br>  <i>Figure 9</i> <br><br>  If the function was interrupted before executing the instruction at 0x7FF6D76C1101, then EstablisherFrame will take the value 0x9E84B9FAA0.  If execution was interrupted before executing the instruction at 0x7FF6D76C110A, then EstablisherFrame will take the value 0x9E84B9FA90.  If execution was interrupted before executing the instruction at 0x7FF6D76C1118, then EstablisherFrame will also take the value 0x9E84B9FA90.  It should be noted that if the function has a frame pointer, as in this example, and it was set before the function was interrupted, EstablisherFrame will take the value of the stack pointer at the time the frame pointer is set, not the current stack pointer.  In this example, the installation of the frame pointer was performed by the instruction at the address 0x7FF6D76C1106. <br><br><h2>  2. Processing </h2><br>  The whole process of exception handling can be divided into two parts. <br><br>  The first part is finding and calling the exception handler.  This part is performed by the operating system.  The conceptual scheme of exception handling is shown below in Figure 10. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/1d3/0a4/ccf/1d30a4ccff0a4117ab65e3f8ee7ae864.png"></a> </div><br>  <i>Figure 10</i> <br><br>  The figure above shows the space of the whole process.  The user space is shown on the left, while the kernel space is on the right.  In each of the spaces are placed modules.  For any application, the ntdll.dll module is always displayed, which performs the necessary auxiliary tasks for the user space.  In kernel space, ntoskrnl.exe is always present, which is the core of Windows.  The remaining modules are shown for example only.  When an exception occurs, the processor calls a function from the corresponding gateway descriptor, which is an element of the Interrupt Descriptor Table.  This function is a kernel function.  For more information on the interrupt table, see the Intel 64 and IA-32 Architectures Software Developer's Manual.  Further, this function together with the KiExceptionDispatch function prepares all the necessary data for processing, after which the KiDispatchException function is called, which performs additional actions before processing, one of which is that if an exception occurred in user space, then the processing of this exception is redirected to the user space. space.  The ntdll.dll module is responsible for processing in user space.  When all the necessary preparation for processing is done, the RtlDispatchException function is called, which performs a search and a call for the handler by scanning the .pdata of the image sections, and if the handler is found, then the function calls it.  It should also be noted that the function does not unwind the stack, it only performs a search for a handler. <br><br>  The second part depends on the format of the LanguageSpecificData field of the EXCEPTION_HANDLER structure generated by the compiler of the corresponding programming language and the implementation of the found exception handler relying on this field. <br><br>  In this article, we look at the try / except and try / finally constructs of C / C ++, therefore, when describing the second part, we will discuss the format of the LanguageSpecificData field of the EXCEPTION_HANDLER structure generated by the compiler for these constructions. <br><br>  In the following subsections, the entire process of preparing and searching for a processor is described in more detail.  For the sake of certainty and simplification of the explanation, the whole process will be considered on the example of the processing of the dividing by zero exception, and the code that generated this exception will be the kernel mode code.  Despite the fact that the whole explanation will be limited to an example of a specific exception, the description described will also be relevant for other exceptions, since  if they do not repeat the exclusion of division by zero, they are very similar and conceptually behave the same way. <br><br><h3>  2.1 Preparation for processing </h3><br>  As it was already indicated earlier, when an exception occurs, the processor calls the function from the corresponding gateway descriptor, which is an element of the interrupt descriptor table.  The function of the divide-by-zero gateway is the KiDivideErrorFault kernel function.  Figure 11 below shows the assembler representation of the function.  For brevity, only that part of the code that is directly related to the topic under discussion is displayed. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/ced/808/7c6/ced8087c658146bb8ae3239e7a5704ba.png"></a> </div><br>  <i>Figure 11</i> <br><br>  As can be seen from the figure, the function first simulates an empty error code, since  to avoid dividing by zero, the processor does not push the code onto the stack.  Next, the function pushes the general-purpose registers, allocates memory on the stack, and sets the frame pointer.  This is where the function prologue ends.  Saving non-persistent general-purpose registers and XMM registers is performed in the function body.  The function also stores in the stack variable the type of the called handler.  The value 1 is always set for exceptions, 0 for interrupts and 2 for services, i.e.  call kernel services from user space.  The last action of the function is a call to the KiExceptionDispatch function.  Before calling, the function also resets the direction flag, saves the MXCSR register of the XMM block, and then loads it with the standard value.  This will be discussed in more detail below.  Please note that the function does not have an epilog.  The fact is that the work of the thread, after processing the exception, does not resume in the usual way, i.e.  KiExceptionDispatch does not return a control, and therefore, an epilog is not needed.  After the instruction of the function call follows the idle instruction.  This is the so-called placeholder.  It is assigned a special role, its presence allows the RtlVirtualUnwind function to reliably determine that an exception occurred during the execution of the function body.  That is, if there is no such placeholder, then the RtlVirtualUnwind function, when promoting the KiExceptionDispatch function, retrieves the return address of the <font color="green">retn</font> instruction, instead of the <font color="green">nop</font> instruction.  And, therefore, at the next iteration of the spinup (that is, when the KiDivideErrorFault function is already spinning), the RtlVirtualUnwind function will analyze whether the prologue, epilogue, or body was executed.  As it was already noted in section 1 of the first part of this article, whether the epilog was performed is determined by the code of the function itself (or using records like UWOP_EPILOG, the UNWIND_INFO version 2 structure, which does not make a big difference, because in this case it plays a role the address of the instruction, not the stream of code bytes), and since the <font color="green">retn</font> instruction is used only in epilogs, the RtlVirtualUnwind function will make the erroneous assumption that the epilogue was being executed, and not the body.  Consequently, this will lead to the fact that during the promotion of the KiDivideErrorFault function, the prologue will not be promoted, and the address of the frame following the stack above the function will be incorrectly determined. <br><br>  The MXCSR XMM block register was not mentioned in Section 3 of the first part of this article, but call conventions also regulate its use when calling functions.  This register is divided into a permanent and non-permanent part, as shown in Figure 12 below. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/91b/9c3/d90/91b9c3d90927477fb1f5fea8dd068d49.png"></a> </div><br>  <i>Figure 12</i> <br><br>  The non-constant part consists of 6 state flags, bits 0-5.  The rest of the register, consisting of control bits c 6-15, is considered constant.  If the called function changes the state of the constant part, then it must restore it before returning.  Moreover, the calling function, before calling other functions, must load the standard values ‚Äã‚Äãinto the permanent part, if it has been changed.  The standard values ‚Äã‚Äãof the fields of the constant part: <br><br><ul><li>  Bit 6 is 0: the denormal operands are zeros; <br></li><li>  Bits 7-12 are 1: all exceptions are masked; <br></li><li>  Bits 13-14 are 0: round to the nearest; <br></li><li>  Bit 15 is 0: resetting the result to zero at the bottom overflow. </li></ul><br>  These rules can be violated only in two cases: <br><br><ol><li>  if the purpose of the function is to change the constant part of the register; <br></li><li>  if the violation of these rules does not lead to a change in the behavior of the program, i.e.  the program will behave as if the rules were not violated. </li></ol><br>  The state of the nonconstant part should not be interpreted in any way on the border of functions, i.e.  a called function should not rely on its values, and the calling function after returning control to it, unless explicitly indicated in the function description. <br><br>  As for the direction flag (DF), its default value is 0. If the flag has been set, then it must be reset before calling the function or before returning from the function. <br><br>  The KiExceptionDispatch function takes 8 parameters.  ECX contains the exception code that occurred;  EDX is the number of parameters specific to this exception;  R8 contains the address of the instruction that generated the exception;  registers R9, R10, R11 contain the values ‚Äã‚Äãof the parameters characteristic of this exception;  RBP and RSP are pointers to stored non-persistent registers.  As noted earlier, the function does not return control.  Below, in Figure 13, an assembly representation of the function is shown.  For brevity, only those parts of the code that are directly related to the topic under discussion are given. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/f32/a5d/2fa/f32a5d2fabc446f383807df0863f6826.png"></a> </div><br>  <i>Figure 13</i> <br><br>  As can be seen from the figure, the function prolog first allocates memory in the stack, after which the constant XMM registers and general-purpose registers are saved.  This is where the function prologue ends.  Next, the function initializes the EXCEPTION_RECORD structure in the memory area allocated in the stack and calls the KiDispatchException function.  After returning from a function, the following are restored: permanent general registers, permanent XMM registers, MXCSR register, non-permanent general registers and non-permanent XMM registers.  Next, the stack memory allocated by the gateway function (in this example, the memory allocated by the KiDivideErrorFault function) is released, and it is returned to the interrupted flow.  The EXCEPTION_RECORD structure is defined below in Figure 14. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/bf7/848/773/bf7848773aa4460eb5c05238b3c2ce1d.png"></a> </div><br>  <i>Figure 14</i> <br><br>  The ExceptionCode field contains the exception code.  The ExceptionFlags field is a bit field and describes the type and state of the exception handling.  Its flags will be discussed in detail in the process of discussing the search and call handler, as well as in the process of discussing the promotion of the stack.  The ExceptionRecord field in some cases contains a pointer to another structure of the same type.  For example, if during the search for an exception handler or a spinup handler, an invalid situation was detected (for example, the handler returned an invalid processing result), then a new exception will be thrown, the EXCEPTION_RECORD structure of which will contain a pointer to the EXCEPTION_RECORD structure for the exception in the context of which this situation occurred.  In other cases, the field is NULL.  It should be noted that this statement is true for 32-bit versions of Windows, and in 64-bit versions it is almost always NULL.  The ExceptionAddress field contains the address of the instruction that raised the exception.  The NumberParameters field contains the number of parameters in the ExceptionInformation array that are specific to the specific type of exception, and the definition of EXCEPTION_MAXIMUM_PARAMETERS is 15, i.e.  this is the maximum number of parameters for all types of exceptions. <br><br>  The KiDispatchException function takes 5 parameters: ExceptionRecord - a pointer to an EXCEPTION_RECORD structure describing the reason for the exception;  NonvolatileRegisters - pointer to permanent registers;  VolatileRegisters - pointer to non-permanent registers;  PreviousMode - context of the thread in which the exception occurred (user or kernel context);  FirstChance - the first processing attempt (TRUE or FALSE).  The function returns no value. <br><br>  ExceptionRecord describes the reason for the exception.  VolatileRegisters is formed by the gateway function (in this example, the KiDivideErrorFault function).  NonvolatileRegisters is generated by the KiExceptionDispatch function.  It should also be noted that both structures contain not only the values ‚Äã‚Äãof the registers at the time of the exception, but also other multi-sort information, which will not be discussed in this article, since  It is not directly related to the topic under discussion.  PreviousMode carries information about the context in which the exception occurred, and is equal to either KernelMode or UserMode.  FirstChance is a boolean value indicating whether this attempt to handle the exception is the first one. <br><br>  The KiDispatchException function is responsible for handling the exception without involving the exception handlers themselves, if possible.  Also, if an exception occurred in user space, then the exception handling is redirected to it.  A simplified block diagram of the function is shown in Figure 15 below. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/277/719/1dc/2777191dc12a43a68f3e5e45969ae043.png"></a> </div><br>  <i>Figure 15</i> <br><br>  As shown in the figure, at the beginning of its work, the function forms a CONTEXT structure from the structures pointed to by NonvolatileRegisters and VolatileRegisters, and the fields reflecting processor registers that are not contained in these structures (for example, segment registers) are initialized with standard values.  Therefore, this structure will reflect the values ‚Äã‚Äãof the processor registers at the time of the exception. <br><br>  The function then tries to handle the exception using the KiPreprocessFault function, without involving exception handlers.  If the exception cannot be handled, then if it originated in the context of the kernel, the function calls the RtlDispatchException function, which searches for and calls the handler. <br><br>  After the RtlDispatchException function has completed its work, and since the fields of the CONTEXT structure could be changed by exception handlers, the fields of this structure are copied back to the structures pointed to by NonvolatileRegisters and VolatileRegisters via the KeContextToKframes function, thus modifying the context of the interrupted flow. <br><br>  If an exception occurred in a user context, the function does not call the handlers for security reasons, and instead, the function copies the RSP and RIP values ‚Äã‚Äãwhen an exception occurs to the user stack, copies the EXCEPTION_RECORD and CONTEXT structures to the user stack, and modifies the engine frame so that when returning from the function, control was transferred to the user mode handler. <br><br>  A pointer to a user mode handler is registered at the time of system initialization.  The function responsible for handling exceptions in a user context is located in the ntdll.dll library called KiUserExceptionDispatch.  Although a custom exception handler is called for user space, it is very similar to the kernel mode handler, and therefore no further explanation is needed regarding its operation. <br><br><h3>  2.2 Search and call handler </h3><br>  As mentioned earlier, the RtlDispatchException function searches and calls the handler.  The function takes two parameters: ExceptionRecord - a pointer to the EXCEPTION_RECORD structure describing the reason for the exception;  ContextRecord is a pointer to a CONTEXT structure that describes the state of the processor registers at the time of the exception.  The function returns a boolean value, TRUE if the exception was processed, and FALSE otherwise. <br><br>  The RtlDispatchException function performs a sequential scan on the stack of called functions.  If the function has a handler, then the RtlDispatchException function calls it.  If the handler returns ExceptionContinueExecution, then the RtlDispatchException function stops, otherwise the search for the handler continues.  Below, in Figure 16, is a block diagram of the function. <br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/510/76b/be4/51076bbe4459431e94c8b34fb4626515.png"></a> </div><br>  <i>Figure 16</i> <br><br>  At the beginning of the function, the function receives the lower and upper limits of the stack.  Since, when the exception handler is called, it is passed a pointer to the structure that describes the processor state at the moment the exception occurred, and since the function performs virtual stack promotion during the search, the contents of the transferred CONTEXT structure will change, and therefore the function copies its contents to its local variable. <br><br>  Next, the function generates the initial value of the ExceptionFlags field for the EXCEPTION_RECORD structure.  It should be noted that the field of the transmitted structure may contain the EXCEPTION_NONCONTINUABLE flag set, which means that it is not possible to continue the execution of the interrupted thread.  Therefore, the function, when initializing the initial value, copies this flag from the passed structure to a local variable.  The function then zeroes the function's frame pointer, the exception handler of which, in the course of its execution, raised the exception (that is, the nested exception) and copies the address of the instruction that generated the exception into the local variable from the transmitted EXCEPTION_RECORD structure. <br><br>  Further, the function, using the RtlLookupFunctionEntry function, obtains the address of the PE image and a pointer to the RUNTIME_FUNCTION structure of the function of this image, during the execution of which an exception occurred.  If the function does not return a pointer, then it is considered that an exception occurred during the execution of a simple function, which, as discussed earlier, do not have any information about promotion.  Since  simple functions do not allocate memory in the stack, their RSP value will point to the return address, therefore, for such functions, the RtlDispatchException function retrieves this address, copies its value in the Rip field of the local CONTEXT structure, and increases the value of the Rsp field of the same structure by 8, way simulating the promotion of a simple function.  Now the contents of the local CONTEXT structure describe the state of execution of the next function in the stack above.  Further, the function from the local CONTEXT structure copies into the local variable the address of the instruction belonging to the function already next in the stack above, and checks with the RtlpIsFrameInBounds function that the new RSP pointer is within the stack limit.  If the pointer goes beyond these limits, it means that the exception handler was not found, and therefore the RtlDispatchException function will return FALSE.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, the function will continue its work, starting with obtaining the address of the PE image and a pointer to the RUNTIME_FUNCTION structure, for the address of the new instruction, already for the next function above the stack.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For personnel functions, the RtlLookupFunctionEntry function will return a pointer to the RUNTIME_FUNCTION structure. In this case, promotion of such functions is performed using the RtlVirtualUnwind function, which returns the frame pointer for the untwisted function. Immediately after the promotion, it checks that the frame pointer is within the stack limit. If the frame pointer goes beyond these limits, then the RtlDispatchException function sets the EXCEPTION_STACK_INVALID flag in the ExceptionFlags field of the passed CONTEXT structure and returns FALSE. Otherwise, if the RtlVirtualUnwind function did not return a pointer to the exception handler for the untwisted function, the RtlDispatchException function will continue promotion of the next function above the stack, after copying the address of the instruction belonging to this function,and checking the value of the Rsp field of the local CONTEXT structure to exceed the stack limit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the RtlVirtualUnwind function returns a pointer to an exception handler, then the RtlDispatchException function will call it. </font><font style="vertical-align: inherit;">Before calling it, the function will update the contents of the ExceptionFlags field of the passed EXCEPTION_RECORD structure from its local copy. </font><font style="vertical-align: inherit;">The exception handler was first discussed in Section 3 of the second part of this article, and its prototype is shown in Figure 5. Before calling the handler, the function prepares the DISPATCHER_CONTEXT structure, which is actively used in cases of nested exceptions and active unwind. </font><font style="vertical-align: inherit;">The structure definition is shown below in Figure 17.</font></font><br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/4fc/631/69d/4fc63169d6b444ed97f1744f598d56a1.png"></a> </div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 17</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ControlPc field contains the address belonging to the function body for which the handler was called. The ImageBase field contains the address of the beginning of the PE image, which contains the function and its handler. The FunctionEntry field contains the address of the RUNTIME_FUNCTION structure of the same function. The EstablisherFrame field contains a function frame pointer. The TargetIp field is used in the promotion, and will be discussed in detail when discussing it. The ContextRecord field contains a pointer to a CONTEXT structure that reflects the current search state of the processor, i.e. pointer to the local variable of the function RtlDispatchException. The LanguageHandler field contains the address of the handler being called. The HandlerData field contains an address for data specific to the corresponding programming language. The HistoryTable field contains a pointer to the search cache table.The ScopeIndex field contains the current value of a local variable of the RtlDispatchException function, and its purpose will be discussed in detail when discussing promotion. The Fill0 field is not used at all and is present for alignment purposes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The RtlDispatchException function does not call the exception handler directly, and instead uses the helper function RtlpExecuteHandlerForException, which takes the same parameters as the handler itself, and also returns the same value. This function is actually a wrapper around the function of the exception handler and is used to catch the exceptions that occurred during the execution of the exception handler itself. The assembler representation of the function is shown below in Figure 18.</font></font><br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/77b/7fa/185/77b7fa18596f4661a0cb75aa5e735ccc.png"></a> </div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 18</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As shown in the figure, the function first allocates memory in the stack for register variables and one variable, stores a pointer to the structure passed to DISPATCHER_CONTEXT in this variable and calls the exception handler whose address is stored in the LanguageHandler field of the DISPATCHER_CONTEXT structure. Also note the presence of a function body placeholder. In addition to the reasons for its necessity described earlier, another one is added to them: since the exception handler is tied to the function body, it will not be called if there is no placeholder, and therefore, the RtlDispatchException function will be additionally violated for this reason. The assembler representation of the exception handler function is shown below in Figure 19.</font></font><br><br><div style="text-align:center;"> <a href=""><img hspace="5" src="https://habrastorage.org/files/a72/2bb/1fb/a722bb1fb5cb47c8baf06ea058b5708f.png"></a> </div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 19</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As shown in the figure, first the handler checks whether promotion is performed, and if it is executed, the function returns ExceptionContinueSearch, thereby giving the unwind function an indication that the search handler will continue searching. Otherwise, the search for the exception handler was performed, during which another exception occurred and you need to copy the frame pointer of the function whose handler generated the new exception into the DISPATCHER_CONTEXT structure of the current search handler process.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the DISPATCHER_CONTEXT structure has been prepared, the RtlDispatchException function calls the exception handler. Immediately after calling the handler, the function sets the EXCEPTION_NONCONTINUABLE flag in its local copy of the flags if it was set in the passed to the EXCEPTION_RECORD structure by the handler. Next, the function resets the EXCEPTION_NESTED_CALL flag in the local copy and resets the frame pointer for the function, the exception exception handler of which, during its execution, raised an exception if the frame pointer of this function coincides with the previously fixed one. The following describes the corresponding actions of the functions depending on the result.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the handler returned ExceptionContinueSearch, the function will continue promotion of the next function above the stack, first copying the address belonging to this function and checking the value of the Rsp field of the local CONTEXT structure to exit the stack limit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the handler returns ExceptionContinueExecution, the function will immediately stop its operation and return TRUE. Preliminarily, the function checks that the EXCEPTION_NONCONTINUABLE flag is not set, otherwise the function will raise an STATUS_NONCONTINUABLE_EXCEPTION exception.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the handler returned ExceptionNestedException, it means that another, incomplete search process of the exception handler was found in the search process, in the context of which a new exception occurred. In this case, the EstablisherFrame field of the DISPATCHER_CONTEXT structure will contain a pointer to the frame of the function whose exception exception handled the exception. As mentioned above, this value copies the exception handler of the RtlpExecuteHandlerForException function there. The RtlDispatchException function will set the EXCEPTION_NESTED_CALL flag for the ExceptionFlags field, and also update the frame pointer of the function whose handler threw the exception. This value will be updated only if the current pointer value is 0 (there were no nested exceptions), or the EstablisherFrame field of the DISPATCHER_CONTEXT structure contains a function frame pointer,which is stack higher than the function in the context of which a new exception occurred.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the handler returned ExceptionCollidedUnwind, this means that an active promotion was detected during the search process, in the context of which an exception occurred. This case will be described in more detail when describing stack promotion; here it is only necessary to indicate that in response to this result, the RtlDispatchException function will update the DISPATCHER_CONTEXT structure and the local CONTEXT structure so that the search for the handler will be resumed from where it was interrupted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all other cases, the RtlDispatchException function throws a STATUS_INVALID_DISPOSITION exception.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned in section 2, the whole process can be divided into two parts, and we have fully considered the first. </font><font style="vertical-align: inherit;">In the </font></font><a href="https://habrahabr.ru/company/aladdinrd/blog/326878/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next part of the article,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the second part will be considered, which includes promotion of the stack and the principle of operation of try / except and try / finally blocks.</font></font></div><p>Source: <a href="https://habr.com/ru/post/324376/">https://habr.com/ru/post/324376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324366/index.html">Tracking js errors with Metrics</a></li>
<li><a href="../324368/index.html">How to choose NGFW or what manufacturers keep back?</a></li>
<li><a href="../324370/index.html">Set method</a></li>
<li><a href="../324372/index.html">How and why static analyzers deal with false positives</a></li>
<li><a href="../324374/index.html">CEPH for pumping</a></li>
<li><a href="../324378/index.html">We bring business to the international market in 5 minutes</a></li>
<li><a href="../324380/index.html">Hard Prioritization</a></li>
<li><a href="../324382/index.html">Fine Rust state machines</a></li>
<li><a href="../324384/index.html">Intel SGX Extensions Tutorial. Part 7, revision of the enclave</a></li>
<li><a href="../324388/index.html">React + mobx path from scratch. Mobx + react, side view</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>