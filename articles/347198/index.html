<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust: swing the tape and parsing JSON</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I'll show you how to write a small program that downloads a feed ( feed ) in JSON format, parses and prints a list of notes to the console in a format...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust: swing the tape and parsing JSON</h1><div class="post__text post__text-html js-mediator-article"><p>  I'll show you how to write a small program that downloads a feed ( <em>feed</em> ) in JSON format, parses and prints a list of notes to the console in a formatted format. </p><br><p>  We have all resulted in a very concise code.  How?  Look under the cut. </p><a name="habracut"></a><br><h2 id="skachaem-rust">  Download Rust </h2><br><p> The usual way to download Rust is to download it to your computer using <strong>rustup</strong> .  Check to <code>rustup</code> already available in the repository of your distribution. </p><br><p>  <code>rustup</code> manages <em>toolchains of</em> development utilities.  It allows you to change the version of Rust used, manage additional development tools, such as RLS, and download development utilities for different platforms. </p><br><p>  When you have Rust installed, type the following command: </p><br><pre> <code class="hljs pgsql">rustup install <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span></code> </pre> <br><p>  For this example, we need to use at least Rust version 1.20, because it requires some dependencies. </p><br><p>  Let's see what we have. </p><br><p>  This command has installed: </p><br><ul><li>  <strong>rustc</strong> compiler </li><li>  <strong>cargo</strong> - package manager and project builder </li><li>  documentation </li><li>  some other tools. </li></ul><br><p>  To view the documentation in your browser, type <code>rustup doc</code> . </p><br><h2 id="nastroyka-proekta-cargo">  Project Setup: <code>cargo</code> </h2><br><p>  <code>cargo</code> manages Rust projects.  We want to build a small executable file, so we tell <code>cargo</code> that we need to build a program, not a library: </p><br><pre> <code class="hljs swift">cargo <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> --bin readrust-cli</code> </pre> <br><p>  This command will create a <code>readrust-cli</code> . </p><br><p>  Let's see what is in this directory: </p><br><pre> <code class="hljs pgsql">. |<span class="hljs-comment"><span class="hljs-comment">-- Cargo.toml |-- src |-- main.rs</span></span></code> </pre> <br><p>  You will notice that the project has a simple structure: it contains only the code of our program ( <code>src/main.rs</code> ) and ( <code>Cargo.toml</code> ).  Let's see what is contained in <code>Cargo.toml</code> : </p><br><pre> <code class="hljs pgsql">[package] <span class="hljs-type"><span class="hljs-type">name</span></span> = "readrust-cli" version = "0.1.0" authors = ["Florian Gilcher &lt;florian.gilcher@asquera.de&gt;"] [dependencies]</code> </pre> <br><p>  Currently the configuration file contains some descriptive information about the project.  Notice that the <code>dependencies</code> section is <code>main.rs</code> empty, and <code>main.rs</code> contains a small "hello world" by default. </p><br><p>  Run: </p><br><pre> <code class="hljs ruby">$ cargo run Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> secs Running <span class="hljs-string"><span class="hljs-string">`target/debug/readrust-cli`</span></span> Hello, world!</code> </pre> <br><p>  Fine.  Everything is working.  <code>cargo run</code> itself launched the <code>rustc</code> compiler, compiled the program and then launched it.  <code>cargo</code> can also detect any changes we have made to the code and recompile them. </p><br><h2 id="a-teper-pristupim">  Now let's get started! </h2><br><p>  We plan the course of our actions in advance.  We want to write a utility with which you can interact via the command line interface. </p><br><p>  On the other hand, we want to solve our problem and not do extra work. </p><br><p>  What do we need: </p><br><pre> <code class="hljs 1c">*     * HTTP- <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   *  JSON <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">.</span></span></code> </pre> <br><p>  Regarding the set of features, I want to add a little flexibility, enough to get started: </p><br><ul><li>  the program will accept <code>--count</code> , which tells the program to display the number of notes in the tape </li><li>  the program will accept <code>--number [NUMBER]</code> , which specifies the number of notes that the program should output. </li></ul><br><h2 id="clap">  CLAP </h2><br><p>  - stands for <code>command line argument parser</code> . <br>  It was easy, wasn't it?  CLAP has extensive documentation, and we will only use a little functionality. </p><br><p>  First, we must add the <code>clap</code> package as a dependency. </p><br><p>  To do this, we must specify the name and version in <code>Cargo.toml</code> : </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] clap = <span class="hljs-string"><span class="hljs-string">"2.29"</span></span></code> </pre> <br><p>  If you run <code>cargo build</code> , <code>clap</code> will be compiled with our program.  In order to use CLAP, we have to specify Rust that we use the library ( <code>crate</code> in the terminology of Rust).  We must also add the types we use to the namespace.  CLAP has a very user-friendly API, which gives us the ability to configure as deeply as we need it. </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> clap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> clap::App; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = App::new(<span class="hljs-string"><span class="hljs-string">"readrust"</span></span>) .version(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>) .author(<span class="hljs-string"><span class="hljs-string">"Florian G. &lt;florian.gilcher@asquera.de&gt;"</span></span>) .about(<span class="hljs-string"><span class="hljs-string">"Reads readrust.net"</span></span>) .args_from_usage(<span class="hljs-string"><span class="hljs-string">"-n, --number=[NUMBER] 'Only print the NUMBER most recent posts' -c, --count 'Show the count of posts'"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> matches = app.get_matches(); }</code> </pre> <br><p>  The next step is to compile and run the program, specifying the option <code>--help</code> , in order to get the instruction message: </p><br><pre> <code class="hljs pgsql">readrust <span class="hljs-number"><span class="hljs-number">0.1</span></span> Florian G. &lt;florian.gilcher@asquera.de&gt; Reads readrust.net <span class="hljs-keyword"><span class="hljs-keyword">USAGE</span></span>: readrust [FLAGS] [<span class="hljs-keyword"><span class="hljs-keyword">OPTIONS</span></span>] FLAGS: -c, <span class="hljs-comment"><span class="hljs-comment">--count Show the count of posts -h, --help Prints help information -V, --version Prints version information OPTIONS: -n, --number &lt;NUMBER&gt; Only print the NUMBER most recent posts</span></span></code> </pre> <br><p>  Good!  A couple of simple lines, and here we already have a full instruction on the use of our program. </p><br><h2 id="poluchenie-neobhodimoy-informacii">  Getting the necessary information </h2><br><p>  In order to test our program, we need the necessary material. </p><br><p>  Wrap this into a function with the following signature: </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_feed</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// implementation }</span></span></code> </pre> <br><p>  One of the good HTTP clients is <code>reqwest</code> .  There is also a <code>hyper</code> from the same author.  Hyper is a more "low-level" library, while <code>reqwest</code> allows <code>reqwest</code> to solve "let's do it quickly" tasks. </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] reqwest = <span class="hljs-string"><span class="hljs-string">"0.8"</span></span></code> </pre> <br><p>  This function is implemented quite simply: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> reqwest; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> URL: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"http://readrust.net/rust2018/feed.json"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_feed</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = reqwest::Client::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> request = client.get(URL); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> resp = request.send().unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(resp.status().is_success()); resp.text().unwrap() }</code> </pre> <br><p>  This is very similar to how you would do it in other programming languages: create a client that allows us to make requests. </p><br><p>  Calling <code>send()</code> , we make a request and get an answer. <br>  Calling <code>text()</code> on the response, we get it as a string. </p><br><p>  Pay attention to the word <strong>mut</strong> .  In Rust, mutable variables are declared this way.  By sending a request and receiving a response, we change the internal state <br>  of the request object, so it must be mutable. </p><br><p>  Finally, <strong>unwrap</strong> and <strong>assert</strong> . <br>  Sending a request or reading a response is an operation that can fail, for example, the connection is broken. </p><br><p>  Therefore, send (sends the request) and <code>text</code> ("reads" the response) returns a <code>Result</code> object. </p><br><p>  Rust expects us to analyze the contents of the returned object and <br>  take the necessary action.  <code>unwrap</code> leads to a panic ( <strong>panic</strong> ) - the program is terminated, but before that it ‚Äúcleans up‚Äù the used memory behind it. </p><br><p>  If there was no error, we get the required value.  The request may be successful in the sense that the server responded, but the HTTP return code is not <code>200 SUCCESS</code> (Internal Server Error?). </p><br><p>  <code>assert</code> prevents us from reading the contents of the response from a request that failed. </p><br><p>  In many scripting languages ‚Äã‚Äãin this place, we would get an unhandled exception ( <em>exception</em> ), which leads to a similar effect. </p><br><p>  <strong>There are no exceptions in Rust</strong> - instead we use <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2582%25D0%25B8%25D0%25BF_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">ADT</a> (like <code>Maybe</code> in Haskell). </p><br><p>  Do not be afraid to use <code>unwrap</code> often during your training. </p><br><p>  You will learn how to use other tools later. </p><br><h2 id="razbor-json-podklyuchaem-serde">  JSON parsing: we connect <code>serde</code> </h2><br><p>  Now we need to parse the JSON tape. <br>  To do this, Rust has a <code>serde</code> library for (se / des) implementation. <br>  <code>serde</code> supports not only JSON, but also other formats. <br>  <code>serde</code> also provides convenient ways to <br>  job serializable types, the so-called <code>derive</code> 's. </p><br><p>  For this reason, we need to add the following 3 dependencies: <br>  <code>serde</code> , <code>serde_derive</code> , <code>serde_json</code> . </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] serde = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span> serde_derive = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span> serde_json = <span class="hljs-string"><span class="hljs-string">"1.0"</span></span></code> </pre> <br><p>  <code>serde_json</code> gives you the opportunity to handle JSON in two ways: to parse a string in a JSON tree or to inform the <code>Serde</code> structure of the expected information. <br>  The second method is much faster and more convenient. <br>  Looking at the definition of the <em>feed</em> , we see that there are 3 main types: </p><br><ul><li>  the authors </li><li>  items </li><li>  tape </li></ul><br><p>  Ribbon and elements have the author. </p><br><p>  Make changes to the code: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Deserialize, Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Author</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  In order to make the example more visual, we presented the URL as a regular string, but in the future we can change this.  We also define a simple data structure with two fields.  The names of these fields match the corresponding fields in JSON.  The most interesting is hidden in the line with <code>derive</code> . </p><br><p>  It tells the compiler to generate additional code based on this structure. </p><br><ul><li>  Debug generates a debug representation in the form of lines, which is often useful. </li><li>  Serialize / Deserialize generates code to serialize our data structure.  This is still not tied to the JSON format that we plan to use with you. </li></ul><br><p>  Create a structure to represent the element in the ribbon: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Deserialize, Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedItem</span></span></span></span> { id: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, content_text: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, date_published: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, author: Author, }</code> </pre> <br><p>  This is similar to the structures that we have already set.  You can see that we used composition to include the field type <code>Author</code> . </p><br><p>  We called our type <code>FeedItem</code> , because it more eloquently indicates why this type is needed. </p><br><p>  Let's see how our tape will look like: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Deserialize, Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Feed</span></span></span></span> { version: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, home_page_url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, feed_url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, description: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, author: Author, items: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;FeedItem&gt;, }</code> </pre> <br><p>  There is nothing new here, except that we have included the <code>items</code> field, which is a vector that includes ribbon elements. </p><br><p>  <code>Vec</code> is a standard type in Rust to represent a list of something.  It can contain any set of objects of the same type. </p><br><p>  For those who are used to generic `s in other languages, this designation is already familiar. </p><br><p>  Let <code>get_feed</code> return a <code>Feed</code> instead of a <code>String</code> : </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_feed</span></span></span></span>() -&gt; Feed { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = reqwest::Client::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> request = client.get(URL); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> resp = request.send().unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(resp.status().is_success()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = resp.text().unwrap(); serde_json::from_str(&amp;json).unwrap() }</code> </pre> <br><p>  There are only two things left to add: we assign the returned text to the <code>json</code> variable and call the function to parse the variable. </p><br><p>  Since the parsing may fail, the program may return a Result containing an erroneous value.  If the function succeeds, in order to retrieve the value you need to call <code>unwrap</code> . </p><br><p>  By the way we changed the return type in the get_feed function, Rust found out that we want to convert JSON text into a variable of type <code>Feed</code> . </p><br><p>  If <code>json</code> does not contain the correct ( <em>valid</em> ) JSON, then the program will end with an error, so if readrust.net changes the tape coding format, we will immediately notice it. </p><br><h2 id="podschet">  Count </h2><br><p>  We are close to completion, but have not yet written the code for displaying the result to the user. <br>  Correct - let's teach our program to show the user the number of elements in the tape. </p><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_count</span></span></span></span>(feed: &amp;Feed) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of posts: {}"</span></span>, feed.items.len()); }</code> </pre> <br><p>  Look at <code>&amp;</code> : Rust is a system programming language that provides two ways to pass arguments: </p><br><ul><li>  transfer of ownership <br>  ( <code>pass ownership</code> , <strong>owned</strong> ) </li><li>  Link transfer - borrowing ( <code>borrow</code> , <strong>borrowed</strong> ). </li></ul><br><p>  <strong>Ownership</strong> - this means that the calling code will lose access to the transmitted object (will transfer ownership of the object).  With the values ‚Äã‚Äãyou own, you can do everything: destroy them, ignore them, use them. </p><br><p>  <strong>Borrowing</strong> - this means that you can only "look" at the object, after which you will have to return the object to its owner.  The owner can give or not give you permission to change the object.  Since now we don‚Äôt need to change the object, we borrow it via an immutable link. </p><br><p>  Here is how it looks in <code>main</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> matches = app.get_matches(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> feed = get_feed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> matches.is_present(<span class="hljs-string"><span class="hljs-string">"count"</span></span>) { print_count(&amp;feed); }</code> </pre> <br><p>  <code>gen_matches</code> determined which arguments were passed to the program. </p><br><p>  The <code>is_present</code> call allows us to know if the user passed the argument <code>--count</code> .  Notice that we must use <code>&amp;</code> and here to tell the compiler that we want to pass an object by reference. </p><br><p>  Run: </p><br><pre> <code class="hljs ruby">[ skade readrust-cli ] cargo run -- --count Compiling readrust v<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1.0</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">file:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>Users/skade/Code/rust/readrust-cli) Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">2.46</span></span> secs Running <span class="hljs-string"><span class="hljs-string">`target/debug/readrust --count`</span></span> Number of <span class="hljs-symbol"><span class="hljs-symbol">posts:</span></span> <span class="hljs-number"><span class="hljs-number">82</span></span></code> </pre> <br><h2 id="formatirovannyy-vyvod">  Formatted output </h2><br><p>  Now we have to teach the program to display the results on the screen.  I decided to print the table using the <code>prettytable</code> library <code>prettytable</code> </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] prettytable-rs = <span class="hljs-string"><span class="hljs-string">"0.6"</span></span></code> </pre> <br><p>  Let's look at one of the examples of using the library and adapt it to our case: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> prettytable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_feed_table</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'feed</span></span>, I: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'feed</span></span> FeedItem&gt;&gt;(items: I) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> table = prettytable::Table::new(); table.add_row(row![<span class="hljs-string"><span class="hljs-string">"Title"</span></span>, <span class="hljs-string"><span class="hljs-string">"Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"Link"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.title.len() &gt;= <span class="hljs-number"><span class="hljs-number">50</span></span> { &amp;item.title[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">49</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { &amp;item.title }; table.add_row(row![title, item.author.name, item.url]); } table.printstd(); }</code> </pre> <br><p>  Here are a few points that are worth paying attention to: </p><br><ul><li>  the loop is used to "run through" the elements and <br>  bring them out </li><li>  some authors like to take notes with headlines, <br>  containing more than 50 characters, we shorten them </li></ul><br><p>  Let's look at <code>if</code> , which in Rust <strong>is an expression that returns a value</strong> . <br>  This means that we can assign the result of the <code>if</code> calculation to the <code>title</code> variable.  If you look at the two possible execution branches, you will again see the <code>&amp;</code> characters ‚Äî this is called a ‚Äúslice‚Äù.  If the title is too long, then we take the link to the first 50 characters, so we don‚Äôt have to copy it.  The similarity with <code>&amp;</code> to denote borrowing is not accidental: we borrow a slice. </p><br><p>  This leads to the fact that the signature looks like this: <br> <code>fn print_feed_table&lt;'feed, I: Iterator&lt;Item = &amp;'feed FeedItem&gt;&gt;(items: I)</code> </p> <br><p>  Functions can work with <em>generics</em> and I decided to add them to the <code>print_feed_table</code> implementation.  This function accepts an object that implements <code>Iterator</code> and provides us with borrowed elements. </p><br><p>  Entities that <code>Iterator</code> gives us are called <code>Item</code> - a type parameter, in this case <code>FeedItem</code> .  Finally, there is a <code>'feed</code> . </p><br><p>  <strong>Rust checks that all links point to something: what they point to should exist.</strong> </p><br><p>  This semantics is expressed in function signatures.  In order to return references to elements, we must make sure that these elements are in memory.  Roughly speaking, <code>&lt;'feed, I: Iterator&lt;Item = &amp;'feed FeedItem&gt;&gt;</code> means that there is some entity outside the function that exists for a time of <code>'feed</code> </p><br><p>  This entity provides us with the <code>items</code> we are borrowing.  We get an iterator I, which "runs" through the elements, giving us elements to borrow.  The lifetime ( <code>lifetime</code> ) expresses these ratios. </p><br><p>  It looks like this: </p><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> matches.is_present(<span class="hljs-string"><span class="hljs-string">"count"</span></span>) { print_count(&amp;feed); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = feed.items.iter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span></span><span class="hljs-function">)</span></span> = matches.value_of(<span class="hljs-string"><span class="hljs-string">"number"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.parse().unwrap(); print_feed_table(iter.take(number)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { print_feed_table(iter) } }</code> </pre> <br><p>  Here we see the reason why I chose this particular implementation.  In order to enable support for the <code>--number</code> option, I decided to use Iterator. </p><br><p>  If the user provides a number, I convert it to a string (this, of course, can fail if a random string is passed). </p><br><p>  After I convert the set of remaining elements into a <code>Take</code> iterator.  <code>Take</code> returns a certain number of elements from the source iterator and then completes its execution. </p><br><p>  All is ready!  Source code you can find <a href="https://github.com/skade/readrust-cli">here.</a> </p><br><h2 id="chto-delat-dalshe">  What to do next? </h2><br><p>  We have written a program that you can expand. </p><br><p>  For example, you can try the following: </p><br><ul><li>  calculate the statistics of notes in the tape </li><li>  select only those notes whose headings match the regular expression </li><li>  improve error handling with more verbose messages </li><li>  present dates with variables of the appropriate type, not strings ( <code>String</code> ) </li><li>  follow the links and get the contents of the notes. </li></ul><br><h2 id="itog">  Total </h2><br><p>  We received a program in which we check the data for errors, completing <br>  program after processing them. </p><br><p>  <code>JSON</code> data is parsed safely, detecting for errors. </p><br><ul><li><p>  The program copes well with unexpected situations.  For example, using iteration instead of indexed access to an array, we are protected from accessing an element outside the array =&gt; no segfault. </p><br></li><li><p>  The program is written using well-documented libraries, with which you can quickly move on to writing your own code.  The situation with the library in Rust is now much better than it was, say, 2 years ago, we already have many mature libraries. </p><br></li><li>  The program is portable ( <em>cross-platform</em> ) =&gt; you can share the program by simply copying the executable file. </li></ul><br><p>  Here is the complete source code: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> clap; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> prettytable; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> reqwest; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> clap::App; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> URL: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"http://readrust.net/rust2018/feed.json"</span></span>; <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Deserialize, Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Author</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Deserialize, Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedItem</span></span></span></span> { id: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, content_text: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, date_published: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, author: Author, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Deserialize, Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Feed</span></span></span></span> { version: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, home_page_url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, feed_url: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, description: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, author: Author, items: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;FeedItem&gt;, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_count</span></span></span></span>(feed: &amp;Feed) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of posts: {}"</span></span>, feed.items.len()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_feed_table</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'feed</span></span>, I: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item=&amp;<span class="hljs-symbol"><span class="hljs-symbol">'feed</span></span> FeedItem&gt;&gt;(items: I) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> table = prettytable::Table::new(); table.add_row(row![<span class="hljs-string"><span class="hljs-string">"Title"</span></span>, <span class="hljs-string"><span class="hljs-string">"Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"Link"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.title.len() &gt;= <span class="hljs-number"><span class="hljs-number">50</span></span> { &amp;item.title[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">49</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { &amp;item.title }; table.add_row(row![title, item.author.name, item.url]); } table.printstd(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_feed</span></span></span></span>() -&gt; Feed { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = reqwest::Client::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> request = client.get(URL); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> resp = request.send().unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(resp.status().is_success()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = resp.text().unwrap(); serde_json::from_str(&amp;json).unwrap() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = App::new(<span class="hljs-string"><span class="hljs-string">"readrust"</span></span>) .version(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>) .author(<span class="hljs-string"><span class="hljs-string">"Florian G. &lt;florian.gilcher@asquera.de&gt;"</span></span>) .about(<span class="hljs-string"><span class="hljs-string">"Reads readrust.net"</span></span>) .args_from_usage( <span class="hljs-string"><span class="hljs-string">"-n, --number=[NUMBER] 'Only print the NUMBER most recent posts' -c, --count 'Show the count of posts'"</span></span>, ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> matches = app.get_matches(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> feed = get_feed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> matches.is_present(<span class="hljs-string"><span class="hljs-string">"count"</span></span>) { print_count(&amp;feed); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iter = feed.items.iter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(string) = matches.value_of(<span class="hljs-string"><span class="hljs-string">"number"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number = string.parse().unwrap(); print_feed_table(iter.take(number)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { print_feed_table(iter) } } }</code> </pre> <br><p>  Many thanks to everyone from the Rustycrate community who participated in the translation, proofreading and editing of this article.  Namely: born2lose, vitvakatu. </p><br><p>  <strong>UPDATE</strong> : added full source code. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347198/">https://habr.com/ru/post/347198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347188/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ298 (January 15 - 21, 2018)</a></li>
<li><a href="../347190/index.html">Pros of the "correct" virtual number</a></li>
<li><a href="../347192/index.html">News from the world of OpenStreetMap ‚Ññ391 (09.01.2018-15.01.2018)</a></li>
<li><a href="../347194/index.html">CSS naming conventions and time saving</a></li>
<li><a href="../347196/index.html">DDoS protection at the web server level</a></li>
<li><a href="../347200/index.html">Java with assembly inserts</a></li>
<li><a href="../347202/index.html">In the US with a bodyshop: go or not go?</a></li>
<li><a href="../347204/index.html">IT solutions architecture. Part 1. Enterprise architecture</a></li>
<li><a href="../347206/index.html">As simple as possible about sorting combinations in real business problems</a></li>
<li><a href="../347208/index.html">Kodein is an interesting alternative to Dagger 2 for dependency injection in Kotlin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>