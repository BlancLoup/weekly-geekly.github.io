<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Selected chapters of the control theory on fingers: linear observers of dynamic systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to write about the theory of management "on the fingers." To understand the current text, it is necessary to read the two previous articles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Selected chapters of the control theory on fingers: linear observers of dynamic systems</h1><div class="post__text post__text-html js-mediator-article">  I continue to write about the theory of management "on the fingers."  To understand the current text, it is necessary to read the two previous articles: <br><br><ol><li>  <a href="https://habrahabr.ru/post/277275/">Least squares methods</a> </li><li>  <a href="https://habrahabr.ru/post/277671/">Linear-square controller, input</a> </li><li>  <b>Line square controller and linear observers</b> </li></ol><br>  I am not at all an expert in management theory, I only read textbooks.  My task is to understand the theory and put it into practice.  In this article, only the theory (well, a little accompanying code), next we will talk about the practice, a small piece of which can be found here: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xRSLq3WJBew" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Corrections and additions are welcome.  For the hundredth time I remind you that first of all I write these texts for myself, as it forces me to structure knowledge in my head.  This site is for me a kind of public address book, to which, by the way, I myself regularly return.  Just in case, let me remind a bearded joke that describes my life well: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  A conversation between two teachers: <br>  - Well, I got a group of stupid this year! <br>  - Why? <br>  - Imagine, explain the theorem - do not understand!  Explaining a second time - do not understand!  For the third time I explain, I already understood.  But they do not understand ... <br></blockquote><br><h1>  Linear-square regulator, side view </h1><br><h3>  LQR: Problem statement </h3><br>  So, let's recall what we <a href="https://habrahabr.ru/post/277671/">talked about in the last article</a> , namely, what the Russian school calls analytical design of optimal regulators.  I will even take an example from that article. <br><br>  Suppose we have a car whose state at a given time k is characterized by its x_k coordinate and v_k speed.  The experiment begins with a certain initial state (x_0, v_0), and our task is to stop the car at zero coordinates.  We can affect it through gas / brakes, that is, through acceleration u_k.  We write this information in a form that is convenient to transfer from person to person, because  The verbal description is cumbersome and can allow several tacings: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/b59/b8a/d87b59b8a776e20bba33452e5a033f74.png" alt="image"><br><br>  It is even more convenient to write this information in a matrix form, since the matrices can be substituted into this formulation by the most diverse, thus the language is very flexible and can describe many different problems: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67b/8b4/921/67b8b49210ca57aa5c5c33cd1579c0bd.png" alt="image"><br><br>  So, we described the dynamics of the system, but we did not describe either the goal, or what exactly is considered good governance.  Let's write the following quadratic function, which takes as parameters the vehicle trajectory and the sequence of control signals: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cf/400/619/7cf40061930dc1f068c8800bedf49d31.png" alt="image"><br><br>  We try to find a vehicle trajectory that minimizes the value of this function.  This function sets a compromise of goals: we want the system to converge to zero as quickly as possible, while maintaining a reasonable amount of control (no need to slow down the skid!) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b86/241/d84/b86241d84f9e1895020a0375c651023a.png" alt="image"><br><br>  So we have the task of minimizing the function with a linear restriction on the input variables.  For our specific problem about the car last time we chose such weights 1 and 256 for our purposes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cac/edc/774/cacedc774fdc0c0a8ed5558f4b16ba37.png" alt="image"><br><br>  If at the initial moment our car is in position 3.1 and has a speed of half a meter per second, then the optimal control looks like this (I quote a picture from the previous article): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/667/92e/eee/66792eeeeccaaf3d11f30a7f9236ef65.png"><br><br><h3>  LQR: Solving the problem </h3><br>  Let's try to draw the same curves in a slightly different way than last time.  To write sums is very cumbersome, let's reduce to a matrix view.  First of all, our entire trajectory and our entire control sequence are summarized into healthy matrix columns: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/f4b/b7c/c0ff4bb7c62efaab0d3c6872d17e17e1.png" alt="image"><br><br>  Then the relationship of the coordinates with the control can be written as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/2b0/c4d/8ff2b0c4d7150380277f678017331899.png" alt="image"><br><br>  Or even more briefly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b6/3ba/ca0/4b63baca0180a8fd92c7d036fe55d73a.png" alt="image"><br><br>  <b>In this article, the sticks above the matrices mean the reduction of small matrices that describe one iteration into large ones for the whole task.</b>  For our particular problem, the powers of the matrix A ^ n are as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cc/50d/68e/9cc50d68ec30b245f02087503fa2857f.png" alt="image"><br><br>  For clarity, let's explicitly write ƒÄ and BÃÑ: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a44/1c7/f79/a441c7f7966f58b1548f98715580e955.png" alt="image"><br><br>  And even give the source code that fills these matrices in numpy: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np np.set_printoptions(precision=<span class="hljs-number"><span class="hljs-number">3</span></span>,suppress=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">128</span></span>,threshold=<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_Abar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, N)</span></span></span><span class="hljs-function">:</span></span> n = A.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] Abar = np.matrix( np.zeros(((N+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,n)) ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N+<span class="hljs-number"><span class="hljs-number">1</span></span>): Abar[i*n:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,:] = A**i <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Abar <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_Bbar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, B, N)</span></span></span><span class="hljs-function">:</span></span> (n,m) = B.shape Bbar = np.matrix( np.zeros(((N+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,N*m)) ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(Ni): Bbar[(Ni)*n:(N-i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,(Nij<span class="hljs-number"><span class="hljs-number">-1</span></span>)*m:(Nij)*m] = (A**j)*B <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bbar A = np.matrix([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]]) B = np.matrix([[<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">1</span></span>]]) (n,m) = B.shape N=<span class="hljs-number"><span class="hljs-number">60</span></span> Abar = build_Abar(A, N) Bbar = build_Bbar(A, B, N)</code> </pre> <br>  Let us summarize in large matrices and coefficients of our quadratic form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f6/504/076/2f650407687179a416132eca33760c9c.png" alt="image"><br><br>  In our specific problem about the car, QÃÑ is the identity matrix, and RÃÑ is the identity multiplied by the scalar 256. Then the control quality function is written in matrix form very briefly: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2e/e74/6bb/e2ee746bbc77541c923444c7b394d51b.png" alt="image"><br><br>  And we are looking for the minimum of this function with one linear constraint: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/252/7e2/e39/2527e2e39a54621c1a41e9e89532b866.png" alt="image"><br><br>  <i>Note to yourself: an excellent reason to deal with the Lagrange multipliers, the Legendre transform and the Hamiltonian function derived from this.</i>  <i>And also how this explains the explanation of LQR through dynamic programming and the Riccati equations.</i>  <i>Apparently, still need to write articles :)</i> <br><br>  I'm lazy, so this time we will go the most direct way.  J depends on two arguments that are linearly related to each other.  Instead of minimizing the function with linear constraints, let's just remove the unnecessary variables from it, namely replace the occurrences of X with ƒÄ x_0 + BÃÑ U in it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/5f3/4a3/2da5f34a33f9fb50cbe8cc3f6344cb6d.png" alt="image"><br><br>  This is quite tedious, but completely mechanical and does not require a brain output.  In the transition from the penultimate line to the last, we took advantage of the fact that QÃÑ is symmetric, it allowed us to write QÃÑ + QÃÑ ^ T = 2 QÃÑ. <br><br>  Now we just need to find the minimum of a quadratic function, no restrictions on variables are imposed.  We recall the tenth grade of the school and equate to zero the partial derivatives. <br><br>  If you are able to differentiate ordinary polynomials, then you can take derivatives from matrix ones.  Just in case, let me remind the rules of differentiation: <br><br><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/e7c/452/f2f/e7c452f2fc0dff13f4039b5ef349c640.png" alt="image"><br></blockquote><br>  Again the smallest tedious writing of scribbles and we get our partial derivative with respect to the control vector U (we again used the symmetry of QÃÑ and RÃÑ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b94/414/fbe/b94414fbe0c83647d700daee6123c144.png" alt="image"><br><br>  Then the optimal control vector U * can be found as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb6/64f/c0d/bb664fc0d4c437b49781ee60ba481ec7.png" alt="image"><br><br>  Well, how do we write squiggles, but still have not drawn anything yet?  Let's get better! <br><br><pre> <code class="python hljs">K=-(Bbar.transpose()*Bbar+np.identity(N*m)*<span class="hljs-number"><span class="hljs-number">256</span></span>).I*Bbar.transpose()*Abar print(<span class="hljs-string"><span class="hljs-string">"K = "</span></span>,K) X0=np.matrix([[<span class="hljs-number"><span class="hljs-number">3.1</span></span>],[<span class="hljs-number"><span class="hljs-number">0.5</span></span>]]) U=K*X0 X=Abar*X0 + Bbar*U plt.plot(range(N+<span class="hljs-number"><span class="hljs-number">1</span></span>), X[<span class="hljs-number"><span class="hljs-number">0</span></span>::<span class="hljs-number"><span class="hljs-number">2</span></span>], label=<span class="hljs-string"><span class="hljs-string">"x(t)"</span></span>, color=<span class="hljs-string"><span class="hljs-string">'red'</span></span>) plt.plot(range(N+<span class="hljs-number"><span class="hljs-number">1</span></span>), X[<span class="hljs-number"><span class="hljs-number">1</span></span>::<span class="hljs-number"><span class="hljs-number">2</span></span>], label=<span class="hljs-string"><span class="hljs-string">"v(t)"</span></span>, color=<span class="hljs-string"><span class="hljs-string">'green'</span></span>) plt.plot(range(N), U, label=<span class="hljs-string"><span class="hljs-string">"u(t)"</span></span>, color=<span class="hljs-string"><span class="hljs-string">'blue'</span></span>) plt.legend() plt.show()</code> </pre><br>  This will give the following picture, note that it perfectly coincides with the one that we received in the last article (drawing <a href="https://github.com/ssloy/tutorials/blob/master/tutorials/lqr2-observer/run01.py">here</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e89/25d/8f1/e8925d8f17bfd660d96119c2da0cfed8.png"><br><br><h2>  LQR: Decision Analysis </h2><br><h3>  Linear communication control and system status </h3><br>  So, the theory tells us that (for a far horizon of events) the optimal control linearly depends on the remaining distance to the final goal.  Last time we proved it for a one-dimensional case, in a two-dimensional case, having believed in the word.  This time again I will not strictly prove, leaving it for a later conversation about Lagrange multipliers.  However, it is intuitively clear that this is the case.  After all, we have obtained the formula U = K * x0, where the matrix K does not depend on the state of the system, but only on the structure of the differential equation (on the matrices A and B). <br><br>  That is, u_0 = k_0 * x_0.  By the way, we got k_0 equal to [-0.052 -0.354]: <br> <code>K = [[-0.052 -0.354] <br> [-0.034 -0.281] <br> [-0.019 -0.215] <br> [-0.008 -0.158] <br> [ 0. -0.11 ] <br> ... <br></code> <br><br>  Compare this result with what I obtained with the help of the OLS and the one <a href="https://habrahabr.ru/post/277671/">that was obtained by solving the Riccati equation (in the comments to the previous article).</a>  It is intuitively clear that if u0 depends linearly on x_0, then for a far horizon of events the same should be for x1. <br><br>  Continuing the argument, we expect that the control u_i should be considered as u_i = k_0 * x_i.  That is, the optimal control should be obtained by the scalar product of the constant vector k_0 and the residual distance to the target x_i. <br><br>  But our result is exactly the opposite!  We found that u_i = k_i * x_0!  That is, we found the sequence k_i, which depends only on the structure of the system equation, but not on its state.  And the control is obtained using the scalar product of a constant vector (the initial position of the system) and the sequence found ... <br><br>  That is, if everything is good, then we should have the equality k_0 * x_i = u_i = k_i * x_0.  Let's draw an illustrative graph, taking x_0 for simplicity equal to k_0.  Along one axis of the graph we will postpone the coordinate of the machine, along the other the speed.  Starting from one point k_0 = x_0 we get two different sequences of points k_i and x_i converging to zero coordinates. <br><br>  Drawing is available <a href="https://github.com/ssloy/tutorials/blob/master/tutorials/lqr2-observer/run02.py">here</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fc/731/2fb/0fc7312fbdc132cdd545a0ab58eafb25.png"><br><br>  If roughly, then k_i * x_0 form a sequence of projections k_i onto the vector x_0.  The same for k_0 * x_i, is a sequence of projections x_i on k_0.  On our graph it is clearly seen that these projections coincide.  Once again, this is not proof, but only an illustration. <br><br>  Thus, we have obtained a dynamic system of the form x_ {k + 1} = (A + BK) x_k.  If the eigenvalues ‚Äã‚Äãof the matrix A + BK are less than unity in absolute value, then this system converges to the origin for any initial x_0.  In other words, the solution of this differential equation is the (matrix) exponent. <br><br><blockquote>  In an insane asylum, where mathematics students were brought to the session, one of them runs around with a knife and shouts: ‚ÄúI will differentiate everyone!‚Äù.  Patients scatter, except for another math student.  When the first one rushes into the chamber crying, ‚ÄúDifferentiate!‚Äù, The second one phlegmatically remarks: ‚ÄúI am in the degree of X!‚Äù.  The first, waving a knife: ‚ÄúI will differentiate by toys!‚Äù <br></blockquote><br>  As an illustration, I randomly selected several hundred different x_0, and drew the trajectories of our typewriter.  Drawing to take <a href="https://github.com/ssloy/tutorials/blob/master/tutorials/lqr2-observer/run03.py">here</a> .  Here is the resulting picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c2/6e5/3a3/0c26e53a337185420762acb94d0297c4.png"><br><br>  All trajectories safely converge to zero, a slight twisting of the trajectories suggests that the matrix A + BK is a rotation and contraction matrix (it has complex eigenvalues ‚Äã‚Äãsmaller than one in absolute value).  If I'm not mistaken, then this picture is called a phase portrait. <br><br><h3>  Open and closed control loops </h3><br>  So, we cheerfully minimized our function J, and obtained the optimal control vector U0 as K * X0: <br><br><pre> <code class="python hljs">U=K*X0 X=Abar*X0 + Bbar*U</code> </pre><br><br>  Is there still a difference between considering management in the same way or as u_i = k_0 * x_i?  There is a colossal, if we have unaccounted factors in the system (that is, almost always).  Let's imagine that our car is not rolling on a horizontal surface, but such a slide can meet on its way: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/517/f55/dd5517f55897edbe1ba7ae2734c0925e.png"><br><br>  If we calculate the optimal control without regard to this slide, then trouble can happen <br>  (drawing <a href="https://github.com/ssloy/tutorials/blob/master/tutorials/lqr2-observer/run04.py">here</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61b/c08/d0b/61bc08d0b14bbb5f2ef9cc18920be4e3.png"><br><br>  The machine not only will not stop, but will go to infinity to the right altogether, I even drew a third of the x_i graphics, and then it grows linearly.  If we close the control loop, then small disturbances in the dynamics of the system do not lead to catastrophic consequences: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N): Xi = X[i*n:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,<span class="hljs-number"><span class="hljs-number">0</span></span>] U[i*m:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*m,<span class="hljs-number"><span class="hljs-number">0</span></span>] = K[<span class="hljs-number"><span class="hljs-number">0</span></span>:m,:]*Xi idxslope = int((Xi[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]+<span class="hljs-number"><span class="hljs-number">5</span></span>)/<span class="hljs-number"><span class="hljs-number">10.</span></span>*<span class="hljs-number"><span class="hljs-number">1000.</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idxslope&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> idxslope&gt;=<span class="hljs-number"><span class="hljs-number">1000</span></span>): idxslope = <span class="hljs-number"><span class="hljs-number">0</span></span> X[(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n:(i+<span class="hljs-number"><span class="hljs-number">2</span></span>)*n,<span class="hljs-number"><span class="hljs-number">0</span></span>] = A*Xi + B*U[i*m:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*m,<span class="hljs-number"><span class="hljs-number">0</span></span>] + B*slope[idxslope]</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/605/940/9b3/6059409b395394cb19a7647f89b7bd90.png"><br><br><h1>  Building a linear observer </h1><br>  So, we are able to manage a dynamic system so that it strives to get to the origin.  But what if we wanted the car to stop not at x = 0, but at x = 3?  Obviously, it is enough to subtract the desired result from the current state x_i, and then everything is as usual.  Moreover, this desired result may well not be permanent, but change over time.  Can we follow another dynamic system? <br><br>  Let's assume that we do not control our typewriter directly, but at the same time we want to follow it.  We measure both states of the machine with the help of some sensors that have a rather low resolution: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d22/170/a28/d22170a28b316e0e00d506f4cddf02da.png"><br><br>  I just took our curves and blundered their values.  Let's try to filter the noise introduced by the measurements.  As usual, we arm ourselves with the smallest squares. <br><br><blockquote>  When you have a hammer in your hands, everything seems to be nails. <br></blockquote><br>  So, our machine obeys the law x_ {k + 1} = A x_k + B u_k, so let's build a diffur observer that follows the same law: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/094/e59/665/094e59665ad7a2cdc2e040158b77ae3c.png" alt="image"><br><br>  Here y_k is a corrective member, through which we will inform our observer how far we are from the real state of affairs.  Like last time, we write the equation in matrix form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/702/f2b/913/702f2b91336796574323bafcd15fd42c.png" alt="image"><br><br>  Okay.  Now what do we want?  We want the correction terms y_k to be small, and that z_k converge to x_k: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/875/2af/e718752afcb540bf1361b288f0d8ff17.png" alt="image"><br><br>  Like last time, we express Z through Y, we equate the partial derivatives with respect to Y to zero, and we obtain the expression for the optimal corrective term: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/401/87c/2b3/40187c2b3a3afb4c595b640cf973c739.png" alt="image"><br><br>  Then vague forebodings begin to torment me ... I have already seen it somewhere!  Well, let's remember how X is related to U, we get the following expression: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d1f/d60/0bcd1fd6049033f5d2b14b7bd75365b4.png" alt="image"><br><br>  But this is accurate to renaming the letters for U *!  And in fact, let's go back a little bit, we rushed into business too quickly.  Combining the dynamics for x_k with the dynamics for z_k we get the dynamics for the error x_k-z_k. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/621/e0d/4cd/621e0d4cd17387da1c321ce1ba41fa24.png" alt="image"><br><br>  That is, our task of tracking a typewriter is absolutely equivalent to the problem of a linear-quadratic controller.  Find the optimal gain matrix, which in our case will be equal to [[-0.594, -0.673], [- 0.079, -0.774]], and we get the following observer code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N): Zi = Z[i*n:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,<span class="hljs-number"><span class="hljs-number">0</span></span>] Xi = X[i*n:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n,<span class="hljs-number"><span class="hljs-number">0</span></span>] Z[(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*n:(i+<span class="hljs-number"><span class="hljs-number">2</span></span>)*n,<span class="hljs-number"><span class="hljs-number">0</span></span>] = A*Zi + B*U[i*m:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*m,<span class="hljs-number"><span class="hljs-number">0</span></span>] + np.matrix([[<span class="hljs-number"><span class="hljs-number">-0.594</span></span>,<span class="hljs-number"><span class="hljs-number">-0.673</span></span>],[<span class="hljs-number"><span class="hljs-number">-0.079</span></span>,<span class="hljs-number"><span class="hljs-number">-0.774</span></span>]])*(Zi-Xi)</code> </pre><br>  But the filtered curves, they are not ideal, but still closer to reality than measurements with low resolution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79d/332/177/79d332177ed927ddc3fb52db2a287fd8.png"><br><br>  The dynamics of the system is determined by the eigenvalues ‚Äã‚Äãof the matrix [[1-0.594.1-0.673], [- 0.079.1-0.774]], which are equal (0.316 + - 0.133 i). <br><br>  And let's go even further.  Let's assume that we can measure only the position, but there is no sensor speed.  Will we be able to build an observer in this case?  Here we go beyond the LQR, but not too far.  Let's write the following system: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57c/dc5/7d0/57cdc57d030e539dd1f1ef3664f50184.png" alt="image"><br><br>  Matrix C dictates to us what we can actually observe in our system.  Our task is to find such a matrix L, which will allow the observer to behave well.  Let's prescribe that the eigenvalues ‚Äã‚Äãof the matrix A + LC, which describes the overall dynamics of the observer, should be about the same as the eigenvalues ‚Äã‚Äãof the matrix from the previous example.  Let's approximate the previous eigenvalues ‚Äã‚Äãwith fractions (1/3 + - 1/6 i).  We write the characteristic polynomial of the matrix A + LC, and make it equal to the polynomial (x- (1/3 + 1/6 * i)) * (x- (1 / 3-1 / 6 * i). Then we solve the simplest system from linear equations, and the matrix L is found. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef0/a0c/c0c/ef0a0cc0c02bbc5eaa5c7dd46afa9069.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b20/38a/7e6/b2038a7e6d0e8cc389dbcd8931483fb4.png" alt="image"><br><br>  <a href="http://sagecell.sagemath.org/%3Fz%3DeJxFTlsKgzAQ_Bc8hxs1auILP3IETyChSNEaWKuYavX2TYq1X_NYZnb0ML1hbF-L2qFpGE2ivMpCi0WZyrAxJCmrr1GWmZQk6tSje24trp0GQlzHdbZ2AQ9ZiNwzuhb_usC4zLQgNyDNUdt39UWi-9Au84QH7ORnAuwUWJwGLC58RYh_anpqEmk1zqj649aviHAF9YRbBw1FRrkQlMdpaCjygAmRx2lhd9iR0iY-JylDRQ%3D%3D%26lang%3Dsage">Calculations can be checked here</a> , and drawing charts <a href="https://raw.githubusercontent.com/ssloy/tutorials/master/tutorials/lqr2-observer/run05.py">here</a> . <br><br>  This is how the work schedules of our observer look like, if we measure (and with a large error) only the coordinate of our machine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98c/d19/139/98cd19139223065742dd0bc7bad681e2.png"><br><br>  From very incomplete data, we can very well restore the dynamics of the entire system!  By the way, the linear observer that we built in fact is the famous Kalman filter, but we will talk about this some time next. <br><br><h2>  Question for attentive readers </h2><br>  If, nevertheless, to bring to the logical end the computations of Y * <a href="https://raw.githubusercontent.com/ssloy/tutorials/master/tutorials/lqr2-observer/run06.py">(code is taken here)</a> , then the final observer curves are much much smoother (and closer to the truth!) Than those that should be equivalent to them.  Why? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2e/a45/90c/c2ea4590cfde8bc8f2eb8ef0ac48a2df.png"></div><p>Source: <a href="https://habr.com/ru/post/341870/">https://habr.com/ru/post/341870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341860/index.html">uSpeech - startup development (2). Run Android version and where to get the first customers</a></li>
<li><a href="../341862/index.html">Prometheus</a></li>
<li><a href="../341864/index.html">[DotNetBook] IDisposable implementation: proper use</a></li>
<li><a href="../341866/index.html">‚ÄúHouston, we have problems‚Äù: what difficulties of web studios will the hosting provider help to figure out</a></li>
<li><a href="../341868/index.html">Problems with data management? How AI and machine learning can solve one of the biggest problems.</a></li>
<li><a href="../341872/index.html">The announcement of the mitap ThinkPHP # 15 in Kharkov</a></li>
<li><a href="../341874/index.html">Web application on Node and Vue, part 3: client and server development</a></li>
<li><a href="../341876/index.html">Configuring Authentication in SAP Netweaver AS Java (Part 1 of 3)</a></li>
<li><a href="../341878/index.html">Debugging React Applications in VS Code</a></li>
<li><a href="../341880/index.html">What is RxJS and why is it useful to know about it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>