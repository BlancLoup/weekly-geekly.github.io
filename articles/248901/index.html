<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Annotation to "Effective Modern C ++" by Scott Myers. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation of the previous post . 



 In this part, we will consider not so much technical changes in C ++, as new approaches to development and th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Annotation to "Effective Modern C ++" by Scott Myers. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Continuation of the <a href="http://habrahabr.ru/post/248137/">previous post</a> . <br><br><img src="https://habrastorage.org/files/069/615/2ef/0696152ef06e40cba11aa1eaba203f11.gif" alt="image"><br><br>  In this part, we will consider not so much technical changes in C ++, as new approaches to development and the possibilities that new tools of the language provide.  From my point of view, the previous post was simply a lingering introduction, whereas here you can discuss a lot. <br><a name="habracut"></a><br><h4>  Lambda expressions - the cherry on the cake </h4><br>  No matter how surprising it sounds, but lambda expressions did not bring new functionality to the language (in the original, expressive power).  Nevertheless, their ever wider use is rapidly changing the style of the language, the ease of creating object functions on the fly inspires and it remains only to wait for the widespread distribution of C ++ 14 (which is already there, but still not quite) where lambdas have reached full bloom.  Starting from C ++ 14, lambda expressions are assumed to be an absolute replacement for <i>std :: bind</i> , there is no real reason to use it.  First, and most importantly, lambdas are easier to read and more clearly express the idea of ‚Äã‚Äãthe author.  I will not give here a rather cumbersome code to illustrate, in the original, Myers has plenty of it.  Secondly, lambda expressions tend to work faster.  The fact is that <i>std :: bind</i> captures and stores a <i>pointer to a function</i> , so the compiler has few chances to <i>inline</i> ( <i>inline</i> ) it, while according to the standard, the function call operator in a closure containing a lambda expression <i>must</i> be embedded, so the compiler remains a bit of work to embed all the lambda expression at the call point.  There are a couple of less significant reasons, but they boil down mainly to the shortcomings of <i>std :: bind</i> and I‚Äôll omit them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main danger when working with lambda expressions is how to capture variables.  Probably needless to say that this code is potentially dangerous: <br><pre><code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">...</span></span>) { ... };</code> </pre> <br>  If the lambda closure survives any of the captured local variables, we get a <i>dangling reference</i> and as a result <i>undefined behavior</i> .  It is so obvious that I will not give even code examples.  Stylistically, a little bit better is this: <br><pre> <code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">&amp;localVar</span></span>](<span class="hljs-link"><span class="hljs-link">...</span></span>) { ... };</code> </pre><br>  We, at least, control exactly which variables are captured, and we also have a reminder before our eyes.  But this does not solve the problem in any way. <br>  The code where lambda is generated on the fly: <br><pre> <code class="hljs markdown">std::all_of(container.begin(), container.end(), [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) { ... });</code> </pre><br>  certainly safe, although Myers even here warns of the danger of copy-paste.  In any case, it is always a good habit to always explicitly list the variables that are captured by reference and not use [&amp;]. <br>  But this is not the end, let's capture everything by value: <br><pre> <code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">=</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) { *ptr=... };</code> </pre><br>  Oops, the pointer is captured by value, and what, is it easier for us? <br>  But that's not all ... <br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt;&gt; filters; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ filters.emplace_back([=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value % divisor == <span class="hljs-number"><span class="hljs-number">0</span></span>; }); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor; };</code> </pre><br>  Well, here everything is perfectly safe, I hope? <br><div class="spoiler">  <b class="spoiler_title">In vain hope.</b> <div class="spoiler_text">  Wrong.  Completely wrong.  Horribly wrong.  Fatally wrong.  (@ScottMeyers) <br></div></div><br>  The fact is that lambda captures <i>local variables in the scope</i> , it does not care that the divisor belongs to the Widget class, is not in the scope, it will not be captured.  Here such code for comparison is not compiled at all: <br><br><pre> <code class="hljs markdown">... void addFilter() const { filters.emplace_back([<span class="hljs-string"><span class="hljs-string">divisor</span></span>](<span class="hljs-link"><span class="hljs-link">int value</span></span>) { return value % divisor == 0; }); ... };</code> </pre><br>  So what is captured?  The answer is simple, <i>this is</i> captured, the divisor in the code is actually interpreted by the compiler as this-&gt; divisor, and if the Widget goes out of scope, we return to the previous example with a dangling pointer.  Fortunately, there is a solution for this problem: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt;&gt; filters; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> localCopy=divisor; filters.emplace_back([=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value % localCopy == <span class="hljs-number"><span class="hljs-number">0</span></span>; }); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor; };</code> </pre><br>  By making a local copy of a class variable, we allow our lambda to capture it by value. <br><br>  Perhaps you will cry, but that's not all!  I mentioned a little earlier that lambdas capture <i><u>local</u> variables in scope</i> , they can also use (i.e. depend on) static objects ( <i>static storage duration</i> ), but they do <i>not capture them</i> .  Example: <br><br><pre> <code class="hljs markdown">static int divisor=...; filters.emplace_back([<span class="hljs-string"><span class="hljs-string">=</span></span>](<span class="hljs-link"><span class="hljs-link">int value</span></span>) { return value % divisor == 0; }); ++divisor; //      </code> </pre><br>  Lambda <i>does not capture the</i> static divisor variable, but <i>refers</i> to it, you can say (although this is not entirely correct) that the static variable is <i>captured by reference</i> .  Everything would be fine, but the [=] icon in the definition of lambda kagbe hinted to us that everything is captured by value, the resulting lambda closure is self-sufficient, <s>it can be stored for a thousand years and passed from function to function and it will work as new ...</s> It's a shame.  Do you know which of these conclusions?  Do not abuse the [=] icon in the same way as [&amp;], do not be lazy to list all variables and you will be happy. <br><br>  Now you can laugh, this time all ... <br><br>  And really everything, more about lambda expressions are essentially nothing to say, you can take and use.  Nevertheless, I will tell in the rest of the additions that C ++ 14 brought, this area is still poorly documented and this is one of the few places where the changes are really profound. <br><br>  One thing that annoyed me from the very beginning in C ++ 11 lambda expressions is the inability to <i>move (move) the</i> variable inside the closure.  With the submission of TP1 and boost, we suddenly realized that the world around us is full of objects that cannot be copied, std :: unique_ptr &lt;&gt;, std :: atomic &lt;&gt;, boost :: asio :: socket, std :: thread, std :: future - the number of such objects is growing rapidly after a simple idea was realized: something that does not lend itself to natural copying is not necessary, but you can always <i>move</i> it.  And suddenly such a cruel disappointment, the new language tool does not support this construction. <div class="spoiler">  <b class="spoiler_title">Of course, there is a reasonable explanation for this.</b> <div class="spoiler_text">  And at what point does the movement take place?  And what about copying the closure itself?  etc </div></div>  however, sediment remains.  And finally, C ++ 14 appears which solves these problems in an unexpected and elegant way: <i>init capture</i> . <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wptr=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Widget&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func=[wptr=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wptr)]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wptr-&gt;...(); }; func();</code> </pre><br>  We create a new local variable in the lambda header to which we move the required parameter.  Pay attention to two interesting points.  The first one is that the names of the variables coincide, this is not necessary, but it is convenient and safe, because their scopes are <i>not suppressed</i> .  The variable to the left of the = sign is defined <i>only</i> inside the lambda body, while the variable in the expression to the right of = is defined externally and not defined internally.  Second, at the same time we were able to capture whole expressions, and not just variables as before.  It is perfectly legal and reasonable to write this: <br><br><pre> <code class="hljs go">auto <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function">=[</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wptr</span></span></span><span class="hljs-function">=</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_unique</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wptr-&gt;...(); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre><br>  But what do those who remain in C ++ 11 do?  Frankly, before the release of this book, I repeatedly tortured the Internet and always received one answer - in C ++ 11 this is not possible, but there is a solution and it is described right in the next paragraph (the Internet should have blush in this place).  Recall how this section began: ‚ÄúLambda expressions did not bring new language into the language,‚Äù everything that they do can be done with the same success with their hands.  Something like that: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PeudoLambda</span></span></span><span class="hljs-class"> </span></span>{ explicit <span class="hljs-type"><span class="hljs-type">PeudoLambda</span></span>(std::unique_ptr&lt;<span class="hljs-type"><span class="hljs-type">Widget</span></span>&gt;&amp;&amp; w) : wptr(std::move(w)) {} bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wptr-&gt;...(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::unique_ptr&lt;<span class="hljs-type"><span class="hljs-type">Widget</span></span> wptr ; }; auto <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function">=</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PeudoLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(std::make_unique&lt;Widget&gt;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  If you still don't want to work with your hands, but you want to use lambda expressions, then ... the solution is just the same, you just have to use <i>std :: bind</i> instead of a homemade class, this is exactly the case when using it in C ++ 11 remains justified. <br><br>  The trick is performed in two steps: on time, our object is <i>moved</i> to an object created by <i>std :: bind</i> , then a <i>link</i> to this object is transferred to the count of two lambda. <br><br><pre> <code class="hljs markdown">std::vector<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">double</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> data; auto func=[<span class="hljs-string"><span class="hljs-string">data=std::move(data)</span></span>] { ... }; // C++14 way auto func=std::bind( [](std::vector<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">double</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>&amp; data) { ... }, // C++11 trick std::move(data) );</code> </pre><br>  Not so, of course, elegant, but it works the same, as a temporary measure will go quite well. <br><br>  The second, and most importantly, why everyone waited for C ++ 14 with impatience, introduced template lambda expressions ( <i>generic lambdas</i> ). <br><br><pre> <code class="hljs swift">auto f=[](auto x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span>; };</code> </pre><br>  Using <i>auto</i> in the parameter declaration we get the ability to pass arbitrary values ‚Äã‚Äãto the lambda closure.  And how does it work under the hood?  Nothing magical: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PseudoLambda</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(x); } };</code> </pre><br>  Just the corresponding operator () is declared a template and accepts any types.  However, the given example is not entirely correct, the lambda in this example will always pass x as an lvalue, even if the parameter to the lambda is transmitted as an rvalue.  Here it would be useful to re-read the first part of the post about type inference, and even better the corresponding chapter in the book.  I, however, immediately give the final version: <br><br><pre> <code class="hljs markdown">auto f=[<span class="hljs-string"></span><span class="hljs-string"></span>](<span class="hljs-link"><span class="hljs-link">auto&amp;&amp; x</span></span>) { return func(std::forward<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">decltype(x)</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(x)); }; //       // , ,        auto f=[](auto&amp;&amp;... x) { return func(std::forward<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">decltype(x)</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(x)...); };</code> </pre><br>  Well, that's probably all about lambda.  I predict that soon there will be a lot of elegant code that still uses unconscious possibilities of lambda expressions, something like the explosive growth of metaprogramming.  I stock up on popcorn. <br><br><h4>  Smart pointers, <i>Smart pointers</i> </h4><br>  Dangerous topic, mountains of paper are written on this topic, thousands of young commentators with burning eyes are mercilessly banned on various forums.  However, trust in Myers, he promises, literally <blockquote>  ‚ÄúI will focus on information that is often not in the API documentation, noteworthy usage examples, analysis of execution speed, etc.  Owning this information means the difference between using and efficiently using smart pointers. ‚Äù </blockquote>  Under such guarantees, I would rather venture into this raging holivar. <br>  In modern language, starting from C ++ 11, there are three types of smart pointers, <i>std :: unique_ptr, std :: shared_ptr &lt;&gt; and std :: weak_ptr &lt;&gt;</i> , all of them work with objects located on the heap, but each of them implements its own model manage your data. <br><ul><li>  std :: unique_ptr &lt;&gt; <i>single-handedly owns</i> its object and kills it when it dies itself.  Yes, he can only be one. </li><li>  std :: shared_ptr &lt;&gt; <i>shares</i> ownership with data from other peers, the object lives as long as at least one of the pointers is alive. </li><li>  std :: weak_ptr &lt;&gt; is relatively unknown, it extends std :: shared_ptr &lt;&gt; using more subtle control mechanisms.  Briefly, he refers to the object not capturing it, enjoys but does not own. </li></ul><br><br>  <b>std :: shared_ptr &lt;&gt; is the</b> most famous of this triad, however, since it uses internal reference counters for an object, it is noticeably less efficient than ordinary pointers.  Fortunately, due to the simultaneous appearance of atomic variables, operations with <i>std :: shared_ptr &lt;&gt; are</i> completely thread-safe and <i>almost</i> as fast as regular pointers.  However, <i>when creating a</i> smart pointer, the memory on the heap should be allocated not only for storing the object itself, but also for the <i>control unit</i> , in which reference counters and a reference to the allocator are stored.  Allocating this memory greatly affects the speed of execution and this is a very good reason to use <i>std :: make_shared &lt;&gt; ()</i> instead of creating the pointer with your hands, the latter function allocates memory for both the object and the control block at a time and therefore greatly benefits in speed.  Nevertheless, <i>std :: shared_ptr &lt;&gt;</i> is naturally twice as large as a simple pointer, not counting the memory allocated on the heap. <br>  <i>std :: shared_ptr</i> also supports non-standard memory allocators (normal <i>delete</i> by default), and such a nice design: the pointer type does not depend on the presence of the allocator and its signature. <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; p1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget(...), customDeleter); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; p2=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Widget&gt;(....);</code> </pre><br>  these two pointers are of the same type and can be assigned to each other, transferred to the same function, placed together in a container, although it is very flexible to allocate memory on the heap.  Unfortunately, <i>std :: make_shared</i> does not support nonstandard deallocators, you have to create with your hands. <br>  I also want to note that in C ++ <i>std :: shared_ptr &lt;&gt;</i> implements the concept of <i>a garbage collector</i> , the object will be destroyed when the last of its pointers no longer refers to it, and, unlike collectors in other languages, the destructor is called immediately and <i>deterministic</i> . <br>  Obviously, when working with a shared pointer, there is only one danger - to pass a raw pointer to the constructors of two different classes: <br><br><pre> <code class="hljs cpp">Widget *w=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; p1(w); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; p2(w);</code> </pre><br>  In this case, two control blocks with their reference counters will be created and, inevitably, sooner or later, two destructors will be called.  The situation is avoided simply, you should never use raw pointers to an object, ideally it is always better to use <i>std :: make_shared &lt;&gt; ()</i> .  However, there is an important exception: <br><br><pre> <code class="hljs cpp"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt;&gt; widgetList; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ widgetList.emplace_back(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre><br>  Here, Widget wants to insert itself into some external container, for which it needs to create a shared pointer.  However, the class object does not know, and cannot in principle know whether it has already been transferred under the control of another pointer, if so, this code will inevitably fall.  To resolve this situation, a CRTP class <i>std :: enable_shared_from_this</i> was created: <br><br><pre> <code class="hljs cpp"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt;&gt; widgetList; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> td::enable_shared_from_this&lt;Widget&gt; { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ widgetList.emplace_back(shared_from_this()); } };</code> </pre><br>  <s>In a magical way, the</s> inherited function <i>shared_from_this ()</i> will find and use the control block of the class, this is equivalent to copying a smart pointer if it was created, or creating it if it was not. <br>  In general, this is a great class - powerful, compact, extremely fast for its functionality.  The only thing that can be reproached is that it is omnipresent, it is used where it is necessary, where it is not necessary, and where it is by no means necessary. <br><br>  <b>std :: unique_ptr &lt;&gt; on the</b> contrary, is greatly underused in my opinion.  Just take a look at its characteristics - it takes exactly the same amount of memory as a regular pointer, its instructions are almost always translated to the exact same code as for a regular pointer.  This hints at the fact that it would be nice to think about your design, if the pointer is the only owner of the object at any given moment, then <i>std :: unique_ptr &lt;&gt;</i> is undoubtedly the best candidate.  Of course, thinking in terms of sharing / not sharing is not very familiar yet, but you also had to get used to the systematic use of <i>const</i> . <br>  A few more buns in the bundle, <i>std :: unique_ptr &lt;&gt; is</i> freely convertible (naturally <i>moved</i> ) to <i>std :: shared_ptr &lt;&gt;</i> , there is no way back, even if the reference count is 1. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> del=[](base_type* p) { ...; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> p; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;base_type, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(del)&gt; factory(Ts&amp;&amp;... args) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;base_type, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(del)&gt; p(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, del); ... p.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> derived_type(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(args)...)); <span class="hljs-comment"><span class="hljs-comment">//    std::unique_ptr&lt;&gt; //         //     return p; } //       //     std::shared_ptr&lt;base_type&gt;=factory(...args...);</span></span></code> </pre><br>  From the example, another bun is visible - <i>std :: unique_ptr &lt;derived_class&gt; is</i> freely converted to <i>std :: unique_ptr &lt;base_class&gt;</i> .  In general, an abstract factory is a natural pattern of use for this type of pointer. <br>  More buns can be initialized with an incomplete type ( <i>pimpl idiom</i> ), a convenient option for fans of this style.  And also, if you declare <i>std :: unique_ptr &lt;&gt;</i> constant, you cannot pass it up from the scope where it was created. <br>  You can also create <i>std :: unique_ptr &lt;&gt;</i> with a non-standard memory allocator, but unlike <i>std :: shared_ptr &lt;&gt;,</i> this affects its type: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">del1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">del2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget*)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(del1)&gt; p1; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Widget, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(del2)&gt; p2;</code> </pre>  here, p1 and p2 are two different types, this is the price you have to pay for the minimum size of the object, in addition, non-standard distributors are also not supported by <i>std :: make_unique</i> . <br>  And finally, the bun of which is <i>extremely not recommended to use</i> , unique pointers can be of the form <i>std :: unique_ptr &lt;T []&gt;</i> which can store an array, nonstandard distributors are incompatible with it, and generally, there are enough other types of containers in C ++. <br>  This is the most vivid example of the type for which copying does not make sense in design, but moving the other way around is a natural operation. <br><br>  <b>std :: weak_ptr &lt;&gt;</b> is a superstructure over <i>std :: shared_ptr &lt;&gt;</i> and, oddly enough, it sounds, it cannot be dereferenced, i.e.  the data he points to is not available.  Two almost single operations on it are a constructor from a shared pointer and conversion to a shared pointer. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sp=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Widget&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;Widget&gt; wp(sp); ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Widget&gt; sp1=wp; <span class="hljs-comment"><span class="hljs-comment">// 1 std::shared_ptr&lt;Widget&gt; sp2=wp.lock(); // 2</span></span></code> </pre><br>  That is, we can create a weak pointer from the shared one, store it for a while, and then try to get the shared pointer out of it again.  What for?  The fact is that <i>std :: weak_ptr &lt;&gt; does not own the</i> object to which it points, either individually as <i>std :: unique_ptr &lt;&gt;</i> , or cooperatively as <i>std :: shared_ptr &lt;&gt;</i> .  It only <i>refers</i> to this object and gives us the opportunity to <i>atomic</i> gain control over it, that is, to create a new shared pointer that owns this object.  Naturally, by this time the object may already be destroyed, hence the two options in the example.  The first, through the constructor, will throw an exception <i>std :: bad_weak_ptr</i> in this case.  The second option is softer, <i>std :: weak_ptr &lt;&gt; :: lock ()</i> will return an empty shared pointer, but you should not forget to check it before using. <br>  And what is it for?  For example, to store loadable objects in a temporary container cache, we don‚Äôt want to store the object forever in memory, but we don‚Äôt want to load the object every time it is needed, so we store the links as weak pointers and when prompted, if the pointer is hung, we load the object again, and if the object has already been loaded and has not yet been deleted, use the resulting shared pointer.  There is still a situation when two objects must refer to each other, refer to what?  The answer ‚Äúsimple pointers‚Äù is not accepted because their fundamental limitation is not to know what is there with the object you are pointing to, and if we use shared pointers, then this couple will permanently freeze in memory, keeping each other‚Äôs reference counters.  The solution is to use shared_ptr at one end and weak_ptr at the other, then nothing will keep the first object from being destroyed, and the second will be able to determine this. <br>  In general, although weak pointers are not very common, they make the picture complete and cover all holes in the application. <br><br>  On this, let me take this chapter as closed, there really is a lot written about smart pointers, I‚Äôd hardly add something new, even retelling Myers. <br><br><h4>  Universal links </h4><br>  On this topic, Myers continuously writes in a <a href="http://scottmeyers.blogspot.com/">blog</a> and lectures the past two years.  The concept itself is so amazing that it changes the usual methods of programming and working with objects.  However, there is something in it that doesn‚Äôt fit well in the head, at least in mine, so I ask the community for permission to start from the very beginning, from elementary foundations.  At the same time, I can give my thoughts in order. <br><br>  Recall what is <i>lvalue</i> and <i>rvalue</i> , the terms that are almost more years old than C ++.  <i>It</i> is relatively simple to define <i>lvalue</i> : this is all that can stand to the left of the assignment sign '='.  For example, all names are automatically lvalue.  But with <i>rvalue it is</i> much more foggy, as if everything that is <i>not an lvalue</i> , that is, can stand to the right of '=', but cannot stand to the left.  And what can not stand on the left?  Please read the entire list: well, firstly, naturally, literals, and secondly, the results of expressions not assigned to any variable, that intermediate result in the expression x = a + b;  which has <i>been</i> computed and <i>will be</i> assigned to x (this is easier to understand if you think of x not as a whole but as a complex class, obviously, the right part is first calculated and then the assignment operator x is called).  However, remember: the <b>name is always <i>lvalue</i></b> , it really matters. <br><br>    (  ,       )          ,        ,          . ,  <i>std::map</i> ‚Äî   ,  <i>std::swap</i>      ,          <div class="spoiler"> <b class="spoiler_title"> !! </b> <div class="spoiler_text">     stl   <i></i>   ,       .       ,    <i>std::swap</i>  . </div></div>  ,     <i>std::map</i>        <i>std::map</i> ,       ,          <i>std::swap</i> ,      . ,     ()     -  ,   ?     ‚Äî      .   <i>rvalue references</i>   &amp;&amp;.  <i>type&amp;&amp;</i>   ,   <i>type</i> ,    <i>type&amp;</i>  <i>type*</i> ,  ,      , ..       ,      . <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> x1=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;&amp; x2=<span class="hljs-number"><span class="hljs-number">0</span></span>; // assigning lvalue <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> rvalue <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;&amp; x3=x1; // error: cannot bind <span class="hljs-string"><span class="hljs-string">'int'</span></span> lvalue <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">'int&amp;&amp;'</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;&amp; x4=std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(x1); // x4 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-type"><span class="hljs-type">name</span></span>, so it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> lvalue here <span class="hljs-type"><span class="hljs-type">int</span></span>&amp;&amp; x5=x4; // error: cannot bind <span class="hljs-string"><span class="hljs-string">'int'</span></span> lvalue <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">'int&amp;&amp;'</span></span> auto&amp;&amp; x6=<span class="hljs-number"><span class="hljs-number">0</span></span>; auto&amp;&amp; x7=x1;</code> </pre>           ‚Äî <i>type&amp;&amp;</i>    ( <i>rvalue reference</i> )  <i>type</i> . <div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text">       ,       ,   . </div></div><br>    ,  <i>type&amp;&amp;    rvalue reference</i> ,     <i>  (type deduction)</i> ,          <i>auto</i>      ,    ,     <i>  (universal references)</i> . <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; param)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; var2 = var1;</code> </pre><br>       (  ),    param  var2    . <br><br><pre> <code class="hljs ruby">Widget w; f(w); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> f(std::move(w)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br> param ‚Äî   ,        <i>lvalue</i>     <i>  (lvalue reference)</i> ‚Äî Widget&amp;.       <i>rvalue</i>     <i> </i> ‚Äî Widget&amp;&amp;. <br><br>        T&amp;&amp;    (,  o T&amp;  T&amp;&amp;),         T&amp;&amp;.    : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp;&amp; param)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp;&amp; param)</span></span></span></span>;</code> </pre><br> param   <i>rvalue reference</i> ,        ,    : ¬´cannot bind lvalue to rvalue¬ª     ,        lvalue reference  .    T&amp;&amp;     : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; x)</span></span></span></span>; ... };</code> </pre><br>  ,  <i>push_back</i>      T&amp;&amp;     ,     ,   ,      <i>rvalue</i> . <br><br>      C++14   -        <i>rvalue references</i>  <i>universal references</i>     <i>auto&amp;&amp;</i>        . <br><br>       , <i>std::move  std::forward</i> ,           : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) move(T&amp;&amp; param) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp;&amp;&gt;(param); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&amp;&amp;&gt;(param); }</code> </pre><br>    ,   <i>std::move</i>   &amp;&amp;   <i>std::remove_reference_t</i> [C++14] ..        T&amp;&amp;,      <i>rvalue reference</i> .    ,  <i>std::forward</i>   ,  <i>lvalue reference</i>    <i>lvalu</i>  <i>rvalue reference</i>   ,    . <br><br>        <i></i>      name (   ),           <i>rvalue</i> <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... Widget(Widget&amp;&amp; x) : name(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(x.name)) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; _name)</span></span></span><span class="hljs-function"> </span></span>{ name=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(_name); } };</code> </pre> ,    setName()      ,     <i>rvalue</i>   <i>lvalu</i> ,  &lt;i&lt;std::forward           .           <i>std::move</i> ,         ,     . <br> <b> success-story</b> :      C++98 : <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; names; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> </span></span>{ ... names.insert(name); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">" "</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; add(name); <span class="hljs-comment"><span class="hljs-comment">// 1 pass lvalue std::string add(std::string("")); // 2 pass rvalue std::string add(""); // 3 pass string literal</span></span></code> </pre><br>       ,             .       <i></i>    ,     .      ‚Äî   const char* ,          ,   .    <i></i>  <i></i>  .          . <br><br>  ,      : <br><br><pre> <code class="hljs ruby">template&lt;typename T&gt; void add(T&amp;&amp; name) { ... names.emplace(std::forward&lt;T&gt;(name)); } std::string name(<span class="hljs-string"><span class="hljs-string">" "</span></span>); add(name); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> pass lvalue std::string add(std::string(<span class="hljs-string"><span class="hljs-string">""</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pass rvalue std::string add(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> pass string literal</code> </pre><br>         ,       ,            <i>std::set::emplace()</i> .               . <br><br> ,    -   ,              ,            ( <i>perfect forwarding</i> ).      C++             .    <i>std::move</i>        -    : ¬´             ¬ª ( ,   ).          C++            .       19..-, C++             ,         . <s>     </s>  ,   . <br><br><h4>  API </h4><br>          ,     .       ,    - ,       : <a href="http://www.amazon.ca/C-Concurrency-Action-Practical-Multithreading/dp/1933988770">C++ Concurrency in Action</a> .    . <br><br>        ,      .    <a href="http://habrahabr.ru/post/248137/"></a> ,  . </div><p>Source: <a href="https://habr.com/ru/post/248901/">https://habr.com/ru/post/248901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248891/index.html">Do not rush to throw out the old servers, you can assemble fast Ethernet-storage in an hour</a></li>
<li><a href="../248893/index.html">Practice "Intel IoT". Galileo Gen2 - Linux & Arduino</a></li>
<li><a href="../248895/index.html">Buttons do not happen much</a></li>
<li><a href="../248897/index.html">C ++ 11 variadic templates and long arithmetic at compile time</a></li>
<li><a href="../248899/index.html">We write extensions with Roslyn by 2015 studios (part 1)</a></li>
<li><a href="../248903/index.html">Launch Linux in Microsoft Azure</a></li>
<li><a href="../248907/index.html">Software routing with VyOS</a></li>
<li><a href="../248909/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.1 of 6</a></li>
<li><a href="../248911/index.html">CSS Report 2014: Testing the use of CSS in the ‚Äúfield‚Äù</a></li>
<li><a href="../248913/index.html">We write extensions with Roslyn by 2015 studios (part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>