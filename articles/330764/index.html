<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Virtual creatures and their habitats: the past and present TTY in Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ubuntu is integrated into Windows 10 Redstone, Visual Studio 2017 has gained support for developing for Linux - even Microsoft is losing ground in fav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Virtual creatures and their habitats: the past and present TTY in Linux</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/web/e86/4ed/36b/e864ed36bd8144ec84b264c7b941ccab.jpg">  Ubuntu is integrated into Windows 10 Redstone, Visual Studio 2017 has gained support for developing for Linux - even Microsoft is losing ground in favor of the growing number of Torvalds supporters, but you still don't know the secrets of the virtual terminal in modern distributions? <br><br>  Do you want to fix this space and open the source code?  TTY, MASTER, SLAVE, N_TTY, VT, PTS, PTMX ... A heap of concepts, virtual devices and random magic?  It all adds up to a rather logical picture, if you remember how it all began ... <br><a name="habracut"></a><br><h3>  <b>1. START FROM SCRATCH &amp; KEEP CALM</b> </h3><br><h3>  <b>TTY: PALEOSIC</b> </h3><br><img align="left" src="https://habrastorage.org/web/2f6/e80/44b/2f6e8044bc8a42769493222aef4cc121.jpg">  We stepped straight into the thirties of the 20th century and found ourselves in the still very young Teletype Corporation.  Directly in front of us is He-S-Who-All-Started ‚Äî a teletype, which is a ‚Äúdirect-printing telegraph,‚Äù which transmits text messages between two subscribers. <br><br>  Subscriber A dials characters on the keyboard that are converted into electrical signals.  By the most ordinary cable, the signals ‚Äúrun‚Äù on the teletype of subscriber B and are already printed there on the most ordinary paper.  If the signal is duplex, then we are very lucky, and subscriber B can immediately write his answer;  if not, then he will need to first connect the second wire for feedback. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img align="right" src="https://habrastorage.org/web/a25/045/dec/a25045decb2c4e3880d64778b654963d.jpg"><br>  Here, at Teletype Corporation, they still don‚Äôt know what the future is in store for their product, and they certainly don‚Äôt suspect that the TTY will outlive the TTY abbreviation.  We will not spoil the intrigue for them, let's go further. <br><br><h3>  <b>TTY: MEZOZA</b> </h3><br><img align="left" src="https://habrastorage.org/web/850/04c/e89/85004ce8945e4d36b2dc4010e32aa470.jpg">  Forty years have passed, we are in the laboratory of Digital Equipment Corporation, admiring the first mini-computer (interactive!) PDP-1.  For the input and output of information, as well as to ensure user interaction, the already familiar teletype is connected to it. <br><br>  The fact is that the leading engineering minds decided not to reinvent the wheel and adapt the already existing cheap and accessible mechanism for new needs.  The teletype was directly connected to the computer (and not to another teletype, as it was before) and they called this case a <b>console</b> .  The operator performing the input sees how the characters typed are instantly printed on paper, but this happens without the participation of the OS - thanks to <b>the</b> typewriter principle stored in the <b>console</b> . <br><br><h3>  <b>TTY: PALEOGEN</b> </h3><br><img align="right" src="https://habrastorage.org/web/f10/8eb/6cd/f108eb6cd72a416b97519b0675be2cc4.jpg">  We find ourselves at the very beginning of the 80s, this time at Bell Laboratories.  One of the most important releases of the ‚Äúearly‚Äù UNIX version 7 for PDP-11 has just been released here.  The features of this release are as follows: the user-entered command is now displayed on the ECHO principle (the character typed on the keyboard first enters the accumulation buffer and only then does the OS send instructions to print this character), simple editing options for the commands entered are supported (you can ‚Äúerase‚Äù the character or whole line, move the caret), there is a separation of modes: <br><br><ul><li>  <b>raw mode</b> (line editing is not performed; control sequences are recognized as normal characters; the entered character is immediately transferred to the process); </li><li>  <b>cooked mode</b> (special characters are recognized and the stop and interrupt signals are generated for the process; the finished line is transferred to the process only after pressing the Return key). </li></ul><br>  Quite an expected question: how can you "erase" what has already been printed teletype?  To visually perform Unix Version 7 editing operations, you can print certain characters: for example, @ - erase the entire line, # - erase the last character.  That is, if our teletype typed ld @ lk # s, and the operator pressed Return, then the ls command went to be executed.  This is not TTY LINE DISCIPLINE (it will be discussed further), but a big step forward in terms of processing input at the OS level. <br><br><img align="right" src="https://habrastorage.org/web/43e/a21/3ee/43ea213ee4df456c98010ef97c7c06fe.jpg">  By the way, for these 20 years Digital Equipment Corporation not only developed the aforementioned PDP-11, but also thought about how to improve the teletype: the so-called smart terminals appeared. <br><br>  We look to the right: this is the VT100, one of the first terminals able to work in love and harmony with the PDP-11 and supported by Unix Version 7. <br><br>  At the OS level, both the console and the smart terminal are now perceived as character devices that are connected via the UART interface, which converts the asynchronous data stream into a sequence of characters.  For the OS, they are basically identical, the only difference is whether to erase the characters on the terminal screen or print the face character using a teletype. <br><br><img align="left" src="https://habrastorage.org/web/5ad/ba0/f06/5adba0f068db4a8d9538539c88087b57.jpg"><br>  The left shows a general scheme of interaction between the computer and the console (or smart terminal).  This scheme has one drawback, which is not at all pleasing to the operator of the PDP-11 console: one session (or session) is associated with one console, in which the user can start several processes in the background, but only one at a time will be active on one TTY one. <br><br>  And our poor operator is forced in the literal sense of the word to move from one console to another, if he suddenly comes up with a few sessions. <br><br><h3>  <b>Tty: neogene</b> </h3><br><img align="left" src="https://habrastorage.org/web/028/d7e/a7c/028d7ea7c2cb443cb22ff2aa244bc461.jpg">  We found ourselves in the editorial office of PC MAGAZINE, we are considering the latest issue of January 13, 1987.  One of the reversals actively convinces us not to spare money on a PC with UNIX System V. What are the arguments?  In particular - grep, awk, sort, split, cut, paste, vi, ed - word processing has clearly stepped forward.  And the most interesting: terminal emulators are now at our service!  Thanks to virtual consoles, it is already possible to run as many as four sessions without the need to connect more and more new physical teletypes. <br><br>  In addition, the life of monochrome terminals can now be colored: it supports CGA, Hercules, EGA graphics.  The poor-man operator can breathe easy, the teletype (as well as the smart terminal) in the form of an iron beast threatens him only in nightmares. <br><br>  We will only advise the operator: never go into the / dev directory - after all, there are several ttyX waiting for him and remind you that the same good old teletype lives under the hood of the virtual console. <br><br><h3>  <b>TTY: ANTHROPOGEN</b> </h3><br>  At the previous step, we were convinced: the console was made virtual (there will not be a solid edition of PC MAGAZINE to lie).  What does it mean - the entire I / O mechanism is rewritten and completely changed?  Then why is the virtual device still ttyX?  It's simple: the virtual console is emulated as the most physical, and the place of the UART driver is probably taken by someone else.  The changed scheme will be discussed in detail a little further. <br><br>  There is only one step to the finish line, but we cannot even skip it out of respect for Linus Torvalds.  Now is the year 1993, and we finally have the good fortune to review the source code for Linux 0.95.  Why this particular release?  It is there that the TTY-abstraction has already formed, which is closest to what we have in the latest distributions: three distinct layers formed ( <b>TTYX - TTY_LINE_DISCIPLINE - TTY_DRIVER</b> ). <br><br>  In addition, Linux 1.0 will be released just a year later, where the window interface provided by the XFree86 project will appear.  From this point on, <b>virtual terminals</b> will be added to the <b>virtual console</b> , which the user (in almost unlimited quantities) will be able to run without leaving the graphical shell ... However, before plunging into the subtleties and details of the improved io-magic, let's return to our present to Ubuntu 16.04. <br><br><h3>  <b>2. STOP BEAT AROUND THE BUSH &amp; LOOK INSIDE</b> </h3><br><br><h3>  <b>VIRTUAL CREATIVES AND PLACES OF THEIR HABITATION</b> </h3><br>  Only some devices in the / dev / directory are used daily: / dev / sdaX, / dev / mem, / dev / zero, / dev / random ... But there are several groups of devices that do not often attract our attention, but more than deserve it.  These devices are / ttyX, / vcsX, / vcsaX, as well as / ptmx and / pts / X.  In fact, they will be discussed further. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/cf1/c99/181/cf1c9918187f4e3aa880d368fc1b35b4.jpg"></div><br><br>  And our first object is a virtual console.  Each such object has at least a <s>sacred number</s> identifier and a <s>totem animal</s> virtual device / tty file, of which 64 are found in the virtual forest of the / dev directory. <br><br>  Check if we have the opportunity to talk with them.  We execute Ctrl-Alt-FX (or chvt X, where X is the console number, for example, Ctrl-Alt-F1) and notice that X can be equal to 1, 2 ... 6. At the same time, we open a virtual console when we first start we are prompted to enter a username and password and create a new session for us.  If X is 7, then we return to our native graphics cores and understand that / tty7 is associated with XServer.  Go ahead.  Eight, nine, ten and so on up to 63 - do not give signs of life. <br><br><img align="left" src="https://habrastorage.org/web/021/487/1a5/0214871a570d42b09b69b776580d729b.jpg">  The fact is that in Linux there is a macro MAX_NR_CONSOLES (64), which defines the maximum allowable number of virtual consoles, which are represented by 64 virtual device files / dev / ttyX.  However, the last word is left behind the parameter ACTIVE_CONSOLES (/ etc / default / console-setup), and this parameter defaults to six. <br><br>  Initialization of consoles occurs in several stages.  First, the kernel, after receiving control from Grub, during the initialization of the subsystems, calls the ‚Äúconsole_init‚Äù function, which creates the primary console, the ‚Äúboot console,‚Äù designed to display debug information.  This console performs the output of characters in the most primitive way: through ‚Äúputchar‚Äù, which directly accesses the BIOS, initializing and filling in the biosregs structure, and outputting a character to the console using the 0x10 interrupt. <br><br>  Later, during the execution of ‚Äúfs-initcall‚Äù and ‚Äúconsole-initcall‚Äù, virtual devices and structures are created under 6 full-fledged virtual consoles - ‚Äúreal console‚Äù.  The activation of these consoles is performed by the first / sbin / init process launched by the kernel, which launches the getty program, which reads the /etc/init/console.conf and /etc/init/tilX.conf configuration files and subsequently displays the contents of the welcome file etc / to the console issue and launch login.  Next, XServer initiates console activation on dev / tty7, on which the graphical shell runs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/676/3df/0f6/6763df0f6a3e49efbc2646991cedc175.jpg"></div><br><br>  However, we still have questions.  What an unknown object / dev / tty0?  And if each / dev / ttyX is a virtual console device, then why do we need / dev / console and / dev / tty?  For the answer, go to tty1 (by pressing Ctrl-Alt-F1) and run the following script in the background: <br><br><pre><code class="bash hljs">sleep 10 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äútty0‚Äù &gt; /dev/tty0 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äútty‚Äù &gt; /dev/tty <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äúconsole‚Äù &gt; /dev/console</code> </pre> <br>  Then go to, say, tty4 and wait a few seconds.  After the expiry we see the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/cf7/8a9/3a6/cf78a93a6dc542d1b28d8ba1e1a21484.jpg"></div><br>  The distribution of roles becomes clear: / dev / tty0 = / dev / console = current console, i.e.  both are always associated with the console that we currently see in front of us, and / dev / tty ‚Äúremembers‚Äù the console with which the process started.  Therefore, while our process was running, / dev / tty0 and / dev / console were defined for it in the course of the play, depending on the current active console, but / dev / tty remained unchanged. <br><br>  Do not rush to leave the directory / dev.  There are a little more than a dozen of curious objects: / dev / vcsX (virtual console screen) and / dev / vcsaX (virtual console screen with attributes).  Another experience: move to tty5 and leave some traces of your stay, then go to any other console (even if its number 3), do ‚Äúcat‚Äù on / dev / vcs5 and see exactly the state of console 5, in which we left her a few seconds ago.  In this case, respectively, / dev / vcs3 and / dev / vcs (as well as / dev / vcsa) belong to console 3, on which we are at the moment. <br><br>  We understand that / dev / vcsX is nothing more than a <s>pool of memory, a</s> device of virtual memory of the console, which allows us to move without loss between instances of tty.  Paired with it is / dev / vcsaX, which provides basic information about the screen state: colors, various attributes (eg flicker), current cursor position, screen configuration (number of rows and columns).  Summing up the scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f05/de1/da9/f05de1da96304620a5752d9ab52190d4.jpg"></div><br><br><h3>  <b>TOP VIEWS BETTER</b> </h3><br>  Now we‚Äôll stop with the study of tty zoology for a while and move on to the tty-abstraction itself, of which our virtual devices are a part.  Let's look at the general structure of the tty-complex and select three components: <br><br><ol><li>  <b>/ dev / ttyX</b> is a virtual console device in the file system that took the place of the UART driver and with which we are already familiar.  At the same level, the devices / dev / vcsX and / dev / vcsaX are located, communication with them is carried out directly through / dev / ttyX. </li><li>  <b>TTY Line Discipline</b> is a driver that makes ECHO a recruited command and allows us to edit it.  Also, the driver of this layer generates signals when typing control sequences (^ C, ^ Z, etc.).  By default, N_TTY reigns here, but this module can be replaced, for example, with its driver - let's experiment with it a little later; </li><li>  <b>TTY driver</b> is a driver that provides a set of methods for initializing and opening the console, as well as methods that process input / output operations, suspend the console when switching and restarting its work, and, of course, provides for ‚Äútransferring‚Äù the command received from the user to the active process. </li></ol><br>  Remember the complaints of the operator PDP-11?  He did not like to waste time on transitions from one physical console to another.  Now the situation is as follows: we have 7 virtual consoles by default, and in front of them - an office chair on wheels (of course, also virtual).  When we switch from one console to another, the operating system moves our chair to the desired tty, and together with the chair "switches" to it and the complex of physical io-devices: the monitor now has the state of our new console, it also receives keyboard input and etc. <br><br>  At the same time, the processes from the first tty continue to work: they read commands from the file of their virtual console, write to this file, but - since they are torn off the ‚Äúchair‚Äù - they do not receive any events (the same ^ C and ^ Z) and - because the physical devices ‚Äúleft‚Äù along with the ‚Äúchair‚Äù - they can only accumulate their ‚Äúoutput‚Äù in the buffer in order to send it to the monitor as soon as the ‚Äúchair‚Äù returns. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/607/06d/d58/60706dd5893c4aaab92dcf16ee062935.jpg"></div><br><br><h3>  <b>TRAVELING TO THE CENTER OF THE EARTH</b> </h3><br>  Yes, from above everything looks quite presentable.  But you,%% username, probably want to see how the three-level interaction of tty-components is implemented directly in the code?  For the answer, you will have to descend from heaven to earth, even better to say - underground, into the depths of the Ubuntu source code (we will work with the kernel of version 4.4). <br><br>  Let's make a preemptive move - let's see through which structures the tty-abstraction is linked into a single whole. <br><br>  First, it is ‚Äútty_struct‚Äù, which has a field ‚Äútty_ldisc‚Äù (this is the structure of the 2nd layer driver methods), a field ‚Äútty_driver‚Äù (this is the 3rd layer driver) and immediately ‚Äútty_operations‚Äù (this is the structure of the driver methods 3rd layer, for the sake of convenience, rendered directly to the "tty_struct"). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/82b/e02/9dc/82be029dc643498482dd596c696b913e.jpg"></div><br>  That is, ‚Äútty_struct‚Äù provides access to the TTY_LINE_DISCIPLINE and TTY_DRIVER layers.  Got access to it - 2/3 stack of tty-abstraction, consider, in front of us.  Now we need to understand how the transition from the virtual device files to this very structure is carried out.  The answer is simple: the ‚Äútty_file_private‚Äù structure just has a ‚Äútty_struct‚Äù type field.  Therefore, referring to the virtual device file on the 1st level, we can easily access the levels higher. <br><br>  While the puzzle is taking shape, but this is not enough for us.  Let us run the kernel (using qemu and cgdb) and consider the backtrace of the output (echo) of a single character entered by the user from the keyboard: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0ef/c0c/640/0efc0c640299474da2122da6a3fb7021.jpg"></div><br>  So, we are at level I of the tty stack.  The ‚Äúwrite‚Äù system call occurs, which is processed by the ‚Äútty_write‚Äù function on our tty.  It is passed a pointer to the structure of the virtual device file and a buffer with a symbol.  In the tty_write function, the tty_struct instance is received from the file.  When accepting the game, ‚Äútty_struct‚Äù first of all causes the TTY_LINE_DISCIPLINE driver - ‚Äútty_ldisc‚Äù, the default location of which is N_TTY.  The first level is passed! <br><br>  N_TTY accepts the baton: in turn, calls the ‚Äún_tty_write‚Äù method, and then transfers the buffer to the ‚Äúoutput_process_block‚Äù function, which, having made sure that we have entered no carriage positioning symbol, asks ‚Äútty_struct‚Äù to call ‚Äútty_driver‚Äù.  That's right, we go to level III. <br><br>  ‚ÄúTty_struct‚Äù successfully plays the role of an intermediary, and now - the ‚Äúcon_write‚Äù method of the tty driver named ‚Äúconsole_driver‚Äù is already running.  A driver of the third level would be happy to do his job, but he is alone, many consoles - which one should you work with?  The tty_struct comes to the rescue again and hands the driver the necessary instance of the vc structure (it is responsible for the state of its specific console and contains its keyboard, screen settings, as well as a set of graphical display methods). <br><br>  "Console_driver" locks the console and calls "vc_data" to finally execute the echo character.  ‚ÄúVc_data‚Äù realizes with horror: they turned to her not for the sake of the question of the state of health of the console entrusted to her, but for the sake of action.  This means only one thing: it's time to call for help the ‚Äúconsw‚Äù methods, which in our case represents VGA (with a different kernel configuration, this could be, for example, a framebuffer).  And for sure - VGA quickly takes on the case, hides the cursor, prints the character, scrolls the screen if necessary or switches to a new line, moves and displays the cursor.  ‚ÄúVc‚Äù exhales: ‚Äúconsole_driver‚Äù accepted the job and unlocked the console.  We can breathe out and we, because all three levels have been successfully completed, each component has completed its mission. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0e5/aa6/d8e/0e5aa6d8e51742bcb7f4937df9b48f33.jpg"></div><br><br><h3>  <b>3. KEEP AN EYE ON VIRTUAL TERMINAL</b> </h3><br>  But that's not all: it's time to get acquainted with representatives of another class of inhabitants / dev - with <b>terminal emulators</b> .  These are the same xterm or gnome-terminal, which we run from a console equipped with a graphical shell, using, for example, Ctrl-Alt-T or Ctrl-Shift-T. <br><br>  They live in a separate aviary / dev / pts (= pseudo-terminal slave) and are files with numbers 0, 1, 2, etc.  Perform ps in the current terminal and see - we are on / dev / pts / 1.  Press Alt + 5 - we move to our fourth in order of opening the terminal, the virtual device file is / dev / pts / 20.  At any terminal we are met by bash, with each terminal is associated with its many processes.  No surprises yet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d66/d9a/36c/d66d9a36c26746c8a65b5acb7118e4d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/web/860/833/3ff/8608333ffc3d43e2a51d9b256f6f77c6.jpg"></div><br>  But note: / dev / pts / X are created dynamically, run on the same console / dev / tty7, do not require login to start, and the most interesting is that there is no ‚Äúchair‚Äù rule: we can open several virtual terminals and simultaneously observe how work is done on each one of them.  Once again,% username% may give rise to doubts: does the principle of tty-abstraction persist here and how does the device fit into this principle ‚Äî the slave, which is probably controlled by a certain device ‚Äî the master? <br><br>  The new object does not keep you waiting: in a single copy, the ptmx file is in the same / dev directory (In fact, it may not be the only one: if more than one console with a graphical shell is running).  By mana, when opening / dev / ptmx, the subordinate part of the / dev / pts / X pseudo-terminal is created, which is associated with its leading part ‚Äúptm‚Äù (accessed via the file descriptor, but the real file is not created).  Then "ptm" is passed to the functions grantpt and unlockpt, and after all this you can open directly / dev / pts / X, which will behave exactly like a virtual console (except for the features described above). <br><br>  For us in the idea key of tty-abstraction, this means the following: when a user wants to start <b>a terminal emulator</b> , XServer requests / dev / ptmx to create a virtual device / dev / pts / X.  The powerful ‚Äúmultiplexer‚Äù / dev / ptmx kindly does this, assigns the device file to the terminal instance and ... / dev / pts / X takes the place of / dev / ttyX, it is assigned the TTY_LINE_DISCIPLINE layer driver, it is gently received by TTY_DRIVER.  The stack above / dev / pts / X takes on the usual form.  The task of studying <b>the terminal emulator</b> mechanism smoothly reduces to the previous history with a <b>virtual console</b> , but its detailed study requires a separate article (which is included in the plans for the future!). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3a2/f47/5da/3a2f475da6c841f18c8cd24256d145ca.jpg"></div><br><br><h3>  <b>4. LET'S PLAY WITH TTY LINE DISCIPLINE</b> </h3><br>  For a moment, remember the tty- "Paleozoic": there was a time when the TTY_LINE_DISCIPLINE layer was not a separate layer and did not have a full-fledged modern functionality.  Let's try to estimate the weight of the changes that have occurred since then. <br><br>  First, make sure that we are really dealing with N_TTY: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1f0/6cb/cb2/1f06cbcb2ef747159e96d07e21895c84.jpg"></div><br>  Everything is relative, therefore we act cardinally and with the help of stty we disable all the useful features of N_TTY: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/af7/d7d/ebf/af7d7debf89f450fa9881770e761e119.jpg"></div><br>  The result clearly demonstrates the area of ‚Äã‚Äãresponsibility of N_TTY, without which the output is not formatted, input is not displayed.  Moreover, if we open a new terminal, then we will be convinced of the integrity and integrity of its LINE_DISCIPLINE.  The resulting effect makes me think: we know exactly which component handles all our input, we can modify it for each virtual terminal separately and, I remember, we heard that this component can be replaced by loading your own module. <br><br>  Unfortunately, N_TTY itself is part of the kernel.  Therefore, we take as a basis the other drivers of the LINE_DISCIPLINE layer, provided in Linux and loaded as modules.  In their image and likeness, we modify the source code file n_tty.c: <br><br><ol><li>  Add a module shipping function, in which the tty_register_ldisc function is called, which ‚Äúacquaints‚Äù the kernel with our personal line of discipline.  In this function, the first parameter is its unique identifier, and the second is a pointer to the structure with driver methods. </li><li>  Add the ‚Äúunloading‚Äù function of the module, in which the tty_unregister_ldisc function is called, respectively. </li><li>  In the tty_ldisc_ops structure itself, we will give a new name for the driver. </li><li>  We will make sure that our module ‚Äúlearns‚Äù the functions it needs from the tty_io.c file (it does not please us with the EXPORT SYMBOL macros, which forces us to either finish all the required functions manually or link together with tty_io.c). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c7c/15f/a4a/c7c15fa4aad348ddb45988adcf9b9ea2.jpg"></div><br>  Now we add some functionality that distinguishes our line of discipline from the original.  Remember that it is TTY_LINE_DISCIPLINE that processes service sequences, so it‚Äôs a sin not to conjure in this field.  To do this, open the function "n_tty_receive_char_special", in which TTY_LINE_DISCIPLINE checks whether the entered characters are not special and, when it is found, sends the appropriate signal.  For example, we swap the signals generated for Ctrl + Z and Ctrl + C: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a5a/bf3/f60/a5abf3f6014c40c0a18af7f8bfdc0550.jpg"></div><br>  After that, we receive from our modified file the kernel module our_ldisc.ko directly.  Download it, make sure the download is successful.  Verify that "our_modyfied_ldisc" actually registered as TTY_LINE_DISCIPLINE.  Open the terminal and see the number of pts.  After that, we assign our driver responsible for the / dev / pts / X TTY_LINE_DISCIPLINE layer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e7d/988/c83/e7d988c83b304e63bedbacdc8ab1ecb0.jpg"></div><br>  Let's set up a new line of discipline with the help of the ‚Äústty echo cooked‚Äù command - now the terminal is working in our usual mode.  Run the test program with an eternal cycle and compare the effect of Ctrl + Z and Ctrl + C: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/470/ae5/901/470ae59014a4439ca3f1eddb0a030312.jpg"></div><br>  We have achieved the desired: generation of signals is redefined at <b>the driver level of the</b> TTY_LINE_DISCIPLINE <b>layer</b> individually for one terminal emulator!  There is a field for fantasy work: from magic tricks with processing utility sequences to a custom command filter. <br><br><h3>  <b>FINALLY</b> </h3><br>  Now for you,% username%, secrets of virtual consoles and terminal emulators are no <b>longer</b> secrets, random magic is <b>not</b> magic, but a technology that has traveled a considerable way to create a flexible tty subsystem, and a teletype is <b>not an</b> artifact of antiquity, but an invention (by the way , our, domestic), without the descendants of which the modern computer somehow does not want to be presented. <br><br>  We love to tell fascinating stories.  Do you want to listen to them live?  Come to the "confrontation" <a href="http://neoquest.ru/">NeoQUEST-2017</a> , there you will <a href="http://neoquest.ru/">find</a> <a href="https://habrahabr.ru/company/neobit/blog/330014/">many interesting reports</a> : from "hardware" to cryptography!  Admission is free when registering on the site. </div><p>Source: <a href="https://habr.com/ru/post/330764/">https://habr.com/ru/post/330764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330754/index.html">Full immersion in virtual reality: the present and the future</a></li>
<li><a href="../330756/index.html">Operation ‚ÄúMigration‚Äù: if your mail is somewhere there, but you need to be here</a></li>
<li><a href="../330758/index.html">GIS and distributed computing</a></li>
<li><a href="../330760/index.html">Working with the server using Alamofire on Swift</a></li>
<li><a href="../330762/index.html">The cost of the error: who pays for the programmers' mistakes and how much?</a></li>
<li><a href="../330772/index.html">Apache step-by-step configuration with the choice of versions of php + Nginx as reverse proxy (with mod_pagespeed) on ubuntu 16.04</a></li>
<li><a href="../330774/index.html">Facebook Mobile Advertising Test</a></li>
<li><a href="../330776/index.html">OpenStack Test Automation</a></li>
<li><a href="../330778/index.html">Release Rust 1.18</a></li>
<li><a href="../330782/index.html">Lectures Tehnotreka. Linux administration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>