<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MongoDB from theory to practice. MongoDB Cluster Installation Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear readers. In this post I would like to describe several examples of mongoDB scan, the differences between them, the principles of their ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MongoDB from theory to practice. MongoDB Cluster Installation Guide</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear readers.  In this post I would like to describe several examples of mongoDB scan, the differences between them, the principles of their work.  However, most of all I would like to share with you the practical experience of sharding mongoDB.  If this post had a plan, it would most likely look like this: <br><br><ol><li>  Introduction.  Scaling brief </li><li>  Some examples of mongoDB scan and their description </li><li>  Sharding mongoDB </li></ol><br>  Points 1 and 2 are theoretical, and number 3 claims to be a practical guide to raising the mongoDB cluster and is best suited to those who are faced with this for the first time. <br><a name="habracut"></a><br><h2>  1. Entry  Little about scaling </h2><br>  Imagine a typical case - there is a database in which data is written and read.  In dynamically growing systems, data volumes tend to increase rapidly and sooner or later you may encounter a problem when the current resources of the machine are not enough for normal operation. <br>  Scaling is used to solve this problem.  Scaling happens 2 types - horizontal and vertical.  Vertical scaling - increasing the capacity of one machine - adding CPU, RAM, HDD.  Horizontal scaling - adding new machines to existing ones and distributing data between them.  The first case is the simplest, because  does not require additional settings of the application and any additional configuration of the database, but its disadvantage is that the power of one machine theoretically sooner or later come to a standstill.  The second case is more complicated in configuration, but has several advantages: <br><ul><li>  Theoretically infinite scaling (you can put as many machines as you like) </li><li>  Greater data security (only when using replication) - the machines can be located in different data centers (if one of them falls, others will remain) </li></ul><br><br><h2>  2. Some examples of mongoDB scan </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  2.1 The simplest scheme, without sharding </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c83/019/bb5/c83019bb55dcee2584516b71e16de3cb.jpg"><br><br>  In this scheme, everything is simple - there is an application that communicates with mongod through a driver.  mongod is the main mongoDB process whose task is to receive requests, process and execute them.  The data in mongod is stored in the so-called chunks.  Each chunk has a size of ‚Äúchunksize‚Äù, which is 64 MB by default.  Physically, chunks are stored in dbName.n files, where n is a sequence number, starting from 0. When the size reaches 64 MB (or another chunksize) the chunk is divided in half, it turns out 2 less chanics - 32 MB each, these 2 chanks begin to fill until reach the size of chunksize, then the separation occurs again, etc.  The dbName.0 file size is 64 MB, dbName.1 is 128 MB, dbName.2 is 256, and so on.  up to 2Gb.  As the number and size of chunks grows, these files are filled and when there is a first file - dbName.5, the size of which is 2 Gb, the size growth stops and mongoDB simply creates files of the same size.  It should also be noted that mongoDB does not just create these files as necessary, but creates them in advance so that if it is necessary to actually write data to the file, do not waste time creating the file.  Therefore, with a relatively small amount of real data, you can find that the hard disk space is decently occupied. <br>  This scheme is applicable most often for local testing. <br><br><h4>  2.2 Shardirovannaya scheme without replica sets </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f7/ccf/a64/0f7ccfa64118aa1fe959373f056f741a.jpg"><br><br>  In this scheme, new items appear.  The pattern is called shardirovannoy.  An important difference between the shardirovannogo scheme - her data is not just written in chunks, which are then divided in half, and fall into them on a certain range of a given field - shard key.  First, only one chunk is created and the range of values ‚Äã‚Äãit takes is within (-‚àû, + ‚àû): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/940/0fc/b7b/9400fcb7bd5229c60c96550c70863893.jpg"><br><br>  When the size of this chunk reaches chunksize, mongos evaluates the value of all the shardkei inside the chunk and divides the chunk in such a way that the data are divided approximately equally.  For example, suppose that we have 4 documents with the fields name, age and id.  id is the shard key: <br><br><pre><code class="javascript hljs">{‚Äúname‚Äù: ‚ÄúMax‚Äù, ‚Äúage‚Äù: <span class="hljs-number"><span class="hljs-number">23</span></span>, ‚Äúid‚Äù: <span class="hljs-number"><span class="hljs-number">23</span></span>} {‚Äúname‚Äù: ‚ÄúJohn‚Äù, ‚Äúage‚Äù: <span class="hljs-number"><span class="hljs-number">28</span></span>, ‚Äúid‚Äù: <span class="hljs-number"><span class="hljs-number">15</span></span>} {‚Äúname‚Äù: ‚ÄúNick‚Äù, ‚Äúage‚Äù: <span class="hljs-number"><span class="hljs-number">19</span></span>, ‚Äúid‚Äù:<span class="hljs-number"><span class="hljs-number">56</span></span>} {‚Äúname‚Äù: ‚ÄúCarl‚Äù, ‚Äúage‚Äù: <span class="hljs-number"><span class="hljs-number">19</span></span>, ‚Äúid‚Äù: <span class="hljs-number"><span class="hljs-number">78</span></span>}</code> </pre> <br>  Assume the size of chunksize, already reached.  In this case, Mongos will divide the range like this (-, 45]; (45, +). We will have 2 chunk: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/ab1/f66/72fab1f6648ed5aaba51265ea162f9b4.jpg"><br><br>  When new documents appear, they will be recorded in a chunk that corresponds to the shardKey range.  Upon achieving chunksize, the separation will occur again and the range will be even narrower and so on.  All chunks are stored on shards. <br>  It is important to note that when a chunk reaches an indivisible range, for example (44, 45), the division will not occur and the chunk will grow above chunksize. Therefore, you should carefully select the shard key so that it is the most random variable possible. we need to fill in the database with all the people on the planet, then the successful shard key choices would be the phone number, the tax identification number, the postal code, the name, the city of residence were unsuccessful. <br>  In the diagram we can see the config server, its difference from mongod is that it does not process client requests, but is a metadata repository - it knows the physical addresses of all the chunk, knows what chunk, what shard to look for and what range a particular another shard.  It stores all this data in a specially designated place - config database. <br>  This scheme also presents a query router, mongos, with the following tasks assigned to it: <br><ol><li>  Caching data stored on the config server </li><li>  Routing of read and write requests from the driver - routing requests from applications to the necessary shards, mongos knows exactly where this or that chunk is physically located </li><li>  Running the background process ‚ÄúBalancer‚Äù </li></ol><br>  The balancer function is to migrate chunks from one shard to another.  The process goes something like this: the balancer sends the moveChunk command to the shard, from which the chunk will migrate, the shard receiving this command starts the process of copying the chunk to another shard.  After all documents are copied, documents are synchronized between these 2 chunks, since  while the migration was taking place, new data could be added to the source chunk.  After the end of synchronization, the shard, which received the new chunk, sends its config address to the server so that it, in turn, updates it in the Mongos cache.  At the end of this process, if there are no open cursors on the original chunk, it is deleted. <br>  This scheme often takes place in a test environment of large applications, and when using 3-config servers, it may be suitable for small production applications.  3 server configs provide data redundancy and if one falls, mongos will still receive the actual addresses of the chunks from other server config. <br><br><h4>  2.3 Shardirovannaya scheme with replica sets </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d6d/c86/829d6dc8666a0904d9f642f5f28f0377.jpg"><br><br>  In this scheme, in addition to sharding, there is replication of shards.  A few words about it.  All writes, deletions, updates, get into the master (primary), and then are recorded in a special collection of oplog, from where they asynchronously get on replicas - repl.1 and repl.2 (secondary).  Thus, data duplication occurs.  Why do you need it? <br><ul><li>  Redundancy ensures data security - when the master crashes, voting takes place between the replicas and one of them becomes the master. </li><li>  Master and replicas can be located in different data centers - this can be useful if the server is physically damaged (fire in the data center) </li><li>  Replicas can be used to more efficiently read data.  For example, there is an application that has a client audience in Europe and in the USA.  One of the replicas can be placed in the United States and set up so that customers from the United States read data from it.  It is worth noting that the documents for the replicas are delayed and it is not always possible to immediately find a newly recorded document on the replica.  Therefore, this item is an advantage only if the reading from the replicas allows the application logic </li></ul><br>  The scheme with a replica sets most often takes place in serious production applications, where data integrity is important or there are a large number of readings and the application logic allows reading from replicas. <br>  We will not dwell on this scheme in more detail, since  she can devote a separate post. <br><br><h2>  3. Sharding </h2><br>  So let's get started.  We will expand all this locally on linux ubuntu 12.0.  For all this we need the installed mongoDB, I have version 2.4.9. <br>  We will shard the scheme number 2, just remove from it elements that have a purely theoretical value: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/285/134/690/28513469036034b1369e8b24f5916d9e.jpg"><br><br>  Let's open <s>the familiar</s> shell to <s>all of us</s> , preferably several tabs at once, since  mongos, mongod, config server are all separate processes.  Further points: <br><br><ol><li>  Create 2 empty directories in which data will be stored: <br><pre> <code class="hljs haskell">&gt; sudo mkdir /<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">/instance1 &gt; sudo mkdir /</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">/instance2</span></span></code> </pre><br>  Raise 2 mongod instances with commands: <br><pre> <code class="hljs kotlin">&gt; sudo mongod --dbpath /<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/instance1 --port <span class="hljs-number"><span class="hljs-number">27000</span></span> <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  And in the following terminal: <br><pre> <code class="hljs kotlin">&gt; sudo mongod --dbpath /<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/instance2 --port <span class="hljs-number"><span class="hljs-number">27001</span></span> <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br>  The <i>--dbpath</i> parameter specifies the path where the .0, .1, .2, and .ns files will be stored.  In the files .0, .1, .2, etc.  the data of this instance is stored in binary form, and in the .ns file the namespace required for navigating the database.  <i>--port</i> - the port on which the database object will be available. <br>  After the first item, we have two instances: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bbb/232/239/bbb232239723bccc1af22c41748f0ccb.jpg"></li><li>  Create an empty directory in which the server config data will be stored: <br><pre> <code class="hljs haskell">&gt; sudo mkdir /<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">/config</span></span></code> </pre><br>  Raise the server configuration command <br><pre> <code class="hljs pgsql">&gt; sudo mongod <span class="hljs-comment"><span class="hljs-comment">--configsvr --dbpath /data/config --port 27002</span></span></code> </pre><br>  The <i>--configsvr</i> parameter indicates that the new instance will be exactly the config server, <i>--dbpath</i> is the path by which data will be stored.  After the second point, the picture looks like this (let me draw your attention to the fact that while these entities know nothing about each other): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b5/a63/a47/1b5a63a47c6cb334fa0622c55a7f1342.jpg"></li><li>  Raise mongos, team <br><pre> <code class="hljs css">&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">sudo</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mongos</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--configdb</span></span> 127<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:27002</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--port</span></span> 27100</code> </pre><br>  By this command, mongos is raised on port <i>27100</i> , he needs to send a list of servers with their hosts to which he will access.  If we did not specify a port when raising Mongos, then it uses the default <i>27017</i> (if it is not busy).  After raising Mongos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/559/871/872/559871872f3d8fc04c42c8301b1c7e26.jpg"></li><li>  Connecting to Mongos, indicating the port on which we raised it, the team <br><pre> <code class="hljs pgsql">&gt; mongo <span class="hljs-comment"><span class="hljs-comment">--port 27100</span></span></code> </pre><br>  After that we get: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/7df/e77/c3b7dfe7737fb8714b311d1b8d2b3be9.jpg"></li><li>  There is a final step - add our shards to the cluster <br><pre> <code class="hljs css">&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">sh</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.addShard</span></span>("127<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:27000")</span></span> &gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">sh</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.addShard</span></span>("127<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:27001")</span></span></code> </pre><br>  These 2 commands need to be executed on Mongos, the connection to which was opened in clause 4. <i>Using the db.printShardingStatus ()</i> command, you can view the status of sharding.  To make sure the shards are added, in the terminal we should see something like: <br><br><pre> <code class="javascript hljs">--- Sharding Status --- sharding version: { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"minCompatibleVersion"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"currentVersion"</span></span> : <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"clusterId"</span></span> : ObjectId(<span class="hljs-string"><span class="hljs-string">"53317aefca1ba9ba232b949e"</span></span>) } shards: { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"shard0000"</span></span>, <span class="hljs-string"><span class="hljs-string">"host"</span></span> : <span class="hljs-string"><span class="hljs-string">"127.0.0.1:27000"</span></span> } { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"shard0001"</span></span>, <span class="hljs-string"><span class="hljs-string">"host"</span></span> : <span class="hljs-string"><span class="hljs-string">"127.0.0.1:27001"</span></span> } databases: { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"admin"</span></span>, <span class="hljs-string"><span class="hljs-string">"partitioned"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"primary"</span></span> : <span class="hljs-string"><span class="hljs-string">"config"</span></span> } { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"partitioned"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"primary"</span></span> : <span class="hljs-string"><span class="hljs-string">"shard0000"</span></span> }</code> </pre><br><br>  We have the final picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/046/442/1f1/0464421f1adac555f1b1f9441f0da0b6.jpg"></li></ol><br><br>  Now let's make sure that everything we set up works, namely, the data is formed into chunks, and the balancer scatters them around the shards.  In order for the data to begin to be shaded, you must enable sharding on the required database, and then on the collection. <br>  All of the following commands must be performed under Mongos.  Let our database be called a <i>bank</i> , we will execute commands that allow it to be shaded: <br><pre> <code class="hljs pgsql">&gt; use <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span> &gt; sh.enableSharding("bank")</code> </pre><br>  <i>Run the db.printShardingStatus ()</i> command <i>again</i> .  The output should be something like this: <br><pre> <code class="javascript hljs">databases: { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"admin"</span></span>, <span class="hljs-string"><span class="hljs-string">"partitioned"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"primary"</span></span> : <span class="hljs-string"><span class="hljs-string">"config"</span></span> } { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-string"><span class="hljs-string">"partitioned"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"primary"</span></span> : <span class="hljs-string"><span class="hljs-string">"shard0000"</span></span> } { <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-string"><span class="hljs-string">"bank"</span></span>, <span class="hljs-string"><span class="hljs-string">"partitioned"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"primary"</span></span> : <span class="hljs-string"><span class="hljs-string">"shard0000"</span></span> }</code> </pre><br><br>  As you can see, in front of <i>partitioned</i> , <i>true</i> appeared, which means we're on the right track. <br><br>  Now let's work with our database: <br><pre> <code class="hljs pgsql">&gt; use bank //   bank (  ,   ) &gt; db.tickets.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>({<span class="hljs-type"><span class="hljs-type">name</span></span>: ‚ÄúMax‚Äù, amount: Math.random()*<span class="hljs-number"><span class="hljs-number">100</span></span>}) //     tickets (  ,      ) &gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">2100000</span></span>; i++) { db.tickets.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>({<span class="hljs-type"><span class="hljs-type">name</span></span>: ‚ÄúMax‚Äù, amount: Math.random()*<span class="hljs-number"><span class="hljs-number">100</span></span>}) } //     javascript &gt; db.tickets.ensureIndex({amount: <span class="hljs-number"><span class="hljs-number">1</span></span>}) // ,       shard Key &gt; db.tickets.stats() //,    .  ,   sharded   <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>,       primaryShard &gt; use <span class="hljs-keyword"><span class="hljs-keyword">admin</span></span> //  ,     tickets.         (<span class="hljs-keyword"><span class="hljs-keyword">primary</span></span>)  &gt; db.runCommand({shardCollection: "bank.tickets", key: {amount: <span class="hljs-number"><span class="hljs-number">1</span></span>}}) //  ,    - shard key  .</code> </pre><br><br>  After the last command, we should see something like this: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"collectionsharded"</span></span> : <span class="hljs-string"><span class="hljs-string">"bank.tickets"</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  After all this, run the <i>sh.status (true)</i> or <i>db.printShardingStatus () command</i> to make sure that everything worked and, if everything is done correctly, we should see the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4a/496/aff/e4a496aff6df69b46b9fbcd95264a3cf.png"><br><br>  As you can see, the data is unevenly distributed, but if you wait a bit and repeat the <i>db.printShardingStatus ()</i> command, the picture changes in the direction of a uniform distribution: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/555/d62/55a/555d6255af665d5b5cfbae819d6355fa.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f2/53b/61b/0f253b61b17e6f043bceb50a626be672.png"><br><br>  And the final picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/db3/4f9/3a9db34f9e380c80d7a952efed34720d.png"><br><br>  As we have seen, at first chunks are saved on the primary shard, and then migrate to the second shard until the number evens out, and their ranges can also change. <br><br>  In the future I would like to tell you about the organization of memory in mongoDB and about replication.  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/217393/">https://habr.com/ru/post/217393/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217381/index.html">We are friends with a regular Volvo speakerphone with Russian letters</a></li>
<li><a href="../217385/index.html">Remote installation of programs on Windows (XP SP3 and newer) without using third-party utilities</a></li>
<li><a href="../217387/index.html">Cocos2D-X and so easy on all devices</a></li>
<li><a href="../217389/index.html">Calculate the day of the week in the mind</a></li>
<li><a href="../217391/index.html">Easy start: Spring + MongoDB</a></li>
<li><a href="../217395/index.html">As a "non-programmer" game wrote</a></li>
<li><a href="../217397/index.html">Work with Oracle DB from Xcode</a></li>
<li><a href="../217399/index.html">How I used BitTorrent Sync between offices in the Russian Federation and China</a></li>
<li><a href="../217401/index.html">Web browser, as an environment for the operation of software for control / process control</a></li>
<li><a href="../217407/index.html">Music for the grandmother from the grandson-programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>