<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Objective-C Runtime for Si-Schnick. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again. My series of articles is dedicated to those programmers who have switched from C to Objective-C, and would like to answer the questions ‚Äú...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Objective-C Runtime for Si-Schnick. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ef8/960/12f/ef896012f6034329b17f60dd5511b118.jpg"><br><br>  Hello again.  My series of articles is dedicated to those programmers who have switched from C to Objective-C, and would like to answer the questions ‚Äúhow exactly is Objective-C based on C?‚Äù And ‚Äúhow does all this happen from the inside?‚Äù. <br><br>  Many thanks to all for the feedback; it is your interest that serves as an incentive for me to continue my articles on the thorough study of the Objective-C Runtime.  I started this part with the subject of my articles, because I want to make a couple of clarifications: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  My articles are not a manual on Objective C. We study the Objective-C Runtime so low level as to understand it at the level of the C language. </li><li>  My articles are not a guide to the C language and debuggers.  We go down to the level of the C language, but not lower.  Therefore, issues such as the presentation of data in memory, I do not affect.  It is assumed that you know all this without me. </li></ol><br><br>  Of course, articles will be of interest to other categories of programmers as well.  But keep in mind these two points. <br><br>  If you have not read the first article, I strongly recommend reading it first: <a href="http://habrahabr.ru/post/250955/">http://habrahabr.ru/post/250955/</a> .  And if you have already read, then welcome under cat. <a name="habracut"></a><br><br><h1>  We "call the methods," and the pedants "send messages." </h1><br><br>  In the previous article, we dealt with ‚Äúcalling methods‚Äù or, as it is also called, ‚Äúsending messages‚Äù: <br><br><pre><code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">myObj someMethod</span></span>];</code> </pre> <br><br>  We came to the conclusion that at run time, such a construction ended up with a call to the objc_msgSend () function and got a good deal out with the selectors. <br><br>  Now let's take a look at the objc_msgSend () function in detail to understand the principles of this notorious message sending to an object. <br><br>  This function is called every time you call a method on an object.  It is logical to assume that the speed of its work <u>greatly</u> affects the speed of the entire application.  Therefore, if you look at the <a href="http://www.opensource.apple.com/source/objc4/objc4-437/runtime/Messengers.subproj/">source code of</a> this function, you will find that it is implemented in assembler for each of the platforms. <br><br>  Before dealing with the source code, I suggest reading the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">documentation</a> : <br><br><blockquote>  ... <br><br>  The message sending function does everything that is needed for dynamic linking: <br><br><ul><li>  First of all, it finds the procedure (method implementation) referenced by the selector.  Since the same method can be implemented by completely different classes, the same procedure that it ( <i>the objc_msgSend function, author's note</i> ) searches for depends on the class of the recipient (to <i>which we send the message, author's note</i> ). </li><li>  Then it calls this procedure, passing in the receiver object (a pointer to it) and all the arguments that were passed in the method call. </li><li>  Finally, it returns the result of the procedure as its own result. </li></ul><br>  ... </blockquote><br><br><div class="spoiler">  <b class="spoiler_title">Lyrical digression</b> <div class="spoiler_text">  Already on the basis of documentation alone, we understand that the phrase ‚Äúcall a method‚Äù is absolutely correct when applied to Objective C. Therefore, if some clever guy corrects you, saying that it‚Äôs correct to say ‚Äúsend a message‚Äù and not ‚Äúcall a method‚Äù, then you can boldly send it to two well-known words - reading the documentation. </div></div><br><br>  Well, with the second and third points everything is so clear.  But with the first you need to understand a little more: how exactly a completely abstract selector is transformed into a very specific function. <br><br><h1>  Communicating with class methods in C </h1><br><br>  Once the familiar function objc_msgSend () first looks for a function that implements the method being called, then we can find this function and call it ourselves. <br><br>  Let's write a small test program that will allow us to get acquainted with the call of methods a little closer: <br><br><pre> <code class="hljs kotlin">#<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;Foundation/Foundation.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;objc/runtime.h&gt; <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> TestClass : NSObject - (void)someMethod; - (void)callSomeMethod; - (void)methodWithParam:(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char *)param; <span class="hljs-meta"><span class="hljs-meta">@end</span></span> <span class="hljs-meta"><span class="hljs-meta">@implementation</span></span> TestClass - (void)someMethod { NSLog(@<span class="hljs-string"><span class="hljs-string">"Hello from %p.%s!"</span></span>, self, _cmd); } - (void)callSomeMethod { NSLog(@<span class="hljs-string"><span class="hljs-string">"Hello from %p.%s!"</span></span>, self, _cmd); [self someMethod]; } - (void)methodWithParam:(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char *)param { NSLog(@<span class="hljs-string"><span class="hljs-string">"Hello from %p.%s! My parameter is: &lt;%s&gt;"</span></span>, self, _cmd, param); } <span class="hljs-meta"><span class="hljs-meta">@end</span></span> int main(int argc, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char * argv[]) { TestClass * myObj = [[TestClass alloc] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>]; [myObj someMethod]; [myObj callSomeMethod]; [myObj methodWithParam:<span class="hljs-string"><span class="hljs-string">"I'm a parameter"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br>  From the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">documentation</a> we become aware that when calling the desired function, objc_msgSend () passes the parameters to it in the following order: <br><br><ol><li>  Pointer to the object whose method we called </li><li>  The selector by which we called the method </li><li>  The remaining arguments that we passed to the method </li></ol><br><br>  That is why our test program looks like this: in each of the methods we output self and _cmd to the log, which contain the pointer ‚Äúto itself‚Äù and the selector, respectively. <br><br>  If you run this program, the output will be something like: <br><br><blockquote>  2015-02-21 12: 43: 18.817 ObjCRuntimeTest [7092: 2454834] Hello from 0x1002061f0.someMethod! <br>  2015-02-21 12: 43: 18.818 ObjCRuntimeTest [7092: 2454834] Hello from 0x1002061f0.callSomeMethod! <br>  2015-02-21 12: 43: 18.819 ObjCRuntimeTest [7092: 2454834] Hello from 0x1002061f0.someMethod! <br>  2015-02-21 12: 43: 18.819 ObjCRuntimeTest [7092: 2454834] Hello from 0x1002061f0.methodWithParam :!  My parameter is: &lt;I'm a parameter&gt; </blockquote><br><br>  Now we will try to call these methods using the C language. To do this, we take from the object a pointer to a function that implements the method of our class.  Considering that we work at the C level, we follow to determine the types that will allow us to work with pointers to our functions.  Given all this, we have the following code in the function main (): <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * argv[]) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*MethodWithoutParams)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, SEL); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*MethodWithParam)(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, SEL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *); TestClass * myObj = [[TestClass alloc] init]; MethodWithoutParams someMethodImplementation = [myObj methodForSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(someMethod)]; MethodWithoutParams callSomeMethodImplementation = [myObj methodForSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(callSomeMethod)]; MethodWithParam methodWithParamImplementation = [myObj methodForSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(methodWithParam:)]; someMethodImplementation(myObj, <span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(someMethod)); callSomeMethodImplementation(myObj, <span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(callSomeMethod)); methodWithParamImplementation(myObj, <span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(methodWithParam:), <span class="hljs-string"><span class="hljs-string">"I'm a parameter"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br>  Well, we have already called the methods exclusively using the means of the C language. The exception in this case was only the selectors, with whom we have already figured out enough in the previous article.  And the methodForSelector: method remains the black box for us. <br><br><h1>  Message Engine in Objective C Runtime </h1><br><br>  The key point in implementing the message engine in Objective C Runtime is how the compiler represents your classes and objects. <br><br>  If expressed in terms of the C ++ language, objects in RAM are created not only for each of the instances of your classes, but also for each class.  That is, by describing a class that inherits the base class NSObject, and creating two instances of this class, during execution you will receive two objects created by you and one <u>object of your class</u> . <br><br>  This very class object contains a pointer to an object of the parent class and a table of matching selectors and function addresses, called the dispatch table.  It is with the help of this table that the objc_msgSend () function searches for the necessary function that needs to be called for the selector passed to it. <br><br>  Each class that inherits from NSObject or NSProxy has an isa field, which is exactly the same as a pointer to a class object.  When you call a method on an object, the objc_msgSend () function passes on the isa pointer to the class object, and searches in it for the address of the function that implements this method.  If it does not find such a function, then it goes to an object of the class of the parent object and searches for that function there.  This happens until the desired function is found.  If the function was not found anywhere, including in an object of the NSObject class, then we all receive a known exception: <br><br><blockquote>  unrecognized selector sent to instance ... </blockquote><br><br><div class="spoiler">  <b class="spoiler_title">And in fact...</b> <div class="spoiler_text">  At present, the rather slow process of searching for functions has been slightly improved.  If you call a method of an object, then it, once found, will be placed in a certain cache table.  Thus, if you call the methodForSelector: method on any object, the first time the search will be performed for the desired function, and when the function is found in an object of the NSObject class, it will be cached in the table of your class, and next time the search for this function will not take much time. <br><br>  In addition, an exception will not occur immediately if the implementation of the method is not found.  There is also a mechanism such as <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html">Message Forwarding</a> . <br></div></div><br><br>  Let's confirm this with real research based on the Objective-C Runtime source code and the NSObject class. <br><br>  As we already understood, NSObject has a methodForSelector: method whose source code looks like this: <br><br><pre> <code class="hljs ruby">+ (IMP)<span class="hljs-symbol"><span class="hljs-symbol">methodForSelector:</span></span>(SEL)sel { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sel) [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-symbol"><span class="hljs-symbol">doesNotRecognizeSelector:</span></span>sel]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object_getMethodImplementation((id)<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, sel); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> -     } - (IMP)<span class="hljs-symbol"><span class="hljs-symbol">methodForSelector:</span></span>(SEL)sel { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sel) [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-symbol"><span class="hljs-symbol">doesNotRecognizeSelector:</span></span>sel]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object_getMethodImplementation(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, sel); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> -     }</code> </pre> <br><br>  As we see, this method is implemented both for the class itself and for class objects.  In both cases, the same object_getMethodImplementation () function is used: <br><br><pre> <code class="hljs pgsql">IMP object_getMethodImplementation(id obj, SEL <span class="hljs-type"><span class="hljs-type">name</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> cls = (obj ? obj-&gt;getIsa() : nil); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> class_getMethodImplementation(cls, <span class="hljs-type"><span class="hljs-type">name</span></span>); }</code> </pre> <br><br>  Stop!  What is this construction "(obj? Obj-&gt; getIsa (): nil)"!?  Indeed, in all articles we are told ... <br><br><img src="https://habrastorage.org/files/8f8/87a/d80/8f887ad80aa245768369bcbc94fec21b.jpg"><br><br>  And it all starts with the <a href="http://www.opensource.apple.com/source/objc4/objc4-646/objc.xcodeproj/project.pbxproj">build settings</a> for the Objective C Runtime project file: <br><br><blockquote>  CLANG_CXX_LANGUAGE_STANDARD = "gnu ++ 0x"; <br>  CLANG_CXX_LIBRARY = "libc ++"; </blockquote><br><br>  And here is the <a href="">implementation of</a> the getIsa () method itself: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Class objc_object::getIsa() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isTaggedPointer()) { uintptr_t slot = ((uintptr_t)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objc_tag_classes[slot]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ISA(); }</code> </pre> <br><br>  In general, it just so happens that any object in Objective-C must contain the isa field.  And the class object is no exception. <br><br>  All this pornography is pretty messy.  The methodForSelector: method has an absolutely identical implementation, both as an object method and for a class method.  The only difference is that in the first case, self points to our object, and in the second, to a class object. <br><br>  Damn it, what the fuck !?  How can we call obj-&gt; getIsa () on a class object?  What is going on there at all? <br><br>  But the fact is that the class object really has the same field, which indicates the ‚Äúclass object for this class‚Äù.  If expressed correctly, it indicates the <i>metaclass</i> .  If you call an object method (the method that starts with the "-" sign), its implementation is searched for in its class.  If you call a class method (starts with a ‚Äú+‚Äù sign), its implementation is searched for in its metaclass. <br><br>  I lied to you a little at the beginning of the article, saying that during execution, when you create two objects of your class, you get three objects: two instances of your class and an object of class.  In fact, a class object is always created in conjunction with a metaclass object.  That is, in the end, you get 4 objects. <br><br>  To visually imagine the whole essence of this lawlessness, I will insert here a picture from <a href="http://habrahabr.ru/post/207786/">this</a> article: <br><br><img src="https://habrastorage.org/files/c41/e6c/d27/c41e6cd277514a90b4bf98a21490ac08.jpg"><br><br>  Let's return to our case, where the function class_getMethodImplementation () is finally called via self: <br><br><pre> <code class="hljs pgsql">IMP class_getMethodImplementation(<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> cls, SEL sel) { IMP imp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cls || !sel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nil; imp = lookUpImpOrNil(cls, sel, nil, YES<span class="hljs-comment"><span class="hljs-comment">/*initialize*/</span></span>, YES<span class="hljs-comment"><span class="hljs-comment">/*cache*/</span></span>, YES<span class="hljs-comment"><span class="hljs-comment">/*resolver*/</span></span>); // Translate forwarding <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> C-callable <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!imp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _objc_msgForward; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> imp; }</code> </pre> <br><br>  Inquisitive ones can see that the lookUpImpOrNil () function uses the lookUpImpOrForward () function, the implementation of which lies again on <a href="">the Apple website</a> .  The function is written in C, which will make sure that everything works exactly as written in the documentation. <br><br><h1>  Summarizing </h1><br><br>  And finally, like last time, let's call the method exclusively using the C language: <br><br><pre> <code class="hljs kotlin">#<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;Foundation/Foundation.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;objc/runtime.h&gt; <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> TestClass : NSObject <span class="hljs-meta"><span class="hljs-meta">@end</span></span> <span class="hljs-meta"><span class="hljs-meta">@implementation</span></span> TestClass + (void)someClassMethod { NSLog(@<span class="hljs-string"><span class="hljs-string">"Hello from some class method!"</span></span>); } - (void)someInstanceMethod { NSLog(@<span class="hljs-string"><span class="hljs-string">"Hello from some instance method!"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@end</span></span> int main(int argc, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char * argv[]) { typedef void (*MyMethodType)(id, SEL); TestClass * myObj = [[TestClass alloc] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>]; Class myObjClassObject = object_getClass(myObj); Class myObjMetaclassObject = object_getClass(myObjClassObject); MyMethodType instanceMethod = class_getMethodImplementation(myObjClassObject, <span class="hljs-meta"><span class="hljs-meta">@selector(someInstanceMethod)</span></span>); MyMethodType classMethod = class_getMethodImplementation(myObjMetaclassObject, <span class="hljs-meta"><span class="hljs-meta">@selector(someClassMethod)</span></span>); instanceMethod(myObj, <span class="hljs-meta"><span class="hljs-meta">@selector(someInstanceMethod)</span></span>); classMethod(myObjClassObject, <span class="hljs-meta"><span class="hljs-meta">@selector(someClassMethod)</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br>  In fact, we are still far from understanding the mechanism of messages in Objective C. For example, we did not understand the return of the result from the called methods.  But read about it in the following parts :). </div><p>Source: <a href="https://habr.com/ru/post/250977/">https://habr.com/ru/post/250977/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250963/index.html">55 million users moving on</a></li>
<li><a href="../250969/index.html">Collect and analyze logs from Fluentd</a></li>
<li><a href="../250971/index.html">JDBC Curriculum</a></li>
<li><a href="../250973/index.html">Speech at the conference: what is important to know</a></li>
<li><a href="../250975/index.html">Selenium for Python. Chapter 4. Search for items</a></li>
<li><a href="../250979/index.html">CxxMock - Mock Objects in C ++</a></li>
<li><a href="../250981/index.html">HTML5 MathMl</a></li>
<li><a href="../250985/index.html">Custom PHP Project Optimization</a></li>
<li><a href="../250989/index.html">Receive radio footage and other digital transmissions using a conventional receiver and computer</a></li>
<li><a href="../250991/index.html">The Equation, Carbanak, Desert Falcons: Report with Security Analyst Summit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>