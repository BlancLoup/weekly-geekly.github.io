<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CRC16 checksum reliability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago on duty faced a rather interesting problem. 

 We have a device that performs intensive exchange on the internal RS485 bus, the number...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CRC16 checksum reliability</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago on duty faced a rather interesting problem. <br><br>  We have a device that performs intensive exchange on the internal RS485 bus, the number of passing packets is of the order of several thousand per second, each packet has a length of 7 bytes, two of which are designed to store the CRC16 checksum in its CMS version (polynomial = 0x8005, starting value = 0xFFFF).  Reception is carried out in the FIFO buffer, which is shifted upward with displacement after receiving each subsequent byte.  An indicator of the receipt of a real packet is the fact that its checksum coincides with the value transmitted in the packet itself.  No headers or additional parameters. <br><br>  The problem was the following - periodically, approximately once every 5 minutes, during data transmission, a packet was skipped, the data of which gave a burst of data for one of the channels, and most often the burst occurred to the same value.  At first we looked in the direction of physical collisions, but the case turned out to be different - from time to time in the buffer where the data was collected, it turned out to be a packet consisting of the end of the previous packet and the beginning of the next one, and the checksum of such a combined packet turned out to be correct.  That is, there is a checksum collision: the packet does not make sense, but gives the correct checksum. <br><a name="habracut"></a><br>  Naturally, the error was already at the system design level, since the packets did not have any headers, the introduction of an additional byte header reduced the number of errors to an undetectable level, but this seemed to me a little.  I decided to check how different types of 16-bit checksums differ from each other in real conditions.  Actually, this article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For comparison, I chose several of the most commonly used 16-bit checksums with different polynomials, starting values, and a bit arrival mechanism.  The amounts I selected are summarized in the following table: <br><table><tbody><tr><td>  <b>Designation</b> </td><td>  <b>Polynomial</b> </td><td>  <b>Init</b> </td><td>  <b>Refin</b> </td><td>  <b>Refout</b> </td><td>  <b>Xorout</b> </td></tr><tr><td>  CMS </td><td>  0x8005 </td><td>  0xFFFF </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  CCITT </td><td>  0x1021 </td><td>  0xFFFF </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  AUG-CCITT </td><td>  0x1021 </td><td>  0x1D0F </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  BYPASS </td><td>  0x8005 </td><td>  0x0000 </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  CDMA2000 </td><td>  0xC867 </td><td>  0xFFFF </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  DDS-110 </td><td>  0x8005 </td><td>  0x800D </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  DECT-X </td><td>  0x0589 </td><td>  0x0000 </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  EN-13757 </td><td>  0x3D65 </td><td>  0x0000 </td><td>  false </td><td>  false </td><td>  0xFFFF </td></tr><tr><td>  Modbus </td><td>  0x8005 </td><td>  0xFFFF </td><td>  true </td><td>  true </td><td>  0x0000 </td></tr><tr><td>  T10-DIF </td><td>  0x8BB7 </td><td>  0x0000 </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  TELEDISK </td><td>  0xA097 </td><td>  0x0000 </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr><tr><td>  XMODEM </td><td>  0x1021 </td><td>  0x0000 </td><td>  false </td><td>  false </td><td>  0x0000 </td></tr></tbody></table><br>  In this case: <br><br><ul><li>  RefIn - the order of receipt of bits from the data buffer: false - starting with the most significant bit (MSB first), true - LSB first; </li><li>  RefOut - flag to invert the order of bits on the output: true - to invert. </li></ul><br>  When emulating packet damage, I implemented the following models: <br><br><ul><li>  <b>Shuffle:</b> Filling a random number of bytes in a packet with random values. </li><li>  <b>Bit shift:</b> shift random bytes in the packet to the left </li><li>  <b>Roll packet:</b> ring byte offset in packet to the left </li><li>  <b>Right shift:</b> shift of the packet to the right by one byte, 0xFF is added to the left (transmission goes via UART) </li><li>  <b>Left shift:</b> shift packet left by one byte, 0xFF appended to the right </li><li>  <b>Fill zeros:</b> filling a random number of bytes in a packet with 0x00 bytes (all zeros) </li><li>  <b>Fill ones:</b> fill a random number of bytes in a packet with 0xFF bytes (all units) </li><li>  <b>Byte injection:</b> insertion of a random byte into a packet in a random place, bytes behind the inserted one are shifted in the direction of the tail </li><li>  <b>Single bit:</b> damage to a single random bit. </li></ul><br>  Then, the program generated 100,000,000 packets randomly, each of them carried out the above operations, after which the checksums of the original and the upgraded packet were compared.  Packages that did not change during conversion were discarded.  If the checksum matches, an error has been logged. <br><br>  As a result, the following table was obtained with the number of errors: <br><table><tbody><tr><td>  <b>Designation</b> </td><td>  <b>Shuffle</b> </td><td>  <b>Bit shift</b> </td><td>  <b>Roll packet</b> </td><td>  <b>Right shift</b> </td><td>  <b>Left shift</b> </td><td>  <b>Fill zeros</b> </td><td>  <b>Fill ones</b> </td><td>  <b>Byte injection</b> </td><td>  <b>Sum</b> </td></tr><tr><td>  CMS </td><td>  5101 </td><td>  3874 </td><td>  2937 </td><td>  1439 </td><td>  1688 </td><td>  3970 </td><td>  4010 </td><td>  1080 </td><td>  24099 </td></tr><tr><td>  CCITT </td><td>  2012 </td><td>  1127 </td><td>  3320 </td><td>  1494 </td><td>  1486 </td><td>  1063 </td><td>  1096 </td><td>  1130 </td><td>  12728 </td></tr><tr><td>  AUG-CCITT </td><td>  2012 </td><td>  1127 </td><td>  3320 </td><td>  1494 </td><td>  1486 </td><td>  1063 </td><td>  1096 </td><td>  1130 </td><td>  12728 </td></tr><tr><td>  BYPASS </td><td>  5101 </td><td>  3874 </td><td>  2937 </td><td>  1439 </td><td>  1688 </td><td>  3970 </td><td>  4010 </td><td>  1080 </td><td>  24099 </td></tr><tr><td>  CDMA2000 </td><td>  1368 </td><td>  1025 </td><td>  1946 </td><td>  1462 </td><td>  1678 </td><td>  1043 </td><td>  1028 </td><td>  1112 </td><td>  10662 </td></tr><tr><td>  DDS-110 </td><td>  5101 </td><td>  3874 </td><td>  2937 </td><td>  1439 </td><td>  1688 </td><td>  3970 </td><td>  4010 </td><td>  1080 </td><td>  24099 </td></tr><tr><td>  DECT-X </td><td>  1432 </td><td>  1189 </td><td>  5915 </td><td>  1779 </td><td>  1580 </td><td>  1215 </td><td>  1209 </td><td>  1093 </td><td>  15412 </td></tr><tr><td>  EN-13757 </td><td>  1281 </td><td>  2209 </td><td>  3043 </td><td>  1520 </td><td>  1528 </td><td>  2193 </td><td>  2187 </td><td>  1039 </td><td>  15,000 </td></tr><tr><td>  Modbus </td><td>  5090 </td><td>  3888 </td><td>  3086 </td><td>  1282 </td><td>  1582 </td><td>  3947 </td><td>  3897 </td><td>  1073 </td><td>  23845 </td></tr><tr><td>  T10-DIF </td><td>  1390 </td><td>  922 </td><td>  1424 </td><td>  1421 </td><td>  1630 </td><td>  994 </td><td>  938 </td><td>  1093 </td><td>  9812 </td></tr><tr><td>  TELEDISK </td><td>  1394 </td><td>  1049 </td><td>  5398 </td><td>  1451 </td><td>  1512 </td><td>  1096 </td><td>  1066 </td><td>  1065 </td><td>  14031 </td></tr><tr><td>  XMODEM </td><td>  2012 </td><td>  1127 </td><td>  3320 </td><td>  1494 </td><td>  1486 </td><td>  1063 </td><td>  1096 </td><td>  1130 </td><td>  12728 </td></tr></tbody></table><br>  Obviously, the starting value of the algorithm does not affect the result, which is logical, the starting value gives us only a different value of the checksum, but the calculation mechanism itself does not change.  Therefore, I excluded these checksums from further consideration.  Similarly, it does not make sense to consider errors in single bits, all checksums coped with this without error, which, in fact, was required from them during creation. <br><br>  Well, the final table of the quality of the checksum, without taking into account duplicate algorithms: <br><table><tbody><tr><td>  <b>Designation</b> </td><td>  <b>Number of collisions</b> </td><td>  <b>Place</b> </td></tr><tr><td>  CMS </td><td>  24099 </td><td>  eight </td></tr><tr><td>  CCITT </td><td>  12728 </td><td>  3 </td></tr><tr><td>  CDMA2000 </td><td>  10662 </td><td>  2 </td></tr><tr><td>  DECT-X </td><td>  15412 </td><td>  6 </td></tr><tr><td>  EN-13757 </td><td>  15,000 </td><td>  five </td></tr><tr><td>  Modbus </td><td>  23845 </td><td>  7 </td></tr><tr><td>  T10-DIF </td><td>  9812 </td><td>  one </td></tr><tr><td>  TELEDISK </td><td>  14031 </td><td>  four </td></tr></tbody></table><br>  The remaining conclusions leave readers.  From myself I will only note that the number of units in the checksum polynom has a certain influence on the results.  But this is just my personal subjective opinion.  I will be glad to hear other explanations. <br><br>  The source code of the program is given below. <br><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;stdbool.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #define PACKET_LEN (7) #define NUM_OF_CYCLES (100000) static unsigned char reverse_table[16] = { 0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF }; uint8_t reverse_bits(uint8_t byte) { // Reverse the top and bottom nibble then swap them. return (reverse_table[byte &amp; 0b1111] &lt;&lt; 4) | reverse_table[byte &gt;&gt; 4]; } uint16_t reverse_word(uint16_t word) { return ((reverse_bits(word &amp; 0xFF) &lt;&lt; 8) | reverse_bits(word &gt;&gt; 8)); } uint16_t crc16_common(uint8_t *data, uint8_t len, uint16_t poly, uint16_t init, uint16_t doXor, bool refIn, bool refOut) { uint8_t y; uint16_t crc; crc = init; while (len--) { if (refIn) crc = ((uint16_t)reverse_bits(*data++) &lt;&lt; 8) ^ crc; else crc = ((uint16_t)*data++ &lt;&lt; 8) ^ crc; for (y = 0; y &lt; 8; y++) { if (crc &amp; 0x8000) crc = (crc &lt;&lt; 1) ^ poly; else crc = crc &lt;&lt; 1; } } if (refOut) crc = reverse_word(crc); return (crc ^ doXor); } uint16_t crc16_ccitt(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x1021, 0xFFFF, 0x0000, false, false); } uint16_t crc16_bypass(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x8005, 0x0000, 0x0000, false, false); } uint16_t crc16_xmodem(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x1021, 0x0000, 0x0000, false, false); } uint16_t crc16_teledisk(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0xA097, 0x0000, 0x0000, false, false); } uint16_t crc16_augccitt(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x1021, 0x1d0f, 0x0000, false, false); } uint16_t crc16_cdma2000(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0xc867, 0xffff, 0x0000, false, false); } uint16_t crc16_dds110(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x8005, 0x800d, 0x0000, false, false); } uint16_t crc16_dect(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x0589, 0x0000, 0x0000, false, false); } uint16_t crc16_en13757(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x3d65, 0x0000, 0xffff, false, false); } uint16_t crc16_t10dif(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x8bb7, 0x0000, 0x0000, false, false); } uint16_t crc16_cms(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x8005, 0xFFFF, 0x0000, false, false); } uint16_t crc16_modbus(uint8_t *data, uint8_t len) { return crc16_common(data, len, 0x8005, 0xFFFF, 0x0000, true, true); } bool compare_buf(uint8_t *buf1, uint8_t *buf2) { uint8_t x; for (x = 0; x &lt; PACKET_LEN; x++) { if (buf1[x] != buf2[x]) return true; } return false; } bool method_shuffle(uint8_t *buf) { uint8_t i, j; uint16_t rnd; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); for (i = 0; i &lt; PACKET_LEN; i++) { for (j = 0; j &lt; 10; j++) { rnd = (uint16_t)rand(); if (rnd % 7 == 0) buf[i] ^= (1 &lt;&lt; (rnd % 8)); } } return compare_buf(buf, copy); } bool method_bitshift(uint8_t *buf) { uint8_t x, i, j; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); x = (uint8_t)(rand() % PACKET_LEN) + 1; for (j = 0; j &lt; x; j++) { i = (uint8_t)(rand() % PACKET_LEN); if (buf[i] == 0) buf[i] = 0x01; else buf[i] &lt;&lt;= 1; } return compare_buf(buf, copy); } bool method_packetroll(uint8_t *buf) { uint8_t x, i, j; uint8_t temp; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); x = (uint8_t)(rand() % (PACKET_LEN - 1)) + 1; for (j = 0; j &lt; x; j++) { temp = buf[0]; for (i = 0; i &lt; PACKET_LEN - 1; i++) buf[i] = buf[i + 1]; buf[PACKET_LEN - 1] = temp; } return compare_buf(buf, copy); } bool method_shiftright(uint8_t *buf) { uint8_t i; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); for (i = 0; i &lt; PACKET_LEN - 1; i++) buf[i + 1] = buf[i]; buf[0] = 0xff; return compare_buf(buf, copy); } bool method_shiftleft(uint8_t *buf) { uint8_t i; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); for (i = 0; i &lt; PACKET_LEN - 1; i++) buf[i] = buf[i + 1]; buf[PACKET_LEN - 1] = 0xff; return compare_buf(buf, copy); } bool method_zero(uint8_t *buf) { uint8_t x, i, j; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); x = (uint8_t)(rand() % PACKET_LEN) + 1; for (j = 0; j &lt; x; j++) { i = (uint8_t)(rand() % PACKET_LEN); if (buf[i] != 0x00) buf[i] = 0x00; else buf[i] = 0xFF; } return compare_buf(buf, copy); } bool method_one(uint8_t *buf) { uint8_t x, i, j; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); x = (uint8_t)(rand() % PACKET_LEN) + 1; for (j = 0; j &lt; x; j++) { i = (uint8_t)(rand() % PACKET_LEN); if (buf[i] != 0xFF) buf[i] = 0xFF; else buf[i] = 0x00; } return compare_buf(buf, copy); } bool method_injection(uint8_t *buf) { uint8_t x, i; uint8_t copy[PACKET_LEN]; memcpy(copy, buf, PACKET_LEN); x = (uint8_t)(rand() % PACKET_LEN); for (i = PACKET_LEN - 1; i &gt; x; i--) { buf[i] = buf[i - 1]; } buf[x] = (uint8_t)rand(); return compare_buf(buf, copy); } bool method_single(uint8_t *buf) { uint8_t x; x = (uint8_t)(rand() % (PACKET_LEN * 8)); buf[(uint8_t)(x / 8)] ^= (1 &lt;&lt; (x % 8)); return true; } typedef struct { uint16_t crc1; uint16_t crc2; uint32_t errors; uint16_t (*fn)(uint8_t *data, uint8_t len); char name[32]; } tCRC; typedef struct { bool (*fn)(uint8_t *buf); char name[32]; } tMethod; static tMethod methods[] = { {method_shuffle, "Shuffle"}, {method_bitshift, "Bit shift"}, {method_packetroll, "Roll packet"}, {method_shiftright, "Right shift"}, {method_shiftleft, "Left shift"}, {method_zero, "Fill zeros"}, {method_one, "Fill ones"}, {method_injection, "Byte injection"}, {method_single, "Single bit"} }; static tCRC crcs[] = { {0, 0, 0, crc16_cms, "CMS"}, {0, 0, 0, crc16_ccitt, "CCITT"}, {0, 0, 0, crc16_augccitt, "AUG-CCITT"}, {0, 0, 0, crc16_bypass, "BYPASS"}, {0, 0, 0, crc16_cdma2000, "CDMA2000"}, {0, 0, 0, crc16_dds110, "DDS-110"}, {0, 0, 0, crc16_dect, "DECT-X"}, {0, 0, 0, crc16_en13757, "EN-13757"}, {0, 0, 0, crc16_modbus, "Modbus"}, {0, 0, 0, crc16_t10dif, "T10-DIF"}, {0, 0, 0, crc16_teledisk, "TELEDISK"}, {0, 0, 0, crc16_xmodem, "XMODEM"} }; int main(int argc, char * argv[]) { uint32_t num_of_cycle; uint32_t num_of_sums; uint8_t packet[PACKET_LEN]; uint8_t i; uint8_t m; //uint8_t buf[8] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}; srand(time(NULL)); printf("------------------------- CRC16 comparison -------------------------\n"); num_of_sums = sizeof(crcs) / sizeof(tCRC); for (m = 0; m &lt; sizeof(methods) / sizeof(tMethod); m++) { printf("\r%s:\n", methods[m].name); for (i = 0; i &lt; num_of_sums; i++) { crcs[i].errors = 0; } for (num_of_cycle = 0; num_of_cycle &lt; NUM_OF_CYCLES; num_of_cycle++) { for (i = 0; i &lt; PACKET_LEN; i++) packet[i] = (uint8_t)rand(); for (i = 0; i &lt; num_of_sums; i++) crcs[i].crc1 = crcs[i].fn(packet, PACKET_LEN); if (!methods[m].fn(packet)) continue; for (i = 0; i &lt; num_of_sums; i++) { crcs[i].crc2 = crcs[i].fn(packet, PACKET_LEN); if (crcs[i].crc1 == crcs[i].crc2) crcs[i].errors++; } if (num_of_cycle % 1000 == 0) printf("\r%.2f%%", (float)num_of_cycle / NUM_OF_CYCLES * 100); } for (i = 0; i &lt; num_of_sums; i++) printf("\r %20s: %10d\n", crcs[i].name, crcs[i].errors); } return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  As a result, in the next version of the product for the internal bus, the CCITT checksum was chosen, mostly because its implementation was available in the hardware of the microcontroller used. </div><p>Source: <a href="https://habr.com/ru/post/428746/">https://habr.com/ru/post/428746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428734/index.html">Error that persisted in Windows since 1974</a></li>
<li><a href="../428736/index.html">Using Retrofit 2.x as a REST client - Tutorial</a></li>
<li><a href="../428738/index.html">Data Science in Visual Studio Code using Neuron</a></li>
<li><a href="../428740/index.html">Quantum networks: prospects and difficulties of implementation</a></li>
<li><a href="../428744/index.html">jDrum rhythm studio emulator</a></li>
<li><a href="../428748/index.html">The digest of interesting materials for the mobile developer # 273 (October 29 - November 4)</a></li>
<li><a href="../428750/index.html">How to turn a federal project into a business card site? Almost detailed instruction</a></li>
<li><a href="../428754/index.html">Smell of thought 2040</a></li>
<li><a href="../428756/index.html">Finishing Up Persons Using Machine Learning</a></li>
<li><a href="../428758/index.html">Missing computer skills at high school students</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>