<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LL (*) parser using Rust macro</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wow. Such Rust. Much macro. ¬© picture - Twitter account Servo 


 Rust language is rapidly gaining momentum. Someone prophesies him to become a replac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LL (*) parser using Rust macro</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/62/5x/az/625xaz3hyq5q3dtannuipu8rnjw.png" alt="Wow. Such Rust. Much macro."><br><p>  <i>Wow.</i>  <i>Such Rust.</i>  <i>Much macro.</i>  <i>¬© picture - <a href="https://twitter.com/servodev">Twitter account Servo</a></i> </p><br><p>  Rust language is rapidly gaining momentum.  Someone prophesies him to become a replacement for C / C ++, someone just likes him.  I rather belong to the second group.  Developers are trying to make it convenient and safe.  It has constructions and principles that will not soon appear in the "pros", due to the inertia of the committee and many other reasons.  Therefore, for all personal projects, I prefer to use Rust. </p><br><p>  It so happened that with varying success I write compilers.  I didn‚Äôt really have time to write one, but the process itself is more interesting to me than the result. </p><br><p>  Once, when I was once again stuck with a parser (aka ‚Äúparser‚Äù), I thought that I was writing a lot of the same type of code.  And this one-type code of one to one falls on the grammar in the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0_%25D0%2591%25D1%258D%25D0%25BA%25D1%2583%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259D%25D0%25B0%25D1%2583%25D1%2580%25D0%25B0">form of Backus-Naur</a> (BNF). </p><br><p>  A little thought, I decided that I need to write a code generator based on grammar.  And for this task the macros in Rust are perfectly suitable. </p><br><p>  The article describes the implementation of the <a href="https://ru.wikipedia.org/wiki/LL-%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580">LL (*)</a> parser using macros.  And the parser of simple mathematical expressions is implemented. </p><br><p>  As a result, the parser for BNF grammar: </p><br><pre><code class="rust hljs">expr ::= sum sum ::= mul <span class="hljs-string"><span class="hljs-string">"+"</span></span> sum | mul <span class="hljs-string"><span class="hljs-string">"-"</span></span> sum | mul mul ::= atom <span class="hljs-string"><span class="hljs-string">"*"</span></span> mul | atom <span class="hljs-string"><span class="hljs-string">"/"</span></span> mul | atom atom ::= <span class="hljs-string"><span class="hljs-string">"("</span></span> expr <span class="hljs-string"><span class="hljs-string">")"</span></span> | number | neg; neg ::= <span class="hljs-string"><span class="hljs-string">"-"</span></span> atom</code> </pre> <br><p>  Can be generated using a series of macros: </p><br><pre> <code class="rust hljs">rule!(expr, sum); rule!(sum, or![ and![(mul, token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), sum) =&gt; make_operator], and![(mul, token(<span class="hljs-string"><span class="hljs-string">'-'</span></span>), sum) =&gt; make_operator], mul ]); rule!(mul, or![ and![(atom, token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), mul) =&gt; make_operator], and![(atom, token(<span class="hljs-string"><span class="hljs-string">'/'</span></span>), mul) =&gt; make_operator], atom ]); rule!(atom, or![ and![(token(<span class="hljs-string"><span class="hljs-string">'('</span></span>), expr, token(<span class="hljs-string"><span class="hljs-string">')'</span></span>)) =&gt; |_lbrace, stat, _rbrace| <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(stat)], num, neg ]); rule!(neg, and![(token(<span class="hljs-string"><span class="hljs-string">'-'</span></span>), atom) =&gt; |_, number| <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(expression::Expression::Negate(number)))]);</code> </pre> <a name="habracut"></a><br><p>  In the article, I will intentionally simplify the implementation of some parts of the code and use the unstable features of the Rust night assembly.  This, I hope, will simplify understanding and improve readability. </p><br><p>  So, as already mentioned, we will generate an LL (*) parser that can analyze a family of grammar of the same name.  If you are too lazy to read what is special about this subset of parsers, then in short, they are easier to write with your hands, but they cannot parse the left-recursive grammars (and we don‚Äôt need to). </p><br><p>  In order to test our parser, we use the above grammar.  She can parse arithmetic expressions, she is LL (*) grammar and we have enough for tests. </p><br><p>  Let's start with the lexical analyzer (aka "lexer"). </p><br><h2>  Lexical analyzer </h2><br><p>  For simplicity, our lexer will give us 1 character per line, skipping spaces.  We will not use a separate type of token, but we will work with a character type.  For the same reason, our numbers can only be one-digit. </p><br><p>  For LL (*) grammar, we need a lexical analyzer that can roll back to an arbitrary number of characters.  At the input of the lexer, we will take a string, and give the characters one by one.  In addition, we will have the function of taking a position and rolling back a lexer to a position. </p><br><p>  A lexer could work with a string lazily, but for simplicity, we simply convert the entire string to a vector of characters: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lexer</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// Input string input: Vec&lt;char&gt;, /// Lexer position position: usize } type Position = usize; impl Lexer { pub fn new(input: &amp;str) -&gt; Self { // Compiler bug. Can't drain string inplace let mut string = String::from(input); let vec = string.drain(..).collect(); Lexer { input: vec, position: 0 } } pub fn position(&amp;self) -&gt; Position { self.position } pub fn next(&amp;mut self) -&gt; Option&lt;char&gt; { while let Some(result) = self.input.get(self.position).cloned() { self.position += 1; if result != ' ' { return Some(result) } } None } pub fn rollback(&amp;mut self, position: Position) { self.position = position } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Regarding a comment with a bug</b> <div class="spoiler_text"><p>  At the time of writing the lexer, I wanted to convert the string into a vector in place and the compiler gave an error, say the line goes out of scope.  But the fact is that <code>collect</code> absorbs an iterator, so there should be no problems. </p><br><p>  I went to the <code>#rust-beginners</code> IRC channel and one of the language developers told me that this is a bug.  So if you have any difficulties, go to the channel and ask boldly.  Very friendly people are sitting on the Rust IRC channels and they will always try to help you. </p></div></div><br><p>  The scenario of working with lexer is as follows: </p><br><ol><li>  Remember the position of the lexer; </li><li>  We read the characters and check them in accordance with the rule; </li><li>  If the character is not accepted by the rule, we roll back to the initial state and return an error. </li></ol><br><p>  Time to implement the type of expressions of our <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">ASD</a> . </p><br><h2>  Expressions </h2><br><p>  For expressions, I made a few simplifications: </p><br><ol><li>  I made the type of expression an enumeration, which I strongly advise against doing in a real compiler.  Any serious grammar makes support of a unified type of expression a very complicated process.  It is better to use types and implementations; </li><li>  For numbers, I used the <code>f32</code> type.  Floating point numbers are not always the best choice, but for our purposes <code>f32</code> is enough for us; </li><li>  I used an unstable feature <code>#![feature(box_patterns)]</code> .  With this syntax, pattern matching looks <s>prettier</s> . </li></ol><br><p>  The function for evaluating expressions <code>eval</code> also added. </p><br><p>  We will support expressions of numbers, arithmetic operators, and negations: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span></span> { Operator { op: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;, left: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;, right: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt; }, Number(<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>), Token(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), Negate(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expression&gt;) } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { Expression::Operator { op: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> Expression::Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left, right } =&gt; left.eval() + right.eval(), Expression::Operator { op: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> Expression::Token(<span class="hljs-string"><span class="hljs-string">'-'</span></span>), left, right } =&gt; left.eval() - right.eval(), Expression::Operator { op: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> Expression::Token(<span class="hljs-string"><span class="hljs-string">'/'</span></span>), left, right } =&gt; left.eval() / right.eval(), Expression::Operator { op: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> Expression::Token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), left, right } =&gt; left.eval() * right.eval(), Expression::Number(val) =&gt; val, Expression::Negate(exp) =&gt; -exp.eval(), token =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Got token inside an expression {:?}"</span></span>, token) } } }</code> </pre> <br><p>  And so, we have a lexically analyzer that gives us tokens and there is a type of expressions.  It's time to start the parser, which will turn sequences of characters into expressions. </p><br><h2>  Syntactical analyzer </h2><br><p>  Parser implementation is our main task. </p><br><p>  All parsing functions will accept the lexer and return the type <code>Option&lt;Box&lt;expression::Expression&gt;&gt;</code> : <code>Some(expression)</code> if the lexer output matches the rule and <code>None</code> if not. </p><br><p>  First, consider the auxiliary function, so that they do not distract us.  I will hide their implementation under the spoiler and can be viewed via the link in the repository. </p><br><p>  Two functions are used to parse the number and compare terminals (symbols <code>()+-.*</code> ): </p><br><div class="spoiler">  <b class="spoiler_title">Number and terminal parsing functions</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span></span>(lexer: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser_pos = lexer.position(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = lexer .next() .map(|c| c <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>) .and_then(|c| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.is_numeric() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(expression::Expression::Number(c.to_string().parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt;().unwrap()))) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lexer.rollback(parser_pos); <span class="hljs-literal"><span class="hljs-literal">None</span></span> }}); result } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">token</span></span></span></span>(token_char: <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser_pos = lexer.position(); lexer .next() .map(|c| c <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>).and_then(|c| <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == token_char { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(expression::Expression::Token(c))) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lexer.rollback(parser_pos); <span class="hljs-literal"><span class="hljs-literal">None</span></span> }) } }</code> </pre> </div></div><br><p>  And another function to create an expression for an arithmetic operation.  This functionality is used in several rules, so it is advisable to make it a separate function: </p><br><div class="spoiler">  <b class="spoiler_title">The function of creating an arithmetic operation</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_operator</span></span></span></span>(left: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;, op: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;, right: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;&gt; { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(expression::Expression::Operator{ op, left, right })) }</code> </pre> </div></div><br><p>  Also, the macro <code>debug_parser!</code> macro <code>debug_parser!</code>  .  It is used to debug the parser (thanks, Captain). </p><br><p>  We will define three macros: </p><br><ol><li> <code>rule!</code>  to generate a rule function; </li><li> <code>or!</code>  to generate the select function <code>"|"</code>  ; </li><li> <code>and!</code>  to generate the following function <code>","</code> . </li></ol><br><h3>  rule! </h3><br><p>  Let's start with the rule.  The macro generates a function with the specified name, which corresponds to the above signature, so it can in turn be used in another rule or function. </p><br><p>  The macro is quite simple: it creates a function that, in turn, when called with a lexer, returns the result of the function passed (sounds more complicated than it actually is). </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> rule { ($name: ident, $parse_func:expr) =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> $</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span></span>(lexer: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;&gt; { debug_parser!(<span class="hljs-string"><span class="hljs-string">"Executing rule {}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stringify!</span></span>($name)); $parse_func(lexer) } }; }</code> </pre> <br><h3>  or! </h3><br><p>  Next macro <code>or!</code>  .  It accepts the list of rules and returns an unnamed function (it is a lambda function, it is also a closure), which, when called with the parser, calls the passed rules one by one and returns the first positive call result, if any.  Otherwise, returns <code>None</code> .  The signature of the return closure is the same as for the rule. </p><br><p>  If you are not familiar with macros in Rust, you should pay attention to how the list of rules unfolds in the body of the macro.  For each rule, the expression <code>$(...),+</code> expanded once.  In our case, this is a block with a function call and a result check.  As a result, each transmitted rule will be called once. </p><br><p>  Note that the closure remembers the lexer position before calling each rule and rolls it back to the initial state if the rule is not executed: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> or { [$($parse_funcs: expr),+] =&gt; { |lexer: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer| -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;&gt; { $( <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser_pos = lexer.position(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = $parse_funcs(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result.is_some() { debug_parser!(<span class="hljs-string"><span class="hljs-string">"Or statement rule {} accepted expression {:?}. Lexer state {:?}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stringify!</span></span>($parse_funcs), result, lexer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lexer.rollback(parser_pos); debug_parser!(<span class="hljs-string"><span class="hljs-string">"Or statement rule {} didn't accept lexer input {:?}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stringify!</span></span>($parse_funcs), lexer); } )+; debug_parser!(<span class="hljs-string"><span class="hljs-string">"Or statement fails"</span></span>); <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } }</code> </pre> <br><h3>  and! </h3><br><p>  And finally, the macro <code>and!</code>  .  Its signature is slightly different from <code>or!</code>  .  It takes a list of rules and a handler function.  The macro returns a closure that calls the passed rules with the lexer and checks that they all return some expression.  If all the rules are executed for the lexer, it forms a tuple of results and passes it to the handler function.  If at least one rule is not executed or the handler function returns <code>None</code> , the lexer is rolled back to its initial position.  The signature of the circuit, according to tradition, is the same as the rule. </p><br><p>  The function handler is passed for ease of use.  It processes the sequence of expressions and converts them into the desired form for further processing.  As an example, you can look at the rule using brackets, which discards the brackets and returns the expression inside the brackets (brackets are only needed to correctly parse the order of calculations). </p><br><p>  The handler function is passed through the operator <code>=&gt;</code> to improve the readability of the macro call. </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> and { [($($parse_funcs: expr),+) =&gt; $nandler_func: expr] =&gt; { |lexer: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer| -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;expression::Expression&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser_pos = lexer.position(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> results = ($(<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> $parse_funcs(lexer) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expression) =&gt; { debug_parser!(<span class="hljs-string"><span class="hljs-string">"And statement rule {} accepted expression {:?}. Lexer state {:?}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stringify!</span></span>($parse_funcs), expression, lexer); expression } _ =&gt; { debug_parser!(<span class="hljs-string"><span class="hljs-string">"And statement rule {} didn't accept lexer input {:?}"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stringify!</span></span>($parse_funcs), lexer); lexer.rollback(parser_pos); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } }), +); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> std::ops::<span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>::call(&amp;$nandler_func, results) { expression @ <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(_) =&gt; { debug_parser!(<span class="hljs-string"><span class="hljs-string">"And handling function successfully handled expression and returned {:?}"</span></span>, expression); expression } _ =&gt; { debug_parser!(<span class="hljs-string"><span class="hljs-string">"And handling function failed to process expressions"</span></span>); lexer.rollback(parser_pos); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } } } }; }</code> </pre> <br><p>  Here it is worthwhile to draw on the call <code>std::ops::Fn::call</code> .  This is an unstable possibility, but without it we would have to pass a tuple, which is noticeably less convenient. </p><br><p>  Now we are ready to express our grammar using macros.  Here is the code that was at the beginning of the article: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// expr = sum // sum = mul "+" sum | mul "-" sum | mul // mul = atom "*" mul | atom "/" mul | atom // atom = "(", expr , ")" | number | neg; // neg = "-" atom rule!(expr, sum); rule!(sum, or![ and![(mul, token('+'), sum) =&gt; make_operator], and![(mul, token('-'), sum) =&gt; make_operator], mul ]); rule!(mul, or![ and![(atom, token('*'), mul) =&gt; make_operator], and![(atom, token('/'), mul) =&gt; make_operator], atom ]); rule!(atom, or![ and![(token('('), expr, token(')')) =&gt; |_lbrace, stat, _rbrace| Some(stat)], num, neg ]); rule!(neg, and![(token('-'), atom) =&gt; |_, number| Some(Box::new(expression::Expression::Negate(number)))]);</span></span></code> </pre> <br><p>  The result looks pretty good.  If we consider only the parser, we have invested in 65 lines of code.  Now it remains to write the test code and run it (yes, I‚Äôm not particularly a fan of the test code): </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result0 = expr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer::new(<span class="hljs-string"><span class="hljs-string">"1 + 2"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result1 = expr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer::new(<span class="hljs-string"><span class="hljs-string">"(1 + -2)"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result2 = expr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer::new(<span class="hljs-string"><span class="hljs-string">"(1 + 2) * 3"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result3 = expr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer::new(<span class="hljs-string"><span class="hljs-string">"1 * (2 - 3)"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result4 = expr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer::new(<span class="hljs-string"><span class="hljs-string">"1 * -2 + 3 * 4"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result5 = expr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> lexer::Lexer::new(<span class="hljs-string"><span class="hljs-string">"(1 * 2 + (-3 + -4))"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"0. Result {:?}"</span></span>, result0); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"1. Result {:?}"</span></span>, result1); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2. Result {:?}"</span></span>, result2); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"3. Result {:?}"</span></span>, result3); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"4. Result {:?}"</span></span>, result4); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"5. Result {:?}"</span></span>, result5); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result0.unwrap().eval(), <span class="hljs-number"><span class="hljs-number">1f32</span></span> + <span class="hljs-number"><span class="hljs-number">2f32</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result1.unwrap().eval(), <span class="hljs-number"><span class="hljs-number">1f32</span></span> - <span class="hljs-number"><span class="hljs-number">2f32</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result2.unwrap().eval(), (<span class="hljs-number"><span class="hljs-number">1f32</span></span> + <span class="hljs-number"><span class="hljs-number">2f32</span></span>) * <span class="hljs-number"><span class="hljs-number">3f32</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result3.unwrap().eval(), <span class="hljs-number"><span class="hljs-number">1f32</span></span> * (<span class="hljs-number"><span class="hljs-number">2f32</span></span> - <span class="hljs-number"><span class="hljs-number">3f32</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result4.unwrap().eval(), <span class="hljs-number"><span class="hljs-number">1f32</span></span> * -<span class="hljs-number"><span class="hljs-number">2f32</span></span> + <span class="hljs-number"><span class="hljs-number">3f32</span></span> * <span class="hljs-number"><span class="hljs-number">4f32</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(result5.unwrap().eval(), <span class="hljs-number"><span class="hljs-number">1f32</span></span> * <span class="hljs-number"><span class="hljs-number">2f32</span></span> + (-<span class="hljs-number"><span class="hljs-number">3f32</span></span> + -<span class="hljs-number"><span class="hljs-number">4f32</span></span>)); }</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="rust hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">1</span></span>), right: Number(<span class="hljs-number"><span class="hljs-number">2</span></span>) }) <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">1</span></span>), right: Negate(Number(<span class="hljs-number"><span class="hljs-number">2</span></span>)) }) <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), left: Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">1</span></span>), right: Number(<span class="hljs-number"><span class="hljs-number">2</span></span>) }, right: Number(<span class="hljs-number"><span class="hljs-number">3</span></span>) }) <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">1</span></span>), right: Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'-'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">2</span></span>), right: Number(<span class="hljs-number"><span class="hljs-number">3</span></span>) } }) <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left: Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">1</span></span>), right: Negate(Number(<span class="hljs-number"><span class="hljs-number">2</span></span>)) }, right: Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">3</span></span>), right: Number(<span class="hljs-number"><span class="hljs-number">4</span></span>) } }) <span class="hljs-number"><span class="hljs-number">5</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left: Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), left: Number(<span class="hljs-number"><span class="hljs-number">1</span></span>), right: Number(<span class="hljs-number"><span class="hljs-number">2</span></span>) }, right: Operator { op: Token(<span class="hljs-string"><span class="hljs-string">'+'</span></span>), left: Negate(Number(<span class="hljs-number"><span class="hljs-number">3</span></span>)), right: Negate(Number(<span class="hljs-number"><span class="hljs-number">4</span></span>)) } })</code> </pre> <br><h2>  Post Scriptum </h2><br><p>  Macros in Rust leave a good impression.  Sometimes it seems that there is a lack of some fundamental structures.  For example, expand a block N times without inserting a parameter, where N is the number of arguments. </p><br><p>  But the developers quite quickly add the required features, so there is hope (for example, they will soon add HKT and non-lexical scopes). </p><br><p>  All code can be viewed on <a href="https://github.com/alexander-smoktal/rust-macroparser">GitHub</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349054/">https://habr.com/ru/post/349054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349042/index.html">Video from UralJS # 6 mitap - get rid of this, type the Redux application and write on React without brakes</a></li>
<li><a href="../349044/index.html">What Robotics Can Teach Game AI</a></li>
<li><a href="../349046/index.html">Analysis of the regulation of cryptocurrency in world markets in early 2018</a></li>
<li><a href="../349048/index.html">Autoencoder in the tasks of political event clustering</a></li>
<li><a href="../349050/index.html">Go 1.10 Release Party @ Badoo February 24</a></li>
<li><a href="../349056/index.html">Open lesson "UML Diagrams"</a></li>
<li><a href="../349058/index.html">Remember everything</a></li>
<li><a href="../349060/index.html">Flask Mega-Tutorial, Part XI: Bare Cosmetics (Edition 2018)</a></li>
<li><a href="../349062/index.html">AgileDays'18: content - all over the head</a></li>
<li><a href="../349064/index.html">Universal React + Express Applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>