<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Million video calls per day or ‚ÄúCall Mom!‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the user's point of view, call services look pretty simple: you go to a page to another user, call, he picks up the phone, you talk to him. From ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Million video calls per day or ‚ÄúCall Mom!‚Äù</h1><div class="post__text post__text-html js-mediator-article">  From the user's point of view, call services look pretty simple: you go to a page to another user, call, he picks up the phone, you talk to him.  From the outside it seems that everything is simple, but few know how to make such a service.  But Alexander Tobol ( <a href="https://habr.com/users/alatobol/" class="user_link">alatobol</a> ) not only knows, but willingly shares his experience. <br><br><img src="https://habrastorage.org/webt/rq/un/cx/rquncxhtqvyydpdbneoatkwfvke.jpeg"><br><br>  Further, the text version of the report on HighLoad ++ Siberia, from which you will learn: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  how video call services work under the hood; </li><li>  how beautiful it is to break through NAT - it will be interesting also for specialists from the gaming industry, who need a peer-to-peer connection; </li><li>  how WebRTC works, what protocols it includes; </li><li>  How can you tying WebRTC through BigData. </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MnEXuKHjIOU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Alexander Tobol leads the development of Video and Tapes platforms at ok.ru. <br><a name="habracut"></a><br><h2>  Video call history <br></h2><br>  The first video call device appeared in 1960, it was called a picture chip, used dedicated networks and was extremely expensive.  In 2006, Skype added video calls to its application.  In 2010, Flash supported the RTMFP protocol, and we started video calls to Flash on Odnoklassniki.  In 2016, Chrome stopped support for Flash, and in August 2017 we restarted calls on a new technology, which I will discuss today.  Having finished the service, in half a year we received a significant increase in successfully made calls.  Recently, we also have masks in calls. <br><img src="https://habrastorage.org/webt/kn/9u/uy/kn9uuyg18yggcfabvmzgs-cfygg.jpeg"><br><br><h2>  Architecture and TK <br></h2><br>  Since we work in a social network, we have no technical tasks, and we do not know what TK is.  Usually the whole idea fits on one page and looks like this. <br><img src="https://habrastorage.org/webt/qf/9x/ju/qf9xjum4vvjczd3-momvzhht9cw.jpeg"><br><br>  The user wants to call other users using web or iOS / Android applications.  Another user may have several devices.  The call comes to all devices, the user picks up the phone on one of them, they talk.  It's simple. <br><br><h2>  Specifications <br></h2><br>  In order to make a quality call service, we need to understand what characteristics we want to track.  We decided to start by looking for what is most annoying to the user. <br><br>  The user is exactly annoyed if he picks up the phone and has to wait for the connection to be established. <br><img src="https://habrastorage.org/webt/8g/kk/qb/8gkkqbq6ioqxnn0ro6dcq9kwhno.jpeg"><br><br>  The user is annoyed if the quality of the call is low - something is interrupted, the video crumbles, the sound gurgles. <br><img src="https://habrastorage.org/webt/2l/rt/ud/2lrtudpp-tw5cjsknhzamgj--pi.jpeg"><br><br>  But the most annoying to the user is the delay in calls.  Latency is one of the important characteristics of calls.  When latency in a conversation of about 5 seconds is absolutely impossible to conduct a dialogue. <br><img src="https://habrastorage.org/webt/z-/tn/lf/z-tnlfghw6laz3j25e3kbwob9mi.jpeg"><br><br>  We have defined acceptable characteristics: <br><br><ul><li>  <strong>Start</strong> - we decided it was good to start a call in a second.  Those.  connecting after a user has answered should take no more than 1 second. </li><li>  <strong>Quality</strong> is a very subjective indicator.  You can measure, for example, the signal-to-noise ratio (SNR), but there are still missing frames and other artifacts.  We measured the quality rather subjectively and then evaluated the happiness of users. </li><li>  <strong>Latency</strong> should be less than 0.5 seconds.  If Latency is more than 0.5 seconds, then you already hear delays and start interrupting each other. </li></ul><br><img src="https://habrastorage.org/webt/cl/yx/j0/clyxj0ajsqq5coamt5orttz-kxc.jpeg"><br><br>  Polycom is a conferencing system installed in our offices.  The average polycom delay is about 1.3 seconds.  With such a delay is not always understand each other.  If the delay increases to 2 seconds, then the dialogue will be impossible. <br><img src="https://habrastorage.org/webt/3_/yy/qq/3_yyqqbvvq5zoavfa5q9tzvqhiq.jpeg"><br><br>  Since we already had a platform running, we roughly expected that we would have a million calls a day.  This is a thousand calls in parallel.  If all calls are sent through the server, there will be a thousand megabit calls per call.  This is just 1 gigabit / s of one iron server will be enough. <br><br><h2>  Internet vs TTX <br></h2><br>  What can prevent to achieve such class performance?  The Internet! <br><img src="https://habrastorage.org/webt/qb/aq/sy/qbaqsyfaf6vln4e882armfugx1g.jpeg"><br><br>  On the Internet, there are things like round-trip time (RTT), which cannot be overcome, there is variable bandwidth, there is NAT. <br><br>  Previously, we measured the transmission speed in the networks of our users. <br><img src="https://habrastorage.org/webt/bm/ge/z6/bmgez6efih7z_lqwidcknso8edw.jpeg"><br><br>  We smashed by the type of connection, looked at the average RTT, packet loss, speed, and decided that we would test calls on the average values ‚Äã‚Äãof each of these networks. <br><img src="https://habrastorage.org/webt/ui/o4/k8/uio4k8pmxmyxyclfwwawehqijes.jpeg"><br><br>  There are other troubles on the Internet: <br><br><ul><li> <strong>Packet loss</strong> - we measured 0.6% random packet loss (we do not take into account congestion packet loss with an excess number of packets). </li><li>  <strong>Reordering</strong> - you send packets in the same order, and the network re-sorts them. </li><li>  <strong>Jitter</strong> - you give a video or audio stream at a certain interval, and on the client side packets come glued together in bundles, for example, due to buffering on network devices. </li><li>  <strong>NAT</strong> - we got that more than 97% of users are behind NAT.  Let's talk further, why, what and how. </li></ul><br><img src="https://habrastorage.org/webt/z_/uo/mc/z_uomck64smc12_beaupdnutgp4.jpeg"><br><br>  Consider the above network settings for a simple example. <br><br>  I pinged the site of Novosibirsk State University from my office and received such a strange ping. <br><img src="https://habrastorage.org/webt/wi/am/at/wiamatloo1eviw58g3zgzbrsc2e.jpeg"><br><br>  The average jitter in this example is 30 ms, that is, the average interval between adjacent ping times is about 30 ms, and the average ping is 105 ms. <br><br>  What is important in calls, why will we fight for p2p? <br><img src="https://habrastorage.org/webt/gb/ny/yx/gbnyyxij20hrfo96scwubxdzovu.jpeg"><br><br>  Obviously, if between our users who are trying to talk to each other in St. Petersburg, we managed to establish a p2p connection, and not through a server that is located in Novosibirsk, we will save about 100 ms round-trip and traffic to this service. <br><br>  Therefore, most of the article is devoted to how to make a good p2p. <br><br><h2>  History or legacy <br></h2><br>  As I said, we had a call service from 2010, and now we have restarted it. <br><img src="https://habrastorage.org/webt/si/ru/lu/sirulur_jaalnldpkmvbjx7ct-q.jpeg"><br><br>  In 2006, when Skype was launched, Flash bought Amicima, which made RTMFP.  Flash already had the RTMP protocol, which in principle can be used for calls, and it is often used for streaming.  Flash later opened the RTMP specification.  I wonder why they needed RTMFP?  In 2010 we used exactly RTMFP. <br><br>  Let's compare the requirements for call protocols and real streaming protocols and see where this border is. <br><img src="https://habrastorage.org/webt/ih/j9/xi/ihj9xiris6praclbyxpxelwc1i4.jpeg"><br><br>  <strong>RTMP</strong> is more like a video streaming protocol.  It uses TCP, it has an accumulating delay.  If you have a good internet connection, calls to RTMP will work. <br><br>  <strong>The RTMFP protocol</strong> , despite the difference in just one letter, is the UDP protocol.  It is free from buffering problems ‚Äî those on TCP;  devoid of head-of-line locks - this is when you have lost one packet, and TCP does not give up the following packets until it is time to send the lost one again.  RTMFP was able to cope with NAT and was experiencing a change in the IP address of clients.  Therefore, we launched the web on RTMFP in 2010. <br><img src="https://habrastorage.org/webt/pv/rx/16/pvrx163tvieetirsg8nkfrov7qm.jpeg"><br><br>  Then, only in 2011, the initial draft WebRTC appeared, which was not yet fully operational.  In 2012, we started supporting calls to iOS / Android, then something else happened, and in 2016, Chrome stopped supporting Flash.  We had to do something. <br><img src="https://habrastorage.org/webt/uu/ub/cs/uuubcssxa_w9-ost03_y6dqq6ic.jpeg"><br><br>  We looked at all the VoIP protocols: as always, in order to do something, we start by studying the competitors. <br><br><h2>  Competitors or where to start <br></h2><br>  We chose the most popular competitors: Skype, WhatsApp, Google Duo (similar to Hangouts) and ICQ. <br><br>  To start, measure the delay. <br><img src="https://habrastorage.org/webt/yv/br/d2/yvbrd2tluf9yzf-xqqibngdooh8.jpeg"><br><br>  Make it easy.  Above is a picture in which: <br><br><ul><li>  Stopwatch (see phone at the top left), which shows the time (03:08). </li><li>  The middle phone makes a call and takes the first phone as a video.  From the moment the image got into the camera of the phone, and you saw it, it took about 100 ms. </li><li>  Call to another phone (white) and one more time.  Here the delay is about 310 ms with Google Duo. </li></ul><br>  I will not reveal all the cards so far, but we did it so that these devices could not establish p2p connections.  Of course, the measurements were carried out in different networks, and this is just an example. <br><img src="https://habrastorage.org/webt/rn/xz/ee/rnxzee4grukafmg0gu3cunpemsi.jpeg"><br><br>  Skype still interrupts a bit.  It turned out that Skype, in case it fails to connect p2p, has a delay of 1.1 s. <br><br>  The test environment was complicated.  We tested in different conditions (EDGE, 3G, LTE, WiFi), we took into account that the channels are asymmetric, and I give the averaged values ‚Äã‚Äãof all measurements. <br><img src="https://habrastorage.org/webt/gb/pp/6s/gbpp6sc5jugssoov8nmzvajlifo.jpeg"><br><br>  In order to estimate the battery consumption, the load on the processor and everything else, we decided that we can just measure the temperature of the phone with a pyrometer and assume that this is some average load on the GPU of the phone on the processor, on the battery.  In principle, it is very unpleasant to bring a hot phone to your ear, and hold it in your hands too.  It seems to the user that now the application will use up his entire battery. <br><img src="https://habrastorage.org/webt/dl/ck/vd/dlckvdbr8we75haadv9qkgk1jxk.jpeg"><br><br>  The result was: <br><br><ul><li>  ICQ and Skype were the slowest <strong>in delay</strong> , and Telegram was the fastest.  This is not a completely correct comparison, since Telegram has no video calls, but on audio, they have minimal latency.  WhatsApp works fine (about 200 ms) and Hangouts - 390 ms. </li><li>  <strong>In terms of temperature,</strong> Telegram eats the least without video, and most of all by Skype. </li><li>  In terms of <strong>response</strong> time, Telegram establishes the longest connection, and the fastest is WhatsApp and Google Duo. </li></ul><br>  Great, we got some metrics! <br><img src="https://habrastorage.org/webt/t8/mb/n0/t8mbn0vv_g1utslspeeevk8g5ie.jpeg"><br><br>  We tested the quality of video and voice in different networks, with different drops and everything else.  As a result, we came to the conclusion that the <strong>highest quality video on Google Duo, and the voice - on Skype</strong> , but this is in ‚Äúbad‚Äù networks, when there is already a distortion.  In general, all work about mediocre.  WhatsApp has the most blurred picture. <br><br>  Let's see what all this is implemented on. <br><img src="https://habrastorage.org/webt/ih/ap/1i/ihap1infndlvdjllso8eszhjnla.jpeg"><br><br>  Skype has its own proprietary protocol, and all others use either a modification of WebRTC, or WebRTC directly.  Hangouts, Google Duo, WhatsApp, Facebook Messenger can work with the web, and they all have WebRTC under the hood.  They are all so different, with different characteristics, and they all have the same WebRTC!  So, you need to be able to cook it properly.  Plus there is a Telegram, which has some parts of WebRTC responsible for the audio part, there is ICQ, which forks WebRTC a long time ago and went to develop its own way. <br><br><h2>  WebRTC.  Architecture <br></h2><br><img src="https://habrastorage.org/webt/3q/0x/-c/3q0x-cy-45bblq5lgoayq2awd5u.jpeg"><br><br>  WebRTC implies a signaling server, an intermediary between clients, which is used to exchange messages during the installation of a p2p connection between them.  After installing a direct connection, clients begin to exchange media with each other. <br><br><h2>  WebRTC.  Demo <br></h2><br>  Let's start with a simple demo.  There are simple 5 steps how to establish a WebRTC connection. <br><br><div class="spoiler">  <b class="spoiler_title">Detailed example code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-comment"><span class="hljs-comment">// Step #1: Getting local video stream and initializing a peer connection with it (both caller and callee) 2. 3. var localStream = null; 4. var localVideo = document.getElementById('localVideo'); 5. 6. navigator 7. .mediaDevices 8. .getUserMedia({ audio: true, video: true }) 9. .then(stream =&gt; { 10. localVideo.srcObject = stream; 11. localStream = stream; 12. }); 13. 14. var pc = new RTCPeerConnection({ iceServers: [...] }); 15. 16. localStream 17. .getTracks() 18. .forEach(track =&gt; pc.addTrack(track, localStream)); 19. 20. // Step #2: Creating SDP offer (caller) 21. 22. pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }) 23. .then(offer =&gt; signaling.send('offer', offer)); 24. 25. // Step #3: Handling SDP offer and sending SDP answer (callee) 26. 27. signaling.on('offer', offer =&gt; { 28. pc.setRemoteDescription(offer) 29. .then(() =&gt; pc.createAnswer()) 30. .then(answer =&gt; signaling.send('answer', answer)) 31. }); 32. 33. // Step #4: Handling SDP answer (calleer) 34. 35. signaling.on('answer', answer =&gt; pc.setRemoteDescription(answer)); 36. 37. // Step #5: Exchanging ICE candidates 38. 39. pc.onicecandidate = event =&gt; signaling.send('candidate', event.candidate); 40. 41. signaling.on('candidate', candidate =&gt; pc.addIceCandidate(candidate)); 42. 43. // Step #6: Getting remote video stream (both caller and callee) 44. 45. var remoteVideo = document.getElementById('remoteVideo'); 46. 47. pc.onaddstream = event =&gt; remoteVideo.srcObject = event.streams[0];</span></span></code> </pre> <br></div></div><br>  It says the following: <br><br><ol><li>  Take a video and set a peer connection, transfer some iceServers (it is not immediately clear what it is). <br></li><li>  Create an SDP offer and send it to signaling, and signaling WebRTC does not implement it for you. <br></li><li>  Then you need to make a wrapper for coming from signaling, and this is not included in WebRTC either. <br></li><li>  Further exchange some candidates. <br></li><li>  Finally get the remote video stream. <br></li></ol><br>  Let's still understand what is happening there and what we need to implement ourselves. <br><img src="https://habrastorage.org/webt/wx/fz/fn/wxfzfnkuw7smjite-bdpmadb_ro.jpeg"><br><br>  See the picture upwards.  There is a WebRTC library, which is already built into the browser, supported by Chrome, Firefox, etc. You can build it under Android / iOS and communicate with it through the API and SDP (Session Description Protocol), which describes the session itself.  Below I will tell you what is included in it.  To use this library in your application, you must establish a connection between subscribers via signaling.  Signaling is also your service that you have to write yourself, WebRTC does not provide it. <br><br>  Further in the article we will discuss the network in order, then video / audio, and in the end we will write our own signaling. <br><br><h2>  WebRTC network or p2p (actually c2s2c) <br></h2><br>  It seems that installing a p2p connection is quite simple. <br><img src="https://habrastorage.org/webt/he/7h/so/he7hsoyzqklbzj715slypgychgc.jpeg"><br><br>  We have Alice and Bob, who want to establish a p2p connection.  They take their IP addresses, they have a signaling server to which they both are connected, and through which they can exchange these addresses.  They exchange addresses, and oh!  Their addresses are the same, something went wrong! <br><img src="https://habrastorage.org/webt/rn/hc/uj/rnhcujxoa5k0tni2oquj-tx3hfi.jpeg"><br><br>  In fact, both users are most likely sitting behind Wi-Fi routers and these are their local gray IP addresses.  A router provides them with a feature such as Network Address Translation (NAT).  How does she work? <br><img src="https://habrastorage.org/webt/yr/xu/r0/yrxur0s_xhoye3i36zod4ropbec.jpeg"><br><br>  You have a gray subnet and an external IP address.  You send a packet to the Internet from your gray address, NAT replaces your gray address with a white one and remembers the mapping: which port it sent from, to which user and which port it corresponds to.  When the return packet arrives, it resolves the map for this map and sends it to the sender.  It's simple. <br><br>  Below is an illustration of how it looks in my home. <br><img src="https://habrastorage.org/webt/ud/ar/da/udardacyxvmzt5mq0modbosd-mc.jpeg"><br><br>  This is my internal IP-address and the address of the router (by the way, also gray).  If I trace and see the route, we will see my Wi-Fi router: a pack of gray provider addresses and an external white IP.  Thus, in fact, I will have two NATs: one, on which I am on Wi-Fi, and the other from the provider, if I, of course, have not bought a dedicated external IP address. <br><br>  <strong>NAT is so popular because:</strong> <br><br><ul><li>  still many IPv4, and addresses are missing; </li><li>  NAT seems to protect the network; </li><li>  This is the standard function of the router: connect to Wi-Fi, there is NAT right there, it works. </li></ul><br>  Therefore, only 3% of users sit with an external IP, and all others go through NAT. <br><br>  NAT allows you to safely go to any white addresses.  But if you did not go anywhere, then no one can come to you. <br><img src="https://habrastorage.org/webt/j7/cl/j2/j7clj2pypnpwv_p-odndgflgzpk.jpeg"><br><br>  To establish a p2p connection this is the problem.  In fact, Alice and Bob cannot send each other packets if they are both behind NAT. <br><br>  There is <strong>a STUN protocol</strong> in WebRTC to solve this problem.  It is proposed to deploy a STUN server.  Then Alice connects to the STUN server, gets her IP address, sends it to Bob via signaling.  Bob also gets his IP address and sends it to Alice.  They send packets to each other and thus break through NAT. <br><img src="https://habrastorage.org/webt/1m/mq/iz/1mmqiz57zbyzzahdgng_y_3hywo.jpeg"><br><br>  <strong>Question</strong> : Alice has a certain port open, NAT / Firewall is already pierced to this port, and Bob is open.  They know each other's addresses.  Alice tries to send the package to Bob, he sends the package to Alice.  Do you think they can talk or not? <br><br>  In fact, you are right in any case, the result depends on the type of NAT pair that users have. <br><img src="https://habrastorage.org/webt/te/hd/hj/tehdhjdvyvfv9dcrxng950n98h8.jpeg"><br><br><h3>  Network Address Translation <br></h3><br>  There are 4 types of NAT: <br><br><ol><li>  Full cone NAT; <br></li><li>  Restricted cone NAT; <br></li><li>  Port restricted cone NAT; <br></li><li>  Symmetric NAT. <br></li></ol><br>  In the basic version, Alice sends a packet to the server STUN, she opens a port.  Bob somehow finds out about her port and sends a reverse packet.  If this is <strong>Full cone NAT</strong> ‚Äî the simplest one that simply maps an external port to an internal one, then Bob will immediately be able to send a packet to Alice, establish a connection, and they will talk. <br><img src="https://habrastorage.org/webt/ph/kp/zr/phkpzrkuy3k2uzqsl4sub-sla7o.jpeg"><br><br>  Below is the interaction scheme: Alice sends a packet to the STUN port from some port, STUN responds with its external address.  STUN can reply from any address, if it is a Full cone NAT, it still breaks through NAT, and Bob can reply to the same address. <br><img src="https://habrastorage.org/webt/dl/pp/3a/dlpp3anl2az479kengmx5easix4.jpeg"><br><br>  In the case of <strong>Restricted cone, NAT</strong> is a bit more complicated.  He remembers not just the port from which you want to map to the internal address, but also the external address to which you went.  That is, if you have established a connection only to the IP of the STUN server, then no one else on the network can answer you, and then the package of Bob will not reach. <br><img src="https://habrastorage.org/webt/yt/-g/sg/yt-gsg5yyrf99ywt77j2ydntyzy.jpeg"><br><br>  How is this problem solved?  In a simple scheme (see illustration below), so: Alice sends a packet to STUN, he answers her IP.  STUN can respond to it from any port while it is Restricted cone NAT.  Bob cannot answer Alice because he has a different address.  Alice responds with a package, knowing Bob‚Äôs IP address.  She opens NAT to Bob, Bob answers her.  Hooray, they talked. <br><img src="https://habrastorage.org/webt/iz/ji/ar/izjiare3mege16iftxwal3haqye.jpeg"><br><br>  A slightly more complicated option is <strong>Port restricted cone NAT</strong> .  All the same, only STUN must respond exactly from the port to which it was addressed.  Everything will work too. <br><br>  The most harmful thing is <strong>Symmetric NAT</strong> . <br><img src="https://habrastorage.org/webt/p-/se/fu/p-sefuxnvpapxpuf8-wqavqkd0u.jpeg"><br><br>  Initially, everything works exactly the same - Alice sends a packet to the STUN server, he responds from the same port.  Bob cannot answer Alice, but she sends the package to Bob.  And here, despite the fact that Alice sends a packet to port 4444, the mapping allocates a new port to it.  Symmetric NAT is different in that when each new connection is established, it issues a new port on the router every time.  Accordingly, Bob fights at the port from which Alice went to STUN, and they can‚Äôt connect. <br><br>  In the opposite direction, if Bob is with an open IP address, Alice can just come to him, and they will establish a connection. <br><br>  All options are collected in one table below. <br><img src="https://habrastorage.org/webt/-c/jf/o9/-cjfo9dclflwku9qz-2p4wl_hre.jpeg"><br><br>  It shows that almost everything is possible except when we try to establish connections through Symmetric NAT with Port restricted cone NAT or Symmetric NAT at the other end. <br><img src="https://habrastorage.org/webt/gp/lk/_d/gplk_darehdjbaxktic84liuwto.jpeg"><br><br>  As we found out, p2p is invaluable for us in terms of latency, but if we failed to install it, then WebRTC offers us a TURN server.  When we realized that p2p is not established, we can simply connect to the TURN, which will proxy all traffic.  True, in this case you will pay for traffic, and users may have some additional delays. <br><br><h2>  Practice <br></h2><br>  Free STUN servers are at Google.  You can put them in the library will work. <br><br>  TURN servers have credential (login and password).  Most likely, you will have to raise your own, it is quite difficult to find free. <br><br>  Examples of free STUN servers from Google: <br><br><ul><li>  stun: stun.l.google.com: 19302 </li><li>  stun: stun1.l.google.com: 19302 </li><li>  stun: stun2.l.google.com: 19302 </li><li>  stun: stun3.l.google.com: 19302 </li></ul><br>  And the free TURN server with passwords: url: 'turn: 192.158.29.39: 3478? Transport = udp', credential: 'JZEOEt2V3Qb0y27GRntt2u2PAYA =', username: '28224511: 1379330808 ‚Ä≤. <br><br>  We use <a href="https://github.com/coturn/coturn">coturn</a> . <br><img src="https://habrastorage.org/webt/yj/_d/zv/yj_dzvkvpkhmol2a8ryscucgoli.jpeg"><br><br>  As a result, 34% of traffic passes through the p2p connection, everything else is proxied through the TURN server. <br><br><h4>  What else is interesting about the STUN protocol? <br></h4><br>  STUN allows you to determine the type of NAT. <br><img src="https://habrastorage.org/webt/nj/lo/7h/njlo7h_sounawjxlwk-pxsiejy0.jpeg"><br><br>  <a href="https://pastebin.com/XVTr6EWC"><em>Link</em></a> <em>on the slide</em> <br><br>  When sending a packet, you can indicate that you want to receive a response from the same port or ask STUN to respond from another port, from another IP, or from another IP and port in general.  Thus, <strong>for 4 requests to the STUN-server, you can determine the type of NAT</strong> . <br><img src="https://habrastorage.org/webt/og/0m/2h/og0m2hawerjjdabsr43zwygz_cy.jpeg"><br><br>  We considered NAT types and got that almost all users have either Symmetric NAT or Port restricted cone NAT.  Hence, it turns out that only a third of users can establish a p2p connection. <br><br>  You may ask why I am telling all this, if you could just take STUN from Google, stick it in WebRTC, and it seems like everything will work. <br><br>  Because you can actually define the type of NAT yourself. <br><img src="https://habrastorage.org/webt/ih/qn/8j/ihqn8j2nm2dumsstvyopem7ljxk.jpeg"><br><br>  This is a <a href="https://pastebin.com/QakVHj9Y">link</a> to a Java application that doesn't do anything tricky: it just pings different ports and different STUN servers, and looks at what port it sees in the end.  If you have an open Full cone NAT, then the STUN server answers will have the same port.  With Restricted cone NAT, you will receive different ports for each STUN request. <br><img src="https://habrastorage.org/webt/ve/qf/t1/veqft1dee6wstziwrkrbemxj5da.jpeg"><br><br>  With Symmetric NAT, my office turns out like this.  There are completely different ports. <br><br>  But sometimes there is an interesting pattern that for each connection the port number is increased by one. <br><img src="https://habrastorage.org/webt/2n/7e/ro/2n7ero_besx7rzunsjuzfjplfpy.jpeg"><br><br>  That is, many NATs are configured so that they increase or decrease the port by a constant.  You can find this constant and thus break through Symmetric NAT. <br><img src="https://habrastorage.org/webt/te/6n/bf/te6nbfknmebcz7zmrtk35jqwfpk.jpeg"><br><br>  Thus, we break through NAT - we go to one STUN-server, to another, we look at the difference, compare and try again to give our port with this increment or decrement.  That is, Alice is trying to give Bob his port, which has already been adjusted for a constant, knowing that next time it will be exactly like that. <br><img src="https://habrastorage.org/webt/l1/re/-m/l1re-mp1om6zkjqm0j1n5rfh004.jpeg"><br><br>  So we managed to <strong>make another 12% peer-to-peer</strong> . <br><br>  In fact, sometimes external routers with the same IP behave the same way.  Therefore, if you compile statistics and if Symmetric NAT is a feature of the provider, and not a feature of the user's Wi-Fi router, then the delta can be predicted, immediately sent to the user, so that he uses it and does not spend too much time on its determination. <br><br><h2>  CDN Relay or what to do if a p2p connection failed <br></h2><br>  If we still use the TURN server and work not in p2p, but in real mode, transferring all the traffic through the server, we can also add a CDN.  Unless, of course, you have a playground.  We have our own CDN sites, so for us it was quite simple.  But it was necessary to determine where it is better to send a person: to the CDN site or, say, to the channel to Moscow.  This is not a very trivial task, so we did this: <br><br><ol><li>  The Moscow sites were randomly given out to some users, some to the remote ones. <br></li><li>  Collected statistics on user's IP, on servers and on network characteristics. <br></li><li>  By maxMind, we grouped the subnets, looked at the statistics, and were able to understand by IP what the nearest TURN server was for the user to connect to. <br></li></ol><br><img src="https://habrastorage.org/webt/ql/dg/sy/qldgsyqtvaeqqdvyctilcipatau.jpeg"><br><br>  There is a CDN in Novosibirsk.  If everything works for you through Moscow, then 99 percentile RTT - 1.3 seconds.  Through the CDN, everything works much faster (0.4 seconds). <br><br>  Is it always better to use a p2p connection and not use a server?  An interesting example is the two Krasnoyarsk providers Optibyte and Mobra (perhaps the names have been changed).  For some reason, the connection between them on p2p is much worse than through MSK.  Probably, they are not friends with each other. <br><img src="https://habrastorage.org/webt/yq/en/dm/yqendmksjs7vila8zpra1xu_2uc.jpeg"><br><br>  We analyzed all such cases, randomly sending users to p2p or via MSK, collected statistics and built predictions.  We know that statistics need to be updated, so we specifically set up different connections for some users to check if something has changed in the networks. <br><br>  We measured such simple characteristics as round time, packet loss, bandwidth - it remains to learn how to compare them correctly. <br><img src="https://habrastorage.org/webt/yu/l-/nb/yul-nbvpnw5za6ixc80wlgumrse.jpeg"><br><br>  How to understand which is better: 2 Mbit / s of the Internet, 400 ms RTT and 5% packet Loss or 100 Kbit / s, 100 ms delay and meager packet loss? <br><br>  There is no exact answer, the video call quality assessment is very subjective.  Therefore, after the end of the call, we asked users to evaluate the quality in asterisks and set up constants based on the results.  It turned out that, for example, RTT is less than 300 ms - it does not matter anymore, bitrate is more important. <br><br>  Higher average user ratings on Android and iOS.  It can be seen that iOS users often put the unit and more often the top five.  I do not know why, probably, the specificity of the platform.  But with them we adjusted the constants so that we have, as it seems to us, good. <br><br>  Back to our article plan, we are still discussing the network. <br><br>  <strong>What is the connection setup?</strong> <br><img src="https://habrastorage.org/webt/-o/0b/zz/-o0bzzfolvd5rhfysec57ebndda.jpeg"><br><br>  Sent to PeerConnection () STUN and TURN servers, a connection is being established.  Alice finds out her IP, sends it to signaling;  Bob learns about Alice's IP.  Alice gets Bob's IP.  They exchange packets, perhaps ping NAT, perhaps set TURN and communicate. <br><img src="https://habrastorage.org/webt/yz/oa/rv/yzoarv064wp3s6zwwjpy0ec68hk.jpeg"><br><br>  In the 5 steps of the connection setup, which we discussed earlier, we sorted out the servers, understood where to get them, and that the ICE candidates are external IP addresses that we exchange via signaling.  The internal IP addresses of clients, if they are within the range of one Wi-Fi, you can also try to punch. <br><br>  We turn to the video. <br><br><h2>  Video and audio <br></h2><br>  WebRTC supports a certain set of video and audio codecs, but you can add your own codec there.  Basicly supported are <strong>H.264 and VP8 for video</strong> .  VP8 is a software codec, so it consumes a lot of battery.  H.264 is not available on all devices (usually it is native), so the default priority is set to VP8. <br><br>  Inside SDP (Session Description Protocol) there is a codec negotiation: when one client sends a list of their codecs, another - their own with priority, and they agree on which codecs they will use to communicate.  If desired, you can change the priority of the VP8 and H.264 codecs, and thus you can save battery on some devices, where 264 is native.  Here is <a href="https://is.gd/5WaBAP">an example</a> of how this can be done.  We did it, it seemed to us that users did not complain about the quality, but at the same time, the battery charge is much less. <br><br>  For audio, WebRTC has <strong>OPUS or G711</strong> , usually all OPUS always works, you don‚Äôt need to do anything with it. <br><br>  Lower temperature measurements after 10 minutes of use. <br><img src="https://habrastorage.org/webt/pf/-q/pj/pf-qpjvwi8myzm7_q1zlmpe2zbs.jpeg"><br><br>  It is clear that we tested different devices.  This is an example of an iPhone, and on it, the OK application spends the least battery on it, because the temperature of the device is the least. <br><br>  The second thing you can turn on if you use WebRTC is to <strong>automatically turn off the video during a very bad connection</strong> . <br><img src="https://habrastorage.org/webt/xg/kx/ab/xgkxab9ccijdbomfmja0rtrhfpg.jpeg"><br><br>  If you have less than 40 Kbps, the video will turn off.  You just need to check the box when creating a connection, the threshold value can be configured through the interface.  You can also set the minimum and maximum starting current bitrate. <br><img src="https://habrastorage.org/webt/xw/7d/ts/xw7dtsmnuz7pe0ujabtjapnnkxg.jpeg"><br><br>  This is a very useful thing.  If you set up a connection and you know in advance what bitrate you expect, you can transfer it, the call will start from it, and you will not need to adapt the bitrate.  Plus, if you know that you often have packet loss or bandwidth subsidence on your channel, then the maximum value can also be limited. <br><br>  WhatsApp works with a very soapy video, but with small delays, because the bitrate is aggressively pressing upward. <br><br>  We collected statistics with the help of MaxMind and mapped it. <br><img src="https://habrastorage.org/webt/la/1b/kq/la1bkqswv6zqpbqdd7zrjarq0xu.jpeg"><br><br>  This is an approximate starting quality that we use for calls in different regions of Russia. <br><br><h2>  Signaling <br></h2><br>  You will most likely have to write this part if you want to make calls.  There are all sorts of pitfalls.  Recall what it looks like. <br><img src="https://habrastorage.org/webt/ip/iv/er/ipiverlo5evjhsixis-obij86vs.jpeg"><br><br>  There is an application with signaling that connects and exchanges with SDP, and the SDP below is an interface to WebRTC. <br><br>  This is simple signaling: <br><img src="https://habrastorage.org/webt/y3/zl/ih/y3zlihhnt8w32ukv-ms7sbelbgm.jpeg"><br><br>  Alice calls Bob.  It connects, for example, via a web-socket connection.  Bob gets a push to his mobile phone or to the browser, or to some kind of open connection, connects via web-socket and after that he starts to ring the phone in his pocket.  Bob picks up the phone, Alice sends him his codecs and other features of WebRTC that she supports.  Bob answers her the same way, and after that they exchange the candidates they see.  Hooray, call! <br><br>  It all looks pretty long.  First, until you set up a web-socket connection, until a push comes in and everything else, Bob will not ring the phone in his pocket.  Alice will be waiting all the time, thinking where is Bob, why he doesn‚Äôt pick up the phone.  After confirmation, it all takes seconds, and even on good connections it can be 3-5 seconds, and on bad connections, all 10. <br><br>  We must do something about it!  You will tell me that everything can be done very simply. <br><br><img src="https://habrastorage.org/webt/kz/q0/ym/kzq0ymgejzqqpmlyso5ri8mvz-k.jpeg"><br><br>  If you already have an open connection to your application, you can immediately send a push to establish a connection, connect to the signaling server you need and immediately start calling. <br><br>  Then another optimization.  Even if the phone is still ringing in your pocket and you didn‚Äôt pick up the phone, you can actually exchange information about supported codecs, external IP addresses, start sending empty video packets, and in general everything will be warm with you.  As soon as you pick up the phone, everything will be great. <br><br>  We did it, and it seemed that everything was cool.  But no. <br><img src="https://habrastorage.org/webt/hh/m5/t6/hhm5t6dtihar96isxhtsm92pums.jpeg"><br><br>  The first problem - users often cancel the call.  They click "Call" and immediately make the cancellation.  Accordingly, the push goes to the call, and the user disappears (the Internet or something else disappears from him).  In the meantime, someone has a phone ringing, he picks up the phone, and they don‚Äôt wait for him there.  Therefore, our primitive optimization in order to start calling as soon as possible does not really work. <br><img src="https://habrastorage.org/webt/xy/we/gy/xywegygpnsrlns4osq7nn4i71f0.jpeg"><br><br>  With a quick cancel call there is a second harmful thing.  If you generate your conversation ID on the server, then you need to wait for a response.  That is, you create a call, get an ID, and only after that you can do whatever you want: send packets, exchange, including, cancel the call.  This is a very bad story, because it turns out that as long as your response has not come, you cannot actually cancel anything from the client.  Therefore, it is best to generate some kind of ID on a client like GUID and say that you started the call.  People still often do this: he called, canceled and immediately called again.  To avoid confusion, make a GUID and send it. <br><img src="https://habrastorage.org/webt/1e/he/ob/1eheobd8oyf6z-je6j0puuj7psy.jpeg"><br><br>  It seems to be nothing, but there is another problem.  If Bob has two phones, or somewhere else the browser remains open, then our entire magic scheme in order to exchange packets, establish a connection, does not work if he suddenly responded from another device. <br><br>  What to do?  Let us return to our basic simple signaling slow scheme and optimize it, send a push a little bit earlier.  The user will start to connect faster, but it will save some pennies. <br><img src="https://habrastorage.org/webt/ap/k3/kx/apk3kx9qq3nsrzmrervqa548e-g.jpeg"><br><br>  What to do with the longest part after he picked up the phone and started the exchange? <br><img src="https://habrastorage.org/webt/ff/bj/qv/ffbjqvge9liirsi6spjc7ttlyby.jpeg"><br><br>  You can do the following.  It‚Äôs clear that Alice already knows all her codecs and can send them to both Bob‚Äôs phones.  She can cut all her IP addresses and send them to the signaling too, which will keep them in her queue, but will not send to any of the clients so that they start to establish a connection with her ahead of time. <br><br>  What can bob?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having received the offer, he can see what codecs were there, generate his own, write what he has, and send it too. But Bob has two phones, and there are different codec negotiation, so signaling will keep it all on himself and will keep in line until he finds out on which device he picked up the phone. Candidates of their own will also generate both devices and send them to signaling. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, it turns out that signaling has one message queue from Alice and several message queues from Bob on different devices. He stores all this, and as soon as one of these devices is picked up, he simply transfers the entire set of already prepared packets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It works pretty fast. We got such an algorithm to reach the characteristics similar to Google Duo and WhatsApp.</font></font><br><img src="https://habrastorage.org/webt/qr/gs/ry/qrgsry_mx3ahy48v6gvw1l49uau.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps you can think of something else better. For example, several queues do not keep on signaling, but send them to the client, and then say which number, but most likely, the gain will be very small. We decided to stop at this. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What other problems await you?</font></font></strong> <br><img src="https://habrastorage.org/webt/tp/fn/p3/tpfnp3a3cqrv_pdv31x7m4tirxi.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is such a thing as a counter call: one calls the other, the other calls back. It would be great if they did not try to compete - at the signaling level, add a command that says that if someone came second, you need to switch to the mode when you just accept the call and immediately pick up the phone.</font></font><br><img src="https://habrastorage.org/webt/so/mv/go/somvgopdt0c3zi5kksffvtpogz4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It so happens that the network disappears, messages are lost, so everything must be done through the queue. That is, you must have a send queue on the client. Messages that you send from a client should be removed from the queue only after the server has confirmed that it has processed them. The server also has a queue for sending, and also with confirmation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So this is all implemented inside of us, given that we have a 24/7 service, we want to be able to lose data centers, shift and update the version of our software. </font></font><br><img src="https://habrastorage.org/webt/3a/uh/au/3auhaued9dsrfuwyhffcubvuqpy.jpeg"><br><br> <a href="https://youtu.be/UNLBEgksin8"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></em></a> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the slide to the video and link to the </font></font><a href="https://habr.com/company/odnoklassniki/blog/417593/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">text version</font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clients connect via web-socket to some kind of load balancer, it sends to signaling servers in different data centers, different clients can come to different servers. At Zookeeper, we do Leader Election, which defines the signaling server that is currently managing this conversation. If the server is not the leader of this conversation, it simply passes all messages to another. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next we use some distributed storage, we have this </font></font><a href="https://habr.com/company/odnoklassniki/blog/417593/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewSQL on top of Cassandra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Actually no matter what to use. </font><font style="vertical-align: inherit;">You can save anywhere the status of all the queues that are on signaling, so that if the signaling server goes down, the electricity goes down or something else happens, Leader Election will work on Zookeeper, another server will rise, which will become the leader, will restore all queues from the database messages and start sending. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm looks like this:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The client sends some message, say, its external IP to signaling </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signaling accepts, writes to the database. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After he realizes that everything has come, he replies that he has received this message. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The client removes this message from its queue. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All packages are supplied with unique numbers, so as not to be confused. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the point of view of the database, we use an add-on over Cassandra, which allows you to make transactions on it (the </font></font><a href="https://youtu.be/UNLBEgksin8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is just about that). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So you found out:</font></font></strong> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what is iceServers and how to transfer them; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what is the Session Description Protocol; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that it needs to be generated and sent to the other side; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that it needs to be received from signaling and transmitted to WebRTC on the other side, to exchange external IP addresses; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and start posting videos! </font></font></li></ul><br><img src="https://habrastorage.org/webt/6j/hp/6k/6jhp6kn6luheqat6jepleauq1me.jpeg"><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We got:</font></font></strong> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calls with delay below the market average; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we didn‚Äôt heat the phones much; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> response time in our application at the top level. </font></font></li></ul><br>  Great! <br><img src="https://habrastorage.org/webt/97/ru/zy/97ruzyu7gams8pyk2ktcoqb9yim.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Security. </font><font style="vertical-align: inherit;">Man in the middle attack for WebRTC</font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's talk about man in the middle attack for WebRTC. In fact, WebRTC is a very difficult protocol in terms of the fact that it is based on RTP, which is still 1996, and SDP came in 1998 from SIP. </font></font><br><img src="https://habrastorage.org/webt/yi/zm/7k/yizm7kvtjfnpnphvmuwiduk6yua.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The huge list below is a bunch of RFCs and other RTP extensions that make WebRTC out of RTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first on the list are two interesting RFCs - one of them adds audio levels to packets, and the other says that it is not safe to transmit audio levels openly in packets and encrypts them. Accordingly, when you exchange SDP, it is important for you to know which set of extensions clients support. There are even several congestion algorithms, several algorithms for recovering lost packets and everything.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The history of WebRTC was complicated. In 2011, the first draft release was released, in 2013, this protocol was supported by Firefox, then it began to build on iOS / Android, in 2014 Opera. In general, it has been developing for many, many years, but it still does not solve one interesting problem. </font></font><br><img src="https://habrastorage.org/webt/53/s2/31/53s231p3esxh8vt9ls8dn8szgqi.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Alice and Bob connect to signaling, then they use this channel, establish a DTLS Handshake and secure connection. Everything is great, but if it was not our signaling, then in principle a person in the middle has the opportunity to ‚Äúsniff‚Äù both with Alice and with Bob, to send all traffic and listen in on what is happening there. </font></font><br><img src="https://habrastorage.org/webt/i-/lq/uh/i-lquhbrd0eltgcqorvk1bu2gjs.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have a high-trust service, then, of course, you should definitely use HTTPS, WSS, etc. There is another interesting solution - ZRTP, it is used, for example, by Telegram.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many have seen Emodji in a Telegram when a connection is established, but few use them. In fact, if you tell a friend what kind of emoji you have, he will check that he has exactly such, then you have absolutely guaranteed secure p2p connection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How it works? </font></font><br><img src="https://habrastorage.org/webt/rx/0-/ws/rx0-wsjwmt6y8fboqtzsgyzpqos.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside all of these protocols, the usual Diffie-Hellman algorithm is initially used. Alice generates some numbers, sends them all but one to Bob. Bob also generates a random number and sends it to Alice. As a result of this exchange, Alice and Bob get some large number K, about which the man in the middle, who listened to their whole channel, knows nothing and cannot guess at all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Dave appears between Alice and Bob, they exchange the same keys with him, and they get K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> respectively. </font><font style="vertical-align: inherit;">Track the presence of this person in the middle is not possible. </font><font style="vertical-align: inherit;">Then this trick is applied. </font><font style="vertical-align: inherit;">These keys K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dave will definitely be different, since Alice and Bob generate their keys randomly. </font><font style="vertical-align: inherit;">We just take some hash from K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and K </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and display it in emodzhi: in an apple, in a pear - in everything, anything - and people simply use the voice to name those pictures that they see. </font><font style="vertical-align: inherit;">Since the voice can identify each other, and if these pictures are different, then someone is between you and maybe he is listening to you.</font></font><br><br><h2>  <strong>results</strong> <br></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We namini NAT type and probed symmetric NAT. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistically estimated, which is better: p2p or relay, quality, CDN; </font><font style="vertical-align: inherit;">and improved star quality in terms of users.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changed the priorities of codecs, saved a little battery. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minimized the signaling delay. </font></font></li></ul><br><img src="https://habrastorage.org/webt/xr/h6/2i/xrh62iyyd4cb5ynwfa66atogljm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The graph shows that first there were old calls to RTMFP, then, when we switched to WebRTC, there is a small failure, and then the peak is up. </font><font style="vertical-align: inherit;">Not everything worked out right away! </font><font style="vertical-align: inherit;">As a result, now we have the number of calls held increased by 4 times.</font></font><br><br><h2> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple instruction</font></font></strong> <br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you do not need all this, there is a very simple instruction: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">download the code from WebRTC ( </font></font><a href="https://webrtc.org/native-code/development/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://webrtc.org/native-code/development/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), compile it under iOS / Android, it already exists in all browsers;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deploy coturn ( </font></font><a href="https://github.com/coturn/coturn"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/coturn/coturn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> );</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> write signaling. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything will call and call pretty well. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listen to the answers to the questions after the report.</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/MnEXuKHjIOU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><blockquote>        HighLoad++  <a href="http://www.highload.ru/moscow/2018/abstracts/3547"></a>      4-. <br><br>     ,   <a href="http://www.highload.ru/moscow/2018/schedule"></a> .    ,  19  (10    9    -)  ,   -    .  ,       ,   . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/428217/">https://habr.com/ru/post/428217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428203/index.html">We look charts: estimates and forecasts for the cloud computing market, data in 2018</a></li>
<li><a href="../428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../428209/index.html">Developer Cookbook: Domain Driven Design Recipes (Part 2, Structure and Interaction)</a></li>
<li><a href="../428211/index.html">The book "Evolutionary Architecture. Continuous change support</a></li>
<li><a href="../428213/index.html">How to interpret model predictions in SHAP</a></li>
<li><a href="../428219/index.html">Where did the practice of mass relocation of qualified personnel come from?</a></li>
<li><a href="../428221/index.html">Generating arbitrary realistic entities using AI</a></li>
<li><a href="../428223/index.html">Cities and their ‚Äúbig data‚Äù</a></li>
<li><a href="../428225/index.html">How to do web analytics for SaaS through Google Analytics: introducing and tracking funnels</a></li>
<li><a href="../428227/index.html">Machine learning: predict stock prices in the stock market</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>