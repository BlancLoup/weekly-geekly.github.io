<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux memory access barriers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a partial translation of a comprehensive guide by David Howells and Paul E. McKenney distributed as part of the Linux documentation (D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux memory access barriers</h1><div class="post__text post__text-html js-mediator-article">  This article is a partial translation of a comprehensive guide by David Howells and Paul E. McKenney distributed as part of the Linux documentation (Documentation / memory-barriers.txt <a href="http://www.kernel.org/doc/Documentation/memory-barriers.txt">online version</a> ). <br><br>  Must read for kernel / driver developers and very informative for application programmers. <br><a name="habracut"></a><br><h2>  A generic memory access model. </h2><br>  Consider the following system model: <br><pre><code class="dos hljs">: : : : : : +-------+ : +--------+ : +-------+ | | : | | : | | | | : | | : | | | CPU <span class="hljs-number"><span class="hljs-number">1</span></span> |&lt;-----&gt;| Memory |&lt;-----&gt;| CPU <span class="hljs-number"><span class="hljs-number">2</span></span> | | | : | | : | | | | : | | : | | +-------+ : +--------+ : +-------+ ^ : ^ : ^ | : | : | | : | : | | : v : | | : +--------+ : | | : | | : | | : | | : | +----------&gt;| Device |&lt;----------+ : | | : : | | : : +--------+ : : :</code> </pre> <br><br>  Each processor executes a program that generates a sequence of memory access operations.  An abstract processor has a weak memory access ordering model, so that, in fact, access operations can be performed in any order, if this does not violate the causal relationships inherent in the executable code.  Similarly, the compiler is free to organize the generated code, provided that the result of the execution of this code will correspond to the source code of the program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the above figure, the memory operations performed by the processor are observed by the other components of the system, like operations crossing the boundaries between this processor and the system (indicated by dotted lines). <br><br><h1>  Operations with external devices. </h1><br>  Many devices have a control interface in the form of a set of registers with specific addresses in memory;  The order of access to control registers is important for proper operation.  For example, a network adapter may have a set of internal registers that are accessed through the address register (A) and the data register (D).  The following code can be used to read the internal register 5: <br><br><pre> <code class="hljs markdown"> <span class="hljs-emphasis"><span class="hljs-emphasis">*A = 5; x = *</span></span>D;</code> </pre><br>  This code can generate the following memory access sequences: <br><br><pre> <code class="hljs markdown">1  <span class="hljs-emphasis"><span class="hljs-emphasis">*A = 5, x =  *</span></span>D 2 x =  <span class="hljs-emphasis"><span class="hljs-emphasis">*D,  *</span></span>A = 5</code> </pre><br>  The second sequence will almost certainly return an incorrect result, since the address register will be set <i>after</i> reading the data register. <br><br><h1>  Guarantees. </h1><br>  The processor guarantees at least the following: <br><br><ul><li>  Memory access operations that depend on one another are performed in the correct order within the same processor.  In other words, for code <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">Q</span></span> = P; <span class="hljs-attribute"><span class="hljs-attribute">D</span></span> = *Q;</code> </pre><br>  the processor will generate the following memory access operations: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">Q</span></span> =  P, D =  *Q</code> </pre><br>  and only in that order. </li><li>  Writes and reads in overlapping areas of memory performed by a single processor maintain their order within this processor.  In other words, for code <br><br><pre> <code class="hljs markdown"> a = <span class="hljs-emphasis"><span class="hljs-emphasis">*X; *</span></span>X = b;</code> </pre><br>  the processor will generate only the following memory access sequence: <br><br><pre> <code class="hljs markdown"> a =  <span class="hljs-emphasis"><span class="hljs-emphasis">*X,  *</span></span>X = b</code> </pre><br>  And for the code <br><br><pre> <code class="hljs swift"> *<span class="hljs-type"><span class="hljs-type">X</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>; d = *<span class="hljs-type"><span class="hljs-type">X</span></span>;</code> </pre><br>  - only this: <br><br><pre> <code class="hljs swift">  *<span class="hljs-type"><span class="hljs-type">X</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d =  *<span class="hljs-type"><span class="hljs-type">X</span></span></code> </pre></li></ul><br><br>  Besides: <br><ul><li>  It should not be assumed that the access operations for independent reads and records will be generated in any particular order.  In other words, for code <br><br><pre> <code class="hljs markdown"> X = <span class="hljs-emphasis"><span class="hljs-emphasis">*A; Y = *</span></span>B; *D = Z;</code> </pre><br>  one of the following sequences can be generated: <br><br><pre> <code class="hljs markdown">1 X =  <span class="hljs-emphasis"><span class="hljs-emphasis">*A, Y =  *</span></span>B,  <span class="hljs-emphasis"><span class="hljs-emphasis">*D = Z 2 X =  *</span></span>A,  <span class="hljs-emphasis"><span class="hljs-emphasis">*D = Z, Y =  *</span></span>B 3 Y =  <span class="hljs-emphasis"><span class="hljs-emphasis">*B, X =  *</span></span>A,  <span class="hljs-emphasis"><span class="hljs-emphasis">*D = Z 4 Y =  *</span></span>B,  <span class="hljs-emphasis"><span class="hljs-emphasis">*D = Z, X =  *</span></span>A 5  <span class="hljs-emphasis"><span class="hljs-emphasis">*D = Z, X =  *</span></span>A, Y =  <span class="hljs-emphasis"><span class="hljs-emphasis">*B 6  *</span></span>D = Z, Y =  <span class="hljs-emphasis"><span class="hljs-emphasis">*B, X =  *</span></span>A</code> </pre></li><li>  It should be considered that adjacent and overlapping memory access operations can be combined or not performed at all.  In other words, for code <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">X</span></span> = *A; <span class="hljs-attribute"><span class="hljs-attribute">Y</span></span> = *(A + <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  one of the following sequences can be generated: <br><br><pre> <code class="hljs markdown">1 X =  <span class="hljs-emphasis"><span class="hljs-emphasis">*A; Y =  *</span></span>(A + 4); 2 Y =  <span class="hljs-emphasis"><span class="hljs-emphasis">*(A + 4); X =  *</span></span>A; 3 {X, Y} =  {<span class="hljs-emphasis"><span class="hljs-emphasis">*A, *</span></span>(A + 4) };</code> </pre><br>  And for the code <br><br><pre> <code class="hljs markdown"> <span class="hljs-emphasis"><span class="hljs-emphasis">*A = X; Y = *</span></span>A;</code> </pre><br>  - one of the following: <br><br><pre> <code class="hljs markdown">1  <span class="hljs-emphasis"><span class="hljs-emphasis">*A = X; Y =  *</span></span>A; 2  *A = Y = X;</code> </pre></li></ul><br><br><h2>  What are memory access barriers? </h2><br>  As shown above, independent memory access operations can be performed in a random order, which can be a problem for interaction between processors or between a processor and an external device.  A mechanism is required to indicate to the compiler and the processor that order is needed. <br><br>  Barriers to memory access are such a mechanism.  They lead to partial ordering of memory access operations on both sides of the barrier. <br><br>  Processors and other system devices use a variety of techniques to improve performance, including reordering operations, postponing and combining memory access operations, early reading of data, conversion prediction, and various types of caching.  Barriers to access memory serve to suppress these mechanisms. <br><br><h1>  Varieties of barriers. </h1><br>  There are 4 main types of barriers: <br><br><ol><li>  Barriers record. <br><br>  Write barriers ensure that all write operations to memory, for instructions preceding the barrier, will be performed by the processor prior to any write operation to memory, for instructions following the barrier, in terms of the rest of the system components. <br><br>  Write barriers order only write operations in memory; one should not assume that they can have any effect on read operations. <br><br>  <b>Note:</b> write barriers must have pair read barriers or data dependency barriers;  see the section <a href="https://habr.com/ru/post/155517/">‚ÄúPairing barriers in the case of SMP‚Äù</a> . <br></li><li>  Barriers to data dependency. <br><br>  Data dependency barriers are a weakened version of reading barriers.  In cases where two read operations are performed in such a way that the second operation depends on the result of the first (for example, the first operation receives the address from which the second one will read), the data dependency barrier ensures that the data at the address of the second read operation will be relevant at the time perform this operation. <br><br>  Data dependency barriers have an effect only on interdependent read operations; one should not assume that they can have an effect on write operations, independent or overlapping read operations. <br><br>  Other processors generate sequences of write operations to memory, the results of which can be observed by the processor in question.  The data dependency barrier ensures that if there are reads from the addresses that were written by another processor in front of the barrier, the results of all other write operations that preceded it will also be available to the processor passing the barrier after it has passed. <br><br>  <b>Note: the</b> relationship between readings must be valid data;  if the address of the second read operation depends on the result of the first one, but not directly, but is calculated based on the result of the first reading, for example, by conditional operators, then this is a control dependence, and in this case a read barrier or an access barrier should be used.  See <a href="https://habr.com/ru/post/155517/">‚ÄúManagement dependency barriers‚Äù</a> . <br><br>  <b>Note:</b> data dependency barriers must have dual record barriers;  see the section <a href="https://habr.com/ru/post/155517/">‚ÄúPairing barriers in the case of SMP‚Äù</a> . <br></li><li>  Barriers to reading. <br><br>  The read barrier is a data dependency barrier with the guarantee that all read operations for instructions preceding the barrier will be executed by the processor prior to any read operation for instructions following the barrier from the point of view of the rest of the system components. <br><br>  Read barriers order only read operations from memory; it should not be assumed that they can have any effect on write operations. <br><br>  <b>Note:</b> read barriers must have dual write barriers;  see the section <a href="https://habr.com/ru/post/155517/">‚ÄúPairing barriers in the case of SMP‚Äù</a> . <br></li><li>  Generalized memory access barriers. <br><br>  The memory access barrier ensures that all read and write operations for instructions preceding the barrier will be performed before any read or write operations for instructions following the barrier from the point of view of the rest of the system. <br><br>  The memory access barriers organize both read and write operations. <br><br>  Memory access barriers imply read barriers and write barriers and can be used instead of both. </li></ol><br>  And a couple of implicit types of barriers: <br><br><ol><li>  Lock Lock (LOCK) operations. <br><br>  Such operations behave as a barrier with unilateral permeability.  They ensure that all memory access operations, for instructions following the lock seizure operation, will be executed after the lock seizure, in terms of the rest of the system components. <br><br>  Memory access operations, for instructions preceding a lock seizure, can be performed both before and after its capture. <br><br>  A lock lock operation almost always must have a pair lock release operation. <br></li><li>  Unlock operations (UNLOCK). <br><br>  Such operations also act as a barrier with unilateral permeability.  They ensure that all memory access operations, for instructions preceding a lock release operation, will be executed before the lock is released, in terms of the rest of the system components. <br><br>  Memory access operations, for instructions following the release of a lock, can be performed both before and after it is released. <br><br>  It is guaranteed that lock capture and release operations are not reordered. <br><br>  The use of lock and release locks basically eliminates the need for using other types of memory access barriers. <br></li></ol><br><br>  Memory access barriers are required only in the case of interprocessor interaction, or processor interaction with an external device.  Memory access barriers are not needed in code that does not participate in these types of interactions. <br><br>  <b>Note: the</b> stated warranty is minimal.  Different processor architectures can provide stronger guarantees for barriers; however, they should not be relied upon in an architecture-independent code. <br><br><h1>  What barriers do not guarantee. </h1><br><ul><li>  There is no guarantee that memory access operations for instructions preceding the barrier will be completed at the moment the barrier passes;  conditionally, we can assume that the barrier ‚Äúdraws a line‚Äù in the queue of processor requests that certain types of requests cannot cross. </li><li>  There is no guarantee that a memory access barrier implemented on one processor will have any effect on another processor or other device in the system.  The indirect effect is expressed in the sequence of memory accesses observed by other devices performed by this processor (see, however, the next item). </li><li>  There is no guarantee that the processor will observe the effects of memory access from other processors in the correct order, even if they use memory access barriers if this processor does not use the appropriate barriers itself (see the section <a href="https://habr.com/ru/post/155517/">‚ÄúPair barriers in the case of SMP‚Äù</a> ). </li><li>  There is no guarantee that no intermediate devices will reorder the memory access.  The mechanisms for maintaining the coherence of the processor cache should transfer the effect of the barriers between the processors, but may interfere with their mutual order. </li></ul><br><br><h1>  Barriers to data dependency. </h1><br>  The model of using data dependency barriers has a number of subtleties, the need for which is not always obvious. <br>  Consider the following sequence of events: <br><br><pre> <code class="hljs delphi"> CPU <span class="hljs-number"><span class="hljs-number">1</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> =============== =============== <span class="hljs-comment"><span class="hljs-comment">{ A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C }</span></span> B = <span class="hljs-number"><span class="hljs-number">4</span></span>; &lt; &gt; P = &amp;B Q = P; D = *Q;</code> </pre><br>  There is an explicit data dependency in the code, and it seems that at the end of the sequence Q can be either &amp; A or &amp; B, as well as (Q == &amp; A) implies (D == 1), and (Q == &amp; B ) implies (D == 4). <br><br>  However, from the point of view of CPU2, P can be updated earlier than B, which will result in (Q == &amp; B) and (D == 2) (o_O). <br><br>  Although it may seem that such behavior is a violation of cause-effect relationships, or a problem of coherence, it is not.  This behavior is observed on some types of processors (for example, DEC Alpha). <br><br>  To correct the situation, a data dependency barrier (or stronger) between reading an address and reading data at this address is required: <br><br><pre> <code class="hljs xml"> CPU 1 CPU 2 =============== =============== { A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C } B = 4; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span> P = &amp;B Q = P; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">   &gt;</span></span> D = *Q;</code> </pre><br>  In this case, the third outcome ((Q == &amp; B) and (D == 2)) is impossible. <br><br>  <b>Note:</b> this unnatural situation is most easily replicable on machines with a split cache, when, for example, one cache bank serves even and the other odd cache lines.  In the case when P and B fall into lines of different parity, the uneven load on the cache banks can lead to the described effect. <br><br><a name="control"></a><h1>  Barriers to dependence on management. </h1><br>  The presence of a control dependency requires the use of a reading barrier; a data dependency barrier will not be enough.  Consider the following code: <br><br><pre> <code class="hljs javascript"> q = &amp;a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p) q = &amp;b; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name"></span></span></span></span><span class="xml"><span class="hljs-tag">   &gt;</span></span></span><span class="xml"> x = *q;</span></span></code> </pre><br>  The barrier in this example does not have the desired effect, since in fact the dependence on the data between (p) and (x = * q) is absent, and there is a dependence on control.  The processor may try to predict the result. <br>  What is really required in this situation: <br><br><pre> <code class="hljs javascript"> q = &amp;a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p) q = &amp;b; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name"></span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span><span class="xml"> x = *q;</span></span></code> </pre><br><br><a name="SMP"></a><h1>  Pair barriers in the case of SMP. </h1><br>  When organizing interprocessor interaction, certain types of barriers should always be used in pairs.  Lack of pairing is almost certainly an error. <br><br>  A write barrier should always have a pair in the form of a data dependency barrier, a read barrier, or a generalized memory access barrier.  Similarly, the data dependency barrier and the read barrier should have a pair in the form of a write barrier or a generalized memory access barrier: <br><br><pre> <code class="hljs xml"> CPU 1 CPU 2 =============== =============== a = 1; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span> b = 2; x = b; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span> y = a;</code> </pre><br>  or: <br><br><pre> <code class="hljs xml"> CPU 1 CPU 2 =============== =============================== a = 1; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span> b = &amp;a; x = b; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">   &gt;</span></span> y = *x;</code> </pre><br>  A reading barrier must always be present, the only question is what kind of primitive force should be chosen for it. <br><br>  <b>Note:</b> write operations before a write barrier usually have paired read operations on the other side of the read barrier or data dependencies and vice versa: <br><br><pre> <code class="hljs tex"> CPU 1 CPU 2 =============== =============== a = 1; }---- ---&gt;{ v = c b = 2; } <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>/ { w = d &lt; &gt; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>&lt; &gt; c = 3; } / <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{ x = a; d = 4; }</span></span></span></span>---- ---&gt;{ y = b;</code> </pre><br><br><h1>  Examples of memory access operations with barriers. </h1><br>  <b>First:</b> write barriers introduce partial order in the write operation.  Consider the following sequence of events: <br><br><pre> <code class="hljs xml"> CPU 1 =======================  A = 1  B = 2  C = 3 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span>  D = 4  E = 5</code> </pre><br>  This sequence reaches the memory coherence support system in the order that other parts of the system can observe as an unordered set of records {RECORD A, RECORD B, RECORD C}, occurring before an unordered record set {RECORD D, RECORD E}: <br><br><pre> <code class="hljs ruby"> +-------+ : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| C=3 |</span></span> } /\ <span class="hljs-params"><span class="hljs-params">| |</span></span> : +------+ }----- \ -----&gt;   <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| A=1 |</span></span> } \/    <span class="hljs-params"><span class="hljs-params">| |</span></span> : +------+ } <span class="hljs-params"><span class="hljs-params">| CPU 1 |</span></span> : <span class="hljs-params"><span class="hljs-params">| B=2 |</span></span> } <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ } <span class="hljs-params"><span class="hljs-params">| |</span></span> wwwwwwwwwwwwwwww } &lt;---      <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ }  ,      <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| E=5 |</span></span> }    <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-params"><span class="hljs-params">| |</span></span> : +------+ } ,    <span class="hljs-params"><span class="hljs-params">| |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| D=4 |</span></span> } <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ +-------+ : : <span class="hljs-params"><span class="hljs-params">| |</span></span> ,     <span class="hljs-params"><span class="hljs-params">|    CPU 1 V</span></span></code> </pre><br><br>  <b>Second</b> , data dependency barriers introduce partial order into data dependent read operations.  Consider the following sequence of events: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">CPU</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> ======================= ======================= { <span class="hljs-attribute"><span class="hljs-attribute">B</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">X</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Y</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">C</span></span> = &amp;Y }  A = <span class="hljs-number"><span class="hljs-number">1</span></span>  B = <span class="hljs-number"><span class="hljs-number">2</span></span> &lt; &gt;  C = &amp;B  X  D = <span class="hljs-number"><span class="hljs-number">4</span></span>  C ( &amp;B)  *C ( B)</code> </pre><br>  Without barriers, CPU 2 can observe events produced by CPU 1 in arbitrary order, despite the use of the CPU 1 recording barrier: <br><br><pre> <code class="hljs ruby"> +-------+ : : : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ +-------+ <span class="hljs-params"><span class="hljs-params">|   |</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> B=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">|----- ---&gt;|</span></span> Y-&gt;<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>  <span class="hljs-params"><span class="hljs-params">| |</span></span> : +------+ \ +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 2 |</span></span> CPU <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-params"><span class="hljs-params">| : |</span></span> A=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-params"><span class="hljs-params">| \ ---&gt;|</span></span> C-&gt;&amp;Y <span class="hljs-params"><span class="hljs-params">| V |</span></span> <span class="hljs-params"><span class="hljs-params">| +------+ |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> wwwwwwwwwwwwwwww <span class="hljs-params"><span class="hljs-params">| : : |</span></span> <span class="hljs-params"><span class="hljs-params">| +------+ |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| C=&amp;B |</span></span>--- <span class="hljs-params"><span class="hljs-params">| : : +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| : +------+ \ |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| D=4 |</span></span> -----------&gt;<span class="hljs-params"><span class="hljs-params">| C-&gt;&amp;B |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ : : |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| : : |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : : <span class="hljs-params"><span class="hljs-params">| CPU 2 |</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">|   ---&gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| B-&gt;7 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span>  B <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">|   ---&gt; \ |</span></span> X-&gt;<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> <span class="hljs-params"><span class="hljs-params">|   \ +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">|  B -----&gt;|</span></span> B-&gt;<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ +-------+ : :</span></span></code> </pre><br>  In the above example, CPU 2 observes the value B == 7, despite the fact that reading * C (which should return B) goes after reading C. <br>  However, if there is a data dependency barrier between reading C and reading * C (i.e. B) on CPU 2, <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">CPU</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> ======================= ======================= { <span class="hljs-attribute"><span class="hljs-attribute">B</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">X</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Y</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">C</span></span> = &amp;Y }  A = <span class="hljs-number"><span class="hljs-number">1</span></span>  B = <span class="hljs-number"><span class="hljs-number">2</span></span> &lt; &gt;  C = &amp;B  X  D = <span class="hljs-number"><span class="hljs-number">4</span></span>  C (gets &amp;B) &lt;   &gt;  *C (reads B)</code> </pre><br>  The picture looks like this: <br><br><pre> <code class="hljs ruby"> +-------+ : : : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| B=2 |</span></span>----- ---&gt;<span class="hljs-params"><span class="hljs-params">| Y-&gt;8 |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : +------+ \ +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 1 |</span></span> : <span class="hljs-params"><span class="hljs-params">| A=1 |</span></span> \ ---&gt;<span class="hljs-params"><span class="hljs-params">| C-&gt;&amp;Y |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| wwwwwwwwwwwwwwww |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ <span class="hljs-params"><span class="hljs-params">| : : |</span></span> <span class="hljs-params"><span class="hljs-params">| : |</span></span> C=&amp;B <span class="hljs-params"><span class="hljs-params">|--- |</span></span> : : +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> : +------+ \ <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> D=<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-params"><span class="hljs-params">| -----------&gt;|</span></span> C-&gt;&amp;B <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| +------+ |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ : : <span class="hljs-params"><span class="hljs-params">| : : |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| : : |</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> X-&gt;<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> ,   --&gt; \ ddddddddddddddddd <span class="hljs-params"><span class="hljs-params">| |</span></span>  ,  \ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>  C   -----&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;2 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span>  +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> : : +-------+</code> </pre><br><br>  <b>Third, the</b> reading barrier partially orders read operations.  Consider the following sequence of events: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">CPU</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> ======================= ======================= { <span class="hljs-attribute"><span class="hljs-attribute">A</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, B = <span class="hljs-number"><span class="hljs-number">9</span></span> }  A=<span class="hljs-number"><span class="hljs-number">1</span></span> &lt; &gt;  B=<span class="hljs-number"><span class="hljs-number">2</span></span>  B  A</code> </pre><br>  Without barriers, CPU 2 can observe events produced by CPU 1 in arbitrary order, despite the use of the CPU 1 recording barrier: <br><br><pre> <code class="hljs ruby"> +-------+ : : : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| A=1 |</span></span>------ ---&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;0 |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ \ +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 1 |</span></span> wwwwwwwwwwwwwwww \ ---&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;9 |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> B=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">|--- |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ \ <span class="hljs-params"><span class="hljs-params">| : : +-------+ +-------+ : : \ |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> ----------&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;2 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| A-&gt;0 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : : +-------+ \ : : \ +-------+ ----&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;1 |</span></span> +-------+ : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span></code> </pre><br>  However, if there is a read barrier between reading B and reading A on CPU 2, <br><br><pre> <code class="hljs xml"> CPU 1 CPU 2 ======================= ======================= { A = 0, B = 9 }  A=1 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span>  B=2  B <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span>  A</code> </pre><br>  partial order provided by CPU 1 will be observed by CPU 2 correctly: <br><br><pre> <code class="hljs ruby"> +-------+ : : : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| A=1 |</span></span>------ ---&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;0 |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ \ +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 1 |</span></span> wwwwwwwwwwwwwwww \ ---&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;9 |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> B=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">|--- |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> +------+ \ <span class="hljs-params"><span class="hljs-params">| : : +-------+ +-------+ : : \ |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> ----------&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;2 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| +-------+ |</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| : : |</span></span> <span class="hljs-params"><span class="hljs-params">|    -&gt; \ rrrrrrrrrrrrrrrrr |</span></span> <span class="hljs-params"><span class="hljs-params">|     \ +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">|   B ----&gt;|</span></span> A-&gt;<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-params"><span class="hljs-params">|------&gt;|</span></span> <span class="hljs-params"><span class="hljs-params">|   CPU 2 +-------+ |</span></span> <span class="hljs-params"><span class="hljs-params">| : : +-------+</span></span></code> </pre><br><br><h1>  Barriers to reading and load speculation. </h1><br>  Many processor architectures can read from memory in advance: in cases where the processor sees a read command from memory in the pipeline and does not use an external bus for other commands, a read command can be issued in advance ‚Äî even if the command execution flow has not reached the read instruction.  This makes it possible for the read instructions to complete very quickly, because by the time it is executed, the processor may already receive the value read from the memory. <br><br>  It may happen that the read value is not needed - for example, if the transition command occurs before the reading command.  In such cases, the read value will be discarded or stored in the cache. <br><br>  Consider the following example: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">CPU</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> CPU <span class="hljs-number"><span class="hljs-number">2</span></span> ======================= =======================  B  }  , ,  }      A</code> </pre><br>  which can generate the following commands: <br><br><pre> <code class="hljs ruby"> : : +-------+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> ---&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;2 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 2 |</span></span> : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>   , ---&gt; ---&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;0 |</span></span>~~~~ <span class="hljs-params"><span class="hljs-params">| |</span></span>     +-------+ ~ <span class="hljs-params"><span class="hljs-params">| |</span></span>   A : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span>     --&gt; : : ~--&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span>     : : <span class="hljs-params"><span class="hljs-params">| |</span></span>    : : +-------+</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Placing a read barrier or data dependency before a second read operation </font></font><br><br><pre> <code class="hljs xml"> CPU 1 CPU 2 ======================= =======================  B   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span>  A</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will force the processor to revise the pre-read value, depending on the type of barrier used. </font><font style="vertical-align: inherit;">If the pre-read memory area has not changed, the value will be used:</font></font><br><br><pre> <code class="hljs ruby"> : : +-------+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> ---&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;2 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 2 |</span></span> : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>   , ---&gt; ---&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;0 |</span></span>~~~~ <span class="hljs-params"><span class="hljs-params">| |</span></span>     +-------+ ~ <span class="hljs-params"><span class="hljs-params">| |</span></span>   A : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> rrrrrrrrrrrrrrrr~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~--&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> : : <span class="hljs-params"><span class="hljs-params">| |</span></span> : : +-------+</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> however, if the memory area was overwritten by another processor, the previously read value will be discarded and the read command will be issued again: </font></font><br><br><pre> <code class="hljs ruby"> : : +-------+ +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> ---&gt;<span class="hljs-params"><span class="hljs-params">| B-&gt;2 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| CPU 2 |</span></span> : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>   , ---&gt; ---&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;0 |</span></span>~~~~ <span class="hljs-params"><span class="hljs-params">| |</span></span>     +-------+ ~ <span class="hljs-params"><span class="hljs-params">| |</span></span>   A : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> : : ~ <span class="hljs-params"><span class="hljs-params">| |</span></span> rrrrrrrrrrrrrrrrr <span class="hljs-params"><span class="hljs-params">| |</span></span> +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span>    ---&gt; ---&gt;<span class="hljs-params"><span class="hljs-params">| A-&gt;1 |</span></span>------&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span>     +-------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> : : +-------+</code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explicit barriers in the core. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux has the following types of barriers that operate at different levels: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barriers to the compiler. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU barriers. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Record barriers in memory mapped I / O areas (MMIO). </font></font></li></ul><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barriers to the compiler. </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The explicit compiler barrier prevents the compiler from moving memory access operations from one side of the barrier to the other: </font></font><br><br><pre> <code class="hljs lisp"> barrier()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the only compiler level barrier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The compiler barrier has no effect on the behavior of the processor, which can reorder memory access operations at its discretion.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU barriers. </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following 8 functions are processor barriers in Linux: </font></font><br><br><pre> <code class="hljs 1c"> <span class="hljs-built_in"><span class="hljs-built_in"></span></span>   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> SMP ===================== ======================= ===========================   mb() smp_mb()  wmb() smp_wmb()  rmb() smp_rmb()  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  read_barrier_depends() smp_read_barrier_depends()</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All processor level barriers, with the exception of the data dependency barrier, include a compiler barrier. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the case of data dependency, one would expect the compiler to organize the reading instructions in the correct order (for example, a [b] read the value of b first, and then a [b]), but the C standard does not give such a guarantee. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When compiling a single-processor core, SMP versions of the barriers turn into compiler barriers, because one processor always observes its own memory operations in the correct order. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SMP barriers should be used to control the order of shared memory operations in SMP systems, but in fact, it is enough to use blocking synchronization primitives.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unconditional barriers should not be used to control the effects of SMP, as this results in poor performance on single-processor systems. </font><font style="vertical-align: inherit;">Their main area of ‚Äã‚Äãuse is the ordering of access operations to I / O devices mapped into memory.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Record barriers in memory mapped I / O areas (MMIO). </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following function is a barrier to writing to the I / O memory mapped: </font></font><br><br><pre> <code class="hljs lisp"> mmiowb()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function is an option of a mandatory write barrier and provides partial ordering of write operations to the MMIO region. </font><font style="vertical-align: inherit;">Its effect can extend inland beyond the interface between the processor and the memory subsystem.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Effects of the processor cache. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How the operations on cached memory are observed by the components of the system depends largely on the cache located between the processor and the memory and the system for maintaining its coherence. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the point of view of the memory access barriers under consideration, the processor cache and the system for maintaining its coherence are part of the system memory; the effect of memory access barriers manifests itself on the border depicted by the dotted line in the diagram:</font></font><br><br><pre> <code class="hljs ruby"> &lt;--- CPU ---&gt; : &lt;-----------  -----------&gt; : +--------+ +--------+ : +--------+ +-----------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +--------+ <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| CPU |</span></span>---&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span>-----&gt;<span class="hljs-params"><span class="hljs-params">| CPU |</span></span>&lt;--&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>---&gt;<span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +--------+ +--------+ : +--------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">|  |</span></span> +--------+ : <span class="hljs-params"><span class="hljs-params">|  |</span></span> : <span class="hljs-params"><span class="hljs-params">| - |</span></span> +--------+ +--------+ +--------+ : +--------+ <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>---&gt;<span class="hljs-params"><span class="hljs-params">| -|</span></span> <span class="hljs-params"><span class="hljs-params">| CPU |</span></span>---&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span>-----&gt;<span class="hljs-params"><span class="hljs-params">| CPU |</span></span>&lt;--&gt;<span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> : <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +--------+ +--------+ +--------+ : +--------+ +-----------+ : <span class="hljs-symbol"><span class="hljs-symbol">:</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although memory access operations can be performed by the processor without accessing the external bus, for example, from the cache, for other processors, the cache coherence support system still maintains the appearance that interprocessor interaction occurs through external memory by migrating cache lines to which access is provided. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The processor core executes instructions in the order that is convenient for it, while guaranteeing the preservation of cause-and-effect relationships in the executed program. Some instructions generate read or write requests that are placed in a queue of requests to the memory subsystem. The processor core places them in a queue in the appropriate order and continues execution until it needs to get the result of any of these instructions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memory access barriers control the order in which requests are transferred from the processor to the memory, as well as the observability of the effects of operations performed on memory by other components of the system. </font></font></div><p>Source: <a href="https://habr.com/ru/post/155517/">https://habr.com/ru/post/155517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155505/index.html">Java application debugging with JDI</a></li>
<li><a href="../155507/index.html">Demonstration of program crashes in the absence of memory barriers</a></li>
<li><a href="../155509/index.html">Timer Architecture in node.js</a></li>
<li><a href="../155511/index.html">My bike for snippets</a></li>
<li><a href="../155515/index.html">Multimethods in C ++. Library implementation. Introduction to MML</a></li>
<li><a href="../155519/index.html">The next era of NASA's Remote Space Network (DSN) lies in the field of X-rays and lasers.</a></li>
<li><a href="../155523/index.html">The continuation of a series of crash tests waterproof phones Sonim, Samsung and Sony. Part 2</a></li>
<li><a href="../155525/index.html">Organic Groups in Drupal 7</a></li>
<li><a href="../155527/index.html">Canonical tries to transfer Ubuntu Linux to tablet PCs</a></li>
<li><a href="../155529/index.html">Six charging stations for Tesla Model S built in California</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>