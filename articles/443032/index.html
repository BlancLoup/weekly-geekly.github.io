<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web components in the real world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo by NeONBRAND 


 Web components are a generic name for a set of technologies designed to help web developers create reusable blocks. The compone...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web components in the real world</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/uo/pu/ne/uopuneinui-cebkkwkd9mx700q8.jpeg"><br><p>  <sub><i>Photo by <a href="https://unsplash.com/photos/tKvp2XBx4NE">NeONBRAND</a></i></sub> </p><br><p>  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web components</a> are a generic name for a set of technologies designed to help web developers create reusable blocks.  The component approach to creating interfaces is well established in front-end frameworks, and it seems like a good idea to embed this functionality natively in browsers.  Browser support for this technology has already reached a sufficient level so that you can seriously think about using this technology for your work projects. </p><br><p>  In this article we will look at the features of using web components, which evangelists of these technologies for some reason do not speak about. </p><a name="habracut"></a><br><h2 id="chto-takoe-veb-komponenty">  What are web components? </h2><br><p>  First you need to decide what exactly is included in the concept of web components.  A good <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">description of the technology</a> is on MDN.  Briefly, the following features are usually included in this concept: </p><br><ul><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements">Custom elements</a> - the ability to register your html tags with a specific behavior </li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">Shadow DOM</a> - creating an isolated CSS context </li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots">Slots</a> - the ability to combine external html content with internal html component </li></ul><br><p> As an example, write a <code>hello-world</code> component that will greet the user by the name: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// -     html- class HelloWorld extends HTMLElement { constructor() { super(); //  Shadow DOM this.attachShadow({ mode: "open" }); } connectedCallback() { const name = this.getAttribute("name"); //     Shadow DOM this.shadowRoot.innerHTML = `Hello, &lt;strong&gt;${name}&lt;/strong&gt; :)`; } } //     html- window.customElements.define("hello-world", HelloWorld);</span></span></code> </pre> <br><p>  Thus, each time the <code>&lt;hello-world name="%username%"&gt;&lt;/hello-world&gt;</code> tag is placed on the page, a greeting will appear in its place.  Very comfortably! </p><br><p>  View this code in action <a href="https://jsfiddle.net/just_boris/13kgq0dh/">here</a> . </p><br><h2 id="vam-vse-ravno-ponadobyatsya-freymvorki">  You still need frameworks. </h2><br><p>  It is widely believed that the implementation of web components will make the framework unnecessary, because the built-in functionality will be enough to create interfaces.  However, it is not.  Custom html tags really resemble Vue or React components, but this is not enough to replace them entirely.  The browsers do not contain anything similar to VDOM - an approach to interface description, when the developer simply describes the desired html, and the framework will take care of updating the DOM ‚Äì elements that have really changed compared to the previous state.  This approach greatly simplifies working with large and complex components, so without VDOM it will be hard. </p><br><p>  In addition, in the previous section with an example of a component, you might have noticed that we had to write some amount of code to register the component and activate the Shadow DOM.  This code will be repeated in each component created, so it makes sense to bring it to the base class - and now we already have the beginnings of the framework!  For more complex components, we will also need a subscription to change attributes, convenient templates, work with events, etc. </p><br><p>  In fact, web-based frameworks already exist, for example <a href="https://github.com/polymer/lit-element">lit-element</a> .  The lit-element already has built-in VDOM, <a href="https://lit-html.polymer-project.org/">lit-html</a> , and other basic features.  Writing components in this way is much more convenient than through the native API. </p><br><p>  More often talk about the benefits of web components in the form of reducing the size of the loaded Javascript.  However, the lit-element that uses web components weighs <a href="https://bundlephobia.com/result%3Fp%3Dlit-element%402.0.1">6 kb</a> at best, while there is a preact that uses its components similar to React, but at the same time weighs 2 times less than <a href="https://bundlephobia.com/result%3Fp%3Dpreact%408.4.2">3 kb</a> .  Thus, the size of the code and the use of web components are orthogonal things and does not contradict one another. </p><br><h2 id="shadow-dom-i-proizvoditelnost">  Shadow DOM and performance </h2><br><p>  Styling large html pages may require a lot of CSS, and it may be difficult to come up with unique class names.  Here comes the Shadow DOM.  This technology allows you to create areas of isolated CSS.  Thus, you can render a component with its own styles that will not overlap with other styles on the page.  Even if you have a class name that matches something else, styles will not mix if each one lives in its own Shadow DOM.  The Shadow DOM is created by calling the <code>this.attachShadow()</code> method, and then we have to add our styles inside the Shadow DOM, either with the <code>&lt;style&gt;&lt;/style&gt;</code> or via <code>&lt;link rel="stylesheet"&gt;</code> . </p><br><p>  Thus, each component instance receives its own copy of CSS, which obviously should affect performance.  This <a href="https://web-components-gepwesylkw.now.sh/">demo</a> shows exactly how.  If the render of ordinary elements without Shadow DOM takes about 30 ms, then with Shadow DOM it is about 50 ms.  Perhaps in the future, browser manufacturers will improve performance, but now it‚Äôs better to abandon small web components and try to make components like <code>&lt;my-list items="myItems"&gt;</code> instead of separate <code>&lt;my-item item="item"&gt;</code> . </p><br><p>  It is also worth noting that alternative approaches, such as CSS modules, do not have such problems, because everything happens at the assembly stage, and regular CSS comes to the browser. </p><br><h2 id="globalnye-imena-komponentov">  Global component names </h2><br><p>  Each web component is bound to its own tag name using <code>customElements.define</code> .  The problem is that the names of the components are declared globally, that is, if someone has already taken the name <code>my-button</code> , you cannot do anything about it.  In small projects, where all component names are controlled by you, this is not a particular problem, but if you use a third-party library, then everything can suddenly break when you add a new component with the same name that you already used.  Of course, this can be defended by the convention of naming using prefixes, but this approach is very similar to the problems with the names of CSS classes that web components promised us to get rid of. </p><br><h2 id="tree-shaking">  Tree-shaking </h2><br><p>  Another problem follows from the global register of components - you do not have a clear connection between the place of registration of the component and its use.  For example, in React, any component used must be imported into a module. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./button"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... render() { return &lt;Button&gt;Click me!&lt;/Button&gt; }</span></span></code> </pre> <br><p>  We explicitly import the Button component.  If you delete the import, then we will have an error in rendering.  With web components, the situation is different, we just render html tags, and they magically come to life.  A similar example with a button on the lit-element would look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'@polymer/paper-button/paper-button.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... render() { return html`&lt;paper-button&gt;Click me!&lt;/paper-button&gt;`; }</span></span></code> </pre> <br><p>  There is no connection between import and use.  If we remove the import, but it remains in some other file, the button will continue to work.  If the import suddenly disappears from another file too, then only then something will break and it will be very sudden. </p><br><p>  The absence of an explicit connection between import and use does not allow <a href="https://webpack.js.org/guides/tree-shaking/">tree-shaking of</a> your code, automatic deletion of unused imports.  For example, if we import several components, but not all of them, they will be automatically deleted: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Button, Icon } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./components'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... render() { return &lt;Button&gt;Click me!&lt;/Button&gt; }</span></span></code> </pre> <br><p>  Icon in this file is not used and will be safely removed.  In the situation with web components, this number will not work, because the bandler is unable to track this connection.  The situation is very similar to the year 2010, when we manually connected the necessary jquery plugins into the site header. </p><br><h2 id="problemy-s-tipizaciey">  Problems with typing </h2><br><p>  Javascript is inherently a dynamic language, and not everyone likes it.  In large projects, developers prefer typing, adding it with Typescript or Flow.  These technologies are perfectly integrated with modern frameworks like React, checking the correctness of calling components: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">&lt;</span></span>{ text: string }&gt; {} &lt;Button /&gt; <span class="hljs-comment"><span class="hljs-comment">// :    text &lt;Button text="Click me" action="test" /&gt; // :   action &lt;Button text="Click me" /&gt; //   ,  </span></span></code> </pre> <br><p>  With web components this doesn't work.  The previous section explained that the location of a web component is statically unrelated to its use, and for the same reason, Typescript will not be able to display valid values ‚Äã‚Äãfor the web component.  Here <code>JSX.IntrinsicElements</code> can come to the <code>JSX.IntrinsicElements</code> - a special interface from where Typescript takes information for native tags.  We can add a definition for our button there. </p><br><pre> <code class="javascript hljs">namespace JSX { interface IntrinsicElements { <span class="hljs-string"><span class="hljs-string">'paper-button'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">raised</span></span>: boolean; disabled: boolean; children: string } } }</code> </pre> <br><p>  Now Typescript will know about the types of our web component, but they are not related to its source code.  If new properties are added to the component, in JSX the definition will need to be added manually.  In addition, this declaration does not help us in any way when working with an element through a <code>querySelector</code> .  There you have to cast the value to the desired type: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'paper-button'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PaperButton;</code> </pre> <br><p>  Perhaps, as the standard spreads, Typescript will come up with a way to statically typify web components, but for now, using web components will have to say goodbye to type safety. </p><br><h2 id="gruppovoe-obnovlenie-svoystv">  Bulk property update </h2><br><p>  Native browser components, such as <code>&lt;input&gt;</code> or <code>&lt;button&gt;</code> , accept values ‚Äã‚Äãas text attributes.  However, sometimes it may be necessary to transfer more complex data to our components, objects, for example.  For this it is proposed to use properties with getters and setters. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     DOM const component = document.querySelector("users-list"); //     component.items = myData;</span></span></code> </pre> <br><p>  On the component side, we define the setter that will process this data: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ set items(items) { <span class="hljs-comment"><span class="hljs-comment">//   this.__items = items; //   this.__render(); } }</span></span></code> </pre> <br><p>  In the lit-element there is a convenient decorator for this - property: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ @property() users: User[]; }</code> </pre> <br><p>  However, it may happen that we need to update several properties at once: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"users-list"</span></span>); component.expanded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; component.items = myData; component.selectedIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><p>  Each setter causes rendering, because it does not know that other properties will be updated there.  As a result, we will have two unnecessary updates with which we need to do something.  The standard does not provide anything ready, so developers need to wriggle out themselves.  In lit-element, this is solved by asynchronous rendering, that is, the setter does not directly cause the update, but leaves a request for deferred rendering, something like <code>setTimeout(() =&gt; this.__render(), 0)</code> .  This approach allows you to get rid of unnecessary redrawing, but complicates the work with the component, for example, its testing: </p><br><pre> <code class="javascript hljs">component.items = [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span> }]; <span class="hljs-comment"><span class="hljs-comment">//  ,     // expect(component.querySelectorAll(".item")).toHaveLength(1); await delay(); //      expect(component.querySelectorAll(".item")).toHaveLength(1);</span></span></code> </pre> <br><p>  Thus, the implementation of the correct component update is another argument for using the framework instead of working with web components directly. </p><br><h2 id="vyvody">  findings </h2><br><p>  After reading this article, it may seem that the web components are bad and they have no future.  This is not entirely true; they can come in handy in some use cases: </p><br><ul><li>  Embedding client logic in a large server-render project.  This is the path now under Github.  They actively use web components for their interface and even <a href="https://github.com/search%3Fq%3Dtopic%253Aweb-components%2Borg%253Agithub%2Bfork%253Atrue">published</a> some of them <a href="https://github.com/search%3Fq%3Dtopic%253Aweb-components%2Borg%253Agithub%2Bfork%253Atrue">in open-source</a> .  In a situation where you have most of the page static or rendered by the server, web components will help to give interactivity to some parts. </li><li>  Implementation of <a href="https://medium.com/%40tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16">micro-frontend</a> .  The page renders independent widgets that can be written in completely different frameworks and different teams, but they need to somehow get along together.  In doing so, they dump their CSS into a global area and interfere with each other in every way.  To combat this, we used to have only iframe, but now we can turn individual micro-frontends into the Shadow DOM, so that they live their lives there. </li></ul><br><p>  There are also things that I would not do on the web components: </p><br><ul><li>  The UI library will be inconvenient due to problems with tree-shaking and the types that are covered in this article.  Writing UI components (buttons, inputs, etc.) on the same framework as the main part of the page (React, Vue, etc.) will allow them to better interact with the main part of the page. </li><li>  For basic content pages, web components will not work.  From the user's point of view, rendering a page with a single <code>&lt;my-app /&gt;</code> web component is no different from using a SPA framework.  The user will have to wait until all the Javascript is uploaded to finally see the content.  And if in the case of Angular / React / Vue, this can be accelerated by pre-rendering the page on the server, then in the case of web components there are no such possibilities. </li><li>  Encapsulating parts of your code into web components also makes no sense.  You will get performance problems, lack of types and no special advantages in return. </li></ul><br><p>  I hope this information will be useful to you when choosing a technology stack this year.  I will be glad to hear what you think about it. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/443032/">https://habr.com/ru/post/443032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443018/index.html">Microsoft has opened the Windows Calculator code</a></li>
<li><a href="../443022/index.html">Rosserial & STM32</a></li>
<li><a href="../443024/index.html">ITMO University Digest: 12 thematic conferences, hackathons and MOOC courses for IT students</a></li>
<li><a href="../443026/index.html">Access control and what it eats</a></li>
<li><a href="../443030/index.html">Simplest memory profiling on STM32 and other microcontrollers</a></li>
<li><a href="../443034/index.html">New charging stations from Tesla: charge the battery for 120 km of course for 5 minutes</a></li>
<li><a href="../443038/index.html">If superglue hit the eye</a></li>
<li><a href="../443040/index.html">7 main reasons why they block applications in Google Play and AppStore</a></li>
<li><a href="../443042/index.html">Running 619 thousand tetrises on GLSL, their rendering and a simple bot</a></li>
<li><a href="../443044/index.html">ProtonMail received 2 million euros for the development of its ecosystem from the EU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>