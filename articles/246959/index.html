<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding Flux, reactive architecture from facebook</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Welcome to Part Three of the Study React series. Today, we will explore how Facebook Flux architecture works and how to use it in our p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding Flux, reactive architecture from facebook</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/617/98e/399/61798e399d0b461689c070f5c8b66ca3.png"><br><br><h2>  Introduction </h2><br>  Welcome to Part Three of the Study React series.  Today, we will explore how Facebook Flux architecture works and how to use it in our projects. <br><a name="habracut"></a><br>  First of all, I advise you to read the first two articles in this series, <a href="http://scotch.io/tutorials/javascript/learning-react-getting-started-and-concepts">Getting Started &amp; Concepts</a> and <a href="http://scotch.io/tutorials/javascript/build-a-real-time-twitter-stream-with-node-and-react-js">Building a Real Time Twitter Stream with Node and React</a> .  Reading them is not mandatory, but it can certainly help you understand this article if you are not familiar with React.js. <br><br><h2>  What is flux? </h2><br>  Flux is the architecture that the Facebook team uses when working with React.  This is not a framework or library, it is a new architectural approach that complements React and the principle of a unidirectional data flow. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, Facebook provides a <a href="https://github.com/facebook/flux">repository</a> that contains the Dispatcher implementation.  The dispatcher plays the role of a global intermediary in the Publisher Subscriber template (Pub / sub) and distributes the payload to registered handlers. <br><br>  A typical implementation of the Flux architecture can use this library along with the EventEmitter class from NodeJS to build an event-oriented system that will help manage the state of the application. <br><br>  Flux is probably the easiest to explain, based on its constituent components: <br><ul><li>  Actions / Helpers to simplify the transfer of data to the Manager </li><li>  Dispatcher / Dispatcher - takes Action and sends the load to registered handlers </li><li>  Stores / Storages - containers for application state and business logic in handlers registered in Dispatcher </li><li>  Controller Views / Views - React-components that collect the state of the repositories and pass it to the child components through properties </li></ul><br><br>  Let's see how this process looks like a diagram: <br><img src="https://habrastorage.org/files/4dc/a12/94a/4dca1294a4c34adea48bf8da61e7a692.png"><br><br>  <i>How does the API relate to this?</i> <br><br>  In my opinion, using Actions to transfer data to the Stores through the Flux stream is the least painful way of working with data coming from outside your program or going outside. <br><br><h2>  Dispatcher / Dispatcher </h2><br>  <i>What is a dispatcher?</i> <br><br>  In essence, the Dispatcher is the manager of the whole process.  This is the central hub of your application.  The dispatcher receives the action as input and sends these actions (and associated data) to registered handlers. <br><br>  <i>So is this really pub / sub?</i> <br><br>  Not really.  The dispatcher sends data to ALL processors registered in it and allows you to call handlers in a specific order, even wait for updates before continuing.  There is only one Dispatcher, and it acts as the central hub of your entire application. <br><br>  Here is what it might look like: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Dispatcher = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'flux'</span></span>).Dispatcher; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AppDispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dispatcher(); AppDispatcher.handleViewAction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dispatch({ <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'VIEW_ACTION'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: action }); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = AppDispatcher;</code> </pre> <br>  In the example above, we create an instance of the Manager and the handleViewAction method.  This abstraction is useful if you are going to separate the actions created in the interface and the actions that came from the server / API. <br><br>  Our method calls the dispatch method, which already sends action data to all handlers registered in it.  This action can then be processed by the Storages, as a result of which the state of the application will be updated. <br><br>  The following diagram illustrates this process: <br><img src="https://habrastorage.org/files/541/299/a87/541299a87d744ddea655e9907d7961d1.png"><br><br><h3>  Dependencies </h3><br>  One of the nice details of the described implementation of the Controller is the ability to describe dependencies and control the order of execution of handlers in the Storages.  So, if for correct state display one of the application components depends on another one, which must be updated before it, the waitFor Dispatcher method is useful. <br><br>  To use this feature, you need to store the value returned from the registration method in the Manager in the store's DispatcherIndex property, as shown below: <br><br><pre> <code class="javascript hljs">ShoeStore.dispatcherIndex = AppDispatcher.register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function">) </span></span>{ });</code> </pre><br>  Then, in the Storage, when processing the Action, we can use the waitFor method of the Manager to make sure that by this moment ShoeStore has already managed to process the Action and update the data: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'BUY_SHOES'</span></span>: AppDispatcher.waitFor([ ShoeStore.dispatcherIndex ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ CheckoutStore.purchaseShoes(ShoeStore.getSelectedShoes()); }); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  <i>Note</i>  <i>Lane: Ken Wheeler, obviously, describes an outdated implementation of the Manager, since the waitFor method <a href="https://github.com/facebook/flux/commit/6ff67ee6d99970def23399e44e0856f3b778a819">has a different signature</a> in the current version.</i> <br><br><h2>  Stores / Storages </h2><br>  Flux repositories control the state of certain parts of the application domain.  At a higher level, this means that the Stores store data, methods for obtaining this data, and Action handlers registered in the Manager. <br><br>  Let's take a look at simple storage: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AppDispatcher = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../dispatcher/AppDispatcher'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShoeConstants = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../constants/ShoeConstants'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'react/lib/merge'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     shoes var _shoes = {}; //    shoes    function loadShoes(data) { _shoes = data.shoes; } //   Event Emitter  Node var ShoeStore = merge(EventEmitter.prototype, { //   shoes getShoes: function() { return _shoes; }, emitChange: function() { this.emit('change'); }, addChangeListener: function(callback) { this.on('change', callback); }, removeChangeListener: function(callback) { this.removeListener('change', callback); } }); //     AppDispatcher.register(function(payload) { var action = payload.action; var text; //        switch(action.actionType) { case ShoeConstants.LOAD_SHOES: //        loadShoes(action.data); break; default: return true; } //    ,   "change" ShoeStore.emitChange(); return true; }); module.exports = ShoeStore;</span></span></code> </pre><br>  The most important thing we did in the example above was that we added EventEmitter from NodeJS to our repository.  This allows repositories to listen and send events, which, in turn, allows the components of the view to be updated based on these events.  Since our view listens to the ‚Äúchange‚Äù event created by the Vaults, it learns that the state of the application has changed, and it's time to get (and display) the current state. <br><br>  We also registered the handler in our AppDispatcher using its register method.  This means that now our Vault now listens to alerts from AppDispatcher.  Based on the data received, the switch statement decides whether we can process the Action.  If the action has been processed, a ‚Äúchange‚Äù event is created, and Views that subscribe to this event react to it by updating their state: <br><img src="https://habrastorage.org/files/e4c/e7a/a88/e4ce7aa881f94a549a3b6c987d4e3e1c.png"><br><br>  The view uses the Store interface's getShoes method to get all the shoes from the _shoes internal object and pass this data to the components.  This is a very simple example; however, this architecture allows components to remain fairly accurate, even if instead of Views you use more complex logic. <br><br><h2>  Action Creators &amp; Actions / Factory Actions and Actions </h2><br>  An Action Factory is a set of methods that are called from Views (or from any other place) to send Actions to the Dispatcher.  Actions are the payload that the Dispatcher sends to subscribers. <br><br>  In the Facebook implementation, Actions differ in type ‚Äî a constant that is sent along with the action data.  Depending on the type, Actions can be appropriately processed in registered handlers, and the data from these Actions are used as arguments to internal methods. <br><br>  Here are the constant declarations: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyMirror = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'react/lib/keyMirror'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = keyMirror({ <span class="hljs-attr"><span class="hljs-attr">LOAD_SHOES</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> });</code> </pre><br>  Above, we used the keyMirror library from React to, as you guessed, create an object with values ‚Äã‚Äãidentical to its keys.  Just by looking at this file, you can say that our application can download shoes.  Using constants allows you to streamline everything and helps you quickly assess the capabilities of the application. <br><br>  Let's now look at the announcement of the relevant Action Factory: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AppDispatcher = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../dispatcher/AppDispatcher'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShoeStoreConstants = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../constants/ShoeStoreConstants'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShoeStoreActions = { <span class="hljs-attr"><span class="hljs-attr">loadShoes</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ AppDispatcher.handleAction({ <span class="hljs-attr"><span class="hljs-attr">actionType</span></span>: ShoeStoreConstants.LOAD_SHOES, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: data }) } }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = ShoeStoreActions;</code> </pre><br>  In the example above, we created a method in our object, ShoeStoreActions, that passes this data to our Manager.  Now we can load this file from our API (or, for example, Views) and call the ShoeStoreActions.loadShoes (ourData) method to transfer the payload to the Dispatcher, which will send it to subscribers.  Thus, ShoeStore will know about this event and will call the boot method of some shoes. <br><br><h2>  Controller Views / Views </h2><br>  Views are just React components that subscribe to the ‚Äúchange‚Äù event and get the state of the application from the Repositories.  Then they pass this data to the child components through properties. <br><br><img src="https://habrastorage.org/files/243/482/42a/24348242a38041e88a1a6ce159579292.png"><br>  Here is what it looks like: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** @jsx React.DOM */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'react'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShoesStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../stores/ShoeStore'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        function getAppState() { return { shoes: ShoeStore.getShoes() }; } //  React- var ShoeStoreApp = React.createClass({ //   getAppState,     getInitialState: function() { return getAppState(); }, //    componentDidMount: function() { ShoeStore.addChangeListener(this._onChange); }, //    componentWillUnmount: function() { ShoesStore.removeChangeListener(this._onChange); }, render: function() { return ( &lt;ShoeStore shoes={this.state.shoes} /&gt; ); }, //        "change" _onChange: function() { this.setState(getAppState()); } }); module.exports = ShoeStoreApp;</span></span></code> </pre><br>  <i>Note</i>  <i>Trans .: In the current version of React, components are created <a href="https://gist.github.com/sebmarkbage/d7bce729f38730399d28">slightly differently</a> .</i> <br><br>  In the example above, we subscribe to the Storage updates using addChangeListener and update our state when we receive the "change" event. <br><br>  The state of the application is stored in our Storages, so we use the Storages interface to get this data and then update the state of the components. <br><br><h2>  Putting it all together </h2><br>  Now that we have walked through all the main parts of the Flux architecture, we better understand how this architecture really works.  Remember our process diagram from the beginning of the article?  Let's take a closer look at them, as we now understand the functions of each part of the stream: <br><br><img src="https://habrastorage.org/files/020/8b8/e50/0208b8e50e8d40eeb8d4db589b7c5869.png"><br><br><h2>  Conclusion </h2><br>  Hope this article has helped you better understand the Flux architecture from Facebook.  I didn‚Äôt even know how comfortable React.js was until I tried it in action. <br><br>  Having once used Flux, you will feel that writing applications on React without Flux is similar to manipulating DOM without jQuery.  Yes, it is possible, but it looks less elegant and orderly. <br><br>  If you want to stick with the Flux architecture, but you don‚Äôt like React, try <a href="https://github.com/deloreanjs/delorean">Delorean</a> , a Flux framework that can be combined with Ractive.js or Flight.  Another noteworthy library is <a href="http://fluxxor.com/">Fluxxor</a> , which uses a slightly different approach to the Flux architecture and implies a more rigid connection of the Flux components in a single instance. <br><br>  I believe that in order to fully understand Flux, it must be tested in action, so stay with us to read the <a href="https://scotch.io/tutorials/creating-a-simple-shopping-cart-with-react-js-and-flux">fourth</a> , final part of a series of articles on learning React, where we will create a simple online store using React.js and Flux architecture . </div><p>Source: <a href="https://habr.com/ru/post/246959/">https://habr.com/ru/post/246959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246947/index.html">Creating a synchronization barrier using C ++ 11</a></li>
<li><a href="../246951/index.html">Playing with genetic algorithms</a></li>
<li><a href="../246953/index.html">Why does OpenVPN slow down?</a></li>
<li><a href="../246955/index.html">FLProg and penguins</a></li>
<li><a href="../246957/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ140 (December 22 - 28, 2014)</a></li>
<li><a href="../246961/index.html">Really transparent WCF usage</a></li>
<li><a href="../246963/index.html">About the diagonal of the square</a></li>
<li><a href="../246965/index.html">Functional programming in Swift. Start</a></li>
<li><a href="../246967/index.html">Happy New Year!</a></li>
<li><a href="../246969/index.html">When technology outpaces needs: how did they think about IT development in 1985</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>