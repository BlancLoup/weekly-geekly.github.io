<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FTP protocol + WinSocks on the example of a simple FTP client (mirror) on ASM!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is another article "walking for a long time" on the Internet, and again, as the author, I will make a repost. I think it is useful here. 

 Intro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FTP protocol + WinSocks on the example of a simple FTP client (mirror) on ASM!</h1><div class="post__text post__text-html js-mediator-article">  This is another article "walking for a long time" on the Internet, and again, as the author, I will make a repost.  I think it is useful here. <br><br><h5>  Introduction </h5><br><br>  In this article, I do not set myself the goal of retelling all the RFCs related to the FTP protocol, of which there are not a few, you can find much more information in them, I will try only in general terms to introduce you to the FTP protocol and the basic techniques for working with it from the client. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  FTP Protocol Overview </h5><br><br>  So, FTP (File Transfer Protocol) is a file transfer protocol in TCP / IP networks.  This protocol was specifically created to facilitate and standardize the programming of file transfer algorithms between the client and the server.  Like all high-level protocols, it does not deal with direct data transmission (the lower-level protocol, TCP, and the protocols below, does this), but only describes the client-server ‚Äúcommunication‚Äù method. <br><br>  Let us proceed directly to the description of the protocol.  Its distinctive feature is the use of two connections between the server and the client.  One connection (command or control) is used to send commands to the server, as well as receive responses to these commands.  The second connection (data connection) is used directly for receiving or transmitting data.  The control connection is always from the client to the server port 21 and remains open throughout the entire session.  A data connection is opened and closed as necessary to receive or receive data. <br><br>  After the control connection is established, the client can send various commands to the server via it.  Each command consists of 3 or 4 ASCII capital characters, followed by one or more spaces followed, some of the commands are not required arguments.  Any command ends with a pair of CR, LF - this is undoubtedly known to all 0dh, 0ah - if we are talking about DOS / Windows.  In general, the command diagram is as follows: <br><br>  <b>Command [argument (s)] CR, LF.</b> <br><br>  In total, there are just over 30 commands (in RFC959 - 33) that can be sent to the server, but this does not mean that the server will support them all.  I will give an example of the most frequently used commands. <br><br>  <b>USER username</b> <br>  Specifies username <br><br>  <b>Pass password</b> <br>  Specifies user password <br><br>  <b>LIST file list</b> <br>  File List Request <br><br>  <b>PORT n1, n2, n3, n4, n5, n6</b> <br>  Specify IP and port for data connection <br><br>  <b>RETR file name</b> <br>  Get file from server <br><br>  <b>STOR file name</b> <br>  Put file on server <br><br>  <b>TYPE type</b> <br>  Type of data transmitted <br><br>  <b>Quit</b> <br>  Disconnect from server <br><br>  <b>Abor</b> <br>  Cancel previous command.  Termination of data transfer. <br><br><br>  When a server receives a request, it sends a response to it via the same control connection.  The server response consists of three characters (numbers) in ASCII format, followed by a non-mandatory text, usually explaining the digital code of the response, followed by the constant CR, LF.  For example, the answer may be: 226 File send OK.  - in this example, the server informs us that the file was sent on its part (which does not mean at all that it has already been received from the client).  The first digit of the server's response is the most significant, and gives an unambiguous idea of ‚Äã‚Äãhow the command was executed (or failed).  Values ‚Äã‚Äãcan be: <br><br><ul><li>  <b>1xx</b> The command is in progress, you must wait for another message before giving the next command. </li><li>  <b>2xx</b> Command completed.  The server is waiting for the next one. </li><li>  <b>3xx</b> The command is completed, but one more command is needed to continue. </li><li>  <b>4xx</b> The command was not executed, you must wait and repeat the command </li><li>  <b>5xx</b> The command was not executed and will not be executed during the repetition. </li></ul><br><br><br>  According to the second digit of the response, it is possible to judge which situation led to the emergence of the response: <br><br><ul><li>  <b>x0x Syntax</b> error. </li><li>  <b>x1x</b> Information. </li><li>  <b>x2x</b> Response refers to the state of the controller or data connection. </li><li>  <b>x3x</b> Response refers to user authentication or budget status. </li><li>  <b>x4x</b> Not defined. </li><li>  <b>x5x</b> Response refers to the state of the file system. </li></ul><br><br>  Finally, the third digit of the response carries additional information. <br><br>  Special attention should be paid to the fact that although the server responds to most commands with one response, there are commands that are widely used, in response to which the server generates several responses.  The first digit of the first response will be ‚Äú1‚Äù - i.e.  If you look at the tables above, the server tells us that you need to wait for another message from it before sending the next command.  An example of such a command is the RETR command, when the server accepts it and starts sending data, it answers us something like: ‚Äú150 Opening BINARY mode data connection for HIDE.ASM (958 bytes).‚Äù - the meaning of the message is reduced to ‚Äúdata transfer started ".  Then, when the data has already been sent to them (but again I want to focus attention - not the fact that they were received by the client), he will send another response via the control connection - ‚Äú226 File send OK.‚Äù - i.e.  "File sent".  In this case, only after receiving the second message, the server is ready for the next command.  Instead of the last message, we may well receive a message with an error starting with ‚Äú4‚Äù - in the event that there are any problems with the transfer of the file. <br><br>  In general terms, this is all about the control connection. <br><br>  Now let's talk about the data connection.  As mentioned above, the data connection is organized as needed, and is closed every time after sending or receiving data.  This happens because the data transfer mode between the client and the server is streaming, and in this mode, the end of the data transfer is closing the connection.  From the above, we have to draw one important conclusion - we can judge the end of data transfer from the server side by closing the connection. <br><br>  Typically, a data connection is opened as follows: <br><br><ul><li>  the client selects a free port on his host and performs a passive opening on it; </li><li>  the client informs the server via the control connection its IP address and the port number to which it has made a passive discovery; </li><li>  the server, having received a port and an IP address, is actively opening it; </li><li>  data is transmitted or received; </li><li>  depending on who sends and who receives data, the port is closed. </li></ul><br><br>  A small digression: if you carefully read the second paragraph, the question may arise - ‚ÄúWhat will happen if we give the server a fictitious address and port?‚Äù.  The answer is ambiguous, the server can check the IP address, but this does not always happen, so there are some interesting ‚Äúproblems‚Äù with the use of fictitious addresses. <br><br>  Regarding the port chosen for the data connection by the client.  Usually a dynamically assigned OS port is used, i.e.  a request is made to the system, it gives the first free one.  If the client does not indicate to the server the port for the connection, it occurs on the port from which the control connection was made (this is not recommended).  The server always connects data from port 20. <br><br>  This is all the main thing that I wanted to talk about the data connection. <br><br>  Now, when we know why and how both connections work, I want to note one more thing (you can skip it when you first read it).  The LIST command returns a list of files in the current directory, and returns it by data connection.  The list is a set of ASCII strings ending in CR, LF.  Each line carries information about one of the elements of the requested catalog.  The general pattern of this line is: <br><br>  <b>Txxxxxxxxx [] uk [] user [] group [] size [] mm [] dd [] yytt [] name CR, LF</b> <br><br>  Where, <br><br>  <b>T</b> - type of element (‚Äúd‚Äù - directory, ‚Äú-‚Äù - file, ‚Äúl‚Äù - link, etc.); <br>  <b>xxxxxxxxx</b> - file protection attributes; <br>  <b>user</b> - the user, the owner of the file; <br>  <b>group</b> - owner group; <br>  <b>size</b> - the size of the element; <br>  <b>mm</b> is the month when the element was created in text form, for example, ‚Äújul‚Äù; <br>  <b>dd</b> - the day of the month the item was created; <br>  <b>yytt</b> - here can be the year or the time of the element creation; <br>  <b>name</b> - the name of the element (file, directory, links); <br>  <b>[]</b> - one or more spaces. <br><br>  Yes, between these elements there can be a different number of spaces, I must say thank you, that in different server implementations they left one number of significant columns, so this should be taken into account when analyzing the file table.  It is necessary to take into account such a thing, that not always the first row from the table is a significant row that carries information about the first element of the catalog.  In some implementations of FTP servers (for example, ftpd on FreeBSD), the first line of the list is ‚Äútotal NN‚Äù. <br><br><h5>  How should this work? </h5><br><br>  Let's digress a bit and see how an FTP session should look like getting a file ‚Äúfrom the inside‚Äù.  So, we run the client.  The server at this time already passively opened and listens to the 21st port.  First of all, we need to create a control connection - go to the server on port 21. What next?  Immediately, as soon as we successfully connected with the server via the created control connection, we received a greeting from the server, it would be something like ‚Äú220 VSFTP deamon base on Alt Linux 2.2, Shpakovsky‚Äù. <br><br>  The next step should be registration - let's say we are connecting to an anonymous server - the client sends the USER anonymous command to the server via the control connection, so if the server supports the anonymous user we get the answer: ‚Äú331 Please specify the password.‚Äù - ‚Äúplease provide the password‚Äù, note the number ‚Äú3‚Äù in the server's response, which means that a command is required to continue, which the client actually does ‚Äî send the command PASS 1 @ 1 ‚Äî specifying a fictitious e-mail as the password.  What we get the server response ‚Äú230 Login successful.  Have fun. ‚Äù-‚Äú Registration was successful. ‚Äù <br><br>  Everything, now our actions depend on what we want, and as mentioned above, we want to get a file from the server, even if for example it is the file ‚ÄúHIDE.EXE‚Äù located in the root directory of the server.  Before receiving or transmitting data to the server, you must specify what type of data will be transmitted, this is done with the command TYPE N, where N = ‚ÄúA‚Äù if the type is ASCII and N = ‚ÄúI‚Äù if the file is binary.  The client sends the TYPE I command to the server, for which he receives the answer - ‚Äú200 Switching to Binary mode.‚Äù. <br><br>  So, it remains only to get the file.  To do this, the client must open a data connection.  A free port is selected by the client, passive opening is performed, i.e.  the client listens to him.  Next, the client needs to inform the server of its IP address and the port number that it has just passively opened (assume the client's IP address is 10.21.23.10, and the port number is 2000).  The client sends the command PORT 10,21,23,10,7,208 to the server on the control connection - ‚Äúwhat is 7,208?‚Äù - you ask.  This is the port number it is built like this - 7 * 256 + 208 = 2000. After receiving this command, the server will try to make an active opening of the specified port and in case of success it will return something like ‚Äú200 PORT command successful.  Consider using PASV. ‚Äù. <br><br>  Everything, the data connection is established, it is necessary to give the command to transfer the data to the server, which is what the client does - RETR HIDE.EXE, and in case everything is normal (the file exists and can be transferred) the server replies "150 Opening BINARY mode data connection for HIDE.EXE (4096 bytes). ‚ÄùAnd begins to merge the file at the data connection.  Again I draw your attention to the first digit of the answer.  When the file is completely sent, the server will send the message ‚Äú226 File send OK.‚Äù And close the data connection. <br><br>  The client waits for the data to be received on its part (as evidenced by receiving a message from the server + closing the data connection, there are some nuances, but about them later) and then closes the data connection port on its part. <br><br>  So the file is received by the client, it remains to break the control connection, the client sends the QUIT command, the server responds with ‚Äú221 Goodbye.‚Äù And terminates the connection. <br><br>  This is actually the most important theoretical information about the protocol.  Before proceeding to practice, I strongly advise you to indulge in managing the connection to the FTP server using telnet, you will not be able to create a data connection, but the commands and responses to them will be visible.  I also recommend working with any console FTP client and watching all this while creating and closing connections using any utility for this, which is like dirt on the Internet. <br><br><h5>  Implementation. </h5><br><br>  Now about the implementation itself.  In this client implementation, I use non-blocking (non-blocking) sockets, so the client model is event-driven, i.e.  perform any actions related to the sockets used by the client, the client will be available only when a corresponding event occurs (for example, closing a connection, notifying on receiving data, etc.).  The events used are messages that come into the main window procedure.  In addition, the program model is stream, it uses a stream to read the data connection and a stream to read the control connection, as well as the main client thread, which starts when you click on the "connection" button.  Since the program is multi-threaded to synchronize the operation of these three streams (as well as the message procedures of the main window), ‚Äúevent's‚Äù are used (‚Äúevents‚Äù, do not confuse these events used by the program as sensor 1 or 0 - an event has occurred or has not occurred sockets that come to the main window procedure). <br><br>  So, let's begin.  When creating the main application window, we carry out the main initialization of the program, I will explain the main points: <br><br> <code>call VirtualAlloc,ebx,1024000,MEM_COMMIT+MEM_RESERVE,PAGE_READWRITE <br> mov ReciveDataBufferOffset,eax <br> call VirtualAlloc,ebx,10240,MEM_COMMIT+MEM_RESERVE,PAGE_READWRITE <br> mov ReciveCommandBufferOffset,eax <br>        (1 )     (10 ). <br> <br> call CreateEventA,ebx,ebx,ebx,ebx <br> mov HDataReciveEvent,eax <br> ‚Ä¶‚Ä¶ <br>   event ()      . <br> <br> call CreateThread,ebx,ebx,offset ReciveThread,offset ReciveDataThreadStruc, \ <br> NORMAL_PRIORITY_CLASS,offset ThreadID_data <br> call CreateThread,ebx,ebx,offset ReciveThread,offset ReciveCommandThreadStruc,\ <br> NORMAL_PRIORITY_CLASS,offset ThreadID_command <br>  2  ‚Äì    ,     .         ,        . <br> <br> call gethostname, offset HostName,64 <br> call gethostbyname,offset HostName <br> ‚Ä¶.. <br> mov PortInPort,esi <br> ret 0</code> <br> <br>  The meaning of the lines above is in obtaining the IP address of our host, a small conversion and writing it to a separate place; we will need the address of the host to execute the PORT command. <br><br>  At this point, the initial initialization process ends, and the program is in a state of waiting for a user command.  Let's see what happens when the user clicks the "connect" button. <br><br>  In the main window procedure, the main flow of the application is created, we consider its key points. <br><br>  Right at the start, we initialize the variables related to receiving data and get the connection parameters entered by the user (server, password, etc.) from the dialog window.  After that, we need to create a controlling connection to the server, which we do: <br><br> <code>-  ; <br> call socket, AF_INET, SOCK_STREAM, IPPROTO_TCP <br> mov ReciveCommandSock,eax <br> -     ,     <br>       ,       <br> . <br> call WSAAsyncSelect, ReciveCommandSock, newhwnd, WM_COMMANDSOCK,FD_READ+FD_CONNECT <br> -          <br> ‚Ä¶.. <br> call connect,ReciveCommandSock,offset sockaddr_in,16 <br> -    FD_CONNECT,        <br>    call SetEvent,HWaitConnectEvent  , <br>       ,        <br> 5 ,        . <br> call WaitForSingleObject,HWaitConnectEvent,5000 <br> call ResetEvent,HWaitConnectEvent <br> -         ,    5 <br> ,     - .  WaitAnswerRecive  . <br> call WaitAnswerRecive,5000 <br> or eax,eax <br> jnz errorwithregisration</code> <br> <br>  - the input parameter to the function is the interval during which the function will be <br>  wait for server response, if no response is received for the specified interval, function <br>  displays an error message and terminates with a non-zero value of the eax register. <br><br> <code>WaitAnswerRecive proc TimeToWait:dword <br> call WaitForSingleObject,HWaitCommandEvent,TimeToWait <br> -    HWaitCommandEvent,     <br>     ,     . <br> or eax,eax <br> jz NoTimeOutGet <br> call MessageBoxA,newhwnd,offset ErrTimeOutCommand,offset ErrorCap,40h <br> call ResetEvent,HWaitCommandEvent <br> -   HWaitCommandEvent ..  ,     <br>  . <br> NoTimeOutGet: <br> ret <br> WaitAnswerRecive endp</code> <br> <br>  Now it's time to consider the data acquisition flows, as mentioned above, these flows are created during the initialization of the main window, and are constantly in the process of waiting for new data, the flows are activated in the main window procedure when it receives a message that there is new data, a message for the manager we defined the connections at the very beginning of the main thread by the WSAAsyncSelect function; the message for the data connection is defined when creating this connection, as we will see later. <br><br>  Universal trade for obtaining data on the control and data connection is given below. <br><br> <code>-        ReciveDataThreadStruc <br>  ReciveCommandThreadStruc     . <br>   ReciveCommandThreadStruc : <br> -      ; <br> HCommandReciveEvent dd ? <br> -  ,        ; <br> HWaitCommandEvent dd ? <br> -    ; <br> ReciveCommandBufferOffset dd ? <br> -      ; <br> BytesCommandRecived dd 0 <br> -  ,      ; <br> ReciveCommandSock dd ? <br> <br> ReciveThread proc parametr:dword <br> mov edi,parametr <br> InfinityLoop: <br> -   ,    ; <br> call WaitForSingleObject,dword ptr [edi],-1 <br> -  esi  ,     -  + <br>  ; <br> mov esi,[edi+8] <br> add esi,[edi+12] <br> -    4096 ; <br> call recv,dword ptr [edi+16],esi,4096,0 <br> -     ,    ; <br> add [edi+12],eax <br> -  ebx   ,   ,     ; <br> mov ebx,[edi+4] <br> -              <br>    ,  -        <br>  ; <br> cmp edi,offset ReciveDataThreadStruc <br> je comparefordata <br> -             <br> 0dh, 0ah,    ; <br> mov eax,[edi+12] <br> mov esi,[edi+8] <br> cmp byte ptr [esi+eax-1],10 <br> je short CallEvent <br> jmp InfinityLoop <br> comparefordata: <br> -     ,     =  ; <br> mov eax,[edi+12] <br> cmp FileLenght,eax <br> jne InfinityLoop <br> CallEvent: <br> -         ; <br> call SetEvent,ebx <br> jmp InfinityLoop <br> ReciveThread endp</code> <br> <br>  Now back to the main thread, we successfully received a response from the server, that it is ready to receive commands, now we can send commands to it, in this implementation, the SendCommandInSocket function is responsible for sending commands to the server, then we call this function in the main thread to send server sequential commands: USER, PASS, TYPE, CWD, PORT and LIST.  The function itself looks like this: <br><br> <code>-   ,     ,    , <br>    ; <br> SendCommandInSocket proc uses ebx ecx esi edi, hSocket:dword, OutBufOffset:dword <br> -    ; <br> mov edi,OutBufOffset <br> push edi <br> mov eax,0ah <br> mov ecx,100 <br> repne scasb <br> sub edi,OutBufOffset <br> mov ecx,edi <br> pop esi <br> push edi <br> -         ,    , <br>           ; <br> mov edi,ReciveCommandBufferOffset <br> add edi,BytesCommandRecived <br> rep movsb <br> pop edi <br> add BytesCommandRecived,edi <br> -    ; <br> call send,hSocket,OutBufOffset,edi,ebx <br> -   ,       WaitAnswerRecive; <br> mov eax,5001 <br> Wait2Answer: <br> dec eax <br> push eax <br> call WaitAnswerRecive <br> or eax,eax <br> jnz ErrorProcessed <br> -  ,    ,   ,     <br>      , ,    <br>            . <br>    . <br> mov edi,ReciveCommandBufferOffset <br> mov ecx,BytesCommandRecived <br> dec ecx <br> dec ecx <br> add edi,ecx <br> mov al,0ah <br> std <br> repne scasb <br> cld <br> xor eax,eax <br> -    ; <br> mov cl,[edi+2] <br> cmp cl,'1' <br> -   "1"        <br> jz Wait2Answer <br> cmp cl,'3' <br> -    "3" -  ; <br> jna NoErrorProcessed <br> call MessageBoxA,newhwnd,edi,offset ErrorCap,40h <br> ErrorProcessed: <br> xor eax,eax <br> inc eax <br> NoErrorProcessed: <br> ret <br> SendCommandInSocket endp</code> <br> <br>  There is one more thing to consider - before sending the PORT command, we need to create a listening socket, we do this by calling the CreateListenSock procedure. <br><br> <code>CreateListenSock proc <br> pushad <br> -  ; <br> call socket, AF_INET, SOCK_STREAM, IPPROTO_TCP <br> mov datasock,eax <br> -    - , ,      <br>        ,   <br>  ,    ; <br> call WSAAsyncSelect, datasock, newhwnd, WM_DATASOCK, FD_ACCEPT+FD_READ+FD_CLOSE <br> -     ; <br> mov sin_port,0 ;  ,       <br> ;    <br> mov sin_family,AF_INET <br> mov sin_addr,INADDR_ANY <br> call bind, datasock, offset sockaddr_in, 16 <br> -    ; <br> call getsockname,datasock,offset sockaddr_in,offset szSockaddr_in <br> -      ; <br> xor eax,eax <br> mov ax,sin_port <br> call ntohs,eax <br> push eax <br> shr eax,8 <br> -       ASCII; <br> call DECtoASCII,eax,PortInPort <br> -       PORT <br> mov al,',' <br> stosb <br> pop eax <br> and eax,0ffh <br> call DECtoASCII,eax,edi <br> mov ax,0a0dh <br> stosw <br> mov esi,PortInPort <br> -  ; <br> call listen, datasock, 1 <br> popad <br> ret <br> CreateListenSock endp</code> <br> <br>  So the last command sent was the LIST command, after it a list of files of the current directory should come to the data connection, so after sending the message we need to wait until we receive this list, because  even if the server sent us a message stating that it had successfully completed the sending of all data, this does not at all mean that our stream has already completed and received everything, so we expect the receive to be completed by the WaitTransferComplete function. <br><br> <code>-             <br> ,  ,       . <br> WaitTransferComplete proc uses ecx edi, TimeToWaitEndTransfer:dword <br> WaitProgress: <br> -        ,   <br>    ; <br> call WaitForSingleObject,HWaitCloseEvent,-1 <br> -  ,      ,     <br> ; <br> call WaitForSingleObject,HWaitDataEvent,TimeToWaitEndTransfer <br> or eax,eax <br> jz CloseDataSocks <br> -  ,     ,    , ..   <br>     , ,        <br>          ; <br> cmp TimeToWaitEndTransfer,1000 ;   <br> jz CloseDataSocks <br> call MessageBoxA,newhwnd,offset ErrTimeOutCommand,offset ErrorCap,40h <br> <br> CloseDataSocks: <br> -    ; <br> call ResetEvent,HWaitDataEvent <br> -     ; <br> call closesocket,ReciveDataSock <br> call closesocket,datasock <br> ret <br> WaitTransferComplete endp</code> <br> <br>  In case of successful completion of the procedure above, the directory table will be in the data receive buffer.  Below the program, we process the resulting table and in turn get all the files found in it, getting the file is no different from getting the directory, so here I will not describe this.  After all the files have been received and saved, we close the control connection and end the stream. <br><br><h5>  Conclusion </h5><br><br>  We discussed the basic principles of working with the FTP protocol from the client, of course, not all aspects of this task were touched upon.  For example, sending files to the server was not considered, but I think, having carefully studied the material above, as well as the accompanying source code, you can do this without any problems, let the further study of the FTP protocol from the server side be your ‚Äúhomework‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/111241/">https://habr.com/ru/post/111241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111233/index.html">Increase the search capabilities of genetic algorithms using time series prediction</a></li>
<li><a href="../111236/index.html">Drag & Drop between TreePanel and GridPanel in ExtJS</a></li>
<li><a href="../111237/index.html">Modeling in ns-2. Approximate 802.11b wireless network bandwidth to real</a></li>
<li><a href="../111238/index.html">[Programming] Working with the status bar in Android</a></li>
<li><a href="../111239/index.html">Working with sockets in Qt</a></li>
<li><a href="../111242/index.html">Symfony Code'n'Coffee Minsk (Belarus) Jan 2011</a></li>
<li><a href="../111243/index.html">Evernote: 2010 in numbers</a></li>
<li><a href="../111244/index.html">Pro Video Compression - Introduction</a></li>
<li><a href="../111246/index.html">Lab DC power supply from power supply</a></li>
<li><a href="../111249/index.html">Video hosting with their own hands</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>