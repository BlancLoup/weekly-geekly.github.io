<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C # string comparison (default)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It often happens that we combine 2 collections or group a collection using LINQ to Objects . When this happens, the keys selected for grouping or bind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C # string comparison (default)</h1><div class="post__text post__text-html js-mediator-article">  It often happens that we combine 2 collections or group a collection using <a href="https://msdn.microsoft.com/en-us/library/bb397919.aspx">LINQ to Objects</a> .  When this happens, the keys selected for grouping or binding are compared. <br>  Fortunately, the cost of these operations is O (n).  But in the case of large collections, the effectiveness of the comparison itself is important to us.  If strings are selected as keys, which of the comparison implementations will be used by default, is this implementation suitable for your strings, and can you <a href="https://msdn.microsoft.com/en-us/library/bb549267(v%3Dvs.110).aspx">specify the IEqualityComparer &lt;string&gt; explicitly</a> to make this operation faster? <br><pre><code class="cs hljs">clients.Join(orders, c =&gt; c.Name, o =&gt; o.ClientName, (c, o) =&gt; CreateOrederDto(c, o));</code> </pre> <br>  How is the implementation of the comparator chosen, if the user does not explicitly specify it? <br><a name="habracut"></a><br>  In the <a href="">source code of the Join method,</a> you can see the following behavior: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; resultSelector) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"outer"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inner == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"inner"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outerKeySelector == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"outerKeySelector"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerKeySelector == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"innerKeySelector"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultSelector == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.ArgumentNull(<span class="hljs-string"><span class="hljs-string">"resultSelector"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JoinIterator&lt;TOuter, TInner, TKey, TResult&gt;(outer, inner, outerKeySelector, innerKeySelector, resultSelector, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;TResult&gt; JoinIterator&lt;TOuter, TInner, TKey, TResult&gt;(IEnumerable&lt;TOuter&gt; outer, IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter, TKey&gt; outerKeySelector, Func&lt;TInner, TKey&gt; innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; resultSelector, IEqualityComparer&lt;TKey&gt; comparer) { Lookup&lt;TKey, TInner&gt; lookup = Lookup&lt;TKey, TInner&gt;.CreateForJoin(inner, innerKeySelector, comparer); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TOuter item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> outer) { Lookup&lt;TKey, TInner&gt;.Grouping g = lookup.GetGrouping(outerKeySelector(item), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; g.count; i++) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resultSelector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item, g.elements[i]</span></span></span><span class="hljs-function">)</span></span>; } } } }</code> </pre><br>  Well, null is passed to the JoinIterator method, there are no checks inside, and the null value is passed as a parameter when the Lookup is created to the CreateForJoin method. <br><br>  <i>Using <a href="https://msdn.microsoft.com/en-us/library/bb460184(v%3Dvs.110).aspx">Lookup is</a> rarely found explicitly.</i>  <i>This class is a collection with access to elements by key, and several elements can be stored for each key, and in the case of an attempt to access by a non-existing key, an <a href="https://msdn.microsoft.com/en-us/library/bb292716(v%3Dvs.110).aspx">empty collection will</a> simply be <a href="https://msdn.microsoft.com/en-us/library/bb292716(v%3Dvs.110).aspx">returned</a> .</i> <br><br>  We are interested in the <a href="">CreateForJoin</a> method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Lookup&lt;TKey, TElement&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateForJoin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;TElement&gt; source, Func&lt;TElement, TKey&gt; keySelector, IEqualityComparer&lt;TKey&gt; comparer</span></span></span><span class="hljs-function">)</span></span> { Lookup&lt;TKey, TElement&gt; lookup = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lookup&lt;TKey, TElement&gt;(comparer); ... } Lookup(IEqualityComparer&lt;TKey&gt; comparer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comparer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) comparer = EqualityComparer&lt;TKey&gt;.Default; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer = comparer; groupings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grouping[<span class="hljs-number"><span class="hljs-number">7</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 7 -  ,    7 }</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  EqualityComparer </h4><br>  The <a href="https://msdn.microsoft.com/en-us/library/ms132151(v%3Dvs.110).aspx">IEqualityComparer &lt;T&gt; generic</a> interface has a basic implementation as an abstract class <a href="">EqualityComparer &lt;T&gt;</a> , which in turn has the static <a href="https://msdn.microsoft.com/en-us/library/ms224763(v%3Dvs.110).aspx">Default</a> property for selecting the default comparator of a particular class T. That is, for any T, class, structure, or simple type, The current object comparator of this type is selected. <br>  <a href="">The complete selection code</a> depending on the type is rather florid, but interesting from the point of view of understanding the work of our Join and GroupBy. <br><ol><li>  For byte will be selected its own special ByteEqualityComparer.  This class is designed to improve performance when comparing arrays of bytes, because it contains an IndexOf implementation for a byte array. </li><li>  If T implements the IEquatable &lt;T&gt; interface, then a GenericEqualityComparer &lt;T&gt; will be selected, which compares the objects based on a call to their implementations of the IEquatable &lt;T&gt;. Equals (T) method.  In addition, before calling, both parameters will be checked for null inequality. </li><li>  If T is a Nullable &lt;U&gt;, the value of which implements IEquatable &lt;U&gt;, the NullableEqualityComparer &lt;T&gt; class will be used, similar to the previous one and containing additional HasValue checks. </li><li>  For enumerations, depending on the base type, one of the EnumEqualityComparer &lt;T&gt; implementations will be selected (for the long type there is its own special implementation), which differ only in JIT optimizations of how the enumeration value will be reduced to a numeric value. </li><li>  In all other cases, an ObjectEqualityComparer &lt;T&gt; is used, which compares objects based on <a href="https://msdn.microsoft.com/en-us/library/bsc2ak47(v%3Dvs.110).aspx">Object.Equals</a> .  Here, everything is as usual - for reference types, the equality of references is checked, for significant types, the coincidence of object types (in the case of the ObjectEqualityComparer &lt;T&gt; is always true) and the coincidence of the values ‚Äã‚Äãof all object fields. </li></ol><br>  The <a href="https://msdn.microsoft.com/en-us/library/system.string(v%3Dvs.110).aspx">String</a> class implements the IEquatable &lt;T&gt; interface and therefore when comparing strings, the implementation of this interface will be called. <br>  <i>For .NET Core, the implementation of the default selection of a comparator is <a href="">different</a> - in the case of strings, <a href="">EqualityComparerForString</a> will be selected, which uses only the equality operator == when comparing.</i> <br><br><h4>  String comparison </h4><br>  The <a href="">String.Equals (string value)</a> method checks the equality of the string references, the equality of the length of the strings, and if equality is not calculated based on these properties, it causes (almost) a <a href="">byte-by-byte string buffer comparison</a> : <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Security.SecuritySafeCritical</span></span>] <span class="hljs-comment"><span class="hljs-comment">// auto-generated [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] private unsafe static bool EqualsHelper(String strA, String strB) { int length = strA.Length; fixed (char* ap = &amp;strA.m_firstChar) fixed (char* bp = &amp;strB.m_firstChar) { char* a = ap; char* b = bp; //   #if AMD64 //   AMD64   12    3 qword  . while (length &gt;= 12) { if (*(long*)a != *(long*)b) return false; if (*(long*)(a+4) != *(long*)(b+4)) return false; if (*(long*)(a+8) != *(long*)(b+8)) return false; a += 12; b += 12; length -= 12; } #else while (length &gt;= 10) { if (*(int*)a != *(int*)b) return false; if (*(int*)(a+2) != *(int*)(b+2)) return false; if (*(int*)(a+4) != *(int*)(b+4)) return false; if (*(int*)(a+6) != *(int*)(b+6)) return false; if (*(int*)(a+8) != *(int*)(b+8)) return false; a += 10; b += 10; length -= 10; } #endif //          \0 while (length &gt; 0) { if (*(int*)a != *(int*)b) break; a += 2; b += 2; length -= 2; } return (length &lt;= 0); } }</span></span></code> </pre><br>  To improve performance, Microsoft even <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25BC%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2586%25D0%25B8%25D0%25BA%25D0%25BB%25D0%25B0">unwound cycles</a> . <br>  So, <b>by default, byte-by-byte comparison of the contents of these strings is used to compare strings</b> .  Effectively?  Probably.  How else can you compare strings? <br><br><h4>  StringComparer </h4><br>  The String class in .net has its own abstract implementation of the <a href="https://msdn.microsoft.com/en-us/library/system.stringcomparer(v%3Dvs.110).aspx">StringComparer</a> comparator and a number of classes inherited from it, access to instances of which can be obtained through the static properties of this class.  There are 6 implementations of comparing strings of 3 types with and without case-sensitive characters each: <br><ul><li>  CurrentCulture / CurrentCultureIgnoreCase - comparison by words, taking into account the rules of the current culture and language (culture of the current Thread) </li><li>  InvariantCulture / InvariantCultureIgnoreCase - word comparison without taking into account the rules of language and culture and language (used by CultureInfo.InvariantCulture) </li><li>  Ordinal / OrdinalIgnoreCase - byte comparison </li></ul><br>  <i>Since StringComparer implements IEqualityComparer &lt;string&gt;, all its descendants can be specified as a parameter where IEqualityComparer &lt;string&gt; is expected.</i> <br>  I have repeatedly met with descriptions of these methods of comparison, but I never really thought about what it means to ‚Äúcompare by words with regard to current culture‚Äù. <br>  Will the byte comparison be identical to that when choosing EqualityComparer &lt;String&gt; .Default or explicitly calling Equals?  In this case, the <a href="">OrdinalComparer</a> class is responsible for <a href="">comparing</a> : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Object.ReferenceEquals(x ,y)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || y == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( _ignoreCase) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x.Length != y.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (String.Compare(x, y, StringComparison.OrdinalIgnoreCase) == <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Equals(y); }</code> </pre><br>  In the case of case-sensitive registration, the difference lies in duplicating the checks for the equality of object references and checking for null.  This is not very much, although from the point of view of MSIL it is a couple dozen instructions: <br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0000</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">nop</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0001</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0002</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0003</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">call</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[mscorlib]</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::ReferenceEquals(object</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">object</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0008</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.i4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0009</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ceq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_000b</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">stloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_000c</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_000d</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">brtrue</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0013</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_000f</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.i4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0010</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">stloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0011</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">br</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_003e</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0013</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0014</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">brfalse</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_001f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0016</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0017</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldnull</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0018</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ceq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_001a</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.i4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_001b</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ceq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_001d</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">br</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_001f</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.i4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0020</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">nop</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0021</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">stloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0022</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0023</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">brtrue</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0029</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0025</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.i4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0026</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">stloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0027</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">br</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_003e</span></span></code> </pre><br>  How about saving case insensitive?  Frankly, I did not expect to see something like <a href="https://msdn.microsoft.com/en-us/library/system.string.tolower(v%3Dvs.110).aspx">ToLower</a> , since this operation depends on the culture.  But the result still exceeded expectations.  To call String.Compare (x, y, StringComparison.OrdinalIgnoreCase), the following <a href="">code branch</a> is executed: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> StringComparison.OrdinalIgnoreCase: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ASCII ,      . if (this.IsAscii() &amp;&amp; value.IsAscii()) { return (CompareOrdinalIgnoreCaseHelper(this, value) == 0); } #if FEATURE_COREFX_GLOBALIZATION return CompareInfo.CompareOrdinalIgnoreCase(strA, 0, strA.Length, strB, 0, strB.Length); #else //   return TextInfo.CompareOrdinalIgnoreCase(strA, strB); #endif</span></span></code> </pre><br>  I wonder how much worse a slow solution should be so that IsAscii is justified? <br>  In the case of ASCII strings, validation is carried out really character-by-character, each character is checked for a register and, if necessary, converted to upper case by simple subtraction of 0x20. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareOrdinalIgnoreCaseHelper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String strA, String strB</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = Math.Min(strA.Length, strB.Length); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ap = &amp;strA.m_firstChar) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* bp = &amp;strB.m_firstChar) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a = ap; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b = bp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charA = *a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charB = *b; Contract.Assert((charA | charB) &lt;= <span class="hljs-number"><span class="hljs-number">0x7F</span></span>, <span class="hljs-string"><span class="hljs-string">"strings have to be ASCII"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//            if ((uint)(charA - 'a') &lt;= (uint)('z' - 'a')) charA -= 0x20; if ((uint)(charB - 'a') &lt;= (uint)('z' - 'a')) charB -= 0x20; if (charA != charB) return charA - charB; //   a++; b++; length--; } return strA.Length - strB.Length; } }</span></span></code> </pre><br>  For non-ASCII strings, <a href="">native</a> C ++ <a href="">code</a> is called and then, depending on the conditions, a string comparison method from the Windows kernel can be invoked or (judging by the comments, this is possible only for Windows XP) a <a href="">method</a> that performs the same character-by-character comparison, translating each character into the upper case based on the operating system character tables. <br><br>  <i>This is indeed of interest to the issue of performance, since the performance of the same comparator may differ depending on the input data, in a degenerate case, from changing one character per line.</i> <br><br>  What about cultures?  The <a href="">CultureAwareComparer</a> class accepts a culture as input, on the basis of which it will compare strings and a flag indicating whether the case of characters is ignored.  Culture information contains the <a href="https://msdn.microsoft.com/en-us/library/system.globalization.compareinfo(v%3Dvs.110).aspx">CompareInfo</a> property, the object of which contains methods for comparing strings based on a given culture, which are used in the CultureAwareComparer. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_compareInfo.Compare(x, y, _ignoreCase? CompareOptions.IgnoreCase : CompareOptions.None) == <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Unfortunately, inside there is nothing interesting, because in fact the <a href="">native code</a> is called, which again climbs into the kernel to call the string sorting function.  To compensate for the lack of code, here's an excerpt for you, which is repeatedly found in the coreclr string functions: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Remove this workaround after Vista SP2 &amp;/or turkic CompareStringEx() gets fixed on Vista. // If its Vista and we want a turkik sort, then call CompareStringW not CompareStringEx LPCWSTR pLingLocaleName = AvoidVistaTurkishBug ? GetLingusticLocaleName((LPWSTR)lpLocaleName, dwCmpFlags) : lpLocaleName; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> End of workaround for turkish CompareStringEx() on Vista/Win2K8</span></span></code> </pre><br>  That is, the <b>comparison of .net strings with regard to culture and language always takes place at the kernel level of the operating system</b> . <br><br><h4>  Performance tests </h4><br>  After such a trip, I could not help but be interested in the real difference in performance.  Initially, my scenario was to combine sequences, since the result is a large number of comparisons.  For a clean test, I left only the string comparison without additional operations.  The source code of the test can be viewed or grabbed on <a href="https://github.com/Vadimyan/StringComparationBenchmark">GitHub</a> .  The results floated a little, but I decided that 10,000 iterations of 1,000,000 would be sufficient without a confidence interval. <br><table><tbody><tr><th>  Scenario </th><th>  Milliseconds / 1,000,000 operations </th><th>  Relative difference </th></tr><tr><td>  string.Equals </td><td>  25.8 </td><td>  1x </td></tr><tr><td>  EqualityComparer &lt;string&gt; .Default </td><td>  33.5 </td><td>  1.3x </td></tr><tr><td>  StringComparer.Ordinal </td><td>  29.8 </td><td>  1.16x </td></tr><tr><td>  StringComparer.OrdinalIgnoreCase </td><td>  50.3 </td><td>  1.95x </td></tr><tr><td>  StringComparer.OrdinalIgnoreCase non ASCII </td><td>  82.2 </td><td>  3.19x </td></tr><tr><td>  StringComparer.CurrentCulture </td><td>  136 </td><td>  5.27x </td></tr><tr><td>  StringComparer.CurrentCulture non ASCII </td><td>  174.3 </td><td>  6.76x </td></tr><tr><td>  StringComparer.CurrentCultureIgnoreCase </td><td>  134.5 </td><td>  5.21x </td></tr><tr><td>  StringComparer.CurrentCultureIgnoreCase non ASCII </td><td>  172.1 </td><td>  6.67x </td></tr><tr><td>  StringComparer.InvariantCulture </td><td>  132.2 </td><td>  5.12x </td></tr><tr><td>  StringComparer.InvariantCulture non ASCII </td><td>  189.5 </td><td>  7.34x </td></tr><tr><td>  StringComparer.InvariantCultureIgnoreCase </td><td>  134.1 </td><td>  5.2x </td></tr><tr><td>  StringComparer.InvariantCultureIgnoreCase non ASCII </td><td>  188 </td><td>  7.29x </td></tr></tbody></table>  The results confirm the code ‚Äî an explicit call to string.Equals is the fastest, GenericEqualityComparer &lt;string&gt; is slower due to additional checks of input parameters.  OrdinalComparer also has additional checks.  And then either unwound cycles are invoked, or methods of unmanaged code that, generally speaking, behave differently on different platforms, but in the case of working with culture, call methods from the operating system kernel. <br><br><h4>  Comparison in other operations on strings </h4><br>  It would seem that by default the fastest and simplest comparison is used, the programmer can not worry.  In fact, everything is not quite so.  There are a number of row operations.  For example, determining <a href="">whether a string begins with a specific substring</a> : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartsWith</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StartsWith(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, StringComparison.CurrentCulture); }</code> </pre><br>  At the same time, <a href="">checking the occurrence of a substring</a> (it would seem the same thing) is again performed byte-by-byte: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( IndexOf(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, StringComparison.Ordinal) &gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre><br>  And checking the occurrence of a substring <a href="">that returns the index of the beginning of this substring</a> is again with the current culture: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IndexOf(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, StringComparison.CurrentCulture); }</code> </pre><br>  LastIndexOf generally calls native code.  What is going on in it?  Only Sathya knows. <br><br><h4>  findings </h4><br>  What to do with all this information? <br><ul><li>  First, with a large number of comparisons, you can get an increase in the performance of these operations by about 10% by implementing your string comparator, which will not duplicate the checks that are already in the string.Equals method. </li><li>  Secondly, if the lines are keys, then you can decide to use only Ascii characters, which will give a gain of about 20% for most comparisons. </li><li>  Thirdly, it is necessary to understand and limit well the case when the comparison is applied taking into account the culture.  Often in the code I met exactly the StringComparer.InvariantCulture option since the author considered such a comparison to be the most general.  But most often it is enough to use StringComparer.Ordinal or, in special cases, StringComparer.OrdinalIgnoreCase. </li><li>  Using various methods of the String class it is better to double-check their behavior in the source code.  Perhaps a surprise is waiting for you after the tests with ‚ÄúTestString‚Äù and ‚ÄúAnotherTestString‚Äù, when the code goes to production. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/274491/">https://habr.com/ru/post/274491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274481/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ192 (December 28, 2015 - January 3, 2016)</a></li>
<li><a href="../274483/index.html">Creating game levels: tips and tricks (part 1)</a></li>
<li><a href="../274485/index.html">String and & str in Rust functions</a></li>
<li><a href="../274487/index.html">Digest on the results of 2015</a></li>
<li><a href="../274489/index.html">Java in Android: Change is Coming (Rumors)</a></li>
<li><a href="../274493/index.html">One more analysis of bubble sort</a></li>
<li><a href="../274495/index.html">Flash Player (ActiveX) update for January 1, 2016</a></li>
<li><a href="../274497/index.html">Centrifugal compressor installations. Surge protection</a></li>
<li><a href="../274499/index.html">Definition of gender by name - when accuracy is really important</a></li>
<li><a href="../274501/index.html">IBM opens blockchain lab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>