<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Natural Motion Simulation: Steering Behaviors - 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first part of the article is here . 


 Part 6. Avoiding Collisions 
 NPC often requires the ability to avoid obstacles to navigate properly. In t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Natural Motion Simulation: Steering Behaviors - 2</h1><div class="post__text post__text-html js-mediator-article">  The first part of the article is <a href="https://habr.com/post/358366/">here</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/7a/xv/zv7axvlbw42adyuixtrzowe2tpq.png"></div><br><h2>  Part 6. Avoiding Collisions </h2><br>  NPC often requires the ability to avoid obstacles to navigate properly.  In this part, we will look at the steering behavior <em>collision avoidance</em> , which allows characters to safely dodge obstacles in the environment. <br><br><hr><br><h2>  Introduction </h2><br>  The basic idea of ‚Äã‚Äãavoiding collisions is to generate a control force to avoid obstacles every time they are close enough to impede movement.  Even if there are several obstacles in the environment, this behavior will simultaneously use one of them to calculate the avoidance force. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Only obstacles in front of the character are analyzed;  the closest one is selected for evaluation as representing the greatest threat.  As a result, the character has the ability to evade all obstacles in the area, safely and without hesitation, moving from one to another. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/054/925/989/054925989028ccca033124291a39b981.png"></div><br>  <i>The obstacles in front of the character are analyzed and the nearest (most threatening) is selected.</i> <br><br>  Collision avoidance behavior is not a pathfinding algorithm.  It makes the characters move around the environment, avoiding obstacles, gradually finding their way through the blocks - but in cases with obstacles in the form of L or T, for example, it does not work very well. <br><a name="habracut"></a><br>  <strong>Hint:</strong> This collision avoidance behavior may seem similar to Flee, but there is an important difference between them.  A character moving along a wall will avoid her only when she blocks his path, and flee behavior always pushes the character away from the wall. <br><br><hr><br><h2>  We look forward </h2><br>  The first step necessary to avoid obstacles in the environment is their perception.  The only obstacles that should excite the character are those that are in front of him and block the current route. <br><br>  As explained in the previous article, the direction of movement of the character describes the velocity vector.  We use it to create a new vector with the name <code>ahead</code> , which will be a copy of the velocity vector, but with a different length: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/011/7df/6ad0117dfee09309c11e1d177cf3f3e6.png"></div><br>  <i>The vector <code>ahead</code> is the character's line of sight.</i> <br><br>  This vector is calculated as follows: <br><br><pre> <code class="actionscript hljs">ahead = position + normalize(velocity) * MAX_SEE_AHEAD</code> </pre> <br>  The length of the vector <code>ahead</code> (changeable with <code>MAX_SEE_AHEAD</code> ) determines the distance that a character can ‚Äúsee‚Äù. <br><br>  The more <code>MAX_SEE_AHEAD</code> , the earlier the character will begin to evade the obstacle, because it will be perceived as a threat, even if you are far away: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/762/cde/c98/762cdec9850c01c71999bad996a18151.png"></div><br>  The greater the length ahead, the earlier the character will take measures to avoid obstacles. <br><br><hr><br><h2>  Collision check </h2><br>  To check the presence of a collision, each obstacle (or a rectangle describing it) must be described in a geometric form.  The best results are obtained by using a sphere (in two dimensions - a circle), therefore every obstacle in the environment should be described in this way. <br><br>  One solution is to check the collision of the intersection of the segment and the sphere - the segment is a vector <code>ahead</code> , and the sphere is an obstacle.  This approach works, but I use its simplification, which is easier to understand and at the same time gives similar results (and sometimes even better). <br><br>  The <code>ahead</code> vector will be used to create another vector half its length: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/984/09e/d5b/98409ed5b654b713c47a4a0d73222584.png"></div><br>  <i>Same direction, half length.</i> <br><br>  The vector <code>ahead2</code> calculated in the same way as <code>ahead</code> , but its length is shortened by half: <br><br><pre> <code class="actionscript hljs">ahead = position + normalize(velocity) * MAX_SEE_AHEAD ahead2 = position + normalize(velocity) * MAX_SEE_AHEAD * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br>  We want to perform a collision check to test whether one of these two vectors is inside the sphere of an obstacle.  This is easy to do by comparing the distance between the end of the vector and the center of the sphere. <br><br>  If the distance is less than or equal to the radius of the sphere, then the vector is inside the sphere and a collision is detected: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c70/65c/543/c7065c543fe90b43ec0e5ff8e5edad3f.png"></div><br>  <i>The vector ahead intersects with an obstacle if d &lt;r.</i>  <i>To make it clearer, the vector ahead2 is removed.</i> <br><br>  If <em>any</em> of these two vectors ahead is inside the sphere of the obstacle, then this obstacle blocks the path.  You can use the definition of the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">Euclidean distance</a> between two points: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a :Object, b :Object)</span></span></span><span class="hljs-function"> :Number </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lineIntersectsCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ahead :Vector3D, ahead2 :Vector3D, obstacle :Circle)</span></span></span><span class="hljs-function"> :Boolean </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  "center"  -  Vector3D. return distance(obstacle.center, ahead) &lt;= obstacle.radius || distance(obstacle.center, ahead2) &lt;= obstacle.radius; }</span></span></code> </pre> <br>  If a character‚Äôs path is blocked by several obstacles, then the nearest (most threatening) is chosen for calculations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68e/0cd/0d0/68e0cd0d05baeea58e1db5d617ee5855.png"></div><br>  For calculations, the nearest obstacle (the most threatening) is selected. <br><br><hr><br><h2>  Calculation of the avoidance force </h2><br>  The force of avoidance should push the character away from the obstacle, allowing him to dodge the sphere.  This can be implemented using a vector formed with the center of a sphere (position vector) and the vector <code>ahead</code> .  We calculate this avoidance force as follows: <br><br><pre> <code class="actionscript hljs">avoidance_force = ahead - obstacle_center avoidance_force = normalize(avoidance_force) * MAX_AVOID_FORCE</code> </pre> <br>  After calculating the <code>avoidance_force</code> it is normalized and scaled to <code>MAX_AVOID_FORCE</code> , that is, to a value that defines the length of the <code>avoidance_force</code> .  The more <code>MAX_AVOID_FORCE</code> , the stronger the power of avoidance pushes the character away from the obstacle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af4/5c2/b29/af45c2b29b1216d4b926504cef075204.png"></div><br>  Calculation of the power of avoidance.  The dotted orange line shows the trajectory that the character will follow to avoid obstacles. <br><br>  <strong>Hint: the</strong> position of any entity can be described as a vector so that they can be used in calculations along with other vectors and forces. <br><br><hr><br><h2>  Avoid obstacles </h2><br>  The finished implementation of the <code>collisionAvoidance()</code> method, which returns the avoidance force, will look like this: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collisionAvoidance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ ahead = ...; <span class="hljs-comment"><span class="hljs-comment">//   ahead ahead2 = ...; //   ahead2 var mostThreatening :Obstacle = findMostThreateningObstacle(); var avoidance :Vector3D = new Vector3D(0, 0, 0); if (mostThreatening != null) { avoidance.x = ahead.x - mostThreatening.center.x; avoidance.y = ahead.y - mostThreatening.center.y; avoidance.normalize(); avoidance.scaleBy(MAX_AVOID_FORCE); } else { avoidance.scaleBy(0); //    } return avoidance; } private function findMostThreateningObstacle() :Obstacle { var mostThreatening :Obstacle = null; for (var i:int = 0; i &lt; Game.instance.obstacles.length; i++) { var obstacle :Obstacle = Game.instance.obstacles[i]; var collision :Boolean = lineIntersecsCircle(ahead, ahead2, obstacle); // "position" -     if (collision &amp;&amp; (mostThreatening == null || distance(position, obstacle) &lt; distance(position, mostThreatening))) { mostThreatening = obstacle; } } return mostThreatening; }</span></span></code> </pre> <br>  The avoidance force must be added to the character's velocity vector.  As explained in the previous article, all control forces can be combined into one, creating a force that represents all active behaviors acting on a character. <br><br>  At a certain angle and direction of the avoidance force, it will not interfere with other control forces, such as seek or wander.  The power of avoidance is added to the character‚Äôs speed in the usual way: <br><br><pre> <code class="actionscript hljs">steering = nothing(); <span class="hljs-comment"><span class="hljs-comment">//  ,  "  " steering = steering + seek(); // ,    -  steering = steering + collisionAvoidance(); steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering, max_speed) position = position + velocity</span></span></code> </pre> <br>  Since all steering behaviors are recalculated every time the game is updated, the avoidance power will be active as long as the obstacle blocks the path. <br><br>  When an obstacle ceases to cross a segment of a vector <code>ahead</code> , the avoidance force becomes zero (no effect) or recalculated to avoid another threatening obstacle.  As a result of this, we get a character who can dodge obstacles. <br><br><hr><br><h2>  Improving Collision Detection </h2><br>  The current implementation has two problems with collision recognition.  The first occurs when the <code>ahead</code> vectors are outside the sphere of the obstacle, but the character is too close to the obstacle (or inside). <br><br>  If this happens, the character will touch (or enter) the obstacle, skipping the avoidance process, because the collision is not detected: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f68/01a/137/f6801a137a7b9ce89ef7fb7e08ee9098.png"></div><br>  <i>Sometimes the <code>ahead</code> vectors are outside the obstacles, but the character is inside.</i> <br><br>  This problem can be eliminated by adding a third vector to the collision check: character position vector.  Using three vectors greatly improves collision detection. <br><br>  The second problem occurs when a character is close to an obstacle and moves away from it.  Sometimes maneuvering can lead to collisions, even if the character just turns to look in a different direction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/f3b/fad/f2ff3bfadb4a3a3858f7bce69697865b.png"></div><br>  <i>Maneuvering can lead to a collision, even if the character just turns around.</i> <br><br>  This problem can be eliminated by changing the scale of the vectors <code>ahead</code> in accordance with the current speed of the character.  For example, the code for computing the <code>ahead</code> vector is changed as follows: <br><br><pre> <code class="actionscript hljs">dynamic_length = length(velocity) / MAX_VELOCITY ahead = position + normalize(velocity) * dynamic_length</code> </pre> <br>  The variable <code>dynamic_length</code> changes from 0 to 1. When a character moves at full speed, <code>dynamic_length</code> is 1;  when a character slows down or speeds up, <code>dynamic_length</code> is 0 or more (for example, 0.5). <br><br>  Therefore, if a character simply maneuvers without moving, <code>dynamic_length</code> tends to zero, creating a zero vector <code>ahead</code> that has no collisions. <br><br><hr><br><h2>  Demo: zombie time! </h2><br>  To demonstrate the behavior of avoiding obstacles in action, a horde of zombies would be best.  Below is a demo with several zombies (all of them have different speeds) seeking to mouse cursor. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Gaqz-SKtMsE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Flash <a href="">online</a> demo is <a href="">here</a> . <br><br><hr><br><h2>  Conclusion </h2><br>  The collision avoidance behavior allows any character to dodge obstacles in the environment.  Since all control forces are recalculated anew each time a game is updated, characters interact seamlessly with various obstacles, always analyzing the most threatening (nearest). <br><br>  Even despite the fact that this behavior is not an algorithm for finding paths, the results achieved on densely populated maps look quite convincing. <br><br><h2>  Part 7. Following the path </h2><br>  The task of implementing the following along the way is often encountered when developing games.  In this part, we will look at the steering behavior <em>path following</em> (following the path), allowing the characters to follow a predetermined path consisting of their points and segments. <br><br><hr><br><h2>  Introduction </h2><br>  The behavior of following the path can be implemented in several ways.  In the original <a href="http://www.red3d.com/cwr/steer/">implementation of Reynolds</a> , a path consisting of segments is used, and the characters strictly follow it, like a train on rails. <br><br>  In some situations, this accuracy is not required.  The character can move along the path, following the segments, but using them as a <em>binding</em> , and not as rails. <br><br>  The follow-up implementation provided in this tutorial is a simplification of the implementation proposed by Reynolds.  It also creates good results, but is not so tightly tied to heavy mathematical calculations like projection of vectors. <br><br><hr><br><h2>  Setting the path </h2><br>  The path can be specified as a set of points (nodes) connected by segments.  You can also use curves to describe the path, but it‚Äôs easier to work with points and lines, and they give almost the same results. <br><br>  If you need to use curves, they can be reduced to a set of connected points: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/365/5d6/9ed/3655d69ed052b047106a942069c7d9b1.png"></div><br>  <i>Curves and segments.</i> <br><br>  The path class will be used to describe the route.  In fact, the class has a vector of points and several methods for processing this list: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Path</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes :Vector.&lt;Vector3D&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector.&lt;Vector3D&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node :Vector3D)</span></span></span><span class="hljs-function"> :void </span></span>{ nodes.push(node); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector.&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector3D</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodes; } }</code> </pre> <br>  Each point of the path is a <code>Vector3D</code> , which is a position in space, similar to the way the character‚Äôs <code>position</code> property works. <br><br><hr><br><h2>  Movement from node to node </h2><br>  To navigate along the path, the character will move from node to node until it reaches the end of the route. <br><br>  Each point on the path can be viewed as a goal, so we can use the Seek behavior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/019/627/98a01962741f17136bb52a5738c07065.png"></div><br>  <i>Performing Seek from one point to another.</i> <br><br>  The character will move to the current point until he reaches it, then the next point on the path becomes current, and so on.  As previously stated in the part on avoiding collisions, the forces of each behavior are recalculated in each game update, that is, the transition from one node to another occurs smoothly and imperceptibly. <br><br>  To process the navigation process, the character class will need two additional properties: the current node (the one the character is aiming at) and a link to the path it follows.  The class will look like this: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Boid</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path :Path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentNode :int; (...) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathFollowing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target :Vector3D = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes :Vector.&lt;Vector3D&gt; = path.getNodes(); target = nodes[currentNode]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(position, target) &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>) { currentNode += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentNode &gt;= nodes.length) { currentNode = nodes.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a :Object, b :Object)</span></span></span><span class="hljs-function"> :Number </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by)); } (...) }</code> </pre> <br>  The <code>pathFollowing()</code> method is responsible for generating the force to follow along the path.  While he does not create strength, but correctly chooses goals. <br><br>  The <code>path != null</code> test checks whether a character follows a certain path.  If this is the case, the <code>currentNode</code> property is <code>currentNode</code> to search for the current target (the one the character should aim at) in the list of points. <br><br>  If the distance between the current goal and the character‚Äôs position is less than <code>10</code> , then this means that the character has reached the current node.  If this happens, the <code>currentNode</code> increased by one, and therefore, the character will tend to the next point on the way.  The process is repeated until the points end on the way. <br><br><hr><br><h2>  Calculation and addition of forces </h2><br>  The force used to push a character to each node of the path is seek.  The corresponding code is already selected in the <code>pathFollowing()</code> method, so now it must return a force that pushes the character to this node: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathFollowing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target :Vector3D = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes :Vector.&lt;Vector3D&gt; = path.getNodes(); target = nodes[currentNode]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(position, target) &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>) { currentNode += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentNode &gt;= nodes.length) { currentNode = nodes.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? seek(target) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); }</code> </pre> <br>  After calculating the force of following the path, it is necessary, as usual, to add the character‚Äôs speed to the vector: <br><br><pre> <code class="actionscript hljs">steering = nothing(); <span class="hljs-comment"><span class="hljs-comment">//  ,  "  " steering = steering + pathFollowing(); steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering, max_speed) position = position + velocity</span></span></code> </pre> <br>  The driving force of following the path is extremely similar to the behavior of Pursuit, in which the character is constantly changing its direction to catch the target.  The difference lies in the fact that the character strives for a fixed target, which, after reaching, begins to ignore and strive for another. <br><br>  The result will be as follows: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XPC5leOwGdA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Flash <a href="">online</a> demo is <a href="">here</a> . <br><br><hr><br><h2>  Motion smoothing </h2><br>  In the current implementation, all characters are required to ‚Äútouch‚Äù the current point on the path in order to choose the next one.  Consequently, a character can perform unwanted movement patterns, for example, move around a target in circles until he reaches it. <br><br>  In nature, all movements tend to follow the <a href="http://en.wikipedia.org/wiki/Principle_of_least_effort">principle of least effort</a> .  For example, a person does not walk constantly in the middle of a corridor;  if there is a turn ahead, it approaches the wall to reduce the distance. <br><br>  This pattern can be recreated by adding a radius to the path.  The radius is applied to points and can be considered as the ‚Äúwidth‚Äù of the route.  He will control how far a character can move away from points, moving along the path: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/706/a44/b13/706a44b13361dce48b43d726bf8958dc.png"></div><br>  <i>The effect of the radius on the path.</i> <br><br>  If the distance between the character and the point is less than or equal to the radius, then the point is considered to be reached.  Consequently, all characters will move using segments and points as <em>guides</em> : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/gKU9YjcpMuw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Flash <a href="">online</a> demo is <a href="">here</a> . <br>  The larger the radius, the wider the route and the greater the distance to the points that the characters will maintain during turns.  The radius value can be changed to create different sequence patterns. <br><br><hr><br><h2>  Forward and backward </h2><br>  Sometimes, reaching the end of the path, it is useful for characters to keep moving.  For example, in the patrol pattern, a character, having reached the end, must return to the beginning of the route, following the same points. <br><br>  This can be achieved by adding the property <code>pathDir</code> to the character class;  it is an integer value that controls the direction in which the character moves along the path.  If <code>pathDir</code> is <code>1</code> , then the character moves to the end of the path;  <code>-1</code> indicates a start. <br><br>  The <code>pathFollowing()</code> method can be changed as follows: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathFollowing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target :Vector3D = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes :Vector.&lt;Vector3D&gt; = path.getNodes(); target = nodes[currentNode]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(position, target) &lt;= path.radius) { currentNode += pathDir; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentNode &gt;= nodes.length || currentNode &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { pathDir *= <span class="hljs-number"><span class="hljs-number">-1</span></span>; currentNode += pathDir; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? seek(target) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); }</code> </pre> <br>  Unlike the previous version, now the value of <code>pathDir</code> added to the <code>currentNode</code> property (instead of simply adding <code>1</code> ).  This allows the character to choose the next point on the path based on the current direction. <br><br>  After this, the test checks whether the character has reached the end of the route.  If this is the case, <code>pathDir</code> is multiplied by <code>-1</code> , which reverses the value, causing the character to reverse its direction of movement. <br><br>  As a result, we get a pattern of moving forward and backward. <br><br><hr><br><h2>  Conclusion </h2><br>  Following the path allows characters to move along a given path.  The route is determined by points and its width can be adjusted, creating patterns of movement that look more natural. <br><br>  The implementation discussed in this part is a simplification of the <a href="http://www.red3d.com/cwr/steer/">initial behavior of following the path</a> suggested by Reynolds, but still creates plausible and natural results. <br><br><h2>  Part 8. Following the leader </h2><br>  In addition to being able to follow the path, the character (or group of characters) must also be able to follow some character (for example, the squad leader).  This problem can be solved using the <em>following leader</em> behavior (following the leader). <br><br><hr><br><h2>  Introduction </h2><br>  The behavior of following the leader is a combination of other control forces arranged in such a way that a group of characters follow a certain character (leader).  In a trivial approach, you can use Seek or Pursuit behaviors to create a following pattern, but the result will not be very good. <br><br>  With seek behavior, the character is pushed towards the goal, sooner or later taking the same place as the goal.  The pursuit behavior, on the other hand, pushes a character to another character, but with the goal of catching it (based on predictions) rather than just following it. <br><br>  When following a leader, the task is to remain close enough to the leader, but <em>slightly behind him</em> .  In addition, when a character is far away, he should move to the leader faster, but slow down while reducing the distance.  This can be achieved by combining the three steering behaviors: <br><br><ul><li>  Arrive: movement to the leader with gradual deceleration and stopping of movement. </li><li>  Evade: if the character is on the path of the leader, then he must quickly move away. </li><li>  <a href="http://gamedev.tutsplus.com/tutorials/implementation/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation/">Separation</a> : Avoiding crowding, when the leader is followed by several characters. </li></ul><br>  Below, I will explain how each of these behaviors can be combined to create a pattern of following the leader. <br><br><hr><br><h2>  Finding the right point to follow </h2><br>  In the process of following the character should strive to remain a little behind the leader, like an army behind the commander.  The following point (called <code>behind</code> ) can be easily calculated based on the speed of the target, because it also represents the direction of the character.  Here is the pseudocode: <br><br><pre> <code class="actionscript hljs">tv = leader.velocity * <span class="hljs-number"><span class="hljs-number">-1</span></span>; tv = normalize(tv) * LEADER_BEHIND_DIST; behind = leader.position + tv;</code> </pre> <br>  If the velocity vector is multiplied by <code>-1</code> , then the result will be the <em>inverse of</em> the velocity vector.  This resultant vector (called <code>tv</code> ) can then be normalized, scaled, and added to the character‚Äôs current position. <br><br>  Here is a visual representation of the process: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96e/84f/0c3/96e84f0c3356baea18ff11d48179c6e0.png"></div><br>  <i>Vector operations used to find the sequence point.</i> <br><br>  The more <code>LEADER_BEHIND_DIST</code> , the greater the distance between the leader and the point behind him.  Since the characters will follow this point, the further it is from the leader, the further the characters will be from it. <br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Follow and Arrival </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is for the character to follow the leader's point </font></font><code>behind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As in all other behaviors, the follow-up process is controlled by the force generated by the method </font></font><code>followLeader()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">followLeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(leader :Boid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tv :Vector3D = leader.velocity.clone(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> force :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-comment"><span class="hljs-comment">//   behind tv.scaleBy(-1); tv.normalize(); tv.scaleBy(LEADER_BEHIND_DIST); behind = leader.position.clone().add(tv); //       behind force = force.add(arrive(behind)); return force; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method calculates a point </font></font><code>behind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and creates a force for arriving at this point. </font><font style="vertical-align: inherit;">Then </font></font><code>followLeader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you can add strength to the control power of the character, as in all other behaviors:</font></font><br><br><pre> <code class="actionscript hljs">steering = nothing(); <span class="hljs-comment"><span class="hljs-comment">//  ,  "  " steering = steering + followLeader(); steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering, max_speed) position = position + velocity</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of this implementation will be that a group of characters will be able to arrive at the </font></font><code>behind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leader's </font><font style="vertical-align: inherit;">point </font><font style="vertical-align: inherit;">(interactive </font><font style="vertical-align: inherit;">Flash </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoiding crowding </font></font></h2><br>    ,       ,     .         ,     ,  ¬´¬ª.       <a href="http://gamedev.tutsplus.com/tutorials/implementation/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation/"></a> ‚Äî   ,  <a href="http://gamedev.tutsplus.com/tutorials/implementation/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation/">  (flocking)</a> . <br><br>                .      : <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">separation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> force :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighborCount :int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i:int = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Game.instance.boids.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b :Boid = Game.instance.boids[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &amp;&amp; distance(b, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) &lt;= SEPARATION_RADIUS) { force.x += b.position.x - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position.x; force.y += b.position.y - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position.y; neighborCount++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighborCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) { force.x /= neighborCount; force.y /= neighborCount; force.scaleBy( <span class="hljs-number"><span class="hljs-number">-1</span></span>); } force.normalize(); force.scaleBy(MAX_SEPARATION); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> force; }</code> </pre> <br>        <code>followLeader</code> ,        <em>    </em> ,     : <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">followLeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(leader :Boid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tv :Vector3D = leader.velocity.clone(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> force :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-comment"><span class="hljs-comment">//   behind tv.scaleBy(-1); tv.normalize(); tv.scaleBy(LEADER_BEHIND_DIST); behind = leader.position.clone().add(tv); //       behind force = force.add(arrive(behind)); //    force = force.add(separation()); return force; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we get a much more natural looking pattern ( </font><font style="vertical-align: inherit;">Flash </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Out of the way </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the leader suddenly changes the current direction, then there is a chance that the characters will be on his way. </font><font style="vertical-align: inherit;">Since the characters follow the leader, it will be illogical to leave him in front of the leader. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If a character gets in the way of a leader, then he must immediately step back to clear the way. </font><font style="vertical-align: inherit;">This can be achieved by evade behavior:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c13/9e4/d8a/c139e4d8a8ce427b5925985fe26deb89.png"></div><br> <i>  </i> <br><br>  ,       ,   ,   ,       collision avoidance:             ( <code>ahead</code> );      <code>ahead</code>   , , <code>30</code> ,          . <br><br>  <code>ahead</code>    ,   <code>behind</code> point;   ,     : <br><br><pre> <code class="actionscript hljs">tv = leader.velocity; tv = normalize(tv) * LEADER_BEHIND_DIST; ahead = leader.position + tv;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to change the method </font></font><code>followLeader()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to check if the character is in scope. </font><font style="vertical-align: inherit;">If this happens, then the variable </font></font><code>force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(representing the force of the sequence) is added to the value, the return </font></font><code>evade(leader)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value, that is, the force avoiding the position of the leader:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">followLeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(leader :Boid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tv :Vector3D = leader.velocity.clone(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> force :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-comment"><span class="hljs-comment">//   ahead tv.normalize(); tv.scaleBy(LEADER_BEHIND_DIST); ahead = leader.position.clone().add(tv); //   behind tv.scaleBy(-1); behind = leader.position.clone().add(tv); //       ,    //     . if (isOnLeaderSight(leader, ahead)) { force = force.add(evade(leader)); } //      behind force = force.add(arrive(behind, 50)); // 50 -   //    force = force.add(separation()); return force; } private function isOnLeaderSight(leader :Boid, leaderAhead :Vector3D) :Boolean { return distance(leaderAhead, this) &lt;= LEADER_SIGHT_RADIUS || distance(leader.position, this) &lt;= LEADER_SIGHT_RADIUS; } private function distance(a :Object, b :Object) :Number { return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by)); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All characters, once in the scope of the leader, will instantly avoid his current position ( </font><font style="vertical-align: inherit;">Flash </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hint: the</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> power of following the leader is a combination of several forces. </font><font style="vertical-align: inherit;">When a character is affected by the power of following, then in fact he is simultaneously influenced by the forces of arrival, separation and avoidance.</font></font><br><br><hr><br><h2>  Demo </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a demo showing the behavior of following the leader. </font><font style="vertical-align: inherit;">The blue soldier (leader) performs the behavior of arrive at the mouse cursor, and the green soldiers follow the leader. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a player clicks on the screen, all the soldiers turn in the direction of the cursor and shoot. </font><font style="vertical-align: inherit;">Monsters every few seconds apply the behavior of arrive at random points.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J8aLJGn0zko" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demo is </font><a href=""><font style="vertical-align: inherit;">here</font></a><font style="vertical-align: inherit;"> .</font></font><br><hr><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The leader following behavior (following the leader) allows a group of characters to follow a specific goal, staying slightly behind it. </font><font style="vertical-align: inherit;">In addition, characters avoid the current location of the leader if they are in his path. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to note that the behavior of following the leader is a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combination of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> several other behaviors, such as arrive, evade and separation. </font><font style="vertical-align: inherit;">It shows that simple behaviors can be combined to create extremely complex patterns of movement.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 9. Queue </font></font></h2><br>   ,       .  -         .             . <br><br>         <em>queue</em> ()   ,   ,    . <br><br><hr><br><h2>  Introduction </h2><br>      <em>Queuing</em> (  )      ,     - .     ,    ,  ,        .        . <br><br>    queue           ¬´  ¬ª.        ,   ,    ( <a href=""></a>  Flash). <br><br>         : seek  collision avoidance. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The door consists of two rectangular obstacles, between which there is a gap (doorway). </font><font style="vertical-align: inherit;">The character seeks (seek) to the point behind this door. </font><font style="vertical-align: inherit;">Having reached there, the character moves to the bottom of the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without a queue, the scene looks like a horde of savages struggling to arrive at their destination. </font><font style="vertical-align: inherit;">After the implementation of the behavior of the crowd will smoothly leave the room, creating rows.</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look forward </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first ability that a character must receive in order to stand in line is the ability to find out if there is anyone in front of him. Based on this information, he can decide whether to keep moving or to stop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the existence of more sophisticated ways to check the presence of neighbors ahead, I use a simplified method based on the distance between the point and the character. This approach was used in collision avoidance behavior to check for the presence of obstacles ahead:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/3f5/2fa/0063f52fa286b8e9dd98474ecfa3c7dc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checking neighbors using the ahead point. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the character is projected a point with the name </font></font><code>ahead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the distance between this point and the neighboring character is less or equal </font></font><code>MAX_QUEUE_RADIUS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it means that there is someone ahead and the character must stop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The point is </font></font><code>ahead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculated as follows (pseudocode):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  qa,  ahead    qa = normalize(velocity) * MAX_QUEUE_AHEAD; ahead = qa + position;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The speed, which also gives the character's direction, is normalized and scaled by </font></font><code>MAX_QUEUE_AHEAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to create a new vector, called </font></font><code>qa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When added </font></font><code>qa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to a vector, the </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">result is a point in front of the character at a distance of </font></font><code>MAX_QUEUE_AHEAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">units from it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this can be wrapped in a method </font></font><code>getNeighborAhead()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNeighborAhead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Boid </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i:int; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret :Boid = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> qa :Vector3D = velocity.clone(); qa.normalize(); qa.scaleBy(MAX_QUEUE_AHEAD); ahead = position.clone().add(qa); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Game.instance.boids.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor :Boid = Game.instance.boids[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d :Number = distance(ahead, neighbor.position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbour != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &amp;&amp; d &lt;= MAX_QUEUE_RADIUS) { ret = neighbor; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method checks the distance between the point </font></font><code>ahead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and all other characters, returning the first character, the distance to which is less or equal </font></font><code>MAX_QUEUE_AHEAD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the character is not found, the method returns </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating a Queuing Method </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As with all other behaviors, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the lining force is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculated in a method called </font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor :Boid = getNeighborAhead(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">  ,      } return new Vector3D(0, 0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result </font></font><code>getNeighborAhead()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is stored in a variable </font></font><code>neighbor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If </font></font><code>neighbor != null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then there is someone ahead; </font><font style="vertical-align: inherit;">otherwise, the path is clear. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, like the methods of all other behaviors, must return power, which is the controlling force associated with the method itself. </font><font style="vertical-align: inherit;">As long as </font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it returns strength without magnitude, that is, it will have no effect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for all characters in the scene with the door looks like this for now (pseudocode):</font></font><br><br><pre> <code class="javascript hljs">public <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>):</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doorway :Vector3D = getDoorwayPosition(); steering = seek(doorway); <span class="hljs-comment"><span class="hljs-comment">// seek   steering = steering + collisionAvoidance(); //   steering = steering + queue(); //      steering = truncate (steering, MAX_FORCE); steering = steering / mass; velocity = truncate (velocity + steering , MAX_SPEED); position = position + velocity;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it </font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns zero power, the characters will continue to move without creating rows. </font><font style="vertical-align: inherit;">It is time for them to take some action when a neighbor is found ahead.</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few words about stopping traffic </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steering behaviors are based on constantly changing forces, so the system as a whole becomes very dynamic. The more forces are used, the more difficult it becomes to identify and cancel the vector of a certain force. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the implementation used in this series of steering behaviors, all forces are added. Therefore, to cancel the force, it is necessary to re-calculate it, to draw it and to add it again to the vector of the current control force. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is what happens in Arrival's behavior, in which the speed is canceled to make the character stop. But what happens when several forces work together, for example, in collision avoidance, flee, and other behaviors?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the sections below, two ideas are presented on how to make a character stop. </font><font style="vertical-align: inherit;">The first uses the ‚Äúhard stop‚Äù approach, which acts directly on the velocity vector and ignores all other control forces. </font><font style="vertical-align: inherit;">The second uses a force vector called </font></font><code>brake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canceling all other controlling forces, that is, forcing the character to stop.</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stop motion: "hard stop" </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Several controlling forces are based on the character's speed vector. </font><font style="vertical-align: inherit;">If this vector changes, it affects all other forces, that is, they need to be recalculated. </font><font style="vertical-align: inherit;">The idea of ‚Äã‚Äãa ‚Äúhard stop‚Äù is quite simple: if there is a character ahead, then we ‚Äútrim‚Äù the speed vector:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor :Boid = getNeighborAhead(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { velocity.scaleBy(<span class="hljs-number"><span class="hljs-number">0.3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above code, when detecting a character in front, the vector scale </font></font><code>velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is reduced to </font></font><code>30%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the current value (length). Consequently, the movement is significantly reduced, but eventually returns to its normal value when the character blocking the path leaves it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is easier to understand by analyzing how the motion is calculated for </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each update</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="actionscript hljs">velocity = truncate (velocity + steering , MAX_SPEED); position = position + velocity;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the force </font></font><code>velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continues to decline, then it happens with force </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because it is based on force </font></font><code>velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This creates a vicious cycle that results in an extremely low value </font></font><code>velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And then the character stops moving. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After completion of the process of reduction in each update of the game, the vector </font></font><code>velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will increase slightly, also affecting the force </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gradually a few updates this will vectors </font></font><code>velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to their normal values. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The solution with a ‚Äúhard stop‚Äù creates the following </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">results</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Flash demo).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even though the result is rather plausible, it still looks a bit ‚Äúmechanical‚Äù. </font><font style="vertical-align: inherit;">In a real crowd, between the participants there is usually no empty space left.</font></font><br><br><hr><br><h2>  :   </h2><br>         ¬´¬ª           <code>brake</code> : <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v :Vector3D = velocity.clone(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brake :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor :Boid = getNeighborAhead(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { brake.x = -steering.x * <span class="hljs-number"><span class="hljs-number">0.8</span></span>; brake.y = -steering.y * <span class="hljs-number"><span class="hljs-number">0.8</span></span>; v.scaleBy( <span class="hljs-number"><span class="hljs-number">-1</span></span>); brake = brake.add(v); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brake; }</code> </pre> <br>    <code>brake</code>        , <code>brake</code>      <code>steering</code> ,      ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54e/885/12d/54e88512d9144b22be3ae361c1cdd86a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Submission of braking force.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The force </font></font><code>brake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receives the components </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the force </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but turns them and changes their scale to </font></font><code>0.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This means that it </font></font><code>brake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is 80% of the magnitude </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and points in the opposite direction. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hint:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direct use of force is </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dangerous. If it </font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the first behavior applied to a character, then the power </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be ‚Äúempty.‚Äù Consequently, </font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is necessary to call </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after all other methods of behaviors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so that he can get to full and final strength </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strength </font></font><code>brake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should also cancel a character‚Äôs speed. This is done by adding </font></font><code>-velocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strength </font></font><code>brake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. After this method</font></font><code>queue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may return the final force </font></font><code>brake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of using braking force is as follows:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/56A6RRPWKA4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demo is </font><a href=""><font style="vertical-align: inherit;">here</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Decrease Character Overlay </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The braking solution creates a more natural result compared to the ‚Äúmechanistic‚Äù one, because all the characters are trying to fill in the empty spaces. </font><font style="vertical-align: inherit;">However, it creates a new problem: the characters overlap each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To eliminate it, the solution with braking can be improved with a slightly modified version of the ‚Äúhard stop‚Äù approach:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v :Vector3D = velocity.clone(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brake :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor :Boid = getNeighborAhead(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { brake.x = -steering.x * <span class="hljs-number"><span class="hljs-number">0.8</span></span>; brake.y = -steering.y * <span class="hljs-number"><span class="hljs-number">0.8</span></span>; v.scaleBy( <span class="hljs-number"><span class="hljs-number">-1</span></span>); brake = brake.add(v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(position, neighbor.position) &lt;= MAX_QUEUE_RADIUS) { velocity.scaleBy(<span class="hljs-number"><span class="hljs-number">0.3</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brake; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The new test is used to check the nearest neighbors. </font><font style="vertical-align: inherit;">This time, instead of using a point to measure distance </font></font><code>ahead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the new test checks the distance between the character vectors </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b70/7de/7b4/b707de7b41c942da6d1c3e2bb39aaddc.png"></div><br> <i>      MAX_QUEUE_RADIUS,   ,     ahead.</i> <br><br>    ,   -      <code>MAX_QUEUE_RADIUS</code> ,       <code>position</code> .     - ,   ,        , ,     . <br><br>   ,      <code>velocity</code>  30%    .      ¬´ ¬ª,   <code>velocity</code>   . <br><br>    ¬´¬ª,    ,    -     ( <a href=""></a>  Flash). <br><br><hr><br><h2>   </h2><br>         ,    ,    ,          . <br><br>    ,    (separation): <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v :Vector3D = velocity.clone(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brake :Vector3D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor :Boid = getNeighborAhead(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { brake.x = -steering.x * <span class="hljs-number"><span class="hljs-number">0.8</span></span>; brake.y = -steering.y * <span class="hljs-number"><span class="hljs-number">0.8</span></span>; v.scaleBy( <span class="hljs-number"><span class="hljs-number">-1</span></span>); brake = brake.add(v); brake = brake.add(separation()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(position, neighbor.position) &lt;= MAX_QUEUE_RADIUS) { velocity.scaleBy(<span class="hljs-number"><span class="hljs-number">0.3</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brake; }</code> </pre> <br>  ,     leader following,    <code>brake</code>    ,          . <br><br>      ,     : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/IIp0BBr--MY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>    Flash  <a href=""></a> . <br><hr><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behavior queue allows characters to queue up and wait patiently for arrival at their destination. </font><font style="vertical-align: inherit;">While in the queue, the character tries not to "cheat" by jumping over positions; </font><font style="vertical-align: inherit;">he will only move when the character in front of him moves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scene with the doorway shown in this tutorial demonstrates how versatile and customizable this behavior can be. </font><font style="vertical-align: inherit;">Minor changes create a completely different result, which is easy to adjust to different situations. </font><font style="vertical-align: inherit;">This behavior can also be combined with others, for example, with collision avoidance (collision avoidance). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you enjoyed this new behavior and you will use it to create moving crowds in your game!</font></font></div><p>Source: <a href="https://habr.com/ru/post/358460/">https://habr.com/ru/post/358460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358448/index.html">Automatically build Unity projects for Android and iOS using Gitlab CI</a></li>
<li><a href="../358450/index.html">How to identify and develop talents in IT: the results of the first Team Leader meetup</a></li>
<li><a href="../358452/index.html">Ramda Thinking: Pointless Notation</a></li>
<li><a href="../358456/index.html">UK encryption devices: English restraint in every detail</a></li>
<li><a href="../358458/index.html">The digest of interesting materials for the mobile developer # 252 (May 7 - May 13)</a></li>
<li><a href="../358462/index.html">Lecture on Toloka. How thousands of people help us make Yandex</a></li>
<li><a href="../358464/index.html">Why do we think that objects are real?</a></li>
<li><a href="../358468/index.html">The key to success in four personal qualities</a></li>
<li><a href="../358472/index.html">Configure Database Status Monitoring</a></li>
<li><a href="../358474/index.html">Are two spaces better than one? Feedback on new research</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>