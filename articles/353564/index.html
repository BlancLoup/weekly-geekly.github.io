<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>getDerivedStateFromState ‚Äîor how to make a complex problem out of a simple problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I love React. I love how it works. For doing things "right." HOC, Composition, RenderProps, Stateless, Stateful - a million patterns and anti-patters ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>getDerivedStateFromState ‚Äîor how to make a complex problem out of a simple problem</h1><div class="post__text post__text-html js-mediator-article">  I love React.  I love how it works.  For doing things "right."  HOC, Composition, RenderProps, Stateless, Stateful - a million patterns and anti-patters that help to mow less. <br><br>  And just recently React brought us another gift.  Another opportunity to mow less - getDeviredStateFromProps. <br><br>  Technically, having a static mapping from props to the state, the application logic should become simpler, more understandable, testable, and so on.  In fact, many people began to stomp their feet, and demand prevProps back, unable (or without special desire) to remake the logic of their application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, the depths of hell unfolded.  Previously, a simple task has become more difficult. <br><br><img src="https://habrastorage.org/webt/go/mz/o8/gomzo8j36pr12gljc6wdiw84soq.png"><br><a name="habracut"></a><br>  The initial discussion turned on the pages of <a href="https://github.com/reactjs/reactjs.org/issues/721">github / reactjs.org</a> , and was caused by the need to know exactly how the props changed, in order to log <br><blockquote>  If you‚Äôre not sure, you‚Äôll have to do so. </blockquote><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// OLD WAY componentWillReceiveProps(newProps){ if (this.props.visible === true &amp;&amp; newProps.visible === false) { registerLog('dialog is hidden'); } } // NEW WAY static getDerivedStateFromProps(nextProps, prevState){ if (this.state.visible === true &amp;&amp; nextProps.visible === false) { registerLog('dialog is hidden'); } return { visible : nextProps.visible }; }</span></span></code> </pre> <br>  PS: But do you know that such operations should be performed in `componentDidUpdate`? <br><br>  But that was only the beginning.  On the same day, a (re) <a href="https://github.com/reactjs/rfcs/pull/40">created issue</a> of the getDerivedStateFromProps modification was created, because there is no life without prevProps.  Exactly the same issue was already closed once with ‚ÄúWont fix‚Äù, and this time, after long verbal battles, it was again closed with ‚ÄúWont fix‚Äù.  It serves him right. <br><blockquote>  But, before discussing the way out, and why the issue was closed, it is better to come up with some convenient example for clarity of reasoning. </blockquote><h3>  Table.  With sorting and page navigation </h3><br>  Let us turn to TDD, and at the beginning define the problem, and ways to solve it. <br><br><ol><li>  What you need to do to draw a table? <br><ol><li>  Take data to display </li><li>  Sort them out </li><li>  Take slice, with data for current page only </li><li>  Do not confuse the order of items </li></ol><br></li><li>  What if the data has changed? <br><ol><li>  Start over again </li></ol><br></li><li>  And if only the page has changed? <br><ol><li>  Run point 1.3 and on. </li></ol><br></li><li>  How to change page <br><ol><li>  this.setState ({page}) </li></ol><br></li><li>  How to respond to a change in state.page? <br><ol><li>  No </li></ol><br></li></ol><br>  That's the problem - you can respond to a change in props, but to change the state there is no such function (even if you read it in the title of this article). <br><br><h4>  The correct solution is number 1 </h4><br>  More precisely, the "correct" solution.  I think it should be a state machine.  Initially, it is in <b>idle</b> state.  When a <b>setState ({page})</b> signal <b>arrives,</b> it will transition to another state - the <b>changing page</b> .  When entering this state, he will consider what he needs there and send a signal <b>setState ({temporalResult})</b> .  For good, then the machine should go to the <b>‚Äúnext step‚Äù</b> state, which will calculate anything from the step after the current one, and eventually get into a <b>commit</b> , and where it will transfer data from <b>temporalResult</b> to <b>data</b> , and then go to <b>idle</b> . <br><br>  Technically, this is the right decision, and everything is possible and works, somewhere deep in the gland, or a piece of paper.  Let it remain there. <br><br><h4>  The correct solution number 2 </h4><br>  And what if you create another element, in which you transfer in the form of state and props from the current element, and use <i>getDerivedStateFromProps</i> ? <br><br>  Ie the ‚Äúfirst‚Äù component is the ‚Äúsmart‚Äù controller, in which setState ({page}) occurs, and its dumb will not be such a dump, calculating the necessary data when the external parameters change. <br>  Everything is good, but the item ‚Äúrecalculate only what is needed‚Äù is not realizable, since we KNOW that something has changed (because someone called getDerivedStateFromProps), but we don‚Äôt know WHAT. <br>  In this regard, nothing has changed. <br><br><h4>  The correct decision number 3 ("official") </h4><br>  The basis of the ‚Äúsolution‚Äù, which served as the argument for closing the issue, was one simple statement. <br><blockquote>  You might not need <s>redux</s> getDerivedStateFromProps.  You need memoization. </blockquote><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// base - https://github.com/reactjs/rfcs/pull/40#discussion_r180818891 import memoize from "lodash.memoize"; class Example { getSortedData = memoize((list, sortFn) =&gt; list.slice().sort(sortFn)) getPagedData = memoize((list, page) =&gt; list.slice(page*10, (page+1)*10)) render() { const sorted = this.getSortedData(this.props.data, this.props.sort); const pages = this.getPagedData(sorted, this.props.page); // Render with this.props, this.state, and derived values ... } }</span></span></code> </pre><br>  Memoization will keep track of the ‚Äúchanges‚Äù because it simply knows the ‚Äúold‚Äù values, and calls the <i>memos function</i> only when the value changes. <br><br>  But there are two problems.  And I both took from the second comment to the original issue. <br><br><h4>  Problem number 1 </h4><br><blockquote>  WeakMap, </blockquote>  The same "significant" order of change of values, multiplied by the curves of the hand.  Some caching levels appear, WeakMaps.  Oho, what are you doing, stop! <br><br><h4>  Problem number 2 </h4><br><blockquote>  It means that you can‚Äôt mistakes. <br></blockquote>  And this is one of the main problems of all libraries of memoization - the requirement of using "finite" values ‚Äã‚Äãas function arguments.  In general, it is simply inconvenient, but at the same time it is possible to confuse variable. <br><br>  The first problem has a solution in reselect.  <a href="https://github.com/reactjs/reselect">In reselect cascades</a> , when you have two memoized values ‚Äã‚Äãat the input, you can create a third memoized value at the output. <br><br>  Even better is the composition of memoized functions, when you simply determine the order of execution, and a certain (finite) machine executes them one by one ... In general, reselect the cascades is also ‚Äúcomposing‚Äù, but they have a tree there, and here you need a linear process - waterfall. <br><blockquote>  Hmm, I saw a waterfall in the announcement of this article.  What is it for? </blockquote><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = {...this.state, ...this.props }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultOfStep1 = {...input, <span class="hljs-attr"><span class="hljs-attr">sorted</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getSortedData(input.data, input.sort); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultOfStep1 = {... resultOfStep1, <span class="hljs-attr"><span class="hljs-attr">sorted</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPagedData(resultOfStep1.sorted, resultOfStep1.page);</code> </pre><br>  If ‚Äúall the garbage‚Äù is brought to the hepler, then we get fairly clean code <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Flow = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input, fns</span></span></span><span class="hljs-function">) =&gt;</span></span> fns.reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc,fn</span></span></span><span class="hljs-function">) =&gt;</span></span> ({...acc, ...fn(acc)}), input); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = Flow({...this.state, ...this.props },[ <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data, sort }</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getSortedData(data, sort) }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data, page }</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getPagedData(data, page) ]);</code> </pre><br>  A clean, simple and very beautiful solution for problem number 1, clearly defining the order of formation of the final value, which is completely impossible to memorize. <br><br>  Which is completely impossible to memoize because the ‚Äústep‚Äù of execution has only one argument, and with any change in input it is necessary to start from the very first stage - it is impossible to understand that only the page has changed and only the last step needs to be restarted. <br><br><h2>  Or can it? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MemoizedFlow} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-memoize"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ getSortedData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list, sortFn</span></span></span><span class="hljs-function">) =&gt;</span></span> list.slice().sort(sortFn) getPagedData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list, page</span></span></span><span class="hljs-function">) =&gt;</span></span> list.slice(page*<span class="hljs-number"><span class="hljs-number">10</span></span>, (page+<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">10</span></span>)) render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;MemoizedFlow input={</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props} flow = [ ({data, sort}</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getSortedData(data, sort)}), ({data, page}) =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getPagedData(sorted, page</span></span></span><span class="hljs-function">)}); ] &gt;{ (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{data}</span></span></span><span class="hljs-function">) =&gt;</span></span> &lt;table&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> is data you are looking <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> {data}&lt;<span class="hljs-regexp"><span class="hljs-regexp">/table&gt; } &lt;/</span></span>MemoizedFlow&gt; ) } }</code> </pre><br>  It is not strange - this time everything will work as a watch.  And even the Flow function that will be used to calculate the final value will be exactly the same as before. <br>  The whole secret is in another function of memoization, memoize-state, <a href="https://habrahabr.ru/post/350562/">about which I told a month ago</a> - she knows what parts of the state were used at a particular stage, making it possible to realize the memoded waterfall. <br><blockquote>  More complicated example of how to play - <a href="https://codesandbox.io/s/23ykx5z5jp">codesandbox.io/s/23ykx5z5jp</a> </blockquote>  As a result, the static function getDerivedStateFromProps is replaced with (in a certain sense) a statically defined component, the setting of which allows you to clearly define the <i>‚Äúmethod and method‚Äù of</i> obtaining the result, or rather the formation of the final result from the source data set. <br><br>  It can be getDerivedStateFromProps, getDerivedStateFromState, getDerivedPropsFromProps - anything.  You can even run side effects (works, but it's better not to). <br><br>  And most importantly - this approach allows you to determine exactly the response to a parameter change.  And allows you to determine exactly in the form that "correct" <br><blockquote>  The data must be updated if the data has changed, or the page.  And not only if the "page". </blockquote>  Once defined, Flow cannot be broken.  The main thing is to stop wanting to know the old values. <br><br><h3>  Conclusion </h3><br>  In general, React recently teaches us to "not want" various approaches that can lead to shitty, or problems with asynchronous rendering.  But people remain people, and do not want to abandon the old, time-tested approaches.  That's the problem. <br><br>  In fact, sometimes it is very difficult to understand how today it is ‚Äúright‚Äù to prepare the reactor, because literally two weeks ago you were preparing it, and here the BAM and the recipe changed. <br><br>  But do not despair - a <a href="https://github.com/theKashey/memoize-state">memoize-state</a> and a <a href="https://github.com/theKashey/react-memoize">react-memoize</a> built on its basis will dull the pain a bit.  All problems can be solved, the main thing is just to try to look at the problem from a different angle. <br><br>  PS: <a href="https://github.com/reactjs/rfcs/pull/40">The very original issue with the conclusion</a> . <br>  PS: <a href="https://habrahabr.ru/post/350562/">A little about how and why memoize-state works</a> . </div><p>Source: <a href="https://habr.com/ru/post/353564/">https://habr.com/ru/post/353564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353554/index.html">Improving Redux</a></li>
<li><a href="../353556/index.html">Postgres enum</a></li>
<li><a href="../353558/index.html">The digest of fresh materials from the world of the frontend for the last week No. 310 (April 9 - 15, 2018)</a></li>
<li><a href="../353560/index.html">Million, million, million ... blue certificates</a></li>
<li><a href="../353562/index.html">[1] + [2] - [3] === 9 !? Examination of internal type conversion mechanisms in JavaScript</a></li>
<li><a href="../353566/index.html">Overview of information security management architecture in Check Point R80.10. Part 1 (Translation)</a></li>
<li><a href="../353572/index.html">Global site tag (gtag.js) in Google Analytics. What is it and do you need it?</a></li>
<li><a href="../353574/index.html">Video about Panda Adaptive Defense on Aether platform</a></li>
<li><a href="../353576/index.html">Correct cryptographic answers: 2018</a></li>
<li><a href="../353580/index.html">From <blocked messenger> - to Matrix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>