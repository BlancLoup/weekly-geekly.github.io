<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous tasks in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, I would like to share with the community my small library. 
 I am programming in C / C ++, and, unfortunately, I cannot use the C ++ 11 stan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous tasks in C ++ 11</h1><div class="post__text post__text-html js-mediator-article">  Good day, I would like to share with the community my small library. <br>  I am programming in C / C ++, and, unfortunately, I cannot use the C ++ 11 standard in work projects.  But the May holidays came, free time appeared and I decided to experiment and study this forbidden fruit.  The best thing to learn is practice.  Reading articles on a programming language will teach you how to best read, so I decided to write a small library for asynchronous function execution. <br>  At once I will make a reservation that I know that there is std :: future, std :: async and so on.  It was interesting for me to implement something very similar and plunge into the world of lambda functions, flows and mutexes with my head.  Holidays - a great time for cycling. <br><a name="habracut"></a><br><br><h5>  so, let's begin </h5><br>  I decided that my library would function as follows. <br>  There is some pool with a fixed number of threads. <br>  Tasks are added to it using lambda function syntax. <br>  From the task itself, you can extract the result of its implementation, or simply wait until the end of its work. <br>  Looking ahead, it looks like this: <br><br><pre><code class="cpp hljs">... act::<span class="hljs-function"><span class="hljs-function">control </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">control</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N_THREADS)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> some_task = act::make_task([](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::const_iterator begin, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::const_iterator end) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = begin; i != end; ++i) { sum+=(*i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } , data.begin(), data.end()); control &lt;&lt; some_task; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; some_task-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; ...</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Class task </h5><br>  First you need to create a class that describes the task: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> task&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ClassType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ReturnType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task</span></span></span><span class="hljs-class">&lt;ReturnType(ClassType::*)(Args...) const&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ClassType &amp;m_func; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; m_vars; ReturnType m_return; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: task(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ClassType &amp;v, Args... args): m_func(v), m_vars(args ...) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~task() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: };</code> </pre><br><br>  As is known, the lamba function is expanded into a class-functor with operator (). <br>  Our class of the problem is template; its type is derived from the type of the operator of the functor &amp; T :: operator (). <br>  The class stores a pointer to the functor, the function arguments in the form of std :: tuple, and the return value. <br><br>  So now we can store in the object a lambda function with parameters, now we need to learn how to call it. <br>  To do this, call opertator () on m_func with the parameters stored in m_vars. <br>  From the beginning, I did not know how to do it, but the increased use of Google and the transition to the second link brought the result: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">seq</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ...S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gens</span></span></span><span class="hljs-class"> :</span></span> gens&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>, N<span class="hljs-number"><span class="hljs-number">-1</span></span>, S...&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ...S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gens</span></span></span><span class="hljs-class">&lt;0, S...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> seq&lt;S...&gt; type; };</code> </pre><br><br>  With this construct, you can add the following functions to a class: <br><br><pre> <code class="cpp hljs"> ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ReturnType r = caller(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> gens&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args)&gt;::type()); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ...S&gt; <span class="hljs-function"><span class="hljs-function">ReturnType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(seq&lt;S...&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_func(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;S&gt;(m_vars) ...); } ...</code> </pre><br><br><h5>  Base class task </h5><br>  Now we are implementing the base class of the task :: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">abstract_task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_mutex; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable m_cond_var; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_complete; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: abstract_task(): m_complete(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~abstract_task() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(m_mutex); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!m_complete) { m_cond_var.wait(lock); } } };</code> </pre><br>  The class contains a mutex and a state variable that signals the completion of the task.  Appropriately, our task class will accept some changes, which I omit, since the source code is available on the github. <br><br><h5>  Creating tasks </h5><br>  Let's make a wrapper function for creating tasks: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;task&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())&gt;&gt; make_task(T func, Args ... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;task&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())&gt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> task&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())&gt;(func, args ...)); }</code> </pre><br>  Since we have a virtual class, it is logical to use a pointer and we will do it, and not just a pointer, but a smart pointer. <br><br><h5>  Management class </h5><br>  Now we are implementing the entity for executing tasks in background threads. <br>  I will give only part of the code: <br><br><pre> <code class="cpp hljs">... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;abstract_task&gt;&gt; m_tasks; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; m_pool; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable m_cond_var; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable m_empty_cond; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; m_run; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; m_active; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: control(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pool_size = <span class="hljs-number"><span class="hljs-number">2</span></span>) { m_run.store(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_relaxed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (m_run.load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_relaxed)) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(m_mutex); m_active[n] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_tasks.empty()) { m_empty_cond.notify_all(); m_active[n] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_cond_var.wait(lock); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;abstract_task&gt; t = m_tasks.front(); m_tasks.pop_front(); lock.unlock(); t-&gt;invoke(); lock.lock(); m_active[n] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }; pool_size = pool_size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? pool_size : <span class="hljs-number"><span class="hljs-number">1</span></span>; m_active.resize(pool_size, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pool_size; ++i) { m_pool.emplace_back(func, i); } } ...</code> </pre><br><br>  For interest, I used all the features of the new standard, the use of which I could at least somehow justify. <br>  This class creates an array of threads and an array of activity state variables to monitor the execution of jobs by child threads. <br>  The main loop of the child stream is controlled by an atomic variable (in theory, it was enough to declare it volatile, since there is no race condition, the main thread only writes to it, and the children only read) <br><br><h5>  Performance </h5><br>  I would not write this article most likely if it were not for the test of the performance of this solution that I conducted compared to std :: async. <br>  Configuration: <br><blockquote>  Intel Core (TM) i7-2600 CPU @ 3.40GHz <br>  $ gcc --version <br>  gcc (Debian 4.8.2-21) 4.8.2 <br></blockquote><br><br>  The test consists of parallel addition of arrays, and then asynchronous addition of the results of all additions.  The result of the operation will be: <br><blockquote>  res = sum (array) * N_P </blockquote><br><br>  Numbers are in milliseconds. <br><br><h6>  Test 1 </h6><br>  Optimization is turned off, the number of elements in the array is 100000000, the number of generated tasks is 73, the number of threads in the pool is 6 <br>  Results: <br><blockquote>  test_act 16775 OK <br>  test_async <b>16028</b> OK </blockquote><br>  Performance is comparable. <br><br><h6>  Test 2 </h6><br>  Optimization is enabled, the number of elements in the array is 100000000, the number of generated tasks is 73, the number of threads in the pool is 6 <br>  Results: <br><blockquote>  test_act <b>1597.6</b> OK <br>  test_async 2530.5 OK </blockquote><br>  My implementation is faster one and a half times. <br><br><h6>  Test 3 </h6><br>  Optimization is enabled, the number of elements in the array is 100000000, the number of generated tasks is 73, the number of threads in the pool is 7 <br>  Results: <br><blockquote>  test_act <b>1313.1</b> OK <br>  test_async 2503.7 OK </blockquote><br><br><h6>  Test 4 </h6><br>  Optimization is enabled, the number of elements in the array is 100000000, the number of generated tasks is 73, the number of threads in the pool is 8 <br>  Results: <br><blockquote>  test_act <b>1402</b> OK <br>  test_async 2492.2 OK </blockquote><br><br><h6>  Test 5 </h6><br>  Optimization is enabled, the number of elements in the array is 100000000, the number of generated tasks is 173, the number of threads in the pool is 8 <br>  Results: <br><blockquote>  test_act <b>4435.7</b> OK <br>  test_async 5789.4 OK </blockquote><br><br><h5>  Conclusions and bugs </h5><br>  These results are most likely related to the fact that async generates a thread for each task, in my implementation the number of threads is fixed and there are no overhead costs for creating them. <br>  A bug - capturing variables of the scope (via []) in the lambda function calls SIGSEGV.  Although passing them through the parameters works fine. <br><br>  I don‚Äôt know how useful this article and the library itself is, but at least I have applied some of the features of the new standard in my practice. <br>  <a href="https://github.com/x0rb0t/acontrol">Source</a> </div><p>Source: <a href="https://habr.com/ru/post/222227/">https://habr.com/ru/post/222227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222207/index.html">Survey: what methodology is used in your project or how much we have through it?</a></li>
<li><a href="../222209/index.html">New scanning business cards in Evernote with LinkedIn</a></li>
<li><a href="../222211/index.html">The smallest comics in the world "painted" on the tip of the hair</a></li>
<li><a href="../222213/index.html">HealthWatch seeks FDA approval for its T-shirt tracking ECG</a></li>
<li><a href="../222225/index.html">12 Disney artists tricks to animate the animation</a></li>
<li><a href="../222239/index.html">Dell Fluid Cache for SAN: when data is always at hand</a></li>
<li><a href="../222243/index.html">NASA announced the collection of projects / ideas for the expedition to Europe, the satellite of Jupiter</a></li>
<li><a href="../222245/index.html">SMO subtleties. Do not be surprised that you do not have social traffic</a></li>
<li><a href="../222247/index.html">Swipe gestures in Internet Explorer and other browsers</a></li>
<li><a href="../222249/index.html">Signed a law on the right of the Cabinet to regulate the threshold of duty-free e-commerce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>