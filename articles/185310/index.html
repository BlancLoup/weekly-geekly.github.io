<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reflections on programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From Aristotle to Wittgenstein 
 I do not need a language that allows you to create good programs. I'm looking for a language in which you can‚Äôt write...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reflections on programming</h1><div class="post__text post__text-html js-mediator-article"><h4>  <b>From Aristotle to Wittgenstein</b> </h4><br>  <i>I do not need a language that allows you to create good programs.</i>  <i>I'm looking for a language in which you can‚Äôt write a bad program.</i>  Author <br><br><h5>  Foreword </h5><br>  The development of computer science as a science is represented by a river that is born in the distant past (Euclid, 3rd century BC; Babylon, 19th century BC; perhaps even earlier) from barely noticeable streams of the first algorithmic calculations.  Moving slowly through history, small streams unite into a river, which, carrying its waters through the centuries, absorbs tributaries from related disciplines, accumulates grandeur and power, and finally falls down from the second to the third millennium of Niagara, turning into a swift swirling stream that captures and carries with it from the past to the future millions of people. <br><br><img src="https://habrastorage.org/storage2/b0a/f36/a0d/b0af36a0d2ac5702db39e11b3caa5b67.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Brownian particle, which then throws on the rapids with a turbulent flow, then overturns into a stagnant swamp, then in shallow water, then into a pool;  The world of information technology seems mysterious, changeable and unpredictable.  However, the joy of constant movement, the heroic overcoming of difficulties, the frantic rotation of the kaleidoscope of new impressions eventually gives way to longing, longing for the spirit and the insurmountable need to rise for a moment over the bustle, look at this wildly raging stream and try to see if not the general direction of the turbulent river, then at least the closest turn of the channel in which you are wallowing. <br><a name="habracut"></a><br><h5>  Introduction </h5><br>  <i>‚ÄúIf a scientist cannot popularly explain to an eight-year-old child what he does, then he is a charlatan‚Äù</i> <br>  Kurt Vonnegut, "Cat's Cradle", 1963 <br><br>  A. ‚ÄúThere is no silver bullet,‚Äù said <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D1%2580%25D1%2583%25D0%25BA%25D1%2581,_%25D0%25A4%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B8%25D0%25BA">F. Brooks</a> in the last century and for a long time cooled the ardor of noble knights from programming in the fight against the ‚ÄúDragon of complexity‚Äù.  Since then, ‚ÄúHis Majesty the Dragon‚Äù has served as an excuse that users, instead of some poorly working programs, are imposed on more and more new ones, which are not much better, but devour more and more CPU and computer memory resources (‚ÄúWhy? People hawth!‚Äù ( c) B.Titamir).  For the sake of Dragon, an entire army of code &amp; fix programmers has been grown (‚Äúdo and rework‚Äù): ‚ÄúNot by skill, but by number!‚Äù, ‚ÄúRefactoring is our everything!‚Äù, ‚ÄúEven members of the Republican Party can program!‚Äù their banners.  To feed the Dragon, every day they create gigabytes of source code, much of which will never be claimed by users.  Over the years, this hideous Dragon has grown and become ‚ÄúThe Idea.  Historical necessity.  Our state interest.  A powerful factor, a justification for our united efforts. ‚Äù <br><br>  B. We are not going to look for another ‚Äúsilver bullet‚Äù, but not because there is none, but because, no matter how much we want, it‚Äôs hard to believe in dragons.  Dragons, as a rule, are born in the minds of people when they are confronted with phenomena that are not explained in their previous experience.  For computer science, the presence of white spots is not surprising because it is a very young branch of human knowledge. <br><br><img src="https://habrastorage.org/storage2/82f/a15/435/82fa1543557b857573bf94ce99f77f46.gif"><br><br>  Q. Few programmers believe in dragons, but many believe that complexity is a subjective concept.  One of the definitions of the word ‚Äúcomplex‚Äù is difficult, tangled.  For example, a complex task, a complex (or maybe more precisely, confusing?) Program.  What is difficult and confusing for one person may be easy and clear for another.  The motion of the planets in the geocentric model of Ptolemy over cycles and epicycles with amendments to them looks complicated.  The motion in the heliocentric model along Kepler ellipses is simple.  If you edit images in a bit format, it will be difficult, and if in a graphic editor, it‚Äôs easy.  An image of a Mandelbrot set can hypnotize its complexity to an uninitiated observer, but in an adequate language, the Mandelbrot set is described very simply: ‚Äúthe set of points with on the complex plane, for which the iterative sequence z <sub>0</sub> = 0, z <sub>n</sub> = z <sub>n-1</sub> <sup>2</sup> + c ( <sub>n</sub> = 1, 2, 3, ...) does not go to infinity. " <br><br>  G. There is nothing difficult and confusing in nature.  Something can only seem difficult and confusing to a person who is trying to understand something.  Maybe we make the software systems we develop ourselves complex and confusing?  Why in the ERP system SAP / R3 more than 50 thousand tables, and in the largest dictionary of the Russian language only about 54 thousand nouns?  I sometimes feel sorry to be a charlatan, trying to explain to the customer why it is so difficult to add to the program the simple functionality that he asks for. <br><br>  D. In this post I don‚Äôt set myself any tasks other than one - to write down my not very connected, but sometimes incomplete thoughts about the most common programming issues that I have been thinking about for the last twenty years.  Time is inexorable and I simply may not have enough of it in order to collect all the necessary "stones" and put together a fairly solid foundation for a new programming paradigm.  I will be satisfied if my thoughts turn out to be useful to someone, and maybe they will push someone from colleagues to go in search of the missing "stones." <br><br><h4>  <b>Theses</b> </h4><br>  <i>‚ÄúEvery task becomes trivial if it is formulated in an adequate language.</i> ‚Äù I. M. Gelfand <br><br><h5>  About programs </h5><br>  <u>Program = task + model + algorithm + data structure</u> <br><br>  The program is created in order to solve a specific task: to provide control over the spacecraft during the flight to Phobos, recognize the criminal through a photo in a stream of people, receive an SMS message from one mobile phone and transfer it to another. <br><br>  <b>The model</b> describes what the program should do to solve the problem, but not how it should do it.  Created in human thinking (mental) domain models can relate both to real-world phenomena, for example, the movement of a space object in the gravitational field and the atmosphere of the Earth, as well as to ideal concepts, such as an online store.  A model is a mental image of a future tool that will allow us to solve the problem posed. <br><br>  The key concept in the definition of the program is the <b>task</b> .  It is unreasonable to discuss the technical system in isolation from the task that it solves, so it is pointless to consider the program outside the goals for which it is created.  To solve different problems, even in the same subject area, different models will be created and different programs developed.  To calculate the trajectories of interplanetary flights, it suffices to simulate the gravitational field as a superposition of the point masses of the Sun and the planets.  For practically acceptable accuracy of predicting the motion of satellites in near-Earth orbits in the gravity model, it is necessary to take into account the heterogeneity of the Earth's field in the form of an expansion in harmonic functions or a specially selected point mass system.  And the solution of individual tasks of the global satellite navigation system (GLONASS / GPS) is impossible without using models of time and space from the General Theory of Relativity. <br><br>  So, a program is a solution of the problem before us written in a language understandable to some computer. <br><br><img src="https://habrastorage.org/storage2/eed/e2f/49e/eede2f49ebcb8b5935dff0a163ee5f05.gif"><br><br><h5>  Object Oriented Approach </h5><br>  Today, about 2,500 programming languages ‚Äã‚Äãhave been created for recording programs.  The history of their development is somewhat similar to the history of the development of human speech.  There is an opinion that the content of the first statements of a person consisted solely of the requirements of assistance that could be provided to him by another individual.  ‚ÄúIf the first statements of a person becoming express with our developed language, they would necessarily contain verbs in the imperative mood:‚Äú <i>give</i> ! ‚Äù,‚Äú <i>Carry</i> ! ‚Äù,‚Äú <i>Break</i> ! ‚Äù,‚Äú <i>Cut</i> ! ‚Äù,‚Äú <i>Beat</i> ! ‚Äù,‚Äú <i>lift</i> ! ‚Äù,‚Äú <i>pull</i> ! ‚Äùand so on.‚Äù  Moreover, these commands were accompanied by gestures that indicated exactly what this action should be applied to.  Well, very much like imperative programming language commands!  For example, assembler commands with precise indication of memory addresses or registers. <br><br>  A person first learns to distinguish one practical situation, taken as a whole, from another situation.  Separate elements of these situations (objects, on which actions are performed, actions, which are performed on objects) are distinguished later - as in practical activity a person became more and more familiar with the things around him, learned their properties and their relations to each other and to to the man himself.  Gradually, a person begins to select from an concrete situation an object of action (in programming, data) and the action itself (in programming, functions).  Mastering the ability to isolate the objects of action was a real revolution in the mental development of primitive man.  And this is very similar to the object-oriented approach (OOP) used in programming.  At least in its modern implementation in languages: C ++, Java, C #. <br><br>  With the help of natural language, a person materializes his mental models of the world in order to transfer them to another person.  With the help of OOP, the programmer materializes his mental models of the software product in order to transfer them to execution to the calculator.  But is the PLO really the main channel of our river?  Or is it just a quiet backwater before a sharp turn, which is characterized by a slow and sometimes reverse flow of water and which has already begun to swamp? <br><br>  The application of the PLO to the construction of mental models of the physical world has more than two thousand years of successful use history, which originated in the writings of Aristotle.  In the world of Aristotle, there are only single and specifically defined things with a given set of properties and related to one and only one category. <br><br>  Yes, now we have learned to say not just ‚Äú <i>carry,</i> ‚Äù but ‚Äú <i>carry firewood</i> ‚Äù or ‚Äú <i>carry stone</i> ‚Äù.  In their development, programming languages ‚Äã‚Äãhave settled on the fact that they have learned to distinguish objects ( <i>firewood and stone</i> ), but have not learned to distinguish actions on them.  And from the point of view of the programming language <i>men.carry (firewood)</i> and <i>men.carry (stone)</i> are different language units, unless <i>firewood</i> and <i>stone</i> objects have a common ancestor!  Simply implementing these ‚Äúinterface objects <i>that a person can wear</i> ‚Äù with these objects will not help us out, since these will be two implementations, and, therefore, there will also be two units of source code. <br><br><img src="https://habrastorage.org/storage2/2c0/4f6/7a5/2c04f67a505374c237f1dcd9b28e78ba.gif"><br><br>  One of the main limitations of OOP, which makes our programs more difficult than they could be, is hidden here, forcing us to use crutches in the form of design patterns to compensate for the innate lameness of OOP.  When we are trying to determine whether a particular software system design is suitable for us or not, we cannot consider this solution in isolation.  We must consider it in terms of reasonable assumptions about how this design will be used in consequence.  If we translate this thesis into the language of " <i>firewood</i> " and " <i>stones</i> ", then this will sound, approximately, as follows.  When designing the ‚Äú <i>firewood</i> ‚Äù and ‚Äú <i>stone</i> ‚Äù software objects, we should be aware of the Lord‚Äôs plans for improving the software system.  Namely, we must assume that He will not limit himself to making firewood and stones, but on the sixth day of the creation of the world he will create a person who will drag them. <br><br><h6>  About inheritance </h6><br>  Another limitation of OOP is that each object belongs to one and only one hierarchy (" <i>is a</i> ") of classes, even with the possibility of multiple inheritance and has once and for all a given set of properties.  For example, a red rose is a flower, and a flower is a plant.  This contradicts the reality in which objects can evolve, acquire new properties, and lose pre-existing ones.  For example, a rose can be a commodity, and then a gift.  What class heir should a rose present be?  Rose-goods or rose-flower?  Another example.  A person is born with a very limited set of properties: to have age, weight, height, squeak, eat and spoil the diaper.  As time goes by, he acquires new sets of properties: a student of a school, a buyer, a passenger, a soldier, a student, an employee, an entrepreneur, a spouse, a parent, etc.  And perhaps not gaining.  For example, not every person serves in the army, studies in high school, marries and becomes a father or an entrepreneur.  Or loses.  For example, he finished studying, served in the army or divorced.  Consequently, the same object must be able to belong to different classes and this set of classes must be dynamic, i.e.  change in the course of the evolution of the object and the software system itself.  As a rule, restrictions are imposed on the set of classes to which the object belongs.  For example.  To become a soldier, a person must reach 18 years.  And if a person is a student, in order to become a husband, you must pass the mat. <br><br><img src="https://habrastorage.org/storage2/d57/cf2/cc0/d57cf2cc0c4808f3362e2c6c525fa566.gif"><br><br><h5>  About messages </h5><br>  Another odd PLO: ‚ÄúBehavior is how an object acts and reacts;  behavior is expressed in terms of the state of the object and the transmission of messages.  But, wait, if I simulate a collision between two cars, which of them receives and sends messages? <br><br><img src="https://habrastorage.org/storage2/613/e5e/419/613e5e419b56abe4c764a387214687a3.gif"><br><br><h5>  About properties </h5><br>  "The state of an object is characterized by a list (usually static) of all the properties of a given object and the current (usually dynamic) values ‚Äã‚Äãof each of these properties."  But does the property of the object belong to the object itself?  I will argue that no.  For example, we say this apple is green.  But what does this really mean?  This means that if we direct a light source close to the spectrum to sunlight, this apple will absorb all wavelengths except those that correspond to the green color range, and an observer who is able to perceive the entire spectrum of sunlight will see only reflected green light.  If the source or observer has a different range, for example, infrared, then the color of the apple will be black.  Thus, a property is not an integral characteristic of an object, but is a possible manifestation of an object when it interacts with other objects.  For example, the property of an object ‚Äúto float on the surface‚Äù may manifest itself in interaction with water and not manifest itself in interaction with alcohol. <br><br><img src="https://habrastorage.org/storage2/788/781/5cd/7887815cd8647ef649fe56842ba3bd0c.gif"><br><br><h5>  About aggregation </h5><br>  We say: a mop "consists of" (aggregates) brushes and sticks.  But what does this mean?  If we consider a mop as an object capable of moving in space, then in this case the aggregation does not manifest itself in any way, we consider the mop as an atomic object and we are only interested in its total mass and dimensions.  But if we load the mop and test it for strength, then the aggregation will manifest as the interaction of its structural components of the brush and stick and the result of the test will depend on whether this interaction occurs through hammered nails or by grooves, spikes and glue.  Therefore, aggregation is also the interaction of objects. <br><br><img src="https://habrastorage.org/storage2/328/37f/f08/32837ff088b01c0eedc81bd888ca7369.gif"><br><br><h5>  About association </h5><br>  If we say that object (a) is the husband of object (b), then we declare that objects (a and b) are related by association.  How can this connection be manifested?  First, this connection itself is the result of the interaction of the three objects (a), (b) and the object (c) (Civil Registry Office, a certain registrar, where this connection is born, and there, by the way, it may disappear).  Secondly, it can manifest itself in interactions of objects, for example, (a and b): the joint spending of the family budget or the birth and upbringing of a common child.  It makes no sense to ask <i>a.is Married</i> (b), he may lie.  But the function <i>isMarried</i> (a, b, c) is quite meaningful.  Consequently, connections, like properties, are possible interactions between objects. <br><br><img src="https://habrastorage.org/storage2/12a/9b3/123/12a9b31233fd996a4aafbdd6aac20d38.gif"><br><br><h5>  About identity </h5><br>  "Identity is a property of an object that distinguishes it from all other objects."  What should really correspond to this statement?  Suppose I repainted my car.  For me, he certainly remained the same.  But for the traffic police it will be a completely different object, which will receive a new state registration number.  Another example.  With the car removed the wheels.  Did the car stay the same?  And if the engine?  And when will the car stop being the same?  Identity arises only when binding specific objects.  Each mop will consist of a very specific brush and stick.  Each husband will have a very specific wife, and each client will have his own copy of a bank account. <br><br><img src="https://habrastorage.org/storage2/88a/c9a/cf8/88ac9acf890a7b67ab359e8e360b08d1.gif"><br><br>  So, in our mental world there are no objects and their properties.  And there are structures and their interactions.  If we simulate road traffic, then cars should be considered as elementary nodes of the structure that, entering into interaction (overtaking, cutting, braking), consistently change their coordinates in phase space (speed, position).  On the other hand, cars cease to be elementary nodes of the structure as soon as we begin to consider their interaction in a collision.  We must move to a lower structural level.  At this level, the elementary units should be: bumper, body, frame, engine, and so on.  components, as well as methods of their connection (bolts, welding, etc.).  The fact of the allocation of a structure node is an act of cognitive activity (Gestalt theory), which depends on the problem being solved. <br><br><h5>  On the ontology of Ludwig Wittgenstein </h5><br><br>  The world of <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2582%25D0%25B3%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD,_%25D0%259B%25D1%258E%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B3">Wittgenstein is</a> not the world of things as in Aristotle.  If for Aristotle the essence of language is noun, then according to Wittgenstein the essence of language is sentence.  Language, according to Wittgenstein, is not a set of names or properties, but consists of sentences in which the interactions of objects are expressed.  In the world of Wittgenstein, facts are primary - interactions between objects, and things are determined by the totality of their possible interactions.  Such a view of the world very well corresponds to the modern category theory, in which morphisms set the interaction of objects, and functors determine the evolution of the model over time. <br><br>  In contrast to the static world of Aristotle, the world of Wittgenstein is dynamic.  In the course of the evolution of the world facts can be added and the idea of ‚Äã‚Äãthings will change.  Thanks to this interpretation of the world, the thing appears not as something given, frozen, quite definite, but as some entity with fuzzy, changeable boundaries.  Software systems dynamically evolve like Wittgenstein‚Äôs world.  In the course of the development of the software system, developers add new potential interactions to objects, which expand their property sets and relationships. <br><br><img src="https://habrastorage.org/storage2/a23/554/15e/a2355415ee371124984b0abf72661d87.gif"><br><br>  Wittgenstein introduced the concept of "language game" - a single whole: the language and actions with which it is intertwined.  ‚ÄúHow many offer types are there?  Let's say a statement, a question, a command?  There are countless such types and endlessly diverse uses of all that we call "signs", "words", "sentences".  And this multiplicity is not something sustainable, once and for all given ... ".  Do we not play a similar language game when we describe a domain model using user stories? <br><br><h5>  About domain-specific language (Domain Specific Language, DSL) </h5><br><br>  It seems to me that in the future programming environments will mostly resemble CAD systems with embedded DSL.  Software systems should be created by application specialists, for example, an engineer will assemble a software model for studying the flight characteristics of a new aircraft from a ready-made element base: fuselage, wings, engines, connecting mounts and models of their interaction with the incoming flow.  Similarly, they will be assembled from ready-made components and business applications: accounting, logistics, warehouse, manufacturing, etc. <br><br>  Does this mean that for each domain we need to create our own unique DSL?  Yes and no.  Yes, in the sense that almost all established areas of people's professional activity, for example, mathematics, medicine, biology, have their own specific language, so in each subject area we will have to create our own DSL to describe specific models for solving specific problems.  No, because professional languages ‚Äã‚Äãare built on the basis of a single syntax of a natural language, and there should be a universal syntax for describing mental models based on the general laws of human thinking. <br><br>  Attempts to create a universal DSL syntax were made more than once.  I will list only the most notable of them: <a href="http://en.wikipedia.org/wiki/Intentional_programming">one</a> and <a href="http://www.jetbrains.com/mps/docs/Language_Oriented_Programming.pdf">two</a> .  I don‚Äôt know examples of serious practical application of the proposed approaches.  Maybe this is because they are trying to simulate the static world of the objects of Aristotle?  It is quite possible that the dynamic world of Wittgenstein's interactions and the categorical approach, reflecting the fundamental features of our thinking, can form the basis for the universal syntax of DSL. <br><br>  DSL like DNA should describe: <br><br><ol><li>  scenarios for assembling a model from finished components; </li><li>  initialization of the initial state; </li><li>  laws of model evolution over time. </li></ol><br><br><img src="https://habrastorage.org/storage2/865/ca5/d56/865ca5d56a79ef4ba5d501ce6f2987f4.gif"><br><br>  The main building block of the language should be the interaction in which the properties of objects manifest, their states change and new instances are born.  Each object in the course of evolution can be supplemented by a new set of potential interactions and this addition should not affect the previously created code.  The appearance of a ‚Äú <i>person</i> ‚Äù in the world of ‚Äú <i>stones</i> ‚Äù and ‚Äú <i>firewood</i> ‚Äù with this approach will lead to the creation of a new interaction carry ( <i>carrier, thing, space, gravitation</i> ) ;.  The <i>carrier</i> element must implement interactions: <i>take (carrier, thing)</i> and <i>move (carrier, thing, space)</i> .  And the <i>thing</i> element should implement the interaction: <i>weight (thing, gravitation)</i> and <i>shape (thing, space)</i> .  In this case, our model of action to bear will be quite universal.  The method will not change from the fact that a person implements the interaction take hands, the animal - his teeth, and the crane - a special capture.  Therefore, we can easily replenish our software system with any elements that implement the necessary interactions for the <i>carrier, thing</i> and we do not need to change our universal function.  What could it be like?  Perhaps, the future DSL will be similar to Mixin-technology or Anemic Domain Model (by the way, Martin Fowler called this model anti-pattern), or D. Knuth's ‚Äú <a href="http://www.literateprogramming.com/knuthweb.pdf">verbal programming</a> ‚Äù, where the narrative description of interactions will be interpreted as algorithms and data structures. <br><br><img src="https://habrastorage.org/storage2/5b5/02b/65c/5b502b65c034f27cdc212c5c571fb497.gif"><br><br><h5>  findings </h5><br>  Programming is a new kind of human activity that is mistakenly related to engineering. <br>  Engineering is the area where the laws of natural sciences, mathematics, physics, and chemistry are applied to the design of new products.         ,       ,            . <br><br>  ‚Äì             ,    : , , ,   .  -      ,   . ,    , -     . </div><p>Source: <a href="https://habr.com/ru/post/185310/">https://habr.com/ru/post/185310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185290/index.html">Building scalable applications in TypeScript. Part 2.5 - Bug Work and Delegates</a></li>
<li><a href="../185292/index.html">Common sense against marketers. Letter to Stephen Elop with a proposal to resurrect the Nokia 3310</a></li>
<li><a href="../185294/index.html">Drawings in SVG format. Part 3. - Draft Standard</a></li>
<li><a href="../185298/index.html">The creator of the Raspberry Pi will receive a silver medal from the Royal Academy of Engineering</a></li>
<li><a href="../185304/index.html">Another "success" of the Russian cosmonautics</a></li>
<li><a href="../185312/index.html">Smartmontools for Windows</a></li>
<li><a href="../185314/index.html">2GIS for Android: good news</a></li>
<li><a href="../185316/index.html">HTML5 mobile application: error or success. Attempt # 0</a></li>
<li><a href="../185318/index.html">Failsafe system based on mySQL replication and CARP network protocol</a></li>
<li><a href="../185320/index.html">Another example of using closures in PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>