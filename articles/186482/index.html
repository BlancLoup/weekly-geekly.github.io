<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Honest glow and speed</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably everyone who has even worked a little bit with Photoshop has seen the outer glow effect for the layer and tried to play with it. In Photoshop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Honest glow and speed</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/53d/554/6cc/53d5546cc2b2d80ae5983f4ea8b9693a.png" align="left">  Probably everyone who has even worked a little bit with Photoshop has seen the outer glow effect for the layer and tried to play with it.  In Photoshop there are 2 techniques of this very outer glow.  Soft and precise.  Soft was not so interesting to me, but looking at precise - I thought. <br><br>  It looks like this: <br><img src="https://habrastorage.org/storage2/e6b/1d6/7ad/e6b1d67ad24fe26c0aa63e1c3e8fce81.png"><br>  This is a single pixel line.  A gradient roughly speaking - reflects the distance to the nearest pixel of the image.  This very distance could be very tasty for building various effects.  This and all contours, and its own gradients, and <div class="spoiler">  <b class="spoiler_title">even gas discharge effects around and so on.</b> <div class="spoiler_text">  <a href="">An example of the effect</a> you can get if you have a distance map.  The example uses OpenGL + GLSL, written in Delphi </div></div><br>  The main problem of such a glow is the complexity of calculations for large sizes.  If we have a glow of 100 pixels, then we need to check 100 * 100 neighboring pixels for each pixel of the image.  And for example, for an image of 800 * 600, this will be only 4,800,000,000 checks. <br><br>  However, photoshop does not suffer from this, and beautifully builds an accurate glow of even large (up to 250) sizes.  So there is a solution.  And I was curious to find him.  I did not manage to google the fast algorithm of such a glow.  Most of the algorithms use blur to build a glow, but we all know that a single-pixel line will not give us the same effect as in the picture, it will just turn out. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So I drove the bike. <br><a name="habracut"></a><br><h5>  What we do </h5>  Let's get started before we decide on terms. <br>  We will build a 100 pixel glow for the png image.  Here it is: <br><img src="https://habrastorage.org/storage2/08a/91b/039/08a91b0393e6304047e75f1b63285501.png"><br>  the original image will be archived.  Also, in order to put it in a topic with a picture, I filled the background with black.  In the original - <a href="">it</a> is <a href="">a white image on a transparent background.</a> <br>  I will call all pixels existing and not existing.  The existing pixel is an alpha which is greater than 0, and in fact it also participates in the construction of the glow. <br><br><h5>  Stage 1 </h5>  In fact, there is no need for each pixel to look for the closest existing pixel within a radius of 100 pixels.  Each existing pixel simply throws on the neighboring roughly this glow: <br><img src="https://habrastorage.org/storage2/6d1/8ca/486/6d18ca486d3a7ab0e2d6f58594fe9f36.png"><br>  At this glow color means the distance to the pixel.  Thus, it all comes down to ‚Äúdrawing‚Äù the glow of the image for each existing pixel.  And so that the point of the resulting effect is the nearest - we ‚Äúdraw‚Äù only the minimum value. <br>  Throwing away non-existent pixels, we have reduced the glow drawing time, but it is still huge.  What to do next? <br><br><h5>  Stage 2 </h5>  If we look closely, we can see that if a point from 4 sides is surrounded by existing pixels: <br><img src="https://habrastorage.org/storage2/2ec/f19/772/2ecf197729d46469799d3942d49bccde.png"><br>  then it won't discard unique pixels at all.  All that we draw, processing the red dot, will be ground in each of the numbered zones with a neighboring pixel.  Thus, after analyzing the neighboring points, we can discard many existing points.  The result of this analysis is this image: <br><img src="https://habrastorage.org/storage2/a88/9d5/19b/a889d519b750816c94f6dce649ea23b0.png"><br>  White - existing points that were discarded.  Gray - points that will give a real glow.  Black - non-existent points. <br>  In fact, we only have the contour, from which we build the glow. <br><br>  So, our algorithm has become orders of magnitude faster, but it is still as slow as a turtle, compared to the implementation of Photoshop.  I have 100 pixels of glow for the image above was built for 2-3 seconds. <br><br><h5>  Stage 3 </h5>  The previous stages were quite trivial.  The work of the algorithm was significantly accelerated, but we still have a crazy overdraw for the pixels on the border. <br>  Let's take a close look at the situation when 3 pixels from which we need to throw away the glow go next to each other: <br><img src="https://habrastorage.org/storage2/510/8f2/9a3/5108f29a37527fc9d6237aa988aadd1e.png"><br>  In fact, out of 3 (red) pixels, bright red will give only 1 actual line, all other information will be redrawn when drawing a glow for dark red pixels.  I will not give a geometric proof of this, for the reader, I think it is quite obvious.  If we move 1 pixel to the side like this: <br><img src="https://habrastorage.org/storage2/5f4/319/2f2/5f43192f22afdab98445f988e8bd678d.png"><br>  then we lose the left "ray".  There will be 1 single pixel, which may be closer to bright red.  In addition, we have a whole new area where we have to drop the glow from the bright red pixel: <br><img src="https://habrastorage.org/storage2/f4b/401/87c/f4b40187cc35163041940513a1b58399.png"><br>  Shift the bottom pixel to the side and see what happens: <br><img src="https://habrastorage.org/storage2/2b0/1ac/ff9/2b01acff9dba4ee6474f238d1b339a3d.png"><br>  We have 2 beams left again. <br>  Having twisted various situations, and carefully thinking, I came to the conclusion.  A pixel will give a ray to the side if there are no three adjacent pixels.  Example for neighboring pixels: <br><img src="https://habrastorage.org/storage2/6c6/099/5b5/6c60995b52d4b11dba7279d4d1b51ed1.png"><br>  the ray to the left will be if there are no adjacent pixels with indices 7, 0, 1 <br>  ray left up - if there are no adjacent pixels with indices 0, 1, 2 <br>  ray up - if there are no adjacent pixels 1, 2, 3 <br>  etc. <br>  In addition, between the rays, too, there are pixels.  So, they will be only when there are 2 adjacent beams.  Those.  according to the above mentioned picture: <br><img src="https://habrastorage.org/storage2/f4b/401/87c/f4b40187cc35163041940513a1b58399.png"><br>  We have a ray right up and a ray right.  Between them you will need to draw glow pixels. <br><br>  Thus, we can significantly reduce overdraw. <br><br><h5>  Implementation </h5>  I implemented this algorithm on Delphi using the <a href="http://imaginglib.sourceforge.net/">Vampyre Imaging Library</a> .  At first, I‚Äôm cooking in memory already flashed in the article <div class="spoiler">  <b class="spoiler_title">glow image</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/6d1/8ca/486/6d18ca486d3a7ab0e2d6f58594fe9f36.png"></div></div><br>  then I prepare <div class="spoiler">  <b class="spoiler_title">image bordering pixels</b> <div class="spoiler_text"><img src="https://habrastorage.org/storage2/4bc/28a/b3b/4bc28ab3b19b00061a4725ba403bedb0.png">  they are gray, you can see if you increase </div></div><br>  glow image I hit logically in 16 zones. <br><img src="https://habrastorage.org/storage2/946/fe1/bd5/946fe1bd5274d795ced9847ca48d665a.png"><br>  The function in the DrawGlowPart code is able to draw only a strictly defined zone by its index.  I had to tinker with the cycles for each zone.  In addition, the DrawGlowPart function can draw a zone with an index of 16. This is 1 pixel around any existing pixel that we draw.  This image shows that this pixel to the left of bright red: <br><img src="https://habrastorage.org/storage2/f4b/401/87c/f4b40187cc35163041940513a1b58399.png"><br><br>  The result of the fuss is such an ominous picture: <br><img src="https://habrastorage.org/storage2/27b/da9/e4e/27bda9e4efde96662cfafcda7407a693.png"><br>  And in just ~ 150 ms on my machine.  This is already human. <br>  This algorithm fits well on the GPU, which I will try to do sometime in my spare time in order to get even greater growth and the opportunity to build such glow in real-time.  Alas, 150ms is not yet a real-time time, but this is already acceptable for load time. <br><br><h5>  In photoshop </h5>  In Photoshop, the Glou is obviously not implemented according to my algorithm, and I won‚Äôt be surprised if I noticefully blasted my code.  If you look at the glow from one pixel in Photoshop, then on a fairly good monitor you can see its ‚Äúpolygonality‚Äù: <br><img src="https://habrastorage.org/storage2/605/371/12b/60537112b0605763b24dae5fa4c1c3d5.png"><br>  I suspect that the developers build a contour on the boundary pixels, then they shift it and get a polygon.  I also suspect that this will reduce overdraft even more.  If anyone has materials on this topic - I will be glad to read. <br><br><h5>  Links to the article </h5>  1. <a href="">The implementation of the algorithm</a> .  Binary file + source codes.  Compilation will require the <a href="http://imaginglib.sourceforge.net/">Vampyre Imaging Library</a> .  The first parameter is the input file.  2nd - the size of the glow in pixels. <br>  2. <a href="">An example of the effect</a> .  It does not generate a glow in real time, but uses a previously generated one.  For rendering, OpenGL + GLSL is used. </div><p>Source: <a href="https://habr.com/ru/post/186482/">https://habr.com/ru/post/186482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186462/index.html">Reddit user created a "viral" animated video about the NSA's total surveillance based on the Pixar screensaver.</a></li>
<li><a href="../186464/index.html">Interview with an individual developer on Delphi</a></li>
<li><a href="../186468/index.html">(Video) Booth Demonstrations: ZyXEL X8004 Universal IP Telephony Communication System</a></li>
<li><a href="../186470/index.html">(Video) HP Networking Networking Products and Solutions</a></li>
<li><a href="../186476/index.html">New summer version of ‚ÄúSimple business‚Äù 1.8.1.2. "Fort Knox": identifying the number, linking tables, speeding up work with documents and cases</a></li>
<li><a href="../186484/index.html">jPutty for layout, jQuery plugin</a></li>
<li><a href="../186486/index.html">The simplest implementation of cross-platform multiplayer on the example of the evolution of a single .NET game</a></li>
<li><a href="../186488/index.html">MikroTik + port knocking over ICMP</a></li>
<li><a href="../186490/index.html">Roskomnadzor plans to block resources with information about blocked resources</a></li>
<li><a href="../186492/index.html">Again on bioinformatics: the assembly of bacterial genomes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>