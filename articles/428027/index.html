<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I tried to make a static analyzer GLSL (and what went wrong)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I was preparing for Ludum Dare and made a simple game where I used pixel shaders (I didn't bring others into the Phaser engine). 
 What are shade...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I tried to make a static analyzer GLSL (and what went wrong)</h1><div class="post__text post__text-html js-mediator-article"><p>  Once I was preparing for Ludum Dare and made a simple game where I used pixel shaders (I didn't bring others into the Phaser engine). </p><br><div class="spoiler">  <b class="spoiler_title">What are shaders?</b> <div class="spoiler_text"><p>  Shaders are programs on the SI-like language GLSL, which are executed on a video card.  There are two types of shaders, in this article we are talking about pixel (they are also "fragment", fragment shaders), which can be very roughly represented in this form: </p><br><pre><code class="hljs lisp">color = pixelShader(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, ...other attributes)</code> </pre> <br><p>  Those.  the shader is executed for each pixel of the displayed image, determining or specifying its color. <br>  Introductory can be read on another article on Habr√© - <a href="https://habr.com/post/333002/">https://habr.com/post/333002/</a> </p></div></div><br><p>  Having tested it, I threw the link to a friend, and I received a screenshot from him with the question "is this normal?" </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ys/ti/qp/ystiqpls-jpsxgixk9blbocn6u8.png"></div><br><p>  No, it was not normal.  Looking carefully at the shader code, I found an error in the calculations: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; M) { realColor = mix(color1,color2, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span> - t / R1, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); }</code> </pre> <br><p>  Since  Since the constant R1 was less than M, in some cases in the first argument of pow, a number less than zero was obtained.  The square root of a negative number is a mysterious thing, at least for the GLSL standard.  My video card was not embarrassed, and it somehow got out of this position (it seems, by returning from pow 0), but at a friend it turned out to be more discriminating. </p><br><p>  And then I wondered: can I avoid such problems in the future?  No one is immune from mistakes, especially those that are not reproduced locally.  You cannot write unit tests on GLSL.  At the same time, the transformations inside the shader are quite simple - multiplications, divisions, sines, cosines ... Is it really impossible to track the values ‚Äã‚Äãof each variable and make sure that under no circumstances does it go beyond the permissible limits of the values? </p><br><p>  So I decided to try static analysis for GLSL.  What came out of it - you can read under the cut. </p><br><p>  Immediately I will warn you: it was not possible to get some finished product, only a training prototype. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-analiz">  Preliminary analysis </h2><br><p>  After a bit of study of the existing articles on this topic (and at the same time finding out that the topic is called Value Range Analysis), I was glad that I had GLSL, and not some other language.  Judge for yourself: </p><br><ul><li>  no "dynamics" - references to functions, interfaces, automatically deducible types, etc. </li><li>  no direct work with memory </li><li>  no modules, linking, late binding - the source code of the shader is available entirely <br>  ranges for incoming values ‚Äã‚Äãare generally well known. </li><li>  some data types, and even those revolve around float.  int / bool is rarely used, and it‚Äôs not so important to keep track of them </li><li>  Ifs and cycles are rarely used (due to performance issues).  if cycles are used, then more often simple counters for traversing an array or repeating a certain effect several times.  Nobody will write such horror in GLSL (I hope). </li></ul><br><pre> <code class="python hljs">//   - https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/RangeAnalysis.pdf k = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> k &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>: i = <span class="hljs-number"><span class="hljs-number">0</span></span> j = k <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; j: i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> j = j ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span> k = k + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  In general, given the limitations of GLSL, the problem seems to be solved.  The basic algorithm is as follows: </p><br><ol><li>  parse the shader code and build a sequence of commands that change the values ‚Äã‚Äãof any variables </li><li>  knowing the initial ranges for variables, go through the sequence, updating the ranges when they change </li><li>  if the range violates any given boundaries (for example, a negative number may come to pow, or gl_FragColor will come to a red component in the red color, something more than 1. will come in), a warning should be shown </li></ol><br><h2 id="ispolzuemye-tehnologii">  Used technologies </h2><br><p>  Here I had a long and painful choice.  On the one hand, my main scop is to check WebGL shaders, so why not javascript - to run everything in the browser during development.  On the other hand, I have been planning to get off the Phaser for a long time and try another engine like Unity or LibGDX.  There will also be shaders, but there will be no javascript anymore. </p><br><p>  And on the third hand, the task was done primarily for entertainment.  And the best entertainment in the world is a zoo.  Therefore: </p><br><ol><li>  parsing GLSL-code is made on javascript.  It's just that I quickly found the GLSL parsing library in AST on it, and the test UI seems to be as usual web-based.  AST turns into a sequence of commands that is sent to ... </li><li>  ... the second part, which is written in C ++ and compiled into WebAssembly.  I decided this way: if I suddenly want to fasten this analyzer to some other engine, with the C ++ library this should be done the easiest way. </li></ol><br><div class="spoiler">  <b class="spoiler_title">A few words about the toolkit</b> <div class="spoiler_text"><ul><li>  as the main IDE, I took the Visual Studio Code and in general I am satisfied with it.  I need a little bit of happiness - the main thing is that Ctrl + Click works and autocomplete when typing.  Both functions work fine in both C ++ and JS parts.  Well, the ability to not switch between different IDEs among themselves is also great. </li><li>  to compile C ++ in WebAssembly, the <a href="https://www.leaningtech.com/cheerp/">cheerp</a> tool is <a href="https://www.leaningtech.com/cheerp/">used</a> (it is paid, but free for open-source projects).  I have not encountered any problems with its use, except that the code has optimized it is rather strange, but here I am not sure whose fault it is - of the cheerp itself or of the clang compiler it uses. </li><li>  for unit tests in C ++ took the good old gtest </li><li>  for the assembly of js in bundle took a certain microbundle.  He met my requirements for ‚ÄúI want 1 npm-package and a couple of command line flags‚Äù, but not without problems, alas.  Let's say watch falls on any error while parsing incoming javascript with the message <code>[Object object]</code> , which does not help much. </li></ul></div></div><br><p>  Everything, now it is possible to go. </p><br><h2 id="korotko-o-modeli">  Briefly about the model </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/hf/8s/chhf8sgclvkleyx_kwasvr74hz8.png"></div><br><p>  The analyzer keeps in memory a list of variables that occur in the shader, and for each stores the current possible range of values ‚Äã‚Äã(such as <code>[0,1]</code> or <code>[1,‚àû)</code> ). </p><br><p>  The analyzer accepts the following type of workflow: </p><br><pre> <code class="hljs matlab">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> opCode: <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> arguments: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,-,-,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,-,-]</code> </pre> <br><p>  Here, we call the sin function, input variables with id = 3 and 4, and the result is written to variables 1 and 2. This call corresponds to the GLSL function: </p><br><pre> <code class="hljs lisp">vec2 a = sin(<span class="hljs-name"><span class="hljs-name">b</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Note the empty arguments (marked with "-").  In GLSL, almost all built-in functions are overloaded for different sets of input types, i.e.  there are <code>sin(float)</code> , <code>sin(vec2)</code> , <code>sin(vec3)</code> , <code>sin(vec4)</code> .  For convenience, I bring all the overloaded versions to one form - in this case, <code>sin(vec4)</code> . </p><br><p>  The output of the analyzer produces a list of changes for each variable, like </p><br><pre> <code class="hljs vhdl">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> branchId: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>: [-<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  What does "variable 2 in line 10 in branch 1 have a range from -1 to 1 inclusive" (what is a branch (branch) we will talk about later).  Now you can beautifully highlight the ranges of values ‚Äã‚Äãin the source code. </p><br><h2 id="horoshee-nachalo">  Good start </h2><br><p>  When the AST-tree has already started somehow turning into a list of commands, it is time to implement the standard functions and methods.  There are quite a few of them (and they still have a lot of overloads, as I wrote above), but in general they have predictable range conversions.  Let's say that for such an example everything is pretty obvious: </p><br><pre> <code class="hljs ruby">uniform float angle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; (-‚àû,‚àû) /<span class="hljs-regexp"><span class="hljs-regexp">/... float y = sin(angle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [-1,1] float ynorm = 1 + y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [0,2] gl_FragColor.r = ynorm /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/aj/0f/vbaj0fdcx0nnk3lc2qti7egg7yq.png"></div><br><p>  The red channel of the output color is in the acceptable range, there are no errors. </p><br><p>  If you cover more built-in functions, then for half of the shaders, such an analysis is enough.  But what about the second half - with the conditions, cycles and functions? </p><br><h2 id="vetvleniya">  Branching </h2><br><p>  Take for example such a shader. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 uv; <span class="hljs-comment"><span class="hljs-comment">// [0,1] void main() { float a = texture2D(uSampler, uv).a; // -&gt; [0,1] float k; // -&gt; ? if (a &lt; 0.5) { k = a * 2.; } else { k = 1. - a; } gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  The variable <code>a</code> is taken from the texture, and therefore the value of this variable is from 0 to 1. But what values ‚Äã‚Äãcan <code>k</code> take? </p><br><p>  You can go on a simple path and "merge branches" - count the range in each case and give the total.  For the if branch, we get <code>k = [0,2]</code> , and for the else branch, <code>k = [0,1]</code> .  If you combine, it turns out <code>[0,2]</code> , and you need to give an error, because  values ‚Äã‚Äãgreater than 1 fall into the output color <code>gl_FragColor</code> . </p><br><p>  However, this is an obvious false alarm, and for a static analyzer there is nothing worse than false positives - if it is not disabled after the first shout of "wolves", then after the tenth exactly. </p><br><p>  It means that we need to process both branches separately, and in both branches we should specify the range of the variable <code>a</code> (although nobody has formally changed it).  Here is what it might look like: </p><br><p>  Branch 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0, 0.5) k = a * 2.; //k = [0, 1) gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Branch 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0.5, 1] k = 1. - a; //k = [0, 0.5] gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Thus, when the analyzer encounters a certain condition that behaves differently depending on the range, it creates branches (branches) for each of the cases.  In each case, he refines the range of the source variable and moves on through the list of commands. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/fp/dy/n7fpdy2xtg92oy5f0qsl7p8thz4.png"></div><br><p>  It should be clarified that the branches in this case are not related to the if-else construct.  Branches are created when a variable is divided into sub-ranges by a range, and the cause may be an optional conditional statement.  For example, the step function also creates branches.  The next GLSL shader does the same thing as the previous one, but does not use branching (which, by the way, is better in terms of performance). </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> k = mix(a * <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>. - a, step(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, a)); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>.) * k;</code> </pre> <br><p>  The step function should return 0 if a &lt;0.5 and 1 otherwise.  Therefore, branches will be created here too - similar to the previous example. </p><br><h2 id="utochnenie-drugih-peremennyh">  Refinement of other variables </h2><br><p>  Consider the slightly modified previous example: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-comment"><span class="hljs-comment">// -&gt; [0,1] float b = a - 0.5; // -&gt; [-0.5, 0.5] if (b &lt; 0.) { k = a * 2.; // k,a -&gt; ? } else { k = 1. - a; }</span></span></code> </pre> <br><p>  Here the nuance is as follows: the branching occurs in the variable <code>b</code> , and the calculations take place with the variable <code>a</code> .  That is, within each branch there will be a correct value of the range <code>b</code> , but completely unnecessary, and the original value of the range <code>a</code> is completely incorrect. </p><br><p>  However, the analyzer saw that the range <code>b</code> was obtained by calculating from <code>a</code> .  If this information is memorized, then with branching, the analyzer can go through all the initial variables and refine their range by performing the reverse calculation. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/lb/sz/pilbszwvjnellonuoosc_oux7wq.png"></div><br><h2 id="funkcii-i-cikly">  Functions and Loops </h2><br><p>  In GLSL, there are no virtual methods, function pointers, or even recursive calls, so each function call is unique.  Therefore, the easiest way is to insert the body of the function at the call (zainlaynit, in other words).  This will fully comply with the sequence of command execution. </p><br><p>  With cycles all the more difficult, because  Formally, GLSL fully supports a C-like for loop.  However, most often cycles are used in the simplest version, like this: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {}</code> </pre> <br><p>  Such cycles are easy to "deploy", i.e.  insert the loop body 12 times in succession.  As a result, thinking, I decided so far to support only this option. </p><br><p>  The advantage of this approach is that commands can be issued by the stream to the analyzer, without requiring it to memorize some fragments (such as function bodies or cycles) for further reuse. </p><br><h2 id="vsplyvshie-problemy">  Emerging issues </h2><br><h3 id="problema-1-slozhnost-ili-nevozmozhnost-utochneniya">  Problem # 1: Difficulty or Impossibility of Clarification </h3><br><p>  Above, we considered cases when, when specifying the value for one variable, we made conclusions about the values ‚Äã‚Äãof another variable.  And this problem is solved when addition / subtraction operations are involved.  But, say, what about trigonometry?  For example, the following condition: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    a? }</span></span></code> </pre> <br><p>  How to count a range inside if?  It turns out an endless set of ranges with step pi, with which then it will be very inconvenient to work. </p><br><p>  And maybe this situation: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-comment"><span class="hljs-comment">// [-10,10] float b = getAnotherValue(); //[-20, 30] float k = a + b; if (k &gt; 0) { //a? b? }</span></span></code> </pre> <br><p>  Refine the ranges of <code>a</code> and <code>b</code> in the general case will be unrealistic.  And, therefore, false positives are possible. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/z9/ea/7ez9eady082-nfgem7j0c65hslk.png"></div><br><h3 id="problema-2-zavisimye-diapazony">  Issue # 2: Dependent ranges </h3><br><p>  Consider this example: </p><br><pre> <code class="hljs pgsql">uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> //-&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-type"><span class="hljs-type">float</span></span> val2 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; gl_FragColor = vec4(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - val2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/0m/jo/gh0mjodwd1oqeoh32mcdkollcyg.png"></div><br><p>  To begin with, the analyzer considers the range of the variable <code>val2</code> - and it is expected to be <code>[0,1] - 1 == [-1, 0]</code> </p><br><p>  However, then, considering the <code>value - val2</code> , the analyzer does not take into account that <code>val2</code> was derived from <code>value</code> , and works with ranges as if they are independent of each other.  Receives <code>[0,1] - [-1,0] = [0,2]</code> , and reports an error.  Although in reality he was supposed to get a constant of 1. </p><br><p>  A possible solution: to store for each variable not just a history of ranges, but also the whole ‚Äúpedigree‚Äù - from which variables was dependency, which operations, and so on.  Another thing is that "expanding" this genealogy will be difficult. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/47/-_/qb/47-_qbz4nhcsbbfo_8wvtepll94.png"></div><br><h3 id="problema-3-diapazony-zavisimye-neyavno">  Problem # 3: Dependent implicit ranges </h3><br><p>  Here is an example: </p><br><pre> <code class="hljs lisp">float k = sin(<span class="hljs-name"><span class="hljs-name">a</span></span>) + cos(<span class="hljs-name"><span class="hljs-name">a</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Here the analyzer will assume that the range is <code>k = [-1,1] + [-1,1] = [-2,2]</code> .  What is wrong, because  <code>sin(a) + cos(a)</code> for any <code>a</code> lies in the range <code>[-‚àö2, ‚àö2]</code> . </p><br><p>  The result of the calculation of <code>sin(a)</code> formally independent of the result of the calculation of <code>cos(a)</code> .  However, they depend on the same range <code>a</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pf/wz/ne/pfwznek8x2iguen0bhyx0thwjuq.png"></div><br><h2 id="itogi-i-vyvody">  Results and conclusions </h2><br><p>  As it turned out, making value range analysis even for such a simple and highly specialized language as GLSL is not an easy task.  Covering the features of the language can still be enhanced: support for arrays, matrices and all embedded operations is a purely technical task, just requiring time-consuming.  But how to solve situations with dependencies between variables is still an unclear question for me.  Without solving these problems, false alarms are inevitable, the noise from which may ultimately outweigh the benefits of static analysis. </p><br><p>  Given what I‚Äôve encountered, I‚Äôm not particularly surprised by the absence of any well-known tools for value range analysis in other languages ‚Äã‚Äã- they have obviously more problems than in relatively simple GLSL.  At the same time in other languages, you can at least write unit tests, and then - no way. </p><br><p>  An alternative solution could be compiling from other languages ‚Äã‚Äãin GLSL - here recently there was <a href="https://habr.com/post/425027/">an article about the compilation from kotlin</a> .  Then you can write unit tests on the source code and cover all boundary conditions.  Or make a ‚Äúdynamic analyzer‚Äù, which will drive the same data that goes to the shader, through the original code on kotlin and warn about possible problems. </p><br><p>  So at this stage I stopped.  Alas, the libraries did not work out, but maybe this prototype will be useful to someone. </p><br><p>  Repository on github, for review: </p><br><ul><li>  <a href="https://github.com/AlexeyGrishin/glsl-value-range-analysis">https://github.com/AlexeyGrishin/glsl-value-range-analysis</a> </li></ul><br><p>  Try: </p><br><ul><li>  <a href="https://alexeygrishin.github.io/glsl-value-range-analysis/html/">https://alexeygrishin.github.io/glsl-value-range-analysis/html/</a> </li></ul><br><h2 id="bonus-osobennosti-sborki-webassembly-s-raznymi-flagami-kompilyatora">  Bonus: features of webassembly assembly with different compiler flags </h2><br><p>  Initially, I did the analyzer without using stdlib - in the old way, with arrays and pointers.  At that moment I was very worried about the size of the output wasm file, I wanted it to be small.  But starting from a certain moment I began to experience discomfort and therefore I decided to transfer everything to stdlib - smart pointers, normal collections, that's all. </p><br><p>  Accordingly, I was able to compare the results of building two versions of the library ‚Äî with and without stdlib.  Well and still to look, how good / badly cheerp (and clang used by it) optimizes the code. </p><br><p>  Therefore, I compiled both versions with different sets of optimization flags ( <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> and <code>-Oz</code> ), and for some of these versions I measured 3000 analysis speeds with 1000 branches.  It agree, not the biggest example, but for the comparative analysis it is enough. </p><br><p>  What happened to the size of the wasm file: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/u9/sc/qzu9sc7tg2jdz7v5-zfbvceqkv8.png"></div><br><p>  Surprisingly, the size of the option with "zero" optimization is better than almost everyone else.  I will assume that there is an aggressive inline of everything in the world in <code>O3</code> , which inflates the binary.  The expected version without stdlib turned out to be more compact, but not so much that <del>  endure such humiliation </del>  deprive yourself of the pleasure of working with convenient collections. </p><br><p>  By execution speed: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w_/dc/hs/w_dchsujm7zdc4rvzjsaiwpzeme.png"></div><br><p>  Now I see that <code>-O3</code> knowingly eats its bread, when compared with <code>-O0</code> .  At the same time, the difference between the versions with and without stdlib is practically absent (I did 10 measurements each time, I think the difference would have disappeared altogether). </p><br><p>  It is worth noting 2 points: </p><br><ul><li>  The graph shows the average values ‚Äã‚Äãof 10 consecutive analysis runs, but on all tests the very first analysis lasted 2 times longer than the others (i.e., say, 120ms, and the next ones are already around 60ms).  Some kind of initialization of WebAssembly probably occurred. </li><li>  With the <code>-O3</code> flag, I grabbed off some horribly strange bugs that I did not catch for other flags.  For example, the min and max functions suddenly started working in the same way - like min. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Thank you all for your attention. <br>  Let the values ‚Äã‚Äãof your variables never go beyond the allotted frame. <br>  But you - go out. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428027/">https://habr.com/ru/post/428027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428011/index.html">Space Zombie Songs</a></li>
<li><a href="../428019/index.html">Playing Mortal Kombat with TensorFlow.js</a></li>
<li><a href="../428021/index.html">Seals against neural networks. Or choose and run the neural network to recognize objects on the Raspberry Zero</a></li>
<li><a href="../428023/index.html">Basics of electrical safety in the design of electronic devices</a></li>
<li><a href="../428025/index.html">Connecting the paging file (SWAP) in MAC OS X when using an external SSD-drive as a system</a></li>
<li><a href="../428029/index.html">Digital events in Moscow from October 29 to November 4</a></li>
<li><a href="../428031/index.html">Integration of 3CX with 1C: Trade Management - a method of combining configurations</a></li>
<li><a href="../428033/index.html">In the US, legalized hacking of smart devices and on-board computers for the purpose of repair and upgrade</a></li>
<li><a href="../428035/index.html">Red Hat will be absorbed by IBM</a></li>
<li><a href="../428039/index.html">Government does not plan to legally protect network neutrality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>