<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implicitly typed fields in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, another very interesting question was asked on QW : why in C # there are implicitly typed local variables aka var , but there are no implicitly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implicitly typed fields in C #</h1><div class="post__text post__text-html js-mediator-article">  Today, another very <a href="http://rsdn.ru/forum/dotnet/4394093.flat.aspx">interesting question</a> was asked on <a href="http://rsdn.ru/">QW</a> : why in C # there are implicitly typed local variables aka <b>var</b> , but there are no implicitly typed fields? <br><br>  In fact, this state of affairs is not at all accidental;  so let's look at a few reasons why the compiler behaves this way and not otherwise. <br><a name="habracut"></a><br>  First, the ability to use <b>var</b> , to declare implicitly typed local variables, has never been a stand-alone feature.  When developing the C # language, no one set a goal to create a completely implicitly typed programming language, such as F #;  implicit typing was only one component (albeit not the least important) of a more general concept, known today under the abbreviation LINQ. <br><br>  Since during the development of LINQ, it was decided that tying a developer only to existing types is too ‚Äúevil‚Äù a limitation, when it was implemented, the developer was given the opportunity to return sequences of anonymous classes.  And if so, then without the use of implicitly typed variables this would not be possible: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#2B91AF">IEnumerable</font> &lt;Customer&gt; customers = <font color="#0000ff">null</font> ; <br> <font color="#008000">// ,    result ? IEnumerable&lt;??&gt;?</font> <br> <font color="#0000ff">var</font> result = <font color="#0000ff">from</font> c <font color="#0000ff">in</font> customers <br> <font color="#0000ff">where</font> c.Age &gt; 33 <br> <font color="#0000ff">select</font> <font color="#0000ff">new</font> {c.Name, c.Age}; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  However, using the <b>var</b> keyword in a type declaration would in no way help to solve a more global goal (I‚Äôm talking about LINQ again). <br><br>  Secondly, even if one does not climb too deeply into how difficult it would be for compiler writers (*) to realize such an opportunity, even without thinking, there are some drawbacks to its implementation and use.  The first drawback is due to the fact that implicitly typed fields will be bad friends with anonymous types. <br><br>  Let's imagine the following class: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> Foo <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">var</font> someField = <font color="#0000ff">new</font> {Name = <font color="#A31515">"name"</font> , Value = 12}; <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Since anonymous types in .Net are now implemented as internal-types, it is simply impossible to ‚Äúexport‚Äù this type outside the current assembly.  You can, of course, limit the use of implicitly typed fields only for internals of classes or private fields, or generally prohibit the use of implicitly typed fields with anonymous classes, but this will make the behavior of two semantically similar constructions of C # language too different.  One of the reasons for the appearance of <b>var</b> in C # 3.0 is the use of anonymous types (with or without LINQ), and here it turns out that non-typed fields will not work with them. <br><br>  Another important limitation is that implicitly typed fields introduce too close a connection between the field being initialized and the ‚Äúinitializer‚Äù.  Let's look at an example: suppose we have a class <b>A</b> , which contains a ‚Äúvar‚Äù field called <b>foo</b> , which is initialized by calling the static method <b>Foo of</b> class <b>B</b> : <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">class</font> A <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">var</font> foo = B.Foo(); <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> B <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> Foo() <br> { <br> <font color="#0000ff">return</font> <font color="#0000ff">default</font> ( <font color="#0000ff">int</font> ); <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  This leads to a number of additional questions: what happens if classes <b>A</b> and <b>B</b> are located in different assemblies?  But what if, without recompiling assembly <b>A, an</b> assembly with class <b>B</b> is recompiled and the return type of the <b>Foo</b> method changes from <b>int</b> to <b>string</b> ?  Or else we may have an implicitly typed <b>C.</b> <b>foo</b> field (i.e., a <b>foo</b> field in class <b>C</b> ) tied to a field type <b>A.</b> <b>foo</b> , a <b>D.</b> <b>foo</b> field tied to a <b>C.</b> <b>foo</b> field, etc.  and then changing the type of return value of one function will lead to a change in the field types in a dozen different classes (**).  And in general, fields are a more important part of class design and its implementation in comparison with local variables, so changing on the fly the type of this field, just because someone changed the function signature in the third module is not a good idea. <br><br>  Of course, it would be possible to limit the use of implicitly typed fields only in a limited set of cases, and prohibit the use of this feature with anonymous types and classes from other assemblies, and leave, for example, only using the methods of the current class.  But even in this case, the implementation of this feature requires too much effort to implement (proof from Eric, I'm not here and J), which makes it rather low priority in the endless list of improvements that are in the heads of the developers of the C # compiler. <br><br>  ---------------------- <br><br>  (*) There is no point getting ‚Äúin the jungle‚Äù, as Eric Lippert already did in his note <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/01/26/why-no-var-on-fields.aspx">Why no var on fields?</a>  in which he just says that the implementation of implicitly typed fields would require much more substantial implementation costs than the implementation of implicitly typed local variables. <br><br>  (**) Of course, this is not an indicator, and any opportunity to use correctly or not correctly.  But with the help of this thing you can pile up such that the example given in the note <a href="http://sergeyteplyakov.blogspot.com/2011/04/blog-post.html">How not to write</a> case <a href="http://sergeyteplyakov.blogspot.com/2011/04/blog-post.html">code</a> can also seem like flowers (since small changes will lead to mass not in one class, but also in a dozen others). </div><p>Source: <a href="https://habr.com/ru/post/127096/">https://habr.com/ru/post/127096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127088/index.html">Create a font that imitates your handwriting.</a></li>
<li><a href="../127090/index.html">Full replacement of Denwer or deploy Ubuntu-server on VMware (Part 1)</a></li>
<li><a href="../127092/index.html">Reordered text captcha</a></li>
<li><a href="../127094/index.html">Thinking out loud about IPv6, or why NAT won't save us</a></li>
<li><a href="../127095/index.html">Fake LJ comments from famous bloggers</a></li>
<li><a href="../127099/index.html">Symbian and Nokia - what awaits us in the future?</a></li>
<li><a href="../127101/index.html">SunCalc - JavaScript library for calculating the position of the sun and solar phases</a></li>
<li><a href="../127105/index.html">DevExpress CodeRush and JetBrains ReSharper Comparison</a></li>
<li><a href="../127106/index.html">Yii 1.1 Application Development Cookbook, final version and process</a></li>
<li><a href="../127107/index.html">Announced Opa Language: Making Web Development Transparent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>