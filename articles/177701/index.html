<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Chomsky generators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Small preface 
 This text is a continuation of the post in which the author tried to describe the concepts of formal language and grammar as simply as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Chomsky generators</h1><div class="post__text post__text-html js-mediator-article"><h4>  Small preface </h4><br>  This text is a continuation of the post in which the author tried to describe the concepts of formal language and grammar as simply as possible and without complicated mathematical calculations.  A lot of responses came to this text and the author felt obliged to write a sequel. <br><br>  The following describes the formalism that generates Chomsky's grammar.  Methods for defining a language with the help of generative grammars are now quite popular, especially for the computer processing of computer languages.  But usually the study of generating grammars in the theory of translators ends on context-free grammars.  The latter are a rather narrow special class of generators of Chomsky grammars and are usually used as a type of categorical grammars (how this is done, it will be shown below) for specifying parsers.  The latter circumstance only obscures the understanding of Chomsky's approach.  The further presentation is intended for those who are interested in understanding what this approach consists of. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Definition of Generative Grammar </h4><br>  A grammar is a final description of a formal language.  The formal language, in turn, is an arbitrary set of strings made up of symbols of a certain finite alphabet.  The arbitrariness of a set is understood here in the sense that it can be infinite, finite, or empty. <br><br>  The formalism of the generators of the Chomsky grammar was introduced by Noam Chomsky in the late 50s of the last century.  In a short time, this formalism gained extraordinary popularity.  For some time, generative grammars were considered as a panacea - a universal approach for defining all sorts of languages, including natural languages ‚Äã‚Äã(that is, languages ‚Äã‚Äãthat people use for everyday communication with each other).  But time has shown that generative grammars for describing natural languages ‚Äã‚Äãare not very convenient.  Now generating grammars are used mainly to describe the syntax of formal languages, like programming languages ‚Äã‚Äãand other computer languages. <br><br>  Chomsky's generating grammar is defined as a set of "rules of generation" (products).  Each rule is just a pair of chains <code>(w', w'')</code> and sets the possibility of replacing the left chain with the right one when generating chains of a language specified by the grammar.  For this reason, the rules are usually written in the form <code>w' --&gt; w''</code> , specifying specifically what can be replaced.  The set of rules in grammar should be non-empty and finite, and is usually denoted by the Latin P. <br><br>  Chains in the rules of grammar can be composed of characters of two alphabets: the alphabet of terminal symbols (terminals) and the alphabet of non-terminal symbols (non-terminals).  The alphabet of terminals is denoted by T. This alphabet actually coincides with the alphabet of the formal language that this grammar specifies.  The meaning of the term "terminal" is that in the rules of grammar on the left side there can not be chains, which are composed only of terminal symbols.  Therefore, if such a chain is obtained as a result of a substitution, then the next process of chain generation will stop (terminate).  Non-terminal symbols are used in intermediate chain spans.  The meaning of the non-terminal in the task of the chain generation algorithm can be very different and usually depends on the type of grammar in which this symbol is used.  Various examples of the use of non-terminal symbols will be discussed below. <br><br>  But one non-terminal symbol always has the same meaning - it means all the chains of the language.  This non-terminal is called the ‚Äúinitial non-terminal character of the generating grammar‚Äù and is usually denoted by the Latin S (start or sentence).  In each generating grammar there must necessarily be a rule to which the left-hand part consists of a single initial non-terminal, otherwise in this grammar it will be impossible to generate even one chain. <br><br>  So, Chomsky's generating grammar is the quadruple <code>G = {N, T, P, S}</code> , where <br><ul><li>  <code>N</code> is the final alphabet of non-terminal characters. </li><li>  <code>T</code> - the final alphabet of terminal symbols (coincides with the alphabet of the language specified by the grammar). </li><li>  <code>P</code> is a finite set of generation rules. </li><li>  <code>S</code> is the initial non-terminal grammar of <code>G</code> </li></ul><br><br><h4>  Generative Grammar Language </h4><br>  Chomsky's generating grammar specifies the language by a finite number of chain substitutions from the initial non-terminal grammar based on the generation rules.  We describe it a little more specifically. <br><br>  The step of generating <code>w' alpha w'' =&gt; w' beta w''</code> consists in replacing the <code>alpha</code> subchain with the <code>beta</code> subchain in accordance with the generation rule <code>alpha --&gt; beta</code> .  In this case, obviously, from the chain <code>w' alpha w''</code> get the chain <code>w' beta w''</code> .  In other words, if there is some chain and some of its straps is the left part of some grammar rule, then we have every right to replace this left part of the rule with the right one.  The final sequence of creature steps is called a creature.  Zero or more spawns will be denoted by <code>=&gt;*</code> .  The notation <code>alpha =&gt;* beta</code> indicates that the <code>beta</code> chain is obtained from the <code>alpha</code> chain by a finite number of substitutions based on the generation rules.  In this notation, it may be that the substitution (generation) was not applied even once, in this case the chain <code>alpha</code> coincides with <code>beta</code> . <br><br>  So, the language of the generating grammar <code>G = {N, T, P, S}</code> is the set of strings composed of terminal symbols and generated from the initial grammar symbol.  The mathematical formula is as follows: <code>L = {w | S =&gt;* w}</code>  <code>L = {w | S =&gt;* w}</code> . <br><br>  For illustration, we give two simple examples. <br><br><h6>  An example of a very simple language </h6><br>  Let the language <code>L</code> consist of a single chain, which consists of a single symbol <code>a</code> .  In other words, <code>L = {a}</code> .  To generate a chain, one rule <code>S --&gt; a</code> enough.  The only generation that can be in a given grammar is <code>S =&gt; a</code> . <br><br>  It should be noted that for this language it would be possible to introduce another non-terminal symbol, say, the symbol <code>A</code> , as well as the rules <code>S --&gt; A</code> and <code>A --&gt; a</code> .  Then the only generation would be the following: <code>S =&gt; A =&gt; a</code> .  Since we choose the non-terminal grammar alphabet arbitrarily, it becomes clear that even for such a simple language there are an infinite number of generating grammars defining this language. <br><br><h6>  Simple arithmetic expressions language </h6><br>  Consider the language <code>A = {a+a, a+a+a, a+a+a+a, ...}</code> .  Chains of this language are sequences of characters <code>a</code> , separated by <code>+</code> characters.  How to set the rules for the generation of this language?  Note that each language chain starts with a character followed by one or more <code>+a</code> chains.  Accordingly, the idea arises to first produce the symbol <code>a</code> , and then each chain of the language will be obtained by attaching one or more chains <code>+a</code> to the symbol to the right.  To separate these two stages of generation from each other, we introduce a non-terminal symbol <code>A</code>  Then, we get a grammar with the following rules: <code>S --&gt; aA, A --&gt; +aA, A --&gt; +a</code> . <br><br>  Consider, for example, how to generate a chain <code>a+a+a</code> .  <code>S =&gt; aA =&gt; a+aA =&gt; a+a+a</code> .  In this generation, all three rules were consistently applied: <code>S --&gt; aA, A --&gt; +aA, A --&gt; +a</code> . <br><br>  The language <code>A</code> contains an infinite number of chains, which means that there is no limit on the length of the chain in this language.  The only way to generate chains of unlimited length is to use recursive generation rules, i.e.  rules in which the left side of the rule is contained in the right part of the rule.  In the example above, this rule is <code>A --&gt; +aA</code> .  The left side is a string of a single symbol <code>A</code> , which is also contained in the right side.  This recursion allows you to consistently apply the same rules in the substitution, increasing, as necessary, the length of the generated chain.  Recursion can be mediated through intermediate rules.  For example, the rules <code>A --&gt; aBc, B --&gt; deA</code> define indirect recursion of the chain <code>A</code> <br><br><h4>  Grammar Classes </h4><br>  Noam Chomsky introduced grammar classes (and the corresponding classes of languages) by setting restrictions on the type of rules for generating grammar.  Each grammar class has its own descriptive power.  The descriptive power of a class of grammars can be characterized as the possibility of expressing in the rules of grammar certain syntactic relations.  Consider how grammar classes define syntactic relationships. <br><br><h5>  Grammar Type 3 </h5><br>  This class of grammars defines an algorithm for generating chains by attaching a number of terminal symbols from the right or left edge of the generated chain.  Obviously, the rules for such a generation method must have the form <code>A --&gt; alpha B</code> or <code>A --&gt; B alpha</code> , where <code>alpha</code> is a string consisting of terminal symbols.  In this case, if there is an intermediate (in the process of spawning) chain <code>X1..Xn A</code> , then the replacement in accordance with rule <code>A --&gt; alpha B</code> will give the chain <code>X1..Xn alpha B</code>  For example, for the rules <code>S --&gt; aaaA</code> , <code>A --&gt; abcA</code> and <code>A --&gt; bbb</code> you can specify the generation <code>S =&gt; aaaA =&gt; aaaabcA =&gt; aaaabcbbb</code> . <br><br>  The syntactic relationship that is given by type 3 grammars can be denoted by the term ‚Äúto be near‚Äù.  ‚ÄúNear‚Äù here is meant both directly next to it, if it is specified on the right side of some generation rule, and indirectly next to it, through non-terminal symbols in related generation rules. <br><br>  For mathematical rigor, the string of terminal symbols in type 3 grammar rules is divided into several rules with one terminal symbol in the right-hand side.  For example, if there is a rule <code>A --&gt; abcB</code> , then it can be replaced with the following rules, the use of which as a result generates the same chain: <code>A --&gt; a A1</code> , <code>A1 --&gt; b A2</code> , <code>A2 --&gt; cB</code> .  In other words, the substitution <code>A =&gt; abcB</code> equivalent to the sequence of substitutions <code>A =&gt; a A1 =&gt; ab A2 =&gt; abcB</code> .  Such grammars, where a non-terminal symbol stands to the right on the right side of the rule, are called right-line grammars, if a non-terminal character is to the left of the terminal on the right side, then the grammar is called left-linear. <br><br>  For example, we define a levilinear grammar for the language <code>A = {a+a, a+a+a, a+a+a+a, ...}</code> .  The rules of type 3 grammar, as discussed above, are: <code>S --&gt; aA, A --&gt; +aA, A --&gt; +a</code> .  Here the chains are generated by appending a pair of characters to the right.  Let's change the grammar so that the characters are joined to the left, and also add non-terminal characters to add only one character each time.  Get the grammar: <br> <code>S --&gt; Aa</code> <br> <code>A --&gt; B+</code> <br> <code>B --&gt; Aa</code> <br> <code>B --&gt; a</code> <br>  This is what a chain of <code>a+a+a</code> looks like: <code>S =&gt; Aa =&gt; B+a =&gt; Aa+a =&gt; B+a+a =&gt; a+a+a</code> . <br><br>  The attentive reader probably noticed that a type 3 grammar is similar to a spawning automaton, in which the role of states is played by non-terminal grammar symbols.  One of the possible interpretations of this grammar is, indeed, a finite automaton. <br><br><h5>  Context-free grammar </h5><br>  Context-free grammars have rules of the form: <code>A --&gt; alpha</code> .  In the left part of the rule there should be one character (of course, non-terminal), and on the right there can be any string of terminal and non-terminal symbols (including the empty one). <br><br>  KS grammars define two types of syntactic relations: the relation ‚Äúto be near‚Äù and the relation ‚Äúto be a part‚Äù or the relation of hierarchy.  The relation of hierarchy is most natural to the human mind.  It is human nature to type things, i.e.  consider specific objects of their thinking as part of a general type (class).  Every thing that a person thinks of is a copy of a certain class.  For example, a particular chair is an instance of a class ‚Äúchair‚Äù with corresponding signs.  It is also common for the human mind to divide types into subtypes, moving from more concrete types to more abstract ones.  Let's say a chair is a subtype of the type of furniture, furniture is a subtype of the type of an object, an object is a subtype of the type of an object, etc.  The type-subtype relationship is the hierarchy relationship. <br><br>  KS grammar can be interpreted as categorical grammar, i.e.  grammar types.  In this case, grammar symbols can be thought of as types, and the rules then define the relation of hierarchy between types.  Non-terminal characters act as complex types, and terminal characters as atomic types that cannot have subtypes.  Such an interpretation of KS grammar is very popular and is often used to create language translators.  But in defining a class for a cop grammar, Chomsky meant something else. <br><br>  Since the KS grammar is a generator, it sets the algorithm (strictly speaking, not an algorithm, but calculus is a multivariate algorithm) for generating chains of a language.  The generation here is defined not only by attaching the chains to the right or left of the existing chain, but also by inserting the chain somewhere inside the existing one.  The insertion is made by replacing the non-terminal symbol in the chain with a chain that stands on the right side of some rule, on the left side of which there is this non-terminal.  Say, <code>aabBBACbbb</code> chain can be converted to <code>aabBBaaaCbbb</code> chain, if there is a rule <code>A --&gt; aaa</code> .  In this sense, the generated chain does not grow evenly from a certain edge, but, as it were, ‚Äúswells‚Äù from the inside. <br><br>  We illustrate this with an example.  Consider the language <code>L = {a^nb^n | n = 1, 2, 3,...}</code>  <code>L = {a^nb^n | n = 1, 2, 3,...}</code> .  The expression <code>a^n</code> here means repeating <code>n</code> times the character <code>a</code> .  Thus, the language <code>L</code> consists of a chain of the form <code>ab, aabb, aaabbb</code> , etc.  Let us define a grammar grammar for this language.  To do this, we note that you can get another language chain from the language chain by appending the character <code>a</code> to the first left and the character <code>b</code> right.  Let's say if there is a chain <code>aabb</code> , then from it you can get a chain <code>aaabbb</code> .  This remark gives the rule of generating <code>S --&gt; aSb</code> (recall that the chains of the language are generated from the initial non-terminal grammar and, therefore, can be denoted by this symbol).  There is also a special case of a chain that does not break up into smaller ones ‚Äî the chain is <code>ab</code> .  We introduce for its generation the rule <code>S --&gt; ab</code> .  So, the grammar of the language has rules: <code>S --&gt; aSb</code> and <code>S --&gt; ab</code> .  Let <code>aaabbb</code> chain <code>aaabbb</code> : <code>S =&gt; aSb =&gt; aaSbb =&gt; aaabbb</code> . <br><br><h5>  Context-free grammar and grammar without restrictions </h5><br>  In the rules of the KS grammar, the non-terminal symbol on the left side of the generation rule can be changed to the right side in any place of the generated chain, wherever this symbol is encountered.  But sometimes I would like to distinguish between contexts in which a symbol is located in a chain, and in some cases replace the symbol, in others - not.  The rules of the COP grammar do not allow this, so special cases are necessary for such cases. <br><br>  Context-sensitive grammar has rules of the form <code>w' A w'' --&gt; w' alpha w''</code> .  Here <code>w'</code> and <code>w''</code> are chains (maybe empty) made up of terminal and non-terminal grammar symbols, <code>alpha</code> is a non-empty string of the same symbols.  In other words, the non-terminal character <code>A</code> is replaced by the <code>alpha</code> chain in the context of the <code>w'</code> and <code>w''</code> chains. <br><br>  Another class of grammars is associated with KZ grammar - non-shortening grammars.  The rules in such grammars must satisfy one condition: the length of the right part must be not less than the length of the left part.  Since there is a condition in the rules for KZ grammar that the <code>alpha</code> chain is non-empty, these grammars are also non-shortening.  But the most interesting thing is that for each language defined by a short-term grammar, a short grammar can be created that defines the same language.  In other words, the classes of languages ‚Äã‚Äãdefined by CG grammars and non-shorten grammars coincide. <br><br>  Why is it so necessary to distinguish the class of languages ‚Äã‚Äãgiven by the non-shortening grammars?  The fact is that for such languages ‚Äã‚Äãyou can specify a recognition machine.  A recognition grammar is constructed as follows: receiving a chain at the input, we sequentially make generations, arranging them along the length of the generated chain.  Since  the grammar is non-shortening, then there will be a finite set of such derivations, and if there is no match with the given chain of input, then type "no." <br><br>  For grammar without restrictions on the type of rules, such a recognition algorithm cannot be constructed in the general case.  The chain created can behave like an "accordion", swelling and puffing in the process of spawning.  Therefore, the achievement of a certain length generated by the chain does not guarantee that further in the process of spawning the chain fed to the input will not be obtained. <br><br>  Do KZ-languages ‚Äã‚Äãreally form their own class? Does this class not coincide with the class of QC-languages?  In other words, is there a language for which it is guaranteed that the KS grammar cannot be specified, but that KG grammar can be defined?  Answer: yes, there are such languages.  An example of such a language is the following language <code>L = {ww}</code> .  The chains of this language are made up of two repeating chains over some alphabet.  We will not prove here that for this language it is impossible to construct a Q-grammar.  KZ grammar can be set based on the following consideration.  First, generate a chain <code>w</code> and a non-terminal symbol, say <code>A</code> , i.e.  get the chain <code>Aw</code> .  Then move the character <code>A</code> through the chain <code>w</code> , generating copies of the characters of this chain along, and then move these characters to the right.  Approximately the same as it will be implemented in the example below. <br><br>  Consider an example of setting grammar for the language <code>L = {a^n^2 | n = 1, 2, 3, ...}</code>  <code>L = {a^n^2 | n = 1, 2, 3, ...}</code> .  The chains of this language consist of the characters <code>a</code> , and the number of these characters is the square of the natural number: 1, 4, 9, 25, etc.  We will set a grammar for this language without restrictions.  Chain generation will consist of the following steps: <br><ol><li>  Generate <code>n</code> characters for some natural number <code>n</code> . </li><li>  Deriving from this number of characters <code>n^2</code> characters. </li><li>  Convert these characters to characters <code>a</code> . </li></ol><br>  To implement the first stage, add the rules <br> <code>S --&gt; LS'R</code> <br> <code>S' --&gt; AS'B</code> <br> <code>S' --&gt; AB</code> <br> <br>  The first rule is to wrap the generated chain in <code>L</code> and <code>R</code> delimiters.  We will need them in the future to implement the third generation phase.  The remaining two rules simply generate a chain of the form <code>AA...ABB...B</code> , where the number of characters <code>A</code> and <code>B</code> same. <br><br>  Now it is necessary to generate <code>n^2</code> characters based on the chain <code>AA...ABB...B</code>  It makes simple reception.  Move the characters <code>B</code> left and, at each transition through the character <code>A</code> , generate another character <code>C</code>  Through the characters C, the character <code>A</code> can freely flow to the right, and the character <code>B</code> to the left.  The rules for this phase are as follows: <br> <code>AB --&gt; BAC</code> <br> <code>AC --&gt; CA</code> <br> <code>CB --&gt; BC</code> <br>  When all the characters <code>B</code> reach the left edge, by moving the characters <code>A</code> , the characters <code>C</code> will be exactly <code>n^2</code> . <br><br>  Now you need to get rid of the characters <code>L</code> , <code>A</code> , <code>B</code> and <code>R</code> , and also convert the characters <code>C</code> to the characters <code>a</code> .  To do this, we annihilate the symbol <code>B</code> as it passes to the left edge, i.e.  before symbol <code>L</code>  Accordingly, we act with the symbol <code>A</code> on the right edge.  With the implementation of such a strategy will remain a chain of the form <code>LCC....CR</code> .  To get rid of the characters <code>L</code> and <code>R</code> , we begin to move the left limit to the right and, when they touch, we destroy these characters.  At the same time, when passing through the characters <code>L</code> , we convert them into characters <code>a</code> .      . <br> <code>LB --&gt; L</code> <br> <code>AR --&gt; R</code> <br> <code>LC --&gt; aL</code> <br> <code>LR --&gt; epsilon</code> <br>  <code>epsilon</code>   . <br><br>       <code>aaaa</code> : <code>S =&gt; LS'R =&gt; LAS'BR =&gt; LAABBR =&gt; LABACBR =&gt; LBACACBR =&gt; LACACBR =&gt; LACABCR =&gt; LACBACCR =&gt; LABCACCR =&gt; LBACCACCR =&gt; LACCACCR =&gt; LCACACCR =&gt; LCCAACCR =&gt; LCCACACR =&gt; LCCACCAR =&gt; LCCACCR =&gt; LCCCACR =&gt; LCCCCAR =&gt; LCCCCR =&gt; aLCCCR =&gt; aaLCCR =&gt; aaaLCR =&gt; aaaaLR =&gt; aaaa</code> <br><br><h4>  Conclusion </h4><br>  ,      ,         ,      ,   .     ,    ¬´ ¬ª ()        . <br><br>             ,  -          ,          .         . ,       ,      ,         . </div><p>Source: <a href="https://habr.com/ru/post/177701/">https://habr.com/ru/post/177701/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177685/index.html">The social network aggregator Meople.Net is now available on Windows 8</a></li>
<li><a href="../177687/index.html">5 annoying technological myths that must always be remembered</a></li>
<li><a href="../177691/index.html">Phalcon 1.1 beta</a></li>
<li><a href="../177693/index.html">Nic.ru is ... is that really possible?</a></li>
<li><a href="../177697/index.html">Big Data Week in Moscow. April 25-27. Program update</a></li>
<li><a href="../177703/index.html">Market Navigator - one click price comparison</a></li>
<li><a href="../177705/index.html">NASA: video results of three-year observations of the Sun</a></li>
<li><a href="../177707/index.html">Yandex 23 minutes was blocked by Rostelecom</a></li>
<li><a href="../177709/index.html">Chrome Logger - server logs in chrome console</a></li>
<li><a href="../177719/index.html">Mars One opened registration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>