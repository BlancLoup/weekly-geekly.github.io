<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we optimized Twitter Lite</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Twitter Lite and high-performance progressive web applications on React 


 A look at how ordinary and unusual performance bottlenecks were removed wh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we optimized Twitter Lite</h1><div class="post__text post__text-html js-mediator-article"><h2>  Twitter Lite and high-performance progressive web applications on React </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c64/b58/183/c64b5818384b4fec9fe4ce0056531aeb.png"><br><br><blockquote>  <i>A look at how ordinary and unusual performance bottlenecks were removed when creating one of the world's largest progressive web applications (PWA) on React.js - <a href="https://mobile.twitter.com/">Twitter Lite</a></i> </blockquote><br>  Creating a fast web application requires many measurement cycles where time is spent.  You need to understand why this happens and apply potential fixes.  Unfortunately, there is no one simple solution.  Performance is an endless game where we look for and measure areas for improvement.  Twitter Lite has made a lot of small improvements in different areas: from the initial loading time to rendering the components React (and preventing re-rendering), loading images and much more.  Most of the changes are small, but they add up, and in the end we got one of the largest and fastest <i><a href="https://developers.google.com/web/progressive-web-apps/">progressive web applications</a></i> . <br><a name="habracut"></a><br><h3>  Before reading </h3><br>  If you have just started measuring and working on improving the performance of your web application, then I highly recommend <a href="http://www.brendangregg.com/flamegraphs.html">learning how to read flame-graphics</a> if you don‚Äôt know it yet. <br><br>  Each section provides examples of screenshots with a record of the timelines from the Chrome Developer Tools.  To make the examples clearer, I single out on each pair of screenshots what is bad (above) and what is good (below). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Special note about the timelines and flame-graphs.</i>  <i>Since we focus on a very large range of mobile devices, we usually record them in an artificial environment: 5 times slower CPU and 3G connection.</i>  <i>This is not only more realistic, but the problems are much clearer.</i>  <i>The distortion can be aggravated if we use <a href="https://facebook.github.io/react/blog/2016/11/16/react-v15.4.0.html">the profile component React v15.4.0</a> .</i>  <i>Real timeline performance on the desktop will be much higher than in our illustrations.</i> <br><br><hr><br><h1>  Browser Optimization </h1><br><h3>  Separate code based on routes </h3><br>  Webpack is powerful, but difficult to learn.  For a while, we had problems with the <a href="https://webpack.js.org/plugins/commons-chunk-plugin/">CommonsChunkPlugin</a> and how it worked with some of our circular code dependencies.  Because of this, we ended up with only three JavaScript resource files with a total size of more than 1 MB (420 KB of gzip in transit). <br><br>  Downloading one or even several very large JavaScript files needed for work is a huge bottleneck for mobile users, which does not allow you to quickly see and start interacting with the site.  With the size of scripts, not only the time of their transmission over the network increases, but also the time of parsing in the browser. <br><br>  After long disputes, we were finally able to split the CommonsChunk into separate pieces based on the routes (example below).  This day came when code analysis fell into our mailboxes: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plugins = [ <span class="hljs-comment"><span class="hljs-comment">// extract vendor and webpack's module manifest new webpack.optimize.CommonsChunkPlugin({ names: [ 'vendor', 'manifest' ], minChunks: Infinity }), // extract common modules from all the chunks (requires no 'name' property) new webpack.optimize.CommonsChunkPlugin({ async: true, children: true, minChunks: 4 }) ];</span></span></code> </pre> <br><blockquote>  <i>Use granular code separation based on routes.</i>  <i>Faster initial and HomeTimeline rendering is achieved at the cost of increasing the overall size of the application, which is divided into more than 40 pieces and is amortized throughout the session.</i>  <i>- <a href="https://medium.com/%40necolas">Nicholas Gallagher</a></i> </blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/584/ea2/b02/584ea2b0229640989c28d5afcdb13f4e.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/ad8/128/bcd/ad8128bcdc4e68fcbb485359317b19b6.png"><br>  <font color="gray">Timelines before (above) and after (below) code separation</font> <br><br>  Our initial configuration required more than 5 seconds to load the main package, and after splitting into pieces based on routes, the download time barely reaches 3 seconds (in the 3G network simulation). <br><br>  We made this change at the very beginning of our performance optimization work, but a single change immediately led to a dramatic improvement in the results of the Google <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> web application audit tool: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e1/1cd/b51/0e11cdb51d2ae716b2dcc1a6405c0fe2.png"><br>  <font color="gray">Test results in the Lighthouse site before (left) and after (right) optimization</font> <br><br><hr><br><h3>  Avoid functions that create freezes. </h3><br>  For many iterations of the <a href="http://itsze.ro/blog/2017/04/09/infinite-list-and-react.html">endless scroll timelines,</a> we used different methods to calculate the scroll position and direction ‚Äî this is needed to decide whether to request an API to load and display additional tweets.  Until recently, we used the <a href="https://github.com/brigade/react-waypoint">react-waypoint</a> , which is fine with us.  However, it is simply not fast enough to achieve maximum performance of one of the main components. <br><br>  Waypoints calculate many different indicators for height, width, and position of elements to determine the current scroll position, how far you are from each edge, and in which direction you scroll.  All this information is useful, but it is calculated on each scrolling event and therefore costly: these calculations cause slowdowns (jank) - and a lot. <br><br>  But first you need to understand what the development tools mean when they inform us about slowdowns. <br><br><blockquote>  <i>Most modern devices update the screen 60 times per second.</i>  <i>If there is an animation or transition effect or the user scrolls the page, then the browser needs to adjust to the refresh rate and output one new picture, or frame, to each of these screen updates.</i> <i><br><br></i>  <i>Each of these frames has a budget of just over 16 ms (1 second / 60 = 16.66 ms).</i>  <i>However, in reality, the browser needs to perform auxiliary tasks, so all your work must be within 10 ms.</i>  <i>If you do not fit into the budget, the frame rate is reduced, and the content moves in jerks on the screen.</i>  <i>This is often referred to as jank, and it adversely affects the user experience.</i>  <i>- <a href="https://developers.google.com/web/fundamentals/performance/rendering/">Paul Lewis in Rendering Performance</a></i> </blockquote><br>  Over time, we developed a new component for endless scrolling called <i>VirtualScroller</i> .  With this new component, we knew exactly which fragment of the tweet tape was rendered in the timeline at each moment in time, so the need to make resource-intensive visual position calculations disappeared. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/65b/680/b1a65b6803919a0d6c971db558e2e519.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/604/3e4/dc0/6043e4dc0b416dcb9a51099865790442.png"><br>  <font color="gray">This may not seem very significant, but earlier during scrolling (from the top) there were slowdowns during rendering, because the height of various elements was calculated.</font>  <font color="gray">Now (from below) there are no content shakes or pauses when scrolling at high speed</font> <br><br>  After refusing calls, which caused additional slowdowns, now scrolling the tape of tweets looks and feels smooth and seamless, which gives a richer, almost native impression of the application.  Although there is always room for optimization, this change has become a noticeable improvement in smoothly scrolling through the tapes.  A good reminder that every little thing matters when it comes to performance. <br><br><hr><br><h3>  Use smaller pictures </h3><br>  We started optimizing traffic for Twitter Lite by working together with several groups on new smaller pictures that are downloaded from our <a href="https://en.wikipedia.org/wiki/Content_delivery_network">CDNs</a> .  It turned out that with the reduction of images, the application performs only minimal rendering, which is absolutely necessary (both in size and quality), and we not only reduced the traffic, but also increased the browser performance, especially while scrolling the tweets ribbon with a large number of images . <br><br>  To determine what effect small pictures have on performance, you can look at the <i>Raster</i> timeline in Chrome Developer Tools.  Before optimizing the size of images, decoding a single image took 300 ms or more, as shown in the top of the two timelines below.  This is the length of time between when the image is downloaded and when it appears on the page. <br><br>  If you aspire to the standard 60 frames per second while scrolling the page, then you need to squeeze as much processing as possible into 16.667 ms (1 frame).  It turns out that rendering one image takes 18 frames, which is too much.  As for the tape, the following should be noted: as you can see, the <i>Main</i> timeline is almost completely blocked from continuing to work until the decoding of the image is complete (as shown by the white spaces).  This means that we have a bottleneck of performance here! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/7c3/efa/1867c3efa4789a5f4150583bcff0215f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/eb1/f79/668/eb1f7966893a159130601fbd3fd2ef63.png"><br>  <font color="gray">Large images (above) can block the main stream for 18 frames.</font>  <font color="gray">Small images (bottom) take only 1 frame</font> <br><br>  Now that we have reduced the size of the images, decoding the largest images requires only a little more than one frame. <br><br><hr><br><h1>  React optimization </h1><br><h3>  Use the method <a href="https://facebook.github.io/react/docs/optimizing-performance.html">shouldComponentUpdate</a> </h3><br>  A popular tip for optimizing application performance with React is to <a href="https://facebook.github.io/react/docs/optimizing-performance.html">use the shouldComponentUpdate method</a> .  We tried to do it where possible, and sometimes corrected serious mistakes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/e4c/704/208e4c704e296afbb1b58c4b25804d91.gif"><br>  <font color="gray">If you like the first tweet, then he and all the discussions below were re-rendered!</font> <br><br>  An example of a component that is always updated.  If you click on the heart icon under tweet to put a like in your feed, then any <code>Conversation</code> component on the screen will also be rendered again.  In the animated example, you can see green rectangles that show where the browser re-fills in color, because we forced the entire <code>Conversation</code> component to re-update from the bottom of the tweet. <br><br>  Below are the two flame graphics of this action.  Without <code>shouldComponentUpdate</code> (above) the entire tree is updated and re-drawn just to change the color of the heart somewhere on the screen.  After adding <code>shouldComponentUpdate</code> (below), we prevented the whole tree from being updated and saved a whole 0.1 seconds of unnecessary data processing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50e/a77/856/50ea77856001a532f5f0ffac6a6b9945.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/02b/9a2/c34/02b9a2c3471c9e0aac3bfb20311ef58e.png"><br>  <font color="gray">Previously (at the top) when putting a message to an outside tweet, the entire discussion was updated and redrawn.</font>  <font color="gray">After adding the logic of shouldComponentUpdate (below), the component and the child processes no longer spend the CPU cycles</font> <br><br><hr><br><h3>  Transfer unnecessary work to componentDidMount </h3><br>  This change may seem obvious, but it's easy to forget about such small things when developing a large application like Twitter Lite. <br><br>  We noticed that in many places of the code, resource-intensive computations are performed for the sake of analytics during the execution of the life-cycle method in React, that is, <a href="https://facebook.github.io/react/docs/react-component.html">componentWillMount</a> .  Each time the components were drawn for a while.  20 ms here, 90 ms there, everything quickly evolved.  At first, we tried to record and transmit to the analytics service in the <code>componentWillMount</code> information which tweets should be rendered, even before the actual rendering begins (the top of two screenshots). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95e/d3f/418/95ed3f41862a6c8e51a5306bb03f0889.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/898/605/ffc/898605ffc008215b6c7d4bf47d11a1f8.png"><br>  <font color="gray">By transferring nonessential parts of the code from `componentWillMount` to` componentDidMount`, we saved a lot of time rendering tweets on the screen.</font> <br><br>  Transferring these calculations and network calls to the <code>componentDidMount</code> method of the React component, we unblocked the main thread and reduced the slowdowns while rendering the components (lower timeline). <br><br><hr><br><h3>  Avoid dangerouslySetInnerHTML </h3><br>  In Twitter Lite, we use SVG icons, as these are the most compact and scalable formats available.  Unfortunately, in older versions of React most of the SVG attributes were not supported when creating elements from components.  Therefore, when we first started writing the application, we had to use <code>dangerouslySetInnerHTML</code> to use the SVG icons as components of React. <br><br>  For example, our initial HeartIcon pictogram looked like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HeartIcon = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> React.createElement(<span class="hljs-string"><span class="hljs-string">'svg'</span></span>, { ...props, <span class="hljs-attr"><span class="hljs-attr">dangerouslySetInnerHTML</span></span>: { <span class="hljs-attr"><span class="hljs-attr">__html</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;g&gt;&lt;path d="M38.723 12c-7.187 0-11.16 7.306-11.723 8.131C26.437 19.306 22.504 12 15.277 12 8.791 12 3.533 18.163 3.533 24.647 3.533 39.964 21.891 55.907 27 56c5.109-.093 23.467-16.036 23.467-31.353C50.467 18.163 45.209 12 38.723 12z"&gt;&lt;/path&gt;&lt;/g&gt;'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">viewBox</span></span>: <span class="hljs-string"><span class="hljs-string">'0 0 54 72'</span></span> });</code> </pre> <br>  The use of <code>dangerouslySetInnerHTML</code> <a href="http://reactjs.cn/react/tips/dangerously-set-inner-html.html">is discouraged</a> from a security point of view, and it also slows down the mount and render processes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47b/dd5/2d6/47bdd52d6c42b255a3c328be088cd95d.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/503/61a/331/50361a3317473fe008a003876c1121e9.png"><br>  <font color="gray">Previously (above) it took about 20 ms to mount four SVG icons, but now (below) it takes about 8 ms</font> <br><br>  Analysis of the flame graphs shows that in the initial version it took about 20 ms on a slow device to mount four SVG icons at the bottom of each tweet.  It seems a little, but such icons are mounted in large numbers while scrolling an endless ribbon of tweets - and we realized that this is a huge loss of time. <br><br>  When we added support for most of the SVG attributes in React v15, we decided to see what happens if we drop <code>dangerouslySetInnerHTML</code> .  As seen on the second flame-graph (the lower one from the upper pair of graphs), we save an average of <b>60%</b> every time you need to mount and draw this set of icons! <br><br>  Now our SVG icons are simple, stateless components.  They do not use <i>‚Äúdangerous‚Äù</i> features and are mounted on average 60% faster.  They look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HeartIcon = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props = {}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="hljs-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">viewBox</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">'0 0 ${width} ${height}'</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">g</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">path</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">d</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">'M38.723 12c-7.187 0-11.16 7.306-11.723 8.131C26.437 19.306 22.504 12 15.277 12 8.791 12 3.533 18.163 3.533 24.647 3.533 39.964 21.891 55.907 27 56c5.109-.093 23.467-16.036 23.467-31.353C50.467 18.163 45.209 12 38.723 12z'</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">path</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">g</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><hr><br><h3>  Postpone rendering while mounting and unmounting a large number of components </h3><br>  On slower devices, we noticed that our main navigation panel did not immediately appear in response to a click, which often leads to repeated clicks - the user thinks that the first click did not lock. <br><br>  Notice the animation below, that the <i>Home</i> icon takes about two seconds to refresh and show that you clicked on it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cd/145/a64/1cd145a643dcef4dd62e42e9a0399d4a.gif"><br>  <font color="gray">Without deferred rendering, the navigation panel does not respond immediately.</font> <br><br>  No, this is not a GIF animation delay.  The update is really so slow.  But after all, all the data for the <i>Home</i> screen has already been loaded, so why are they not displayed for such a long time? <br><br>  It turned out that assembling and unmounting the component trees (like tweeting tapes) in React takes a lot of resources. <br><br>  We wanted to at least eliminate the impression that the navigation bar does not respond to user pressure.  To do this, create a small component of a higher order: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hoistStatics <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'hoist-non-react-statics'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Allows two animation frames to complete to allow other components to update * and re-render before mounting and rendering an expensive `WrappedComponent`. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferComponentRender</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WrappedComponent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeferredRenderWrapper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props, context) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props, context); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">shouldRender</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; } componentDidMount() { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">shouldRender</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })); }); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.shouldRender ? <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">WrappedComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...this.props</span></span></span></span><span class="xml"><span class="hljs-tag">} /&gt;</span></span></span><span class="xml"> : null; } } return hoistStatics(DeferredRenderWrapper, WrappedComponent); }</span></span></code> </pre>  <font color="gray">Our component HigherOrderComponent, written by <a href="https://mobile.twitter.com/katiesievert">Katie Sievert</a></font> <br><br>  After applying it to HomeTimeline, the response of the navigation bar became almost instantaneous, which led to an <i>apparent</i> overall acceleration. <br><br> <code>const DeferredTimeline = deferComponentRender(HomeTimeline); <br> render(&lt;DeferredTimeline /&gt;);</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/0c3/a89/464/0c3a89464f92191719088b9187fbfee5.gif"><br>  <font color="gray">With deferred rendering, the navigation bar reacts instantly</font> <br><br><hr><br><h1>  Redux Optimization </h1><br><h3>  Avoid Staying Too Frequently. </h3><br>  Although it seems to be recommended to use <a href="https://facebook.github.io/react/docs/forms.html">monitored components</a> , but if you control the data entry, you will have to re-render for each keystroke. <br><br>  On a desktop computer with a 3 GHz processor, this is not noticeable, but small mobile devices with very limited CPU resources will experience a significant delay between clicks, especially when a large number of characters are removed from the field. <br><br>  To preserve the convenience of composing tweets, as well as leaving the counter for the number of characters, we used a monitored component, and <i>also</i> passed the current value of the input field to our Redux state for each keystroke. <br><br>  At the top of the pair of screenshots - a typical device for Android 5, where each press leads to a change, which takes approximately 200 ms of extra time.  If a person really quickly types the text, we will get a very bad state, when the user complains that the cursor randomly moves around the form, confusing sentences. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e7/9b5/7ad/0e79b57ad633f5e2cf96acd61ae16795.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/681/964/256/68196425618356127d8da11efd505601.png"><br>  <font color="gray">Comparison of the time it takes to update after each key press before the status is sent to Redux and after optimization</font> <br><br>  We accelerated the execution time by 50% when we banned the state of a draft tweet from updating the main Redux state, and instead saving it locally in the state of the React component. <br><br><hr><br><h3>  Group actions into single distribution packages </h3><br>  In Twitter Lite, we use <a href="http://redux.js.org/">redux</a> and <a href="http://redux.js.org/docs/basics/UsageWithReact.html">react-redux</a> to assign components to state data changes.  We optimized our data on different areas of large storage using <a href="https://github.com/paularmstrong/normalizr">Normalizr</a> and <a href="http://redux.js.org/docs/api/combineReducers.html">combineReducers</a> .  This all worked fine, preventing data duplication and keeping the storage size small.  However, each time we received new data, we had to send numerous actions to add them to the appropriate repositories. <br><br>  Considering the react-redux mechanism of operation, this meant that every action after sending resulted in a re-computation of changes and a possible re-rendering of related components (called containers). <br><br>  Although we use specially developed middleware, <a href="https://www.npmjs.com/package/redux-batched-actions">there are</a> <a href="https://www.npmjs.com/package/redux-batch-middleware">other</a> <a href="https://www.npmjs.com/package/redux-batch-actions">middleware</a> <a href="https://www.npmjs.com/package/redux-batch-enhancer">available</a> for batch work.  Use the appropriate or write your own module. <br><br>  The best way to demonstrate the benefits of batch processing is to use the <a href="https://github.com/crysislinux/chrome-react-perf">Chrome React Perf Extension</a> .  After preloading, we perform proactive caching and calculate unread private messages in the background.  At this time we add many different objects (conversations, users, message recordings, etc.).  <i>Without batch processing</i> (the top of a couple of screenshots), each component is rendered twice as often (about 16 times) than <i>with batch processing</i> (about 8 times). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87a/5d2/a14/87a5d2a14ddf7553df94d34345a02cb2.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/089/6d6/698/0896d66987a60c0122a914b0a0cc1de0.png"><br>  <font color="gray">Comparison of the work of the React Perf extension for Chrome without batch processing in Redux (above) and with packages (below)</font> <br><br><hr><br><h1>  Service workers </h1><br>  Although service workers are not yet available in all browsers, they are an invaluable part of Twitter Lite.  If possible, we use them for push notifications, pre-caching of resources, and more.  Unfortunately, for a fairly new technology, there are many issues with performance. <br><br><h3>  Resource Pre-Caching </h3><br>  Like most products, Twitter Lite is far from perfect.  We are still actively developing it, adding features, fixing bugs, making it faster.  This means that you often need to post new versions of our JavaScript resources. <br><br>  There may be an unpleasant situation if the user opens the application - and he needs to re-download a bunch of script files in order to just watch one tweet. <br><br>  In browsers with support for service workers, we have a useful opportunity to automatically update, download and cache any modified files in the background.  This happens by itself, before the application opens. <br><br>  What does this mean for the user?  Almost instant subsequent download of the program, even if we rolled out a new version! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/195/4df/170/1954df1700475df9501f90f350a89a68.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/018/026/be5/018026be5067e53c3402fb0f9689b5e0.png"><br>  <font color="gray">Download time of network resources without service workers (above) and with service workers (below)</font> <br><br>  In the illustration above without service workers, each resource for the current viewing window should be downloaded from the network when the application opens.  On a good 3G network it takes about 6 seconds.  But if the resources are pre-cached by service workers (bottom screenshot), then on the same 3G connection the same page finishes downloading in 1.5 seconds.  Acceleration by 75%! <br><br><hr><br><h3>  Delay registration service worker </h3><br>  In many applications it is safer to register a service worker immediately when the page loads: <br><br> <code>&lt;script&gt; <br> window.navigator.serviceWorker.register('/sw.js'); <br> &lt;/script&gt;</code> <br> <br>  Although we are trying to send the browser as much data as possible to render the finished page, this is not always possible on Twitter Lite.  It happens that we have sent insufficient data or this page does not support the preliminary reception of data from the server.  Because of these and various other limitations, we have to make some API requests immediately after the page is initially loaded. <br><br>  This is usually not a problem.  But if the browser has not yet installed the current version of our service worker, then you need to inform it about the need for installation - and this leads to about 50 requests with preliminary caching of various JS, CSS, and image resources. <br><br>  When we used a simple approach with the immediate registration of our service worker, we observed a network jams in the browser, reaching the maximum limit on the number of allowed parallel requests (the top of a couple of screenshots). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/374/fd8/2b1/374fd82b1a22865bcf80d4a4ddffc001.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/fa3/45c/41d/fa345c41d4d785ffab9e757e0c59456c.png"><br>  <font color="gray">Please note that with the immediate registration of the service worker, he can block all other network requests (above).</font>  <font color="gray">If you postpone it (below), the page can load and make the necessary network requests without being blocked because of the limit on the number of simultaneous connections in the browser</font> <br><br>  We delayed the registration of the service worker until the end of the execution of additional API requests, loading CSS resources and images.  This allowed us to finish the page rendering and reduce the response time, as shown in the screenshot below. <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, only a few of the many improvements that we have made in </font></font><a href="https://mobile.twitter.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter Lite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> over time are listed here </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Certainly, there will be other improvements, and we hope that we will continue to talk about the problems found and how to solve them. </font><font style="vertical-align: inherit;">For real-time information and new insights about React and PWA, follow </font></font><a href="https://mobile.twitter.com/paularmstrong"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">me</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://mobile.twitter.com/paularmstrong/lists/twitter-lite/members"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the development team</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Twitter.</font></font></div><p>Source: <a href="https://habr.com/ru/post/327494/">https://habr.com/ru/post/327494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327484/index.html">My upgrade byndyusoft.Infrastructure | DDD + CQRS + WebApi</a></li>
<li><a href="../327486/index.html">Paparazzo. Powerful, stylish, your own. Part II</a></li>
<li><a href="../327488/index.html">What is the Cyber-Kill Chain and why should it be taken into account in the protection strategy?</a></li>
<li><a href="../327490/index.html">Powershell Empire and FuzzBunch: exploiting the notorious ETERNALBLUE vulnerability</a></li>
<li><a href="../327492/index.html">‚ÄúIn a year or two, .NET Core will replace Java in the enterprise solution market‚Äù, - Interview with Jon Skeet, Google</a></li>
<li><a href="../327498/index.html">How to learn to see the brain. Review of the book "Visual Thinking" by Dan Roem</a></li>
<li><a href="../327500/index.html">14 useful services and applications for learning English</a></li>
<li><a href="../327502/index.html">5 worst domestic design techniques from the 90s</a></li>
<li><a href="../327504/index.html">How caching will speed up your site</a></li>
<li><a href="../327506/index.html">Updated PhpStorm Yii2support plugin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>