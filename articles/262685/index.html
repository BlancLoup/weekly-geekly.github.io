<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fault detection on the example of determining the surface of an autonomous machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 In this article I will talk about how we did an autonomous machine based on our OS Embox , which detects a change in the type of surface on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fault detection on the example of determining the surface of an autonomous machine</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b55/c13/ddd/b55c13ddd1b0488ca772879fda657b5a.jpg" width="400" align="right">  Hello! <br><br>  In this article I will talk about how we did an autonomous machine based on our <a href="http://embox.github.io/">OS Embox</a> , which detects a change in the type of surface on which it is traveling. <br><br>  It so happened that in the New Year I was in the hands of a Chinese machine on the radio.  Unfortunately, she did not go.  I did not have a check from the store (the machine was a gift), and, frankly, I wanted to take it apart and look at the circuit elements.  The usual way was to get the scheme, it was necessary to unsolder.  Perhaps, at that very moment when I took up the soldering iron, I realized that it would definitely not be possible to return the machine to the store.  In short, all winter parts of my window sill were gathering dust, until one day I was caught by <a href="http://www.ofuturescholar.com/paperpage%3Fdocid%3D27282">an article from NASA</a> about detecting a discrepancy in the rover. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Just imagine for a moment: somewhere far on the red planet, the rover is hanging, hung with sensors, on a surface that can hardly be called friendly.  Therefore, it is necessary to ensure that it does not turn over, does not get stuck in the sand, does not roll down the hill, or, on the contrary, does not drive into it.  How to do it?  I wanted to answer such a difficult question. <br><a name="habracut"></a><br>  The rover was not at hand, so I decided to make a machine with two sensors - a gyroscope and an accelerometer.  And set the task to determine two situations: <br><ol><li>  The machine began to go up the hill; </li><li>  The machine began to slow down sharply (for example, drove into the sand). </li></ol><br>  In this article I will talk only about the second situation, since it is the most complete in terms of implementation. <br><br>  Two years ago I bought myself an STM32F3-Discovery, which included an Ecompass (magnetometer + accelerometer) and a gyroscope.  Remembering that my colleagues already have experience in <a href="http://habrahabr.ru/company/embox/blog/138967/">animating machines</a> , I decided that I could try to apply this board. <br><br><h4>  Reviving cars </h4><br>  Having blown away a <s>century</s> - <s>old</s> three <s>-</s> month dust from spare parts from a typewriter, I got down to business.  At the first stage, it was necessary to launch Embox on the board, and then reach the sensors.  I did this using the standard BSP library from the manufacturer.  After I managed to communicate with the sensors, I thought about how to connect the motors.  This task was easily solved (I will not describe the details of the scheme) by simply connecting through the driver for controlling the L293B motors.  I will note only a small nuance: the machine can be powered both from batteries (4 x 1.2V) and via USB.  This solution was useful in the first stage, when we did not have support for flash memory, and we had to save the data in RAM. <br><br>  When the machine started up and went, it was time to manage it.  For these purposes, we have implemented several <a href="https://github.com/embox/embox/tree/d7e7bc98d2703ffa28ee1dbd6961bd239c0ff88b/platform/stm32f3_sensors">libraries</a> : motor control, LED control, sensor library, signal filtering library, and finally, a library of alarms detection algorithms. <br><br><h4>  Test ground or 2 meters of foam rubber </h4><br>  Everyone knows that the first step in the software development process is writing tests (TDD) and creating a test environment.  Therefore, before proceeding to the solution of the task, I began to develop methods to verify that the problem was solved correctly.  Since the original task was for the rover, and I did not have the opportunity to simulate the ground well, I decided to use the available means at hand.  This improvised tool turned out to be a piece of foam rubber, which, according to its characteristics, was very different from the surface of a table or floor.  There was also an idea to use sand, but experiments had to be done in St. Petersburg, in which it rained constantly, so I had to restrict myself to ‚Äúunder-roof‚Äù methods (but, perhaps, the main reason was that I had to repeat the experiment quite often, and there was would be costly). <br><br>  In general, as a verification of the correctness of the algorithm, I decided that the machine should go in a straight line until it decided that it hit a ‚Äúbad‚Äù surface, and then just stop and turn on the LED.  In general, it was assumed that there are two LEDs, because we wanted the algorithm to distinguish the problem that the machine encountered.  The first is foam rubber, the second is just an inclined surface. <br><br>  For testing, I ran a typewriter on a flat table surface and on a table with foam rubber attached to it.  It is important that I wanted to detect not only a change in the table-&gt; foam rubber, but at the same time ignore minor irregularities (in the photo below this is a strip of foam rubber). <br><img src="https://habrastorage.org/files/185/f90/b72/185f90b72d1048f095d3fcea430e2cea.jpg" width="800"><br><br>  Now what concerns the process of debugging the algorithm.  We tuned the accelerometer to a frequency of 1344 Hz.  In the polling mode, the values ‚Äã‚Äãwere read and raw were stored in flash memory.  Then, the resulting values ‚Äã‚Äãfrom flash memory were saved to a file by calling the flashdump command from the gdb debugger.  After we had enough data files, it became possible to implement and debug algorithms in Python, and then transfer the already debugged code to the machine. <br><br><h4>  Let's return to our task. </h4><br>  Above, I mentioned the word <i>frustration</i> several times.  And in practice, this is, in general, a very understandable state - when the system begins to behave unusually.  But how to formalize it is <i>unusual</i> ? <br><br>  Mathematically, this is described as ‚Äúchanging the probabilistic characteristics of a random process.‚Äù  But this is a very general definition, we restrict ourselves to a special case.  Let there be a sequence of random variables. <img src="https://habrastorage.org/files/e1d/e5c/c19/e1de5cc19304448f97710b7f0f4b2170.png" width="4%">  In our case, these are readings from the sensors.  We assume that this is a sample from a distribution with some parametric density <img src="https://habrastorage.org/files/75a/a4b/795/75aa4b79570547fe97be92b3b7371933.png" width="5%">  .  Let it also be known that at the initial time the value of the parameter is equal to some scalar <img src="https://habrastorage.org/files/916/cc9/a61/916cc9a6138742998ab61ee4c1849d66.png">  .  By this we will understand the <i>discord</i> .  However, it is important to note that we are not interested in any changes in the density parameter, but only large ones of some h&gt; 0. This parameter h should depend on the type of surface (that is, it is an input parameter of the algorithm that is chosen ‚Äúby eye‚Äù). <br><br>  Now that we have figured out what we are trying to find, we need to understand how we will do it.  To detect the slowdown, we used the accelerometer readings along the axis in the direction of motion.  As can be seen from the graph, the readings are noisy, so the original task is divided into two subtasks: <br><ul><li>  noise filtering; </li><li>  frustration detection </li></ul><br><img src="https://habrastorage.org/files/d00/8d9/190/d008d9190e8748c2bc07700da5806edf.png" width="800"><br>  Red marked the fragment on which the slowdown occurred.  Green - uninteresting to us random irregularities.  Let's now take a closer look at the filtering task. <br><br><h4>  Noise filtering </h4><br>  Often the task of filtering set in this way.  Will consider <br><img src="https://habrastorage.org/files/398/95e/916/39895e916d8647a38c846a293844e306.png"><br>  where y (x) is the observed variables (in our case, these are accelerometer readings), f (x) is the real signal (without noise), <img src="https://habrastorage.org/files/805/a30/369/805a303697c44b3f863bc93906d49533.png" width="3%">  - noise (we believe that it has a standard normal distribution).  Required to build an estimate <img src="https://habrastorage.org/files/814/e65/e1f/814e65e1fdb144aebe2cd9b41ec9523a.png">  for <img src="https://habrastorage.org/files/55b/e97/140/55be971408b04c559763543787e01876.png">  . <br><br>  Suppose that f is continuous (in our case, this is a fairly natural assumption about the continuity of acceleration).  In this case, the usual average can be used to estimate: <br><img src="https://habrastorage.org/files/aa1/6b4/d15/aa16b4d15c884f92aa1c573281fe2db9.png"><br>  Where <img src="https://habrastorage.org/files/299/1b0/87f/2991b087f47e4efc82678a9a667530bf.png" width="4%">  - many points of observation, <img src="https://habrastorage.org/files/797/49a/fb2/79749afb2aee47d9ba78d95ce3d251b9.png" width="4%">  - power set <img src="https://habrastorage.org/files/299/1b0/87f/2991b087f47e4efc82678a9a667530bf.png" width="4%">  .  But the question arises of how to choose the window size, because we know nothing about f.  Is it possible to somehow choose it dynamically in order to achieve a better result?  It turns out that it is possible. <br><br><h4>  How to choose a window? </h4><br>  A small philosophical retreat.  In fact, of course, you can take a moving average, choose a window empirically and say that everything works.  But every time from 10 launches, when the machine could not detect an obstacle for any reason, I began to doubt it.  Therefore, let's try to get the most out of the data that we have in order to choose the window as well as possible. <br><br>  I relied on the article " <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.127.458">On the Spatial Adaptive Estimation of Nonparametric Regression</a> ".  It presents various theoretical assessments, but in this article I will not consider them, but I will tell you about the idea itself.  So, the question is how to choose the best window if a priori information about the function f is unknown.  To answer this question, we estimate the upper bound of the error difference as follows: | <img src="https://habrastorage.org/files/814/e65/e1f/814e65e1fdb144aebe2cd9b41ec9523a.png">  - <img src="https://habrastorage.org/files/55b/e97/140/55be971408b04c559763543787e01876.png">  |  rated as <br><img src="https://habrastorage.org/files/602/19b/3e7/60219b3e756942719dff38a02ff30a3e.png"><br>  Where <img src="https://habrastorage.org/files/db6/474/6a1/db64746a11484fb890fee5b0fb44d7a9.png">  , <img src="https://habrastorage.org/files/fea/8e9/f1e/fea8e9f1e5104029a8712f05d5b95a87.png">  = <img src="https://habrastorage.org/files/aaf/095/df7/aaf095df7159495da9e793b811b07b67.png">  .  The right side of the inequality consists of two parts - deterministic dynamic error. <img src="https://habrastorage.org/files/c58/cd3/a59/c58cd3a5967e40d3a2d2a1876262a94d.png">  which is completely determined by the function f, and the stochastic error <img src="https://habrastorage.org/files/251/e11/cd9/251e11cd99ac49ca88a33962dc9cd633.png">  which is completely independent of f.  Since the noise in our case has a standard normal distribution, the error can be limited from above to the exponent (with a certain probability): <br><img src="https://habrastorage.org/files/6fc/42c/3e3/6fc42c3e3d55420b89fd06dec6b481c5.png"><br>  where c&gt; 0, some constant (Here I will not describe why this is so, I can only say that during the test I used the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B0%25D0%25BB_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25B6%25D0%25B8%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B2%25D1%258B%25D0%25B1%25D0%25BE%25D1%2580%25D0%25BA%25D0%25B8">confidence interval for the mathematical expectation of a normal sample</a> .) <br><br>  Let the choice of the optimal interval comes from <img src="https://habrastorage.org/files/f06/717/d5c/f06717d5cf62412cb00be38289575dee.png">  .  That is, we fixed the point and build nested intervals with the center at this point, among which we are trying to choose the best.  Then, taking advantage of the boundedness of the error, the following inequality can be obtained at each of these intervals: <br><img src="https://habrastorage.org/files/2dd/3b5/c57/2dd3b5c57c344bd195d8744b6a8fa639.png"><br>  It is easy to verify that as i grows, the deterministic error grows, and the stochastic error decreases.  Therefore, it is reasonable to choose a window that would balance these errors.  In other words, you need to find the maximum I, such that <img src="https://habrastorage.org/files/084/1e2/0a1/0841e20a131e45db93b92462f000d599.png"><img src="https://habrastorage.org/files/76e/5f2/c26/76e5f2c2638741938027cdfaea6593c0.png">  .  Denote <img src="https://habrastorage.org/files/453/17c/807/45317c80766f43f18d70014733d45838.png" width="15%">  and we will build the intervals of the form: <br><img src="https://habrastorage.org/files/f79/c0a/244/f79c0a2441c94f8a904cf13bf31da790.png">  , <br>  Where <img src="https://habrastorage.org/files/6c5/ccd/099/6c5ccd0990ad4f2795b020b6ff2181e3.png">  this is the top score on <img src="https://habrastorage.org/files/de6/be1/9d0/de6be19d0db244ad9d24d9cb6e9c0e88.png">  what follows from the assumption that <img src="https://habrastorage.org/files/b45/d59/434/b45d59434f704d1b85f91a76c6a0c061.png">  .  It is clear that these segments will have a common point in the intersection - <img src="https://habrastorage.org/files/55b/e97/140/55be971408b04c559763543787e01876.png">  .  Now it becomes clear that you need to build such intervals as long as they have a common point of intersection, and then take the last one as the window (it will be the largest).  The result of applying such a filter is shown in the graphs below.  It can be seen that the bursts remained almost unchanged, but the oscillations along them smoothed out. <br><img src="https://habrastorage.org/files/91c/4ad/bef/91c4adbefc0246c4966b4ded2008f206.png"><br>  Fig.  1. Initial raw data from accelerometer <br><img src="https://habrastorage.org/files/e3e/0cf/13f/e3e0cf13f77c487f85d876d2826bf772.png"><br>  Fig.  2. The result of the filter <br><br>  Now that we have learned how to filter the noise, we move on to the second part, the detection of frustration. <br><br><h4>  Filtered Derivative Algorithm </h4><br>  As I wrote above, discord is a change in the probability characteristics of a random process.  An example of such a probability characteristic can be the mathematical expectation.  To be more precise, we are interested in the mat.  waiting for a sample on some window.  The graph of raw data shows that the mat.  waiting somewhere around 0. <br><img src="https://habrastorage.org/files/aed/739/acf/aed739acf74c467287fe746e1c5d13dd.png" width="800"><br>  Figure 3. The red line - the average value of the sample on the window size of 200. <br><br>  And now let's take the absolute value of acceleration.  As can be seen from the figure, there is a surge mate.  waiting  This surge we will try to detect. <br><img src="https://habrastorage.org/files/599/66f/97f/59966f97fcaf48f7b172d3b28e637173.png" width="800"><br>  Figure 4. Red line - the average value of the sample on the window size of 200. <br><br>  At the core of many methods of detecting disorder is the concept <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B4%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B1%25D0%25B8%25D1%258F">of likelihood function</a> .  This function allows us to estimate the density distribution parameter, which we talked about at the beginning.  In other words, it gives an estimate for an unknown parameter using the well-known accelerometer reading.  To understand which distribution most likely belongs to y, the likelihood ratio logarithm is used: <br><img src="https://habrastorage.org/files/0f6/5a5/086/0f65a50866fb453fbbf18628f9b31701.png"><br>  (I did not find an explanation of why logarithm is here, but most likely because of convenience: many popular distributions belong to an exponential family, and ln removes the exponential). <br><br>  As a rule, it is interesting not to change a single value, but to change the values ‚Äã‚Äãin a certain window.  To do this, you can build the following amount: <br><img src="https://habrastorage.org/files/82d/1d7/64f/82d1d764fa15434d9fbb8dc8807637da.png"><br>  Where <img src="https://habrastorage.org/files/0b4/225/67e/0b422567e14b4ac99620944f8ce9e4ee.png">  - some filter, N - window size.  Let us now once again understand what interests us?  We want to track change mate.  waiting for accelerometer values ‚Äã‚Äãalong the x axis.  At the same time we want to track the sharp slowdown of the machine.  In other words, we are interested in changing the derivative of the function. <img src="https://habrastorage.org/files/827/560/32f/82756032f4b144eeb7389b3962581d7c.png">  .  Since everything is discrete, the derivative is replaced by a difference scheme: <br><img src="https://habrastorage.org/files/ca9/2e2/29d/ca92e229dc91419784acbf774d058798.png"><br>  The moment of disorder will be defined as: <br><img src="https://habrastorage.org/files/c25/73e/367/c2573e3670264ea3a8f49c19906210a3.png"><br>  that is, we count the number of changes in the derivative by more than h, and if the number of such changes is greater than <img src="https://habrastorage.org/files/834/468/bb7/834468bb7a2d415bb3201fd6d044c7ad.png">  , there was a discord.  In the event that we are interested in changing the mat.  waiting then the function <img src="https://habrastorage.org/files/827/560/32f/82756032f4b144eeb7389b3962581d7c.png">  takes the form: <br><img src="https://habrastorage.org/files/f7c/488/867/f7c488867bc7428fa0c8fca342e98dc2.png"><br>  Where, <img src="https://habrastorage.org/files/774/349/a78/774349a789514dbe99fe22f44410d80d.png">  - the average of two mat.  expectations - initial and threshold. <br><br>  Now if as <img src="https://habrastorage.org/files/0b4/225/67e/0b422567e14b4ac99620944f8ce9e4ee.png">  take a triangular filter (i.e. <img src="https://habrastorage.org/files/8ca/ab6/7d1/8caab67d19c54e02bc694a67d1d0da38.png">  ) in order to take into account later data with less weight, you can get the following formula (easy to check on paper :)) <br><img src="https://habrastorage.org/files/018/c99/f8c/018c99f8c75540a1abe72755580ccca4.png"><br>  Where <img src="https://habrastorage.org/files/5ee/c69/a0e/5eec69a0e6814ba9b4322f497ab07caf.png">  .  That is, we track how much the average value has changed on neighboring windows.  And that's what happened for the machine: <br><img src="https://habrastorage.org/files/924/ca2/d5d/924ca2d5d76548bf9d5408f6535bebad.png" width="800"><br>  Figure 5. h = 3000 (the threshold line on the graph) <img src="https://habrastorage.org/files/834/468/bb7/834468bb7a2d415bb3201fd6d044c7ad.png">  = 1. <br><br><h4>  Result </h4><br>  The result of the two algorithms described above.  Once again I remind you what should have happened - when a slowdown is detected on the foam rubber, the machine lights the LED and turns off the motors. <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/4rKXX11HOYE%3Ffeature%3Doembed&amp;xid=17259,15700002,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhivmQMaeDON0dnahcpFxwBqq2NI4Q" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Conclusion </h4><br>  Summing up: we managed to recognize a serious slowdown of the machine, while ignoring the minor interferences in its path.  With the machine, I went to <a href="https://sites.google.com/site/traditionalschool/">TMSH 2015</a> , where I was just told about the choice of the window - thanks for this to the participants and teachers :) <br><br>  If the article seems tolerable to you, then in the future I could tell you about our further progress - using the Kalman filter to detect inclined surfaces, analyzing the dispersion (and not the mat. Expectations in this article), and generally what methods for solving this kind of problems. <br><br>  I did not provide code snippets in the article, but gave a link to the source code, since there is not a lot of code.  But if you have questions on implementation, I will be glad to answer them. <br><br>  PS <br>  When I was at TMSH 2015, several guys were interested in the software inside the machine, so leave links to the <a href="https://github.com/embox/embox/tree/d7e7bc98d2703ffa28ee1dbd6961bd239c0ff88b/platform/stm32f3_sensors">code</a> .  If someone is interested, you can repeat everything that is described in the article yourself.  Or maybe someone will even improve the algorithm or advise how this can be done. </div><p>Source: <a href="https://habr.com/ru/post/262685/">https://habr.com/ru/post/262685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262673/index.html">Archives and history spiral</a></li>
<li><a href="../262675/index.html">Asterisk: Auto-informing the callee before connecting to the operator</a></li>
<li><a href="../262679/index.html">"Y" you do not "and" short! The Importance of Unicode Normalization</a></li>
<li><a href="../262681/index.html">It's not about the number of lines of code. From serial developer modules</a></li>
<li><a href="../262683/index.html">Pros and Cons: Tier Assessment System</a></li>
<li><a href="../262687/index.html">Beeline automatically adds a toolbar and changes the design of sites.</a></li>
<li><a href="../262689/index.html">The most interesting materials about Visual Studio 2015</a></li>
<li><a href="../262693/index.html">FPGA verification. What is it?</a></li>
<li><a href="../262695/index.html">YandexBot follows the links that the user follows.</a></li>
<li><a href="../262697/index.html">Automatic migrations to Peewee</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>