<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Copy semantics and resource management in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++, the programmer must decide for himself how the used resources will be freed; there are no automatic tools like the garbage collector. The art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Copy semantics and resource management in C ++</h1><div class="post__text post__text-html js-mediator-article"><hr><p>  <i>In C ++, the programmer must decide for himself how the used resources will be freed; there are no automatic tools like the garbage collector.</i>  <i>The article discusses possible solutions to this problem, details potential problems, as well as a number of related issues.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Table of contents </h1><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><p>  <a href="https://habr.com/ru/post/425837/">Introduction</a> <br>  <a href="https://habr.com/ru/post/425837/">1. Basic copy-ownership strategies</a> <br>  <a href="https://habr.com/ru/post/425837/">1.1.</a>  <a href="https://habr.com/ru/post/425837/">Copy prohibition strategy</a> <br>  <a href="https://habr.com/ru/post/425837/">1.2.</a>  <a href="https://habr.com/ru/post/425837/">Exclusive ownership strategy</a> <br>  <a href="https://habr.com/ru/post/425837/">1.3.</a>  <a href="https://habr.com/ru/post/425837/">Deep copy strategy</a> <br>  <a href="https://habr.com/ru/post/425837/">1.4.</a>  <a href="https://habr.com/ru/post/425837/">Joint ownership strategy</a> <br>  <a href="https://habr.com/ru/post/425837/">2. Deep copy strategy - problems and solutions</a> <br>  <a href="https://habr.com/ru/post/425837/">2.1.</a>  <a href="https://habr.com/ru/post/425837/">Copy on write</a> <br>  <a href="https://habr.com/ru/post/425837/">2.2.</a>  <a href="https://habr.com/ru/post/425837/">Definition of the state exchange function for a class</a> <br>  <a href="https://habr.com/ru/post/425837/">2.3.</a>  <a href="https://habr.com/ru/post/425837/">Deletion of intermediate copies by the compiler</a> <br>  <a href="https://habr.com/ru/post/425837/">2.4.</a>  <a href="https://habr.com/ru/post/425837/">Implementing move semantics</a> <br>  <a href="https://habr.com/ru/post/425837/">2.5.</a>  <a href="https://habr.com/ru/post/425837/">Accommodation vs.</a>  <a href="https://habr.com/ru/post/425837/">inserts</a> <br>  <a href="https://habr.com/ru/post/425837/">2.6.</a>  <a href="https://habr.com/ru/post/425837/">Results</a> <br>  <a href="https://habr.com/ru/post/425837/">3. Possible options for implementing a joint ownership strategy</a> <br>  <a href="https://habr.com/ru/post/425837/">4. Exclusive ownership strategy and semantics of moving</a> <br>  <a href="https://habr.com/ru/post/425837/">5. Copy ban strategy - quick start.</a> <br>  <a href="https://habr.com/ru/post/425837/">6. The life cycle of the resource and the object-owner of the resource</a> <br>  <a href="https://habr.com/ru/post/425837/">6.1.</a>  <a href="https://habr.com/ru/post/425837/">Resource Capture During Initialization</a> <br>  <a href="https://habr.com/ru/post/425837/">6.2.</a>  <a href="https://habr.com/ru/post/425837/">Advanced options for managing the life cycle of the resource</a> <br>  <a href="https://habr.com/ru/post/425837/">6.2.1.</a>  <a href="https://habr.com/ru/post/425837/">Extended life cycle of the resource</a> <br>  <a href="https://habr.com/ru/post/425837/">6.2.2.</a>  <a href="https://habr.com/ru/post/425837/">Single capture resource</a> <br>  <a href="https://habr.com/ru/post/425837/">6.2.3.</a>  <a href="https://habr.com/ru/post/425837/">Increase Indirectness</a> <br>  <a href="https://habr.com/ru/post/425837/">6.3.</a>  <a href="https://habr.com/ru/post/425837/">Joint ownership</a> <br>  <a href="https://habr.com/ru/post/425837/">7. Results</a> <br>  <a href="https://habr.com/ru/post/425837/">Applications</a> <br>  <a href="https://habr.com/ru/post/425837/">Appendix A. Rvalue References</a> <br>  <a href="https://habr.com/ru/post/425837/">Appendix B. Movements semantics</a> <br>  <a href="https://habr.com/ru/post/425837/">Bibliography</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Introduction </h1><br><p> Resource management is something that a C ++ programmer has to do all the time.  Resources can include memory blocks, OS kernel objects, multi-threaded locks, network connections, database connections and just any object created in dynamic memory.  Access to a resource is through a descriptor, the type of the descriptor is usually a pointer or one of its aliases ( <code>HANDLE</code> , etc.), sometimes integer (UNIX file descriptors).  After using the resource, it is necessary to free it, otherwise, sooner or later, an application that does not release resources (and possibly other applications) will face a shortage of resources.  This problem is very acute, it can be said that one of the key features of the .NET, Java and several other platforms is a unified resource management system based on garbage collection. </p><br><p>  Object-oriented features of C ++ naturally lead to the following solution: the class that manages the resource contains the resource handle as a member, initializes the handle when the resource is captured, and frees the resource in the destructor.  But after some reflection (or experience) there comes an understanding that not everything is so simple.  And the main problem is the semantics of copying.  If the class that manages the resource uses the copy constructor generated by the compiler by default, then after copying the object we get two copies of the descriptor of the same resource.  If one object frees a resource, then the second can attempt to use or release an already freed resource, which in any case is incorrect and can lead to so-called undefined behavior, that is, anything can happen, for example, a program crash. </p><br><p>  Fortunately, in C ++, the programmer can fully control the copying process by means of his own definition of the copy constructor and the copy assignment operator, which allows to solve the problem described above, and usually not in one way.  The implementation of copying should be closely linked to the resource release mechanism, and this together we will call the copy-ownership strategy.  The so-called ‚ÄúBig Three Rule‚Äù is well known, which states that if a programmer has defined at least one of the three operations ‚Äî a copy constructor, a copy assignment operator, or a destructor ‚Äî then he must define all three operations.  Copy-ownership strategies specify how to do this.  There are four basic copy-ownership strategies. </p><br><a name="id-1"></a><br><h1>  1. Basic copy-ownership strategies </h1><br><p>  Before or after the resource is captured, the descriptor must take a special value indicating that it is not associated with the resource.  This is usually zero, sometimes -1, reduced to the type of descriptor.  In any case, such a descriptor will be called zero.  The class that manages the resource must recognize the null descriptor and not try to use or free the resource in this case. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Copy prohibition strategy </h2><br><p>  This is the simplest strategy.  In this case, it is simply forbidden to copy and assign class instances.  The destructor frees the captured resource.  In C ++, it is not difficult to prohibit copying; the class must declare, but not define, the closed copy constructor and the copy assignment operator. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Attempts to copy are stopped by the compiler and linker. </p><br><p>  The C ++ 11 standard offers a special syntax for this case: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  This syntax is more intuitive and gives more understandable compiler messages when attempting to copy. </p><br><p>  In the previous version of the standard library (C ++ 98), the copy prohibition strategy used I / O stream classes ( <code>std::fstream</code> , etc.), while in Windows many classes from MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.) were used.  In the standard C ++ 11 library, some classes use this strategy to support multi-threaded synchronization. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Exclusive ownership strategy </h2><br><p>  In this case, when implementing copying and assignment, the resource handle moves from the source object to the target object, that is, it remains in a single copy.  After copying or assignment, the source object has a null descriptor and cannot use the resource.  The destructor frees the captured resource.  For this strategy, the terms exclusive or strict possession of [Josuttis], Andrei Alexandrescu [Alexandrescu] uses the term destructive copying.  In C ++ 11, this is done in the following way: normal copying and copying assignment are prohibited in the manner described above, and the semantics of movement are implemented, that is, the translational constructor and the movement assignment operator are defined.  (More on the semantics of moving on.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Thus, the exclusive ownership strategy can be considered an extension of the copy ban strategy. </p><br><p>  In the standard C ++ library, this strategy uses the smart pointer <code>std::unique_ptr&lt;&gt;</code> and some other classes, for example: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , as well as classes that previously used the copy prohibition strategy ( <code>std::fstream</code> , etc.).  In Windows, the MFC classes that previously used the copy prohibition strategy also began to use the exclusive ownership strategy ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Deep copy strategy </h2><br><p>  In this case, you can copy and assign instances of the class.  You must define a copy constructor and a copy assignment operator, so that the target object copies the resource to itself from the source object.  After that, each object owns its own copy of the resource, and can independently use, modify, and release the resource.  The destructor frees the captured resource.  Sometimes for objects using the deep copy strategy, the term value objects is used. </p><br><p>  This strategy does not apply to all resources.  It can be applied to resources associated with a memory buffer, such as strings, but it is not very clear how to apply it to OS kernel objects such as files, mutexes, etc. </p><br><p>  The deep copy strategy is used in all types of object strings, <code>std::vector&lt;&gt;</code> and other containers of the standard library. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Joint ownership strategy </h2><br><p>  In this case, you can copy and assign instances of the class.  You must define a copy constructor and a copy assignment operator, in which the resource descriptor (as well as other data) is copied, but not the resource itself.  After that, each object has its own copy of the descriptor, can use, modify, but cannot release the resource, while there is at least one more object that owns a copy of the descriptor.  The resource is released after the last object that owns the copy of the descriptor goes out of scope.  How this can be implemented is described below. </p><br><p>  Smart pointers are often used in a joint ownership strategy; it is also natural to use it for immutable resources.  In the standard C ++ 11 library, this strategy is implemented by the smart pointer <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-2"></a><br><h1>  2. Deep copy strategy - problems and solutions </h1><br><p>  Consider the template function of the exchange of states of objects of type <code>T</code> in the standard library C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  If type <code>T</code> owns a resource and uses a deep copying strategy, then we have three operations for allocating a new resource, three operations for copying and three operations for releasing resources.  Whereas in most cases this operation can be carried out at all without allocating new resources and copying, it is enough for the objects to exchange internal data, including the resource descriptor.  There are many examples of such examples when you have to create temporary copies of a resource and release them immediately.  Such an inefficient implementation of daily operations has stimulated the search for solutions to optimize them.  Consider the main options. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Copy on write </h2><br><p>  Copy on write (COW), also known as deferred copying, can be viewed as an attempt to combine a deep copy strategy and a joint ownership strategy.  Initially, when copying an object, the resource descriptor is copied, without the resource itself, and for the owners, the resource becomes shared and available in read-only mode, but as soon as some owner needs to modify the shared resource, the resource is copied and then the owner works with his a copy.  The implementation of the COW solves the problem of exchanging states: there is no additional resource allocation and copying.  Using COW is quite popular when implementing strings; <code>CString</code> (MFC, ATL) can be <code>CString</code> as an example.  A discussion of possible ways to implement COW and problems that arise can be found in [Meyers1], [Sutter].  Guntheroth proposes an implementation of COW using <code>std::shared_ptr&lt;&gt;</code> .  There are problems with the implementation of COW in a multi-threaded environment, which is why in the standard C ++ 11 library it is forbidden to use COW for strings, see [Josuttis], [Guntheroth]. </p><br><p>  The development of the COW idea leads to the following resource management scheme: the resource is immutable and is controlled by objects using the joint ownership strategy, if necessary, a new, appropriately modified resource is created and the new owner object is returned.  This scheme is used for strings and other immutable objects on .NET and Java platforms.  In functional programming, it is used for more complex data structures. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Definition of the state exchange function for a class </h2><br><p>  It was shown above how inefficient the state exchange function, implemented straightforward, through copying and assignment, can work.  And it is used quite widely, for example, it is used by many algorithms of the standard library.  In order for algorithms to use not <code>std::swap()</code> , but another function specifically defined for a class, you must perform two steps. </p><br><p>  1. Determine in the class a member function <code>Swap()</code> (the name does not matter) that implements the exchange of states. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  It is necessary to ensure that this function does not throw exceptions; in C ++ 11, such functions must be declared as <code>noexcept</code> . </p><br><p>  2. In the same namespace as class <code>X</code> (usually in the same header file), define the free (non-member) function <code>swap()</code> as follows (the name and signature are fundamental): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  After that, the algorithms of the standard library will use it, not <code>std::swap()</code> .  This provides a mechanism called search dependent on argument types (argument dependent lookup, ADL).  For more on ADL, see [Dewhurst1]. </p><br><p>  In the standard C ++ library, all containers, smart pointers, and other classes implement the state exchange function in the manner described above. </p><br><p>  The member function <code>Swap()</code> is usually easy to determine: it is necessary to consistently apply the state exchange operation to the databases and members, if they support it, and <code>std::swap()</code> otherwise. </p><br><p>  The above description is somewhat simplified, more detailed can be found in [Meyers2].  A discussion of problems related to the state exchange function can also be found in [Sutter / Alexandrescu]. </p><br><p>  The state exchange function can be attributed to one of the basic class operations.  With it, you can gracefully define other operations.  For example, the copy assignment operator is defined by copying and <code>Swap()</code> as follows: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  This template is called the ‚Äúcopy and share‚Äù idiom or the Sutter's emblem idiom, see [Sutter], [Sutter / Alexandrescu], [Meyers2] for more details.  Its modification can be applied to the implementation of the semantics of displacement, see sections 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Deletion of intermediate copies by the compiler </h2><br><p>  Consider the class </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  And function </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  In the case of a straight-line approach, the return from the function <code>Foo()</code> is realized by copying an instance of <code>X</code>  But compilers can remove a copy operation from code, an object is created directly at the call point.  This is called return value optimization (RVO).  RVO has been used by compiler developers for a long time and is currently fixed in the C ++ 11 standard.  Although the compiler decides on RVO, the programmer can write code for its use.  For this, it is desirable that the function has one return point and the type of the returned expression matches the type of the return value of the function.  In some cases, it is advisable to define a special closed constructor, called a ‚Äúcomputational constructor,‚Äù for more details, see [Dewhurst2].  RVO is also discussed in [Meyers3] and [Guntheroth]. </p><br><p>  Compilers can also remove intermediate copies in other situations. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implementing move semantics </h2><br><p>  The implementation of the movement semantics consists in defining a translational constructor that has a parameter of the type rvalue-reference to the source and a motion assignment operator with the same parameter. </p><br><p>  In the standard C ++ 11 library, the state exchange function template is defined as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  In accordance with the rules for allowing overloads of functions that have parameters of type rvalue-reference (see Appendix A), in the case when type <code>T</code> has a displacement constructor and a transfer assignment operator, they will be used, and there will be no allocation of temporary resources and copying.  Otherwise, a copy constructor and a copy assignment operator will be used. </p><br><p>  The use of move semantics avoids the creation of temporary copies in a much wider context than the state exchange function described above.  Move semantics applies to any rvalue value, that is, a temporary, unnamed value, as well as to the return value of the function if it is created locally (including the lvalue), and no RVO has been applied.  In all these cases, it is guaranteed that the source object cannot be used in any way after the movement has been completed.  Move semantics also applies to an lvalue value to which the <code>std::move()</code> transformation is applied.  But in this case, the programmer himself is responsible for how the source objects will be used after the move (example <code>std::swap()</code> ). </p><br><p>  The standard C ++ 11 library has been reworked to reflect the movement semantics.  Many classes have added a relocation constructor and a move assignment operator, as well as other member functions, with parameters of type rvalue-reference.  For example, <code>std::vector&lt;T&gt;</code> has an overloaded version of the <code>void push_back(T&amp;&amp; src)</code> .  All this allows in many cases to avoid creating temporary copies. </p><br><p>  Implementing move semantics does not override the definition of the state exchange function for a class.  A specially defined state exchange function can be more efficient than the standard <code>std::swap()</code> .  Moreover, a moving constructor and a moving assignment operator are very easily determined using the state exchange member function as follows (a variation of the idiom "copy and exchange"): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  The relocation constructor and relocation assignment operator belong to those member functions for which it is highly desirable to ensure that they do not throw exceptions, and, accordingly, are declared as <code>noexcept</code> .  This allows you to optimize some operations of the containers of the standard library without violating the strict security guarantee of exceptions, for more details, see [Meyers3] and [Guntheroth].  The proposed template provides such a guarantee, provided that the default constructor and the member state exchange function do not throw exceptions. </p><br><p>  The C ++ 11 standard provides for the compiler to automatically generate a translation constructor and a transfer assignment operator; to do this, they must be declared using the <code>"=default"</code> construct. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Operations are implemented by successively applying a move operation to databases and class members, if they support moving, and copy operations otherwise.  It is clear that this option is far from always acceptable.  Raw descriptors do not move, but you cannot usually copy them.  If certain conditions are met, the compiler may independently generate such a moving constructor and a move assignment operator, but it is better not to use this opportunity, these conditions are rather complicated and can easily change when the class is refined.  See [Meyers3] for details. </p><br><p>  In general, the implementation and use of movement semantics is a rather ‚Äúthin thing‚Äù.  The compiler can apply copying where the programmer expects movement.  Let us cite several rules that allow us to exclude or at least reduce the likelihood of such a situation. </p><br><ol><li>  If possible, use a copy ban. </li><li>  Declare a relocation constructor and a move assignment operator as <code>noexcept</code> . </li><li>  Implement move semantics for base classes and members. </li><li>  Apply the <code>std::move()</code> transformation to the parameters of functions of the type rvalue-reference. </li></ol><br><p>  Rule 2 was discussed above.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      ‚Äî   (variadic templates),         .  ,      C++11 ‚Äî     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2> 2.6.  Results </h2><br><p>     ,    ,     .               -  .                   .   ‚Äî     :    ,    .     ,       ,     ,  .      :     ,     ,  ¬´¬ª   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    ‚Äî   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    ‚Äî   .     6. </p><br><p>   ,     -  -,  ¬´  ¬ª,   -     .         -    . ,   ,     ,     ,    -       .      ¬´¬ª. </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          ¬´   ¬ª (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      ¬´¬ª RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2>  6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3>  6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     ¬´  ¬ª,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3>  6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  ¬´¬ª RAII,   ‚Äî          .      ,     ,    . 3.       .    ¬´¬ª,    . </p><br><a name="id-6-2-3"></a><br><h3>  6.2.3.    </h3><br><p>        ‚Äî    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2>  6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Applications </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- ‚Äî      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         ‚Äî    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Bibliography </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Alexandrescu] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu, Andrei. </font><font style="vertical-align: inherit;">Modern design in C ++ .: Trans.</font></font> from English  - M .: OOO ‚ÄúI.D.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Williams, 2002. </font></font></p><br><p> [Guntheroth] <br> , .    C++.     .: .  from English ‚Äî .:  ¬´-¬ª, 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  from English  - M .: OOO ‚ÄúI.D. ¬ª, 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  from English ‚Äî .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  from English ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  from English ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  from English ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  from English  - M .: OOO ‚ÄúI.D. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  from English ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  from English  - M .: OOO ‚ÄúI.D. ¬ª, 2015. </p><br><p> [Schildt] <br> , .    C++.: .  from English ‚Äî .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  from English ‚Äî .:  ¬´ ¬´¬ª, 1999. </p><br></div></div><br><br></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425837/">https://habr.com/ru/post/425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425827/index.html">Google+ lesson: projects should be monitored so that the boundaries between the interests of users in real life are respected and online</a></li>
<li><a href="../425829/index.html">How we fought Roskomnadzor and what came of it</a></li>
<li><a href="../425831/index.html">RKN Alert - Roskomnadzor database in your browser</a></li>
<li><a href="../425833/index.html">A tool to help you choose the best product ideas.</a></li>
<li><a href="../425835/index.html">"Breaking Bugs" in Sberbank: how to fix the seven-day rate of bugs per day</a></li>
<li><a href="../425839/index.html">Atlassian Conference Overview</a></li>
<li><a href="../425843/index.html">Python for the child: the choice of tutorial</a></li>
<li><a href="../425845/index.html">Auto-blocking apps on Google Play</a></li>
<li><a href="../425847/index.html">An example of using Microsoft Flow or How to give a wife flowers</a></li>
<li><a href="../425849/index.html">Amazon gave up and raised employee salaries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>