<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GraphQL and Golang</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL technology over the past few years, after the Facebook company transferred it to the category of open-source, has become very popular. The aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GraphQL and Golang</h1><div class="post__text post__text-html js-mediator-article">  GraphQL technology over the past few years, after the Facebook company transferred it to the category of open-source, has become very popular.  The author of the material, the translation of which we are publishing today, says that he tried to work with GraphQL in the Node.js environment and was convinced from his own experience that this technology, thanks to its remarkable capabilities and simplicity, attracts so much attention to itself.  Recently, he was engaged in a new project, moved from Node.js to Golang.  Then he decided to try the joint work of Golang and GraphQL. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/444346/"><img src="https://habrastorage.org/webt/jp/qa/qv/jpqaqvlt5xh7d7mlhwpxvvwhptq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Preliminary Information</font> </h2><br>  From the official definition of GraphQL, you can find out that this is a query language for APIs and a runtime environment for executing such queries on existing data.  GraphQL provides a complete and understandable description of the data in some kind of API, allows customers to request exactly the information they need, and nothing more, simplifies the development of the API over time and gives developers powerful tools. <br><br>  There are not many GraphQL libraries for Golang.  In particular, I have tested such libraries as <a href="https://github.com/samsarahq/thunder">Thunder</a> , <a href="https://github.com/graphql-go/graphql">graphql</a> , <a href="https://github.com/graph-gophers/graphql-go">graphql-go</a> , and <a href="https://github.com/99designs/gqlgen">gqlgen</a> .  I should note that the gqlgen library has become the best I've ever tried. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The gqlgen library is still at the beta stage, at the time of writing this material it was version <a href="">0.7.2</a> .  The library is rapidly evolving.  <a href="https://github.com/99designs/gqlgen/projects/1">Here</a> you can learn about plans for its development.  Now the official sponsor of gqlgen is the <a href="https://99designs.com/">99designs</a> project, which means that this library, quite possibly, will develop even faster than before.  The main developers of this library are <a href="https://github.com/vektah">vektah</a> and <a href="https://github.com/neelance">neelance</a> , while neelance is also working on the graphql-go library. <br><br>  Let's talk about the gqlgen library on the assumption that you already have some basic knowledge of GraphQL. <br><br><h2>  <font color="#3AC1EF">Gqlgen features</font> </h2><br>  In the description of gqlgen, you can find out what is in front of us is a library for quickly creating strongly typed GraphQL servers on Golang.  This phrase seems to me very promising, as it means that while working with this library I will not come across something like <code>map[string]interface{}</code> , since it uses an approach based on strong typing. <br><br>  In addition, this library uses an approach based on a data scheme.  This means that the API is described using GraphQL <a href="http://graphql.org/learn/schema/">Schema Definition Language</a> .  Related to this language are its own powerful code-generation tools, which automatically create GraphQL code.  The programmer can only implement the basic logic of the relevant interface methods. <br><br>  This article is divided into two parts.  The first is devoted to the basic techniques of work, and the second - advanced. <br><br><h2>  <font color="#3AC1EF">Basic techniques of work: setup, requests for data acquisition and change, subscriptions</font> </h2><br>  We, as an experimental application, will use a site where users can post videos, add screenshots and reviews, search for videos and view lists of records associated with other records.  Let's start working on this project: <br><br><pre> <code class="go hljs">mkdir -p $GOPATH/src/github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/</code> </pre> <br>  Create the following data schema file ( <code>schema.graphql</code> ) in the project root directory: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User {   id: ID!   name: String!   email: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video {   id: ID!   name: String!   description: String!   user: User!   url: String!   createdAt: Timestamp!   screenshots: [Screenshot]   related(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Screenshot {   id: ID!   videoId: ID!   url: String! } input NewVideo {   name: String!   description: String!   userId: ID!   url: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Query {   Videos(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } scalar Timestamp</code> </pre> <br>  This describes the basic data models, one mutation ( <code>Mutation</code> , a description of the data change request), which is used to publish new video files on the site, and one query ( <code>Query</code> ) to get a list of all video files.  You can read more about GraphQL scheme <a href="https://graphql.org/learn/schema">here</a> .  In addition, here we declared one own scalar data type.  The 5 standard scalar data <a href="https://graphql.org/learn/schema/">types</a> ( <code>Int</code> , <code>Float</code> , <code>String</code> , <code>Boolean</code> and <code>ID</code> ) that are in GraphQL are not enough. <br><br>  If you need to use your own types, you can declare them in <code>schema.graphql</code> (in our case, the type is <code>Timestamp</code> ) and provide their definitions in code.  When using the gqlgen library, you need to provide marshaling and unmarshaling methods for all of your own scalar types and configure mapping with <code>gqlgen.yml</code> . <br><br>  It should be noted that in the latest version of the library one important change has appeared.  Namely, the dependency on compiled binary files was removed from it.  Therefore, in the project, you need to add the <code>scripts/gqlgen.go</code> file <code>scripts/gqlgen.go</code> following content: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// +build ignore package main import "github.com/99designs/gqlgen/cmd" func main() { cmd.Execute() }</span></span></code> </pre> <br>  After that, you need to initialize <code>dep</code> : <br><br><pre> <code class="go hljs">dep init</code> </pre> <br>  Now it's time to take advantage of the code generation library.  They allow you to create all the boring sample code, which, however, can not be called very very uninteresting.  To start the mechanism of automatic code generation, execute the following command: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> init</code> </pre> <br>  As a result of its execution, the following files will be created: <br><br><ul><li>  <code>gqlgen.yml</code> : configuration file for managing code generation. <br></li><li>  <code>generated.go</code> : generated code. <br></li><li>  <code>models_gen.go</code> : all models and data types of the provided schema. <br></li><li>  <code>resolver.go</code> : here will be the code that the programmer creates. <br></li><li>  <code>server/server.go</code> : entry point with <code>http.Handler</code> to start GraphQL server. <br></li></ul><br>  Let's take a look at the generated model for the <code>Video</code> type ( <code>generated_video.go</code> file): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> User        User  <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Screenshots []*Screenshot <span class="hljs-string"><span class="hljs-string">`json:"screenshots"`</span></span> Related     []Video  <span class="hljs-string"><span class="hljs-string">`json:"related"`</span></span> }</code> </pre> <br>  Here you can see that <code>ID</code> is a string, <code>CreatedAt</code> is also a string.  Other related models are configured accordingly.  However, in real applications it is not necessary.  If you use any type of SQL data, then you need, for example, that the <code>ID</code> field would have an <code>int</code> or <code>int64</code> type, depending on the database used. <br><br>  For example, I use PostgreSQL in this demo application, so, of course, I need the <code>ID</code> field to be of type <code>int</code> , and the field of <code>CreatedAt</code> is of type <code>time.Time</code> .  This leads to the fact that we need to define our own model and tell gqlgen to use our model instead of generating a new one.  Here is the contents of the <code>models.go</code> file: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> User        User <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Related     []Video } <span class="hljs-comment"><span class="hljs-comment">//    int  ID func MarshalID(id int) graphql.Marshaler { return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.Quote(fmt.Sprintf("%d", id))) }) } //        func UnmarshalID(v interface{}) (int, error) { id, ok := v.(string) if !ok {   return 0, fmt.Errorf("ids must be strings") } i, e := strconv.Atoi(id) return int(i), e } func MarshalTimestamp(t time.Time) graphql.Marshaler { timestamp := t.Unix() * 1000 return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.FormatInt(timestamp, 10)) }) } func UnmarshalTimestamp(v interface{}) (time.Time, error) { if tmpStr, ok := v.(int); ok {   return time.Unix(int64(tmpStr), 0), nil } return time.Time{}, errors.TimeStampError }</span></span></code> </pre> <br>  Let us indicate to the library that it should use these models (the <code>gqlgen.yml</code> file): <br><br><pre> <code class="go hljs">schema: - schema.graphql exec: filename: generated.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> model: filename: models_gen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> resolver: filename: resolver.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resolver models: Video:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Video ID:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.ID Timestamp:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Timestamp</code> </pre> <br>  The point of all this is that we now have our own definitions for <code>ID</code> and <code>Timestamp</code> with marshaling and unmarshaling methods and their mapping in the <code>gqlgen.yml</code> file.  Now, when the user provides the string as an <code>ID</code> , the <code>UnmarshalID()</code> method converts the string to an integer.  When sending a response, the <code>MarshalID()</code> method converts the number to a string.  The same happens with the <code>Timestamp</code> or with any other scalar type declared by the programmer. <br><br>  Now it's time to implement the application logic.  Open the <code>resolver.go</code> file and enter descriptions of mutations and requests into it.  There is already an automatically generated template code that we need to fill with meaning.  Here is the code for this file: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { newVideo := api.Video{   URL:         input.URL,   Name:        input.Name,   CreatedAt:   time.Now().UTC(), } rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"INSERT INTO videos (name, url, user_id, created_at) VALUES($1, $2, $3, $4) RETURNING id"</span></span>,   input.Name, input.URL, input.UserID, newVideo.CreatedAt) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;newVideo.ID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.IsForeignKeyError(err) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.UserNotExist   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVideo, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *queryResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Videos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, limit *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, offset *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]api.Video, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> video api.Video <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videos []api.Video rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"SELECT id, name, url, created_at, user_id FROM videos ORDER BY created_at desc limit $1 offset $2"</span></span>, limit, offset) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;video.ID, &amp;video.Name, &amp;video.URL, &amp;video.CreatedAt, &amp;video.UserID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {     errors.DebugPrintf(err)     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError   }   videos = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(videos, video) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videos, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Now let's test the mutation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/a2c/01f/f7ba2c01f766ebc31ed90880376136f1.png"></div>  <i><font color="#999999">CreateVideo mutation</font></i> <br><br>  Works!  But why is there nothing in the user information ( <code>user</code> object)?  When working with GraphQL, concepts similar to ‚Äúlazy‚Äù (lazy) and ‚Äúgreedy‚Äù (eager) loading are applicable.  Since this system is expandable, you need to specify which fields need to be filled ‚Äúgreedily‚Äù and which ones are ‚Äúlazy‚Äù. <br><br>  I suggested to the team in the organization where I work the following ‚Äúgolden rule‚Äù applied when working with gqlgen: ‚ÄúDo not include the fields in the model that need to be loaded only if they are requested by the client.‚Äù <br><br>  In our case, I only need to download data about related video clips (and even information about users) if the client requests these fields.  But since we included these fields in the model, gqlgen assumes that we provide this data by getting information about the video.  As a result, we now get empty structures. <br><br>  Sometimes it happens that data of a certain type is needed every time, so it is inappropriate to load it with a separate request.  To do this, for the sake of improving performance, you can use something like SQL unions.  One day (this, however, does not apply to the example considered here), I needed to have his metadata loaded with the video as well.  These entities were stored in different places.  As a result, if my system received a request to download a video, I had to make another request to receive metadata.  But, since I knew about this requirement (that is, I knew that on the client side both the video and its metadata are always needed), I preferred to use the ‚Äúgreedy‚Äù loading technique to improve performance. <br><br>  Let's rewrite the model and generate the gqlgen code again.  In order not to complicate the narration, we will write only methods for the <code>user</code> field (file <code>models.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> UserID      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"-"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> }</code> </pre> <br>  We added a <code>UserID</code> and removed the <code>User</code> structure.  Now re-generate the code: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Thanks to this command, the following interface methods will be created to resolve undefined structures.  In addition, you will need to define the following in the resolver ( <code>generated.go</code> file): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> VideoResolver <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { User(ctx context.Context, obj *api.Video) (api.User, error) Screenshots(ctx context.Context, obj *api.Video) ([]*api.Screenshot, error) Related(ctx context.Context, obj *api.Video, limit *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, offset *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ([]api.Video, error) }</code> </pre> <br>  Here is the definition ( <code>resolver.go</code> file): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { rows, _ := dal.LogAndQuery(r.db,<span class="hljs-string"><span class="hljs-string">"SELECT id, name, email FROM users where id = $1"</span></span>, obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user api.User <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Now the results of the test mutations will look as shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25a/41d/aaa/25a41daaa86b8db5407bd432312c3028.png"></div><br>  <i><font color="#999999">CreateVideo mutation</font></i> <br><br>  What we have just discussed is the basis of GraphQL, having mastered that, you can already write something of your own.  However, before you dive into experiments with GraphQL and Golang, it will be useful to talk about subscriptions (subscription), which are directly related to what we are doing here. <br><br><h3>  <font color="#3AC1EF">‚ñçFollowing</font> </h3><br>  GraphQL provides the ability to subscribe to changes in data that occur in real time.  The gqlgen library allows, in real time, using web sockets to work with subscription events. <br><br>  The subscription must be described in the <code>schema.graphql</code> file.  Here is the description of a subscription to a video posting event: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subscription {   videoPublished: Video! }</code> </pre> <br>  Now, again, run the automatic code generation: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  As already mentioned, during the automatic generation of code in the <code>generated.go</code> file, an interface is created that needs to be implemented in the resolver.  In our case it looks like this ( <code>resolver.go</code> file): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videoPublishedChannel <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { videoPublishedChannel = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video{} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subscriptionResolver <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Resolver } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *subscriptionResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VideoPublished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> api.Video, error)</span></span></span></span> { id := randx.String(<span class="hljs-number"><span class="hljs-number">8</span></span>) videoEvent := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   &lt;-ctx.Done() }() videoPublishedChannel[id] = videoEvent <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videoEvent, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ... for _, observer := range videoPublishedChannel {   observer &lt;- newVideo } return newVideo, nil }</span></span></code> </pre> <br>  Now, when creating a new video, you need to trigger an event.  In our example, this is done in the <code>for _, observer := range videoPublishedChannel</code> line <code>for _, observer := range videoPublishedChannel</code> . <br><br>  Now it's time to check out the subscription. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/d7f/42b/f71d7f42b147f59d227a25e577ef57fb.gif"></div><br>  <i><font color="#999999">Subscription check</font></i> <br><br>  GraphQL, of course, has certain valuable features, but, as they say, not all is gold that glitters.  Namely, we are talking about the fact that those who use GraphQL need to take care of authorization, query complexity, caching, the problem of N + 1 queries, limiting the speed of query execution and some other things.  Otherwise, the system developed using GraphQL may face a serious drop in performance. <br><br><h2>  <font color="#3AC1EF">Advanced work practices: authentication, data loaders, query complexity</font> </h2><br>  Every time I read manuals like this, I get a feeling that, having mastered them, I will learn everything I need to know about a certain technology and get the ability to solve problems of any complexity. <br><br>  But when I start working on my own projects, I usually find myself in unforeseen situations that look like server errors or requests that have been running for ages, or some other deadlock situation.  As a result, in order to do business, I had to better understand what had only recently seemed completely understandable.  In the same manual, I hope this can be avoided.  That is why in this section we will look at some advanced techniques for working with GraphQL. <br><br><h3>  <font color="#3AC1EF">‚ñç Authentication</font> </h3><br>  When working with the REST API, we have an authentication system and standard authorization tools when working with a certain endpoint.  But when using GraphQL, only one endpoint is used, so the authentication tasks can be solved using schema directives.  Edit the <code>schema.graphql</code> file as follows: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! @isAuthenticated } directive @isAuthenticated on FIELD_DEFINITION</code> </pre> <br>  We created an <code>isAuthenticated</code> directive and applied it to the <code>createVideo</code> subscription.  After the next session of automatic code generation, you need to define a definition for this directive.  Now directives are implemented as methods of structures, and not as interfaces, so we need to describe them.  I edited the automatically generated code in the <code>server.go</code> file and created a method that returns the GraphQL configuration for the <code>server.go</code> file.  Here is the <code>resolver.go</code> file: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>  Here is the <code>server.go</code> file: <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware(   db,   handler.GraphQL(     go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)   ) ) http.Handle(<span class="hljs-string"><span class="hljs-string">"/query"</span></span>, auth.AuthMiddleware(rootHandler))</code> </pre> <br>  We read the user <code>ID</code> from the context.  Doesn't it seem strange to you?  How did this meaning fit into the context and why did it even appear in the context?  The fact is that gqlgen provides request contexts only at the implementation level, so we are not able to read any HTTP request data, such as headers or cookies, in recognizers or directives.  As a result, you need to add your own intermediate mechanisms to the system, obtain this data and put it in context. <br><br>  Now we need to describe our own intermediate authentication mechanism to obtain authentication data from the request and verify it. <br><br>  No logic is defined here.  Instead, as authorization data, for demonstration purposes, the user <code>ID</code> simply transmitted here.  This mechanism is then integrated into <code>server.go</code> with a new configuration loading method. <br><br>  Now the description of the directive makes sense.  We do not process requests of unauthorized users in the code of the intermediate layer, since such requests will be processed by the directive.  Here's what it looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f6/a26/09c/6f6a2609cec8936c024fd68c7ed30096.png"></div><br>  <i><font color="#999999">Work with unauthorized user</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/b92/378/267b923783521a82738973f82600a2a4.png"></div><br>  <i><font color="#999999">Work with authorized user</font></i> <br><br>  When working with schema directives, you can even pass arguments: <br><br><pre> <code class="go hljs">directive @hasRole(role: Role!) on FIELD_DEFINITION enum Role { ADMIN USER }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçData Loaders</font> </h3><br>  It seems to me that all this looks quite interesting.  You load data when you need it.  Customers have the ability to manage data from the storage takes exactly what you need.  But everything has its price. <br><br>  What have to "pay" for these opportunities?  Take a look at the logs download all videos.  Namely, we are talking about the fact that we have 8 videos and 5 users. <br><br><pre> <code class="go hljs">query{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>){   name   user{     name   } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/7c1/b5c/5627c1b5c34f74aec26381f8b0431147.png"></div><br>  <i><font color="#999999">Video Upload Information</font></i> <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  What's going on here?  Why are there 9 requests (1 request is associated with the video table and 8 with the user table)?  It looks awful.  My heart almost stopped when I thought that our existing API would have to be replaced with this ... However, data loaders help to completely cope with this problem. <br><br>  This is known as the N + 1 problem. The point is that there is one query to get all the data and for each data fragment (N) there will be another database query. <br><br>  This is a very serious problem when it comes to performance and resources: although these requests are parallel, they drain system resources. <br><br>  To solve this problem, we will use the <a href="https://github.com/vektah/dataloaden">dataloaden</a> library from the author of the gqlgen library.  This library allows you to generate go code.  First, generate the data loader for the <code>User</code> entity: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/vektah/dataloaden dataloaden github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.User</code> </pre> <br>  We will have a <code>userloader_gen.go</code> file <code>userloader_gen.go</code> methods like <code>Fetch</code> , <code>LoadAll</code> and <code>Prime</code> . <br><br>  Now we need to define the <code>Fetch</code> method ( <code>dataloader.go</code> file) to get general results: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataloaderMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB, next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> {   userloader := UserLoader{     wait : <span class="hljs-number"><span class="hljs-number">1</span></span> * time.Millisecond,     maxBatch: <span class="hljs-number"><span class="hljs-number">100</span></span>,     fetch: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*api.User, []error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids) == <span class="hljs-number"><span class="hljs-number">1</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id = ?"</span></span>       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id IN (?)"</span></span>       }       sqlQuery, arguments, err := sqlx.In(sqlQuery, ids)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       sqlQuery = sqlx.Rebind(sqlx.DOLLAR, sqlQuery)       rows, err := dal.LogAndQuery(db, sqlQuery, arguments...)       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       userById := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]*api.User{}       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {         user:= api.User{}         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {           errors.DebugPrintf(err)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []error{errors.InternalServerError}         }         userById[user.ID] = &amp;user       }       users := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*api.User, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids))       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, id := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ids {         users[i] = userById[id]         i++       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>     },   }   ctx := context.WithValue(r.Context(), CtxKey, &amp;userloader)   r = r.WithContext(ctx)   next.ServeHTTP(w, r) }) }</code> </pre> <br>  Here we expect for 1 ms.  before executing the request and collect requests in packages of up to 100 requests.  Now, instead of performing a request for each user individually, the loader will wait for the specified time before accessing the database.  Next, you need to change the logic of the recognizer, reconfiguring it using the request to use the data loader ( <code>resolver.go</code> file): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { user, err := ctx.Value(dataloaders.CtxKey).(*dataloaders.UserLoader).Load(obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *user, err }</code> </pre> <br>  Here is how the logs look after this in a situation similar to the above: <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Dataloader: User : SELECT id, name, email from users WHERE id IN ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>, $<span class="hljs-number"><span class="hljs-number">3</span></span>, $<span class="hljs-number"><span class="hljs-number">4</span></span>, $<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  Here, only two database queries are executed; as a result, everyone is happy now.  ,      5  ,     8 .    ,      . <br><br><h3> <font color="#3AC1EF">‚ñç </font> </h3><br> GraphQL   API  ,    .    ,   API   DOS-. <br><br>     ,     . <br><br>   <code>Video</code>  ,   .      GraphQL  <code>Video</code> .           .   ‚Äî  . <br><br>  ,      ‚Äî   : <br><br><pre> <code class="go hljs">{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){   name   url   related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){     name     url     related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){       name       url       related(limit: <span class="hljs-number"><span class="hljs-number">100</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){         name         url       }     }   } } }</code> </pre> <br>           100,        .  (, , )    ,         . <br><br>  gqlgen      ,     .     ,       ( <code>handler.ComplexityLimit(300)</code>   )   GraphQL     (300   ).  ,     ( <code>server.go</code> ): <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware( db, handler.GraphQL(   go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)),   handler.ComplexityLimit(<span class="hljs-number"><span class="hljs-number">300</span></span>) ), )</code> </pre> <br>       ,   ,        .        12.   ,       ,   ,      ( ,  ,  ,   ,     ).    <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//  countComplexity := func(childComplexity int, limit *int, offset *int) int {   return *limit * childComplexity } c.Complexity.Query.Videos = countComplexity c.Complexity.Video.Related = countComplexity //   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>     ,     ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/702/045/d0a7020450bf5115f69c6a1ba61beca4.png"></div><br> <i><font color="#999999">    </font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/057/fec/7e3/057fec7e30f98b63aed8bbb6aec5193f.png"></div><br> <i><font color="#999999">      </font></i> <br><br>       ,   ,   <code>related</code>  . , , ,      ,             . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br> ,        ,    <a href="https://github.com/ridhamtarpara/go-graphql-demo">GitHub</a> .         .       ,     ,      . <br><br>  <b>Dear readers!</b>     GraphQL  ,   Go? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/444346/">https://habr.com/ru/post/444346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444336/index.html">Swift capture lists: what is the difference between weak, strong and unowned links?</a></li>
<li><a href="../444338/index.html">Python 3 Encapsulation</a></li>
<li><a href="../444340/index.html">Features of using the Symbol data type in JavaScript</a></li>
<li><a href="../444342/index.html">Development of simple modern JavaScript applications using Webpack and progressive web technologies</a></li>
<li><a href="../444344/index.html">10 steps to a successful Python project</a></li>
<li><a href="../444350/index.html">For some reason, MVP does not start (minimally viable product)</a></li>
<li><a href="../444352/index.html">Kontur.Kampus: we invite you to a free student camp of industrial development near St. Petersburg</a></li>
<li><a href="../444356/index.html">React Training Course, Part 24: Second Form Work</a></li>
<li><a href="../444360/index.html">Injustice Google Play, like a good life experience</a></li>
<li><a href="../444362/index.html">Unity is working on a new physics engine with Havok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>