<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How not to write factorial in Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The translation of this article has already been published once on Habr√© , but for some reason the most important part remained behind the scenes. Bel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How not to write factorial in Java</h1><div class="post__text post__text-html js-mediator-article">  <em>The translation of this article has already been <a href="http://habrahabr.ru/blogs/java/112969/">published</a> once <a href="http://habrahabr.ru/blogs/java/112969/">on Habr√©</a> , but for some reason the most important part remained behind the scenes.</em>  <em>Below is a complete translation.</em> <br><br>  I was inspired to write this article by the note ‚Äú <a href="">How would you write factorial in Java?</a> ‚Äù.  So excuse me, I‚Äôm going to talk a little bit in the code: I have a main thought that I‚Äôll express at the end. <br><br>  If you need to write factorial in Java, then most of you will probably start with something <a name="habracut"></a>  such: <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n-<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Wrap it up in a class (we are still talking about Java), it will probably be some kind of auxiliary (* Util) class, for example: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n-<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br><br>  Just, isn't it? <br><br>  There is also a non-recursive solution: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; ++i) ret *= i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  The attentive reader will notice that the result may be greater than the maximum allowed integer (integer type), and will certainly want to rewrite the function so that it uses BigInteger or at least long, depending on the requirements of the program.  So, <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ BigInteger ret = BigInteger.ONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; ++i) ret = ret.multiply(BigInteger.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  Please note that so far I have not used the fact that I constantly calculate the same intermediate values ‚Äã‚Äãfrom 1 to n.  If I cached these values, of course, the calculations could be much faster.  If we have already calculated a value once, then save it for future use, for example, in the HashMap: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HashMap&lt;Integer,BigInteger&gt; cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer,BigInteger&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ BigInteger ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.ONE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> != (ret = cache.get(n))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; ret = BigInteger.valueOf(n).multiply(factorial(n-<span class="hljs-number"><span class="hljs-number">1</span></span>)); cache.put(n, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  Simple enough, right? <br>  Each of these methods has its advantages and disadvantages, therefore, given that this library will probably come in handy more than once in the future, we should use the standard mechanism popular in Java libraries.  I'm talking about the pluggable system of modules, which allows at runtime to decide which algorithm to use: slow, but consuming less memory, or fast, but consuming more memory.  First we need to remake our class in Singleton, because any plug-in gizmos require initialized classes and a siglton that returns the default implementation. <br><br>  So, we create a class whose job is to support a singleton for our factory (Factory class), and links to an algorithm that implements the method.  This class provides the old interface that was shown above, and also allows you to use a new, improved algorithm: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FactorialUtil singleton; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FactorialAlgorithm algorithm; <span class="hljs-comment"><span class="hljs-comment">/** * Default (internal) constructor constructs our default algorithm. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ algorithm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFactorialImplementation(); } <span class="hljs-comment"><span class="hljs-comment">/** * New initializer which allows selection of the algorithm mechanism * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> algorithm */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FactorialAlgorithm a)</span></span></span><span class="hljs-function"> </span></span>{ algorithm = a; } <span class="hljs-comment"><span class="hljs-comment">/** * Default public interface for handling our factorial algorithm. Uses * the old standard established earlier for calling into our utility class. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> n * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (singleton == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Use default constructor which uses default algorithm singleton = new FactorialUtil(); } return singleton.doFactorial(n); } /** * New mechanism which allows us to instantiate individual factorial * utilitiy classes and invoke customized factorial algorithms directory. * @param n * @return */ private BigInteger doFactorial(int n) { // Defer to our algorithm return algorithm.factorial(n); } }</span></span></code> </pre><br><br>  Note that the above class is responsible for creating the singleton and passing control to the class of the algorithm.  It even has a private constructor that initializes the class of the algorithm, as well as the ability to create and use another algorithm. <br><br>  It depends on the interface of the algorithm: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; }</code> </pre><br><br>  And here is an implementation that uses intermediate results caching, which we mentioned earlier: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachedFactorialImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HashMap&lt;Integer,BigInteger&gt; cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer,BigInteger&gt;(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ BigInteger ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.ONE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> != (ret = cache.get(n))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; ret = BigInteger.valueOf(n).multiply(factorial(n-<span class="hljs-number"><span class="hljs-number">1</span></span>)); cache.put(n, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  See how beautiful this structure is!  I mean that we can easily add a non-caching non-recursive implementation: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopedFactorialImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ BigInteger ret = BigInteger.ONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; ++i) ret = ret.multiply(BigInteger.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  The disadvantage of this design, from the point of view of Java, should be obvious: it does not allow us to choose an algorithm at runtime (and this was originally our main idea).  That is, obviously, we need to load the configuration and select the algorithm according to it.  For example, we can read some system property (System property), which contains the name of the class that implements the algorithm.  Ideally, our main method should look something like this: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ System.getProperties().setProperty(<span class="hljs-string"><span class="hljs-string">"com.chaosinmotion.factorialalgorithm"</span></span>, <span class="hljs-string"><span class="hljs-string">"cachedAlgorithm"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"5! = "</span></span> + FactorialUtil.factorial(<span class="hljs-number"><span class="hljs-number">5</span></span>)); }</code> </pre><br><br>  Which means that we need to have an associative array containing all existing implementations.  From it we could take the necessary algorithm before creating our singleton inside the factory method. <br><br>  So, we need a factory that can generate algorithms.  We store both an array of created singleton factories, and an array of class names and implementations in classMapping.  Thus, we do not create an object of the class-algorithm until we really need it (there is nothing to call extra constructors and waste resources uselessly). <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Factory class manages the factorial algorithms in our system. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@author</span></span></span><span class="hljs-comment"> wwoody * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithmFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HashMap&lt;String,FactorialAlgorithm&gt; mapping = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String,FactorialAlgorithm&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HashMap&lt;String,Class&lt;? extends FactorialAlgorithm&gt;&gt; classMapping = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String,Class&lt;? extends FactorialAlgorithm&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FactorialAlgorithm defaultAlgorithm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFactorialImplementation(); <span class="hljs-comment"><span class="hljs-comment">/** Static initializer registers some of my known classes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Class.forName(<span class="hljs-string"><span class="hljs-string">"com.chaosinmotion.factorial.LoopedFactorialImplementation"</span></span>); Class.forName(<span class="hljs-string"><span class="hljs-string">"com.chaosinmotion.factorial.CachedFactorialImplementation"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { <span class="hljs-comment"><span class="hljs-comment">// Should never happen. } } /** Get the default algorithm for computing factorials */ public static FactorialAlgorithm getDefaultAlgorithm() { if (defaultAlgorithm == null) { // Warning: this will fail if for whatever reason CachedFactorialImplementation // is not in the class path. defaultAlgorithm = getAlgorithm("cachedAlgorithm"); } return defaultAlgorithm; } /** Get the factorial algorithm specified by name */ public static FactorialAlgorithm getAlgorithm(String name) { FactorialAlgorithm f = mapping.get(name); if (f == null) { // We haven't created an instance yet. Get it from the class mapping. Class&lt;? extends FactorialAlgorithm&gt; c = classMapping.get(name); if (c != null) { // Create a new instance of the factorial algorithm specified try { f = c.newInstance(); mapping.put(name, f); return f; } catch (Exception e) { // Log the error Logger.getLogger("com.chaosinmotion.factorial"). warning("Unable to instantiate algorithm " + c.getCanonicalName() + ", named " + name); } } return getDefaultAlgorithm(); // return something. } else return f; } /** Register the class so we can construct a new instance if not already initialized */ public static void registerAlgorithm(String name, Class&lt;? extends FactorialAlgorithm&gt; f) { classMapping.put(name, f); } }</span></span></code> </pre><br><br>  Rewrite the class FactorialUtil so that it uses our named algorithms: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FactorialUtil singleton; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FactorialAlgorithm algorithm; <span class="hljs-comment"><span class="hljs-comment">/** * Default (internal) constructor constructs our default algorithm. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String name = System.getProperty(<span class="hljs-string"><span class="hljs-string">"com.chaosinmotion.factorialalgorithm"</span></span>, <span class="hljs-string"><span class="hljs-string">"cachedAlgorithm"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { algorithm = FactorialAlgorithmFactory.getDefaultAlgorithm(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { algorithm = FactorialAlgorithmFactory.getAlgorithm(name); } } <span class="hljs-comment"><span class="hljs-comment">/** * New initializer which allows selection of the algorithm mechanism * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> algorithm */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FactorialAlgorithm a)</span></span></span><span class="hljs-function"> </span></span>{ algorithm = a; } <span class="hljs-comment"><span class="hljs-comment">/** * Utility to create by name. Calls into FactorialAlgorithmFactory to * actually get the algorithm. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> name */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FactorialUtil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ algorithm = FactorialAlgorithmFactory.getAlgorithm(name); } <span class="hljs-comment"><span class="hljs-comment">/** * Default public interface for handling our factorial algorithm. Uses * the old standard established earlier for calling into our utility class. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> n * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (singleton == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Use default constructor which uses default algorithm singleton = new FactorialUtil(); } return singleton.doFactorial(n); } /** * New mechanism which allows us to instantiate individual factorial * utilitiy classes and invoke customized factorial algorithms directory. * @param n * @return */ private BigInteger doFactorial(int n) { // Defer to our algorithm return algorithm.factorial(n); } }</span></span></code> </pre><br><br>  And also we will need to add to the CachedFactorialImplementation and LoopedFactorialImplementation classes static initialization blocks, which will register them in the factory: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachedFactorialImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HashMap&lt;Integer,BigInteger&gt; cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;Integer,BigInteger&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { FactorialAlgorithmFactory.registerAlgorithm(<span class="hljs-string"><span class="hljs-string">"cachedAlgorithm"</span></span>, CachedFactorialImplementation.class); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ BigInteger ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> != (ret = cache.get(n))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; ret = BigInteger.valueOf(n).multiply(factorial(n-<span class="hljs-number"><span class="hljs-number">1</span></span>)); cache.put(n, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  and <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopedFactorialImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { FactorialAlgorithmFactory.registerAlgorithm(<span class="hljs-string"><span class="hljs-string">"loopedAlgorithm"</span></span>, LoopedFactorialImplementation.class); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ BigInteger ret = BigInteger.ONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; ++i) ret = ret.multiply(BigInteger.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } }</code> </pre><br><br>  The highest beauty of this architecture is that we can connect our own implementation of factorial on the fly in FactorialUtil.  To do this, you just need to create your own class that implements the FactorialAlgorithm interface and register it through the FactorialAlgorithmFactory in the static initialization block: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecursiveFactorialImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactorialAlgorithm</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { FactorialAlgorithmFactory.registerAlgorithm(<span class="hljs-string"><span class="hljs-string">"recursiveAlgorithm"</span></span>, RecursiveFactorialImplementation.class); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigInteger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.ONE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigInteger.valueOf(n).multiply(factorial(n-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre><br><br>  Finally, in the main method, we make sure that our class is loaded, and set the system property. <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Class.forName(<span class="hljs-string"><span class="hljs-string">"com.chaosinmotion.factorial.RecursiveFactorialImplementation"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { <span class="hljs-comment"><span class="hljs-comment">// if this fails, no matter; we'll still use the default implementation. } System.getProperties().setProperty("com.chaosinmotion.factorialalgorithm", "recursiveAlgorithm"); System.out.println("5! = " + FactorialUtil.factorial(5)); }</span></span></code> </pre><br><br>  No problems!  Moreover, this architecture allows you to connect and more sophisticated solutions such as <a href="http://www.luschny.de/math/factorial/FastFactorialFunctions.htm">these</a> . <br><br><div style="text-align:center;"><img width="110" height="16" title="separator.png" alt="separator.png" src="http://1450821356653848934481"></div><br><br>  I am sure that many Java programmers, having reached this place, nod their heads and admire the elegance of this architecture.  There will be those who are already pressing the button ‚ÄúLeave a comment‚Äù and writes: ‚ÄúDamn it, it would be better for you to set the system properties so-and-so‚Äù.  For example, I could place an initializer for different classes in a file with properties (* .properties) or in an XML file.  Or maybe it would be better if the value of the system property was the full name of the class. <br><br>  And, of course, there will be those who have made entries in their notebook all the way and are already copying pieces of code from this blog (yes, all this code is working, I tested it on my car). <br><br>  But wait, finally my main thought. <br><br>  <em><a href="http://asolntsev.livejournal.com/53088.html">All this crap.</a></em> <br><br>  Each is a string. <br><br>  Undoubtedly, in some circumstances, the connected architecture is useful and even necessary.  But this is quite rare - so rare that it is even unfunny.  In 99% of cases, when I saw such a code, it was completely and completely useless.  It hides the true purpose of the code, replacing the two-three-lined auxiliary method with dozens and even hundreds of lines of the smug, bombastic pompous Java.  It may help you to feel good, but it creates an ugly mess that future developers will have to clean up, or most likely avoid, like the plague. <br><br>  And the most interesting, did you notice something?  During all this discussion, you did not notice anything? <br><br>  <em>We have never taken care of negative numbers.</em> <br><br><div style="text-align:center;"><img width="110" height="16" title="separator.png" alt="separator.png" src="http://1450821356653848934481"></div><br><br>  A smart Java developer knows when to stop.  Life is too short to build castles in the clouds.  He knows that a simple solution with a cycle is more than enough, and of course he will take care of negative numbers.  (Well, you know, yes? Our recursive solution will fall into an infinite loop if you give a negative number as an input.) <br><br>  A truly smart Java developer can get a little deeper into the problem and find out that factorial is a special case of the <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">Gamma function</a> .  Perhaps the correct solution is none of the above pieces of code, but in general <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB%25D0%25B0_%25D0%25A1%25D1%2582%25D0%25B8%25D1%2580%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B0">Stirling approximation</a> for the gamma function: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Gamma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmp1 = Math.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>*Math.PI/z); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmp2 = z + <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(<span class="hljs-number"><span class="hljs-number">12</span></span> * z - <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(<span class="hljs-number"><span class="hljs-number">10</span></span>*z)); tmp2 = Math.pow(z/Math.E, z); <span class="hljs-comment"><span class="hljs-comment">// ooops; thanks hj tmp2 = Math.pow(tmp2/Math.E, z); return tmp1 * tmp2; }</span></span></code> </pre><br><br>  But it already depends on the problem area - which we actually didn‚Äôt even think about, creating all these factories of ours. <br><br><div style="text-align:center;"><img width="110" height="16" title="separator.png" alt="separator.png" src="http://1450821356653848934481"></div><br><br>  My biggest complaint about Java developers is that they develop a whole bunch of really bad habits.  Specifications are unclear.  They think that someday the code may need to be extended in a different direction.  Therefore, they write a whole bunch of bloated architectural nonsense, believing that one day all this extra garbage will <a href="http://lurkmore.ru/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25BD%25D0%25BE">suddenly</a> help them and make their lives easier.  And Java as a language allows you to do this quickly and conveniently, so it‚Äôs easy for us to build an architecture that will make our lives easier in the future. <br><br>  But the future never gets any easier, right? <br><br>  Because a year later they were going through all this excess baggage written at the time when they thought they understood the problem area (although it is now clear that they did not understand), instead of having a few lines of simple code (like our very first an example of factorial), which they could reconsider if necessary, is forced to deal with a heap of nonsense that no one can understand. <br><br>  And instead of sneaking through this heap to untie a knot or at least understand how this mechanism works, they simply slap the patch over the architecture, as in the classic example <a href="http://www.antipatterns.com/lavaflow.htm">of a lava flow</a> .  For example, they do not understand how to create a plug-in algorithm, and therefore they override the FactoryUtil class or simply write the FactoryUtil class again and add another hundred or two (ill-conceived) code there, just to quickly patch up the misunderstanding of the previous hundred lines (ill-conceived ) code. <br><br><div style="text-align:center;"><img width="110" height="16" title="separator.png" alt="separator.png" src="http://1450821356653848934481"></div><br><br>  Therefore, please do us all a favor: if you feel like adding complexity simply because ‚Äúsometime it will be useful to us‚Äù or ‚Äúthe system is not flexible enough yet‚Äù or ‚Äúthere must be reusability in our code‚Äù or (don‚Äôt let God!) because ‚Äúit's cool‚Äù - just go home early.  See cartoons.  Or hire the " <a href="http://www.kinopoisk.ru/level/1/film/447301/">Start</a> ". <br><br>  Stop creating additional work for us without a good reason. <br><br><br><br></div><p>Source: <a href="https://habr.com/ru/post/113128/">https://habr.com/ru/post/113128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113122/index.html">Idea motivation</a></li>
<li><a href="../113123/index.html">Ubuntu 11.04 Natty Narwhal Alpha 2 released</a></li>
<li><a href="../113124/index.html">And we will go the other way. Moving the model to the database</a></li>
<li><a href="../113126/index.html">Chrome 9: Breakthrough in speed, support for 3D and web applications</a></li>
<li><a href="../113127/index.html">Having fun with hashes</a></li>
<li><a href="../113129/index.html">yourfilms.org - your movies</a></li>
<li><a href="../113131/index.html">February 18, St. Petersburg - Java Tech Day 2011</a></li>
<li><a href="../113133/index.html">Uncompromising replacement for a 60-watt light bulb</a></li>
<li><a href="../113134/index.html">Creative Commons licenses are adapted in the first country of the former USSR - Estonia</a></li>
<li><a href="../113135/index.html">Roman Nurik - "our man" in Honeycomb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>