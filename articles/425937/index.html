<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CoreBluetooth in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article Practical CoreBluetooth for Peripherals 
 A couple of years ago, when I first encountered Bluetooth with a working draft, I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CoreBluetooth in practice</h1><div class="post__text post__text-html js-mediator-article"><h3>  Translation of the article <a href="https://academy.realm.io/posts/yoav-schwartz-corebluetooth-peripherals/">Practical CoreBluetooth for Peripherals</a> </h3><br>  A couple of years ago, when I first encountered Bluetooth with a working draft, I found this article, which greatly helped to understand how it works, to find the ‚Äústarting point‚Äù.  I hope that it will be useful for beginners. <br><br>  About the author: Yoav Schwartz is a leading iOS developer in Donkey Republic, Copenhagen's bikering system, seeking to change attitudes towards bike transport.  Next, it will be on behalf of the author. <br><br>  In this article I will talk about the practical tricks to work with CoreBluetooth.  First, about Bluetooth Low Energy (BLE), because not everyone is familiar with this technology, then about CoreBluetooth, the Apple framework, which allows us to interact with BLE devices.  I will also tell you about some techniques in the development, which I found out myself while I was debugging, weeping and tearing hair on my head. <br><a name="habracut"></a><br><h4>  Bluetooth Low Energy </h4><br>  For a start, what is BLE?  It's kind of like Bluetooth, which we all use in speakers, headsets, etc., but there is a difference - this protocol consumes very little power.  Usually, a single battery charge can be enough for months or even years for a device that works with BLE (depending on how this device is used, of course).  This allows us to do things previously unavailable for ‚Äúnormal‚Äù Bluetooth.  This standard is called Bluetooth 4.0, it all started with a technology called Smart Bluetooth, which later developed into BLE.  There is a 200-page <a href="https://www.bluetooth.com/specifications/bluetooth-core-specification">manual</a> , you can read before bed, an exciting reading. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      BLE is very economical in terms of energy consumption, and the protocol itself is not very complicated.  So why ble?  How can we use it?  The first and most common example is the heart rate sensor.  Usually this device measures and transmits your heart rate to the protocol.  There are still any sensors to which you can connect via BLE and read the data that they collect.  Finally, there are iBeacons that can tell you ‚Äúproximity‚Äù to any place.  In quotes, because Apple‚Äôs iPhone doesn‚Äôt allow iBeacons to be detected as ordinary Bluetooth devices, so we have to work with CoreLocation.  In general, this is the Internet of things: you can connect to a TV or an air conditioner and communicate with it using this protocol. <br><br><h4>  How it works? </h4><br>  We have a peripheral - so-called devices that use the Bluetooth protocol.  Each periferal has services, there can be as many of them as possible, and each of them has characteristics.  You can consider the periferl as a server.  With all the ensuing consequences: sometimes it turns off, sometimes it takes time to transfer data, and sometimes this data does not come at all. <br><br>  In general, we have a service with a variety of characteristics, each of which contains some value, type, and so on.  To work with CoreBluetooth, you don‚Äôt need to know everything, the most important thing is to read data.  This is what we are trying to get, change or use for our own purposes.  We need this data and knowledge of what we can do with it. <br><br>  Here is a brief introduction to BLE because there are thousands of resources that will explain technical features better than me. <br><br><h4>  Core Bluetooth </h4><br>  Core Bluetooth was introduced by Apple a long time ago, in iOS 5. Apple began work on introducing BLE into its devices much earlier than Android and the growing popularity of technology.  Many developers use this framework in their applications, by and large - this is just a wrapper, since the BLE protocols themselves are quite complex.  Not that much, but believe me, this is not something with which I would like to work every day.  Just like many other things, Apple wrapped it up in a beautiful and convenient package, allowing us to use terms that all of us stupid developers can understand. <br><br>  Now it is the turn to tell what you really need to know - about the classes involved in communicating with the framework.  Our main actor, CBCentralManager, will create it: <br><br><pre><code class="plaintext hljs">manager = CBCentralManager(delegate:self, queue:nil, options: nil)</code> </pre> <br>  Above, we created a new manager, specifying his delegate, otherwise we will not be able to use it.  We also indicate the queue, in our case nil, which means that all communication with the manager will be carried out on the main line. <br><br>  You need to understand what exactly you are going to do - using a separate queue will complicate the application, but, of course, users will love you more.  If you plan to communicate with only one device, you can not bother and use the main queue.  If you still want to experiment, then create a queue, specify it in the constructor and do not forget to return to the main one, before using the results obtained elsewhere. <br><br>  Options  There is nothing particularly interesting here, perhaps, the main thing is when you create a manager and the user has bluetooth turned off - the application will tell him about it, but almost everyone clicks ‚ÄúOK‚Äù (which actually doesn‚Äôt include bluetooth), which is why do not use. <br><br>  The first thing after creating a manager is to call its delegate: <br><br><pre> <code class="plaintext hljs">func centralManagerDidUpdateState(_ central: CBCentralManager)</code> </pre> <br>  So we will get a response from the hardware - whether the user has bluetoooth on or not. <br>  First advice: the manager is useless until we get an answer that bluetoth is turned on, his status is .PoweredOn.  The remaining states can be used except to ask the user to turn on bluetooth. <br><br><h4>  Device search </h4><br>  Now that our manager is working properly, we can look, <br>  what is around us (after getting the state .PoweredOn - call the function scanForPeripheralsWithServices :) <br><br><pre> <code class="plaintext hljs">manager.scanForPeripheralsWithServices([CBUUID], options: nil)</code> </pre> <br>  As for services, this is an CBUUID array (a class representing 128-bit universal unique identifiers of attributes used by Bluetooth Low Energy approx. Lane), which we use as a filter to find devices only with this UID, it is common practice in CoreBluetooth . <br><br>  If you pass nil as an argument, we can see all the devices around.  For performance, of course, it is better to specify an array of the parameters we need, but in the case when you do not know them, nothing terrible will happen, if you pass nil, no one will die. <br><br>  Since we started the search for devices, we should stop it.  Otherwise, the search will continue and implant the user's battery until we stop it.  As soon as we find the right device, or the need for searching disappears, we‚Äôll stop: <br><br><pre> <code class="plaintext hljs">manager.stopScan()</code> </pre> <br>  Each time a new device is detected by the manager delegate, the didDiscoverPeripheral function will be called on the queue we specified during its initialization.  The function sends us the device found (peripheral), information about it (advertisementData is something that the chip developers decided to show every time) and the relative level of the RSSI signal in decibels. <br><br><pre> <code class="plaintext hljs">func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber)</code> </pre> <br>  Second tip: always keep a strong link to the desired periferal found.  If this is not done, the system will decide that we do not need the device found and discard it.  She will remember him, but we will no longer have access to him.  Otherwise we will not be able to work with the device. <br><br><h4>  Connect to device </h4><br>  We found the device we are interested in - it's like coming to a party and seeing a pretty girl.  We want to connect, call the connectPeripheral function - we offer ‚Äúbuy a drink‚Äù.  So we try to connect to the right device (peripheral), and it can tell us ‚Äúyes‚Äù or ‚Äúno‚Äù, but our iPhone is really good, so we will hear a positive response. <br><br><pre> <code class="plaintext hljs">manager.connectPeripheral(peripheral, options: nil)</code> </pre> <br>  Here we turned to the manager who is responsible for the connections, telling him which device we are connecting to, and again we give nil as options (if you are really interested in learning about the options, read the documentation, but you can usually do without them).  When you finish working with the device, you can disconnect from it, well, you know, in the morning - cancelPeripheralConnection: <br><br><pre> <code class="plaintext hljs">//called to cancel and/or disconnect manager.cancelPeripheralConnection(peripheral)</code> </pre> <br>  After we connect or disconnect the connection, the delegate will tell us about it: <br><br><pre> <code class="plaintext hljs">//didConnect func centralManager(central: CBCentralManager!, didConnectPeripheral peripheral: CBPeripheral!) //didDisconnect func centralManager(central: CBCentralManager!, didDisconnectPeripheral peripheral: CBPeripheral!, error: NSError!)</code> </pre> <br>  Now, two more important tips.  The Bluetooth protocol assumes a connection timeout, but Apple does not care.  iOS will try to connect again and again and will not stop until you call cancelPeripheralConnection.  This process may take too long, so it is necessary to limit it in time, and if, in the end, we do not receive messages about successful connection (didConnectPeripheral) - you need to inform the user that something has gone wrong. <br><br>  If you do not keep a strong link to the peripheral, iOS will simply drop the connection.  From her point of view, this will mean that you don‚Äôt need it, and supporting it is a fairly energy intensive task for the battery, and we know how Apple relates to energy consumption. <br><br><h4>  Making the device useful </h4><br>  And so, we connected to the device, let's do something with it.  Earlier, I mentioned services and features, the values ‚Äã‚Äãthey contain, this is what we need.  Now we have a device, it is connected and we can get its services by calling peripheral.discoverServices. <br><br><pre> <code class="plaintext hljs">peripheral.discoverServices(nil) func peripheral(peripheral: CBPeripheral!, didDiscoverServices error: NSError!) peripheral.services</code> </pre> <br>  Now it will sound a bit confusing, but the delegate is called on the thread that we defined when creating the manager, despite the fact that this is a delegate of the periferal.  That is, the system remembers with which stream it works, and all of our Bluetooth communication occurs on this stream.  It is important not to forget to return to the main, if you did not use it. <br><br>  We received services, but we still have nothing to work with.  Next, you need to call peripheral.discoverCharacteristics, the delegate will give us all the available characteristics for the received services in didDiscoverCharacteristicsForService.  Now we can read the values, <br>  which are contained there (readValueForCharacteristic) or ask to let us know as soon as something changes there - setNotifyValue. <br><br><pre> <code class="plaintext hljs">peripheral.discoverCharacteristics(nil, forService: (service as CBService)) func peripheral(peripheral: CBPeripheral!, didDiscoverCharacteristicsForService service: CBService!, error: NSError!) peripheral.readValueForCharacteristic(characteristic) peripheral.setNotifyValue(true, forCharacteristic: characteristic) func peripheral(peripheral: CBPeripheral!, didUpdateValueForCharacteristic characteristic: CBCharacteristic!, error: NSError!)</code> </pre> <br>  Unlike Android, Apple does not distinguish between reading and notification.  That is, we do not know what is happening - we are reading something from the device or this device is telling us something. <br><br><h4>  Write to device </h4><br>  We have a device, we read information from it, we manage it.  So, we can write information to it, as a rule, - the usual NSData.  Only it is necessary to find out what this device expects from us and what will be accepted by it. <br><br>  Most BLE devices come with a specification, a kind of API, from which it is clear how to ‚Äúcommunicate‚Äù with them.  You can pull the data from the characteristics to get at least a rough idea of ‚Äã‚Äãwhat the device expects from us. <br><br>  From the specifications we find out in which characteristics which properties we read, and in which we write, whether we will be notified of changes (isNotifying).  Most often here we will find everything that is required for work. <br><br><pre> <code class="plaintext hljs">peripheral.writeValue(data: NSData!, forCharacteristic: CBCharacteristic!, type: CBCharacteristicWriteType) characteristic.properties - OptionSet type characteristic.isNotifying func peripheral(peripheral: CBPeripheral!, didWriteValueForCharacteristic characteristic: CBCharacteristic!, error: NSError!)</code> </pre> <br>  During the writing process, the delegate will tell us that everything went well (didWriteValueForCharacteristics) that the required value was updated, and we can tell the user about it or use this information differently. <br><br>  We consider the topic in a very narrow cut, relying on the implementation of Apple, so there are a number of problems that will have to be faced.  For example, a very strong dependence on the delegation, so beloved Apple. <br><br><h4>  Inheritance of CBPeripheral?  If everything was so easy </h4><br>  It would seem that once we have a device, we can start using it, but in fact it will not tell us anything about ourselves.  Perhaps we want to control the lock, air conditioning or pulse sensor.  You need to know which device we are communicating with. <br><br>  It looks like inheritance: we have a special case of something in common.  From my experience I can say that when using inheritance, something will not work at all as expected, something will not work at all, and you will not know why.  In general, I would caution you against the idea of ‚Äã‚Äãinheriting CBPeripheral.  What to do? <br><br>  I advise you to add CBPeripheral to the constructor of the object that will manage it.  It encapsulates it inside this class.  Use it to interact with the device, hold a strong link to it, so that iOS does not break the connection.  But the most important thing is that this class will be used as a delegate, otherwise it will be difficult to manage all devices in one place, this threatens with a bunch of if else. <br><br><h4>  Connect and work with CBPeripheralDelegate </h4><br>  And here we are connecting to the device and want to be CBPeripheralDelegate.  There is one more nuance: while you are working with the device, you ‚Äúinterrogate‚Äù its services and characteristics, read and write to them, almost all communication occurs with the periphery.  Everything except the connection. <br><br>  Naturally, we would like to concentrate all communication in one place, but the manager should be aware of what is happening with the device.  And the difficulty is to have one source of truth, to make sure that everyone is timely informed about what is happening with the device.  To do this, we will monitor the state of the peripheral - it can change from disconnected (disconnected), connected (connecting) and connected (connected).  It will always tell you about the current situation.  It remains to subscribe to the status change in our management facility, which I mentioned earlier, this will give the opportunity to communicate with the device from one place. <br><br><h4>  Determination of proximity </h4><br>  A very important point, since finding normal documentation on this topic is difficult.  In the case of Apple and their iBeacons, everything is simple, they tell us how close we are to the bluetooth device. <br>  Unfortunately, we are not given such an easy way to work with third-party devices.  And more than once it happened that there was a need to determine the nearest device.  It is also difficult to understand whether the device is in the available range or not.  Sometimes when searching for devices, it can only make itself known once and disappear, then the connection attempt will be unsuccessful. <br><br>  We use the following method: save the stack with date and signal level labels (RSSI) of each message received in discoverPeripheral.  If someone came across CoreLocation, our method is similar to how time stamps and corresponding coordinates are stored there.  Usually, the higher the signal (RSSI), the closer the device.  To understand whether the device is in the available range or not is more difficult, partly because this concept itself is quite flexible.  For this, I use the weighted average of the signal.  Keep in mind that the signal level of a connected device must be manually requested every time you need to know it. <br><br><h4>  What's next? </h4><br>  Unfortunately, this article will not make you an expert if you read it and you <br>  It became interesting - pay attention to <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Apple's CoreBluetooth Programming Guide</a> , the manual is not very big, but very useful.  There are still a couple of broadcasts from WWDC 2012 ( <a href="https://developer.apple.com/videos/wwdc2012">basic</a> and <a href="https://developer.apple.com/videos/wwdc2012">advanced</a> ) and one since <a href="https://developer.apple.com/videos/wwdc2013">2013</a> , but don't worry, not much has changed since then. <br><br>  There is also a video from <a href="https://academy.realm.io/posts/altconf-jon-shier-corebluetooth-and-you/">Altconf 2015</a> posted on the Realm site, where John Shier, an excellent guy and specialist, shares his experience. </div><p>Source: <a href="https://habr.com/ru/post/425937/">https://habr.com/ru/post/425937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425927/index.html">Weather Station on Arduino from A to Z. Part 2</a></li>
<li><a href="../425929/index.html">Google Corporation has abandoned the struggle for the billionth Pentagon contract</a></li>
<li><a href="../425931/index.html">‚ÄúI want to leave the factory on the web‚Äù - 10 questions for a programmer, issue 8</a></li>
<li><a href="../425933/index.html">The humidity level in the data center: why it matters</a></li>
<li><a href="../425935/index.html">Suspension of the system unit under the standing table</a></li>
<li><a href="../425939/index.html">DataIncrement - addition to the capabilities of phpMyAdmin</a></li>
<li><a href="../425941/index.html">Download JivoSite dialogs via API</a></li>
<li><a href="../425943/index.html">Kotlin: digging deeper. Constructors and initializers</a></li>
<li><a href="../425945/index.html">Tips for professional use RecyclerView. Part 1</a></li>
<li><a href="../425947/index.html">Corporate Ratatouille</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>