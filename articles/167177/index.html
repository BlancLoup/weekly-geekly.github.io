<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for common elements in an array</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Task: in an array of length N, find an element that repeats more than N / 2 times. 

 It would seem, what is there to think? Take a Dictionary <elemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for common elements in an array</h1><div class="post__text post__text-html js-mediator-article">  Task: in an array of length <i>N,</i> find an element that repeats more than <i>N</i> / 2 times. <br><br>  It would seem, what is there to think?  Take a Dictionary &lt;element value, number of occurrences&gt;, for one pass through the array, count the occurrences of each element, then select the desired element from the dictionary.  Solution for <i>O</i> ( <i>N</i> ), where could it be even faster? <br><img src="https://habrastorage.org/storage2/ba9/ad0/438/ba9ad043830d4692246716e3c4afedf7.jpg"><br>  There is one caveat: for the dictionary, we need <i>O</i> ( <i>N</i> ) additional memory - several times larger than the size of the original array, and this is when implementing the dictionary even with a hash table, even a tree.  What will we do if our goal is to process the signal with a device with a small memory?  Array - measurements of the signal level, of which one is the ‚Äúreal‚Äù transmitted level, and the rest are noise and interference.  Do you really have to mess around with hash tables and trees to determine the ‚Äúreal‚Äù level? <br><br>  Fortunately, no: there is enough <i>O</i> (1) additional memory, and still one pass through the array. <a name="habracut"></a>  The algorithm of Boyer-Moore ‚Äî those of Boyer and Moore who invented the much better known <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">algorithm for searching for a substring</a> ‚Äî is easiest to imagine <a href="http://stackoverflow.com/questions/7059780/find-the-element-repeated-more-than-n-2-times">as follows</a> : N <i>people</i> <i>gathered at the party</i> <i>, and each had one element from the array.</i>  <i>When there are two people whose elements are different, they sit down to discuss it.</i>  <i>In the end, only people with the same elements will remain standing;</i>  <i>Obviously, this is the very element that has been met more than</i> N <i>/ 2 times.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://keithschwarz.com/interesting/code/%3Fdir%3Dmajority-element">The implementation of</a> the Boyer-Moore algorithm takes only a few lines: <br><pre><code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* majority(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> confidence = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* candidate = NULL; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    -- <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,      //          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (confidence == <span class="hljs-number"><span class="hljs-number">0</span></span>) { candidate = array+i; confidence++; } //        , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*candidate == array[i])) confidence++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> confidence--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> confidence &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? candidate : NULL; }</code> </pre> <br>  In the end, we get the ‚Äúmost likely candidate‚Äù for presence in <i>N</i> / 2 copies: if such an element really exists in the array, then it will be found;  if there is no such element, then perhaps it will remain just some poor fellow who lacked a pair.  For a more stringent implementation of the <code>majority</code> it is required to go through the array a second time and check whether the found element actually occurs the required number of times. <br><img src="https://habrastorage.org/storage2/114/f49/c0b/114f49c0be956c937ec0eee8893986bf.jpg"><br><br>  Let's complicate the task.  Now, in an array of length <i>N,</i> we need to find elements that repeat more than <i>N</i> / 3 times - if there are two, then both, if there is one, then one. <br><br>  For example, our device with a small memory needs to accept a binary signal with unknown levels of zero and one, but it is known that about half of the time is zero, about half of the time is one, and any signal levels that are different from them are interferences and bounce from switching. <br><br>  The idea of ‚Äã‚Äãthe past algorithm is also easy to generalize for triples: let people with different elements sit in three.  So, at the end of the party there will be a maximum of people with two different elements.  If an element has been met more than <i>N</i> / 3 times, then the person with him is guaranteed to remain standing, after all, the sitting threes will get no more than <i>N</i> / 3.  As in the past case, if the required elements exist, then they will be found, but if they are not there, then someone can be found. <br><br>  The code is a little different from the previous one: there is still one pass through the array and <i>O</i> (1) additional memory. <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> majority(<span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> N, <span class="hljs-type"><span class="hljs-type">int</span></span>** cand1, <span class="hljs-type"><span class="hljs-type">int</span></span>** cand2) { <span class="hljs-type"><span class="hljs-type">int</span></span> conf1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, conf2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; //       *cand1 = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; *cand2 = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; //       //          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) { //     ,   ?      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf1 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; **cand1 == <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i]) conf1++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; **cand2 == <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i]) conf2++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // ,     ,    ? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { *cand1 = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>+i; conf1++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf2 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { *cand2 = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>+i; conf2++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //     ,      conf1<span class="hljs-comment"><span class="hljs-comment">--; conf2--; } } if(conf1 == 0) *cand1 = NULL; if(conf2 == 0) *cand2 = NULL; }</span></span></code> </pre><br>  This algorithm was <a href="http://www.cs.utexas.edu/users/misra/scannedPdf.dir/FindRepeatedElements.pdf">published</a> in 1982 by American scientists Jayadev Misra and David Gries (Jayadev Misra &amp; David Gries), and their work uses a more boring metaphor - a bag with <i>N</i> numbers from which they extract 3 different numbers for each operation.  In addition, their pseudo-code is not similar to any language understandable to the modern programmer.  I liked more the explanation of their algorithm in the <a href="http://www.cs.dartmouth.edu/~ac/Teach/CS49-Fall11/Notes/lecnotes.pdf">last year‚Äôs lecture notes by</a> American professor Amit Chakrabarti. <br><br><img src="https://habrastorage.org/storage2/06c/527/4e4/06c5274e4a647b81b83932a0f1162897.jpg"><br><br>  In the most general form, when in an array of length <i>N</i> you need to find elements that repeat more than <i>N</i> / <i>k</i> times, you will have to use a dictionary.  Store in the dictionary, we will only those elements with which people are - that is,  no more than <i>k</i> -1 entries. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span>[] majority(<span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> N, <span class="hljs-type"><span class="hljs-type">int</span></span> k) { //      <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>,uint&gt; candidates = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>,uint&gt;{}; //        k <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) { //     ,   ?      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.ContainsKey(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i])) candidates[<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i]]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // ,     k<span class="hljs-number"><span class="hljs-number">-1</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.Count &lt; k - <span class="hljs-number"><span class="hljs-number">1</span></span>) candidates[<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i]] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //   k<span class="hljs-number"><span class="hljs-number">-1</span></span>  ,      <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> candidates.Keys) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates[l]<span class="hljs-comment"><span class="hljs-comment">-- == 0) // (**) candidates.Remove(l); // (*) } return candidates.Keys.ToArray(); }</span></span></code> </pre><br>  In this most general form of the algorithm, there is still one pass through the array and <i>O</i> ( <i>k</i> ) additional memory.  If we use a hash table to implement the dictionary, and link all entries in the dictionary to the list, then the overall complexity of the algorithm will remain linear: the line (*) will be executed at most <i>N</i> times after deleting the entry from the dictionary, because at each iteration of the main loop the dictionary is added no more than one entry.  As an exercise, readers are asked to understand why the line (**) does not violate the linearity of the algorithm. <br><br>  Thus, our device with a small memory would be able to communicate with <a href="http://habrahabr.ru/post/166377/">one fluffy beast</a> , recently prepared by habraumelets.  The signals of this animal have five logical levels: we assume <i>k</i> = 6, and we get all five levels right on the move, even without storing the signal in memory.  It is only necessary to provide a protocol so that all five levels occur in the signal equally often. <br><br>  Other applications are mentioned for the Misra-Gris algorithm.  For example, you can monitor real-time traffic on the network, and if a single host consumes a disproportionately large part of the traffic, start an investigation.  You can also monitor clicks on banners, financial transactions, the flow of instructions in the simulated processor ... In general, everywhere where a large number of repetitions is a suspicious anomaly. <br><br>  <i>For animating the text with illustrations, thank <a href="https://habrahabr.ru/users/nitatunarabe/" class="user_link">Nitatunarabe.</a></i> </div><p>Source: <a href="https://habr.com/ru/post/167177/">https://habr.com/ru/post/167177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167165/index.html">A bunch of ExtJS + Django + Apache + SVN deploy (and a simple CRUD controller on Django)</a></li>
<li><a href="../167167/index.html">Perhaps the strangest accessory. HTC launches bluetooth smartphone phone</a></li>
<li><a href="../167169/index.html">Facebook Hacker Cup 2013 - The Qualification Round is taking place right now</a></li>
<li><a href="../167171/index.html">Manage Windows services using PowerShell. Part 2</a></li>
<li><a href="../167173/index.html">Introduction to Jasmine</a></li>
<li><a href="../167179/index.html">Avast! opens the hunt for mistakes</a></li>
<li><a href="../167181/index.html">Functional PHP programming</a></li>
<li><a href="../167187/index.html">ITU officially approved draft of H.265 video compression standard</a></li>
<li><a href="../167195/index.html">How technology and social sciences help plan</a></li>
<li><a href="../167199/index.html">Counter-Strike 1.6 is available for Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>