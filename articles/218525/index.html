<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Musical toy on STM32 from improvised means</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. 
 One evening I got bored and I decided to assemble a small electronic device from components lying around the house...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Musical toy on STM32 from improvised means</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/751/0d9/9cd7510d956f7a82c4fa73bde41c5b6f.jpg"><br>  Good afternoon, dear habrovchane. <br>  One evening I got bored and I decided to assemble a small electronic device from components lying around the house, purely for entertainment, without any practical purpose.  Anyone can repeat it, even a printed circuit board is not required - the device is assembled from the minimum of electronic components to the canopy, glued with epoxy to some unwanted board, exclusively as a structural element, soldered with the help of wires and flooded with the same epoxy for reliability. <br>  So, do an electronic flute! <br><a name="habracut"></a><br>  In fact, the device is very far from the flute in the spectrum of the sound extracted from it.  But he has an RGB-LED that changes color depending on the notes played, and the sounds are made by a piezo-squeaker, thanks to which the flute's consumption is very low. <br><br>  Let's immediately look at the result: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/AOHIml2C15w%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhi0aCxrIGfADVU6igyEAyBcbfsRXg" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Component selection </h4><br>  Actually, the device started with the tweeters - I saw among my components a pair of SMD piezo emitters from the company Murata, namely <a href="http://www.chipdip.ru/product/pklcs1212e4001/">PKLCS1212E4001</a> and PKLCS1212e2000-r1, similar to it.  These are two ordinary piezo emitters of very small dimensions (10 x 12 x 3 mm), one with a peak response in 4000 Hz, the second in 2000 Hz.  Unlike the speakers, they consume almost no current, the piezoplate bends when voltage is applied, so a square wave at 4 KHz causes the plate to vibrate at the same frequency, making a loud sound.  The consumption is about 0.3 mA at 3.3V. <br>  Since the consumption is so low - why not make a small electronic device powered by a battery?  After all, we will not need any amplifiers and powerful current sources.  True, it will have to pay for this very curve of the frequency response of the pischalok - no, they can reproduce an arbitrary sound signal, for the experiment I even output WAV to them, but the sound leaves much to be desired, therefore we will ‚Äúfeed‚Äù them with the usual meander.  And changing its duty cycle will change the volume of the sound. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/048/e1e/44d/048e1e44d67bc25043342219c4a7c88d.jpg"><br>  <i>Frequency response tweeters</i> <br><br>  Here the presence of two different piezo-emitters plays into the hands - in sum, they will give a slightly smoother frequency response and cover a larger frequency range. <br>  So, with a sound emitter, we decided.  With the power source, too, no questions - good old CR2032, a lithium battery with a very low level of self-discharge, voltage from 3V (fully charged), up to 2V (fully discharged).  For her, I found <a href="http://www.voltmaster.ru/cgi-bin/qwery.pl%3Fid%3D719696023%26group%3D41601">this</a> convenient SMD holder: <br><img src="https://habrastorage.org/getpro/habr/post_images/732/00f/957/73200f957f5da73d5239ce2938d718a9.jpg" alt="image"><br>  <i>SMD battery holder</i> <br><br>  Of course, we need a microphone in order to capture external noise, it is the signal from the microphone that will control the duty cycle of a rectangular signal fed to the emitters.  Any electret will suit, for example, <a href="http://www.chipdip.ru/product/ecm-10d/">such</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/cf7/0d8/995cf70d892e3c87b2b77dbf9fa801e0.jpg" alt="image"><br>  <i>Electret microphone</i> <br><br>  Choose a note will be a variable resistor, again, any one will do, but it's better to take a little more resistance so that it does not draw a lot of current from the battery.  I took 50 kom. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76f/da8/446/76fda8446b9c9ae6b35724e799140603.jpg" alt="image"><br>  <i>Variable resistor</i> <br><br>  You can replace the resistor with several buttons, the game will become much more convenient, but the dimensions of the device will increase (and the number of wires that will have to be led to these buttons, and this, given the chosen method of installation, is a very unpleasant circumstance!) <br><br>  To make the device more interesting, add an RGB-LED.  Of course, this will have a strong effect on consumption, but hardly anyone will play this ‚Äúflute‚Äù long enough for the battery to sit down, so that's okay.  I chose the SMD LED <a href="http://www.chipdip.ru/product/kaa-3528embsgc/">KAA-3528EMBSGC</a> . <br><br>  It remains to the controller - took what was at hand, <a href="http://www.st.com/web/catalog/mmc/FM141/SC1169/SS1031/LN775/PF216837">STM32F100C4</a> , at one time they were worth almost 20 rubles in Terra for some kind of action, and I could not help myself, I bought them a whole bag.  The controller is not in the most convenient case for mounting on the ‚Äúknee‚Äù - LQFP48, with a pitch of 0.5 mm. <br><br>  Actually, almost all the details are shown in the photo below (and a piece of some old board to which it all stuck) - a second squeaker was added to them (there is only one in the photo, the one on 4 KHz), a couple of SMD buttons and a handle for potentiometer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c4/81f/a6c/3c481fa6cddcd3c7c8b1dd76d637165f.jpg"><br>  <i>Device details</i> <br><br>  As for the buttons - initially I planned to select all notes with a variable resistor (and the notes were planned to have two full octaves), but then I realized that then the device would turn out quite uncomfortable and added two buttons.  One chooses ‚Äúsharps‚Äù, that is, it shifts the currently selected note a semitone up, and the second shifts the selected note by a whole octave.  Thus, instead of 2 (octaves) * 12 (half tones) = 24 positions of the potentiometer, you will need to track only 7, corresponding to seven notes, and change semitones and octaves by pressing the buttons if necessary. <br><br><h4>  Device layout </h4><br>  Of course, I did not draw the outline of this whole affair, instead using the STM software to select the controller configuration, MicroXplorer.  It turned out such a beautiful picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/c23/cb0/b66/c23cb0b66e3c0b53fd6d265c8d9d8d27.jpg"><br><br>  So, what and with what we will connect? <br><ol><li>  For a start, we need two PWM channels for our two tweeters.  In principle, this is a moot point - you can get by with one and put both tweeters in parallel, then they will always feed on the signal of the same frequency and duty cycle. <br>  You can select the channel for each beeper, then the frequencies will be the same, and the duty ratio (and hence the envelope shape!) Can be set individually.  And, finally, each timer can be assigned a separate timer, then it will be possible to set different frequencies and different duty cycles. <br>  Since the circuit will be filled with epoxy, after which it will be impossible to change something in it, I decided to output the signals necessary for the implementation of all the options to a small debugging connector in order to be able to change the solution later. <br>  Therefore, we take a timer, say, TIM3, and select a pair of its channels for outputting PWM - these are the pins PA6 and PA7. </li><li> Of course, you need three PWM channels to control the RGB LED.  Considering the voltage of the battery and its internal resistance, we will feed directly through the pins of the controller, without resistors - we will not give more than 10 mA for each pin, on the blue diode it drops so much that it will not even be able to bring it to maximum brightness at our maximum 3V power supply. <br>  We will derive the fourth channel for the situation mentioned in item 1 - if anything, let them squeak. <br>  So, choose TIM1 and pins PA8, PA9, PA10, PA11 to output PWM. </li><li>  Definitely have to remove the analog signal from the microphone and potentiometer, for this we use the built-in ADC - pins PA2 and PA3. <br>  Since we started talking about the analog signal, we will immediately think how to take the signal from the microphone.  The traditional circuit includes a capacitor, for cutting the DC component, a resistive divider to shift the signal by half the power, the preamp to use the entire dynamic range of the ADC.  We will do without all this.  We will cut off the constant component programmatically, the dynamic range is not so important to us, therefore we will connect a microphone like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/035/8a1/1c90358a1813ed3a06b893d7f45d9253.jpg"><br><br>  As a result, the output will get about 2V in a quiet state, and from ~ 1.5 to ~ 2.5 with loud sounds near the microphone. <br>  The potentiometer, of course, will turn on as a divider between the power supply and the ground, deriving the midpoint to the adjacent ADC channel. <br></li><li>  We will need to remove the signal from the two buttons - for this we will use the free pins PA0 and PA1 for now, turn on the internal one, so we just connect the pins through the button to the ground. </li><li>  We will definitely need a debugging interface.  In principle, it is enough to bring out SWDIO and SWCLK (as well as ground and power), but in reality, the RESET pin will not really, really hurt - since we will set up the sleep mode, we will be left without debug as soon as the controller falls asleep.  And it can be changed only by STM utility with a RESET pin, software reset will not work.  So let's not play with fire, but just pull out the ground, power, PA13, PA14 pins and NRST pin on the debugger connector. </li><li>  The last item is optional, but it makes debugging easier when working with analog signals - we will output the DAC channel to the same connector to which the pins for flashing were brought out - with its help we will be able to watch any intermediate analog signal during processing </li></ol><br><br>  That is, in fact, all the iron.  Then begins the longest part - the assembly circuit without a printed circuit board.  If you are not averse to spending this time fussing with ferric chloride, you can dilute the described scheme on a small board and skip the following points. <br><br><h4>  Soldering </h4><br>  There is nothing to describe here, I attach a few photos of the process.  The microcircuit is glued ‚Äúupside down‚Äù, a thin stripped and debonded wire is soldered to each required leg, and gently retracted to the side.  When all the wires are set aside, the connection is checked and, if all is well, the chip is filled with a drop of epoxy.  After that, the wires can be pulled without fear.  The wire that goes in a ring is the ground, the controller is connected to the ground and to the power supply on each side. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e00/974/191/e00974191ea48475be17bf7ab943ce94.jpg"><br>  <i>Solder the ground.</i>  <i>The old board came in handy - I used its ground to unite the land.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a98/a4d/491/a98a4d49126f0e176dc8879009782a89.jpg"><br>  <i>Solder the debugging interface and check that the controller is running.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70e/c84/cbc/70ec84cbc43cb5c2e55319d45095ad5b.jpg"><br>  <i>Solder all other pins</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13b/a7d/15f/13ba7d15f37b279b7b31c63e35ee4481.jpg"><br>  <i>Fill with epoxy</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f1/ead/892/2f1ead892bac663c31821f8cb230e3dd.jpg"><br>  <i>Almost assembled device, it remains to place the second squeaker and top up with epoxy</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/124/029/e24124029b3b728b821ea00ee0f78ef8.jpg"><br>  <i>All is ready</i> <br><br>  On this, the hardware is finished, go to the firmware. <br><br><h4>  Firmware </h4><br>  The firmware is pretty simple.  We create an empty project under our STM32F100C and begin to prescribe initialization: <br><br><div class="spoiler">  <b class="spoiler_title">GPIO Initialization</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_Red GPIO_Pin_9 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_Green GPIO_Pin_10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_Blue GPIO_Pin_11 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_SHARP GPIO_Pin_0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_OCT GPIO_Pin_1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_FreePWM GPIO_Pin_8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BUZZER1 GPIO_Pin_6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BUZZER2 GPIO_Pin_7 void InitGPIO() { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_BUZZER1 | GPIO_BUZZER2 | GPIO_FreePWM |GPIO_Red|GPIO_Green|GPIO_Blue; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_SHARP | GPIO_OCT; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); }</span></span></code> </pre> <br></div></div><br>  Here we set up our GPIO - all PWM channels are output controlled by peripherals in the Push-Pull mode (GPIO_Mode_AF_PP), the buttons are input pins pulled to power.  ADC channels and so default are configured as analog inputs. <br><br><div class="spoiler">  <b class="spoiler_title">ADC Initialization</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIGNAL_OFFSET 850 void InitADC() { ADC_InitTypeDef ADC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); ADC_InitStructure.ADC_ScanConvMode = ENABLE; ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_Init(ADC1, &amp;ADC_InitStructure); ADC_InjectedSequencerLengthConfig(ADC1, 2); ADC_InjectedChannelConfig(ADC1, ADC_Channel_2, 1, ADC_SampleTime_1Cycles5); ADC_SetInjectedOffset(ADC1, ADC_InjectedChannel_1, SIGNAL_OFFSET); ADC_InjectedChannelConfig(ADC1, ADC_Channel_3, 2, ADC_SampleTime_1Cycles5); ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_None); ADC_Cmd(ADC1, ENABLE); }</span></span></code> </pre><br></div></div><br>  Here we set up two ADC channels.  We will use it in the ‚Äúinjected channels‚Äù mode, which means that we have as many as four registers for the data, that is, we can take up to four measurements from different channels and not care that some data grind others. <br>  We say that we need the SCAN mode - that is, the conversion of all these channels one by one.  Channel 2 is responsible for the microphone, so we say that we have an offset of 850 units - this number will automatically be deducted from the result of the conversion.  To calculate it, it is enough to set this offset to zero and see what value is removed from the ADC in silence. <br><br><div class="spoiler">  <b class="spoiler_title">Timer initialization</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; TIM_TimeBaseStructure.TIM_Period = <span class="hljs-number"><span class="hljs-number">0xFFF</span></span>; TIM_TimeBaseStructure.TIM_Prescaler = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_TimeBaseStructure.TIM_ClockDivision = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; TIM_OC1Init(TIM3, &amp;TIM_OCInitStructure); TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable); TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); TIM_SetCompare1(TIM3, <span class="hljs-number"><span class="hljs-number">0x00</span></span>); TIM_SetCompare2(TIM3, <span class="hljs-number"><span class="hljs-number">0x00</span></span>); TIM_ARRPreloadConfig(TIM3, ENABLE); TIM_Cmd(TIM3, ENABLE); TIM_CCxCmd(TIM3, TIM_Channel_1, ENABLE); TIM_CCxCmd(TIM3, TIM_Channel_2, ENABLE); TIM_TimeBaseStructure.TIM_Period = <span class="hljs-number"><span class="hljs-number">0xFFF</span></span>; TIM_TimeBaseStructure.TIM_Prescaler = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_TimeBaseStructure.TIM_ClockDivision = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number"><span class="hljs-number">0x000</span></span>; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low; TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure); TIM_OC2Init(TIM1, &amp;TIM_OCInitStructure); TIM_OC3Init(TIM1, &amp;TIM_OCInitStructure); TIM_OC4Init(TIM1, &amp;TIM_OCInitStructure); TIM_CCxCmd(TIM1, TIM_Channel_1, DISABLE); TIM_CCxCmd(TIM1, TIM_Channel_2, ENABLE); <span class="hljs-comment"><span class="hljs-comment">//R TIM_CCxCmd(TIM1, TIM_Channel_3, ENABLE); //G TIM_CCxCmd(TIM1, TIM_Channel_4, ENABLE); //B TIM_Cmd(TIM1, ENABLE); TIM_CCPreloadControl(TIM1, DISABLE); TIM_CtrlPWMOutputs(TIM1, ENABLE); }</span></span></code> </pre><br></div></div><br>  The largest initialization function, setting up two timers.  We adjust both to PWM, the frequency of what controls the LEDs will be fixed, the frequency of the squeaker, of course, will change.  Since  the system frequency is 8 MHz (the smaller, the better, it will consume less!), we will have to change the width of the PIM to achieve the required output frequencies (up to 4 KHz +), but more on that later. <br><br>  Now consider the implementation of the main function of the device - the interrupt handler from the system timer ticking with a frequency of 1 KHz. <br>  Initially, I assumed the use of the calculated power of the captured signal to modulate the pulse that feeds the piezo emitters, but it turned out that this does not sound very good, despite the filters.  As a result, the simplest solution turned out to be the most pleasing to the ear: the signal power acts as a ‚Äútrigger‚Äù, exceeding the threshold (in absolute value and derivative) starts the playback process. <br>  The envelope is generated by a process slightly similar to the discharge of a capacitor: when the threshold is exceeded, we enter into the working variable <b>Envelope</b> some initial value <b>START_VAL</b> - this is an instant ‚Äúcharging‚Äù of our capacitor.  Further, at each interrupt processing, a new signal value is obtained from the old by multiplying by 0.987 - a purely empirically selected value, which, moreover, depends on the frequency with which interrupts occur.  Thus, Envelope (t) = START_VAL * 0.987 ^ t.  In order not to use soft floats, we use a fixed comma, multiplying by 0.987 is equal to multiplying 64684 and dividing by 65,536 (shift by 16 to the right).  I.e, <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENV_DECR 64684 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//0,987 Envelope = (Envelope*ENV_DECR)&gt;&gt;16;</span></span></span></span></code> </pre><br>  We limit the output <b>ClippedEnvelope</b> value <b>to</b> some number, say, 4000, also chosen empirically.  Then the output value will be 4000 when the <b>Envelope is</b> greater than 4000, or the <b>Envelope</b> value itself when it is smaller.  As a result, we obtain a decreasing exponent with a ‚Äúshelf‚Äù ‚Äîa short period of time, during which the output signal does not depend on time and is maximum. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71b/1ef/83e/71b1ef83ee4bb18fed3a0fe8fd6e90b0.jpg"><br>  <i>ClippedEnvelope value</i> <br><br>  This signal can be directly set as the duty ratio, if not for two BUT: <br><ol><li>  To change the frequency of the sound, you will have to change the period of the timer, and with our system frequency there will no longer be 12-bit PWM at 4KHz. </li><li>  For a PWM piezorestiller with a maximum duty cycle, it does not differ from a minimum PWM, so the maximum sound volume will be at the meander (the duty cycle is 50%). </li></ol><br>  Consequently, the period of the <b>TimerPeriod</b> timer is specified by the note selected at the moment, and the maximum value of the comparison register will be half the period ( <b>TimerPeriod</b> / 2), which will mean a square wave with a 50% duty cycle, which means the maximum sound volume. <br>  Then, at this frequency, the value of our <b>ClippedEnvelope</b> signal, equal to 4000, should set this maximum to half of the period, which means <br><br><pre> <code class="cpp hljs">u16 OutEnvelope = (TimerPeriod/<span class="hljs-number"><span class="hljs-number">2</span></span>)*ClippedEnvelope/<span class="hljs-number"><span class="hljs-number">4000</span></span>;</code> </pre><br>  The values ‚Äã‚Äãof <b>TimerPeriod</b> will be selected according to the table, which can either be calculated at the start using the well-known formula <img src="https://habrastorage.org/getpro/habr/post_images/090/1b9/2cd/0901b92cdcf2dd7ccdf794511151edb4.png" alt="image">  , or even set constants, which I did to maintain accuracy.  The formula sets the frequency ratios (and, respectively, periods) for a <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2580%25D0%25BD%25D0%25BE_%25D1%2582%25D0%25B5%25D0%25BC%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B9">uniformly tempered pitch</a> .  We can only choose the base note, from which we will count all the rest - I took the note To the third octave at a frequency of 1046.5 Hz.  For the current value of the controller frequency (8 MHz), the corresponding period is equal to 7644 timer ticks. <br>  In this case, to reproduce the notes of the next octave, it is enough for us to divide the current value of the period by 2. And to reproduce the ‚Äúsharps‚Äù (by a half tone), divide the period by <img src="https://habrastorage.org/getpro/habr/post_images/138/f14/e07/138f14e07ea45c159eefa38ec7fbdc50.png" alt="image">  . <br>  In order not to start the second array with the predicted "sharps", we will again use a fixed comma - divide by 1.059463 means multiply by 61858 and divide by 65536. <br>  Let's check our calculations: according to the table in Wikipedia, the frequency of the C-sharp (C #) note is 1108.7 hertz.  Our period for Do is 7644. <br>  c_sh = (7644 * 61858) &gt;&gt; 16 = 7215 <br>  We divide the timer frequency (8 000 000) by the received period, we get 1108.8 Hz - very close. <br><br>  Practically all the questions were considered, the illumination remained - let's first implement an auxiliary function for calculating the color of the LED, and then proceed to the code for the interrupt handler. <br><br><div class="spoiler">  <b class="spoiler_title">Calculate RGB color components</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Spectrum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 position, u32* r, u32* g, u32* b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position&lt;<span class="hljs-number"><span class="hljs-number">85</span></span>) { *r=<span class="hljs-number"><span class="hljs-number">85</span></span>-position; *g=position; *b=<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position&gt;<span class="hljs-number"><span class="hljs-number">84</span></span>&amp;&amp;position&lt;<span class="hljs-number"><span class="hljs-number">170</span></span>) { *r=<span class="hljs-number"><span class="hljs-number">0</span></span>; *g=<span class="hljs-number"><span class="hljs-number">170</span></span>-position; *b=position<span class="hljs-number"><span class="hljs-number">-85</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position&gt;<span class="hljs-number"><span class="hljs-number">169</span></span>) { *r=position<span class="hljs-number"><span class="hljs-number">-170</span></span>; *g=<span class="hljs-number"><span class="hljs-number">0</span></span>; *b=<span class="hljs-number"><span class="hljs-number">255</span></span>-position; } *r*=<span class="hljs-number"><span class="hljs-number">3</span></span>; *g*=<span class="hljs-number"><span class="hljs-number">3</span></span>; *b*=<span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br></div></div><br>  For this, I propose the following implementation.  The byte <b>position</b> parameter indicates where we are in the spectrum, and the function writes the byte values ‚Äã‚Äãof R, G, and B into the pointers passed to it (higher-dimensional pointers for interfacing with the rest of the code). <br>  The implementation is very simple and transparent - if we look at the spectrum, we will see that we can distinguish 3 fragments of equal length.  From zero to 1/3 of the spectrum, the intensity of the red color drops from a maximum to zero, at the same time the intensity of green grows from zero to a maximum (it covers the red-orange-yellow-green parts).  From one-third to two-thirds the same thing happens with green (drops to zero) and blue (grows to maximum) colors (covers green-blue-blue parts), and finally, the last part - red gains strength again, and blue reduces intensity , covers the blue-violet portions and loops again in red. <br><br>  As an input parameter, you can take the position of the potentiometer, but even better - take, say, the last three positions - then even having played three notes in a row, we still see a change of colors.  The ‚Äúbyte‚Äù of the input value will help us - we will not invent anything, but simply add up all three positions of the potentiometer, since  at the output, in any case, we get a number from the range 0-255. <br>  At the same time, let's not forget that we still have the second octave and the button for selecting the sharps, so that we take them into account, <br><br><pre> <code class="cpp hljs">ResistorValue = ((res*highOctave)+sharp)&gt;&gt;<span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Here, <b>res</b> is the value read from the ADC channel, <b>highOctave</b> takes the values ‚Äã‚Äã1 and 2 depending on the pressed octave selection button, and <b>sharp</b> adds a small offset if the sharps button is pressed.  We shift all this by 5, because  The value of the ADC is 12-bit - in the end, the output value will be 8-bit, as required by the color calculation function. <br><br>  The following is the implementation of the interrupt handler: <br><br><div class="spoiler">  <b class="spoiler_title">System Timer Interrupt Handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HALF_TONE 61858 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//0.9438782 #define ENV_DECR 64684 //0,987 #define START_VAL 7500 #define CLIPPING_VAL 4000 #define POWER_TH 400 #define DPOWER_TH 500 #define SLEEP_INTERVAL 10 u16 Notes[7] = {7644, 6810, 6067, 5726, 5102, 4545, 4050}; u16 ResLin[] = {10, 249, 480, 900, 2000, 3685, 4095}; s32 Envelope=0; u32 TimerPeriod=0; s32 LastPower=0; u16 ResistorValue[3]; u32 Sleeped = 0; u16 sharp=0, highOctave=0; void SysTick_Handler() { volatile s16 mic; volatile u16 res; mic = (s16)ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_1); res = ADC_GetInjectedConversionValue(ADC1, ADC_InjectedChannel_2); ADC_SoftwareStartInjectedConvCmd(ADC1, ENABLE); s32 power = mic; power = (power*((s32)mic))&gt;&gt;9; s32 dP = power-LastPower; LastPower=power; //linearizing resistor u8 n; for(n=0;n&lt;6;n++) if(res&lt;ResLin[n]) break; if(power&gt;POWER_TH &amp;&amp; dP&gt; DPOWER_TH) { //got signal! Sleeped=0; TimerPeriod=Notes[n]; sharp=0; highOctave=1; if(!GPIO_ReadInputDataBit(GPIOA, GPIO_SHARP)) { sharp = 0x700; TimerPeriod=(TimerPeriod*HALF_TONE)&gt;&gt;16; } if(!GPIO_ReadInputDataBit(GPIOA, GPIO_OCT)) { TimerPeriod/=2; highOctave = 2; } if(Envelope&lt;CLIPPING_VAL) { ResistorValue[0] = ResistorValue[1]; ResistorValue[1] = ResistorValue[2]; ResistorValue[2] = ((res*highOctave)+sharp)&gt;&gt;5; } TIM_SetAutoreload(TIM3, TimerPeriod); Envelope=START_VAL; } Envelope = (Envelope*ENV_DECR)&gt;&gt;16; if(Envelope&lt;50) { Envelope=0; Sleeped++; StopPeripherals(); u32 interval=SLEEP_INTERVAL; if(Sleeped&gt;1000) interval*=8; Stop(interval); } u16 ClippedEnvelope=Envelope; if(Envelope&gt;CLIPPING_VAL) ClippedEnvelope=CLIPPING_VAL; u16 OutEnvelope = (TimerPeriod/2)*ClippedEnvelope/4000; //Debug DAC //DAC_SetChannel1Data(DAC_Align_12b_R, dP); u32 r=0,g=0,b=0; u8 sPos = 0; for(u8 i=0;i&lt;3;i++) sPos+=ResistorValue[i]; Spectrum(sPos,&amp;r,&amp;g,&amp;b); r*=ClippedEnvelope; g*=ClippedEnvelope; b*=ClippedEnvelope; r&gt;&gt;=11; g&gt;&gt;=9; b&gt;&gt;=8; TIM_SetCompare1(TIM3, OutEnvelope); TIM_SetCompare2(TIM3, OutEnvelope); TIM_SetCompare2(TIM1, r); TIM_SetCompare3(TIM1, g); TIM_SetCompare4(TIM1, b); }</span></span></span></span></code> </pre><br></div></div><br>  Here we have almost considered everything, except for the linearization of the potentiometer - it turned out that it is terribly non-linear closer to the edges of the range.  So, for example, we need to divide its maximum rotation angle (about 275 degrees) into 7 sectors, but it turns out that almost the entire first sector has a value taken from the ADC equal to 0. Toward the end of the first sector, it begins to increase sharply, the linear part goes then, closer to the end of the last sector, again sharply rises to the limit value.  It saves the graduated scale, on which I turned the potentiometer approximately at the required angle and looked at the real value of the ADC, which I then entered into the <b>ResLin</b> array. <br>  The second point that may catch the eye is shear operations after calculating the color.  First, the obtained values ‚Äã‚Äãof the color components must be multiplied by the envelope so that the diode flashes in time with the music.  Therefore, we already get 12 bits + 8 bits = 20 bits.  It is necessary to shift the result by 8 to prevent overflow. <br>  And the difference in the magnitude of the shift is due to the fact that different voltage drops on the diodes of different colors, which is why the red diode at the same PWM value shines brighter than green, and, moreover, than blue.  By setting a different shift, we slightly compensate for this so that the white color looks really white rather than yellowish. <br><br>  The last stage is energy saving.  In the active mode, the device consumes 5.5 mA (and up to 10-15 with the LED flash).  Acceptable for a working device, but completely unacceptable for a waiting signal.  We will lead the device to sleep, as soon as the envelope value reaches 0 (more precisely, when it reaches 50, then we equate it manually to zero, because the exponent will get to zero for a long time, and even a 1/4096 portage enough to produce sound). <br>  Therefore, we tune the RTC to 1 KHz: <br><br><div class="spoiler">  <b class="spoiler_title">RTC setup</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitRTC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE); PWR_DeInit(); PWR_BackupAccessCmd(ENABLE); RCC_LSICmd(ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET); RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI); RCC_RTCCLKCmd(ENABLE); RTC_WaitForSynchro(); RTC_WaitForLastTask(); RTC_SetPrescaler(<span class="hljs-number"><span class="hljs-number">40</span></span>); RTC_WaitForLastTask(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(RTC_GetFlagStatus(RTC_FLAG_SEC|RTC_FLAG_ALR) == RESET); EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line = EXTI_Line17; EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_InitStructure.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_InitStructure); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel = RTCAlarm_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">1</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); }</code> </pre><br></div></div><br><br>  We define auxiliary functions - fall asleep for a specified number of milliseconds, turning off the peripherals, turning on the peripherals back and the RTC Alarm interrupt handler: <br><br><div class="spoiler">  <b class="spoiler_title">Energy saving features</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 delay)</span></span></span><span class="hljs-function"> </span></span>{ RTC_SetCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>); RTC_WaitForLastTask(); RTC_SetAlarm(RTC_GetCounter()+delay); RTC_WaitForLastTask(); PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StopPeripherals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ADC_Cmd(ADC1, DISABLE); TIM_Cmd(TIM1, DISABLE); TIM_Cmd(TIM3, DISABLE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartPeripherals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ADC_Cmd(ADC1, ENABLE); TIM_Cmd(TIM1, ENABLE); TIM_Cmd(TIM3, ENABLE); ADC_SoftwareStartInjectedConvCmd(ADC1, ENABLE); SysTick_Config(SystemCoreClock/<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RTCAlarm_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EXTI_ClearITPendingBit(EXTI_Line17); StartPeripherals(); }</code> </pre><br></div></div><br><br>  To ensure that the system behaves adequately during the game, we will fall asleep to SLEEP_INTERVAL = 10 ms, this is completely unnoticeable, however, it reduces the consumption to 1.1 mA.  And in order not to waste extra energy when the device is postponed, we will count our intervals in the <b>Sleeped</b> variable, and if we have counted more than 1000 (about 10 seconds) without an input signal, we start falling asleep at SLEEP_INTERVAL * 8, reducing the consumption to 0.7 mA. <br><br>  Unfortunately, I didn‚Äôt succeed in reducing consumption - not the most suitable for low consumption controller, a potentiometer with a resistance lower than it should (I planned 50K, 100K would be necessary, but I soldered, it looks like, by mistake, 24K), perhaps - some small leakage through the power supply circuit of the microphone and so on.  However, the toy will come down, the battery has a capacity of 150 mAh, so it should be enough for almost 9 days of waiting. <br><br>  On this I have everything, good devices to you! </div><p>Source: <a href="https://habr.com/ru/post/218525/">https://habr.com/ru/post/218525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218505/index.html">Who should I work then, what to do?</a></li>
<li><a href="../218507/index.html">How not to make a "poop"? Personal experience of creating a product</a></li>
<li><a href="../218509/index.html">Best methods for finding new B2B customers in 2014</a></li>
<li><a href="../218521/index.html">Advantages of dedicated servers over cloud solutions on the example of Tuffle.com server architecture</a></li>
<li><a href="../218523/index.html">How to become a negotiator - an interview with Dmitry Kotkin</a></li>
<li><a href="../218527/index.html">GestureWorks Gameplay Virtual Controller - The Second Birth of Favorite Games</a></li>
<li><a href="../218529/index.html">Stylization of form elements and an attempt to circumvent the pitfalls</a></li>
<li><a href="../218531/index.html">Second PyCon Russia: Ekaterinburg, June 2-3</a></li>
<li><a href="../218533/index.html">A new version of the distribution has been released to create a pfSense 2.1.1 firewall.</a></li>
<li><a href="../218535/index.html">Utility StorTrends iDATA for intelligent analysis of bottlenecks in IT infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>