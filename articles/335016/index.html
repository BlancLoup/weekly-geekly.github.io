<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TSP problem. Mixed algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all. In previous articles, we compared two heuristic optimization algorithms on a symmetric traveling salesman problem such as: ACS (ant c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TSP problem. Mixed algorithm</h1><div class="post__text post__text-html js-mediator-article">  Good day to all.  In previous articles, we compared two heuristic optimization algorithms on a symmetric traveling salesman problem such as: ACS (ant colony system - ant algorithm) and SA (simulating annealing - annealing simulation algorithm).  As we have seen each has its own pros and cons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c0a/5ae/0bc/c0a5ae0bc2df4b3b991ba9196f550132.jpeg"></div><br><a name="habracut"></a><br>  The advantages of SA are the relatively high speed of the algorithm, the ease of implementation.  Of the minuses - the algorithm is not "flexible", there is also no so-called "ability to rebuild the figure."  For those who want to grasp the essence of the simulation annealing algorithm, refer to this <a href="https://habrahabr.ru/post/209610/">article</a> . <br>  Pros AS (ACS) - the presence of collectivism, the convergence of the algorithm from iteration to iteration, the ability to rebuild the figure (always looking for alternative ways, in fact, with the correct selection of parameters does not get stuck on the local optimum), the possibility of partial parallelism.  Of the minuses - a long time algorithm, the complexity of a high number of vertices.  Those who want to grasp the essence of the ant algorithm refer to the <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D1%2583%25D1%2580%25D0%25B0%25D0%25B2%25D1%258C%25D0%25B8%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B">site</a> .  You can also see the code written in MatLab in my previous articles; there you can understand the principle in the comments. <br><br>  Today I would like to show you the first version of the algorithm, which has absorbed the best of different algorithms, and which is able to find, from the first attempt with a high probability, a <b>global optimal path</b> to 100 vertices in less than 5 seconds on a regular home PC.  I will try to show everything by examples with graphic illustrations.  The code is written in MatLab.  Mostly in his element - vector, if anyone has problems with the transfer of the algorithm to your language - write in the comments.  Those who are interested more seriously, or those who want to implement their version - I suggest to look at previous articles, and also to see the full code of the algorithm, which will be attached below the article.  In the comments I tried to paint every line. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately, I note that this algorithm may already exist, but I did not find it in the vastness of the global network.  So, how should it be in the implementation of this article: <br><br>  1 - as simple as possible <br>  2 - The fastest <br>  3 - The possibility of parallelization on the CPU (including the current fashionable GPU) <br>  4 - Flexible (possibility of upgrading, variability of parameters) <br>  5 - Less dependent on random parameters. <br>  6 - Ability to rebuild the figure <br><br>  By what I mean rebuilding the figure, see below. <br><br>  Rebuilding a TSP shape on task Eil101 (traveling salesman problem): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/4ec/7ed/184/4ec7ed184a724e9a92f872635c7bbe90.png"></div><br>  The image shows that the distance of both routes differs by 1%, but their routes are completely different.  That is completely different figures.  A good algorithm should create as many similar shapes as possible.  In SA it is poorly developed. <br><br>  The method of simulating annealing (as we have seen in previous articles) at the initial high temperature, as well as at a slowly falling temperature, is able to achieve good results, but this significantly increases the algorithm time, nor does it guarantee that the global best path will be found.  It‚Äôs another thing if we run several SA algorithms at once, add the results of each to the array and select the best one. <br><br>  One of the drawbacks of the classic SA algorithm is that there are too many ‚Äúrandoms‚Äù in it, first we randomly select two vertices, then again ‚Äúrandom‚Äù, in order to make or not make the worst decision.  In this algorithm, I tried to minimize the proportion of chance. <br><br>  Therefore, in this algorithm, instead of ‚Äúrandomizing‚Äù two vertices, we immediately iterate over all possible parts of the inversion path.  Let me remind you that our goal is only the global optimum, only <strike>hardcore</strike> .  More precisely not global, but the best found to date. <br><br>  <i><b>Clarification:</b></i> <br>  <i>There is a route: [1,2,3,4,5,6,7,8] - the traveler first visits the first city, then the second, etc.</i>  <i>‚ÄúRandom two vertices‚Äù means randomly choosing two numbers (even distribution), say 2 and 6, then invert the path between them.</i>  <i>The path will take the form: [1, <b>6</b> , 5,4,3, <b>2</b> , 8].</i> <br><br>  We completely enumerate the parts of the path inversion into a function that accepts a route (any, even the most incorrect one), searches for the most profitable part of the route for a turn, unfolds it, then again searches for the most profitable part of the route taking into account the previous changes and repeats the cycle until , while no replacement of part of the route will improve the distance. <br><br>  This method is known as the 2opt algorithm.  However, in the classic 2opt algorithm, we immediately expand a part of the route, which improves the result, but here we are looking for, in addition to the standard 2opt, also the ‚Äúbest replacement‚Äù. <br><br>  Graphic illustration: <br><br>  on the 1st gif animation, the algorithm immediately expands the found part of the route, which improves the total distance (standard 2-opt) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a83/5a1/4b5/a835a14b572640948bea91ec91288648.gif"></div><br>  on the 2nd gif animation, the algorithm drives all possible replacements of a part of the route, then expands the most maximal delta (m. 2-opt) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/255/316/870/2553168704974b75a17b181175e84c97.gif"></div><br>  In today's algorithm, we will use the second option, since in a series of tests it shows far better results.  The first option will be left for revision. <br><br>  So, we have two functions that optimize the route with a kind of "modernized method of simulating annealing."  It remains only to pass by a parallel loop (in MatLabe, the parfor operator allows you to use all the cores of a PC) into the function a couple of thousand of such routes (which will also be created by a parallel loop) and select the best one. <br><br><div class="spoiler">  <b class="spoiler_title">Brute force function (best replacement)</b> <div class="spoiler_text"><pre><code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">%         %     ( ) % dist -   % route -  % openclose -       %------------------------------------------------------------------------ function [tour, distance] = all_brute_best(dist,route,n) global_diff = -0.1; best_dist = inf; %      ,    while global_diff &lt; 0 global_diff = 0; p1 = route(n); %     for i = 1:n-2 t1 = p1; p1 = route(i); t2 = route(i+1); spd_var = dist(t1,p1); for j = i+2:n p2 = t2; t2 = route(j); diff = (dist(t1,p2) - dist(p2,t2))... + (dist(p1,t2) - spd_var); %        if global_diff &gt; diff global_diff = diff; % ""     imin = i; jmin = j; end end end %   if global_diff &lt; 0 route(imin:jmin-1) = route(jmin-1:-1:imin); end end %-------------------------------------------------------------------- %    cur_dist = 0; for i = 1:n-1 cur_dist = cur_dist + dist(route(i),route(i+1)); end %      cur_dist = cur_dist + dist(route(1),route(end)); %-------------------------------------------------------------------- %    if cur_dist &lt; best_dist best_route = route; best_dist = cur_dist; end %   -   distance = best_dist; %   tour = best_route; end</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Brute force function (each replacement)</b> <div class="spoiler_text"><pre> <code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">%         %     ( ) % dist -   % route -  % openclose -       %------------------------------------------------------------------------- function [tour, distance] = all_brute_first(dist,route,n) global_diff = -0.1; best_dist = inf; %      ,    while global_diff &lt; 0 global_diff = 0; p1 = route(n); %     for i = 1:n-2 t1 = p1; p1 = route(i); t2 = route(i+1); spd_var = dist(t1,p1); for j = i+2:n p2 = t2; t2 = route(j); diff = (dist(t1,p2) - dist(p2,t2))... + (dist(p1,t2) - spd_var); %        if diff &lt; 0 global_diff = diff; % ""     imin = i; jmin = j; break end end %    if diff &lt; 0 break end end %   if global_diff &lt; 0 route(imin:jmin-1) = route(jmin-1:-1:imin); end end %-------------------------------------------------------------------- %    cur_dist = 0; for i = 1:n-1 cur_dist = cur_dist + dist(route(i),route(i+1)); end %      cur_dist = cur_dist + dist(route(1),route(end)); %-------------------------------------------------------------------- %    if cur_dist &lt; best_dist best_route = route; best_dist = cur_dist; end %   -   distance = best_dist; %   tour = best_route; end</span></span></code> </pre><br></div></div><br>  This is where the fun begins. <br><br>  What routes to transmit?  Naturally, when exiting, they should contain as many different figures as possible (see above).  Also, if we simply transmit a random array, then we will not see the best result globally.  So let our array of routes to the input of the function ‚Äúall_brute_best‚Äù consist of different algorithms. <br><br>  The first that immediately came to mind is the <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B0">method of the nearest neighbor</a> .  We will leave each city once, and get an array of nxn routes (n is the number of cities).  Then we transfer this array to the optimization function. <br><br>  At Matlabe, the nearest city will be visited as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Nearest Neighbor Method</b> <div class="spoiler_text"><pre> <code class="matlab hljs"><span class="hljs-keyword"><span class="hljs-keyword">parfor</span></span> k = <span class="hljs-number"><span class="hljs-number">1</span></span>:n <span class="hljs-comment"><span class="hljs-comment">%   (   ) dist_temp = dist; %     route = zeros(1,n); %    next_point = start_route(k); %   route(1) = next_point; %     for e = 2:n %   dist_temp(next_point,:) = nan; %     [~,next_point] = min(dist_temp(:,next_point)); %   route(e) = next_point; end %        1-  if check_routes == true route = check_tour(route); end %   arr_route_in(k,:) = route; end</span></span></code> </pre><br></div></div><br>  In general, TSP tasks (traveling salesman problem) were solved by many.  They were also solved by the most ‚Äúhard-boiled‚Äù algorithms.  So on the <a href="http://www.math.uwaterloo.ca/tsp/data/">site</a> laid out the best solutions found today. <br><br>  Let us check the algorithm on the problem Eil76, the visual work of which is presented below.  The best path found is 538. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a9a/d78/1b2/a9ad781b2b894e489ca398ee7d818ab5.gif"></div><br>  After completing all 76 optimizations, we get the best route found - 545. The elapsed time is 0.15 seconds.  This algorithm will always find the distance in 545, since there is no share of randomness in it.  The global error is 1.3%. <br><br>  Now the fun part.  As you probably noticed, we just mixed the greedy algorithm, brute force (brute force) and imitation annealing.  Now it's time to add some ant algorithm.  Now, in our algorithm, before transferring to the optimization function, the transition to the nearest city is performed with a 100% probability.  Our task is to find the best route found, make up as many ‚Äúfigures‚Äù as possible and pass them to the function.  As we remember from the ant algorithm (AS), the probability of transition from vertex i to vertex j is determined by the following formula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/64c/a76/bad/64ca76bad7a0437186ab5cdc5ced8f27.png"></div><br>  where [œÑ (i, j)] is the pheromone level on the edge (i, j), [n (i, j)] is the weight inverse to the distance on the edge (i, j), Œ≤ is an adjustable parameter, the higher it is, the the algorithm will tend to select an edge that has a shorter distance.  Since there are no pheromones in this algorithm, we remove them.  Leave only the level of "greed" algorithm.  We carry, as in ACS, the probability of choosing an unvisited vertex.  Either we select only the shortest city, or proceed as follows: <br><br>  The probability of choosing the next edge will be inversely proportional to its length.  We also introduce the variable responsible for the selection of cities that have not yet been visited.  That is, when choosing the next vertex, we will not take into account all the remaining ones, but we will choose among the N-th number of the remaining peaks.  N is a user defined parameter.  This idea was taken from the genetic algorithm.  In the genetic algorithm there is the concept of ‚Äúselection‚Äù, at the stage of which it is necessary to select a certain share from the entire current population, which will remain ‚Äúto live‚Äù.  The probability of survival of an individual should depend on the value of the function of fitness.  Here, the value of the function of fitness is the distance of the edge, and the population is the share of the remaining cities not visited.  We simply choose only one ‚Äúindividual‚Äù from the whole population, i.e.  one vertex.  The formula for the probability of taking the next edge will be: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/297/861/0d4/2978610d45ee4fcd92e0b508b8a836d8.png"></div><br>  where <i>q</i> is the probability of making an alternative decision (not necessarily the shortest edge) <br>  <i>r</i> is a random number [0; 1] <br>  <i>N</i> - edges involved in the selection (sortable) <br><br>  Thus, we will form a set of "controlled" different routes to the input of the all_brute function.  The word controlled means the control of randomness of the route.  The more the <i>q</i> parameter tends to 1, just as the <i>N</i> tends to the total number of cities, the more random the search will be. <br><br><div class="spoiler">  <b class="spoiler_title">Route Build Function</b> <div class="spoiler_text"><pre> <code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">% (probability several route) % ,         % dist -   % tour_sev - -   % n - -  % tour_select - -   % check_routes -       % p_change -      %------------------------------------------------------------------------- function [arr_several_route] = psr(dist,tour_sev,n,tour_select,cr,p_change) %   () arr_several_route = zeros(tour_sev,n); parfor k = 1:tour_sev %   (   ) dist_temp = dist; %     route = zeros(1,n); %    (   ) next_point = randi([1,n]); %     route(1) = next_point; %  count_var = 0; %     for e = 2:n %     dist_temp(next_point,:) = nan; %  count_var = count_var + 1; %     if rand(1) &gt; p_change %      k-  %     [~,next_point] = min(dist_temp(:,next_point)); else %    %       () arr_next = 1./(dist_temp(:,next_point)); %        % ,   "habrahabr_vis"  habrahabr_vis = (1:1:n)'; %     arr_next = [arr_next, habrahabr_vis]; %      arr_next_sort = sortrows(arr_next,1); %   rand   if (n - count_var) &lt; tour_select tour_select_fun = (n - count_var); else tour_select_fun = tour_select; end %       P = arr_next_sort(1:tour_select_fun,:); P(:,1) = P(:,1)./sum(P(:,1)); randNumb = rand; next_point = P(find(cumsum(P) &gt;= randNumb, 1, 'first'),2); end %   route(e) = next_point; end %      1-  if cr == true route = check_tour(route); end %    ( ) arr_several_route(k,:) = route; end</span></span></code> </pre><br></div></div><br>  So, we look at the results on various tasks: <br><br>  <u>Exact solutions:</u> <br><br>  <b>Oliver30</b> task (30 vertices).  Global best way - 423.741 <br>  Parameters: the <i>number of created routes to enter - 500</i> <br>  <i>q = 0.03</i> <br>  <i>N = 10</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/web/98a/920/548/98a920548a0b4863a1f2970ae2585b54.png"></div><br>  Problem <b>Eil51</b> (51 vertices).  Global best way - 426 <br>  Parameters: the <i>number of routes created for entry - 2500</i> <br>  <i>q = 0.03</i> <br>  <i>N = 5</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/web/862/b2f/af4/862b2faf4105441bacb6b5e3dfec2b8f.png"></div><br>  Problem <b>Eil76</b> (76 vertices).  Global best way - 538 <br>  Parameters: the <i>number of generated routes to the entrance - 4000</i> <br>  <i>q = 0.03</i> <br>  <i>N = 10</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/web/114/4ea/9f2/1144ea9f28d3405e867a411a2327fdf8.png"></div><br>  Problem <b>Eil101</b> (101 vertices).  Global Best Way - 629 <br>  Parameters: the <i>number of routes created for entry - 2500</i> <br>  <i>q = 0.03</i> <br>  <i>N = 6</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/web/b29/000/bbf/b29000bbff724c8f9bf55147e5e67b5d.png"></div><br>  <b>Ch150</b> problem (150 vertices).  Global Best Way - 6528 <br>  Parameters: the <i>number of generated routes to the entrance - 40000</i> <br>  <i>q = 0.05</i> <br>  <i>N = 10</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/web/d87/33d/00d/d8733d00d42b46e581d0cd1350e340c5.png"></div><br>  The result was good.  Yes, this algorithm is much more efficient than heuristic algorithms, such as an annealing simulation method or a genetic algorithm.  But agree that the range of problem solving by the genetic algorithm is extremely wide, which cannot be said about this algorithm.  However, it was interesting to find out the result when mixing different algorithms. <br><br>  The main goal of this algorithm is to create an array of optimized routes, as well as their distance array.  In the next article, we, using this array, will combine the genetic and ant algorithms.  We enable computing on the GPU.  And we will aim at finding a global best path of 500, 1000 and 2000 vertices on a home PC in a very reasonable time.  Looking ahead to say that it is quite real. <br><br>  So, in this article we found the best paths found so far in various tasks.  The huge gap between the best found ever and the approximate solution.  If this algorithm finds approximate solutions, then the execution time of the algorithm will be 10 times lower. <br><br>  Below is the main code of the algorithm with comments (its functions were published above) <br><br><div class="spoiler">  <b class="spoiler_title">Main</b> <div class="spoiler_text"><pre> <code class="matlab hljs"><span class="hljs-comment"><span class="hljs-comment">% TSP() (   ) %------------------------------------------------------------------------% if exist('cities','var') == 1 clearvars -except cities n = length(cities(:,1)); else clearvars intvar = inputdlg({'- '}... ,'TSP',1); n = str2double(intvar(1)); if isnan(n) || n &lt; 0 msgbox '  ' return else cities = rand(n,2)*100; end end %     tic %---------------------------------------------------------------% %     (  x  y ) start_tour = 1; %    ,     %  (   ) check_routes = false; %        roulete_method = false; %   (- ) if roulete_method == true crrm = 1000; end %     "ts"   top_roulete_method = true; if top_roulete_method == true % -    " " ctrrm = 1000; %        ts = 10; %     p_change = 0.05; end %------------------------------------------------------------------% %     dist = zeros(n,n); %   () best_dist = inf; %      brute_edge arr_route_in = zeros(n,n); %  -  ( ) % b = 1; %------------------------------------------------------------------------% %   for i = 1:n for j = 1:n dist(i,j) = sqrt((cities(i,1) - cities(j,1))^2 + ... (cities(i,2) - cities(j,2))^2); end end %    dist = round(dist); %    returndist = 1./dist; %    (  ) start_route = linspace(1,n,n); %      if start_tour &gt; n || start_tour &lt; 1 start_tour = 1; end %       "start_tour" start_route(start_tour) = 1; start_route(1) = start_tour; %       %      % parfor -   parfor k = 1:n %   (   ) dist_temp = dist; %     route = zeros(1,n); %    next_point = start_route(k); %   route(1) = next_point; %     for e = 2:n %   dist_temp(next_point,:) = nan; %     [~,next_point] = min(dist_temp(:,next_point)); %   route(e) = next_point; end %        1-  if check_routes == true route = check_tour(route); end %   arr_route_in(k,:) = route; end %        ( ) %        if top_roulete_method == true arr_several = psr(dist,ctrrm,n,ts,check_routes,p_change); arr_route_in = [arr_route_in; arr_several]; end %      %        if roulete_method == true %   ,   [randRoute] = prr(returndist,crrm,n,check_routes); %     arr_route_in = [arr_route_in;randRoute]; end % %      % parfor r = 1:size(arr_route_in, 1); % temp_route = arr_route_in(r,:); % [~,numb_ix] = find(temp_route == 1); % if numb_ix ~= 1 % temp_route = [temp_route(numb_ix:end),temp_route(1:numb_ix-1)]; % elseif numb_ix == n % temp_route = fliplr(temp_route); % end % arr_route_in(r,:) = temp_route; % end %  ,    arr_route_in = unique(arr_route_in,'rows'); %------------------------------------------------------------------% %      () arr_tour_out = zeros(size(arr_route_in,1),n); %      () arr_result = zeros(size(arr_route_in,1),1); %------------------------------------------------------------------------% %    ( ) spdvar = size(arr_route_in, 1); parfor i = 1:spdvar % [tour, distance] = all_brute_first(dist,arr_route_in(i,:),n); [tour, distance] = all_brute_best(dist,arr_route_in(i,:),n); arr_tour_out(i,:) = tour; arr_result(i,1) = distance; end %     toc %    [best_length,best_indx] = min(arr_result); %     1-  best_route = arr_tour_out(best_indx,:); % %    % mean(arr_result) %-----------------------------------------------------------------% tsp_plot = figure(1); set(tsp_plot,'name','TSP','numbertitle','off'... ,'color','w','menubar','none') set(gcf,'position',[2391 410 476 409]); opt_tour(:,[1,2]) = cities(best_route,[1,2]); plot([opt_tour(:,1);opt_tour(1,1)],[opt_tour(:,2);opt_tour(1,2)],'-g.', ... 'linewidth',1.5) set(gca,'color','k') title(['TSP best distance = ',num2str(round(best_length,2))]) xlabel('cities'); ylabel('cities') %------------------------------------------------------------------------% fprintf('%s %d\n','  ',round(best_length)); clearvars -except cities arr_result arr_tour_out arr_route_in ... n best_length opt_tour dist openclose</span></span></code> </pre><br></div></div><br>  Thanks for attention.  Until new meetings. </div><p>Source: <a href="https://habr.com/ru/post/335016/">https://habr.com/ru/post/335016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335002/index.html">Lecture by Vladimir Iglovikov at machine training for Yandex</a></li>
<li><a href="../335006/index.html">[Archeology Live] Shameful talk about singletons</a></li>
<li><a href="../335008/index.html">We give the user of the application game currency using AdMob Rewarded Video</a></li>
<li><a href="../335010/index.html">[UPDATED + Comments] At first they steal, and when you win, they kill you</a></li>
<li><a href="../335012/index.html">SHA2017 CTF: Need More Traffic</a></li>
<li><a href="../335018/index.html">CDC + MSC USB Composite Device on STM32 HAL</a></li>
<li><a href="../335020/index.html">TDD React.js Applications</a></li>
<li><a href="../335022/index.html">MythBusters - Gentoo Linux</a></li>
<li><a href="../335026/index.html">Limitations of depth learning and the future</a></li>
<li><a href="../335028/index.html">Using Hotspot Helper Extension</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>