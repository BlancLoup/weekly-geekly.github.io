<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fads Stream API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stream - the mysterious world of functionalism, alien to the Old Believers in the world of object Java. At the same time, the world of lambdas is inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fads Stream API</h1><div class="post__text post__text-html js-mediator-article">  Stream - the mysterious world of functionalism, alien to the Old Believers in the world of object Java.  At the same time, the world of lambdas is interesting and alien, allowing you to sometimes do things with data sets that others who see this will want to burn you at the stake. <br><br>  Today we will talk about the Stream API and try to lift the veil of secrecy in the still unknown world.  Despite the fact that Java 8 was released a long time ago, not everyone uses the full range of its capabilities in their projects.  To open this Pandora's box and find out what actually hides inside such a mysterious phenomenon, the developer from JetBrains - Tagir <a href="https://habrahabr.ru/users/lany/" class="user_link">lany</a> Valeev, who has long studied this fantastic beast and its habitat far and wide (and just recently wrote <a href="https://habrahabr.ru/post/337350/"><b>another guide</b></a> about how , and how wrong it is to write streams), and even wrote his own library, StreamEx, to improve work with Java streams.  To whom it became interesting, we ask under kat! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1_Zj3gS_a3E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  <i>The material is based on the <a href="http://2016.jokerconf.com/talks/weird-stream-api/">report of</a> Tagir Valeev at the Joker conference, which was held in October 2016 in St. Petersburg.</i> <br><br>  About a couple of months before the report, I did a small poll on Twitter: <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="761107099845701632"></twitter-widget><script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><br>  Therefore, I will talk less about <i>Parallel Stream</i> .  But we still talk about them. <br><br>  In this report I will tell you about a certain number of quirks. <br><br><img src="https://habrastorage.org/web/a37/172/81a/a3717281a1c44734b0074f3ad6ea124f.png"><br><br>  Everyone knows that in Java, in addition to the Stream interface, there are several other interfaces: <br><br><ul><li>  Intstream <br></li><li>  Longstream <br></li><li>  Double stream <br></li></ul><br>  And, seemingly, a natural question arises: ‚ÄúWhy use them, what is the point in them?‚Äù <br><br><img src="https://habrastorage.org/web/1a2/e6d/42b/1a2e6d42b1bc417fb0d0ab0e3f98023d.png"><br><br>  The point is that it gives speed.  Primitive is always faster.  So, at least, it is specified in documentation on Stream. <br><br>  Let's check if a primitive Stream is really faster.  To begin, we need test data that we generate randomly using the same Stream API: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ ] ints; Integer[ ] integers; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(<span class="hljs-number"><span class="hljs-number">1</span></span>).ints(<span class="hljs-number"><span class="hljs-number">1000000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) .toArray(); integers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(<span class="hljs-number"><span class="hljs-number">1</span></span>).ints(<span class="hljs-number"><span class="hljs-number">1000000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) .boxed().toArray(Integer[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); }</code> </pre> <br><br>  Here we generate one million numbers ranging from 0 to 1000 (not including).  Then we assemble them into a primitive <i>ints</i> array, and then we pack them into an object array of <i>integers</i> .  In this case, the numbers we get are exactly the same, since we initialize the generator with the same number. <br><br>  Let's perform some operation on numbers - let's calculate how many unique numbers we have in both arrays: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Stream.of(integers).distinct().count(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(ints).distinct().count(); }</code> </pre> <br><br>  The result, of course, will be the same, but the question is which Stream will be faster and by how much.  We believe that the primitive Stream will be faster.  But in order not to guess, we will test and see what we have done: <br><br><img src="https://habrastorage.org/web/634/623/e49/634623e493684553b11a30319fae6c75.png"><br><br>  Hmm, primitive Stream, oddly enough, lost.  But if tests are run on Java 1.9, then the primitive will be faster, but still less than twice.  The question arises: "Why so, because they still promise that primitive Streams are faster?".  To understand this, you need to look at the source code.  For example, consider the distinct () method, and how it works in a primitive Stream.  Yes, everything seems to be understandable with this, but since Stream is an interface, naturally, there will be no implementation in it.  The whole implementation lies in the <i>java.util.stream</i> package, where in addition to the public packages there are many private packages in which, in fact, the implementation is located.  The main class that implements Stream is <i>ReferencePipeline</i> , which inherits <i>AbstractPipeline</i> .  The implementation for primitive Streams takes place accordingly: <br><br><img src="https://habrastorage.org/web/e4f/6fc/a0b/e4f6fca0bb994ec6bf504d4d7b422320.png"><br><br>  Therefore, we go to IntPipeline and look at the implementation of distinct (): <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// java.util.stream.IntPipeline</span></span></code> </pre> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> IntStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// While functional and quick to implement, // this approach is not very efficient. // An efficient version requires an // int-specific map/set implementation. return boxed().distinct().mapToInt(i -&gt; i); }</span></span></code> </pre> <br><br>  We see that the packaging of a primitive type occurs, the formation of a Stream call on it distinct'a, after which a primitive Stream is formed back. <br><br>  Accordingly, if we substitute it, we get that in the second case we have the same work and even more.  We take our stream of primitive numbers, package it, and then call <i>distinct ()</i> and <i>mapToInt ()</i> .  The <i>mapToInt</i> itself practically does not eat up anything, but the packaging requires memory.  In the first case, we have already been allocated memory in advance, since we already had objects, but in the second case, it needs to be allocated, and there the GC starts to work.  What we will see: <br><br><img src="https://habrastorage.org/web/22b/fee/c03/22bfeec03b1c427da82432c80d8f2b2d.png"><br><br>  In the first case, our test takes 48 kB of memory, which basically goes to support <i>HashSet</i> , which is used inside <i>distinct'a</i> to check the numbers that already exist.  In the second case, we have allocated significantly more memory, about 13 megabytes. <br><br>  But in general, I want to reassure you, this is the only exception to the rule.  In general, primitive streams behave much faster.  Why is this so done in the JDK - because in Java there are no specialized collections for primitives.  To implement <i>distinct ()</i> on primitive <i>int</i> , you need a collection for primitive types.  There are libraries that provide similar functionality: <br><br><ul><li>  <a href="https://habrahabr.ru/post/187234/">https://habrahabr.ru/post/187234/</a> <br></li><li>  <a href="https://github.com/leventov/Koloboke">https://github.com/leventov/Koloboke</a> <br></li><li>  <a href="https://github.com/vigna/fastutil">https://github.com/vigna/fastutil</a> <br></li></ul><br><br>  But this is not in the JDK, but if you implement a primitive <i>HashSet</i> for an <i>int</i> , then you need to do a <i>HashSet</i> for both <i>long</i> and <i>double</i> .  There are also parallel Streams, and parallel Streams are <i>ordered</i> and <i>unordered</i> .  In ordered there is a <i>LinkedHashSet</i> , and in unordered, a Concurrent is needed.  Therefore, you need to implement a bunch of code, and nobody simply began to write it.  Everyone hopes for a <i>Generic</i> specialization, which will probably be released in the tenth Java. <br><br>  Let's look at another fad. <br><br><img src="https://habrastorage.org/web/72b/f6e/f4b/72bf6ef4b1f44b01b2fc7118f34bd478.png"><br><br>  Continue to play with random numbers and take a million numbers.  The range will be larger - from 0 to 50,000 (not including), so that numbers rarely repeat.  We sort them in advance and put them into a primitive array: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(<span class="hljs-number"><span class="hljs-number">1</span></span>).ints(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50_000</span></span>) .sorted().toArray(); }</code> </pre><br>  Then, using distinct'a, we calculate the sum of unique numbers: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).distinct().sum(); }</code> </pre> <br><br>  This is the most trivial implementation, it works and correctly calculates the result.  But we want to come up with something faster.  I offer you some more options: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).distinct().sum(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortedDistinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).sorted().distinct().sum(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boxedSortedDistinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).boxed().sorted().distinct() .mapToInt(x -&gt; x).sum(); }</code> </pre><br>  In the second variant, we will once again sort out before <i>distinct ()</i> , and in the third variant, we will also pack, then sort, perform <i>distinct ()</i> and result in a primitive array and then sum it up. <br><br>  The question arises: ‚ÄúWhy sort?  With us, everything was sorted.  Then the result of the sum does not depend on the sorting ‚Äù. <br><br>  Then, based on common sense, we can assume that the first option will be the fastest, the second slower, and the third - the longest. <br><br>  However, we can recall that <i>distinct ()</i> does the packing, and then leads to a primitive type, so the examples described above can be represented as follows: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).boxed().distinct() .mapToInt(x -&gt; x).sum(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortedDistinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).sorted().boxed().distinct() .mapToInt(x -&gt; x).sum(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boxedSortedDistinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).boxed().sorted().distinct() .mapToInt(x -&gt; x).sum(); }</code> </pre> <br><br>  The examples are now more similar to each other, but in any case we do the packaging as an extra job.  Now let's see the results: <br><br><img src="https://habrastorage.org/web/dfd/7a8/750/dfd7a87505f148a991796f5b69e456a2.png"><br><br>  The second option, as expected, is slower, but the last option, oddly enough, works the fastest.  Mysterious behavior, is not it? <br><br>  In general, several factors can be identified at once.  First, sorting in Java works quickly if the data is already sorted.  That is, if she saw that the numbers are going in the correct order, then she immediately leaves.  Therefore, sorting sorted fairly cheap.  However, the operation <i>sorted ()</i> in Stream'e adds a characteristic that it is already sorted.  We initially array was already ordered, but Stream does not know about it.  Only we know about this.  Therefore, when <i>distinct ()</i> sees a sorted Stream, it includes a more efficient algorithm.  He no longer collects <i>HashSet</i> and looks for the presence of duplicate numbers, but simply compares each successive number with the previous one.  That is, theoretically, sorting can help us if we already have the input data sorted.  Then it is not clear why the second test is slower than the third.  To understand this, you need to look at the implementation of the <i>boxed ()</i> method: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// java.util.stream.IntPipeline @Override public final Stream&lt;Integer&gt; boxed() { return mapToObj(Integer::&lt;i&gt;valueOf&lt;/i&gt;); }</span></span></code> </pre> <br><br>  And if we substitute it in the code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).mapToObj(Integer::valueOf) .distinct().mapToInt(x -&gt; x).sum(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortedDistinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).sorted().mapToObj(Integer::valueOf) .distinct().mapToInt(x -&gt; x).sum(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boxedSortedDistinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(data).mapToObj(Integer::valueOf).sorted() .distinct().mapToInt(x -&gt; x).sum(); }</code> </pre> <br><br>  And <i>mapToObj ()</i> removes the characteristic that the Stream is sorted.  And in the third case, we sort the objects and help <i>distinct ()</i> , which then starts to work faster.  And if <i>mapToObj ()</i> comes <i>across</i> between them, then it makes this sorting senseless. <br><br>  It seemed strange to me.  You can write <i>boxed () a</i> little longer and keep the Stream sorting characteristic.  Therefore, I introduced a patch in Java 1.9: <br><br><img src="https://habrastorage.org/web/a7b/89e/603/a7b89e603acb4c9bbfa44e64be0acb25.png"><br><br>  As we can see, after applying the patch, the results are much more interesting.  The second option now wins, because it sorts on primitives.  The third option now loses a little bit to the second one, because we sort the objects, but it still outperforms the first option. <br><br>  By the way, I would like to note that when performing tests in version 9, I used the ‚ÄìXX: + UseParallelGC option, since in version 8 it is by default, and in 9 it is by default G1.  If we remove this option, the results are significantly different: <br><br><img src="https://habrastorage.org/web/5d2/2e5/c36/5d22e5c365074e34ae8f976e83ceffee.png"><br><br>  Therefore, I would like to warn you that when upgrading to version 9, something may begin to work more slowly for you. <br><br>  Let's move on to the next fad. <br><br><img src="https://habrastorage.org/web/211/6c9/30c/2116c930cc134a0a919e68b8e8878ca5.png"><br><br>  Perform the following task.  To perform it, we will use icosahedra.  An icosahedron is such a regular convex polyhedron having 20 faces. <br><br><img src="https://habrastorage.org/web/d7d/5ec/651/d7d5ec6512124c9c993b66e9059da88f.png"><br><br>  We do this using the Stream API: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IntStream ints(long streamSize, int origin, int bound) new Random().ints(5, 1, 20+1).sum();</span></span></code> </pre> <br><br>  We set the parameters and sum the values ‚Äã‚Äãobtained.  With this approach, the result may not be entirely correct.  We need the sum of five <i>pseudo-random</i> numbers.  And it may happen that we get a repeat: <br><br><img src="https://habrastorage.org/web/2b2/0ff/a88/2b20ffa88d74432397cdf39fc7521828.png"><br><br>  If you add <i>distinct ()</i> , this will not help either, since it just throws out a repetition, we will already have a sum of 4 numbers or even less: <br><br><img src="https://habrastorage.org/web/b69/d2b/8a2/b69d2b8a21ec45ab88534a91fb4e530a.png"><br><br>  It remains for us to take the version a bit longer: <br><br><img src="https://habrastorage.org/web/9c6/130/58a/9c613058a1c74eec9815d097342a585c.png"><br><br>  We will take <i>ints ()</i> and now we will not specify the number of numbers we need, but simply indicate that we need the numbers generated in a certain way.  We will have an infinite Stream in which <i>distinct ()</i> will check the numbers for repetition, and <i>limit ()</i> after receiving 5 numbers will stop the execution of the generation of numbers. <br><br>  Now let's try to parallelize this task.  This is not easy, but very simple: <br><br><img src="https://habrastorage.org/web/2c6/982/84a/2c698284aa0b4facb2689f99ee750933.png"><br><br>  Enough to add <i>parallel ()</i> and you will have a parallel Stream.  All of the above examples will compile.  Do you think there is a difference between the above examples?  We can assume that the difference will be.  If you think so, then it is not your fault, because the documentation about this is badly said, and, indeed, a lot of people think the same way.  However, in reality there is no difference.  The entire Stream has a certain data structure, in which there is a Boolean variable that describes it as parallel or normal.  And where would you not write <i>parallel ()</i> before executing the Stream, it will set this special variable to true and after that the terminal operation will use it in the value in which this variable was. <br><br>  In particular, if you write like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().ints(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>).parallel().distinct().limit(<span class="hljs-number"><span class="hljs-number">5</span></span>) .sequential().sum();</code> </pre> <br><br>  You might think that only <i>distinct ()</i> and limit () are executed in parallel, and sum () is sequential.  Actually, no, since <i>sequential ()</i> will clear the checkbox and the entire Stream will be executed sequentially. <br><br>  In the ninth version of the documentation was improved so as not to mislead people.  For this, a separate ticket was opened: <br><br><img src="https://habrastorage.org/web/798/658/aac/798658aac6034fffaa03f97fb1c10a25.png"><br><br>  Let's see how long the serial Stream will run: <br><br><img src="https://habrastorage.org/web/d9c/625/a6d/d9c625a6d1fc429fadead0e34317ac7e.png"><br><br>  As we can see, the execution happens very quickly - 286 nanoseconds. <br><br>  To be honest, I doubt that parallelization will be faster.  Big costs - create tasks, scatter them across processors.  It should be longer than 200 nanoseconds - too much overhead. <br><br>  How do you think, how many times longer will a parallel Stream run?  10 times, 20 or very long down to infinity?  From a practical point of view, the latter will be right, since the test will be performed for about 6,000 years: <br><br><img src="https://habrastorage.org/web/e35/0a8/9e1/e350a89e10bb47e49067755437130ca8.png"><br><br>  It is possible that the test will run on your computer for a couple of thousand years more or less.  To understand the reason for this behavior, you need to dig a little.  It's all about the fancy operation <i>limit ()</i> , which has several implementations.  Because it works differently depending on the sequence or parallelism and other flags.  In this case, <i>java.util.stream.StreamSpliterators.UnorizedSliceSpliterators &lt;T, T_SPLIT&gt;</i> works for us.  I will not show you the code, but I will try to explain as simply as possible. <br><br>  Why unordered?  Because the source of random numbers indicates that the Stream is not ordered.  Therefore, if we change the order when parallelizing, no one will notice anything.  And it seemed easy to implement the unordered limit - add an atomic variable to it and increment it.  Increased, and the limit has not yet been reached - we ask the <i>distinct ()</i> to give us another number and pass it to the adder.  As soon as the atomic variable becomes equal to 5, we stop the calculations. <br><br>  This implementation would work if it were not for the JDK developers.  They decided that in such an implementation there would be too much contention due to the fact that all the threads use the same atomic variable.  Therefore, they decided to take not one number, but 128. That is, each of the threads increases the atomic variable by 128 and takes 128 numbers from the parent source, but the counter does not update anymore, and only after 128 does the update occur.  This is a smart decision if you have a limit there, for example, 10,000. But it is incredibly stupid if you have such a small limit.  After all, it is known in advance that more than 5 is not required.  We will not be able to take 128 numbers from this source.  We take the first 20 numbers normally, and at 21 we will ask the <i>distinct ()</i> to give us another number.  He tries to get it from the "cube", he gives it.  For example, <i>distinct ()</i> gets the number 10. ‚ÄúAnd it already was,‚Äù says distinct () and asks for more.  He gets the number 3, and he already had it too.  And no one will stop this process, since <i>distinct ()</i> has already seen all faces of our cube, and it does not know that the cube is over.  This should be happening indefinitely, but if you look at the <i>ints</i> () documentation, then Stream is not infinite, it is effectively unlimited.  It specifically <i>contains Long.MAX_VALUE</i> elements and at some point it will end: <br><br><img src="https://habrastorage.org/web/d28/785/bd7/d28785bd7e994d46bd95bd23d6d814b6.png"><br><br>  It seemed strange to me, I fixed this problem in version 9: <br><br><img src="https://habrastorage.org/web/b36/dc9/540/b36dc9540b3e4d33b129ea23d7276c24.png"><br><br>  Accordingly, we get a failure in performance, which is quite adequate - approximately 20-25 times.  But I want to warn you that even though I fixed this problem for a specific example, this does not mean that it was fixed at all.  This was a performance problem, not a problem with the correct implementation of Stream. <br><br>  The documentation never states that if you have <i>limit (5)</i> , then you will have exactly 5 numbers read from the source.  If you have <i>findFirst</i> , it does not mean that you will have one number read - it can be read as much as you like.  Therefore you need to be careful with the endless stream.  Because if we take not 5, but 18 numbers as a limit, we can again face the same problem.  Since 18 numbers have already been read, and the other 3 parallel threads will also be asked for one more, and we will already push in 21. Therefore, you should not parallelize such operations.  With parallel Stream it is clear - if you have a short-circuited operation, it deducts much more than you think. <br><br><img src="https://habrastorage.org/web/64a/1ad/f00/64a1adf00f8b4d62a0b7b1c9818fd3df.png"><br><br>  With consecutive Stream there is a fad on this example: <br><br><img src="https://habrastorage.org/web/68a/375/768/68a37576894b465fa4aa6776143d7315.png"><br><br>  The example may be a little artificial, but in some algorithm it may appear.  We want to bypass the array of integers, but to circumvent it in a clever way.  Let's start with 0 element, and the value in this element is the index of the next element that we want to take.  Since we want to work around it using the Stream API, we find the Stream.iterate () method, which would seem to be created for our task: <br><br><img src="https://habrastorage.org/web/106/ee5/5ba/106ee55baabb4cb6b9153f7a642c0d9c.png"><br><br>  The first element of the Stream is the index in our array, and the second will be the increment function, i.e.  function, which from the previous element does the following.  In our case, we use the element as an index.  But since the first element of 0 is the index and we do not need it, we skip it with <i>skip (1)</i> .  Then we limit the Stream to the length of the array and display on the screen or do something else, another algorithm, for example, with us. <br><br>  Everything works correctly, and there is no trick.  But since we have integers here, why not use <i>IntStream</i> ?  In this interface, we have an iterate and all other operations.  We write <i>IntStream</i> , we get: <br><br><pre> <code class="java hljs">Exception in thread <span class="hljs-string"><span class="hljs-string">"main"</span></span> java.lang.ArrayIndexOutOfBoundsException at test.Iterate.lambda$<span class="hljs-number"><span class="hljs-number">0</span></span>(Iterate.java:<span class="hljs-number"><span class="hljs-number">9</span></span>) at test.Iterate$$Lambda$<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">424058530</span></span>.applyAsInt(Unknown Source) at java.util.stream.IntStream$<span class="hljs-number"><span class="hljs-number">1</span></span>.nextInt(IntStream.java:<span class="hljs-number"><span class="hljs-number">754</span></span>) ‚Ä¶ at test.Iterate.main(Iterate.java:<span class="hljs-number"><span class="hljs-number">12</span></span>)</code> </pre><br><br>  The thing is that this is a part of the implementation of <i>IntStream.iterate ()</i> , while <i>Stream.iterate ()</i> does not have this part.  Each time you get a number, the following is immediately requested.  It is stored in a variable, and the previous number is given to you.  Therefore, when we try to get -1, an attempt is made to get the value of the array with the index -1 at the source, which leads to an error.  It seemed strange to me, and I fixed it: <br><br><img src="https://habrastorage.org/web/cc0/340/657/cc0340657aa94e5f97a30ec70f81bbee.png"><br><br>  But this is just a strangeness of implementation, and this cannot be called a bug, since the behavior corresponds to the specification. <br><br><img src="https://habrastorage.org/web/a81/f54/19c/a81f5419c2494a72b66163447fc77744.png"><br><br>  Stream really love it for this: <br><br><pre> <code class="java hljs">Map&lt;String, String&gt; userPasswords = Files.lines(Paths.get(<span class="hljs-string"><span class="hljs-string">"/etc/passwd"</span></span>)) .map(str -&gt; str.split(<span class="hljs-string"><span class="hljs-string">":"</span></span>)) .collect(toMap(arr -&gt; arr[<span class="hljs-number"><span class="hljs-number">0</span></span>], arr -&gt; arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br><br>  You can take a file and use it as a source.  Turn it into a Stream of strings, turn it into arrays, promapit and so on.  Everything is beautiful, everything is so in one line - everything is fluent here: <br><br><img src="https://habrastorage.org/web/ae8/2f7/f9e/ae82f7f9e6274b7db9a764c255507e8a.png"><br><br>  But do not you think that something is missing in this code?  Maybe <i>try-catch</i> ?  Almost, but not quite.  Not enough <i>try-with-resources</i> .  It is necessary to close the files, otherwise you may run out of file descriptors, and under Windows even worse, with this you will not do anything later. <br><br>  In fact, the code should already look like this: <br><br><img src="https://habrastorage.org/web/db4/86b/199/db486b199daf4ad19f86e63b27aad123.png"><br><br>  And now everything is not so rosy.  It was necessary to insert try, and for this purpose to get a separate variable.  This is the recommended way of writing code, that is, I did not invent it.  Any Stream document says you should do this. <br><br>  Naturally, some people do not like it and they are trying to fix it.  Here, for example, Lukas Eder tried to do this.  A wonderful person and he offers just such an idea.  He laid out his thought for discussion on StackOverfow - <a href="http://stackoverflow.com/questions/34753078/">as a question</a> .  It's all strange, we know when Stream is finished working - it has a terminal operation, and after calling it, it is definitely not needed.  So let us close it. <br><br>  Stream is an interface, we can take it and implement it.  Make a delegate to the Stream, which the JDK issues to us, and redefine all terminal operations - call the original terminal operation and close the Stream. <br><br>  Will this approach work and correctly close all files?  Consider a list of all terminal operations - they are divided into 2 groups: I called one ‚ÄúNormal‚Äù operations (with internal bypass), and another (once we have quirks) ‚ÄúFancy‚Äù (with external bypass): <br><br><img src="https://habrastorage.org/web/3d3/8dd/5c3/3d38dd5c399b4b0da4352f68d9206241.png"><br><br>  ‚ÄúFancy‚Äù operations spoil the whole picture.  Imagine that you made a Stream lines of the file and want to transfer it to the old API, which with Stream does not know anything, but knows about the iterators.  Naturally, we take an iterator from this Stream, but nobody wants the entire file to be loaded into memory.  We want it to work "lazily", Streams are lazy.  That is, in fact, the terminal operation has already been called, but the open file is still needed.  After this, the iterator contract does not imply that this iterator needs to be closed or said that it is not needed after that. <br><br>  You can call <i>iterator.next ()</i> once and then throw it.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, when the iterator is returned, you will never know that the file is not needed. It turns out that the problem is not solved. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spliterator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the same, only a side view. It also has a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, which includes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasNext ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> together </font><font style="vertical-align: inherit;">and we can say about it that it is an iterator on steroids. But there is absolutely the same problem with it - you can throw it in an unknown state and in no way say that the file is actually time to close. If you did not use it in your code, then perhaps you called it implicitly. For example, here is such a construction:</font></font><br><br><img src="https://habrastorage.org/web/1a3/b1f/cfb/1a3b1fcfba114268b21e79e48c209c62.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, it seems, the legal construction is the union of two Stream together. </font><font style="vertical-align: inherit;">But after that, any short-circuited operation will have the same effect - you have an abandoned iterator in an unknown state. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, I began to think how to make the Stream shut down automatically. </font><font style="vertical-align: inherit;">In fact, there is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for this </font><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/web/dca/a60/8ec/dcaa608ec17c4a37a6356894c94c5259.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take the documentation, and it says that this is a method. </font><font style="vertical-align: inherit;">It takes a function, and every element you turn into a Stream. </font><font style="vertical-align: inherit;">There is also a wonderful note that every created Stream will be closed after its content is transferred to the current Stream. </font><font style="vertical-align: inherit;">That is, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> promises us that the Stream will be closed. </font><font style="vertical-align: inherit;">So he can do everything for us, we do not need to do everything with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try-with-resources</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's then write this:</font></font><br><br><pre> <code class="java hljs">Map&lt;String, String&gt; userPasswords = Stream.of(Files.lines(Paths.get(<span class="hljs-string"><span class="hljs-string">"/etc/passwd"</span></span>))) .flatMap(s -&gt; s) .map(str -&gt; str.split(<span class="hljs-string"><span class="hljs-string">":"</span></span>)) .collect(toMap(arr -&gt; arr[<span class="hljs-number"><span class="hljs-number">0</span></span>], arr -&gt; arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream.of (Files.lines (...))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - leads to the formation of a Stream consisting of one Stream. Then we called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and again got one Stream. But now </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> guarantees that the Stream will be closed. Then we have everything exactly the same and we should get the same result. In this case, the file should automatically close without any </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and additional variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you think this is generally an excellent solution, in which there are no problems with performance and everything will be closed correctly? Yes, there is no trick and everything will work. This is a good solution in terms of performance, and the file will be closed normally. Even if we do not have ‚Äú:‚Äù in some line and arr [1] will cause</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArrayIndexOutOfBoundsException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and everything will fall with the exception, the file will close anyway, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> guarantees this. But let's see what price it does. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the report at the JPoint, I said that if we make </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Stream </font><font style="vertical-align: inherit;">, then the resulting Stream we get a bit spoiled. </font></font><br><br><img src="https://habrastorage.org/web/782/e7d/393/782e7d393b3c4f43a6278790d22aad40.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, the short-circuiting inside the Stream is lost, that is, inside the nested Stream we cannot make a short circuit, even if there is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limit ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font><i><font style="vertical-align: inherit;">findFirst ()</font></i><font style="vertical-align: inherit;"> written there</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- all nested Stream will still be read. And this is actually a very important part of the implementation of Stream, and it is very unpleasant. You should know about it when you use Stream (serial or parallel). That is, if you have a </font><font style="vertical-align: inherit;">short-circuited operation </font><font style="vertical-align: inherit;">after </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then get ready for the fact that you have the last and necessary Stream that issued </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be read to the end. And this can lead to performance problems in your code. And the saddest thing is that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> behaves badly at all: </font></font><br><br><img src="https://habrastorage.org/web/2a9/3bb/f6c/2a93bbf6c46b4477894bd609ead5555d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I had such a case. I made a Stream from a single element and used </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on a Stream of 1,000,000,000 elements. And then I took from Stream </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spliterator ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - I wanted to display the first Stream element. It all ended sadly - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OutOfMemoryError</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When only I did </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the entire nested Stream was loaded into the buffer - as a result, the RAM ran out. I talked more about this at the JPoint, you can see. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This shows us in particular what will happen:</font></font><br><br><pre> <code class="java hljs">Files.lines(Paths.get&lt;(<span class="hljs-string"><span class="hljs-string">"/etc/passwd"</span></span>)) .spliterator().tryAdvance(...); <span class="hljs-comment"><span class="hljs-comment">//   ,    Stream.of(Files.lines(Paths.get("/etc/passwd"))) .flatMap(s -&gt; s) .spliterator().tryAdvance(...); //     ,  </span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first case, if we call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spliterator (). TryAdvance (),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the simple Stream will have one line read and the file will not be closed. Actually, a little more can be read, we have </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BufferedReader</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there </font><font style="vertical-align: inherit;">. But the buffer size does not depend on the length of the file, that's what's important. Even if we have a gigabyte file there, we can bypass it with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and our memory will not run out. But in the second case, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> promises us that the file will be closed, but it does not know when we will drop the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spliterator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and in what condition. Therefore, it reads the entire file into memory and the file closes. That is, he guarantees us the closure of the file. This fact has an interesting side effect - many people do not like this behavior.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , they do not like that it could potentially put everything in the buffer. They believe that this can be fixed, you can write a good </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There are even </font></font><a href="http://stackoverflow.com/a/32767282/4856258"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (unbuffered </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). It is not written in JDK, but outside. It must be called as a static method, but after that it will make a short circuit in the nested Stream, and if you call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spliterator (). TryAdvance (),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there will be no buffering. Everything will be great. So why don't the JDK developers add this implementation? Because this implementation does not guarantee that all of your nested Stream will be closed. And in the specification it is written that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flatMap () is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> guaranteed to close the Stream.</font></font><br><br><img src="https://habrastorage.org/web/706/a4a/bc3/706a4abc38ee47f0acfd2cb5d825cfef.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everyone loves short-circuited operations. Why do they love them? They can get results before all the input data is read. In particular, they can get the result on an infinite Stream, that is, we have an infinite number of input data, but we can still know the result. But what happens if the short circuit does not work or does work at the very end? Let's try to explore this case. </font></font><br><br><img src="https://habrastorage.org/web/8c3/27d/111/8c327d111a84418194e9becf3c8eac7a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take the numbers from 0 to 1 000 000. In the first case, we count the number of occurrences of the number 1 000 000 in this series, and in the second we simply find this number 1 000 000. With the help of Stream, this is done rather trivially:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a01/f8a/9ed/a01f8a9ed12f29b7058fb91a23e726af.png"><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).boxed() .filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).count(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).boxed() .filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).findAny(); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rangeClosed ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , create a range of integers. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boxed ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I added specifically to make it look like on the next slides, it does not affect the output. It will just be easier for me to compare the results later. Conclusions and primitive Stream will be the same. Then we make filters that are exactly the same, and at the end we perform the operation - either </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">count ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findAny ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Either find an arbitrary number, or count. What do you think, which of the operations will be faster? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In both cases, we have to loop through the numbers from 0 to 1,000,000, in both cases we will have some kind of verification, the verification is absolutely the same. In both cases, it will work once and at the same moment. Even if we remember that there is a processor</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">branch predictor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc., it should still work out equally. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And only at this very last moment will there be a slight difference. We either add one to some variable (which is fast), or we somehow get out of this cycle (which is also fast). That is, we really should have close performance. However, if we measure this, we will see: </font></font><br><br><img src="https://habrastorage.org/web/8d0/1af/33f/8d01af33fa7e480ab5279a2744b577cc.png"><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FindAny ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loses, and significantly - by 25%. These results are stable, so this is a significant difference. Well, you might think that no one uses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntStream.rangeClosed ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and this is a rare source. The most common source is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArrayList</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Let's make it from the same numbers, pack them and perform the same operations:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ list = IntStream.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).boxed() .collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.stream().filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).count(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.stream().filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).findAny(); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, we have faster results, mainly because we don‚Äôt need to pack numbers (everything was packed in advance): </font></font><br><br><img src="https://habrastorage.org/web/c6c/467/077/c6c467077b384dd2a061853540683616.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The difference is even more tangible. The short-circuited operation loses already by 65%. This is why this happens. Not a short-circuited operation, when you know in advance that you need to bypass the entire Stream, bypasses it through </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEachRemaining,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which immediately knows that you need to go through the entire source and should not stop anywhere. A short-circuited operation </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iterates</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> over one number through </font><i><font style="vertical-align: inherit;">tryAdvance () ‚Äîthat</font></i><font style="vertical-align: inherit;"> is, calls </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , received one number, caused another </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> received another number. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the fact is that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEachRemaining</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spliterator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be implemented more efficiently. For example, the state can be stored in local variables (how many numbers you have bypassed and how many are left), and in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> after each call you need to save to the state fields so that the next time you call, you know where you are standing. Working with a heap is always, naturally, more expensive and therefore the JIT compiler cannot splarter the spliterator, therefore slowing down occurs. In the case of a list, the situation is even worse, since you have to constantly check </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modCount ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so that if someone from another thread makes a change, you can throw </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConcurrentModificationExceptions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In the case of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEachRemaining, </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modCount () is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> checked at the end. And in the case of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need to check it with every call. We do not know how much we will call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tryAdvance ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> again </font><font style="vertical-align: inherit;">. So this is still overhead. Therefore, to bypass the entire Stream is much faster than if you bypass it one by one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And one more problem, which we said that short-circuited operations do not work in the nested Stream:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAny1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) .boxed().filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">0</span></span>).findAny(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAny1Flat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.of(<span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).flatMap(x -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, x)) .boxed().filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">0</span></span>).findAny(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we want to find the first element from 1,000,000, we get: </font></font><br><br><img src="https://habrastorage.org/web/19f/1ff/181/19f1ff1814004805a409b8f3f62c7daa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first test will work in 83 nanoseconds, it is very fast. And in the second test, where all the elements were from the nested Stream, the entire nested Stream will be bypassed to the end, despite the fact that we found the right element at the very beginning. We lost 54,000 times and can lose any number of times, depending on how many elements we have. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We conclude: </font></font><br><br><img src="https://habrastorage.org/web/331/c03/c4c/331c03c4c9c44908afedbc20439cc6c0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question arises, how to fix this thing. There is, for example, a quick </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEachRemaining,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that is, to somehow call this ‚Äúquick‚Äù - first we say that we will bypass all the elements, but at some specific moment we understand that we don‚Äôt need to go further. We somehow </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEach</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we say we have to go out. </font><font style="vertical-align: inherit;">But as we can say, we are inside the lambda, and the lambda is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it cannot return anything. </font><font style="vertical-align: inherit;">If we exit, we will be immediately launched for the next item. </font><font style="vertical-align: inherit;">So is there any way to jump out of this </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEachRemaining</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Generate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ea3/a34/fa2/ea3a34fa206c4ace8b560bb9e9476e44.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You cannot use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for Control Flow, the same anti-pattern ( </font></font><a href="http://c2.com/cgi/wiki%3FDontUseExceptionsForFlowControl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/657/30b/c7c/65730bc7c2664d3dbcfa3fbe397028ef.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everyone says so ... or is it still possible? </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/135/f2f/7a3/135f2f7a38e64fa5b66a4ab8baef488b.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's try - we write this code: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FoundException</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimeException</span></span></span><span class="hljs-class"> </span></span>{ Object payload; FoundException(Object payload) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.payload = payload; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Optional&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fastFindAny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;T&gt; stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { stream.forEach(x -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FoundException(x); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.empty(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FoundException fe) { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>({ <span class="hljs-string"><span class="hljs-string">"unchecked"</span></span> }) T val = (T) fe.payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.of(val); } }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's create our own exception, moreover, derived from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RuntimeException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because </font><font style="vertical-align: inherit;">we cannot throw a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checked</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exception. After we write a quick search - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fastFindAny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). Naturally, we cannot add to the Stream interface so quickly - we will make a static method that Stream accepts. And in it we will do such a thing - let's go round it all, through </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEach</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Naturally, there will be used a quick </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEachRemaining</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But as soon as we are called once, we </font><font style="vertical-align: inherit;">throw </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Then we carefully catch it, because it is private, no one else can throw it, unpack the found element from it and return it calmly. If </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it didn‚Äôt fly out, it means we didn‚Äôt find the item - just return an empty </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optinal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is this a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solution and can it replace the standard </font><i><font style="vertical-align: inherit;">findAny ()</font></i><font style="vertical-align: inherit;"> ? Or is it a terrible decision - do your eyes bleed at the sight of it? Personally, I think this is a terrible code and a cool solution in both cases. This method is correct, it gives the result, if it finds something, or it does not give anything otherwise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In tests, we take the usual </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findAny ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and ‚Äúfast‚Äù </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fastFindAny ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).boxed() .filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>).findAny(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fastFindAny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fastFindAny(IntStream.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>) .boxed().filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1_000_000</span></span>)); }</code> </pre> <br><br><img src="https://habrastorage.org/web/64f/0af/f3b/64f0aff3b3fb4abb91e0fb8120e076e1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we notice that the ‚Äúfast‚Äù starts working as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">count ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , that is, we do not observe this dip by 25-65%. Now let's </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if we </font><i><font style="vertical-align: inherit;">succeeded</font></i><font style="vertical-align: inherit;"> in </font><i><font style="vertical-align: inherit;">flatMap ()</font></i><font style="vertical-align: inherit;"> - to get out of the nested Stream: </font></font><br><br><img src="https://habrastorage.org/web/599/bb6/0a2/599bb60a22fb42d79e6eb95099fb7650.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, we did. It was 4,000 microseconds, and it was 2 microseconds. But we are seeing an unpleasant moment - for a simple Stream ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntStream.rangeClosed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) we found the first number and left. But we lost 20 times in performance. And why have lost - because </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used. Some may know that someone read or went to the reports of Andrei Pangin - the hardest thing in Exception is not to throw it, but to create it. And do not even create and fill Stack Trace. Because when </font><i><font style="vertical-align: inherit;">Exception</font></i><font style="vertical-align: inherit;"> occurs</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can get </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Trace</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the time of its creation. At the same time, when we create it, we do not know if it will be useful in the future and the JDK will fill it up. Fortunately, there is a solution: </font></font><br><br><img src="https://habrastorage.org/web/be2/ce7/a93/be2ce7a93be84ef1ae80554528900582.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a special </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">protected Constructor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in some exceptions, including a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RuntimeException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where you can specify with the last parameter that </font><font style="vertical-align: inherit;">we do not need </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Trace</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Therefore, we can do a little optimization:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FoundException</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimeException</span></span></span><span class="hljs-class"> </span></span>{ Object payload; FoundException(Object payload) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;&lt;&lt; this.payload = payload; } }</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take our </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FoundException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and use this great constructor. </font><font style="vertical-align: inherit;">Then we will get another performance boost: </font></font><br><br><img src="https://habrastorage.org/web/66f/984/2eb/66f9842ebfcf4e3facb2894de9939738.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, we get a small loss due to the generation of the exception - 200-300 nanoseconds. </font><font style="vertical-align: inherit;">If for you this small overhead is not an obstacle, and you are ready to put up with it, then this may be a good solution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we forgot about parallel Stream. </font><font style="vertical-align: inherit;">Although it would seem, what about them?</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAnyPar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100_000_000</span></span>).parallel().boxed() .filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">10_000_000</span></span>).findAny(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fastFindAnyPar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fastFindAny(IntStream.&lt;i&gt;range&lt;/i&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100_000_000</span></span>) .parallel().boxed().filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">10_000_000</span></span>)); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forEach</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it also works in a parallel Stream. </font><font style="vertical-align: inherit;">Throw an exception and everything should end. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run Benchmark and look at the results. </font><font style="vertical-align: inherit;">I took a 4-core machine without an HT and received: </font></font><br><br><img src="https://habrastorage.org/web/9ce/222/8b6/9ce2228b66444cbd8b38e2b2c40c46d9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out very unpleasantly that our fast implementation - it loses one and a half times the standard implementation.</font></font> What is the reason?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I think Duke is tired and he got confused in these parallel streams: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/6da/a84/e13/6daa84e13cd340fc9f40dcd64b31e6d7.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> He needs to get some sleep: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2a7/ab7/eb1/2a7ab7eb18e84df180a8e6085e3f1932.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's let him sleep: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"20"</span></span>, <span class="hljs-string"><span class="hljs-string">"40"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sleep; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span>(Level.Invocation) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ Thread.sleep(sleep); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add this setup method before each test - it will sleep or will not sleep. </font><font style="vertical-align: inherit;">And after that we see that it helps: </font></font><br><br><img src="https://habrastorage.org/web/14e/190/d89/14e190d89c8647f1b8fe793c5ed93b83.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We see that if we slept a little bit, it became better, we slept even more - it became even better. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have not guessed what is happening, you can do this simple test:</font></font><br><br><pre> <code class="java hljs">AtomicInteger i = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicInteger(); Optional&lt;Integer&gt; result = fastFindAny( IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100_000_000</span></span>).parallel() .boxed().peek(e -&gt; i.incrementAndGet()) .filter(x -&gt; x == <span class="hljs-number"><span class="hljs-number">10_000_000</span></span>)); System.out.println(i); System.out.println(result); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); System.out.println(i);</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, we use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peek ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, which is recommended in the documentation for debugging. Every time we iterate through a number, we will increment the variable by 1 to see how many numbers we‚Äôve actually touched. Let's output this counter, then we will sleep and again we will display. We get the result is different, but about this: </font></font><br><br><img src="https://habrastorage.org/web/99b/f64/116/99bf64116c2f4fe2953a5a898bdaf035.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, 20 000 000 numbers, and then after a second it turned out 50 000 000 numbers. That is, if you throw an exception from a parallel Stream, then you complete the task that threw it. The remaining tasks continue to work - nobody has told them that they need to be completed. I discussed this problem in Core-Libs-Dev, with Paul Anders and Doug Lee - the bug was brought to this case:</font></font><br><br><img src="https://habrastorage.org/web/3ab/f00/d1e/3abf00d1e5504bef8ec0a8bd82521537.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They agreed that this is not a feature of behavior, but a bug. </font><font style="vertical-align: inherit;">But, in version 9 it will definitely not be fixed. </font><font style="vertical-align: inherit;">Therefore, if you use parallel Stream and throw exceptions, use them with caution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I can also say that the exception option can be improved and it will work as well. </font><font style="vertical-align: inherit;">But the realization of these things is quite complicated and, alas, it is not included in our report. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is about everything that I wanted to tell you. </font><font style="vertical-align: inherit;">Stream has a lot of quirks, but if you vary between them, then Stream is great.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you like to dig in the JVM and wait for Java 9 just like us, then we recommend that you pay attention to the following </font></font><a href="https://jokerconf.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reports of the upcoming Joker 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li> <a href="https://jokerconf.com/2017/talks/g3wijzyyfamwe6gqsgawa/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 9: ‚Äã‚Äãthe good parts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Cay Horstmann, San Jose State University)</font></font><br></li><li> <a href="https://jokerconf.com/2017/talks/4ryvdufhggoeieaekimsq/">Amazon Alexa vs Google Home</a> :      Java ( , JFrog;  , CA Technologies) <br></li><li> <a href="https://jokerconf.com/2017/talks/61uvnsroxu4kkwcykweq4k/"> Java 9.   OSGi?</a> ( , Excelsior LLC) <br></li><li> <a href="https://jokerconf.com/2017/talks/5q8bvkqzy40q0g6qeuuwak/">     </a> ( , ) <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/337534/">https://habr.com/ru/post/337534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337520/index.html">Security Week 36: a black hole in the Windows kernel, Adobe homograph attacks, the largest data leak in the US</a></li>
<li><a href="../337522/index.html">For a thousand rubles for the idea: we pay for proposals for the automation of QIWI wallets</a></li>
<li><a href="../337526/index.html">Microservice Architecture - Motive Shift to Target</a></li>
<li><a href="../337528/index.html">Parallelism versus multithreading versus asynchronous programming: an explanation</a></li>
<li><a href="../337532/index.html">10 years with hummingbirds: how it was</a></li>
<li><a href="../337536/index.html">Fix 7 common exception handling errors in java</a></li>
<li><a href="../337538/index.html">‚ÄúYoung people want to buy shares of familiar start-ups on the stock exchange‚Äù: finance trends according to the founder of the Robinhood service</a></li>
<li><a href="../337540/index.html">Setting up a Webpack 3 + Angular 4 development environment: from complex to simple</a></li>
<li><a href="../337546/index.html">Why don't CRM work</a></li>
<li><a href="../337548/index.html">Kaggle: how our nets considered sea lions in the Aleutian Islands</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>