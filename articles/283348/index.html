<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Firebird 3.0 Verification</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, a new version of Firebird DBMS was released. The release became one of the largest in the history of the project: the architecture wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Firebird 3.0 Verification</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/f55/70c/3cf/f5570c3cfce54e27bf2c7dff92a43b24.png"></div><br><br>  Not so long ago, a new version of Firebird DBMS was released.  The release became one of the largest in the history of the project: the architecture was greatly reworked, support for multi-threading was added, and performance was improved.  Such a significant update was the reason for re-checking Firebird using the PVS-Studio static code analyzer. <br><a name="habracut"></a><br><br><h2>  Introduction </h2><br>  Firebird is a cross-platform free database management system.  The project is written in C ++ and runs on Microsoft Windows, Linux, Mac OS X and many Unix-like operating systems.  The DBMS is completely free to use and distribute.  Learn more about Firebird on the <a href="http://www.firebirdsql.org/">official website</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Earlier, Firebird has already been checked by the analyzer.  The report on the previous check can be found in the article " <a href="http://www.viva64.com/ru/b/0235/">Side effect: we check Firebird with PVS-Studio</a> ".  The code with <a href="https://github.com/FirebirdSQL/firebird">GitHub</a> from the master branch was taken for verification.  The assembly is described in detail in the <a href="http://www.firebirdsql.org/en/building-the-code-windows/">corresponding article</a> on the project website.  The source files were <a href="http://www.viva64.com/ru/d/0360/">analyzed</a> in <a href="http://www.viva64.com/ru/d/0360/">PVS-Studio Standalone</a> version 6.03 using compiler monitoring interception (Compiler Monitoring).  This technology allows you to check projects without integration into the assembly system.  The resulting report can be viewed both in the Standalone version and in Visual Studio. <br><br><h2>  Typos </h2><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advance_to_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">isalpha</span></span>(c) &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'_'</span></span> &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'.'</span></span> &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'_'</span></span>) syntax_error(lineno, line, cptr); .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0090/">warning</a> : <a href="http://www.viva64.com/ru/d/0090/">V501</a> There are identical sub-expressions 'c! =' _ '' Operator.  reader.c 1203 <br><br>  The analyzer found that in the logical operation there are two identical subexpressions <i>c! = '_'</i> .  In the last condition, a typo was made and the variable <i>c</i> should be compared with another symbol.  In other functions, the check with the '$' symbol is used, perhaps you should use it here: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">isalpha</span></span>(c) &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'_'</span></span> &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'.'</span></span> &amp;&amp; c != <span class="hljs-string"><span class="hljs-string">'$'</span></span>)</code> </pre> <br>  Another example of a mistake from inattention: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newlen &lt;= MAX_UCHAR) { put(tdgbl, attribute); put(tdgbl, (UCHAR) newlen); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newlen &lt;= MAX_USHORT) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attribute2) BURP_error(<span class="hljs-number"><span class="hljs-number">314</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> BURP_error(<span class="hljs-number"><span class="hljs-number">315</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); .... }</code> </pre> <br>  PVS-Studio warnings: <ul><li>  <a href="http://www.viva64.com/ru/d/0212/">V601</a> The string literal is implicitly cast to the bool type.  Inspect the second argument.  backup.cpp 6113 </li><li>  <a href="http://www.viva64.com/ru/d/0212/">V601</a> The string literal is implicitly cast to the bool type.  Inspect the second argument.  backup.cpp 6120 </li></ul><br>  The BURP_error function is incorrectly used here.  It is declared as follows: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BURP_error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USHORT errcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abort</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MsgFormat::SafeArg&amp; arg = MsgFormat::SafeArg())</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BURP_error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USHORT errcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">abort</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* str)</span></span></span></span>;</code> </pre> <br>  The second argument is boolean, and the string is the third argument.  As a result, the string literal is cast to <i>true.</i>  The function call must be rewritten as BURP_error (315, true, "") or BURP_error (315, false, ""). <br><br>  However, there are cases when only a project developer can recognize an error. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IDX_create_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... index_fast_load ifl_data; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ifl_data.ifl_duplicates) scb-&gt;sort(tdbb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ifl_data.ifl_duplicates) BTR_create(tdbb, creation, selectivity); .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0183/">warning</a> : <a href="http://www.viva64.com/ru/d/0183/">V581</a> The conditional expressions of the 'if' are agreed alongside each other are identical.  Check lines: 506, 509. idx.cpp 509 <br><br>  In the code there are two blocks in succession with the same condition.  Maybe one of them made a typo, maybe this situation arose because of copying or deleting individual sections: in any case, such code looks strange. <br><br>  In the following example, consider the situation associated with pointers. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_to_datetime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* p = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USHORT length = CVT_make_string(desc, ttype_ascii, &amp;p, &amp;buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer), err); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = p + length; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (p &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*p != <span class="hljs-string"><span class="hljs-string">' '</span></span> &amp;&amp; *p != <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &amp;&amp; p != <span class="hljs-number"><span class="hljs-number">0</span></span>) { CVT_conversion_error(desc, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ++p; } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0354/">warning</a> : <a href="http://www.viva64.com/ru/d/0354/">V713</a> The pointer has been used in the same logical expression.  cvt.cpp 702 <br><br>  In the condition, the variable <i>p is</i> checked for nullptr immediately after dereference.  This may mean that there should have been another condition at the inspection site, or that the verification is superfluous. <br><br>  If you look at the code above, you can find a similar fragment: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++p &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*p != <span class="hljs-string"><span class="hljs-string">' '</span></span> &amp;&amp; *p != <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &amp;&amp; *p != <span class="hljs-number"><span class="hljs-number">0</span></span>) CVT_conversion_error(desc, err); }</code> </pre> <br>  In order to avoid such an error, for comparison with zero it is better to use the corresponding literals: <i>'\ 0'</i> for the type char, 0 for numbers and nullptr for pointers.  If you take this as a rule, you can avoid many of these silly mistakes. <br><br><h2>  Dangerous use of memcmp </h2><br><pre> <code class="cpp hljs">SSHORT TextType::compare(ULONG len1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UCHAR* str1, ULONG len2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UCHAR* str2) { .... SSHORT cmp = <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(str1, str2, MIN(len1, len2)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmp == <span class="hljs-number"><span class="hljs-number">0</span></span>) cmp = (len1 &lt; len2 ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : (len1 &gt; len2 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cmp; }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0260/">warning</a> : <a href="http://www.viva64.com/ru/d/0260/">V642</a> Saving the 'memcmp' function result inside the short type variable is inappropriate.  Breaking the program's logic.  texttype.cpp 3 <br><br>  The <i>memcmp</i> function returns the following values: <ul><li>  &lt;0 if <i>str1 is</i> less than <i>str2</i> </li><li>  0 if <i>str1</i> is equal to <i>str2</i> </li><li>  &gt; 0 if <i>str1 is</i> greater than <i>str2</i> </li></ul><br>  Exact values ‚Äã‚Äãof the function are not guaranteed when the strings are unequal; therefore, saving the result to a variable smaller than <i>int</i> can lead to the loss of significant bits and violation of application logic. <br><br><h2>  Extra checks </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Trigger::compile(thread_db* tdbb) { SET_TDBB(tdbb); Database* dbb = tdbb-&gt;getDatabase(); Jrd::Attachment* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> att = tdbb-&gt;getAttachment(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extTrigger) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!statement <span class="hljs-comment"><span class="hljs-comment">/*&amp;&amp; !compile_in_progress*/</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (statement) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... } }</code> </pre> <br>  PVS-Studio Warning: <a href="http://www.viva64.com/ru/d/0255/">V637</a> Two opposite conditions were encountered.  The second condition is always false.  Check lines: 778, 780. jrd.cpp 778 <br><br>  The analyzer found a test of two opposite conditions.  Most likely, the second condition here was no longer necessary as a result of changing the first one and it can be removed, but the author should make a decision here. <br><br>  Another example of strange branching is the following code snippet. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asgn_from</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ref* reference, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> column)</span></span></span><span class="hljs-function"> </span></span>{ TEXT variable[MAX_REF_SIZE]; TEXT temp[MAX_REF_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; reference; reference = reference-&gt;ref_next) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gpre_fld* field = reference-&gt;ref_field; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!field || field-&gt;fld_dtype == dtype_text) .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!field || field-&gt;fld_dtype == dtype_cstring) .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... } }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0153/">warning</a> : <a href="http://www.viva64.com/ru/d/0153/">V560</a> A part of conditional expression is always false <a href="http://www.viva64.com/ru/d/0153/">:!</a> Field.  int_cxx.cpp 217 <br><br>  If <i>field is</i> not a null pointer, then the code will never reach the condition in else if.  Either this test is superfluous, or there should be another comparison in its place.  It is not known whether this condition contradicts the logic of the application. <br><br>  In addition, several unnecessary checks were found in logical expressions. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> XnetServerEndPoint::server_init(USHORT flag) { .... xnet_connect_mutex = CreateMutex(ISC_get_security_desc(), FALSE, name_buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!xnet_connect_mutex || (xnet_connect_mutex &amp;&amp; ERRNO == ERROR_ALREADY_EXISTS)) { system_error::raise(ERR_STR(<span class="hljs-string"><span class="hljs-string">"CreateMutex"</span></span>)); } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0375/">warning</a> : <a href="http://www.viva64.com/ru/d/0375/">V728 Alert</a> check can be simplified.  The '||'  operator expressly surrounded by opposite expressions '! xnet_connect_mutex' and 'xnet_connect_mutex'.  xnet.cpp 2231 <br><br>  The <i>if</i> check <i>(! Xnet_connect_mutex || (xnet_connect_mutex &amp;&amp; ERRNO == ERROR_ALREADY_EXISTS))</i> can be simplified to <i>if (! Xnet_connect_mutex || ERRNO == ERROR_ALREADY_EXISTS)</i> .  This can be easily proved using the truth table. <br><br><h2>  Dangerous comparison of unsigned variable </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thread_db* tdbb, BufferDesc* bdb, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bdb-&gt;bdb_page.getPageNum() &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0137/">warning</a> : <a href="http://www.viva64.com/ru/d/0137/">V547</a> Expression 'bdb-&gt; bdb_page.getPageNum ()&gt; = 0' is always true.  Unsigned type value is always&gt; = 0. cch.cpp 4827 <br><br>  The <i>bdb-&gt; bdb_page.getPageNum ()&gt; = 0</i> condition will always be true, since the function returns an unsigned value.  The programmer may have checked the value incorrectly.  Taking into account similar comparisons in the project, we can assume that the code should look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bdb-&gt;bdb_page.getPageNum() != <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><h2>  Null pointer dereferencing </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeFastMutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FAST_MUTEX* lpMutex, LPSECURITY_ATTRIBUTES lpAttributes, BOOL bInitialState, LPCSTR lpName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid == <span class="hljs-number"><span class="hljs-number">0</span></span>) pid = GetCurrentProcessId(); LPCSTR name = lpName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(lpName) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(FAST_MUTEX_EVT_NAME) - <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;= MAXPATHLEN) { SetLastError(ERROR_FILENAME_EXCED_RANGE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } setupMutex(lpMutex); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> sz[MAXPATHLEN]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lpName) .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0205/">warning</a> : <a href="http://www.viva64.com/ru/d/0205/">V595</a> The 'lpName' pointer was used before it was verified against nullptr.  Check lines: 2814, 2824. isc_sync.cpp 2814 <br><br>  The V595 warning is the most common in projects tested by PVS-Studio, and Firebird is no exception.  Total found more than 30 places with this warning. <br><br>  In this example, the call to <i>strlen (lpName)</i> comes before checking the pointer to <i>nullptr</i> .  This will lead to undefined behavior when trying to pass a null pointer to the function.  The pointer dereference is hidden here in the <i>strlen</i> call, which makes it difficult to detect an error if you do not use a static analyzer. <br><br><h2>  Check for nullptr after new </h2><br><pre> <code class="cpp hljs">rem_port* XnetServerEndPoint::get_server_port(....) { .... XCC xcc = FB_NEW struct xcc(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port) cleanup_port(port); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xcc) cleanup_comm(xcc); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> port; }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0293/">warning</a> : <a href="http://www.viva64.com/ru/d/0293/">V668</a> against c pointer allocated allocated allocated allocated...  The exception will be generated in the case of memory allocation error.  xnet.cpp 2533 <br><br>  The analyzer warns that the new operator cannot return nullptr ‚Äî you must use a try-catch or <i>new (std :: nothrow)</i> block to check.  However, in this example, everything is somewhat more complicated.  To allocate memory, use the <i>FB_NEW</i> macro.  It is declared in the alloc.h file: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> USE_SYSTEM_NEW #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OOM_EXCEPTION std::bad_alloc #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OOM_EXCEPTION Firebird::BadAlloc #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FB_NEW new(__FILE__, __LINE__) inline void* operator new(size_t s ALLOC_PARAMS) throw (OOM_EXCEPTION) { return MemoryPool::globalAlloc(s ALLOC_PASS_ARGS); }</span></span></code> </pre> <br>  It is difficult to say whether this particular example is an error or not, as a non-standard allocator is used.  But due to the fact that the definition of the operator is set to <i>throw (std :: bad_alloc)</i> , such a check looks suspicious. <br><br><h2>  Dangerous use of realloc </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mputchar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mstring *s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s || !s-&gt;base) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;ptr == s-&gt;end) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = s-&gt;end - s-&gt;base; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((s-&gt;base = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(s-&gt;base, len+len+TAIL))) { s-&gt;ptr = s-&gt;base + len; s-&gt;end = s-&gt;base + len+len+TAIL; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { s-&gt;ptr = s-&gt;end = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ch; } } *s-&gt;ptr++ = ch; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ch; }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0340/">warning</a> : <a href="http://www.viva64.com/ru/d/0340/">V701</a> realloc () possible leak: when realloc () fails in allocating memory, original pointer 's-&gt; base' is lost.  Consider assigning realloc () to a temporary pointer.  mstring.c 42 <br><br>  An expression like <i>ptr = realloc (ptr, size) is</i> bad because if <i>realloc</i> returns nullptr, the pointer to memory will be lost.  To avoid this, save the <i>realloc</i> result to a temporary variable and, after checking for nullptr, assign <i>ptr to</i> its value. <br><pre> <code class="cpp hljs">temp_ptr = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(ptr, new_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//handle exception } else { ptr = temp_ptr; }</span></span></code> </pre> <br><h2>  Unused enum values ‚Äã‚Äãin switch </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CharType&gt; LikeEvaluator&lt;CharType&gt;::LikeEvaluator(....) { .... PatternItem *item = patternItems.begin(); .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (item-&gt;type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> piSkipFixed: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> piSkipMore: patternItems.grow(patternItems.getCount() + <span class="hljs-number"><span class="hljs-number">1</span></span>); item = patternItems.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Note: fall into case piNone: item-&gt;type = piEscapedString; item-&gt;str.data = const_cast&lt;CharType*&gt; (pattern_str + pattern_pos - 2); item-&gt;str.length = 1; break; case piSearch: item-&gt;type = piEscapedString; // Note: fall into case piEscapedString: item-&gt;str.length++; break; } .... }</span></span></code> </pre> <br>  PVS-Studio Warning: <a href="http://www.viva64.com/ru/d/0362/">V719</a> The switch statement doesn‚Äôt cover all of the PatternItemType enum: piDirectMatch.  evl_string.h 324 <br><br>  Not all enum values ‚Äã‚Äãwere used in the switch construction, and there is no default block.  It is possible that they forgot to add piDirectMatch processing.  List of places with the same warning: <ul><li>  V719 The switch statement doesn‚Äôt cover all of the PatternItemType enum: piDirectMatch, piSkipMore.  evl_string.h 351 </li><li>  V719 The switch statement doesn‚Äôt cover all of the 'PatternItemType' enum: piDirectMatch.  evl_string.h 368 </li><li>  V719 The switch statement doesn‚Äôt cover all of the 'PatternItemType' enum: piDirectMatch.  evl_string.h 387 </li></ul><br><h2>  Buffer overflow </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GDS_NAME_LEN = <span class="hljs-number"><span class="hljs-number">32</span></span>; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BurpGlobals* tdgbl)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isc_844_struct</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> isc_870; <span class="hljs-comment"><span class="hljs-comment">/* gds__null_flag */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> isc_874 [<span class="hljs-number"><span class="hljs-number">125</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* RDB$PACKAGE_NAME */</span></span> .... } isc_844; att_type attribute; TEXT temp[GDS_NAME_LEN * <span class="hljs-number"><span class="hljs-number">2</span></span>]; .... SSHORT prefixLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-comment"><span class="hljs-comment">/*X.RDB$PACKAGE_NAME.NULL*/</span></span> isc_844.isc_870) { prefixLen = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;SSHORT&gt;(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-comment"><span class="hljs-comment">/*X.RDB$PACKAGE_NAME*/</span></span> isc_844.isc_874)); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(temp, <span class="hljs-comment"><span class="hljs-comment">/*X.RDB$PACKAGE_NAME*/</span></span> isc_844.isc_874, prefixLen); temp[prefixLen++] = <span class="hljs-string"><span class="hljs-string">'.'</span></span>; } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0148/">warning</a> : <a href="http://www.viva64.com/ru/d/0148/">V557</a> Array overrun is possible.  The value of 'prefixLen ++' index could reach 124. restore.cpp 10040 <br><br>  The buffer size <i>isc_844.isc_874</i> is 125, respectively, the maximum possible value of <i>strlen (isc_844.isc_874)</i> is 124. The <i>temp</i> size is 64, which is less than this value.  Writing at this index may result in a buffer overflow.  It is safer to allocate more memory for the <i>temp</i> variable. <br><br><h2>  Shift negative numbers </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ISC_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stuff_literal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gen_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* gen, SLONG literal)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (literal &gt;= <span class="hljs-number"><span class="hljs-number">-32768</span></span> &amp;&amp; literal &lt;= <span class="hljs-number"><span class="hljs-number">32767</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stuff_args(gen, <span class="hljs-number"><span class="hljs-number">3</span></span>, isc_sdl_short_integer, literal, literal &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); .... }</code> </pre><br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0225/">warning</a> : <a href="http://www.viva64.com/ru/d/0225/">V610</a> Unspecified behavior.  Check the shift operator '&gt;&gt;'.  The left operand is negative ('literal' = [-32768..32767]).  array.cpp 848 <br><br>  The code contains a right shift of a negative number.  The C ++ standard states that such an action has unspecified behavior, which means it can produce different results on different compilers and platforms.  It is better to rewrite it like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (literal &gt;= <span class="hljs-number"><span class="hljs-number">-32768</span></span> &amp;&amp; literal &lt;= <span class="hljs-number"><span class="hljs-number">32767</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stuff_args(gen, <span class="hljs-number"><span class="hljs-number">3</span></span>, isc_sdl_short_integer, literal, (ULONG)literal &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>);</code> </pre> <br>  Another place where the warning worked: <br><br>  <a href="http://www.viva64.com/ru/d/0225/">V610</a> Unspecified behavior.  Check the shift operator '&gt;&gt;'.  The left operand is negative ('i64value' = [-2147483648..2147483647]).  exprnodes.cpp 6382 <br><br><h2>  Variable override </h2><br><pre> <code class="cpp hljs">THREAD_ENTRY_DECLARE Service::run(THREAD_ENTRY_PARAM arg) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> exit_code = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Service* svc = (Service*)arg; RefPtr&lt;SvcMutex&gt; ref(svc-&gt;svc_existence); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> exit_code = svc-&gt;svc_service_run-&gt;serv_thd(svc); svc-&gt;started(); svc-&gt;svc_sem_full.release(); svc-&gt;finish(SVC_finished); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; ex) { <span class="hljs-comment"><span class="hljs-comment">// Not much we can do here iscLogException("Exception in Service::run():", ex); } return (THREAD_ENTRY_RETURN)(IPTR) exit_code; }</span></span></code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0154/">warning</a> : <a href="http://www.viva64.com/ru/d/0154/">V561</a> It's not better to declare it an exit_code 'variable than to declare it anew.  Previous declaration: svc.cpp, line 1893. svc.cpp 1898 <br><br>  In this example, instead of assignment, the variable <i>exit_code is</i> redefined.  This hides the previous variable from the scope, and as a result, the function returns an incorrect value, always equal to -1. <br><br>  Correct code: <br><pre> <code class="cpp hljs">THREAD_ENTRY_DECLARE Service::run(THREAD_ENTRY_PARAM arg) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> exit_code = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Service* svc = (Service*)arg; RefPtr&lt;SvcMutex&gt; ref(svc-&gt;svc_existence); exit_code = svc-&gt;svc_service_run-&gt;serv_thd(svc); svc-&gt;started(); svc-&gt;svc_sem_full.release(); svc-&gt;finish(SVC_finished); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; ex) { <span class="hljs-comment"><span class="hljs-comment">// Not much we can do here iscLogException("Exception in Service::run():", ex); } return (THREAD_ENTRY_RETURN)(IPTR) exit_code; }</span></span></code> </pre> <br><br><h2>  Conclusion </h2><br>  Most of the problems found in the <a href="http://www.viva64.com/ru/b/0235/">previous test</a> were fixed by the developers of the project and now they are not in the code - it means the analyzer has done an excellent job.  However, the best result can be achieved with regular use, which will allow you to catch errors at an early stage.  Incremental analysis and compatibility with any build systems make it easy to integrate a static analyzer into your project.  Using a static analyzer can save a lot of time and find errors that are difficult to detect with debugging or dynamic analysis. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0396/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Pavel Belikov.  <a href="http://www.viva64.com/en/b/0396/">Analyzing Firebird 3.0</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/283348/">https://habr.com/ru/post/283348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283334/index.html">Moscow Python Meetup ‚Ññ35 (May 23, 7 pm)</a></li>
<li><a href="../283340/index.html">DevConf-2016: conference program</a></li>
<li><a href="../283342/index.html">ONLYOFFICE Documents 1.3 for iOS: how the mobile spreadsheet editor is organized</a></li>
<li><a href="../283344/index.html">Theory and practice of escape from the 5 GHz band</a></li>
<li><a href="../283346/index.html">CUBA Platform Enters Free Software Market</a></li>
<li><a href="../283350/index.html">Basics of game design: 20 board games. Part one</a></li>
<li><a href="../283352/index.html">C ++ without new and delete</a></li>
<li><a href="../283354/index.html">Leaflet as a shell for Yandex.Maps - we display 100 thousand markers on the map</a></li>
<li><a href="../283356/index.html">REG.RU: Step-by-Step Guide to Creating a Company Website</a></li>
<li><a href="../283358/index.html">CDN - New Video Broadcast Standard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>