<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of IntelliJ IDEA plugin. Part 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this part: backlight, reference system, autocompletion, code navigation. The previous part is here . 
 Syntax and error highlighting 
 The class us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of IntelliJ IDEA plugin. Part 5</h1><div class="post__text post__text-html js-mediator-article"><h6>  In this part: backlight, reference system, autocompletion, code navigation.  The previous part is <a href="http://habrahabr.ru/post/187224/">here</a> . </h6><br><h4>  Syntax and error highlighting </h4><br>  The class used in IDEA to determine how the corresponding text range should be highlighted is called <a href="">TextAttributesKey</a> .  An instance of this class is created for each different type of element that needs to be highlighted (keywords, numbers, strings, comments, etc.), it defines the default attributes that apply to elements of the corresponding type (for example, keywords are bold , numbers - in blue, lines - in italics and green background).  The mapping of the TextAttributesKey to specific attributes used in the editor is determined by the <a href="">EditorColorsScheme</a> class and can be customized by the user if the plugin provides the appropriate configuration interface.  In the backlight can be used overlay several TextAttributeKey: for example, one key can define the style, and the other - the color of the element. <a name="habracut"></a><br><br><h5>  Basic syntax highlighting </h5><br>  Syntax and error highlighting is performed at different levels.  On the first, syntax highlighting, based on the results of lexical analysis, is performed via the <a href="">SyntaxHighlighter</a> interface.  This interface returns TextAttributeKey instances for each type of token that requires special highlighting.  To highlight lexer errors, use the standard object of the TextAttributeKey class for invalid characters ( <code>HighligherColors.BAD_CHARACTER</code> ). <br><br>  The color management scheme has changed a bit in Intelli IDEA 12.1 to facilitate the work of circuit designers and make the same mapping for different programming languages, even if the scheme was not originally intended for them.  Previously, language plug-ins used fixed color schemes are not always compatible, for example, with dark themes.  The new implementation allows you to define dependencies on a set of standard text attributes associated with a schema, rather than a specific language.  Attributes for specific languages ‚Äã‚Äãcan still be set by the schema designer, but now they are optional.  New color schemes have the .icls extension to avoid compatibility issues. <br>  Now we use the <a href="">DefaultLanguageHighlighterColors</a> class to define text attributes and dependencies on standard keys. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Example: <a href="">SyntaxHighlighlighter implementation</a> for the Properties plugin. <br><br>  At the second level of illumination - the selection of errors that occurred during the syntactic analysis.  If a specific chain of tokens does not match the grammar of the language, the PsiBuilder.error () method can be used to highlight invalid tokens and display an error message. <br><br><h5>  Annotations </h5><br>  The third level of illumination is performed using the <a href="">Annotator</a> interface.  The plugin can register one or several annotations at the <code>com.intellij.annotator</code> extension <code>com.intellij.annotator</code> , after which they will be called in the background process while highlighting elements of the PSI tree of the user language.  Annotations can analyze not only syntax, but also semantics and thus provide a more subtle logic for handling and highlighting errors.  The abstract may contain functionality for solving detected problems (so-called quick fix). <br><br>  When a file is modified, the annotation is called incrementally to process only the changed elements of the PSI tree. <br>  To highlight a specific text range as an error or warning, the annotation calls createErrorAnnotation () or createWarningAnnotation () on an object of type <a href="">AnnotationHolder</a> , and optionally registerFix () on the returned Annotator object to add error correction logic.  To apply additional highlighting, the annotation may call AnnotationHolder.createInfoAnnotation () with a blank message and then, by calling Annotation.setTextAttributes (), set text attributes. <br><br>  Example: <a href="">Annotator for the language Properties</a> . <br><br><h5>  External annotations </h5><br>  Finally, if the user language uses external tools to validate files, their results can be provided by implementing the <a href="">ExternalAnnotator</a> interface and registering it at the expansion point <code>com.intellij.externalAnnotator</code> .  Illumination using ExternalAnnotator has the lowest priority and is performed only after all background processes are completed.  External annotations use the same AnnotationHolder interface to adapt the output of external tools and display the backlight. <br><br><h5>  Color Settings Page </h5><br>  The plugin can also provide a configuration interface that allows the user to customize the colors of certain elements.  To do this, you must create an instance of the <a href="">ColorSettingPage</a> class and register it in the expansion point <code>com.intellij.colorSettingsPage</code> . <br><br>  Example: <a href="">ColorSettingsPage for Properties</a> . <br><br>  The ‚ÄúExport to HTML‚Äù function uses the same highlighting mechanism as the editor, so it becomes available for the user language immediately after the implementation of SyntaxHighlighter. <br><br><h4>  IntelliJ IDEA Reference System </h4><br>  One of the most important and confusing parts in the implementation of the program structure of the user language is the resolution of links, i.e.  the ability to proceed from the place of use of the element (variable in the expression, method call, etc.) to the place of definition (variable declaration, method, etc.).  This is required to support many IDEA functions, such as ‚ÄúGo to Declaration‚Äù (Ctrl-B and Ctrl-Click), as well as when searching for usages, renaming, autocompletion. <br><br>  Each PSI element that is supposed to work with a link must override the PsiElement.getReference () method so that it returns the corresponding implementation of the <a href="">PsiReference</a> interface.  This interface can be implemented both by the PsiElement class itself and as a separate one.  If an element can contain several links (for example, a string with a list of classes), then it must implement the PsiElement.getReferences () method, which returns an array of links. <br><br>  The main method of the PsiReference interface is resolve (), which returns either the element pointed to by the link or null if it is impossible to resolve the link (for example, if it indicates an undefined class).  The opposite method is isReferenceTo (), which checks whether the link points to a specific element.  The latter method can be implemented by calling resolve () and comparing the result with the passed PSI element, but allows the developer to apply additional optimizations. <br><br>  Example: <a href="">Link to ResourceBundle</a> in Properties plugin. <br><br>  IDEA provides a number of interfaces that can be used as a base for implementing reference support, namely the <a href="">PsiScopeProcessor</a> interface and the PsiElement.processDeclarations () method.  These interfaces have many complexities that are not necessary for most user languages ‚Äã‚Äã(for example, support for substitution of generic types), but they are necessary if the user language can refer to Java code.  If interoperability with Java is not required, or there are other reasons, the plugin can override the standard implementation of link resolution. <br><br>  The standard IDEA helper classes used to resolve links consist of the following components: <br><ul><li>  a class that implements the PsiScopeProcessor interface, which collects possible link definitions and stops the resolution process when it is fully completed.  The main method that needs to be implemented is execute (), which is called to process each definition and returns false when the definition is found; </li><li>  a function that bypasses the tree from the place the link is located and until it resolves or goes out of scope; </li><li>  The PSI elements on which the processDeclarations () method is called during a walk around the PSI tree.  If the element is a definition, then it passes the reference to itself to the execute () method.  If necessary in accordance with the language rules for defining scopes, an element can pass the PsiScopeProcessor to its child elements. </li></ul><br>  There is an extension to the PsiReference interface that allows links to use multiple target elements - PsiPolyVariantReference.  The target link elements are returned by the multiResolve () method.  The ‚ÄúGo to Declaration‚Äù action for this type of link allows you to select which element to use for navigation.  The implementation of multiResolve () can be based on the PsiScopeProcessor if, instead of stopping the search after the first result found, we continue to collect the remaining target elements. <br><br>  On the other hand, in IntelliJ IDEA there is an approach to the implementation of the reference system through the Reference Contributor and the Reference Provider. <br>  <a href="">PsiReferenceContributor</a> checks each PsiElement and, using the appropriate description provided by the user, returns the reference provider object registered for this case ( <a href="">example</a> ).  In turn, <a href="">PsiReferenceProvider</a> is a class designed to find links inside a single PSI element of the tree.  It returns an array of PsiReference objects ( <a href="">example</a> ). <br>  The PsiReferenceProvider.getReferencesByElement () method should return a list of links (PsiReference) that are contained in the PsiElement element passed to it.  In this case, only one link is returned, but in the general case there may be several of them, with each link having to contain a corresponding textRange (starting index and ending index of finding the link within the text of the PSI element). <br><br>  Reference Contributor must be registered in the plugin.xml file at the corresponding extension point - com.intellij.psi.referenceContributor. <br>  After that, it is possible to use the results of his work to get a list of links when implementing the PsiElement.getReferences () method.  In order not to duplicate this code in each reference element, you can define a base class for custom Psi elements: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyASTWrapperPsiElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASTWrapperPsiElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyASTWrapperPsiElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull ASTNode astNode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(astNode); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PsiReference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PsiReference[] references = getReferences(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> references.length == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : references[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PsiReference[] getReferences() { <span class="hljs-comment"><span class="hljs-comment">//  ,   Contributor return ReferenceProvidersRegistry.getReferencesFromProviders(this); } }</span></span></code> </pre><br><h4>  Code completion </h4><br>  There are two main types of autocompletion that can be used in a user language plugin: simple reference add-on and provider-based add-on. <br><br><h5>  Simple autocompletion </h5><br>  To populate the add-on list, IDEA calls the PsiReference.getVariants () method either at the link under the cursor, or at the dummy item that fits under the cursor.  This method should return an array of objects containing strings, PSI elements, or instances of the LookupElement class.  If an instance of PsiElement is found in the returned array, then the corresponding icon will be displayed in the add-on list. <br>  The most common way to implement getVariants () is to use the same tree traversal function as in the PsiReference.resolve () method, but returning all the definitions found. <br><br><h5>  Autocompletion on the basis of the provider </h5><br>  Implementing an add-on based on the <a href="">CompletionContributor</a> interface gives you the most control over the code auto-completion operation. <br>  The main use case of the Completion Contributor consists of calling the extend () method and passing to the ‚Äúpattern‚Äù parameter of the corresponding context in which this option is applied, the provider is passed to the ‚Äúprovider‚Äù parameter, which generates the corresponding autocompletion list items. <br><br>  Example: <a href="http://git.jetbrains.org/%3Fp%3Didea/contrib.git%3Ba%3Dblob%3Bf%3Dosmorc/src/org/osmorc/manifest/ManifestCompletionContributor.java%3Bhb%3DHEAD">CompletionContributor</a> for auto-completion of keywords in MANIFEST.MF files. <br><br>  The items in the autocompletion list are represented by instances of the <a href="">LookupElement</a> interface.  These objects are usually created using LookupElementBuilder.  For each of these, you can define the following attributes: <br><ul><li>  main text, additional text, line with type - additional text is shown immediately after the main text, but is not used to search for matches; it is intended mainly for displaying the list of method parameters.  The string containing the type of the complemented expression is right justified in the list of additions, usually shows the returned type of the method or the class containing it; </li><li>  icon; </li><li>  text attributes; </li><li>  A handler for inserting text is a callback method, which is executed when any item from the add-on list is selected. It can be used, for example, to insert brackets after calling the method. </li></ul><br><h4>  Search for uses </h4><br>  The ‚ÄúFind Usages‚Äù action in IDEA is a multi-step process, each step of which requires participation from the plugin: in the form of implementing and registering <a href="">FindUsagesProvider</a> at the expansion point com.intellij.lang.findUsagesProvider, as well as the features of implementing the program structure (PsiNamedElement and PsiReference interfaces) . <br><br>  Example: <a href="">implementation of FindUsagesProvider</a> for Properties. <br><br>  To implement this function, the following steps must be performed: <br><ul><li>  before performing the ‚ÄúFind Usages‚Äù action, IDEA builds an index of the words represented in each file of the user language.  Using the WordsScanner implementation obtained from FindUsagesProvider.getWordsScanner (), IDEA loads the contents of each file and sends it to the word scanner, along with a word processor.  The scanner breaks the text into words, determines the context of each word (code, comments, lines) and sends them to the processor.  The easiest way to implement a scanner is to use the DefaultWordsScanner class; </li><li>  when the user invokes the "Find Usages" action, IDEA identifies the element to which you want to find links.  The PSI element under the cursor (or the direct parent in the token tree under the cursor) should be <a href="">PsiNamedElement</a> or a link to it.  IDEA will use the word cache to search for text returned by PsiNamedElement.getName ().  If the text range PsiNamedElement includes other text besides the identifier returned by getName (), the getTextOffset () method must be rewritten to return the starting offset of the identifier; </li><li>  as soon as an element is found, IDEA calls FindUsagesProvider.  canFindUsagesFor () to find out if the action applies to this element; </li><li>  when the Find Usages dialog is shown to the user, IDEA calls FindUsagesProvider.getType () and FindUsagesProvider.getDescriptiveName () to determine how to display this element; </li><li>  For each file containing the found words, IDEA builds a PSI tree and performs a recursive descent.  IDEA breaks the text of each element into words and scans them.  If an element is indexed as an identifier, then for each word it is checked whether it points to the required element; </li><li>  after all uses are found, the results are shown in the uses panel.  The text to display to the user is taken from the FindUsagesProvider.getNodeText () method. </li></ul><br>  To correctly display the name of the found element in the header of the Find Usages panel, you must provide an implementation of the ElementDescriptionProvider interface.  The ElementDescriptionLocation object that is passed to the provider in this case must have the actual type UsageViewLongNameLocation. <br><br>  Example: <a href="">ElementDescriptionProvider</a> for the Properties plugin. <br><br>  In the next part: refactorings, formatting, etc. <br><br><h6>  All articles of the cycle: <a href="http://habrahabr.ru/post/187106/">1</a> , <a href="http://habrahabr.ru/post/187142/">2</a> , <a href="http://habrahabr.ru/post/187208/">3</a> , <a href="http://habrahabr.ru/post/187224/">4</a> , <a href="http://habrahabr.ru/post/187292/">5</a> , <a href="http://habrahabr.ru/post/187474/">6</a> , <a href="http://habrahabr.ru/post/188060/">7</a> . </h6></div><p>Source: <a href="https://habr.com/ru/post/187292/">https://habr.com/ru/post/187292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187278/index.html">Computer generated efficient, but incomprehensible to man, TCP acceleration algorithms</a></li>
<li><a href="../187280/index.html">In Belarus, problems with access to Google</a></li>
<li><a href="../187282/index.html">The simplest implementation of cross-platform multiplayer on the example of the evolution of a single .NET game. Part two, more technical</a></li>
<li><a href="../187284/index.html">Ubuntu Phone, Core Applications. Inside view</a></li>
<li><a href="../187286/index.html">Interplanetary rally of two centuries</a></li>
<li><a href="../187294/index.html">Ice cream trailer on request from a mobile application</a></li>
<li><a href="../187298/index.html">Disney Research has developed a tactile feedback system based on a vortex cannon.</a></li>
<li><a href="../187300/index.html">Simple-Science - Simple Experiments (Digest # 25)</a></li>
<li><a href="../187304/index.html">[Poll] Application for saving and synchronizing history in the clipboard. To be or not to be?</a></li>
<li><a href="../187310/index.html">ConceptNet 5 - Real AI is around the corner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>