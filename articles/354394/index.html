<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to improve performance using serverless architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo : Jesse Darland with Unsplash 

 This article will discuss how to transfer the process of image preprocessing from an application server to an a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to improve performance using serverless architecture</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ag/ze/ep/agzeep2k2d-99bzef6b5honmcrw.jpeg"><br>  <i>Photo</i> : <a href="http://unsplash.com/photos/cAQfkfLSA80%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText"><i>Jesse Darland</i></a> <i>with</i> <a href="http://unsplash.com/search/photos/perform%3Futm_source%3Dunsplash%26utm_medium%3Dreferral%26utm_content%3DcreditCopyText"><i>Unsplash</i></a> <br><br>  This article will discuss how to transfer the process of image preprocessing from an application server to <b>an absolutely serverless</b> AWS platform architecture. <a name="habracut"></a><br><br><h3>  The essence of the problem </h3><br>  If the web application allows you to upload an image, most likely it needs to be processed before it is shown to the user. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The article will talk about serverless architecture based on the AWS platform, which provides ample opportunities for scaling. <br><br>  In one of my recent projects (a web-based trading application, when working with which the user needs to upload a product image), the original image is first cropped at a 4: 3 aspect ratio.  It is then converted into three different formats used in various elements of the user interface: 800x600, 400x300 and 200x150. <br><br>  Being a developer of the Ruby on Rails framework, I first decided to try the RubyGem packages, namely <a href="http://github.com/thoughtbot/paperclip">Paperclip</a> or <a href="http://github.com/markevans/dragonfly">Dragonfly</a> , which use ImageMagick for image processing. <br><br>  This is a fairly simple approach, but it has its drawbacks: <br><br><ol><li>  Images are processed on the application server.  This may lead to an increase in the overall response time due to increased processor load. </li><li>  The application server has limited performance and is not suitable for step-by-step request processing.  If you want to simultaneously process multiple images, it can be fully loaded for a long time.  Improving server performance, in turn, will increase costs. </li><li>  Images are processed sequentially.  Again, if you want to immediately process a lot of images, it will be long. </li><li>  If the above packages are configured incorrectly, the processed images will be saved to disk, which can quickly lead to a shortage of free space on the server. </li></ol><br>  In general, if an application processes a sufficiently large number of images, this solution does not scale. <br><br><h3>  Decision </h3><br>  If you look at the process of image processing, you can understand that in most cases there is no need to execute it directly on the application server.  This is especially true if the same transformations are always performed, which do not require any other data than the image itself.  So it was in my case: I always just did that I created several images of different sizes, optimizing their level of quality. <br><br>  As soon as it became clear that this task can be easily separated from the rest of the application logic, the thought of a serverless solution that just takes the original image as input data and performs all the necessary transformations immediately came to mind. <br><br>  It turned out that the AWS Lambda service is ideal for this purpose.  It is capable of processing thousands of requests per second, while you only have to pay for the actual computing time.  If the code is not executed, then the money will not be required from you. <br><br>  AWS S3 offers unlimited storage at a low price, and AWS SNS provides simple ‚Äúpublisher-subscriber‚Äù messaging for microservices, distributed systems, and serverless applications.  Finally, AWS Cloudfront is used as a content delivery network for images stored in S3. <br>  The combination of these four AWS services gives us a powerful solution for image processing at minimal cost. <br><br><h2>  High level architecture </h2><br>  Creating different versions of an image from the same source begins with loading the original in AWS S3.  Then, using AWS SNS, the AWS Lambda function is launched, which is responsible for creating new versions and reloading them into AWS S3.  In more detail, the process looks like this: <br><br><ol><li>  Images are uploaded to a specific folder inside the AWS S3 batch. </li><li>  Every time a new image is uploaded to this folder, the service sends a message with the S3 key of the created object in the AWS SNS topic. </li><li>  AWS Lambda, configured as a user in the same SNS topic, reads the message and uses this key to retrieve the new image. </li><li>  AWS Lambda processes the image by performing the necessary conversions, and then loads it back into S3. </li><li>  Processed images are displayed to users.  In order to optimize download speed, AWS Cloudfront content delivery network is used for this. </li></ol><br><img src="https://habrastorage.org/webt/hx/05/na/hx05naqtx2l0xyfem2nhuqoarqc.png"><br><br>  This architecture is easily scalable, as each loaded image initiates a new execution of Lambda code to process a particular request.  Thus, multiple code execution allows you to process thousands of images simultaneously. <br><br>  The disk space and computing resources of the application server are not used, since all data is stored in S3 and processed by the Lambda service. <br><br>  Finally, setting up the content delivery network for S3 is very simple and allows you to maintain high download speed anywhere in the world. <br><br><h2>  Step-by-step instruction </h2><br>  The implementation of this solution is not very complicated, since basically (with the exception of the Lambda code, which performs pre-processing of images) includes only the setting.  The rest of this article describes in detail how to configure the AWS architecture.  And so that you can fully appreciate its work, the AWS Lambda code for resizing the loaded image is also given. <br><br>  To test it yourself, you will need an AWS account.  You can create one and use the AWS free starter pack <a href="http://aws.amazon.com/free/">here</a> . <br><br><h3>  Step 1: Create a topic in AWS SNS </h3><br>  First of all, you need to set up a new SNS (Simple Notification Service) topic, where AWS will post messages every time a new image is uploaded to S3.  Such a message contains an S3-key object, which is subsequently used by the Lambda function to extract and process the image. <br><br>  From the AWS console, go to <a href="https%253A%252F%252Fconsole.aws.amazon.com%252Fsns%252Fv2%252Fhome%253Fstate%253DhashArgs%252523%2526isauthcode%253Dtrue%26client_id%3Darn%253Aaws%253Aiam%253A%253A015428540659%253Auser%252Fsns%26forceMobileApp%3D0">the SNS page</a> , click Create topic, and enter a topic name, for example, image-preprocessing. <br><br><img src="https://habrastorage.org/webt/w3/we/xi/w3wexijlou5xksjrrwc0jsyhcr8.png"><br><br>  Then you need to change the topic's policy to allow the S3 bakt to post messages. <br>  On the topic page, click Actions -&gt; Edit Topic Policy, select Advanced view, add the following JSON block (with your own Amazon resource names (arn) in the Resource and SourceArn lines) to the Statement array and update the policy: <br><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Sid"</span></span>: <span class="hljs-string"><span class="hljs-string">"ALLOW_S3_BUCKET_AS_PUBLISHER"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Effect"</span></span>: <span class="hljs-string"><span class="hljs-string">"Allow"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Principal"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"AWS"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Action"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SNS:Publish"</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">"Resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"arn:aws:sns:us-east-1:AWS-OWNER-ID:image-preprocessing"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Condition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"StringLike"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"aws:SourceArn"</span></span>: <span class="hljs-string"><span class="hljs-string">"arn:aws:s3:*:*:YOUR-BUCKET-NAME"</span></span> } } }</code> </pre> <br>  An example of a full JSON policy text is <a href="">here</a> . <br><br><h3>  Step 2: Create AWS S3 Folder Structure </h3><br>  Now you need to prepare the folder structure in S3, in which the original and processed images will be stored.  In this example, we will create image versions in two sizes: 800x600 and 400x300. <br><br>  From the AWS console, open <a href="https%253A%252F%252Fs3.console.aws.amazon.com%252Fs3%252Fhome%253Fstate%253DhashArgs%252523%2526isauthcode%253Dtrue%26client_id%3Darn%253Aaws%253Aiam%253A%253A015428540659%253Auser%252Fs3%26forceMobileApp%3D0">the S3 page</a> and create a new bakt.  I will call it image-preprocessing-example.  Next you need to create a folder in the bucket called originals, 800x600 and 400x300. <br><br><img src="https://habrastorage.org/webt/9p/hc/ak/9phcakflt_ungnbjajgzqpjtyi4.png"><br><br><h3>  Step 3: Configure AWS S3 Events </h3><br>  Every time a new image is uploaded to the folder, the originals S3 should publish a message in the image-preprocessing topic, so that this image can be processed. <br><br>  To set up the publication of such messages, open the S3 bakt via the AWS console, click Properties -&gt; Events -&gt; Add notification and complete the following fields: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7j/in/6e/7jin6elfr-j-lbc7ncppnrlqmjm.png" alt="image"></div><br>  Here we set a rule for generating an event each time a new object is created (ObjectCreate checkbox) inside the originals folder (Prefix field), and publishing this event in the SNS topic image-preprocessing. <br><br><h3>  Step 4: Configure the IAM Role to Provide Lambda Access to the S3 Folder </h3><br>  You need to create a Lambda function that will download images from the S3 folder, process them, and upload the processed versions back to S3.  But first you need to configure the IAM role so that the Lambda function can access the required S3 folder. <br><br>  From the AWS console, go to the IAM page: <br><br><ul><li>  Click <a href="https%253A%252F%252Fconsole.aws.amazon.com%252Fiam%252Fhome%253Fregion%253Dus-east-1%2526state%253DhashArgs%252523%25252Fpolicies%252524new%25253Fstep%25253Dedit%2526isauthcode%253Dtrue%26client_id%3Darn%253Aaws%253Aiam%253A%253A015428540659%253Auser%252Fiam%26forceMobileApp%3D0">Create Policy</a> . </li><li>  Click JSON and enter the name of your bucket: </li></ul><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2012-10-17"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Statement"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Sid"</span></span>: <span class="hljs-string"><span class="hljs-string">"Stmt1495470082000"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Effect"</span></span>: <span class="hljs-string"><span class="hljs-string">"Allow"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Action"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"s3:*"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"Resource"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arn:aws:s3:::YOUR-BUCKET-NAME/*"</span></span> ] } ] }</code> </pre> <br>  The Resource string refers to our baket in S3.  Click Review, enter a policy name, for example, AllowAccessOnYourBucketName, and create a policy. <br><br><img src="https://habrastorage.org/webt/a-/k3/pl/a-k3plvbirtfkczvtxwaqbxntxw.png"><br><br><ul><li>  Click Roles -&gt; Create role. </li><li>  Select AWS Service -&gt; Lambda (the service that will use the policy). </li><li>  Select the policy you created earlier (AllowAccessOnYourBucketName). </li><li>  Now click review, enter a name (LambdaS3YourBucketName) and click Create a role. </li></ul><br><img src="https://habrastorage.org/webt/6n/rq/vi/6nrqvih7z2w8_g-0lcgyyu6kpbs.png"><br><br>  Creating a <code>Lambda</code> Role <br><br><img src="https://habrastorage.org/webt/ak/eq/po/akeqpofbqvefqsdjmikiia5kz14.png"><br><br>  Attaching a policy to the role of <code>Lambda</code> <br><br><img src="https://habrastorage.org/webt/xl/pc/4t/xlpc4txyltgyrutzfm4lj2akbs0.png"><br><br>  Saving role <br><br><h3>  Step 5: Create the AWS Lambda Function </h3><br>  Next, you need to configure the Lambda function so that it reads messages from the image-preprocessing topic and generates modified versions of the images. <br><br>  Let's start by creating a new Lambda function. <br><br>  From the AWS console, go to <a href="https%253A%252F%252Fconsole.aws.amazon.com%252Fsns%252Fv2%252Fhome%253Fstate%253DhashArgs%252523%2526isauthcode%253Dtrue%26client_id%3Darn%253Aaws%253Aiam%253A%253A015428540659%253Auser%252Fsns%26forceMobileApp%3D0">the Lambda page</a> , click Create function and enter the name of the new function, for example, ImageResize.  Select the runtime environment (in this case, Node.js 6.10) and the previously created IAM role. <br><br><img src="https://habrastorage.org/webt/fp/cc/xi/fpccxis8kzrmlp0jkzlecsqpfro.png"><br><br>  Then you need to add the SNS to the number of triggers so that the Lambda function is called every time a new message is posted in the image-preprocessing topic. <br><br>  To do this, click SNS in the list of triggers, select image-preprocessing in the list of SNS topics, and click Add. <br><br><img src="https://habrastorage.org/webt/g5/3k/e0/g53ke0awvnf757_9eqiytwb4_4w.png"><br><br>  Now you need to load the code that will handle the S3 ObjectCreated event, which includes retrieving the downloaded image from the originals folder, processing it, and reloading it into the appropriate folders for the modified images. <br><br>  The code can be downloaded <a href="http://github.com/domangi/image-preprocessing-lambda">here</a> . <br><br>  The only element that needs to be loaded into the Lambda function is the <a href="">version1.1.zip</a> archive, which contains the index.js file and the node_modules folder. <br><br><img src="https://habrastorage.org/webt/dv/cy/2j/dvcy2jqvdrqyfjbujivhtgv9tmk.png"><br><br>  To provide the Lambda function with enough resources for image processing, you can increase the memory up to 256 MB, and the maximum execution time (timeout) up to 10 seconds.  The need for resources depends on the size of the image and the complexity of the transformations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/fj/cp/rmfjcptyyyfhw6ny0v749yi9t6e.png" alt="image"></div><br>  The code itself is fairly simple and designed to demonstrate AWS integration. <br><br>  First, the handler function (export.handler) is defined.  It is called by an external trigger.  In this case, a message published in SNS that contains the S3 key of the object of the loaded image. <br><br>  First of all, it analyzes the JSON text of the event message to extract the name of the S3 bucket, the S3 key of the object of the loaded image, and the file name (the last part of the key). <br><br>  After getting the name of the bucket and the object key, the loaded image is retrieved using the s3.getObject operation, and then passed to the function for resizing.  The variable SIZE contains the dimensions of the images to be obtained.  They correspond to the names of the S3 folders into which the converted images are loaded. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'async'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AWS = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'aws-sdk'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gm'</span></span>).subClass({ <span class="hljs-attr"><span class="hljs-attr">imageMagick</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AWS.S3(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SIZES = [<span class="hljs-string"><span class="hljs-string">"800x600"</span></span>, <span class="hljs-string"><span class="hljs-string">"400x300"</span></span>]; exports.handler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message, srcKey, dstKey, srcBucket, dstBucket, filename; message = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(event.Records[<span class="hljs-number"><span class="hljs-number">0</span></span>].Sns.Message).Records[<span class="hljs-number"><span class="hljs-number">0</span></span>]; srcBucket = message.s3.bucket.name; dstBucket = srcBucket; srcKey = message.s3.object.key.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\+/g</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>); filename = srcKey.split(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; dstKey = <span class="hljs-string"><span class="hljs-string">""</span></span>; ... ... <span class="hljs-comment"><span class="hljs-comment">// Download the image from S3 s3.getObject({ Bucket: srcBucket, Key: srcKey }, function(err, response){ if (err){ var err_message = 'Cannot download image: ' + srcKey; return console.error(err_message); } var contentType = response.ContentType; // Pass in our image to ImageMagick var original = gm(response.Body); // Obtain the size of the image original.size(function(err, size){ if(err){ return console.error(err); } // For each SIZES, call the resize function async.each(SIZES, function (width_height, callback) { var filename = srcKey.split("/")[1]; var thumbDstKey = width_height +"/" + filename; resize(size, width_height, imageType, original, srcKey, dstBucket, thumbDstKey, contentType, callback); }, function (err) { if (err) { var err_message = 'Cannot resize ' + srcKey; console.error(err_message); } context.done(); }); }); }); }</span></span></code> </pre><br>  The resize function converts the original image using the gm library, in particular, it changes the image size, cuts it if necessary and reduces the quality to 80%.  It then loads the modified image into S3, using the s3.putObject operation, and specifies the ACL: public-read to make the new image publicly available. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size, width_height, imageType, original, srcKey, dstBucket, dstKey, contentType, done</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.waterfall([ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width_height_values = width_height.split(<span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width = width_height_values[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> height = width_height_values[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Transform the image buffer in memory original.interlace("Plane") .quality(80) .resize(width, height, '^') .gravity('Center') .crop(width, height) .toBuffer(imageType, function(err, buffer) { if (err) { next(err); } else { next(null, buffer); } }); }, function upload(data, next) { console.log("Uploading data to " + dstKey); s3.putObject({ Bucket: dstBucket, Key: dstKey, Body: data, ContentType: contentType, ACL: 'public-read' }, next); } ], function (err) { if (err) { console.error(err); } done(err); } ); };</span></span></code> </pre><br><h3>  Step 6: Testing </h3><br>  Now you can check whether everything works correctly by uploading the image to the originals folder.  If everything was done correctly, we will get the corresponding converted versions of the downloaded image in folders 800x600 and 400x300. <br><br>  In the video below you can see three windows: on the left - the originals folder, in the middle - the 800x600 folder, and on the right - the 400x300 folder.  After uploading the file to the originals folder, the two other windows are updated to check if the images were created. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iiKm6UGHoWg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  And voila, here they are;) <br><br><h3>  (Optional) Step 7: Add Cloudfront Content Delivery Network </h3><br>  Now that the images are created and uploaded to S3, they need to be delivered to the end users.  To increase download speed, you can use the Cloudfront content delivery network.  For this: <br><br><ol><li>  Open <a href="https%253A%252F%252Fconsole.aws.amazon.com%252Fcloudfront%252Fhome%253Fstate%253DhashArgs%252523%2526isauthcode%253Dtrue%26client_id%3Darn%253Aaws%253Aiam%253A%253A015428540659%253Auser%252Fcloudfront%26forceMobileApp%3D0">the CloudFront page</a> . </li><li>  Click Create Distribution. </li><li>  When requesting a delivery method, select Web Distribution. </li><li>  In the Origin Domain Name field, select the required S3 batch and click Create Distribution. </li></ol><br>  The network creation process will take some time, so wait until the CDN status changes from <i>In Progress</i> to <i>Deployed</i> . <br><br>  After the network is deployed, you can use the domain name instead of the link to the S3 baket.  For example, if the name of your Cloudfront domain is <i>1234-cloudfront-id.cloudfront.net</i> , then you can access the processed images folder using the links <i><a href="https://1234-cloudfront-id.cloudfront.net/400x300/FILENAME">1234-cloudfront-id.cloudfront.net/400x300/FILENAME</a> and <a href="https://1234-cloudfront-id.cloudfront.net/800%25D1%2585600/FILENAME">1234-cloudfront-id.cloudfront .net / 800x600 / FILENAME</a></i> <br><br><img src="https://habrastorage.org/webt/da/mg/0g/damg0gfchbwp71cq1cttimjrgc8.png"><br><br>  There are many other important parameters in Cloudfront, but we will not consider them in this article.  For more detailed instructions on setting up your content delivery network, refer to <a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html">the Amazon Guide</a> . </div><p>Source: <a href="https://habr.com/ru/post/354394/">https://habr.com/ru/post/354394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354384/index.html">Made an attack on MyEtherWallet, through the interception of Amazon DNS service using BGP</a></li>
<li><a href="../354386/index.html">GDPR as a weapon of mass destruction</a></li>
<li><a href="../354388/index.html">Backend optimization when switching to api-based architecture</a></li>
<li><a href="../354390/index.html">Ubuntu 18.04 LTS: what's new?</a></li>
<li><a href="../354392/index.html">Solar JSOC Forensics: mining case on 32 non-existent hypervisors</a></li>
<li><a href="../354396/index.html">Open source and mentoring: writing code that saves lives</a></li>
<li><a href="../354398/index.html">rholang - programming language for distributed systems</a></li>
<li><a href="../354400/index.html">Epic Growth Story with Denis Pushkin: how does Growth Hacking work in Skyeng?</a></li>
<li><a href="../354406/index.html">You can not leave: about the difficult and often false choice</a></li>
<li><a href="../354408/index.html">Communication channels L2 and L3 VPN - Differences between physical and virtual channels of different levels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>