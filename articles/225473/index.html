<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cellular automata with komonad</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One evening I came across an article on the implementation of a one-dimensional cellular automaton using komonads, but the material is incomplete and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cellular automata with komonad</h1><div class="post__text post__text-html js-mediator-article">  One evening I came across an <a href="http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html">article</a> on the implementation of a one-dimensional cellular automaton using komonads, but the material is incomplete and a bit outdated, and therefore decided to write a Russian-language adaptation (at the same time having considered two-dimensional cellular automata on the example of Game of Life): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d9/aea/ce3/6d9aeace35043724a6e879062d9e6ddc.gif" alt="life_anim"><br><a name="habracut"></a><br><h2>  Universe </h2><br>  Consider the data type <code>Universe</code> , defined as follows: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe</span></span></span><span class="hljs-class"> [a] a [a]</span></span></code> </pre><br><br>  This is an endless list on both sides, but with a focus on a certain element that we can shift using functions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">left</span></span>, right :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Universe</span></span> a left (<span class="hljs-type"><span class="hljs-type">Universe</span></span> (a:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) x bs) = <span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a (x:bs) right (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> x (b:bs)) = <span class="hljs-type"><span class="hljs-type">Universe</span></span> (x:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) b bs</code> </pre><br><br>  In essence, this is a type of fastener ( <a href="http://learnyouahaskell.com/zippers">zipper</a> ), but we can regard it as a constant C-pointer to an infinite memory area: the increment and decrement operations apply to it.  But how to dereference it?  To do this, we define a function that has a focused value: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">extract</span></span> :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> a -&gt; a extract (<span class="hljs-type"><span class="hljs-type">Universe</span></span> _ x _) = x</code> </pre><br><br>  For example, <code>Universe [-1, -2..] 0 [1, 2..]</code> is all integers.  However, <code>Universe [0, -1..] 1 [2, 3..]</code> are the same integers, but with a slightly changed context (we point to another element). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d7/7dc/b85/2d77dcb854ccec2f9ca80709c5c20052.png" alt="integres_figure"><br><br>  If we want to get all degrees 2, we need a way to apply the function <code>(2**)</code> to the <code>Universe</code> integers.  It is easy to define an instance of the class Functor, which obeys all laws: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> x bs) = <span class="hljs-type"><span class="hljs-type">Universe</span></span> (fmap f <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) (fx) (fmap f bs) <span class="hljs-comment"><span class="hljs-comment">--  powersOf2 = fmap (2**) (Universe [-1, -2..] 0 [1, 2..]) -- ..0.25, 0.5, 1, 2, 4..</span></span></code> </pre><br><br>  In the cellular automaton, the values ‚Äã‚Äãof the cells depend on the values ‚Äã‚Äãof all the other cells in the previous step.  Therefore, we can create the <code>Universe</code> all shifts and the rule of their convolution: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">duplicate</span></span> :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Universe</span></span> (<span class="hljs-type"><span class="hljs-type">Universe</span></span> a) duplicate u = <span class="hljs-type"><span class="hljs-type">Universe</span></span> (tail $ iterate left u) u (tail $ iterate right u)</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/583/5b8/14b/5835b814bcbc17f86e3a4940a34c3f54.png" alt="duplicate_figure"><br><br>  The convolution rule must be of the type <code>Universe a -&gt; a</code> , so for the <code>Universe Bool</code> an example of a rule might be: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">rule</span></span> :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> rule u = lx /= cx <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lx = extract $ left u cx = extract u</code> </pre><br><br>  Applying the rule to the Universe of all shifts, we obtain the following state of the automaton: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">next</span></span> :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> a -&gt; (<span class="hljs-type"><span class="hljs-type">Universe</span></span> a -&gt; a) -&gt; <span class="hljs-type"><span class="hljs-type">Universe</span></span> a next ur = fmap r (duplicate u) <span class="hljs-comment"><span class="hljs-comment">--  un = Universe (repeat False) True (repeat False) `next` rule</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/553/16d/ebc/55316debc684c6d8fc1cccdf7aeca83a.gif" alt="1d_gif"><br><br><h2>  Komonad </h2><br>  We can notice that our functions are subject to the following laws: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">extract</span></span> . duplicate = id fmap extract . duplicate = id duplicate . duplicate = fmap duplicate . duplicate</code> </pre><br><br>  Therefore, the <code>Universe</code> forms a <a href="https://hackage.haskell.org/package/comonad">comonad</a> , and the <code>next</code> function <a href="https://hackage.haskell.org/package/comonad">corresponds to the</a> operator <code>(=&gt;&gt;)</code> .  Komonada is a dual monad, in connection with which one can trace some analogies between their operations.  For example, <code>join</code> combines nested contexts, and <code>duplicate</code> , on the contrary, doubles the context;  <code>return</code> puts context, <code>extract</code> extracts from it, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2aa/b71/f3e/2aab71f3e4a6d378bdc0f77555feb81c.png" alt="comonad_laws"><br><br><h2>  Two-dimensional cellular automaton </h2><br>  Now, we can equally well realize a two-dimensional cellular automaton.  First, let's declare the type of two-dimensional <code>Universe</code> : <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe2</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe2</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getUniverse2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br><br>  In Haskell, it is very easy to apply a function to nested containers using <code>fmap</code> composition, so writing an instance of the <code>Functor</code> class for <code>Universe2</code> will be no problem: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f = <span class="hljs-type"><span class="hljs-type">Universe2</span></span> . (fmap . fmap) f . getUniverse2</code> </pre><br><br>  An instance of a comonad is done in the same way as a regular Universe, and since Universe2 is only a wrapper, we can define methods in terms of those already available.  For example, <code>extract</code> simply enough to run twice.  In <code>duplicate</code> , however, we have to receive shifts of nested contexts, for which an auxiliary function is defined. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Comonad</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract = extract . extract . getUniverse2 duplicate = fmap <span class="hljs-type"><span class="hljs-type">Universe2</span></span> . <span class="hljs-type"><span class="hljs-type">Universe2</span></span> . shifted . shifted . getUniverse2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> shifted :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> (<span class="hljs-type"><span class="hljs-type">Universe</span></span> a) -&gt; <span class="hljs-type"><span class="hljs-type">Universe</span></span> (<span class="hljs-type"><span class="hljs-type">Universe</span></span> (<span class="hljs-type"><span class="hljs-type">Universe</span></span> a)) shifted u = <span class="hljs-type"><span class="hljs-type">Universe</span></span> (tail $ iterate (fmap left) u) u (tail $ iterate (fmap right) u)</code> </pre><br><br>  This is almost everything!  It remains only to define the rule and apply it with <code>(=&gt;&gt;)</code> .  In Game of Life, a new state of a cell depends on the state of neighboring cells, so we define the function of their location: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">nearest3</span></span> :: <span class="hljs-type"><span class="hljs-type">Universe</span></span> a -&gt; [a] nearest3 u = fmap extract [left u, u, right u] neighbours :: (<span class="hljs-type"><span class="hljs-type">Universe2</span></span> a) -&gt; [a] neighbours u = [ nearest3 . extract . left , pure . extract . left . extract , pure . extract . right . extract , nearest3 . extract . right ] &gt;&gt;= ($ getUniverse2 u)</code> </pre><br><br>  Here is the rule itself: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cell</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dead</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alive</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) rule :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Universe2</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cell</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cell</span></span></span><span class="hljs-class"> rule u | nc == 2 = extract u | nc == 3 = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alive</span></span></span><span class="hljs-class"> | otherwise = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dead</span></span></span><span class="hljs-class"> where nc = length $ filter (==</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alive</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">neighbours</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class">)</span></span></code> </pre><br><br>  There remains only a boring conclusion, which I will not consider separately. <br><br><h2>  Conclusion </h2><br>  Thus, we can implement any cellular automaton, just by defining the <code>rule</code> function.  We get an infinite field as a gift, thanks to lazy calculations, although this creates such a problem as linear memory consumption. <br>  The fact is that since we apply the rule to each element of the infinite list, it will be necessary to go through all the previous steps to compute the cells to which there has not yet been any appeal, which means they need to be stored in memory. <br><br>  Source codes of both files: <br><br><div class="spoiler">  <b class="spoiler_title">Universe.hs</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Universe <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Comonad data Universe a = Universe [a] a [a] newtype Universe2 a = Universe2 { getUniverse2 :: Universe (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) } left :: Universe a -&gt; Universe a left (<span class="hljs-type"><span class="hljs-type">Universe</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span>:<span class="hljs-title"><span class="hljs-title">as</span></span>) x bs) = Universe <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">bs</span></span>) right :: Universe a -&gt; Universe a right (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-title"><span class="hljs-title">as</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> (<span class="hljs-title"><span class="hljs-title">b</span></span>:<span class="hljs-title"><span class="hljs-title">bs</span></span>)) = Universe (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">as</span></span>) b bs makeUniverse fl fr x = Universe (<span class="hljs-title"><span class="hljs-title">tail</span></span> $ <span class="hljs-title"><span class="hljs-title">iterate</span></span> <span class="hljs-title"><span class="hljs-title">fl</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) x (<span class="hljs-title"><span class="hljs-title">tail</span></span> $ <span class="hljs-title"><span class="hljs-title">iterate</span></span> <span class="hljs-title"><span class="hljs-title">fr</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) instance Functor Universe where fmap f (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-title"><span class="hljs-title">as</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">bs</span></span>) = Universe (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">f</span></span> <span class="hljs-title"><span class="hljs-title">as</span></span>) (<span class="hljs-title"><span class="hljs-title">fx</span></span>) (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">f</span></span> <span class="hljs-title"><span class="hljs-title">bs</span></span>) instance Comonad Universe where duplicate = makeUniverse left right extract (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">_</span></span>) = x takeRange :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Universe a -&gt; [a] takeRange (<span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-title"><span class="hljs-title">b</span></span>) u = take (<span class="hljs-title"><span class="hljs-title">b</span></span>-<span class="hljs-title"><span class="hljs-title">a</span></span>+1) x where Universe _ _ x | a &lt; 0 = iterate left u !! (-<span class="hljs-title"><span class="hljs-title">a</span></span>+1) | otherwise = iterate right u !! (<span class="hljs-title"><span class="hljs-title">a</span></span>-1) instance Functor Universe2 where fmap f = Universe2 . (<span class="hljs-title"><span class="hljs-title">fmap</span></span> . <span class="hljs-title"><span class="hljs-title">fmap</span></span>) f . getUniverse2 instance Comonad Universe2 where extract = extract . extract . getUniverse2 duplicate = fmap Universe2 . Universe2 . shifted . shifted . getUniverse2 where shifted :: Universe (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; Universe (<span class="hljs-type"><span class="hljs-type">Universe</span></span> (<span class="hljs-type"><span class="hljs-type">Universe</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>)) shifted = makeUniverse (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>) (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) takeRange2 :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Universe2 a -&gt; [[a]] takeRange2 (<span class="hljs-title"><span class="hljs-title">x0</span></span>, <span class="hljs-title"><span class="hljs-title">y0</span></span>) (<span class="hljs-title"><span class="hljs-title">x1</span></span>, <span class="hljs-title"><span class="hljs-title">y1</span></span>) = takeRange (<span class="hljs-title"><span class="hljs-title">y0</span></span>, <span class="hljs-title"><span class="hljs-title">y1</span></span>) . fmap (<span class="hljs-title"><span class="hljs-title">takeRange</span></span> (<span class="hljs-title"><span class="hljs-title">x0</span></span>, <span class="hljs-title"><span class="hljs-title">x1</span></span>)) . getUniverse2</code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">Life.hs</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Comonad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Process (<span class="hljs-title"><span class="hljs-title">rawSystem</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Universe data Cell = Dead | Alive deriving (<span class="hljs-type"><span class="hljs-type">Eq</span></span>, <span class="hljs-type"><span class="hljs-type">Show</span></span>) nearest3 :: Universe a -&gt; [a] nearest3 u = fmap extract [left u, u, right u] neighbours :: (<span class="hljs-type"><span class="hljs-type">Universe2</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] neighbours u = [ nearest3 . extract . left , pure . extract . left . extract , pure . extract . right . extract , nearest3 . extract . right ] &gt;&gt;= ($ <span class="hljs-title"><span class="hljs-title">getUniverse2</span></span> <span class="hljs-title"><span class="hljs-title">u</span></span>) rule :: Universe2 Cell -&gt; Cell rule u | nc == 2 = extract u | nc == 3 = Alive | otherwise = Dead where nc = length $ filter (==<span class="hljs-type"><span class="hljs-type">Alive</span></span>) (<span class="hljs-title"><span class="hljs-title">neighbours</span></span> <span class="hljs-title"><span class="hljs-title">u</span></span>) renderLife :: Universe2 Cell -&gt; String renderLife = unlines . map concat . map (<span class="hljs-title"><span class="hljs-title">map</span></span> <span class="hljs-title"><span class="hljs-title">renderCell</span></span>) . takeRange2 (-7, -7) (20, 20) where renderCell Alive = "‚ñà‚ñà" renderCell Dead = " " fromList :: a -&gt; [a] -&gt; Universe a fromList d (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = Universe (<span class="hljs-title"><span class="hljs-title">repeat</span></span> <span class="hljs-title"><span class="hljs-title">d</span></span>) x (<span class="hljs-title"><span class="hljs-title">xs</span></span> ++ <span class="hljs-title"><span class="hljs-title">repeat</span></span> <span class="hljs-title"><span class="hljs-title">d</span></span>) fromList2 :: a -&gt; [[a]] -&gt; Universe2 a fromList2 d = Universe2 . fromList ud . fmap (<span class="hljs-title"><span class="hljs-title">fromList</span></span> <span class="hljs-title"><span class="hljs-title">d</span></span>) where ud = Universe (<span class="hljs-title"><span class="hljs-title">repeat</span></span> <span class="hljs-title"><span class="hljs-title">d</span></span>) d (<span class="hljs-title"><span class="hljs-title">repeat</span></span> <span class="hljs-title"><span class="hljs-title">d</span></span>) cells = [ [ Dead, Alive, Dead] , [Alive, Dead, Dead] , [Alive, Alive, Alive] ] main = do gameLoop $ fromList2 Dead cells gameLoop :: Universe2 Cell -&gt; IO a gameLoop u = do getLine rawSystem "clear" [] putStr $ renderLife u gameLoop (<span class="hljs-title"><span class="hljs-title">u</span></span> =&gt;&gt; <span class="hljs-title"><span class="hljs-title">rule</span></span>)</code> </pre> <br></div></div><br><br>  Thanks <a href="https://habrahabr.ru/users/int_index/" class="user_link">int_index</a> for help in preparing the article. </div><p>Source: <a href="https://habr.com/ru/post/225473/">https://habr.com/ru/post/225473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225459/index.html">Tips on maintaining a mobile application for a novice developer</a></li>
<li><a href="../225463/index.html">Classcraft turns school lessons into a huge role-playing game - with a shareware model.</a></li>
<li><a href="../225465/index.html">WWDC 2014. Report for Thursday</a></li>
<li><a href="../225469/index.html">Recoder - another look at the NSI</a></li>
<li><a href="../225471/index.html">Mover.io: service for cloud migrations</a></li>
<li><a href="../225477/index.html">Gamers are more educated and sociable than those who laugh at them</a></li>
<li><a href="../225479/index.html">M-LAG as an alternative to STP and stack</a></li>
<li><a href="../225481/index.html">Parsing the address bar (street [house]) using Golang and Postgis</a></li>
<li><a href="../225483/index.html">Wi-Fi networks: penetration and protection. 2) Kali. Hiding SSID. MAC filtering. WPS</a></li>
<li><a href="../225485/index.html">3D printer head. Three components and three sources. On the road to excellence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>