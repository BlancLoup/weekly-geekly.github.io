<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Centralized collection and processing of Windows print logs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In small offices, network printers and multifunction printers are not always used; therefore, it is rather difficult to obtain statistics on the use o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Centralized collection and processing of Windows print logs</h1><div class="post__text post__text-html js-mediator-article">  In small offices, network printers and multifunction printers are not always used; therefore, it is rather difficult to obtain statistics on the use of printing devices.  Especially, if it is required to produce with minimal cost.  Such data can help identify the most actively used devices, assess the load on them, and make timely decisions on the purchase of consumables, maintenance, or even replacement with more economical and productive ones.  This task can be solved without additional software using the built-in management tools for Windows logs and Powershell script. <br><a name="habracut"></a><br>  Using search engines you can find ready-made software products for auditing printing in the office, for example: <br><ul><li>  <a href="http://www.papercut.com/products/free_software/print_logger/">www.papercut.com/products/free_software/print_logger</a> </li><li>  <a href="http://www.printaudit.com/print-audit-6.asp">www.printaudit.com/print-audit-6.asp</a> </li></ul>  Such systems are far from always suitable, as they require a purchase, free versions have limited functionality, it is necessary to install both central software on the server and agents on client computers, some programs work only with a print server, and so on.  I suggest using the built-in tools of the Windows 7 / 2008R2 operating system and Powershell scripts to solve the problem. <br><br>  So, let's take the following information as the source data: <br><ul><li>  The organization has an Active Directory domain. </li><li>  The organization uses computers with an operating system of at least Windows 7, a server with an operating system of at least Windows Server 2008R2 </li><li>  There are both network and local printers and MFPs. </li><li>  There is a need to centrally handle print logs from printers and to have statistics on the use and load on printers. </li></ul><br><h3>  Infrastructure preparation </h3><br>  The first step is to prepare the infrastructure for centrally collecting event logs from client computers. <br>  For the Windows event subscription to work on the source computer, the following settings are required: <br><ol><li>  User presence in the <b>Event Log Readers</b> group, on whose behalf the log will be read </li><li>  Remote control access (Windows Remote Management from the collector server </li><li>  Configured permission to forward events to the log collector server. </li><li>  Print event log enabled (disabled by default) </li></ol><br>  Create a new user in the Users and Computers snap-in, and specify EventCollectorUser as the full name and login.  We assign a complex password and put the checkboxes ‚ÄúForbid changing the password by the user‚Äù and ‚ÄúPassword validity is unlimited‚Äù. <br><br>  Next, create a new group policy on the domain controller and call it, for example, GPO-EventCollector. <br>  In the policy we set the following parameters: <br><ol><li>  In the section " <i>Computer Configuration - Settings - Control Panel Settings - Services</i> " create a service entry " <i>Startup: Automatic (Delayed Start)</i> ", " <i>Service Name</i> - Windows Remote Management Service (MS-Management) (WinRM)", " <i>Service Action</i> : Start services " </li><li>  In the section " <i>Computer Configuration - Policies - Administrative Templates - Windows Components - Windows Remote Management - Windows Remote Management Service</i> " set the " <i>Allow automatic configuration of listeners</i> : Enable" option and set the "IPv4 Filter" section to the value "*". </li><li>  In the section ‚Äú <i>Computer Configuration - Policies - Windows Configuration - Security Settings - Windows Firewall with Advanced Security - Windows Firewall with Advanced Security - Inbound Rules</i> ‚Äù create a new rule.  Select the item ‚Äú <i>Predefined rules</i> ‚Äù and in the list select ‚Äú <i>Windows Remote Control (HTTP - incoming traffic)</i> ‚Äù </li><li>  In the ‚Äú <i>Computer Configuration - Policies - Administrative Templates - Windows Components - Event Forwarding</i> ‚Äù section, set the ‚Äú <i>Configure Subscription Manager</i> ‚Äù option and in the ‚Äú <i>SubscriptionManagers</i> ‚Äù section enter the full FQDN path to the server ‚Äì collector. </li><li>  In the section " <i>Computer Configuration - Policies - Windows Configuration - Security Settings - Restricted Access Groups</i> " we add a new group " <i>Event Log Readers</i> ".  We add the EventCollectorUser user created by us to the group members. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After creating the group policy, you must restart the target computers or execute the <b>gpupdate / force</b> command on them. <br><br>  You can enable the print log on the target computer using the Event Viewer MMC snap-in, under the path ‚Äú <i>Applications and Services Logs ‚Äî Microsoft ‚Äî Windows ‚Äî PrintService ‚Äî Works</i> ‚Äù (right-click on the log and select ‚Äúenable‚Äù).  This option is suitable if there are not so many computers. <br>  In case you need to enable the log on a large group of PCs, you can use the following method: <br><ol><li>  Prepare a text file with a list of computer names.  For example, d: \ temp \ computers.txt </li><li>  Run the following command as a user with domain administrator rights: <br>  For / F% i in (d: \ temp \ computers.txt) do wevtutil sl Microsoft-Windows-PrintService / Operational / e: true / r:% i </li></ol><br><br>  <b>Update:</b> Also, as <a href="http://habrahabr.ru/users/nesvist/" class="user_link">NeSvist</a> correctly noted, you can install the registry key: <br>  HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows \ CurrentVersion \ WINEVT \ Channels \ Microsoft-Windows-PrintService / Operational - Enabled equal to 1. <br>  This parameter can be distributed in the group policy that we created above. <br>  For reference: <a href="https://dimanb.wordpress.com/2011/07/06/gp-pref-05/">About working with the registry in GPO</a> <br><br><h3>  Creating an event subscription </h3><br>  After preparing the infrastructure, you can proceed directly to setting up a subscription to events on the collector server. <br><ol><li>  Go to the " <i>Event Viewer - Subscriptions</i> " snap-in. </li><li>  Choose on the right in the menu " <i>Create a subscription ...</i> " </li><li>  Enter the subscription name, for example, ‚ÄúTest Subscription‚Äù.  Add a clear description. </li><li>  Next, select the log, which will receive received events.  I recommend leaving everything by default - ‚ÄúForwarded Events‚Äù.  It is worth noting that I did not manage to find a way to place events in a manually created log.  So the default option is almost the only one. </li><li>  Next, click on the button " <i>Select computers ...</i> ".  In the window that opens, click the "Add" button to add the necessary source computers.  Using the ‚ÄúCheck‚Äù button you can check the availability of the target machines using the remote control protocol, the result will be shown in the information window. </li><li>  We select events which we will collect from sources.  We are interested in the level of events ‚ÄúInformation‚Äù from the ‚Äú <i>Microsoft-Windows-PrintService / Works</i> ‚Äù log with event code 307. All other settings are left as default. </li><li>  We click on the "Advanced" button, in the window that opens, select the "specific user" item and specify the user we created and his password.  The settings for optimizing the delivery of events are left in the ‚ÄúNormal‚Äù position. </li><li>  Click "OK" and the subscription is created.  When events appear in the log of source computers, they will be uploaded to the collector server in the ‚ÄúForwarded Events‚Äù log for 15 minutes. </li></ol><br><h3>  Script for processing collected events </h3><br>  Collected events can be downloaded in the CSV format using the ‚ÄúEvent Viewer‚Äù snap-in, but the data obtained will not be very informative and will not allow obtaining interesting statistics on their basis that can be shown to management.  Therefore, I propose a variant of processing received events with Powershell for ease of further use. <br>  A search log analysis script for Windows Server 2003 was found by searching the Internet. (Http://trevorsullivan.net/2009/11/06/windows-2003-print-log-parsing-script-powershell/) Since there are certain differences in the Powershell cmdlets of the new versions, and the method of receiving events differs from the one proposed in the article, the script was reworked by me. <br>  I did not change the general structure of the script, it is divided into functions that are easy to modify (in the case of localization, for example).  The logic of the script is as follows: <br><ol><li>  Get a list of events from the log </li><li>  Parsing the Message property of each event and writing fields to the PrintJob object. </li><li>  Save the resulting list of objects in CSV format </li></ol><br><br>  We receive a list of events from the ‚ÄúForwarded Events‚Äù log by code 307 (in case any other events are sent to the specified log). <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPrintEntriesFromLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { $PrintEntries = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>-winevent -FilterHashTable @{LogName=<span class="hljs-string"><span class="hljs-string">'ForwardedEvents'</span></span>; ID=<span class="hljs-number"><span class="hljs-number">307</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $PrintEntries }</code> </pre> <br>  Create a new PrintJob object.  Add the required fields to it. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePrintJob</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { $PrintJob = New-Object PsObject Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name PageCount -Value $<span class="hljs-literal"><span class="hljs-literal">null</span></span> Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name UserName -Value $<span class="hljs-literal"><span class="hljs-literal">null</span></span> Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name DocumentName -Value $<span class="hljs-literal"><span class="hljs-literal">null</span></span> Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name Size -Value $<span class="hljs-literal"><span class="hljs-literal">null</span></span> Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name Printer -Value $<span class="hljs-literal"><span class="hljs-literal">null</span></span> Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name Time -Value $<span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $PrintJob }</code> </pre></div></div><br>  From the <b>Message</b> property, we <b>get the</b> event field <b>User name, Printer name, Number of printed pages in the document, Document name.</b>  We take it all out of the line with regular expressions.  In the case of an English magazine, we change the lines in the regular expressions to others, respectively. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#   Function ParsePrintEntry($PrintEntry) { $NewPrintJob = CreatePrintJob $NewPrintJob.PageCount = GetPageCount $PrintEntry.Message $NewPrintJob.UserName = GetUserName $PrintEntry.Message $NewPrintJob.DocumentName = GetDocumentName $PrintEntry.Message $NewPrintJob.Size = GetPrintSize $PrintEntry.Message $NewPrintJob.Printer = GetPrinterName $PrintEntry.Message $NewPrintJob.Time = $PrintEntry.TimeCreated.ToString() return $NewPrintJob } #   Function GetUserName($PrintEntry) { If ($PrintEntry -eq "" -or $PrintEntry -eq $null) { return $null } $rxUserName = [regex]"  ([0-9a-zA-Z.]{1,})" $rxMatches = $rxUserName.Match($PrintEntry) return $rxMatches.Groups[1].Value } #   Function GetPrinterName($PrintEntry) { If ($PrintEntry -eq "" -or $PrintEntry -eq $null) { return $null } $rxPrinterName = [regex]"  (.{1,}) " $rxMatches = $rxPrinterName.Match($PrintEntry) return $rxMatches.Groups[1].Value } #     Function GetPrintSize($PrintEntry) { If ($PrintEntry -eq "" -or $PrintEntry -eq $null) { return $null } $rxPrintSize = [regex]"  : ([0-9]+)." $rxMatches = $rxPrintSize.Match($PrintEntry) return $rxMatches.Groups[1].Value } #   (  ) Function GetPageCount($PrintEntry) { If ($PrintEntry -eq "" -or $PrintEntry -eq $null) { return $null } $rxPageCount = [regex]" : ([0-9]+)" $rxMatches = $rxPageCount.Match($PrintEntry) return $rxMatches.Groups[1].Value } #   Function GetDocumentName($PrintEntry) { If ($PrintEntry -eq "" -or $PrintEntry -eq $null) { return $null } $rxDocumentName = [regex]", (.{1,})  " $rxMatches = $rxDocumentName.Match($PrintEntry) return $rxMatches.Groups[1].Value }</span></span></code> </pre><br></div></div><br>  The main function.  We get a list of events and turn it into a PrintJob object in a loop.  Then we export the list of objects to the specified file.  We put the UTF8 encoding for correct display of the Cyrillic alphabet and the separator ";" for readable opening of the file in Excel.  Every 100 events we write a log, it is convenient when debugging. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { $PrintEntries = GetPrintEntriesFromLog $Global:ParsedEntries = @{}; $i = <span class="hljs-number"><span class="hljs-number">0</span></span> ForEach ($PrintEntry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $PrintEntries) { $ParsedEntries.Add($i, $(ParsePrintEntry $PrintEntry)) $i++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($i % <span class="hljs-number"><span class="hljs-number">100</span></span> -eq <span class="hljs-number"><span class="hljs-number">0</span></span>) { Write-Host <span class="hljs-string"><span class="hljs-string">"Processed $i records"</span></span> } } $ParsedEntries.Values | Export-Csv <span class="hljs-string"><span class="hljs-string">"D:\PrintReports\PrintUsageReport.csv"</span></span> -NoTypeInformation -Encoding UTF8 -Delimiter <span class="hljs-string"><span class="hljs-string">';'</span></span> } <span class="hljs-meta"><span class="hljs-meta">#  . Main</span></span></code> </pre><br>  When preparing regular expressions for the script, the site <a href="http://regex101.com/">Regex101.com was used</a> .  The site is understandable, with brief documentation, highlighting the search result in the source line, decoding the meaning of a regular expression on the fly.  Very informative and convenient, it is recommended to use. <br>  The resulting script can be used on demand by launching the PowerShell in the command shell, or it can be assigned as a task in the Task Scheduler. <br>  For this you need: <br><ol><li>  Open Task Scheduler ( <i>Start - Administration - Task Scheduler</i> ) </li><li>  Select " <i>Create a simple task ...</i> " </li><li>  Enter task name, description, select execution interval </li><li>  Select the action " <i>run the program</i> ."  As a program, select ‚ÄúC: \ Windows \ System32 \ WindowsPowerShell \ v1.0 \ powershell.exe‚Äù, and the path to the script as an argument. </li><li>  Open the task properties and set the ‚ÄúExecute regardless of user registration‚Äù switch, select the user on whose behalf the task should be executed and enter the password for it. </li></ol><br>  Thus, in the directory specified when creating the script, the file from the list of printed documents will be updated at a specified interval. <br><br><h3>  Problem solving </h3><br><ol><li>  If an error of the following type occurs when starting the script: <br><blockquote>  The file D: \ PrintReports \ PrintInfo.ps1 could not be loaded because script execution is disabled on this system.  For more <br>  For information, see about_Execution_Policies at <a href="http://go.microsoft.com/fwlink/%3FLinkID%3D135170">go.microsoft.com/fwlink/?LinkID=135170</a> . <br>  + CategoryInfo: Security Error: (:) [], ParentContainsErrorRecordException <br>  + FullyQualifiedErrorId: UnauthorizedAccess <br></blockquote>  This means that the security policy for executable Powershell scripts does not allow starting the program.  To run the created script, you need to lower the security level to ‚Äú <b>Remote Signed</b> ‚Äù, that is, you will be allowed to run any scripts created locally, and scripts created on remote systems are executed only if signed by a trusted publisher.  To do this, in the Powershell console running as an administrator, you must run the <b>Set-ExecutionPolicy RemoteSigned command.</b> </li><li>  You can use the eventcreate.exe command line tool to test the forwarding and collection of events.  This utility allows you to create events manually in a specific log.  For example, you can create an event with ID 100 in the Application log using the following command: <i>eventcreate / t error / id 100 / l application / d "Custom event"</i> .  If everything is configured correctly and there is a collection of events from the specified log, the event will be on the server collector within a minute. <br>  If the event does not hit the collector server, you need to check the following: <br><ul><li>  If the parameters were set by group policy, then check that the policy is applied.  If necessary, you can enforce group policy with the gpupdate / force command </li><li>  The status of the Windows Remote Management (WinRM) service (Windows Remote Management Service).  The service must be started and configured to start automatically.  If necessary, this service can be configured on the client computer using the <b>winrm quickconfig command</b> .  This command configures the WinRM service, creates a winrm listener, and creates a firewall exception rule. <br>  To verify that the collector server can connect to the source computer using WinRM, you can use the following command: <b>winrm id -remote: &lt;Target computer name&gt; -u: &lt;Username&gt; -p: &lt;Password&gt;</b> .  Specify the account and password of the user who has the ability to connect via winrm. </li><li>  The EventCollectorUser user is a member of the Event Log Readers group.  Only members of this group can read events on a specific computer. </li></ul><br></li></ol><br><h3>  What can be improved </h3><br>  The proposed processing script is not a universal solution and can be improved in various directions, for example, <br><ul><li>  Selection of events by time (day, week, month) and writing them into the corresponding individual sheets of the spreadsheet or output CSV files.  It is possible to envisage setting the date range using the input parameters of the script. </li><li>  Add a graphical representation of data using summary tables for users and printing devices and graphs.  Such a report can be immediately put on the table to the head. </li><li>  Set up archiving and rotation of the ‚ÄúForwarded Events‚Äù log, add the function of analyzing the corresponding archive files.  It will be reasonable when working with a sufficiently large number of computers (over 50). </li></ul><br>  So, in this article I tried to show the principle of centralized collection of events from Windows logs and their further processing with Powershell.  This method is suitable for solving problems in small organizations.  Of course, specialized software copes with its goals more efficiently, but it is expensive, more cumbersome, its installation brings an IT specialist less new knowledge and skills, and an understanding of the work of the software they serve. <br><br>  The following materials and sources were used in the preparation of this article: <br><ol><li>  <a href="http://mcp.su/windows-server-2008/event-collector-in-windows-server-2008/">mcp.su/windows-server-2008/event-collector-in-windows-server-2008</a> </li><li>  <a href="http://windowsnotes.ru/powershell-2/nastrojka-udalennogo-vzaimodejstviya-v-powershell-chast-1/">windowsnotes.ru/powershell-2/nastrojka-udalennogo-vzaimodejstviya-v-powershell-chast-1</a> </li><li>  <a href="https://social.technet.microsoft.com/Forums/en-US/8e7399f6-ffdc-48d6-927b-f0beebd4c7f0/enabling-print-history-through-group-policy%3Fforum%3Dwinserverprint">social.technet.microsoft.com/Forums/en-US/8e7399f6-ffdc-48d6-927b-f0beebd4c7f0/enabling-print-history-through-group-policy?forum=winserverprint</a> </li><li>  <a href="https://mywinsysadm.wordpress.com/2012/07/16/powershell-audit-printer-event-logs/">mywinsysadm.wordpress.com/2012/07/16/powershell-audit-printer-event-logs</a> </li><li>  <a href="http://www.winblog.ru/admin/1147767392-29031101.html">www.winblog.ru/admin/1147767392-29031101.html</a> </li><li>  <a href="http://windowsitpro.com/security/q-what-are-some-simple-tips-testing-and-troubleshooting-windows-event-forwarding-and-collec">windowsitpro.com/security/q-what-are-some-simple-tips-testing-and-troubleshooting-windows-event-forwarding-and-collec</a> </li></ol><br><br><anchor>  <b>Update:</b> </anchor>  As noted by <a href="http://habrahabr.ru/users/nesvist/" class="user_link">NeSvist</a> and <a href="http://habrahabr.ru/users/selenite/" class="user_link">selenite</a> , binding to a specific localization and parsing it with regular expressions is not the most effective solution.  In this regard, I give the option of processing the collected events using their representation in XML.  The solution was more accurate and understandable. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#     $Events = Get-Winevent -FilterHashTable @{LogName='ForwardedEvents'; ID=307;} #    $Jobs = @() ForEach ($Event in $Events) { #   XML $eventXML = [xml]$Event.ToXml() #          XML-  $PrintJob = New-Object PsObject Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name PageCount -Value $eventXML.Event.UserData.DocumentPrinted.Param8 Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name UserName -Value $eventXML.Event.UserData.DocumentPrinted.Param3 Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name DocumentName -Value $eventXML.Event.UserData.DocumentPrinted.Param2 Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name Size -Value $eventXML.Event.UserData.DocumentPrinted.Param7 Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name Printer -Value $eventXML.Event.UserData.DocumentPrinted.Param5 #     SystemTime   . $date = Get-Date $eventXML.Event.System.TimeCreated.SystemTime Add-Member -Force -InputObject $PrintJob -MemberType NoteProperty -Name Time -Value $date #      $Jobs += $PrintJob } #       CSV $Jobs | Export-Csv D:\PrintReports\events.csv -NoTypeInformation -Encoding UTF8 -Delimiter ';'</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/257297/">https://habr.com/ru/post/257297/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257285/index.html">Cards, money, two stars</a></li>
<li><a href="../257287/index.html">Head Unit - as a target for a hacker</a></li>
<li><a href="../257291/index.html">Fix corrupted MySQL tables with myisamchk</a></li>
<li><a href="../257293/index.html">Attackers use Linux / Mumblehard to compromise servers, part 2</a></li>
<li><a href="../257295/index.html">Just about corporate IaaS: what it is, for whom, and how it is paid</a></li>
<li><a href="../257299/index.html">How clouds have changed the architecture of data centers</a></li>
<li><a href="../257301/index.html">2.5 million views - did you work well? Time to go on</a></li>
<li><a href="../257303/index.html">Processing and display of signals at the conversion frequency of the ADC</a></li>
<li><a href="../257305/index.html">Implementing Private Fields with WeakMap in JavaScript</a></li>
<li><a href="../257307/index.html">A meeting on Atlassian products took place in Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>