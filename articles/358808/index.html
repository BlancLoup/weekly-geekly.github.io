<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Promise guide for those who want to understand them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The forest is wonderful, dark - look at the depths. 
 But first, I will return all debts ... 
 And many miles, until I fall asleep, 
 So many miles, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Promise guide for those who want to understand them</h1><div class="post__text post__text-html js-mediator-article">  <i>The forest is wonderful, dark - look at the depths.</i> <i><br></i>  <i>But first, I will return all debts ...</i> <i><br></i>  <i>And many miles, until I fall asleep,</i> <i><br></i>  <i>So many miles, until I fall asleep ...</i> <br>  <sup>Robert Frost</sup> <br><br> <a href="https://habr.com/company/ruvds/blog/358808/"><img src="https://habrastorage.org/getpro/habr/post_images/397/f6e/2b8/397f6e2b82f54cf21c5e4b995fa32668.jpg" alt="image"></a> <br><br>  Promises are one of the most exciting innovations of ES6.  JavaScript supports asynchronous programming via callback functions and <a href="http://exploringjs.com/es6/ch_async.html">other mechanisms</a> .  However, when using callback functions, we run into some problems.  Among them - " <a href="http://callbackhell.com/">hell kollbekov</a> " and " <a href="https://en.wikipedia.org/wiki/Pyramid_of_doom_%2528programming%2529">pyramid of horror</a> ."  Promises are a pattern that greatly simplifies asynchronous programming on JS.  Asynchronous code written using promises looks like synchronous and devoid of problems associated with callbacks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The material, the translation of which we are publishing today, is dedicated to promises and their practical use.  It is designed for novice developers who want to deal with promises. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What is promis?</font> </h2><br>  Here is the definition of promises given by ECMA: ‚ÄúPromis is an object that is used as a placeholder for a possible future outcome of deferred (and possibly asynchronous) calculations. <br><br>  Simply put - promise is a container for some future value.  It is worth noting that often speaking of promises, they are called ‚Äúpromises‚Äù and ‚Äúpromised results.‚Äù  If you think a little, it‚Äôs like people use the word ‚Äúpromise‚Äù in everyday life.  For example, you booked a plane ticket that flies to India.  There you are going to visit the beautiful mountain station <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B0%25D1%2580%25D0%25B4%25D0%25B6%25D0%25B8%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B3_(%25D0%25B3%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B4)">Darjeeling</a> .  After completing the booking process, you receive a ticket.  This ticket, in fact, is the promise of the airline to give you a seat on the plane the day you want to go.  In general, a ticket is a placeholder for future values, namely, for a seat in an airplane. <br><br>  Here is another example.  You promised a friend that you would return his book The <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">Art of Programming</a> to him after you read it.  In this case, the placeholder is your words.  And the ‚Äúfuture result‚Äù is a book. <br><br>  In ordinary life, you can find other similar situations.  For example, waiting at the receptionist, ordering food in a restaurant, issuing a book in the library, and many others.  All of these situations include some form of promise.  Perhaps we gave fairly simple examples, so <a href="https://news.ycombinator.com/item%3Fid%3D902216">let's deal with the code</a> . <br><br><h2>  <font color="#3AC1EF">Creating promises</font> </h2><br>  Promises are created in situations where it is not possible to say exactly how long it takes to perform an operation, or it is expected that this operation will take a very long time.  For example, a network request may take from 10 to 200 ms, depending on the connection speed.  We do not want to wait for the receipt of this data.  For a person, 200 ms is very little, but for a computer it is a very significant length of time.  Promises simplify and facilitate the solution of such problems. <br><br>  A new promise can be created by resorting to the <code>Promise</code> designer.  It looks like this. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">100</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">90</span></span>) {       resolve(<span class="hljs-string"><span class="hljs-string">'Hello, Promises!'</span></span>);   }   reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'In 10% of the cases, I fail. Miserably.'</span></span>)); });</code> </pre> <br>  Notice that the constructor takes a function with two parameters.  This function is called the executor function, it describes the calculations that must be performed.  Parameters are usually called <code>resolve</code> and <code>reject</code> , they are, respectively, used to indicate the successful and unsuccessful completion of the performing function. <br><br>  The <code>resolve</code> and <code>reject</code> parameters are also functions, they are used to return values ‚Äã‚Äãto the promise object.  If the calculation succeeds, or the future value is ready, we send this value using the <code>resolve</code> function.  In such a situation they talk about the successful resolution of promis. <br><br>  If the calculations could not be performed or an error occurred during the work, we report this by passing the error object to the <code>reject</code> function.  In this case, they say that promis is rejected.  Actually, the <code>reject</code> function accepts any value, however, it is recommended to pass an <code>Error</code> object to it, as this helps during debugging during stack tracing. <br><br>  In our example, the <code>Math.random()</code> function is used to generate random numbers.  In 90% of cases, based on the equal probability of issuing different random numbers, the promise will be resolved.  In other cases, it will be rejected. <br><br><h2>  <font color="#3AC1EF">Use of promises</font> </h2><br>  Above, we created a promise and saved a link to it in <code>myPromise</code> .  How to get access to the values ‚Äã‚Äãpassed by the functions <code>resolve</code> and <code>reject</code> ?  The <code>.then()</code> function, which is available to all promises, will help us with this.  Take a look at how to work with her. <br><br><pre> <code class="hljs coffeescript">const myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.random() * <span class="hljs-number"><span class="hljs-number">100</span></span> &lt; <span class="hljs-number"><span class="hljs-number">90</span></span>) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'resolving the promise ...'</span></span>);       resolve(<span class="hljs-string"><span class="hljs-string">'Hello, Promises!'</span></span>);   }   reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'In 10% of the cases, I fail. Miserably.'</span></span>)); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   const onResolved = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolvedValue)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolvedValue); const onRejected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); myPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(onResolved, onRejected); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      myPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolvedValue)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolvedValue); }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ( <span class="hljs-number"><span class="hljs-number">90</span></span>% ) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> resolving the promise ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Hello, Promises! <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Hello, Promises!</code> </pre> <br>  The <code>.then()</code> method accepts two callback functions.  The first is called when promise is enabled.  The second is performed if the promis is rejected. <br><br>  Notice the two functions, <code>onResolved</code> and <code>onRejected</code> .  In the role of callback functions, they are passed to the <code>.then()</code> method.  You can write the same shorter, it is shown in the same example below.  The capabilities of such a design do not differ from those of the one where the functions were described before transferring them <code>.then()</code> . <br><br>  Here I would like to pay special attention to several important things.  We created a myPromise <code>myPromise</code> .  Then we doubled the <code>.then()</code> handler to it.  Both the one and the other have the same functionality, but they are perceived as different entities.  In this regard, the following should be noted: <br><br><ul><li>  Promis may be resolved or rejected only once.  It cannot be resolved twice, it cannot be rejected twice, and after it is allowed or rejected, its state cannot be reversed. </li><li>  If the promise was resolved or rejected, and the corresponding callback (that is,. <code>then()</code> ) was added to it after this event, then the correct callback function would be called, although the promise was allowed or rejected before the connection <code>.then()</code> . </li></ul><br>  All this means that as soon as the promise reaches its final state, this state does not change (that is, the calculations are not performed again) even if you connect several <code>.then()</code> handlers to the promise. <br><br>  To check this, you can take a look at the <code>console.log()</code> call at the very beginning of the example.  When the code is run and two <code>.then()</code> handlers are attached to it, the <code>console.log()</code> call will be executed only once.  This indicates that promis caches the result and, when another <code>.then()</code> connected, does the same. <br><br>  Another important thing to pay attention to is that promises use a strategy of <a href="https://en.wikipedia.org/wiki/Eager_evaluation">energetic calculations</a> .  With this approach, calculations in promis begin immediately after it is declared and the reference to it is written to a variable.  There are no methods like <code>.start()</code> or <code>.begin()</code> that could be used to force the promise to run.  In the previous example, this is exactly what happens. <br><br>  In order to make the processing of promises used a strategy of lazy calculations, so that they are not called instantly, they are wrapped in a function.  We will talk about this later. <br><br><h2>  <font color="#3AC1EF">Error handling in promises</font> </h2><br>  Until now, in order not to complicate the narration, we have considered only cases of successful resolution of the promises.  Let's talk now about what happens when an error occurs in the execution function.  In this situation, the second callback <code>.then()</code> is called, that is, the <code>onRejected</code> function.  Consider an example. <br><br><pre> <code class="hljs coffeescript">const myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.random() * <span class="hljs-number"><span class="hljs-number">100</span></span> &lt; <span class="hljs-number"><span class="hljs-number">90</span></span>) {   reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'The promise was rejected by using reject function.'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'The promise was rejected by throwing an error'</span></span>); }); myPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'resolved'</span></span>), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error.message) ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ( <span class="hljs-number"><span class="hljs-number">90</span></span>% ) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> The promise was rejected <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> using reject function.</code> </pre> <br>  The example is exactly the same as the previous one, with the difference that the promise will now be rejected with a probability of 90% and will give an error in the remaining 10% of cases. <br><br>  Here the <code>onResolved</code> and <code>onRejected</code> callback functions are declared.  Please note that the onRejected <code>onRejected</code> will be executed even if an error is thrown during the execution of the promise code.  There is no need to explicitly reject the promise by passing the object of the error to the <code>reject</code> function.  That is, the promise will be rejected in both cases. <br><br>  Since error handling is a prerequisite for developing reliable programs, there is a special mechanism for working with errors in promises.  Instead of writing something like <code>.then(null, () =&gt; {...})</code> , if we need to handle errors, we can use the <code>.catch(onRejected)</code> construct, which accepts one callback - <code>onRejected</code> .  This is how the new fragment of the above code will look when adding this mechanism to it. <br><br><pre> <code class="hljs coffeescript">myPromise.<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error.message) );</code> </pre> <br>  Remember that <code>.catch()</code> , in fact, just ‚Äú <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> ‚Äù for <code>.then(undefined, onRejected)</code> . <br><br><h2>  <font color="#3AC1EF">Combination of promises in chains</font> </h2><br>  The methods <code>.then()</code> and <code>.catch()</code> always return promises.  Therefore, you can combine multiple <code>.then()</code> calls into chains.  Let's sort it out by example. <br><br>  First, create a <code>delay()</code> function that returns a promise.  Returned promis will be resolved after a specified time.  This is what this function looks like. <br><br><pre> <code class="hljs lisp">const delay = (<span class="hljs-name"><span class="hljs-name">ms</span></span>) =&gt; new Promise( (<span class="hljs-name"><span class="hljs-name">resolve</span></span>) =&gt; setTimeout(<span class="hljs-name"><span class="hljs-name">resolve</span></span>, ms) )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  In this example, we use the function to wrap a promise in it, with the result that the promise will not be executed immediately.  The <code>delay()</code> function takes, as a parameter, the time expressed in milliseconds.  The executing function has access to the <code>ms</code> parameter due to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">closure</a> .  Here, in addition, there is a call to <code>setTimeout()</code> , which calls the <code>resolved</code> function after the specified number of milliseconds has passed, which leads to resolution of promise.  Here is how to use this feature. <br><br><pre> <code class="hljs coffeescript">delay(<span class="hljs-number"><span class="hljs-number">5000</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Resolved after 5 seconds'</span></span>));</code> </pre> <br>  And here is how to combine several <code>.then()</code> calls into a chain. <br><br><pre> <code class="hljs coffeescript">const delay = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ms)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(resolve, ms) ); delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Resolved after 2 seconds'</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay(<span class="hljs-number"><span class="hljs-number">1500</span></span>); }) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Resolved after 1.5 seconds'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay(<span class="hljs-number"><span class="hljs-number">3000</span></span>); }).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Resolved after 3 seconds'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); }).<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caught an error.'</span></span>); }).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done.'</span></span>); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Resolved after <span class="hljs-number"><span class="hljs-number">2</span></span> seconds <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Resolved after <span class="hljs-number"><span class="hljs-number">1.5</span></span> seconds <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Resolved after <span class="hljs-number"><span class="hljs-number">3</span></span> seconds <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Caught an error. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Done.</code> </pre> <br>  This code starts with the line where the <code>delay</code> function is called.  Then the following happens here: <br><br><ul><li>  The <code>delay(2000)</code> function returns a promise that resolves after 2 seconds. <br><br></li><li>  Then the first <code>.then()</code> block is executed.  He writes <code>Resolved after 2 seconds</code> to the log.  It then returns another promise, causing <code>delay(1500)</code> .  If <code>.then()</code> returns a promise, the resolution (technically called settlement) of this promise is passed to the next <code>.then()</code> call. </li><li>  This process continues until the chain ends. </li></ul><br>  Also, pay attention to the code snippet where we execute the <code>throw new Error()</code> command, that is, we throw an error into <code>.then()</code> .  This means that the current promise will be rejected, and the next <code>.catch()</code> handler will be called.  As a result, the line <code>Caught an error</code> is displayed in the log.  That is why the <code>.then()</code> block that <code>.catch()</code> after <code>.catch()</code> called. <br><br>  Recommended, for error handling, to use.  <code>catch()</code> , not <code>.then()</code> with <code>onResolved</code> and <code>onRejected</code> .  Here is the code that clarifies this recommendation. <br><br><pre> <code class="hljs coffeescript">const promiseThatResolves = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   UnhandledPromiseRejection promiseThatResolves().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err), ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    promiseThatResolves() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  At the very beginning of this example, we create a promise that is always allowed.  When there is a <code>.then()</code> with two callbacks, <code>onResolved</code> and <code>onRejected</code> , you can handle errors and situations in which the promise is rejected, only for the performing function.  Suppose the handler in <code>.then()</code> also throws an error.  This, as can be seen from the code, will not result in a call to the onRejected <code>onRejected</code> . <br><br>  However, if there is a <code>.catch(</code> ) block after <code>.then()</code> , this block will intercept both <code>.catch(</code> function errors and <code>.then()</code> errors.  This makes sense, since <code>.then()</code> always returns a promise. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  You can independently perform all the examples, which will allow you, through practice, to better master what was discussed in this material.  In order to study promises, you can practice in the implementation of functions based on callbacks in the form of promises.  If you are working in Node.js, note that many functions in <code>fs</code> and in other modules are based on callbacks.  There are utilities that allow you to automatically convert such functions into constructions based on promises.  Let's say it's <a href="https://nodejs.org/api/util.html">util.promisify</a> from Node.js, and <a href="https://github.com/sindresorhus/pify">pify</a> . <br><br>  However, if you are only learning all this, it is recommended to adhere to the principle of WET (Write Everything Twice, write everything two times) and implement independently (or, at least, carefully read) as much code as possible of the libraries under study.  In other cases, especially if you are writing code that goes into production, stick to the DRY principle (Don't Repeat Yourself, Don't Repeat).  In terms of working with promises, there is a lot more that does not fall into this material.  For example, these are static methods <code>Promise.all</code> , <code>Promise.race</code> , and others.  In addition, error handling is very briefly covered here.  There are well-known anti-patterns and subtleties that you should know about when working with promises.  Here are some materials that would be useful for those who are interested in all this: <a href="http://www.ecma-international.org/ecma-262/6.0/">ECMA specification</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Mozilla Docs materials</a> , Google promises guide, Exploring JS <a href="http://exploringjs.com/es6/ch_promises.html">chapter</a> on promises, <a href="http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/">useful article</a> on promises basics. <br><br>  <b>Dear readers!</b>  How do you write asynchronous code in javascript? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/358808/">https://habr.com/ru/post/358808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358798/index.html">Inverse kinematics in two-dimensional space</a></li>
<li><a href="../358800/index.html">White spots in work with SSH</a></li>
<li><a href="../358802/index.html">USB3Vision and GenICam. View from the inside. I</a></li>
<li><a href="../358804/index.html">Protocol-Oriented Programming</a></li>
<li><a href="../358806/index.html">Red Hat Summit: The best moments of the main open source conference in 30 minutes</a></li>
<li><a href="../358810/index.html">‚ÄúLife after Java 10‚Äù: what changes Java 11 will bring</a></li>
<li><a href="../358814/index.html">Lead Dev New York: review of reports and review of the conference</a></li>
<li><a href="../358816/index.html">Neural network speech synthesis with their own hands</a></li>
<li><a href="../358818/index.html">Summer vacation: how not to worry about the work of your site in vain</a></li>
<li><a href="../358820/index.html">FontCode: a new way of steganography through the shape of letters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>