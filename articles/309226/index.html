<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RxConnect - when React meets RxJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This translation is a Russian-language interpretation of the documentation, which I myself wrote, so do not hesitate to ask questions. 
 Introduction ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RxConnect - when React meets RxJS</h1><div class="post__text post__text-html js-mediator-article"><p>  This translation is a Russian-language interpretation of the documentation, which I myself wrote, so do not hesitate to ask questions. </p><br><h1>  Introduction </h1><br><p>  Handling user input may not be as easy as it sounds.  We do not want to send requests to the server while the user is still typing his request?  And, of course, the user must always see the result on the last request he sent. </p><br><p>  There are different ways to respond to interactive events in React applications, and, in my opinion, the reactive approach (thanks to such libraries as RxJS or Bacon) is one of the best.  That's just to use RxJS and React at the same time, you have to deal with the life cycle of the React component, manually manage subscriptions to streams, and so on.  The good news is that all this can be done automatically using RxConnect, a library developed during the migration process from Angular to React to ZeroTurnaround. </p><br><a name="habracut"></a><br><h1>  Motivation </h1><br><p>  First was React.  And it was good. </p><br><p>  ... But then people realized that making API requests and scattering the state of the application across different components is not good.  And there was a Flux architecture.  And it became good. </p><br><p>  ... But then people realized that instead of having a lot of data storage, there could be one.  And Redux appeared.  And it became good and centralized. </p><br><p>  But another problem has appeared - it has become difficult to do simple things, and every sneeze (such as the login field) must pass through the action creators, reducer, and be stored in a global state.  And then everyone remembered that the React component ... may have a local state!  <a href="https://github.com/reactjs/redux/issues/1287">How well Dan noticed</a> : </p><br><blockquote>  Use the state of the React component where it is unimportant for the global state of the application and when it (the local state) does not change through complex transformations.  For example, checkbox status, form field. <br>  Use Redux as a state storage for a global state or for a state that is modified through complex transformations.  For example, user cache, or draft article entered by the user. <br>  In other words, do what seems least strange (unacceptable). </blockquote><p>  And RxJS is better suited than ever to manage this local state. </p><br><p>  Consider an example: </p><br><p>  We will write the simplest timer showing how many seconds have passed, without RxJS or other libraries: </p><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">counter</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } componentWillMount() { setInterval( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">counter</span></span>: state.counter + <span class="hljs-number"><span class="hljs-number">1</span></span> })), <span class="hljs-number"><span class="hljs-number">1000</span></span> ) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{ this.state.counter }</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } }</code> </pre> <br><p>  Simple, isn't it?  That's just bad luck - what happens when we remove this component from the scene?  It will continue to call <code>setState()</code> and throw an exception, because you cannot call <code>setState()</code> on remote components. </p><br><p>  So, we need to make sure that we unsubscribe from the interval before the component is removed: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } intervalRef = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; componentWillMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalRef = setInterval( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: state.value + <span class="hljs-number"><span class="hljs-number">1</span></span> })), <span class="hljs-number"><span class="hljs-number">1000</span></span> ) } componentWillUnmount() { clearInterval(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalRef); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{ this.state.value }</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } }</code> </pre> <br><p>  This problem is so popular that there is even a library for this: <a href="https://github.com/reactjs/react-timer-mixin">https://github.com/reactjs/react-timer-mixin</a> </p><br><p>  Now imagine that for each Promise, interval, and any other asynchronous, we have to write our own signing and unsubscribing handlers, separate libraries.  Well, there is RxJS - an abstraction that allows you to handle such things <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">reactively</a> . </p><br><p>  The same example, but using RxJS alone, will look something like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } subscription = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; componentWillMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscription = Rx.Observable.timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).timestamp().subscribe(::<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState); } componentWillUnmount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscription.dispose(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{ this.state.value }</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } }</code> </pre> <br><p>  But is it a bit too much code for such a simple task?  And what if the developer forgets to call dispose on the subscription?  And, since we already have a state in the form of <code>Rx.Observable.timer</code> , why should we duplicate it in the form of a local component state? </p><br><p>  This is where RxConnect will help us: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { rxConnect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rx-connect"</span></span>; @rxConnect( Rx.Observable.timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).timestamp() ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{ this.props.value }</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } }</code> </pre> <br><p>  (You can play with an example at <a href="http://codepen.io/bsideup/pen/wzvGAE">http://codepen.io/bsideup/pen/wzvGAE</a> ) </p><br><p>  RxConnect is implemented as a <a href="https://medium.com/%40franleplant/react-higher-order-components-in-depth-cf9032ee6c3e">Higher Order Component</a> and takes over the entire subscription management routine, which makes your code safer and improves readability.  The same component is now a function of properties, i.e.  "Pure", which greatly simplifies testing due to lack of internal state. </p><br><p>  And starting with React 0.14, we can use functions as React stateless components, due to which the code can be turned into one line: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer = rxConnect(Rx.Observable.timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).timestamp())(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ value }</span></span></span><span class="hljs-function">) =&gt;</span></span> &lt;div&gt;{value}&lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;)</span></span></code> </pre> <br><p>  True, I find the class option much more readable. </p><br><h1>  Life example </h1><br><p>  Timers are good, but most often we have to deal with <del>  boring </del>  API and all sorts of services, so let's look at a more realistic example - search for articles from Wikipedia. </p><br><h3>  Component </h3><br><p>  Let's start with the component itself: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { articles, search } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; &lt;label&gt; Wiki search: &lt;input type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"text"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onChange={ e =&gt; search(e.target.value</span></span></span><span class="hljs-function">) } /&gt; &lt;/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">label</span></span></span><span class="hljs-function">&gt; { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">articles</span></span></span><span class="hljs-function"> &amp;&amp; (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;ul&gt; { articles.map(({ title, url }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{url}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{title}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) ) } &lt;<span class="hljs-regexp"><span class="hljs-regexp">/ul&gt; ) } &lt;/</span></span>div&gt; ); } }</code> </pre> <br><p>  As you can see, he expects two properties: </p><br><ul><li>  <strong>articles</strong> - an array of articles (note, the component knows nothing about where they come from) </li><li>  <strong>search</strong> is the function it will call when the user enters something in the input field. </li></ul><br><p>  The component is clean and stateless.  Remember it, because we will no longer modify its code! </p><br><p>  <strong>Note: RxConnect works with existing React components without modifications.</strong> </p><br><h3>  Reactive component </h3><br><p>  It's time to connect our component with the outside world: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { rxConnect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rx-connect"</span></span>; @rxConnect(Rx.Observable.of({ <span class="hljs-attr"><span class="hljs-attr">articles</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"Pure (programming Language)"</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"https://en.wikipedia.org/wiki/Pure_(programming_language)"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"Reactive programming"</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"https://en.wikipedia.org/wiki/Reactive_programming"</span></span> }, ] })) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  (Play around: <a href="http://codepen.io/bsideup/pen/VKwKGv">http://codepen.io/bsideup/pen/VKwKGv</a> ) </p><br><p>  Here we simulated data by laying a static array of two elements, and we see that the component from displays!  Hooray! </p><br><p>  ** Note: the function passed to the <code>rxConnect</code> method should return <code>Observable</code> component properties. </p><br><h3>  Reactive Interactive Component </h3><br><p>  All of course cool, but ... Search?  The user is still unable to interact with our component.  Requirements were: </p><br><ul><li>  It should search on Wikipedia when the user enters a query. </li><li>  It should ignore the result of all previous requests if the user enters a new request. </li></ul><br><p>  Thanks to RxJS, we can easily implement this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { rxConnect, ofActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rx-connect"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchWikipedia</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">search</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rx.DOM .jsonpRequest(<span class="hljs-string"><span class="hljs-string">`https://en.wikipedia.org/w/api.php?action=opensearch&amp;search=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${search}</span></span></span><span class="hljs-string">&amp;format=json&amp;callback=JSONPCallback`</span></span>) .pluck(<span class="hljs-string"><span class="hljs-string">"response"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Wikipedia      o_O .map(([,titles,,urls]) =&gt; titles.map((title, i) =&gt; ({ title, url: urls[i] }))) } @rxConnect(() =&gt; { const actions = { search$: new Rx.Subject() } const articles$ = actions.search$ .pluck(0) //      .flatMapLatest(searchWikipedia) return Rx.Observable.merge( Rx.Observable::ofActions(actions), articles$.map(articles =&gt; ({ articles })) ) }) class MyView extends React.PureComponent { // ... }</span></span></code> </pre> <br><p>  (Play: <a href="http://codepen.io/bsideup/pen/rrNrEo">http://codepen.io/bsideup/pen/rrNrEo</a> <strong>ATTENTION! Do not enter too quickly, otherwise you will rest against the restriction of the API by the number of requests</strong> (see below)) </p><br><p>  Great, it works!  We print and we see the result. </p><br><p>  Go through the code step by step: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actions = { <span class="hljs-attr"><span class="hljs-attr">search$</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rx.Subject() }</code> </pre> <br><p>  Here we create an object from user actions.  They are <a href="">Subjects</a> .  You can declare as many subjects as you want. </p><br><p>  See the $ sign at the end of the action name?  This is a special notation in RxJS to identify the data stream.  RxConnect will drop it, and the component will receive it as a <code>search</code> property. </p><br><p>  But the actions themselves do nothing, we must respond to them with the help of reactions: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> articles$ = actions.search$ .pluck(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// select first passed argument .flatMapLatest(searchWikipedia)</span></span></code> </pre> <br><p>  Now we have only one reaction - to search, but there may be many, which is why we combine the flows of all reactions into one: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rx.Observable.merge( Rx.Observable::ofActions(actions), articles$.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">articles</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ articles })) )</code> </pre> <br><p>  The stream of articles will be converted to the <code>articles</code> property of our component. </p><br><h3>  Reactive interactive component that takes into account API limitations </h3><br><p>  In the current implementation, we request the API each time the user enters a new character in the input field.  This means that if the user enters too often, for example, 10 characters per second, then we will send 10 requests per second.  But the user wants to see only the result for the last query, when he stopped typing.  And this situation is a great example for which we choose RxJS - because it is designed to handle such situations! </p><br><p>  We modify our reaction a bit: </p><br><pre> <code class="javascript hljs">actions.search$ .debounce(<span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;-- RxJS ! .pluck(0) .flatMapLatest(searchWikipedia)</span></span></code> </pre> <br><p>  (Play: <a href="http://codepen.io/bsideup/pen/gwOLdK">http://codepen.io/bsideup/pen/gwOLdK</a> (do not be afraid to enter as fast as you can) </p><br><p>  Now the user can enter at any speed, because we will send a request only when there is no input from the user within 500ms, which means our server will receive a maximum of 2 requests per second. </p><br><p>  <strong>To the note: study RxJS, it is gorgeous :)</strong> </p><br><h3>  Reactive, interactive API component with attention to detail. </h3><br><p>  Type something in the input box.  After seeing the results, enter something else.  Old results remain on the screen until we receive a response from the server to a new request.  It's not very beautiful, but we can fix it easily. </p><br><p>  Remember I said that we combine data streams, which means our component is reactive?  Due to this, it is not more difficult to clean up previous results than to send an empty object at the same time as we send a request to the server, but before its result: </p><br><pre> <code class="javascript hljs">actions.search$ .debounce(<span class="hljs-number"><span class="hljs-number">500</span></span>) .pluck(<span class="hljs-number"><span class="hljs-number">0</span></span>) .flatMapLatest(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">search</span></span></span><span class="hljs-function"> =&gt;</span></span> searchWikipedia(search) .startWith(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;--     undefined,  ,   ,     )</span></span></code> </pre> <br><p>  Result: <a href="http://codepen.io/bsideup/pen/mAbaom">http://codepen.io/bsideup/pen/mAbaom</a> </p><br><h1>  Redux </h1><br><p>  In order to reduce the size of the article, I will not cover the topic of Redux, I will just say that RxConnect works great with Redux and allows you to also reactively link your components, replacing <code>@connect</code> .  For example: </p><br><pre> <code class="javascript hljs">@rxConnect(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props$, state$, dispatch</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actions = { <span class="hljs-attr"><span class="hljs-attr">logout</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> dispatch(logout()), }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user$ = state$.pluck(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).distinctUntilChanged(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rx.Observable.merge( Rx.Observable::ofActions(actions), user$.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ user })), ); }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Example: <a href="https://github.com/bsideup/rx-connect/tree/master/examples/blog/">https://github.com/bsideup/rx-connect/tree/master/examples/blog/</a> <br>  Demo: <a href="https://bsideup.github.io/rx-connect/examples/blog/dist/">https://bsideup.github.io/rx-connect/examples/blog/dist/</a> </p><br><h1>  Conclusion </h1><br><p>  Reactive programming can be easier than it seems.  After we transferred most of our components to RxJS, we no longer see any other way.  And RxConnect allowed us to avoid unnecessary code and potential subscription management errors. </p><br><h1>  Links </h1><br><ul><li>  <a href="https://bsideup.gitbooks.io/rxconnect/content/">https://bsideup.gitbooks.io/rxconnect/content/</a> - documentation </li><li>  <a href="https://github.com/bsideup/rx-connect">https://github.com/bsideup/rx-connect</a> - RxConnect on GitHub </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/309226/">https://habr.com/ru/post/309226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309216/index.html">Huawei KunLun server - our testing</a></li>
<li><a href="../309218/index.html">STM32 USB Mass Storage Bootloader</a></li>
<li><a href="../309220/index.html">Blind programmer and forged chains</a></li>
<li><a href="../309222/index.html">How to build a simple Java program using Maven</a></li>
<li><a href="../309224/index.html">And a little more about the Fujitsu World Tour</a></li>
<li><a href="../309228/index.html">Asynchronous (and not so) data loading in Unreal Engine 4</a></li>
<li><a href="../309230/index.html">10 Webpack features</a></li>
<li><a href="../309232/index.html">In memory of Solomon Golomb (1932-2016): the author of the shift register with linear feedback of maximum length and polynomial</a></li>
<li><a href="../309234/index.html">Top10 Virtualization Software Companies</a></li>
<li><a href="../309236/index.html">How to make them not go away</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>