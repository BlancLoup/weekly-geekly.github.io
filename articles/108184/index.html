<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous Programming and Computation Expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous notes ( part I , part II ) about async / await in C # 5, I wrote that a similar approach was implemented in languages ‚Äã‚Äãlike Haskell, F # ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous Programming and Computation Expressions</h1><div class="post__text post__text-html js-mediator-article">  In previous notes ( <a href="http://habrahabr.ru/blogs/net/107498/">part I</a> , <a href="http://habrahabr.ru/blogs/net/107583/">part II</a> ) about async / await in C # 5, I wrote that a similar approach was implemented in languages ‚Äã‚Äãlike Haskell, F # and Nemerle, but, unlike C #, these languages ‚Äã‚Äãsupport a higher level concept, which allows you to implement asynchronous computing in the async / await style as a library, and not at the language level.  It's funny that in Nemerle this concept itself is implemented as a library.  The name of this concept is monad.  In addition to asynchronous calculations, monads allow you to implement other goodies, such as list comprehension, continuation, the transformation of dirty functions into a pure block, through which the state is implicitly pulled, and many others. <br><br>  Some monads implement such "Wishlist" C # programmers, such as yield collections or yield foreach and yield from lambda expressions. <br><br>  The purpose of this note is an introduction to asynchronous programming and computation expressions in Nemerle, but it can also be useful to those who study F #, so the implementation of asynchronous programming in Nemerle was done with an eye to it in F #.  On the other hand, someone may be interested in how some tasks that are a problem in other languages ‚Äã‚Äã( <a href="http://habr.ru/post/108298">after all asynchronous calls</a> ) are solved using computation expressions in a couple of lines. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Probably everyone who realized what a monad is, writes an article about what a monad is.  I was no exception.  I will try to make the description as concisely as possible so that those who know will remember, and others will be able to understand the further narration. <br><br><h4>  Monads </h4><br>  A monad is a generative pattern whose support is built into the language.  The basis for the implementation of this pattern is the following pair: <br><br>  polymorphic type <br><br><pre><code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ ... }</code> </pre> <br>  and a couple of operations on it <br><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Return</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) { ... } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&lt;U&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bind</span></span></span><span class="hljs-class">&lt;T,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Func</span></span></span><span class="hljs-class">&lt;T, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&lt;U&gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class">) { ... } }</span></span></code> </pre> <br>  Return allows you to wrap any value into a monad, and Bind to transform it.  A very weak analogy can be made with StringBuilder, which is passed an initial value in the constructor parameter, and then modified using the Append * methods. <br><br>  If you replace F with IEnumerable, then the Bind signature resembles the SelectMany signature from Linq.  This is not surprising, since Linq with great reservations is also a monad.  By the way, this was interestingly told by Bart De Smet at PDC2010 with the report ‚ÄúLINQ, Take Two - Realizing the LINQ to Everything Dream‚Äù ( <a href="http://player.microsoftpdc.com/Session/bfa72307-6534-41ad-bcf7-0f4fb9280515">link</a> ). <br><br>  If Linq is a monad, then try to draw a simple Linq expression: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nums = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqrt = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nums <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> n &gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> Math.Sqrt(n);</code> </pre> <br>  using M-operations.  At the beginning we declare M-operations: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span>&lt;T&gt;(T obj) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.Add(obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;U&gt; Bind&lt;T, U&gt;(this IEnumerable&lt;T&gt; obj, Func&lt;T, IEnumerable&lt;U&gt;&gt; fun) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.SelectMany(fun); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">Empty</span></span>&lt;T&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Enumerable.<span class="hljs-keyword"><span class="hljs-keyword">Empty</span></span>&lt;T&gt;(); } }</code> </pre> <br>  And rewrite the Linq expression: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nums = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqrt = nums .Bind(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? MList.Return(n) : MList.Empty&lt;int&gt;()) .Bind(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> MList.Return(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.Sqrt(n)));</code> </pre> <br>  It turned out even worse than with Linq, but this is because monad support is not built into C #.  In the case of Nemerle, this code can be as follows, we declare M-operations: <br><br><pre> <code class="hljs markdown">class MList { public Return[<span class="hljs-string"><span class="hljs-string">T</span></span>](<span class="hljs-link"><span class="hljs-link">obj : T</span></span>) : IEnumerable[<span class="hljs-string"><span class="hljs-string">T</span></span>] { def data = List(); data.Add(obj); data } public Bind[<span class="hljs-string"><span class="hljs-string">T, U</span></span>](<span class="hljs-link"><span class="hljs-link">obj : IEnumerable[T], f : T-&gt;IEnumerable[U]</span></span>) : IEnumerable[<span class="hljs-string"><span class="hljs-string">U</span></span>] { obj.SelectMany(f) } public Empty[<span class="hljs-string"><span class="hljs-string">T</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) : IEnumerable[T] { Enumerable.Empty() } }</code> </pre> <br>  And rewrite the Linq expression: <br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mlist</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nums</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enumerable</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mlist</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defcomp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nums</span></span></span><span class="hljs-function">;</span></span> defcomp n = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) mlist.Return(n) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mlist.Empty(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Sqrt(n <span class="hljs-symbol"><span class="hljs-symbol">:&gt;</span></span> double); };</code> </pre> <br>  In the beginning, we recall that def in Nemerle is a non-convenient analogue of var in C #, if the ternary operator (? :), and a constructor call does not require new.  Now to the point, the comp statement declares the beginning of monadic calculations, the parameter following it provides the M-operations, and then the calculations themselves go. <br><br>  Compared to Linq, we have three lines, instead of one, but these lines look like ordinary code that works with one variable, and in fact it generates a new collection from the original one.  This example is provided for training purposes, below are examples that repeat the usual code is very difficult.  We will understand how it works. <br><br>  defcomp is a magic operator that ‚Äúturns‚Äù the monad (in this case, of type IEnumerable [T]) into a value (of type T), and return, conversely, translates the value into a monad.  In fact, there is no magic, just an expression <br><br><pre> <code class="hljs erlang">defcomp n = nums; ...</code> </pre> <br>  revealed by the compiler in <br><br><pre> <code class="hljs php">mlist.Bind(nums, n =&gt; ...)</code> </pre> <br><h4>  Computation expressions </h4><br>  If we were discussing the Haskell language, then the story about monads could be finished.  But in the case of hybrid languages ‚Äã‚Äã(functional / imperative), the situation is a bit more complicated, as there are such control structures as conditional, loop and yield operators.  To understand how this presents a problem, one can try to express through M-operations monadic calculations, which contain a cycle, and inside the cycle, the defcomp operator. <br><br>  The solution to this problem is quite simple, you need to add methods to the set of M-operations that deal with the transformation of branch operators and cycles, for example, while it will have the following signature: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">public F</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FakeVoid</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> While</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(Func</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">bool</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> cond, Func</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">F</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">FakeVoid</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt; body)</span></span></code> </pre> <br>  And when the compiler encounters a loop whose body contains monadic operators, it first transforms the loop body into a Bind chain, since Bind returns F &lt;T&gt;, then this chain can be wrapped in lambda "() =&gt; body ()", like Func &lt;F &lt;T &gt;&gt;, as well, the compiler wraps the loop condition in lambda, and then passes those lambdas to the While m-operation. <br><br>  Each M-operation should return a monad, but the cycle returns nothing, therefore there is no value that can be wrapped into a monad.  For these purposes, the FakeVoid singelton is used. <br><br>  Now you can give an informal description of the computation expression, it is a monad for imperative languages.  In the case of a-la haskell, the compiler rewrites only defcomp and return within monadic calculations, as already noted in the case of imperative languages, the control structures are also rewritten, in the table below are all the operators that are rewritten: <br><table><tbody><tr><td>  defcomp </td><td>  turns monad into value, meaning close to assignment </td></tr><tr><td>  callcomp </td><td>  expands the monad, is used when the value is not important </td></tr><tr><td>  return </td><td>  wraps the argument in a monad, is used at the end of the monadic block, meaning close to returning from the function </td></tr><tr><td>  returncomp </td><td>  the argument is a monad, returns this monad as the result of a block of monadic calculations, unlike return, does not wrap it again </td></tr><tr><td>  yield </td><td>  wraps the argument into a monad and performs actions similar to yield return </td></tr><tr><td>  yieldcomp </td><td>  the argument is a monad, performs actions similar to a yield return, unlike yield does not wrap the argument again </td></tr><tr><td>  if, when, unless, while, do, foreach, for, using, try ... catch ... finally </td><td>  monadic versions of ordinary control structures </td></tr></tbody></table><br>  Just a couple of words about M-operations providers.  Officially, they are called builders, and when building a computation expression, duck typing is used, that is, builders must contain methods that the compiler uses, but the builder is not required to implement any interface.  This solution allows to partially implement builders if it is planned to use not all features in the computation expression.  By the way, we have already used this approach when creating the MList builder (only defcomp and return support is implemented). <br><br>  Another reason why the interfaces are not used is that they impose a stricter condition on the signature of M-operations.  Only compatibility of monads and M-operations by type is required.  For example, in the examples above it was assumed that the monad has one generic parameter, but it can easily have several of them, for further narration this is not important, but it can be studied using the example of the <a href="">Continuation</a> monad. <br><br>  For those who want to write their builders, the best advice is to study the source code of <a href="http://code.google.com/p/nemerle/source/browse/nemerle/trunk/snippets/ComputationExpressions/">Computation expressions</a> . <br><br><h4>  Examples of standard builders </h4><br><br>  Standard builders are built into the Computation Expressions library, and instead of creating an instance of them and passing comp as a parameter, you just need to pass their name as a parameter. <br><br><h5>  List </h5><br>  The list builder supports standard language control structures, as well as yield and yieldcomp.  As a monad, it uses list [T] (the standard list in Nemerle).  This builder is interesting in that it implements two long-standing C # programmers of programmers: yield from lambda and yield collections.  In the beginning, we will look at the Linq analogue from the beginning of the article: <br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enumerable</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function">[</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double</span></span></span><span class="hljs-function">] = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> Math.Sqrt(n); }</code> </pre> <br>  As you can see, the list builder allows you to use yield expressions in place without requiring you to declare a function for this, you can also use it instead of Link to objects.  It seems to me that this code is much easier to read than the equivalent linq expression. <br><br>  Consider now another ‚ÄúWishlist‚Äù - the yield of the collection, at the beginning I declare a local function that generates a sequence, and then call it two times and make a collection of collections. <br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span></span> { comp list { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(mutable i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n;i++) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twice</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> yieldcomp upTo(<span class="hljs-number"><span class="hljs-number">3</span></span>); } Console.WriteLine(twice); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br>  I had to write my own generator instead of using ‚ÄúEnumerable.Range (0, 3)‚Äù because of the types: yieldcomp expects a monad for input, its type in this case is list [int], and ‚ÄúEnumerable.Range (0, 3) Returns an IEnumerable [int].  To overcome this inconsistency there is another builder - enumerable. <br><br><h5>  Enumerable </h5><br>  This builder largely repeats the List builder, only uses IEnumerable [T] as a monad type and allows you to build infinite sequences.  Rewrite the last example: <br><br><pre> <code class="hljs pgsql">def twice = comp enumerable { repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>) yieldcomp Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> twice) Console.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>($"$item "); //<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><h5>  Array </h5><br>  Similar to list and enumerable, the array behaves, only uses array [T] as the monad type. <br><br><h5>  Async </h5><br>  The most difficult, but very useful builder, in many respects resembles the future async / await in C #.  It is used to build asynchronous computing, combining already existing asynchronous computing. <br><br>  It supports all operations except yield and yieldcomp. <br><br>  The monad type of this builder is Async [T].  Objects of this type describe an asynchronous calculation, the result of which will be a value of type T (like Task &lt;T&gt; in C #), if the asynchronous operation does not return a value, then instead of T a specific type of FakeVoid is used.  The Bind operation, its Async [T] * type (T-&gt; Async [U]) -&gt; Async [U], ‚Äúcontinues‚Äù the asynchronous computation (of the Async [T] type) with a function; this function takes an object of type T (the result asynchronous calculation) and returns a new asynchronous calculation of the type Async [U]. <br><br>  Another key type is the abstract class ExecutionContext, instances of its descendants are responsible for starting an asynchronous operation (for example, in the current thread, in a thread from the ThreadPool or using SynchronizationContext), here is its signature: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExecutionContext</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">computatuion : </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> -&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">) : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span>; }</code> </pre> <br>  To start an asynchronous operation, call the Start method of the object describing the asynchronous operation (Async [T] class), passing it an object of type ExecutionContext, if the method is called without arguments, then the asynchronous operation is started using ThreadPool.QueueUserWorkItem. <br><br>  In the extension (async CTP), which allows using the async / wait implementation in C #, there are already a lot of extension methods that complement the existing classes with asynchronous operations.  In a library with a monad implementation, async does not provide such extensions, but it does provide an easy way to build them on the basis of already existing primitives.  For example, consider a part of the existing HttpWebRequest signature, which is responsible for the asynchronous execution of a query that exists from the first version of the framework: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HttpWebRequest</span></span> : <span class="hljs-title"><span class="hljs-title">WebRequest</span></span>, <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginGetResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AsyncCallback callback, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> WebResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndGetResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncResult asyncResult</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Now we will create an asynchronous extension, which is suitable for use in monadic calculations using these primitives. <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> module AsyncExtentions { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GetResponseAsync(this <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> : HttpWebRequest) : Async[WebResponse] { Async.FromBeginEnd(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.BeginGetResponse(_, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.EndGetResponse(_)) } }</code> </pre> <br>  It should be recalled that _ in Nemerle is a special character, in this case currying is used through it (the record f (_) is equivalent to x =&gt; f (x)).  Similarly, wrappers can be created for any standard asynchronous computing. <br><br>  Let's try on Nemerle to write something from (C # 101) Async samples, for example, parallel loading of several web pages and printing a header, I dropped the code for the extension GetHtml () and GetTitle (), the article was already dragged out. <br><br><pre> <code class="hljs ruby">public PrintTitles() : Async[FakeVoid] { comp async { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpWebRequest</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"http://www.ya.ru"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>.GetResponseAsync(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpWebRequest</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"http://www.habr.ru"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>.GetResponseAsync(); defcomp response1 = response1; defcomp response2 = response2; Console.WriteLine(response1.GetHtml().GetTitle()); Console.WriteLine(response2.GetHtml().GetTitle()); } }</code> </pre> <br>  The first two lines start asynchronous page load operations, these methods return objects describing asynchronous operations at the time of execution, from the compiler's point of view, the type of these objects Async [WebResponce] (monad).  In the next two lines, the monad expands into value, at a different level of meaning, it means waiting for results.  In the last lines, the results are processed. <br><br>  It's funny that the post-reasoning about how to properly ( <a href="http://habr.ru/post/108298">wait for the results of all the asynchronous calls</a> ) to do in javascript turned out to be very hot: 90 favorites, 100 comments.  But back to our example. <br><br>  The main thing to remember is that a monad is a spawning pattern, you have created a function that describes asynchronous computing, but does not trigger it, so you can start it so PrintTitles (). Start (). GetResult ().  <b>In fact, this is very important, since it can serve as a source of errors, if the method returns Async [T], you need to be aware of whether this code runs the calculations or only constructs them</b> .  For the difference, you probably should use a naming convention, for example, methods that run calculations must have the Async suffix. <br><br>  In my second article on async / await in C #, I wrote that processing the results of asynchronous calculations await starts in the SynchronizationContext of the thread that started asynchronous calculations.  Nemerle in this regard provides for greater flexibility, it is possible to transfer calculations from one stream to another.  Consider a button click handler: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> button1_Click (sender : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class"> </span></span>: <span class="hljs-type"><span class="hljs-type">System</span></span>.<span class="hljs-type"><span class="hljs-type">EventArgs</span></span>) : void { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formContext</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">SystemExecutionContexts</span></span>.<span class="hljs-type"><span class="hljs-type">FromCurrentSynchronizationContext</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-function"> </span></span>= comp async { <span class="hljs-type"><span class="hljs-type">Thread</span></span>.<span class="hljs-type"><span class="hljs-type">Sleep</span></span>(<span class="hljs-number"><span class="hljs-number">5000</span></span>); callcomp <span class="hljs-type"><span class="hljs-type">Async</span></span>.<span class="hljs-type"><span class="hljs-type">SwitchTo</span></span>(formContext); label1.<span class="hljs-type"><span class="hljs-type">Text</span></span> = <span class="hljs-string"><span class="hljs-string">"success"</span></span>; } _ = task.<span class="hljs-type"><span class="hljs-type">Start</span></span>(<span class="hljs-type"><span class="hljs-type">SystemExecutionContexts</span></span>.<span class="hljs-type"><span class="hljs-type">ThreadPool</span></span>()); }</code> </pre> <br>  First we get the ExecutionContext, which starts the calculations in the current SynchronizationContext, then we describe the asynchronous operation: Thread.Sleep emulates a heavy calculation, switch the execution context to the execution context of the thread gui and output the result.  The calculation itself is run in the thread pool's ExecutionContexts. <br><br>  It looks like magic, but in fact all this has already happened, callcomp just opens the monad when its meaning is not important.  But why then open it at all?  The point is the side effects and the state, during the monadic operations the state is dragged through them, the monad has access to this state at the time of disclosure and can change it, which is what happens here.  In this example, the state stores information in which context to execute the code, and if this information changes, it switches to the new context.  For details, I can recommend to go read the <a href="http://code.google.com/p/nemerle/source/browse/">source</a> , they are interesting. <br><br>  In addition to Async.SwitchTo, there are other interesting monads affecting the flow of execution, for example, Async.Yield says that the execution context has changed, although it does not change it.  In some cases, this does nothing, in the case where the ThreadPool was used, this action provokes a jump to another thread from the pool. <br><br><h4>  Conclusion </h4><br>  In conclusion, I can only note that monads are a very rich topic.  In this article, I did not touch on such classic monads as State, Cont (continuation), Maybe (another Wishlist C # fanboy).  You can read about them in other articles, I tried to give a practical explanation, thanks to which you can start using asynchronous programming and list / enumerable monads in Nemerle and know what is happening under the hood. <br><br>  In many ways, the implementation of await / async in the future C # and the monadic approach to asynchronous programming in Nemerle are similar, but there is one note to support await / async the next version of the language is needed, and the asynchronous programming in Nemerle is implemented through monads language, not language). <br><br>  I will be glad to comment and answer questions. </div><p>Source: <a href="https://habr.com/ru/post/108184/">https://habr.com/ru/post/108184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108176/index.html">562 applications were received for the domain Avto.rf</a></li>
<li><a href="../108178/index.html">Microsoft All-In-One Code Framework (C #, C ++, VB.NET)</a></li>
<li><a href="../108179/index.html">Opportunities online store "medium" or screwed</a></li>
<li><a href="../108182/index.html">Testing PayPal Direct Recurring Payments. Quest quest</a></li>
<li><a href="../108183/index.html">SaaS in the field of site building</a></li>
<li><a href="../108185/index.html">Akamai data rate statistics for the 50 largest countries</a></li>
<li><a href="../108188/index.html">Green Elephant in the Land of the Rising Sun</a></li>
<li><a href="../108190/index.html">Smarty 3 Final has been released. What's new?</a></li>
<li><a href="../108191/index.html">Django 1.3 alpha 1</a></li>
<li><a href="../108192/index.html">20 domains-in-gift.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>