<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fourier transform in action: accurate signal frequency determination and note highlighting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="latest article is available on makeloft.xyz 

 Let's start with the piano. Very simplified, this musical instrument is a set of white and black keys, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fourier transform in action: accurate signal frequency determination and note highlighting</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://makeloft.xyz/ru/knowledges/signal-processing/fourier-transform">latest article is available on makeloft.xyz</a> <br><br>  Let's start with the piano.  Very simplified, this musical instrument is a set of white and black keys, when you click on each of which a certain sound of a predetermined frequency from low to high is extracted.  Of course, each keyboard instrument has its own unique tonal color of the sound, thanks to which we can distinguish, for example, an accordion from a piano, but if roughly generalized, each key is simply a generator of sinusoidal acoustic waves of a certain frequency. <br><br>  When a musician plays a composition, he alternately or simultaneously presses and releases the keys, as a result of which several sinusoidal signals overlap each other to form a drawing.  This picture is perceived by us as a melody, so that we can easily recognize one work performed on various instruments in different genres or even unprofessionally sung by a person. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/de6/44b/706/de644b7066a03141d3ace71556113ee8.png" alt="image"><br><br><a name="habracut"></a><br>  Graphic illustration of music pattern <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/yl1bL9dWBdk%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253&amp;usg=ALkJrhjT7YHelPqb80nkZ5o2t5CXf7Kygg" frameborder="0" allowfullscreen=""></iframe><br><br>  Determination of frequency (guitar tuner mode) <br><img src="https://habrastorage.org/getpro/habr/post_images/b78/8ad/760/b788ad7601c9d2ee130dc105aa14f352.png" alt="image"><br><br>  The inverse problem is to disassemble the sounding musical composition into notes.  That is, decompose the total acoustic signal caught by the ear into the original sinusoids.  In essence, this process is a direct Fourier transform.  And pressing the keys and extracting sound is a process of inverse Fourier transform. <br><br>  Mathematically, in the first case, the decomposition of a complex periodic (on a certain time interval) function into a series of more elementary orthogonal functions (sinusoids and cosine curves) occurs.  And in the second they are the inverse summation, that is, the synthesis of a complex signal. <br><br>  Orthogonality, in some way, denotes immiscibility of functions.  For example, if we take a few pieces of colored clay and glue them together, then we can still make out what colors were originally, but if we mix several jars of gouache paints well, then it will be impossible to restore the original colors without additional information. <br><br>  (!) It is important to understand that <b>when we undertake to analyze a real signal using the Fourier transform, we idealize the situation and assume that it is periodic in the current time interval and consists of elementary sinusoids</b> .  This is often the case, since acoustic signals, as a rule, are of a harmonic nature, but more complex cases are possible in general.  Any of our assumptions about the nature of the signal usually lead to partial distortions and errors, but without this it is extremely difficult to isolate useful information from it. <br><br>  Now we describe the whole process of analysis in more detail: <br><br>  1. It all starts with the fact that sound waves oscillate the membrane of a microphone, which converts them into analog oscillations of electric current. <br><br>  2. Then the analogue electrical signal is digitized.  At this point it is worth staying in detail. <br><br>  Since an analog signal mathematically consists of an infinite continuous in time set of amplitude point-values, in the measurement process we can extract from it only a finite series of values ‚Äã‚Äãat discrete points in time, that is, in essence, perform time quantization ... <br><br>  As a rule, sample values ‚Äã‚Äãare taken at small equal time intervals, that is, with a certain frequency, for example, 16000 or 22000 Hz.  However, in the general case, discrete readings can also be uneven, but this complicates the mathematical apparatus of analysis, therefore, in practice, it is usually not used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/d9f/57f/38ad9f57fb18eae8425e2ab1c9fce782.png" alt="image"><br><br>  There is an important <b>Kotelnikov-Nyquist-Shannon theorem</b> , which states that an analog periodic signal having a finite (limited in width) spectrum can be uniquely reconstructed without distortion and loss from its readings taken at a frequency greater than or equal to twice the upper frequency of the spectrum ( called sampling rate or Nyquist). <br><br>  For this restoration, it is necessary to apply special interpolating functions, but the problem is that when using these functions, calculations must be performed on an infinite time interval, which is impossible in practice.  Therefore, in real life it is impossible to arbitrarily increase the sampling rate artificially without distortion, even if it initially satisfies the Kotelnikov-Nyquist-Shannon theorem.  For this operation apply filters Farrow. <br><br>  Also, discretization occurs not only in time, but also in terms of the magnitude of the amplitude values, since the computer is able to manipulate only a limited set of numbers.  This also introduces small errors. <br><br>  3. At the next stage, the <b>discrete direct Fourier transform</b> occurs. <br><br>  We select a short frame (interval) of the composition, consisting of discrete samples, which we conditionally consider periodic and apply the Fourier transform to it.  As a result of the transformation, we obtain an array of complex numbers containing information about the amplitude and phase spectra of the frame being analyzed.  Moreover, the spectra are also discrete with a step equal to (sampling frequency) / (number of samples).  That is, the more samples we take, the more accurate the resolution is in frequency.  However, with a constant sampling frequency, increasing the number of samples, we increase the analyzed time interval, and since in real music the notes have different sound durations and can quickly replace each other, they overlap, therefore the amplitude of long notes ‚Äúeclipses‚Äù the amplitude of short notes.  On the other hand, for guitar tuners this way of increasing the frequency resolution is well suited, since the note usually sounds long and alone. <br><br>  There is also a fairly simple trick to increase the frequency resolution ‚Äî you need to fill the original discrete signal with zeros between samples.  However, as a result of this filling, the phase spectrum is strongly distorted, but the amplitude resolution increases.  It is also possible to use Farrow filters and artificially increase the sampling rate, however, it also distorts the spectra. <br><br>  The frame duration is usually about 30 ms to 1 s.  The shorter it is, the better resolution we get in time, but the worst in frequency, the longer the sample, the better in frequency, but the worst in time.  This is very similar to <b>the Heisenberg uncertainty principle</b> from quantum mechanics ... and is not simple, as Wikipedia says, <b>the uncertainty relation in quantum mechanics in the mathematical sense is a direct consequence of the properties of the Fourier transform</b> ... <br><br>  It is also interesting that as a result of analyzing a single sinusoidal signal sample, the amplitude spectrum is very similar to the diffraction pattern ... <br><br>  Sinusoidal signal bounded by a rectangular window and its "diffraction" <br><img src="https://habrastorage.org/getpro/habr/post_images/733/799/dae/733799dae050ec4ed80c14f8ad96fa12.gif" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/61e/2ac/589/61e2ac58928d783aff054cd14e6e4245.gif" alt="image"><br><br>  Light diffraction <br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/fb6/4ab/2bafb64ab9decf3915107c6e1e165fff.jpg" alt="image"><br><br>  In practice, this is an undesirable effect that complicates the analysis of signals, so they try to reduce it by applying window functions.  A lot of such functions have been invented, below are the implementations of some of them, as well as a comparative impact on the spectrum of a single sinusoidal signal. <br><br>  Applying a window function to an input frame is very simple: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameSize; i++) { frame[i] *= Window.Gausse(i, frameSize); }</code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Rainbow</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Window</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Q = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Gausse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = (frameSize - <span class="hljs-number"><span class="hljs-number">1</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = (n - a)/(Q*a); t = t*t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Exp(-t/<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hamming</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.54</span></span> - <span class="hljs-number"><span class="hljs-number">0.46</span></span>*Math.Cos((<span class="hljs-number"><span class="hljs-number">2</span></span>*Math.PI*n)/(frameSize - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hann</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span>*(<span class="hljs-number"><span class="hljs-number">1</span></span> - Math.Cos((<span class="hljs-number"><span class="hljs-number">2</span></span>*Math.PI*n)/(frameSize - <span class="hljs-number"><span class="hljs-number">1</span></span>))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlackmannHarris</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.35875</span></span> - (<span class="hljs-number"><span class="hljs-number">0.48829</span></span>*Math.Cos((<span class="hljs-number"><span class="hljs-number">2</span></span>*Math.PI*n)/(frameSize - <span class="hljs-number"><span class="hljs-number">1</span></span>))) + (<span class="hljs-number"><span class="hljs-number">0.14128</span></span>*Math.Cos((<span class="hljs-number"><span class="hljs-number">4</span></span>*Math.PI*n)/(frameSize - <span class="hljs-number"><span class="hljs-number">1</span></span>))) - (<span class="hljs-number"><span class="hljs-number">0.01168</span></span>*Math.Cos((<span class="hljs-number"><span class="hljs-number">4</span></span>*Math.PI*n)/(frameSize - <span class="hljs-number"><span class="hljs-number">1</span></span>))); } } }</code> </pre><br><br><img src="http://pandia.org/text/77/481/images/image022_4.gif" alt="image"><br><br>  As for computers, a <b>fast Fourier transform</b> algorithm was developed at the time, which minimizes the number of mathematical operations needed to calculate it.  The only requirement of the algorithm is that the number of readings is a multiple of a power of two (256, 512, 1024, and so on). <br><br>  Below is its classic recursive implementation in C #. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Rainbow</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Butterfly</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> SinglePi = Math.PI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> DoublePi = <span class="hljs-number"><span class="hljs-number">2</span></span>*Math.PI; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Complex[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecimationInTime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Complex[] frame, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> direct</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frame.Length == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frameHalfSize = frame.Length &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// frame.Length/2 var frameFullSize = frame.Length; var frameOdd = new Complex[frameHalfSize]; var frameEven = new Complex[frameHalfSize]; for (var i = 0; i &lt; frameHalfSize; i++) { var j = i &lt;&lt; 1; // i = 2*j; frameOdd[i] = frame[j + 1]; frameEven[i] = frame[j]; } var spectrumOdd = DecimationInTime(frameOdd, direct); var spectrumEven = DecimationInTime(frameEven, direct); var arg = direct ? -DoublePi/frameFullSize : DoublePi/frameFullSize; var omegaPowBase = new Complex(Math.Cos(arg), Math.Sin(arg)); var omega = Complex.One; var spectrum = new Complex[frameFullSize]; for (var j = 0; j &lt; frameHalfSize; j++) { spectrum[j] = spectrumEven[j] + omega*spectrumOdd[j]; spectrum[j + frameHalfSize] = spectrumEven[j] - omega*spectrumOdd[j]; omega *= omegaPowBase; } return spectrum; } public static Complex[] DecimationInFrequency(Complex[] frame, bool direct) { if (frame.Length == 1) return frame; var halfSampleSize = frame.Length &gt;&gt; 1; // frame.Length/2 var fullSampleSize = frame.Length; var arg = direct ? -DoublePi/fullSampleSize : DoublePi/fullSampleSize; var omegaPowBase = new Complex(Math.Cos(arg), Math.Sin(arg)); var omega = Complex.One; var spectrum = new Complex[fullSampleSize]; for (var j = 0; j &lt; halfSampleSize; j++) { spectrum[j] = frame[j] + frame[j + halfSampleSize]; spectrum[j + halfSampleSize] = omega*(frame[j] - frame[j + halfSampleSize]); omega *= omegaPowBase; } var yTop = new Complex[halfSampleSize]; var yBottom = new Complex[halfSampleSize]; for (var i = 0; i &lt; halfSampleSize; i++) { yTop[i] = spectrum[i]; yBottom[i] = spectrum[i + halfSampleSize]; } yTop = DecimationInFrequency(yTop, direct); yBottom = DecimationInFrequency(yBottom, direct); for (var i = 0; i &lt; halfSampleSize; i++) { var j = i &lt;&lt; 1; // i = 2*j; spectrum[j] = yTop[i]; spectrum[j + 1] = yBottom[i]; } return spectrum; } } }</span></span></code> </pre><br><br>  There are two types of FFT algorithms - with thinning in time and frequency, but both give identical results.  The functions take an array of complex numbers filled with real values ‚Äã‚Äãof the amplitudes of the signal in the time domain, and after their execution they return an array of complex numbers containing information about the amplitude and phase spectra.  <b>It is worth remembering that the real and imaginary parts of a complex number are not the same thing as its amplitude and phase!</b> <br><br>  magnitude = Math.Sqrt (x.Real * x.Real + x.Imaginary * x.Imaginary) <br>  phase = Math.Atan2 (x.Imaginary, x.Real) <br><br>  The resulting array of complex numbers is filled with exactly half of the useful information; the other half is only a mirror image of the first and can easily be excluded from consideration.  If you think about it, this moment is well illustrated by the Kotelnikov-Nyquist-Shannon theorem, that the sampling frequency should not be less than the maximum doubled signal frequency ... <br><br>  There is also a variation of the <a href="http://www.codeproject.com/Articles/32172/FFT-Guitar-Tuner">Cooley-Tukey FFT</a> algorithm that is often used in practice, but it is a bit more difficult to understand. <br><br>  Immediately after calculating the Fourier transform, it is convenient to normalize the amplitude spectrum: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spectrum = Butterfly.DecimationInTime(frame, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameSize; i++) { spectrum[i] /= frameSize; }</code> </pre><br>  This will lead to the fact that the magnitude of the amplitude values ‚Äã‚Äãwill be of the same order regardless of the size of the sample. <br><br>  After calculating the amplitude and frequency spectra, it is easy to perform signal processing, for example, apply frequency filtering or compress.  In essence, an equalizer can be made this way: by performing a direct Fourier transform, it is easy to increase or decrease the amplitude of a certain frequency range, and then perform the inverse Fourier transform (although the operation of real equalizers is usually based on a different principle ‚Äî the phase shift of the signal).  Yes, and compress the signal is very simple - you just need to make a dictionary, where the key is the frequency, and the value is the corresponding complex number.  In the dictionary you need to enter only those frequencies, the amplitude of the signal which exceeds some minimum threshold.  Information about "quiet" frequencies that are not heard by the ear will be lost, but you will get a noticeable compression while maintaining an acceptable sound quality.  In part, this principle underlies many codecs. <br><br>  <b>4. Exact frequency determination</b> <br><br>  The discrete Fourier transform gives us a discrete spectrum, where each amplitude value is separated from its neighbors by equal intervals in frequency.  And if the frequency in the signal is a multiple of the step equal to (sampling frequency) / (number of samples), then we will get a pronounced sharp peak, but if the signal frequency lies somewhere between the boundaries of the step closer to the middle, we will have a peak with a ‚Äúcut off‚Äù peak and we it will be difficult to say what the frequency is.  It may very well be that in the signal there are two frequencies lying next to each other.  This is the limitation of the frequency resolution.  Just as in a low-resolution photograph, small objects stick together and become indistinguishable, so also fine details of the spectrum can be lost. <br><br>  But the frequencies of musical notes lie far from the grid of Fourier transform steps, but for everyday tasks of tuning musical instruments and recognizing notes, it is necessary to know the exact frequency.  Moreover, at low octaves with a resolution of 1024 samples and below, the Fourier frequency grid becomes so rare that several notes start to fit in one step and it becomes virtually impossible to determine which one of them actually plays. <br><br>  In order to somehow circumvent this limitation, approximating functions are sometimes used, for example, parabolic. <br>  <a href="http://www.ingelec.uns.edu.ar/pds2803/Materiales/Articulos/AnalisisFrecuencial/04205098.pdf">www.ingelec.uns.edu.ar/pds2803/Materiales/Articulos/AnalisisFrecuencial/04205098.pdf</a> <br>  <a href="https://mgasior.web.cern.ch/mgasior/pap/biw2004_poster.pdf">mgasior.web.cern.ch/mgasior/pap/biw2004_poster.pdf</a> <br>  But all these are artificial measures that, improving some indicators, can give distortions in others. <br><br>  <b>Is there a more natural way to accurately determine the frequency?</b> <br>  Yes, and it is hidden just the same in using the phase spectrum of the signal, which is often neglected. <br>  This method of signal frequency refinement is based on calculating the phase delay of the spectra of two frames superimposed on each other, but slightly shifted in time. <br><br>  Read more about it on the links: <br>  <a href="http://www.guitarpitchshifter.com/algorithm.html">www.guitarpitchshifter.com/algorithm.html</a> <br>  <a href="http://www.dspdimension.com/admin/pitch-shifting-using-the-ft/">www.dspdimension.com/admin/pitch-shifting-using-the-ft</a> (+ code examples) <br>  <a href="http://eudl.eu/pdf/10.1007/978-3-642-29157-9_43">eudl.eu/pdf/10.1007/978-3-642-29157-9_43</a> <br>  <a href="https://ctuner.googlecode.com/">ctuner.googlecode.com</a> (examples of using the algorithm in C ++ and Java) <br><br>  In C #, the implementation of the method looks quite simple: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Rainbow</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Œî‚àÇœâœÄ public static class Filters { public const double SinglePi = Math.PI; public const double DoublePi = 2*Math.PI; public static Dictionary&lt;double, double&gt; GetJoinedSpectrum( IList&lt;Complex&gt; spectrum0, IList&lt;Complex&gt; spectrum1, double shiftsPerFrame, double sampleRate) { var frameSize = spectrum0.Count; var frameTime = frameSize/sampleRate; var shiftTime = frameTime/shiftsPerFrame; var binToFrequancy = sampleRate/frameSize; var dictionary = new Dictionary&lt;double, double&gt;(); for (var bin = 0; bin &lt; frameSize; bin++) { var omegaExpected = DoublePi*(bin*binToFrequancy); // œâ=2œÄf var omegaActual = (spectrum1[bin].Phase - spectrum0[bin].Phase)/shiftTime; // œâ=‚àÇœÜ/‚àÇt var omegaDelta = Align(omegaActual - omegaExpected, DoublePi); // Œîœâ=(‚àÇœâ + œÄ)%2œÄ - œÄ var binDelta = omegaDelta/(DoublePi*binToFrequancy); var frequancyActual = (bin + binDelta)*binToFrequancy; var magnitude = spectrum1[bin].Magnitude + spectrum0[bin].Magnitude; dictionary.Add(frequancyActual, magnitude*(0.5 + Math.Abs(binDelta))); } return dictionary; } public static double Align(double angle, double period) { var qpd = (int) (angle/period); if (qpd &gt;= 0) qpd += qpd &amp; 1; else qpd -= qpd &amp; 1; angle -= period*qpd; return angle; } } }</span></span></code> </pre><br>  The application is also simple: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spectrum0 = Butterfly.DecimationInTime(frame0, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spectrum1 = Butterfly.DecimationInTime(frame1, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameSize; i++) { spectrum0[i] /= frameSize; spectrum1[i] /= frameSize; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spectrum = Filters.GetJoinedSpectrum(spectrum0, spectrum1, ShiftsPerFrame, Device.SampleRate);</code> </pre><br>  Normally, the source frames are shifted by 1/16 or 1/32 of their length, that is, the ShiftsPerFrame is 16 or 32. <br><br>  As a result, we obtain a frequency-amplitude dictionary, where the frequencies will be quite close to real.  However, the "cut peaks" will still be observed, although less pronounced.  To eliminate this disadvantage, you can simply "finish" them. <br><br><img src="https://habrastorage.org/files/0d0/85f/ce2/0d085fce2e424123a0b3555e56e9f0d7.png"><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Rainbow</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Filters</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Dictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Antialiasing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; spectrum</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = spectrum.ToList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; spectrum.Count - <span class="hljs-number"><span class="hljs-number">4</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = j; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x0 = data[i].Key; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>].Key; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y0 = data[i].Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y1 = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = (y1 - y0)/(x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = y0 - a*x0; i += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u0 = data[i].Key; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> u1 = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>].Key; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v0 = data[i].Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v1 = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = (v1 - v0)/(u1 - u0); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = v0 - c*u0; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = (d - b)/(a - c); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = (a*d - b*c)/(a - c); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; y0 &amp;&amp; y &gt; y1 &amp;&amp; y &gt; v0 &amp;&amp; y &gt; v1 &amp;&amp; x &gt; x0 &amp;&amp; x &gt; x1 &amp;&amp; x &lt; u0 &amp;&amp; x &lt; u1) { result.Add(x1, y1); result.Add(x, y); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.Add(x1, y1); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } }</code> </pre><br><br>  <b>Perspectives</b> <br><br>  Music analysis of musical works opens up a number of interesting possibilities.  After all, having a ready-made musical pattern available, you can search for other musical compositions with a similar pattern. <br><br>  For example, one and the same work can be performed on another instrument, in a different manner, with a different timbre, or transposed in octaves, but the musical pattern will remain similar, which will allow you to find different versions of the performance of the same work.  This is very similar to the game "guess the melody." <br><br>  In some cases, such an analysis will help to identify plagiarism in musical works.  Also, according to a musical pattern, theoretically, you can search for works of a particular mood or genre, which raises the search to a new level. <br><br>  <b>Results</b> <br><br>  This article outlines the basic principles for accurately determining the frequencies of acoustic signals and highlighting notes.  And it also shows some subtle intuitive connection of the discrete Fourier transform with quantum physics, which pushes for reflection on a single picture of the world. <br><br>  PS The Rainbow Framework (Rainbow Framework) containing all the above code examples can be downloaded from <a href="https://rainbow.codeplex.com/">Codeplex</a> . <br><br>  PPS Perhaps this article will ever be very useful to you in your professional activity and will help save a lot of time and effort, so if you want to thank the author for your work, you can <a href="http://poet.of.by/ru/download">make a donation</a> , <a href="http://www.windowsphone.com/s%3Fappid%3D29ad20cb-edd9-424b-87c8-23ed9f089a29">buy an application</a> ( <a href="http://www.windowsphone.com/s%3Fappid%3D86df3548-fe24-4b54-b178-f0faf34a6022">free advertising version</a> ), through which the article originated, or just express gratitude with a kind word. <br><br>  <b>Literature</b> <br><br>  1. Basic spectral analysis of sounds <a href="http://pandia.org/text/77/481/644.php">pandia.org/text/77/481/644.php</a> <br><br>  2. Algorithm Cooli-Tukey <a href="http://www.codeproject.com/Articles/32172/FFT-Guitar-Tuner">www.codeproject.com/Articles/32172/FFT-Guitar-Tuner</a> <br><br>  3. Resampling (resampling) <br>  <a href="http://www.dsplib.ru/forum/viewtopic.php%3Ff%3D5%26t%3D11">www.dsplib.ru/forum/viewtopic.php?f=5&amp;t=11</a> <br>  <a href="http://www.dsplib.ru/content/farrow/farrow.html">www.dsplib.ru/content/farrow/farrow.html</a> <br><br>  4. Frequency correction by phase shift <br>  <a href="http://www.guitarpitchshifter.com/algorithm.html">www.guitarpitchshifter.com/algorithm.html</a> <br>  <a href="http://www.dspdimension.com/admin/pitch-shifting-using-the-ft/">www.dspdimension.com/admin/pitch-shifting-using-the-ft</a> (+ code examples) <br>  <a href="http://eudl.eu/pdf/10.1007/978-3-642-29157-9_43">eudl.eu/pdf/10.1007/978-3-642-29157-9_43</a> <br>  <a href="https://ctuner.googlecode.com/">ctuner.googlecode.com</a> (examples of using the algorithm in C ++ and Java) </div><p>Source: <a href="https://habr.com/ru/post/247385/">https://habr.com/ru/post/247385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247373/index.html">14 index questions in SQL Server that you feel shy about asking</a></li>
<li><a href="../247375/index.html">Free application promotion + results</a></li>
<li><a href="../247377/index.html">Apple fixes an important iCloud vulnerability</a></li>
<li><a href="../247379/index.html">On automatic differentiation, Newton's method and solution of SLAE on Delphi. Part 1</a></li>
<li><a href="../247381/index.html">Waterban, PlanTrack, GtkSharp and other funny phrases - a couple of thoughts about why you should make a decision on UE</a></li>
<li><a href="../247389/index.html">How to enable the display of Facebook applications on mobile devices?</a></li>
<li><a href="../247391/index.html">Fail2ban integration with CSF to counter DDoS on nginx</a></li>
<li><a href="../247393/index.html">https comes on geektimes / habrahabr?</a></li>
<li><a href="../247395/index.html">Internet in a closed country: the experience of North Korea</a></li>
<li><a href="../247397/index.html">WS_EX_LAYERED style for child windows in Windows 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>