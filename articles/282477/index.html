<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Async / Await in javascript. View from the outside</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, more and more of my friends, colleagues, and people from the community are talking about working with asynchronous functions, and in particu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Async / Await in javascript. View from the outside</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/534/8cf/c62/5348cfc62b40483f89d3a71bed605ef0.png" width="100%"><br><br>  Recently, more and more of my friends, colleagues, and people from the community are talking about working with asynchronous functions, and in particular about using async / await on their projects.  I decided to figure out for myself what kind of animal it is and whether it should be used in the development of combat projects. <br><br>  <i>The first thing I want to dispel is the common misconception that async / await is an ES7 feature.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In my opinion, the use of the terms ES6 and ES7 is not very true in itself and can mislead the developers.  After the successful release of the ES2015 specification, called ES6, many people had the erroneous view that everything was not included in it and filled through the <a href="http://babeljs.io/">babel</a> - these are features of ES7.  This is not true.  Here is a <a href="http://frontender.info/ecmascript-2016/">list</a> of what appears with the release of the ES2016 specification.  As you can see, it is not so big and async / await doesn‚Äôt appear in it. <br><br>  I want us to talk right.  And speaking of this or that feature, they referred to a specific specification within the framework of which it was described and implemented, and not the mythical <b>ES6, ES7 ... ESN</b> . <br><a name="habracut"></a><br><h2>  Moving on.  So what is async / await in simple terms? </h2><br>  In open <b>source, async / await is <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></b> . <br><br>  When you declare a function as asynchronous, through the magic word <b>async</b> , you say that this function returns a Promise.  Every thing you expect inside this function, using the magic word <b>await</b> , the same returns Promise. <br><br>  <i>This is a very important point for understanding how such functions work and what to expect when working with them.</i> <br><br><h2>  Let's see what our unicorn looks like and see how it works. </h2><br>  Here is a simple example of an asynchronous <a href="https://github.com/reactjs/redux">Redux</a> action for leaving the office: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (dispatch) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">data</span></span>: {success, message}} = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'/logout'</span></span>); (success) ? dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: LOGOUT_SUCCESS }) : dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: LOGOUT_FAILURE, message }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: LOGOUT_FAILURE, e.data.message }); } }; }</code> </pre> <br><h2>  And now we go from the general to the particular </h2><br>  After reading a number of articles and playing on my own, I made up for myself a short brief answering basic questions with a few examples. <br><br><h2>  What you need to do to get started? </h2><br>  If you do not use any build system, it is enough to install babel and babel-runtime. <br><br><pre> <code class="bash hljs">babel test.js -o <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-compile.js ‚Äîoptional runtime ‚Äîexperimental</code> </pre><br>  In other cases, it is better to watch the settings based on their build system and babel version.  This is very important, as the settings in the babel5 and babel6 versions are very different. <br><br><h2>  How is an asynchronous function created? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unicorn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rainbow = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getRainbow(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rainbow.data.colors }</code> </pre><br>  Creating an asynchronous function consists of two main parts: <br><br>  1. Use the word async before declaring a function. <br><br>  <i>As we can see from the example c logout (), this also works when using switch functions.</i>  <i>It also works for class functions and static functions.</i>  <i>In the latter case, async is written after static.</i> <br><br>  2. In the body of the function itself, we must use the word await. <br><br>  <i>Using the word await signals that the main code would wait and not return the response until some action is performed.</i>  <i>It simply processes the Promise for us and waits until it returns the resolve or reject.</i>  <i>Thus, it seems that the code runs synchronously.</i> <br><br>  <i><b>*</b> To work with await, the function must be asynchronous and declared using the async keyword.</i>  <i>Otherwise it just won't work.</i> <br><br><h2>  How does await work and what does it do? </h2><br>  As mentioned earlier, await waits for any Promise.  Drawing an analogy with the operation of the Promise object, it can be said that await performs the exact same function as its .then () method.  The only significant difference is that it does not require any callback functions for receiving and processing the result.  Actually due to this, it seems that the code is executed synchronously. <br><br><h2>  Well, if await is an analog of .then () in Promise, how can I catch and handle exceptions? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unicorn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rainbow = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getRainbow(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rainbow.data.colors; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: e.data.message, <span class="hljs-attr"><span class="hljs-attr">somaText</span></span>: <span class="hljs-string"><span class="hljs-string">'     '</span></span> } } }</code> </pre><br>  Since the code is in synchronous style, for this reason we can use the good old try / catch to solve such problems. <br><br>  Additionally, I want to focus on this attention. <br><br><img src="https://habrastorage.org/files/54d/a2d/e6f/54da2de6f982499c8900601b3f1c28e9.png" width="100%"><br><br>  Using try / catch is the only way to catch and handle an error.  If for some reason you decide not to use it or simply forget it, this can lead to a lack of processing capability, as well as loss at all. <br><br><h2>  At what point does the following await code execute? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unicorn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _colors = []; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rainbow = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getRainbow(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rainbow.data.colors.length) { _colors = rainbow.colors.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">color</span></span></span><span class="hljs-function">) =&gt;</span></span> color.toUpperCase()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _colors; }</code> </pre><br>  The code following await continues its execution only when the function used with await returns <b>resolve</b> or <b>reject</b> . <br><br><h2>  What if the function used with await does not return Promise? </h2><br>  If the function used with await does not return Promise, and we already know that await is waiting for it, then the code will continue as if we did not use await at all. <br><br><h2>  What if I declare an asynchronous function, but do not use await? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unicorn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rainbow = getRainbow(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rainbow; }</code> </pre><br>  In this case, at the output, we get a simple reference to the Promise function getRainbow (). <br><br><h2>  What happens if I write several functions using await in a row? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unicorn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rainbow = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getRainbow(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> food = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getFood(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {rainbow, food} }</code> </pre><br>  This code will be executed sequentially.  First, getRainbow () will work, after it returns resolve or reject, getFood () will start working.  One challenge, one result. <br><br><h2>  And if I need to simultaneously receive the result from several calls? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unicorn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [rainbow, food] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([getRainbow(), getFood()]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {rainbow, food} }</code> </pre><br>  Since we have already figured out that we are dealing with Promise.  Therefore, you can use the method.  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">all ()</a> of the Promise object for solving such problems. <br><br>  Additionally, I want to note that the await * arrayOfPromises construction is no longer relevant and has been removed from the specification.  When you try to use it, you will receive a message with love that it is better to use Promise.all (). <br><br>  Sample message: <br><pre> <code class="bash hljs"> await* has been removed from the async <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span> proposal. Use Promise.all()</code> </pre><br>  <i>Updated await design information *.</i>  <i>Thanks <a href="https://habrahabr.ru/users/xgrommx/" class="user_link">xGromMx</a> and <a href="https://habrahabr.ru/users/degorov/" class="user_link">degorov</a> .</i> <br><br><h2>  What else would be good to know for successful work? </h2><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAllUnicorns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">names</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(names.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unicorn = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getUnicorn(name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unicorn; })); }</code> </pre><br>  You need to remember that if you start using async / await in your project, you need to be prepared for the fact that almost your entire stack will have to be asynchronous.  And this can add quite a few problems and inconveniences. <br><br>  <b>It seems to be all.</b> <br><br>  We have dealt with the main theoretical aspects, if something remains unclear or you have something to add, I wait in the comments. <br><br>  And for me, the time has come to put all the information together, and decide what to do with our asynchronous unicorn.  Take with you on a release journey or leave home for your Pet projects. <br><br><h2>  Findings: </h2><br>  At first glance, asynchronous functions cause positive emotions.  Such a <i>nice thing that</i> makes your code synchronously similar, which makes it more concise and readable. <br><br>  But it is at first glance. <br><br>  Yes, the code is concise and readable.  Yes, it looks pretty.  But as soon as you try to write something harder than a normal API or complex interrelated scripts, for example, a queue of tasks for working with a database, you immediately encounter the problem of an asynchronous stack. <br><br>  Almost all forever green browsers, out of the box, are 93% -98% supported by ES2015 features ( <a href="https://kangax.github.io/compat-table/es6/">table</a> ).  For me, this means that starting a new project, based on the requirements and the stack, I will think about the need for babel on the project. <br><br>  But, if I decide to use async / await, I will have to use babel.  And I can not say that it will add beauty to <a href="https://babeljs.io/repl/">my code</a> .  After all, officially there is no async / await, and it is not known whether it will be at all.  And this is a big minus for me. <br><br>  I also don‚Äôt like the fact that if I forgot to use await or simply not successful copy-paste, instead of automatically sending an error, I won‚Äôt get anything except for the reference to Promise.  This can be fraught with consequences, especially when a large project with several developers. <br><br>  And the last. <br><br>  Most tasks using async / await are perfectly solved with the help of <a href="https://learn.javascript.ru/generator">generators</a> . <br><br>  First, they have better support. <br>  Secondly, the work of generators will be more natural and predictable. <br>  Thirdly, babel himself leads such a code to the generator with special settings <a href="https://babeljs.io/repl/">example 1</a> , <a href="https://babeljs.io/docs/plugins/transform-async-to-generator/">example 2</a> . <br><br><h2>  Support in NodeJS </h2><br>  Async / await already experimentally got into V8.  This means that from the version of nodejs 7, you can play with it and work right out of the box. <br>  How to do it: <br><pre> <code class="javascript hljs">NVM_NODEJS_ORG_MIRROR=https:<span class="hljs-comment"><span class="hljs-comment">//nodejs.org/download/nightly nvm install 7 nvm use 7 node --harmony-async-await app.js</span></span></code> </pre><br><br><h2>  Total </h2><br>  I answer the question asked at the very beginning: <br>  If I use asynchronous functions, it is only on my Pet projects and not very large workers, mainly for writing the API.  At least until everything is standardized and will not be flagged experimentally. <br><br>  <i>For example, I liked using them in actions for Redux.</i>  <i>Everything looks beautiful and harmonious.</i> <br><br>  I wrote this material first of all for myself in order to deal with the question that interests me.  If this material is still useful to someone, I will be very happy. <br><br>  Also, in the next article, I would like to compare in detail the different approaches to the implementation of asynchrony (callbacks, promises, generators, atoms).  So that this is understandable not only to the gurus, but also to people just starting out in javascript. <br><br>  <b>Thank you all for your attention.</b>  <b>Good luck!</b> </div><p>Source: <a href="https://habr.com/ru/post/282477/">https://habr.com/ru/post/282477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282465/index.html">One little problem downloading files on slow connections</a></li>
<li><a href="../282467/index.html">How to connect the Internet in one day and set up telephony in the office?</a></li>
<li><a href="../282471/index.html">Yandex has developed a corporate font</a></li>
<li><a href="../282473/index.html">Integration of PVS-Studio into the CI process</a></li>
<li><a href="../282475/index.html">The implementation of the simulator of the mathematical game "Life"</a></li>
<li><a href="../282479/index.html">CRM: April theses from Ruli24</a></li>
<li><a href="../282485/index.html">New Firefox 46.0 is available for free on FTP Mozilla</a></li>
<li><a href="../282489/index.html">Hackers and exchanges: The consequences of attacks on financial companies</a></li>
<li><a href="../282491/index.html">A word guru, problems with unity3d, and a happy ending in the end</a></li>
<li><a href="../282493/index.html">Communications in store-and-forward mode, UUCP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>