<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a web application on Go in 2017</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 

1. Part 1 
2. Part 2 
3. Part 3 
4. Part 4 


 A couple of weeks ago, I started developing another web application, only now on Go . Being m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a web application on Go in 2017</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><ol><li>  <strong>Part 1</strong> </li><li>  <a href="https://habrahabr.ru/post/329584/">Part 2</a> </li><li>  <a href="https://habrahabr.ru/post/329612/">Part 3</a> </li><li>  <a href="https://habrahabr.ru/post/329622/">Part 4</a> </li></ol></div></div><br><p>  A couple of weeks ago, I started developing another web application, only now on <a href="https://golang.org/">Go</a> .  Being mainly a backend developer, I didn‚Äôt write the whole web application often, so each such case was more like a challenge.  At such times, I wanted someone to write a guide to web development for people who do not have the opportunity to go all day into the subtleties of great design, but who just need to create a working, functional website without too much fuss. </p><br><p>  I decided to take this opportunity and make such a guide in which to start a web application from scratch in the way it should be done in 2017 (in my understanding).  I spent many hours digging into things that I used to avoid before, just so that at least once in many years I could say with confidence that I have my own opinion and experience in this matter, and get a working recipe for myself which may be useful not only for me. </p><a name="habracut"></a><br><p>  The article begins a short series highlighting what I learned in the process.  This first post is a general introduction describing the current state of affairs, problems and why I think Go is a good choice.  Subsequent articles will be more detailed and contain more code.  I am curious how my experience correlates with yours;  maybe I‚Äôm wrong about something, so feel free to comment. </p><br><p>  If you are only interested in the code, it is <a href="https://github.com/grisha/gowebapp">here</a> . </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  Previously, my basic knowledge of HTML, CSS, and JavaScript was enough for my modest needs in site-building.  Most of the applications that I have ever created have been made using <a href="https://github.com/grisha/mod_python">mod_python</a> , directly using the handler publishing mechanism (note: per.: You can see an example <a href="">here</a> ).  It's funny that being an early follower of Python, I also worked a lot with <a href="http://rubyonrails.org/">Rails</a> .  Over the past few years, I have focused on the infrastructure of (big) data, which is not at all a web development, although the need for web interfaces is not uncommon here.  In fact, the application I am working on is an application for working with data, but it is not an open source and what it does is irrelevant for this article.  In general, this should make it clear which way I look at it all. </p><br><h2 id="python-i-ruby">  Python and Ruby </h2><br><p>  A year ago, I would recommend Python or Ruby as a web application environment.  There may be other similar languages, but from my point of view, Python and Ruby dominate the world. </p><br><p>  Most of the time, the main task of the web application was to construct the web pages using the layout of the final HTML on the server side.  Both Python and Ruby are very well suited for extracting data from a database and turning it into a bunch of HTML code using templates.  There are many frameworks / tools to choose from, for example, Rails, Django, Sinatra, Flask, etc.  etc. </p><br><p>  And although these languages ‚Äã‚Äãhave certain significant limitations, such as <a href="https://ru.wikipedia.org/wiki/GIL">GIL</a> , the ease with which they solve the problem of generating HTML is much more valuable than the compromises that have to be made. </p><br><h2 id="gil">  GIL </h2><br><p>  GIL (Global Interpreter Lock) is a special mention.  Of course, this is the biggest limitation of any solution in Python or Ruby, but this is a very slippery topic, people often prefer to pretend that there is no problem.  And if we‚Äôre talking about it, emotions usually go over the edge, endless discussions on the topic of GIL take place in the Ruby and Python communities. </p><br><p>  For those unfamiliar with this problem, GIL allows only one thing to be executed at a time.  When you create threads and they ‚Äúlook‚Äù like running in parallel, in fact the interpreter still executes the instructions sequentially.  This means that one process can use only one CPU. </p><br><p>  There are alternative implementations, for example, based on JVM, but they are rarely used.  I don‚Äôt know exactly why, maybe they are not fully compatible, or they probably don‚Äôt support C-extensions correctly, and they may still have GIL.  Not sure, but as far as I can tell, the implementation in C is usually used. To make an interpreter without GIL, you have to rewrite it completely, and this can already change the behavior of the language (in my naive understanding), and therefore it seems to me that GIL will remain. </p><br><p>  Web applications of any significant scale necessarily require the ability to service requests in parallel, using the capabilities of each CPU on the machine.  So far, the only possible solution is to launch several instances of the application as separate processes. </p><br><p>  This is usually done using additional software, such as Unicorn / Gunicorn, with each process listening to its own port and running behind some kind of connection balancer, such as Nginx and / or Haproxy.  Alternatively, this can be done through Apache and its modules (such as mod_python or mod_wsgi), in any case it is difficult.  Such applications usually rely on the database server as an arbiter for any competitively sensitive tasks.  When implementing caching, in order not to store multiple copies of the same on the same server, shared storage is required, such as Memcached or Redis, and usually both.  Also, these applications can not do background processing, for this there is a separate set of tools, such as Resque.  And then all of these components require monitoring to be sure that it all works.  Logs must be consolidated, and they have their own additional tools.  Given the inevitable complexity of this setup, a configuration manager, such as Chef or Puppet, is also required.  Nevertheless, these kits are usually not able to support a large number of long-term compounds - a problem known as <a href="https://ru.wikipedia.org/wiki/C10k">C10K</a> . </p><br><p>  As a result, a simple web application with a database requires a whole bunch of parts before it can serve the Hello World! Page.  And almost all of this is due to GIL. </p><br><h2 id="poyavlenie-odnostranichnyh-prilozheniy">  Appearance of one-page applications </h2><br><p>  Farther and farther into the past is the generation of HTML on the server.  The latest (and correct) trend is to build the user interface and render completely on the client side, using JavaScript.  Applications whose user interface is completely controlled by JS are sometimes called a <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">one-page application</a> and, in my opinion, the future is with them, whether we like it or not.  In such applications, the server only serves the data, usually in the form of JSON, without generating HTML code.  In this case, that enormous complexity, introduced primarily for the possibility of using the popular scripting language [to create a web application], turns out to be unnecessary.  Especially considering that Python or Ruby brings little benefit when all output is JSON. </p><br><h2 id="vzglyad-na-golang">  Golang look </h2><br><p>  Go is gradually undermining the established world of web applications.  It natively supports parallel execution, which eliminates the need for almost all components commonly used to work with GIL constraints. </p><br><p>  Go programs are binary programs that are natively launched, so no language-specific installation is required on the server.  The problem of ensuring the correct version of the execution environment required by the application disappears;  There is no separate execution environment - it is built into the binary.  Go programs can easily and elegantly run tasks in the background, so there is no need for tools like Resque.  These programs run as a single process, so caching becomes trivial, which means that Memcached or Redis are not needed.  Go can control an unlimited number of parallel connections, leveling the need for front-end protection, such as Nginx. </p><br><p>  With Go, a high layered tower from Python, Ruby, Bundler, Virtualenv, Unicorn, WSGI, Resque, Memcached, Redis, etc., etc.  reduced to just one binary.  The only third-party component that is usually still needed is the database (I would advise PostgreSQL).  It is important to note here that all these tools can still be used, but you can do without them with Go. </p><br><p>  The launch time of such a Go program will most likely be an order of magnitude greater than any Python / Ruby application, requiring less memory and lines of code. </p><br><h2 id="horosho-a-est-populyarnyy-freymvork">  Well, is there a popular framework? </h2><br><p>  The short answer is: the framework is optional and not recommended.  There are many projects that claim to be a great framework, but I think it's better to do without them.  This is not only my personal opinion, I find this opinion fairly common in the Go community. </p><br><p>  It is necessary to understand why frameworks were created at all.  In the world of Python / Ruby, this happened because these languages ‚Äã‚Äãwere not originally designed to serve web pages, and many external components were needed to solve this problem.  The same can be said about Java, which, like Python and Ruby, is as old as the web, as we know it, or even a bit older. </p><br><p> As far as I remember, early versions of Python "out of the box" did not provide anything for working with the database, there were no templates, HTTP support was confusing, work with the network was nontrivial, even encryption was then illegal and in general, a lot of things were missing.  The framework provided all these necessary pieces and set language-specific development rules for all common variants of web applications. </p><br><p>  Go, on the other hand, was created by people who already had experience and were versed in web development.  It includes almost everything you need.  One or two external packages may be needed to solve some specific problems, such as OAuth, but in no case this pair of packages is a ‚Äúframework‚Äù. </p><br><p>  If all of the above with regards to frameworks does not sound convincing enough, it is useful to consider the learning curve for frameworks and risks.  It took me about two years to build a relationship with Rails.  Frameworks can become abandoned and obsolete, and it is hard and sometimes impossible to port an application to a new framework.  Considering how quickly everything changes in information technology, the framework certainly should not be chosen lightly. </p><br><p>  I would like to highlight tools and frameworks that attempt to mimic idioms common to Python, Ruby, or JavaScript environments.  Everything that looks, or feels, or claims the role of ‚ÄúRails for Go‚Äù, including techniques such as injections, dynamic publication of methods, etc., which are highly dependent on reflection, does not fit Go ideology, therefore it‚Äôs better to stay away. </p><br><p>  Undoubtedly, frameworks make some things easier, especially in the typical world of CRUD applications for business, where applications have many pages with a large number of fields, manipulate data in complex and constantly changing database schemas.  I'm not sure that in such an environment Go is a good choice, especially if performance and scalability are not in priority. </p><br><p>  Another problem common to frameworks is that they abstract the low-level mechanisms from the developer so that over time they become so mysterious that it is literally impossible to understand what they really have going on there.  What begins with a lexical pseudonym for a single line of JavaScript becomes a layer in layers of transpilers, minimizers, on top of helpers hidden somewhere in subdependencies.  Once something breaks, and it is impossible to understand where to look for the problem.  It's nice when you know exactly what is happening, and Go is very good at it. </p><br><h2 id="kak-naschet-bazy-dannyh-i-orm">  How about a database and ORM? </h2><br><p>  Similar to frameworks, ORMs in Go are not very common.  To begin with, Go does not support objects - what is indicated by O in the abbreviation ORM. </p><br><p> I know if instead of using the convenient <code>User.find(:all).filter...</code> , which is provided with something like ActiveRecord, writing SQL manually is something unheard of in some communities, but I still think that this attitude must change.  SQL is a great language.  Dealing with SQL directly is not so difficult, and in return we get more freedom and opportunities.  Perhaps the most tedious part of such direct work is copying data from the database cursor to the structures, but the <a href="https://github.com/jmoiron/sqlx">sqlx</a> project is very useful <a href="https://github.com/jmoiron/sqlx">here</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In my opinion, the article describes in some detail the current situation on the server side.  I think the client part is better to be allocated in a separate post, so today - everything.  To summarize, we build an application with approximately the following requirements: </p><br><ul><li>  Minimal dependency on third party packages. </li><li>  No web framework. </li><li>  PostgreSQL as a database. </li><li>  Single page application. </li></ul><br><p>  <a href="https://habrahabr.ru/post/329584/">Continuation</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329582/">https://habr.com/ru/post/329582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329572/index.html">Experience of transition from Waterfall to RUP methodology for the implementation of large IT projects</a></li>
<li><a href="../329574/index.html">Smart IDReader SDK - how to add recognition in an iOS application in 5 minutes - now on Github</a></li>
<li><a href="../329576/index.html">Modeling designs. Requirements for the modeler</a></li>
<li><a href="../329578/index.html">Three cycles in the Lorenz attractor</a></li>
<li><a href="../329580/index.html">What is waiting for us in Swift 4?</a></li>
<li><a href="../329584/index.html">Creating a web application on Go in 2017. Part 2</a></li>
<li><a href="../329592/index.html">learnopengl. Lesson 2.1 - Colors</a></li>
<li><a href="../329594/index.html">Is there too much text in your game?</a></li>
<li><a href="../329596/index.html">A bit of reverse-engineering USB flash on the SK6211 controller</a></li>
<li><a href="../329598/index.html">Online course "Functional Security of Computer Systems"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>