<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Professional programming for artificial intelligence systems in PROLOG</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the tasks of artificial intelligence, various models of knowledge representation and computational methods are used - soft computations, genetic al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Professional programming for artificial intelligence systems in PROLOG</h1><div class="post__text post__text-html js-mediator-article">  In the tasks of artificial intelligence, various models of knowledge representation and computational methods are used - soft computations, genetic algorithms, neural networks, logical models and other approaches.  All these methods are based on symbolic calculations and therefore can be implemented on the basis of the PROLOG language. <br>  Here we look at the methods of building intelligent systems based on a logical approach that is closest to the nature of logical programming and is often used in expert systems. <br><a name="habracut"></a><br>  The basis of the logical conclusion is the mathematical concept of "formal system (FS)".  FS is a collection of abstract objects interconnected by certain rules.  Recall the definition.  The formal system F is given if the quad is defined: <br>  F = (Al, Sn, Ax, Ru) <br>  Al - the alphabet - a finite set of characters; <br>  Sn - syntax - the procedure for constructing correctly constructed FS formulas; <br>  Ax - axioms - the set of correct formulas given initially; <br>  Ru - inference rules - a finite set of rules that allow to obtain new formulas from other FS formulas. <br>  Any program in the language of the PROLOGUE is a FS, which in one program can be several.  In the PROLOGUE, the notion of unification plays an important role, allowing the FS rules to be more widely applied by substitution of parameters.  A good example of a file system in a program is the PROLOG () parser. <br>  FS can be used to generate new statements (direct inference) or to prove the correctness of statements (inverse conclusion).  In the PROLOGUE, both variants of inference can be realized, although the reverse inference is realized directly, since it is embedded in the structure of the language. <br>  A logic programming language provides many interesting possibilities for solving intellectual problems, i.e.  requiring logical inference to obtain a solution.  As a rule, the possibilities of a language in creating various types of application systems are demonstrated in fairly simple examples, intended more to demonstrate the paradigm of logic programming, for educational purposes. <br>  To create practically useful application systems, a number of properties are required which are absent in the PROLOG system, but which can be added to it. <br>  Just in case, let us recall that the computation in logic programming consists in the search for logical inference.  This term refers to a tree whose root is the statement to be proved, and the remaining vertices contain statements related to each other by logical following.  At the same time, the terminal vertices (leaves) of the tree must be the initial data - assertions formulated in the problem statement. <br>  Building a logical inference tree consists in searching for interrelated chains of statements from leaves to apex among a set of all possible paths from top to leaves.  This set is called the task search space. <br>  Search can be direct - from data to the desired and reverse - from the desired to the data.  In the first approach, the conditions of the problem calculate what is possible - the new statements, thereby increasing the amount of the known about the problem. <br>  In the second approach, hypotheses are built - a sequence is built, more precisely a tree, hypotheses, which should lead to known data. <br>  Since the PROLOGUE is based on inverse output, we first consider inverse output. <br>  To illustrate the problems that arise when constructing non-toy expert systems, we use as a subject area planimetry, more precisely, its small part associated with the solution of triangles. <br>  Consider a specific task. <br>  In an isosceles triangle, there is a height from a vertex located between equal sides.  In the resulting inner triangle, the height is again drawn, then another height in the new triangle, and so on.  total - 10 heights.  The base length of triangle AC and side BC is known.  Any triangle formed by the altitudes must be solved. <br>  The presentation of the main objects can be as follows: <br><br><ul><li>  seg (A, B) - a segment with end points A and B; </li><li>  tri (A, B, C) is a triangle with vertices A, B, C; </li><li>  length (seg (A, B), L) is the length of the segment; </li><li>  equal (tri (A, B, C), tri (X, Y, Z)) - equality of triangles. </li></ul><br><img src="https://habrastorage.org/files/e6f/ee0/04e/e6fee004e9cd461698bb64be1723e2d1.bmp"><br>  For simplicity, consider the calculation of the second height of the triangle - DE.  Let us write the conditions of the problem by means of the PROLOG language: <br><br>  s (1, exist (d, tri (a, b, c))). <br>  s (2, height (seg (b, d), tri (a, b, c))). <br>  s (3, height (seg (d, e), tri (b, c, d))). <br>  s (4, height (seg (f, e), tri (b, e, d))). <br>  s (5, height (seg (f, g), tri (f, e, d))). <br>  s (6, height (seg (h, g), tri (f, g, e))). <br>  s (7, height (seg (h, i), tri (g, h, e))). <br>  s (8, height (seg (i, k), tri (h, i, e))). <br>  s (9, height (seg (k, l), tri (i, k, e))). <br>  s (10, height (seg (l, m), tri (l, k, e))). <br>  s (11, height (seg (m, n), tri (m, l, e))). <br>  s (12, equal (seg (a, b), seg (b, c))). <br>  s (13, length (seg (a, b), 10)). <br>  s (14, length (seg (a, c), 16)). <br>  s (15, length (seg (d, e), x)). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To ensure the numbering of the conditions of the problem, the predicates are written in additional brackets in the form of s (N, P). <br>  The last line in the source data of the problem defines the goal - the statement that must be proved.  In our case, the target length (seg (d, e), x) contains the variable x, which allows us to calculate the value of the length of the segment DE. <br>  One of the main difficulties in applying the PROLOGUE to the implementation of commercial systems is the occurrence of a program looping during the calculation process.  The reason for this may not be an error in the program, but the recursiveness of the properties of the objects of the domain and, accordingly, the recursiveness of the rules of inference. <br>  For example, in the inference rules for solving triangles, inevitably there is a recourse to similar rules. <br>  Example 1, Calculating the length of a segment in a triangle. <br><br>  Calculating the length of the side of a triangle through height and area: <br>  length (seg (A, C), L): - <br>  height (seg (B, D), tri (A, B, C)), <br>  length (seg (B, D), L1), <br>  area (tri (A, B, C), S1), <br>  L is (2 * S1) / L1. <br><br>  Calculate the length of the height of the triangle through the base and area: <br>  length (seg (B, D), L): - <br>  height (seg (B, D), tri (A, B, C)), <br>  length (seg (A, C), L1), <br>  area (tri (A, B, C), S1), <br>  L is (2 * S1) / L1. <br><br>  To solve our problem, four rules are enough to calculate the length of the segment ‚Äî calculating the length of the segment formed by the height of an isosceles triangle, the Pythagorean theorem, calculating the length of height through the area and the base of the triangle, and getting the value from an equal segment. <br>  In the process of finding a solution, all emerging goals are numbered.  All the solutions that were considered in the search process form the task search space, from which only a small part falls into the resulting logical inference tree. <br>  The solution - the logical inference tree for our problem can be written as a list of numbered predicates as follows: <br><br><ol><li>  (78) hypot (tri (d, b, c), seg (b, c)) [79] </li><li>  (45) exist_rect (tri (d, b, c), seg (d, b)) [2] </li><li>  (46) length (seg (d, c), 8) [14,47] </li><li>  (66) length (seg (b, c), 10) [13,12] </li><li>  (77) pif_length ([seg (d, b), 6], [[seg (d, c), 8], [seg (b, c), 10]]) [78] </li><li>  (47) median (tri (a, b, c), seg (b, d)) [2.48] </li><li>  (333) rectangle (tri (c, d, b), _ 2F28) [2] </li><li>  (334) catets (tri (c, d, b), [seg (b, d), seg (d, c)]) [78] </li><li>  (44) length (seg (d, b), 6) [77,66,46,45] </li><li>  (46) length (seg (d, c), 8) [14,47] </li><li>  (332) area (tri (c, d, b), 24) [46,44,334,333] </li><li>  (66) length (seg (b, c), 10) [13,12] </li><li>  (331) length (seg (d, e), 4.8) [66,332,3] </li></ol><br>  Each predicate is a goal derived from the process of solving a problem and has a number assigned to it in the course of calculations.  On the right, in square brackets, is the list of predicate numbers used in the rule of the same name for obtaining the result. <br>  The same tree in the graphical representation has the following form: <br><br><img src="https://habrastorage.org/files/c2d/76a/f17/c2d76af17d2740db90df2c85a0523c92.bmp"><br>  As you can see from the figure, all terminal vertices of the tree are statements from the source data. <br>  We present a textual interpretation of the solution obtained. <br>  1) To calculate the length of the segment seg (d, e) (331), the rule is used: if the desired segment is height in a triangle, then its length is equal to the area of ‚Äã‚Äãthe triangle divided by the base and multiplied by two.  Arguments for this rule are derived from targets with numbers 66,332.3, <br>  The area of ‚Äã‚Äãthe triangle cdb is 24 - target 332. The length of the base bc is 10 - target 66. The required length is 2 * (24/10) = 4.8.  The segment de is the height of the triangle cdb - goal 3 (initial data). <br>  2) The length of the segment bc (66) is calculated from the rule - if the desired segment is equal to another segment with a known length, then the desired length is equal to the length of an equal segment. <br>  In our case, the desired segment bc is equal to the segment ab - this is specified in the source data ‚Äî goal 12, the length of the segment ab is specified in statement 13. <br>  3) The area of ‚Äã‚Äãthe triangle cdb (332) is calculated according to the rule for right-angled triangles by the lengths of the legs, the arguments are given by targets 46,44, 333, 334. <br>  The rectangle triangle cdb (333) follows from the fact that the segment bd is the height of the triangle abc (2).  This implies the definition of segments that are legs in this triangle ‚Äî bd and dc (334).  This is followed by the calculation of the lengths of the legs (44) and (46). <br>  4) The length of the leg db (44) is calculated through the right-angled triangle bdc of the targets with numbers 77,66,46,45. <br>  Goal 77 - apply the Pythagorean theorem to calculate the segment db.  Target 66 - calculate the length of the segment bc.  Goal 46 is the length of the segment dc.  Objective 45 is the presence of a right-angled triangle dbc with the required segment db. <br>  5) The length of the leg dc (46) is calculated from targets 14, 47 according to the segment rule with the median of a triangle.  Target 14 is specified in the source data ‚Äî the length of the ac segment to which the median bd (47) is omitted.  The rule applies - height in an isosceles triangle, dropped on its base, is the median. <br><br>  Since in the given example the data were obtained as a result of applying a specific logic program, it can be assumed that the search volume was 334 targets, of which 13 were the necessary solution of the problem. <br>  For a more complicated case, for example, to calculate the tenth height in our triangle - the segment LM, the search volume was 1667 targets, and in the process of finding a conclusion, 138 statements were made, of which not all were included in the desired solution.  The insignificant amount of search is due to the fact that only four rules were used to calculate the length of the segment. <br>  We looked at a simplified example to illustrate the main aspects of solving problems that require logical inference.  If we try to describe all the planimetry theorems for calculating the length of a segment ‚Äî the similarity and equality of triangles, trigonometric functions, composite segments, the volume of necessary calculations increases by orders of magnitude and here we will need to have additional possibilities to cope with all the arising difficulties. <br>  In order to solve sufficiently voluminous intellectual tasks, the usual PROLOG language is not enough, since it lacks a number of properties, without which it is difficult to build a practically useful program.  These improvements to the PROLOGUE language system can be divided into two groups - the control of finding the output (logical) and technological. <br>  The following search management enhancements are needed: <br><br><ul><li>  looping protection; </li><li>  save created output; </li><li>  the ability to work with large volumes of rules; </li><li>  saving the trace of the search of output in the state space of the subject area for debugging; </li><li>  management of the volume of calculations to protect against unnecessary inefficient searches in the presence of an error or lack of a solution; </li><li>  building an explanation of the decision. <br>  Technological improvements: </li><li>  integration with procedural programming languages; </li><li>  integration with operating system tools; </li><li>  code efficiency; </li><li>  the possibility of creating offline programs. <br>  Most modern systems of the PROLOGUE language have a compiler and other tools that provide the ability to create application programs that are applicable without the PROLOG language interpreter, in conjunction with programs in other programming languages ‚Äã‚Äãor autonomously. <br>  To obtain search improvements, it is necessary to insert additional checks in each PROLOG rule in the application program and, accordingly, additional arguments. <br>  In order not to do it manually, you can use special tool systems.  The research and production company Semantics Research has developed a system called Exxlog, which can be downloaded for free on the company's website (exxlog.ru). </li></ul><br>  Conclusion <br><br>  We reviewed the main aspects of building a formal system in the form of a program for solving logical problems.  FS solves problems by full busting options. <br>  If the method given here describes the rules for all the necessary planimetry theorems, the search space will be very heavy for the average computer, and maybe for a supercomputer.  However, we are well aware that a sensible schoolchild will solve almost any problem that can be solved in a reasonable time, without performing too much enumeration. <br>  How he does it?  By analyzing and planning solutions, outlining the most promising approaches and not considering deliberately useless.  The knowledge that he will use to plan the solution is not a geometric theorem - this is the knowledge that is called expert - knowledge about the methods of finding a solution that an expert usually gets in the process of learning and develops independently in the process of gaining experience. <br>  Conclusion - one FS is not an expert system.  For ES, you need to combine several FS.  In the following, we will consider in more detail how to do this. <br></div><p>Source: <a href="https://habr.com/ru/post/277229/">https://habr.com/ru/post/277229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277197/index.html">PHP Digest number 79 - interesting news, materials and tools (February 1 - 14, 2016)</a></li>
<li><a href="../277201/index.html">Yii 2.0.7</a></li>
<li><a href="../277203/index.html">FBD game ‚Äú2048‚Äù per hour</a></li>
<li><a href="../277209/index.html">Installing and configuring Yii2 on a shared hosting</a></li>
<li><a href="../277221/index.html">Nominal rows for JavaScript and GOST-28884-90</a></li>
<li><a href="../277231/index.html">Training courses. Training</a></li>
<li><a href="../277233/index.html">How graph databases help fight e-commerce fraud</a></li>
<li><a href="../277235/index.html">Preparing ASP.NET Core: how to present static content as resources</a></li>
<li><a href="../277237/index.html">How do we decide what to do?</a></li>
<li><a href="../277239/index.html">How not to recover data, or so lucky for you too</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>