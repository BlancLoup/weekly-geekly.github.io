<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Latent semantic analysis and python search</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, Google announced that it is moving from keyword search to fully semantic search. I do not know how cool the search algorithms of the world g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Latent semantic analysis and python search</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/582/b0c/d0d582b0cda179c2b9831140ab929525.png"><br><br>  Recently, Google announced that it is moving from keyword search to fully semantic search.  I do not know how cool the search algorithms of the world giants are, but the search in the small sandbox turns out to be rather semantic.  Of course, with the search for less large amounts of data, everything is not so rosy, you need to prepare words very carefully, but nevertheless. <br><br>  Immediately make a reservation: who is interested only in theory, then I refer to a very good <a href="http://habrahabr.ru/post/110078/">article on Habr√©</a> , who is not particularly interested in how everything works, and only production is interested, he can try a <a href="http://radimrehurek.com/gensim/tutorial.html">good library for semantic search on python</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  So, we have a list with a dozen documents, according to which we will look for: <br><br><pre><code class="python hljs">titles =[ <span class="hljs-string"><span class="hljs-string">"      WikiLeaks"</span></span>, <span class="hljs-string"><span class="hljs-string">"      ,  "</span></span>, <span class="hljs-string"><span class="hljs-string">"      19 "</span></span>, <span class="hljs-string"><span class="hljs-string">"     Wikileaks  "</span></span>, <span class="hljs-string"><span class="hljs-string">"     "</span></span>, <span class="hljs-string"><span class="hljs-string">"      Wikileaks"</span></span>, <span class="hljs-string"><span class="hljs-string">"         "</span></span>, <span class="hljs-string"><span class="hljs-string">"    WikiLeaks, ,  "</span></span>, <span class="hljs-string"><span class="hljs-string">"        "</span></span> ]</code> </pre> <br><br>  Actually this is the input data.  Now we need to do three preparatory operations: <br>  1) Remove different commas, periods, colons, if there is html and other garbage from the text. <br>  2) Bring everything to lower case and delete all prepositions in, on, for, and so on. <br>  3) Bring the words into normal form, that is, since to search for words like bonus, bonuses, etc. will be different words, you need to fix this. <br>  4) If we just want to find similar documents, then we can delete the words that occur only once - they are useless for analyzing similarities, and being deleted will significantly save memory. <br><br>  Now the algorithm itself, thanks to the mathematical libraries of Python, everything is quite simple here. <br>  5) We compose a matrix of zeros and ones, respectively, representing the absence or presence of a word in the document. <br>  6) We perform the singular decomposition of this matrix, as a result of which we obtain three other matrices in which we obtain the coordinates of documents and words in space. <br><br>  At the last stage, in a simplified form, it remains for us to simply compare the coordinates of documents and / or words with each other: those that are closest to each other are the desired result, those that are far away are correspondingly less relevant. <br><br>  We will carry out all manipulations with matrices using <code>numpy</code> and <code>scipy</code> bring the words to their original form using nltk.  Installing ... <br> <code>pip install numpy <br> pip install nltk <br> pip install scipy</code> <br>  If you try to install <code>scipy</code> encounter any problems (it will require to install a BLASS), it will probably help. <br> <code>apt-get install gfortran libopenblas-dev liblapack-dev <br></code> <br><br>  Class initialization <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSI</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, stopwords, ignorechars, docs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#      ,          self.wdict = {} # dictionary -         self.dictionary = [] #       , ,  self.stopwords = stopwords if type(ignorechars) == unicode: ignorechars = ignorechars.encode('utf-8') self.ignorechars = ignorechars #    for doc in docs: self.add_doc(doc)</span></span></code> </pre><br><br>  Preparation of words, we replenish the dictionary, if the word is in the dictionary, we return its number, we preliminarily remove any extra characters and bring them into the initial form <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word, add = False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(word) == unicode: word = word.encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     word = word.lower().translate(None, self.ignorechars) word = word.decode('utf-8') #     word = stemmer.stem(word) #         if word in self.dictionary: return self.dictionary.index(word) else: #              if add: #self.ready = False self.dictionary.append(word) return len(self.dictionary) - 1 else: return None</span></span></code> </pre><br><br>  Construction of the original matrix <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    self.keys = [k for k in self.wdict.keys() if len(self.wdict[k]) &gt; 0] self.keys.sort() #    self.A = zeros([len(self.keys), len(self.docs)]) #    for i, k in enumerate(self.keys): for d in self.wdict[k]: self.A[i,d] += 1</span></span></code> </pre><br><br>  Building the remaining matrices <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  U, S Vt -  """</span></span> self.U, self.S, self.Vt = svd(self.A)</code> </pre><br><br>  Normalization of weight or importance of words in the matrix.  We calculate the importance of a term depending on its occurrence.  For example, the word ‚Äúand‚Äù occurs quite often, so this word will have low significance, and, say, the word ‚ÄúUSA‚Äù is found to be significantly cut and, accordingly, will have greater significance.  Standard speech turns out, but rare terms remain. <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFIDF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  -    wordsPerDoc = sum(self.A, axis=0) #      docsPerWord = sum(asarray(self.A &gt; 0, 'i'), axis=1) rows, cols = self.A.shape for i in range(rows): for j in range(cols): self.A[i,j] = (self.A[i,j] / wordsPerDoc[j]) * log(float(cols) / docsPerWord[i])</span></span></code> </pre><br><br>  Comparison of documents on the coordinate axes and search by them. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word)</span></span></span><span class="hljs-function">:</span></span> self.prepare() idx = self.dic(word) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> idx: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.keys: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'        stopwords'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] idx = self.keys.index(idx) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'word --- '</span></span>, word, <span class="hljs-string"><span class="hljs-string">'='</span></span>, self.dictionary[self.keys[idx]], <span class="hljs-string"><span class="hljs-string">'.\n'</span></span> <span class="hljs-comment"><span class="hljs-comment">#    wx, wy = (-1 * self.U[:, 1:3])[idx] print 'word {}\t{:0.2f}\t{:0.2f}\t{}\n'.format(idx, wx, wy, word) arts = [] xx, yy = -1 * self.Vt[1:3, :] for k, v in enumerate(self.docs): #    ax, ay = xx[k], yy[k] #      dx, dy = float(wx - ax), float(wy - ay) arts.append((k, v, ax, ay, sqrt(dx * dx + dy * dy))) #      return sorted(arts, key = lambda a: a[4])</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">All code in its entirety</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSI</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, stopwords, ignorechars, docs)</span></span></span><span class="hljs-function">:</span></span> self.wdict = {} self.dictionary = [] self.stopwords = stopwords <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(ignorechars) == unicode: ignorechars = ignorechars.encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) self.ignorechars = ignorechars <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> docs: self.add_doc(doc) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.build() self.calc() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word, add = False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(word) == unicode: word = word.encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) word = word.lower().translate(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, self.ignorechars) word = word.decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) word = stemmer.stem(word) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.dictionary: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.dictionary.index(word) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> add: self.dictionary.append(word) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.dictionary) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_doc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, doc)</span></span></span><span class="hljs-function">:</span></span> words = [self.dic(word, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> doc.lower().split()] self.docs.append(words) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.stopwords: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.wdict: self.wdict[word].append(len(self.docs) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.wdict[word] = [len(self.docs) - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.keys = [k <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.wdict.keys() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(self.wdict[k]) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>] self.keys.sort() self.A = zeros([len(self.keys), len(self.docs)]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.keys): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.wdict[k]: self.A[i,d] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.U, self.S, self.Vt = svd(self.A) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFIDF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> wordsPerDoc = sum(self.A, axis=<span class="hljs-number"><span class="hljs-number">0</span></span>) docsPerWord = sum(asarray(self.A &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'i'</span></span>), axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) rows, cols = self.A.shape <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(cols): self.A[i,j] = (self.A[i,j] / wordsPerDoc[j]) * log(float(cols) / docsPerWord[i]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_src</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.prepare() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'    '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.A): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> self.dictionary[i], row <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_svd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.prepare() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'  '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> self.S <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'  3  U  '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(self.U): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> self.dictionary[self.keys[i]], row[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'  3  Vt '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>*self.Vt[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>, :] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, word)</span></span></span><span class="hljs-function">:</span></span> self.prepare() idx = self.dic(word) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> idx: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.keys: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'        stopwords'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] idx = self.keys.index(idx) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'word --- '</span></span>, word, <span class="hljs-string"><span class="hljs-string">'='</span></span>, self.dictionary[self.keys[idx]], <span class="hljs-string"><span class="hljs-string">'.\n'</span></span> <span class="hljs-comment"><span class="hljs-comment">#    wx, wy = (-1 * self.U[:, 1:3])[idx] print 'word {}\t{:0.2f}\t{:0.2f}\t{}\n'.format(idx, wx, wy, word) arts = [] xx, yy = -1 * self.Vt[1:3, :] for k, v in enumerate(self.docs): ax, ay = xx[k], yy[k] dx, dy = float(wx - ax), float(wy - ay) arts.append((k, v, ax, ay, sqrt(dx * dx + dy * dy))) return sorted(arts, key = lambda a: a[4])</span></span></code> </pre><br><br></div></div><br><br>  It remains to call the above code. <br><br><pre> <code class="python hljs">docs =[ <span class="hljs-string"><span class="hljs-string">"      WikiLeaks"</span></span>, <span class="hljs-string"><span class="hljs-string">"       ,  "</span></span>, <span class="hljs-string"><span class="hljs-string">"      19 "</span></span>, <span class="hljs-string"><span class="hljs-string">"     Wikileaks  "</span></span>, <span class="hljs-string"><span class="hljs-string">"     "</span></span>, <span class="hljs-string"><span class="hljs-string">"      Wikileaks"</span></span>, <span class="hljs-string"><span class="hljs-string">"         "</span></span>, <span class="hljs-string"><span class="hljs-string">"    WikiLeaks, ,  "</span></span>, <span class="hljs-string"><span class="hljs-string">"        "</span></span> ] ignorechars = <span class="hljs-string"><span class="hljs-string">''',:'!'''</span></span> word = <span class="hljs-string"><span class="hljs-string">""</span></span> lsa = LSI([], ignorechars, docs) lsa.build() lsa.dump_src() lsa.calc() lsa.print_svd() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsa.find(word): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> res[<span class="hljs-number"><span class="hljs-number">0</span></span>], res[<span class="hljs-number"><span class="hljs-number">4</span></span>], res[<span class="hljs-number"><span class="hljs-number">1</span></span>], docs[res[<span class="hljs-number"><span class="hljs-number">0</span></span>]]</code> </pre><br><br><pre> lsa.dump_src ()

 British [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
 polits [1. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
 knows [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] 
 ...
</pre><br>  In the columns of the documents in the lines of the terms. <br><br><pre> lsa.print_svd ()

 here are the first 3 columns of the u matrix 
 British [-0.06333698 -0.08969849 0.03023127]
 police [-0.14969793 -0.20853416 0.07106177]
 knows [-0.06333698 -0.08969849 0.03023127]
 ...

 Here are the first 3 lines of the Vt matrix
 [[0.25550481 0.47069418 0.27633104 0.39579252 0.21466192 0.26635401 0.32757769 0.3483847 0.3666749]
  [0.34469126 -0.18334417 -0.36995197 0.37444485 -0.29101203 0.27916372 -0.26791709 0.45665895 -0.35715836]
  [-0.10950444 0.64280654 -0.39672464 -0.1011325 -0.36012511 -0.01213328 0.38644373 -0.14789727 -0.32579232]]
</pre><br><br><pre> for res in lsa.find (word):
	 print res [0], res [4], res [1], docs [res [0]]

 word 9 (word code in the dictionary) -0.17 (first coordinate of the word) 0.46 (second coordinate) United States (the word itself)

  document number in list |  distance |  document decomposed on codes |  the document itself
 6 0.127328977215 [35, 36, 9, 37, 38, 39, 23, 40, 12, 41] NATO and the United States developed plans for the defense of the Baltic States against Russia
 1 0.182108022464 [7, 8, 9, 9, 10, 11, 12, 13, 14, 15] The trial against the Russian who sent out spam begins in the US court
 5 0.649492914495 [31, 8, 32, 33, 34, 5, 6] The Swedish court refused to consider the appeal of the founder of Wikileaks
 0 0.765573367056 [0, 1, 2, 3, 4, 5, 6] British police are aware of the whereabouts of the founder of WikiLeaks
 3 0.779637110377 [7, 24, 25, 5, 26, 6, 27, 28] Julian Assandzh, the founder of the Wikileaks website, is arrested in the UK
 8 0.810477163078 [7, 45, 36, 46, 47, 48, 17, 18, 19] Nobel Prizes will be awarded today in Stockholm and Oslo
 4 0.831319718049 [29, 30, 16, 17, 18, 19] Ukraine ignores the Nobel Prize award ceremony
 7 0.870710388156 [1, 24, 42, 5, 6, 43, 44, 25] British police found the founder of WikiLeaks, but did not arrest
 2 0.88243190531 [16, 17, 18, 19, 20, 21, 22, 23] 19 countries are boycotting the Nobel Peace Prize award ceremony </pre><br><br>  That's all, the topic is quite extensive, tried as concisely as possible. <br><br><h5>  useful links </h5><br>  - <a href="http://habrahabr.ru/post/110078/">A brief theory of latent semantic search</a> (rus.) <br>  - <a href="http://radimrehurek.com/gensim/tutorial.html">gensim - library for LSA python</a> <br>  - <a href="http://nltk.org/">nltk - library for word normalization</a> <br>  - <a href="http://scikit-learn.org/stable/">scikit-learn library for machine learning</a> </div><p>Source: <a href="https://habr.com/ru/post/197238/">https://habr.com/ru/post/197238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../197224/index.html">Due to total NSA surveillance, the US economy could lose up to $ 35 billion</a></li>
<li><a href="../197226/index.html">Or maybe divide the "Favorites" and "Read later"?</a></li>
<li><a href="../197228/index.html">LightShot and other screenshots</a></li>
<li><a href="../197232/index.html">Why i left google</a></li>
<li><a href="../197234/index.html">Ru-Center was fined 239 million rubles for frauds with. rf domains</a></li>
<li><a href="../197250/index.html">DIY: plastic for 3d printer</a></li>
<li><a href="../197252/index.html">Video demo of Steam Controller</a></li>
<li><a href="../197254/index.html">Phalcon PHP freymork. Work with annotations</a></li>
<li><a href="../197258/index.html">Never Gonna Give Your Terminal</a></li>
<li><a href="../197262/index.html">Using Lua Scripts in .NET with LuaInterface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>