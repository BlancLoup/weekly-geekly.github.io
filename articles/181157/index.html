<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proper splicing when intercepting functions prepared for HotPatch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article I looked at five options for intercepting functions including their variations. 

 True, I left it unresolved two unpleasant situa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Proper splicing when intercepting functions prepared for HotPatch</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/178393/">last article</a> I looked at five options for intercepting functions including their variations. <br><br>  True, I left it unresolved two unpleasant situations: <br>  1. The call to the intercepted function at the moment when the trap is removed. <br>  2. Simultaneous call of the intercepted function from two different threads. <br><br>  In the first case, the programmer who installed the interceptor will not see the whole picture, because  part of the data will pass him. <br>  The second case faces more serious consequences, including the crash of the application in which the interceptor is installed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Both of these situations can only be in the case of splicing.  When intercepted via import / export tables, etc.  the body of the intercepted function is not modified; therefore, these variants of interception do not require excessive gestures. <br><br>  This article will discuss in more detail the splicing of the entry point of a function prepared for HopPatch, since  These functions provide us with a way to avoid the above errors. <br><br>  Interception by splicing via JMP NEAR OFFSET or PUSH ADDR + RET (most vulnerable to these errors) will not be considered, since  for good, without the implementation of the length disassembler, it is impossible to make this interception option work as it should. <br><br><a name="habracut"></a><br><br><h4>  1. We realize the application intercepting the call to CreateWindowExW </h4><br>  To begin with, we will prepare an application that will visually show us the loss of data when intercepting the API due to the fact that the call to the intercepted function can occur at the moment when the interception is removed from it. <br><br>  Create a new project and place three elements on the main form: TMemo, TOpenDialog and TButton. <br><br>  The essence of the application: when you click a button, the interception will be set to the CreateWindowExW function and a dialog will be displayed.  After closing the dialog, TMemo will display information about all the windows created by the dialog. <br><br>  To do this, we need a part of the code from the <a href="http://habrahabr.ru/post/178393/">previous article</a> , namely: <br><br>  1. Declaration of types and constants for interception: <br><br><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LOCK_JMP_OPKODE: Word = $F9EB; JMP_OPKODE: Word = $E9; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//      JMP NEAR OFFSET TNearJmpSpliceRec = packed record JmpOpcode: Byte; Offset: DWORD; end; THotPachSpliceData = packed record FuncAddr: FARPROC; SpliceRec: TNearJmpSpliceRec; LockJmp: Word; end; const NearJmpSpliceRecSize = SizeOf(TNearJmpSpliceRec); LockJmpOpcodeSize = SizeOf(Word);</span></span></code> </pre> <br><br>  2. Procedures for recording NEAR JMP and atomic recording SHORT JMP <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//         procedure SpliceNearJmp(FuncAddr: Pointer; NewData: TNearJmpSpliceRec); var OldProtect: DWORD; begin VirtualProtect(FuncAddr, NearJmpSpliceRecSize, PAGE_EXECUTE_READWRITE, OldProtect); try Move(NewData, FuncAddr^, NearJmpSpliceRecSize); finally VirtualProtect(FuncAddr, NearJmpSpliceRecSize, OldProtect, OldProtect); end; end; //         procedure SpliceLockJmp(FuncAddr: Pointer; NewData: Word); var OldProtect: DWORD; begin VirtualProtect(FuncAddr, LockJmpOpcodeSize, PAGE_EXECUTE_READWRITE, OldProtect); try asm mov ax, NewData mov ecx, FuncAddr lock xchg word ptr [ecx], ax end; finally VirtualProtect(FuncAddr, LockJmpOpcodeSize, OldProtect, OldProtect); end; end;</span></span></code> </pre><br><br>  3. A slightly modified procedure for initializing the structure of THotPachSpliceData <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//       procedure InitHotPatchSpliceRec(const LibraryName, FunctionName: string; InterceptHandler: Pointer; out HotPathSpliceRec: THotPachSpliceData); begin //      HotPathSpliceRec.FuncAddr := GetProcAddress(GetModuleHandle(PChar(LibraryName)), PChar(FunctionName)); //      ,     Move(HotPathSpliceRec.FuncAddr^, HotPathSpliceRec.LockJmp, LockJmpOpcodeSize); //   JMP NEAR HotPathSpliceRec.SpliceRec.JmpOpcode := JMP_OPKODE; //    (  NearJmpSpliceRecSize  , // ..     ) HotPathSpliceRec.SpliceRec.Offset := PAnsiChar(InterceptHandler) - PAnsiChar(HotPathSpliceRec.FuncAddr); end;</span></span></code> </pre><br><br>  We will place all this code in a separate SpliceHelper module, we will need it in the following chapters. <br><br>  Now let's move to the main form, we need two global variables: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> HotPathSpliceRec: THotPachSpliceData; WindowList: TStringList;</code> </pre><br><br>  The variable HotPathSpliceRec will contain information about the interceptor.  The second will contain a list of created windows. <br><br>  In the form constructor, we will initialize the structure of THotPachSpliceData. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     InitHotPatchSpliceRec(user32, 'CreateWindowExW', @InterceptedCreateWindowExW, HotPathSpliceRec); //     NOP- SpliceNearJmp(PAnsiChar(HotPathSpliceRec.FuncAddr) - NearJmpSpliceRecSize, HotPathSpliceRec.SpliceRec); end;</span></span></code> </pre><br><br>  Create a function interceptor, called instead of the original function. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedCreateWindowExW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dwExStyle: DWORD; lpClassName: PWideChar; lpWindowName: PWideChar; dwStyle: DWORD; X, Y, nWidth, nHeight: Integer; hWndParent: HWND; hMenu: HMENU; hInstance: HINST; lpParam: Pointer)</span></span></span><span class="hljs-function">:</span></span> HWND; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   SpliceLockJmp(HotPathSpliceRec.FuncAddr, HotPathSpliceRec.LockJmp); try //      Index := -1; if not IsBadReadPtr(lpClassName, 1) then begin S := 'ClassName: ' + string(lpClassName); S := IntToStr(WindowList.Count + 1) + ': ' + S; Index := WindowList.Add(S); end; //    Result := CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam); //       if Index &gt;= 0 then begin S := S + ', handle: ' + IntToStr(Result); WindowList[Index] := S; end; finally //   SpliceLockJmp(HotPathSpliceRec.FuncAddr, LOCK_JMP_OPKODE); end; end;</span></span></code> </pre><br><br>  And it remains to complete the implementation of the button handler. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  CreateWindowExW SpliceLockJmp(HotPathSpliceRec.FuncAddr, LOCK_JMP_OPKODE); try //           WindowList := TStringList.Create; try //   OpenDialog1.Execute; //      Memo1.Lines.Text := WindowList.Text; finally WindowList.Free; end; finally //   SpliceLockJmp(HotPathSpliceRec.FuncAddr, HotPathSpliceRec.LockJmp); end; end;</span></span></code> </pre><br><br>  Everything is ready, you can run the program for execution. <br><br>  I will not talk in detail about the code implemented in this chapter, it is more than described in detail in the <a href="http://habrahabr.ru/post/178393/">previous article</a> , it makes no sense to paint a second time. <br><br>  Start the program, click the button and close the dialog by pressing the button "Cancel", it should turn out like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e23/7bd/f8a/e237bdf8a30b8054f3a789c6f5dbb37a.png" alt="image"><br><br>  Thus, we found that when you open a regular TOpenDialog, 14 windows of different classes are created. <br><br>  Now let's find out if this is true. <br><br><h4>  2. Create an auxiliary utility for viewing the application window tree. </h4><br>  To check the operation of our interceptor, it is necessary to insure a third-party utility that can display an up-to-date list of windows from the application, with which we will find out whether we have received all the information with our interceptor or not. <br><br>  You can of course use third-party programs, like Spy ++, but we are programmers, that we should implement it ourselves, all the more so is the time to implement it. <br><br>  Create a new project and place on the main form TTreeView and then implement the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TdlgWindowTree</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) WindowTreeView: TTreeView; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sys_Windows_Tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node: TTreeNode; AHandle: HWND; ALevel: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgWindowTree</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Sys_Windows_Tree(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, GetDesktopWindow, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgWindowTree</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sys_Windows_Tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node: TTreeNode; AHandle: HWND; ALevel: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRootNodeData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Node: TTreeNode; PID: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> szClassName, szCaption, szLayoutName: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..MAXCHAR - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Char; szFileName : <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..MAX_PATH - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Char; Result: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; PID, TID: Cardinal; I: Integer; RootItems: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TRootNodeData; IsNew: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      while AHandle &lt;&gt; 0 do begin //    GetClassName(AHandle, szClassName, MAXCHAR); //  ( Caption)  GetWindowText(AHandle, szCaption, MAXCHAR); //    if GetWindowModuleFilename(AHandle, szFileName, SizeOf(szFileName)) = 0 then FillChar(szFileName, 256, #0); TID := GetWindowThreadProcessId(AHandle, PID); //   AttachThreadInput(GetCurrentThreadId, TID, True); VerLanguageName(GetKeyboardLayout(TID) and $FFFF, szLayoutName, MAXCHAR); AttachThreadInput(GetCurrentThreadId, TID, False); //  Result := Format('%s [%s] Caption = %s, Handle = %d, Layout = %s', [String(szClassName), String(szFileName), String(szCaption), AHandle, String(szLayoutName)]); //       if ALevel in [0..1] then begin IsNew := True; for I := 0 to Length(RootItems) - 1 do if RootItems[I].PID = PID then begin Node := RootItems[I].Node; IsNew := False; Break; end; if IsNew then begin SetLength(RootItems, Length(RootItems) + 1); RootItems[Length(RootItems) - 1].PID := PID; RootItems[Length(RootItems) - 1].Node := WindowTreeView.Items.AddChild(nil, 'PID: ' + IntToStr(PID)); Node := RootItems[Length(RootItems) - 1].Node; end; end; //   Sys_Windows_Tree(WindowTreeView.Items.AddChild(Node, Result), GetWindow(AHandle, GW_CHILD), ALevel + 1); //   ( )  AHandle := GetNextWindow(AHandle, GW_HWNDNEXT); end; end;</span></span></code> </pre><br><br>  Actually everything can be run: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d7/f5f/c09/9d7f5fc098d82f75648ac446f0c12046.png" alt="image"><br><br><h4>  3. Analyzing the results </h4><br>  Now compare the results of the work of both programs.  We do this as follows. <br>  1. Start the program with the interceptor and click on the button displaying the dialog. <br>  2. Run the utility from the second chapter. <br>  3. Close the dialog of the first program, to get the result of the intercepted windows. <br><br>  We look: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e0/f10/6b7/7e0f106b7eb1ea15e1ab279bc55fa310.png" alt="image"><br><br>  The red window with the class Auto-Suggest DropDown is highlighted, let's see what it is: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/617/bb1/624/617bb1624ca1d30d651bb6ae77ceeca9.png" alt="image"><br><br>  And it turns out it contains 4 more windows, two scrolbars, a ListView, which also holds SysHeader32 with the same child.  But this is already interesting.  Henly windows in both applications are the same, but neither ListView nor SysHeader32, we see even two scrolls in the first application. <br><br>  But, the fact that we do not see them in the first list does not mean anything.  Creation of these windows occurred at the moment when our interceptor was removed, and this could happen only for one reason - due to the fact that the call to CreateWindowExW can lead to a recursive call to itself. <br><br>  So you need to implement the interceptor code in such a way that it does not require the removal and restoration of the interception. <br><br><h4>  4. Calling an intercepted function without removing the interception code. </h4><br>  Let's look at this picture from the previous article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/761/eb3/0ae/761eb30aeae63f43b4e030d69e36a927.png" alt="image"><br><br>  This shows the beginning of the MessageBoxW function.  The very first instruction is the non-doing instruction MOV EDI, EDI, preceded by five instructions NOP. <br><br>  This is exactly how most of the functions that are prepared for interception via HotPatch, including the intercepted by CreateWindowExW, look like. <br><br>  In the case of intercepting a function, instead of the seven bytes allocated, occupied with instructions that do nothing, the following code will be located: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/589/ba0/ff1589ba060a322b17b9f1506961d3e0.png" alt="image"><br><br>  Actually this is the interceptor installed by us. <br>  Instead of the instruction MOV EDI, EDI the code JMP-7 is placed, transferring control to the previous instruction. <br>  Instead of five NOP instructions, the jump to the beginning of the interceptor function is located. <br><br>  If we start executing not from the address of the beginning of the CreateWindowExW function, but from the address of its first useful instruction PUSH EBP, then we will not affect the interceptor installed by us, and if so, then there is no point in removing it. <br><br>  In code form, it looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TCreateWindowExW = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dwExStyle: DWORD; lpClassName: PWideChar; lpWindowName: PWideChar; dwStyle: DWORD; X, Y, nWidth, nHeight: Integer; hWndParent: HWND; AMenu: HMENU; hInstance: HINST; lpParam: Pointer)</span></span></span><span class="hljs-function">:</span></span> HWND; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedCreateWindowExW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dwExStyle: DWORD; lpClassName: PWideChar; lpWindowName: PWideChar; dwStyle: DWORD; X, Y, nWidth, nHeight: Integer; hWndParent: HWND; hMenu: HMENU; hInstance: HINST; lpParam: Pointer)</span></span></span><span class="hljs-function">:</span></span> HWND; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> S: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; ACreateWindowExW: TCreateWindowExW; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      Index := -1; if not IsBadReadPtr(lpClassName, 1) then begin S := 'ClassName: ' + string(lpClassName); S := IntToStr(WindowList.Count + 1) + ': ' + S; Index := WindowList.Add(S); end; //    @ACreateWindowExW := PAnsiChar(HotPathSpliceRec.FuncAddr) + LockJmpOpcodeSize; Result := ACreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam); //       if Index &gt;= 0 then begin S := S + ', handle: ' + IntToStr(Result); WindowList[Index] := S; end; end;</span></span></code> </pre><br><br>  Having calculated the address of the first useful instruction equal to the offset from the beginning of the function by two bytes, we store it in the ACreateWindowExW time variable, and then call the function in the usual way. <br><br>  Let's see what happens in this case, here we expect it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b6/254/c9f/2b6254c9f1fbe3830a8bdb913d4ebdb2.png" alt="image"><br><br>  And that is exactly what we find in the list issued to us: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/588/747/5d4/5887475d4986c09b651c8af4c1a25d62.png" alt="image"><br><br>  Well, we have found our ‚Äúlosses‚Äù, all the same 26 windows are created by calling TOpenDialog, and not 14. <br><br>  The whole thing was in the notorious recursive call, which can be seen in the procedure call stack, if you set the breakpoint at the beginning of the InterceptedCreateWindowExW function. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/459/465/c01459465804850e3a69fbf8461454cb.png" alt="image"><br><br><h4>  5. Error while calling intercepted function from different threads. </h4><br>  With this error, the same is simple.  If we constantly remove and restore the interceptor function, then at some point we will get an error in the function SpliceLockJmp on the instruction "lock xchg word ptr [ecx], ax".  The fact is that at this moment the operation of returning page attributes to an interceptor address from another thread can be completed and, despite the fact that we have allowed to write to this address in our thread, the actual page attributes will be completely different. <br><br>  It is with this behavior that the author of this thread encountered: <a href="http://forum.sources.ru/index.php%3Fshowtopic%3D374739">interception of recv</a> . <br><br>  This error should be solved in the same way as shown above. <br>  However, one should not forget about the interception handler, it should also be ThreadSafe, but the implementation of the handler is up to you. <br><br><h4>  6. Is it always possible to skip the first two bytes of the function being intercepted? </h4><br>  An interesting question and the answer to it - no, not always. <br>  When functions are prepared for interception using the HotPatch method, Microsoft only guarantees that there will always be five NOP instructions in front of them and each such function will begin with a two-byte instruction.  More we are not guaranteed anything. <br><br>  If you look at the MessageBoxW or CreateWindowExW code, you can see that their first useful instruction, PUSH EBP, is one byte.  Thus, since it does not satisfy the conditions, the body of this function is preceded by an empty call MOV EDI, EDI.  The same will be true for functions starting with instructions of length three and more bytes.  However, if the function starts with two-byte instructions, it does not make sense to inflate its body with an empty cap, because all the conditions for HotPatch are met (five NOP and 2 bytes). <br><br>  In this case, if we apply the method described above, we will see nothing but an error. <br><br>  An example of such a function is RtlCreateUnicodeString. <br>  It starts with a useful PUSH $ 0C instruction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee4/71e/e4f/ee471ee4f5f7e6d8d01fcb4f9f58bd02.png" alt="image"><br><br>  The simplest solution would be to restore the original instructions before calling the original function, but as I said from the very beginning, this could lead to errors. <br><br>  Therefore, we were faced with the task of ensuring the call of the erased instruction and ensuring the operability of the function even with the interception code set: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/17c/2f0/75e17c2f042535390784a563569aa899.png" alt="image"><br><br>  In principle, we have the machine code of the wiped instruction and it is stored in the HotPathSpliceRec.LockJmp structure, but we cannot call it directly for several reasons. <br><br>  Well, firstly, this structure is located in the heap (or rather, not in the heap, but in the allocated memory, since Delphi does not work with the Heap mechanism directly) which has no performance attributes, i.e.  if we somehow execute CALL at HotPathSpliceRec.LockJmp, we get an error. <br><br>  You can of course set the correct attributes of the page, but this is too clumsy, though the executable code should not be mixed up with the data area. <br><br>  Secondly, even if we pass the execution to this instruction, we must force the JMP instruction to the correct address after it (in this case it will be $ 77B062FB, see the previous picture), taking into account the offset of the instruction being called. <br><br>  Third, in addition to the call, we must place on the stack in the correct order the parameters passed to the called function, which at least will lead us to the need to use asm inserts. <br><br>  <b>Let's try to solve everything in order.</b> <br><br>  In order not to get involved in passing parameters from an ASM insert, we can implement a certain springboard function by assigning this task to the compiler. <br><br>  Those.  roughly write an interceptor like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrampolineRtlCreateUnicodeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DestinationString: PUNICODE_STRING; SourceString: PWideChar)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> db $<span class="hljs-number"><span class="hljs-number">90</span></span>, $<span class="hljs-number"><span class="hljs-number">90</span></span>, $<span class="hljs-number"><span class="hljs-number">90</span></span>, $<span class="hljs-number"><span class="hljs-number">90</span></span>, $<span class="hljs-number"><span class="hljs-number">90</span></span>, $<span class="hljs-number"><span class="hljs-number">90</span></span>, $<span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterceptedRtlCreateUnicodeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DestinationString: PUNICODE_STRING; SourceString: PWideChar)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TrampolineRtlCreateUnicodeString(DestinationString, SourceString); ShowMessage(DestinationString^.Buffer); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  In this case, the interceptor will be engaged in the call springboard and logging. <br><br>  Inside the springboard function, 7 bytes are reserved, which is just enough for us to write two-byte erased instructions and five-byte NEAR JMP. <br>  The function itself is located in the code area, and there should be no difficulties with its call. <br><br>  And now an important nuance. <br>  If we write these 7 bytes in place of the reserved block, we will encounter one unpleasant feature of Delphi.  The fact is that the Delphi compiler almost always generates a prolog and an epilog for functions. <br><br>  For example, let's say after the patch, the code of our function began to look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrampolineRtlCreateUnicodeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DestinationString: PUNICODE_STRING; SourceString: PWideChar)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> push $<span class="hljs-number"><span class="hljs-number">0</span></span>C <span class="hljs-comment"><span class="hljs-comment">//    jmp $77B062FB //      end; end;</span></span></code> </pre><br><br>  In fact, it will turn into the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/ad3/ce8/ca9ad3ce86533ca765b01b03726b407a.png" alt="image"><br><br>  Those.  on the stack, instead of two parameters DestinationString and SourceString, the values ‚Äã‚Äãof the EBP and ECX registers will be placed, which will result in absolutely unpredictable consequences. <br><br>  We absolutely do not need this, so we will proceed more simply, namely the springboard code will be written right from the beginning of this function, overwriting the instructions of the function prologue. <br><br>  But in fact, in fact, we absolutely do not need these instructions, since  after a jump into the body of the intercepted function and its execution, the control will not return to the springboard function distorted by our actions, but directly to the place from which it was called, i.e.  in function - the interception handler. <br><br>  Thus we implement the initialization of the interceptor in the following way: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//            procedure InitHotPatchSpliceRecEx(const LibraryName, FunctionName: string; InterceptHandler, Trampoline: Pointer; out HotPathSpliceRec: THotPachSpliceData); var OldProtect: DWORD; TrampolineSplice: TNearJmpSpliceRec; begin //      HotPathSpliceRec.FuncAddr := GetProcAddress(GetModuleHandle(PChar(LibraryName)), PChar(FunctionName)); //      ,     Move(HotPathSpliceRec.FuncAddr^, HotPathSpliceRec.LockJmp, LockJmpOpcodeSize); //   VirtualProtect(Trampoline, LockJmpOpcodeSize + NearJmpSpliceRecSize, PAGE_EXECUTE_READWRITE, OldProtect); try Move(HotPathSpliceRec.LockJmp, Trampoline^, LockJmpOpcodeSize); TrampolineSplice.JmpOpcode := JMP_OPKODE; TrampolineSplice.Offset := PAnsiChar(HotPathSpliceRec.FuncAddr) - PAnsiChar(Trampoline) - NearJmpSpliceRecSize; Trampoline := PAnsiChar(Trampoline) + LockJmpOpcodeSize; Move(TrampolineSplice, Trampoline^, SizeOf(TNearJmpSpliceRec)); finally VirtualProtect(Trampoline, LockJmpOpcodeSize + NearJmpSpliceRecSize, OldProtect, OldProtect); end; //   JMP NEAR HotPathSpliceRec.SpliceRec.JmpOpcode := JMP_OPKODE; //    (  NearJmpSpliceRecSize  , // ..     ) HotPathSpliceRec.SpliceRec.Offset := PAnsiChar(InterceptHandler) - PAnsiChar(HotPathSpliceRec.FuncAddr); end;</span></span></code> </pre><br><br>  The initialization itself and the call of the intercepted function look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UNICODE_STRING = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Length: WORD; MaximumLength: WORD; Buffer: PWideChar; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PUNICODE_STRING = ^UNICODE_STRING; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlCreateUnicodeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DestinationString: PUNICODE_STRING; SourceString: PWideChar)</span></span></span><span class="hljs-function">:</span></span> BOOLEAN; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-string"><span class="hljs-string">'ntdll.dll'</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm2</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//       InitHotPatchSpliceRecEx('ntdll.dll', 'RtlCreateUnicodeString', @InterceptedRtlCreateUnicodeString, @TrampolineRtlCreateUnicodeString, HotPathSpliceRec); //     NOP- SpliceNearJmp(PAnsiChar(HotPathSpliceRec.FuncAddr) - NearJmpSpliceRecSize, HotPathSpliceRec.SpliceRec); end; procedure TForm2.Button1Click(Sender: TObject); var US: UNICODE_STRING; begin //  RtlCreateUnicodeString SpliceLockJmp(HotPathSpliceRec.FuncAddr, LOCK_JMP_OPKODE); try RtlCreateUnicodeString(@US, 'Test UNICODE String'); finally //   SpliceLockJmp(HotPathSpliceRec.FuncAddr, HotPathSpliceRec.LockJmp); end; end;</span></span></code> </pre><br><br>  Now you can click on the button and see the result of the interception as a message. <br><br><h4>  As a conclusion </h4><br>  As a result, the splice implementation variant shown in the sixth chapter is the most universal in the case of interception of functions prepared for HotPatch.  It will work correctly in the case of a MOV EDI, EDI stub and if there is a useful instruction at the beginning of the function being intercepted.  It is not subject to errors, described at the very beginning of the article, but the truth is to intercept the usual functions using this algorithm will not work, however, I already <a href="http://habrahabr.ru/post/178393/">wrote</a> about this <a href="http://habrahabr.ru/post/178393/">earlier</a> . <br><br>  I apologize for having to split up the information into pieces and not give it all at once, but as I was advised a year ago, it‚Äôs better to give the material in small portions so that there is time for its digestion :) <br><br>  On the other hand, if you collect all the material in a pile, then firstly it will take quite a long time, which I do not have available, and secondly it will lead to its unreadable due to the large volume (there were precedents). <br>  Therefore, it is better that way. <br><br>  The source code for the examples can be collected at <a href="">this link</a> . <br><br>  ¬© Alexander (Rouse_) Bagel <br>  May, 2013 </div><p>Source: <a href="https://habr.com/ru/post/181157/">https://habr.com/ru/post/181157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181143/index.html">Searchlight past events ‚Ññ3</a></li>
<li><a href="../181145/index.html">ActiveRecord Hacks</a></li>
<li><a href="../181147/index.html">Do not do as I do. Or about your future job</a></li>
<li><a href="../18115/index.html">Avatars have overtaken blacks on energy consumption</a></li>
<li><a href="../181151/index.html">The algorithm of the game "sea battle": the shelling of the enemy</a></li>
<li><a href="../181159/index.html">Device of points of virtual reality Oculus Rift</a></li>
<li><a href="../18116/index.html"><base> is bad.</a></li>
<li><a href="../181161/index.html">The new technology of noise reduction allows you to transfer 400 Gb / s over fiber for 12,800 km without signal repeaters</a></li>
<li><a href="../181165/index.html">Robotic Data Center of the Future</a></li>
<li><a href="../18117/index.html">A new book by Vadim Panov - "Bonfires on the altars".</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>