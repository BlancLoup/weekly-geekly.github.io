<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React Native: from simple animation to interactive at 60 FPS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The need for data exchange between UI and JS processes in React Native inevitably affects the performance of preventing the execution of JavaScript an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React Native: from simple animation to interactive at 60 FPS</h1><div class="post__text post__text-html js-mediator-article"><p>  The need for data exchange between UI and JS processes in React Native inevitably affects the performance of preventing the execution of JavaScript animation with a high frame rate.  Modern libraries, such as Animated, solve this problem by minimizing the number of messages transmitted through the bridge.  The next step is the controls that continuously respond to the user's gestures.  How can we animate them at 60 frames per second? </p><a name="habracut"></a><br><h3 id="peresekaya-poslednyuyu-milyu">  Crossing the last mile </h3><br><p>  React Native is quite an attractive tool for developing modern mobile applications.  Its main advantage is a significant increase in developer productivity.  Simply put, you develop an application much faster.  Partly due to the fact that you can finally reuse the same code on different platforms. </p><br><p>  However, there are a couple issues of concern.  Will React Native allow me to cross the last mile?  Will my application match the best of those developed using native tools? </p><br><p>  I must admit that this concern is justified.  About a year ago, at wix.com, we switched from using native tools with a separate code base for iOS and Android to React Native.  The first 95% of the development went like clockwork.  We noticed that we are moving almost 4 times faster than before.  But the remaining 5% were a bit more complicated.  And these same 5%, which I call the last mile, are still not so easy to implement using React Native. </p><br><p>  Our goal, as a community, is to fix this. </p><br><h3 id="chto-delaet-prilozhenie-vydayuschimsya">  What makes the app outstanding? </h3><br><p>  So how do the best apps differ from mediocre ones?  When using mobile applications, we are accustomed to the fact that objects no longer appear on the screen just like that.  We expect all their movements to be beautifully animated. </p><br><p>  Smooth animation at 60 frames per second is an important part of the remaining five percent.  For a long time, animation was a big problem in React Native.  This issue was resolved with the help of <a href="https://facebook.github.io/react-native/docs/animated.html">Animated</a> , an excellent library that is part of the core. </p><br><p>  But let's look a little further than simple animation - realistic, dynamic user interaction.  Such interaction occurs when the user makes a gesture over an element and the element continuously and physically realistically reacts to it. </p><br><p>  To better understand what we are talking about, let's look at a few real life examples.  I walked on my phone and gathered some great examples of interaction from my favorite applications: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zqsnGEcMeV0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><ul><li>  Actions on the line in the list (ListView row actions) - On the left we have the official app from Apple - the Mail App and the Inbox for Gmail from Google.  As the user shifts the row of the list, the buttons of possible actions gradually appear. </li><li>  Swipeable cards - The second on the left is the Google Now app from Google and Flic from Lifehack Labs with a Tinder-like interface.  As the user shifts the cards, they change their appearance, and if they are moved strongly enough, they fly away from the screen. </li><li>  Collapsible views ‚Äî Airbnb and Cal from Any.DO are shown second right.  Both of these applications have areas that the user can collapse depending on the state.  For example, switching from filters to searching in Airbnb, or switching from displaying the month to displaying the week in Cal. </li><li>  Sliding panels &amp; drawers - On the right, we have the official iOS notification panel and the iOS Maps application from Apple.  The user can pull out these panels to view additional controls that are hidden in the normal state.  Just like in the popular navigation drawer / side menu. </li></ul><br><p>  What unites all these examples?  Their animation is physically realistic.  Elements have speeds that change when dragging and dropping.  Pay attention to little things like the notification bar bounces off the bottom of the screen after it has been pushed with enough force. </p><br><h3 id="realizaciya-s-ispolzovaniem-javascript">  Implementation using javascript </h3><br><p>  Using React Native, we naturally try to implement these animations using JavaScript.  Let's look at this implementation.  In fact, the first example from the above (ListView row actions) is already implemented in React Native under the name <a href="">SwipeableRow</a> . </p><br><p>  This implementation contains all the latest and greatest.  It focuses on performance and uses the Animated library.  Let's look at the very implementation of the interaction. </p><br><pre><code class="javascript hljs">_handlePanResponderMove(event: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">gestureState</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._isSwipingExcessivelyRightFromClosedPosition(gestureState)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onSwipeStart(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._isSwipingRightFromClosed(gestureState)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._swipeSlowSpeed(gestureState); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._swipeFullSpeed(gestureState); } }, _isSwipingRightFromClosed(gestureState: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._previousLeft === CLOSED_LEFT_POSITION &amp;&amp; gestureStateDx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }, _swipeFullSpeed(gestureState: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.currentLeft.setValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._previousLeft + gestureState.dx); }, _swipeSlowSpeed(gestureState: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.currentLeft.setValue( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR, ); }, _isSwipingExcessivelyRightFromClosedPosition(gestureState: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._isSwipingRightFromClosed(gestureState) &amp;&amp; gestureStateDx &gt; RIGHT_SWIPE_THRESHOLD ); },</code> </pre> <br><p>  This implementation relies on the <a href="https://facebook.github.io/react-native/docs/panresponder.html">PanResponder</a> to compute all changes that have occurred to the elements between touch events.  What performance can we expect from this solution? </p><br><p>  In order to analyze the performance, we need to look under the hood of React Native.  And there are two areas (realm) that work independently of each other: the area of ‚Äã‚ÄãJavaScript ‚Äî here we implement the business logic of our application and the UI (native) area ‚Äî where controls live.  Communication between these two areas takes place with the help of a bridge.  And since serialization is needed to send data over the bridge, frequent communication is expensive. </p><br><p>  Touch events are native constructs of the platform and they occur in areas of the UI.  For each frame of the interaction animation, these events are sent over the bridge for processing by the <code>_handlePanResponderMove</code> method in the JavaScript process.  As soon as the business logic computes the response, the value is set to <code>Animated Value</code> .  And since the elements are updated in the UI area, we need to send the data over the bridge again. </p><br><p>  As you can see, each frame serializes the data to be sent across the bridge.  If your application is busy with other calculations, you will see that this overhead will not allow the animation to run at 60 frames per second. </p><br><h3 id="realizaciya-s-ispolzovaniem-nativnyh-instrumentov">  Implementation using native tools </h3><br><p>  While working on the Wix application, we started to implement all the interactions in JavaScript.  But when the performance was lower than we expected, we began to port some scripts into native code. </p><br><p>  This means implementing everything twice.  Once on Objective-C for iOS and one more on Java for Android.  As a rule, it is easier to achieve 60 FPS performance when writing with the use of native tools because we exclude the transfer of data across the bridge, as well as store business logic and elements in the UI process. </p><br><p>  Since we open almost all of our native code, we have several <a href="https://github.com/wix/react-native-swipe-view">react-native-swipe-view</a> libraries that implement shifted cards and a <a href="https://github.com/wix/react-native-action-view">react-native-action-view</a> for actions on the list line.  Obviously, without a common solution, each new use case turns into such a highly specialized library. </p><br><p>  The main problem of this approach is that it requires, as a rule, two programmers with experience in developing native applications.  For these purposes, we in Wix have about 10% of frontend developers with Objective-C / Swift or Java skills. </p><br><p>  But this is not enough.  We must strive for the best and find an elegant general-purpose solution. </p><br><h3 id="uchimsya-u-animaciy">  Learning from animations </h3><br><p>  In fact, simple animations have similar problems.  A simple implementation would change the properties of objects from frame to frame in the JavaScript area.  This would create a lot of "noise on the bridge" and would lead to a loss of performance.  But as we know, the <a href="https://facebook.github.io/react-native/docs/animated.html">Animated</a> library has become a 60 FPS animation solution for React Native.  How does she work? </p><br><p>  The main idea behind this library is the declarative API for describing animations.  If we can describe the entire animation from the beginning to the end in advance, then the whole description can be serialized and sent across the bridge only once.  And then the <em>general purpose animation driver</em> simply executes it frame by frame. </p><br><p>  The first version of the driver for Animated was developed in JavaScript.  Later, a native driver was introduced that can perform animations and update objects in the UI area without sending data over the bridge. </p><br><p>  This method reduces the amount of data transmitted through the bridge to the data required for initialization.  And he leads us to an interesting conclusion: </p><br><p>  <em>The declarative interface is what allows us to cross the last mile.</em> </p><br><p>  This is a very powerful concept.  This is the type of library that we should think about.  Whenever we stand at the React Native performance limit, this is the way to expand it.  All we have to do is find a few usage scenarios and create a declarative interface covering them all.  That is what we will do now. </p><br><h3 id="deklarativnyy-interfeys-dlya-vzaimodeystviy-s-polzovatelem">  Declarative interface for user interactions </h3><br><p>  In order to create a good interface, we need to define several goals: </p><br><ul><li>  Our API should be general purpose.  In order to verify this, we must make sure that it covers all 8 scenarios from our examples. </li><li>  Our API should be simple.  The description of each interaction should not exceed 3-5 lines of code. </li></ul><br><p>  Before turning to the details, I want to mention one very interesting work that is being done in the Animated library and is aimed at user interaction.  One of the interesting additions is <a href="">Animated.ScrollView</a> and it allows you to interpolate the properties of the scroll <a href="http://facebook.github.io/react-native/docs/scrollview.html">pane</a> based on the <a href="http://facebook.github.io/react-native/docs/scrollview.html">ScrollView</a> position.  Another interesting development in progress from <a href="https://github.com/kmagiera">Krzysztof Magiera</a> is the <a href="https://github.com/kmagiera/react-native-gesture-handler">react-native-gesture-handler</a> and it allows you to interpolate the properties of an object depending on user gestures. </p><br><p>  Our approach is a little different.  We will take the 8 UX scripts from our examples and create the simplest high-level API that can describe them all. </p><br><h3 id="stadiya-pervaya-opredelim-api">  Stage One: Define the API </h3><br><p>  After analyzing our examples, we will see that some objects can move horizontally, and some vertically.  Thus, specifying the direction (direction) will be a good starting point for our API. </p><br><p>  Another observation is that objects can move freely while dragging.  But as soon as the user releases them, they, as a rule, tend and are fixed at a certain point (snap).  As an example, the side menu can be either closed or open. </p><br><p>  And the last.  To make the fixing function realistic, we need to use a spring-like curve for the animation.  And since we don't want our spring to jump forever, we need to add friction (or attenuation). </p><br><p>  Thus, at the first stage, our API will have the following properties: </p><br><ul><li>  horizontal / vertical </li><li>  snap points </li><li>  friction </li></ul><br><p>  Now let's try using our API to describe the first two scenarios of our examples.  ListView row actions and swipeable cards </p><br><p><img src="https://habrastorage.org/web/ca2/2c1/63c/ca22c163c4b84f10a89c12fa53fb2969.png"></p><br><pre> <code class="javascript hljs">&lt;Interactable.View horizontalOnly={<span class="hljs-literal"><span class="hljs-literal">true</span></span>} snapPoints={[ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>} ]} friction={<span class="hljs-number"><span class="hljs-number">0.7</span></span>} /&gt; <span class="hljs-comment"><span class="hljs-comment">// swipeable cards &lt;Interactable.View horizontalOnly={true} snapPoints={[ {x: -360}, {x: 0}, {x: 360} ]} friction={0.6} /&gt;</span></span></code> </pre> <br><p>  In order for the cards to fly away when brushing, we simply pointed out the snap points outside the screen (-360 and 360 logical pixels).  Please note that at the moment we are using pixels to simplify.  Later we can add support for units of measure that are more suitable for different screen resolutions, such as percentages. </p><br><p>  Not bad for a start, but the design of the declarative interface is only the first half.  The second half is the implementation of the native driver.  This we now do. </p><br><h3 id="realizaciya-nativnogo-drayvera-pervaya-popytka">  Implementing a native driver: First try </h3><br><p>  After the data for describing the interaction is formed in the JavaScript area, it is serialized and sent once to the UI area.  Our native general-purpose driver accepts them and performs all interactions only in the native area.  There will no longer be any bridge transfers for rendering each frame of interaction, which will allow for smooth animation at a speed of 60 FPS. </p><br><p>  Let's start with a simple implementation on Objective-C.  We will move our object using <a href="https://developer.apple.com/reference/uikit/uipangesturerecognizer%3Flanguage%3Dobjc">UIPanGestureRecognizer</a> and when the move gesture is over, we will find the closest anchor point and smoothly move the object to it using the spring curve of the animation. </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)handlePan:(<span class="hljs-built_in"><span class="hljs-built_in">UIPanGestureRecognizer</span></span> *)pan { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> translation = [pan translationInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.initialPanCenter.x + translation.x, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.initialPanCenter.y + translation.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pan.state == <span class="hljs-built_in"><span class="hljs-built_in">UIGestureRecognizerStateEnded</span></span>) { InteractablePoint *snapPoint = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> findClosestPoint:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.snapTo toPoint:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (snapPoint) { [<span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> animateWithDuration:<span class="hljs-number"><span class="hljs-number">0.8</span></span> delay:<span class="hljs-number"><span class="hljs-number">0</span></span> usingSpringWithDamping:<span class="hljs-number"><span class="hljs-number">0.7</span></span> initialSpringVelocity:<span class="hljs-number"><span class="hljs-number">0</span></span> options:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> animations:^{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center = [snapPoint positionWithOrigin:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.origin]; } completion:^(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> finished) {}]; } } }</code> </pre> <br><p>  This implementation works pretty well.  But there is one problem.  We emulate physics by animation.  What happens if a user swipes an object at some initial speed?  The animation function that we use can only move an object in a certain direction using the dynamics of the spring.  But what happens if the user swipes the object in the other direction?  Our model is not universal enough. </p><br><h3 id="realizaciya-nativnogo-drayvera-vtoraya-popytka">  Implementing a native driver: second attempt </h3><br><p>  Let's look at more advanced models for managing interactions.  If you plunge into the native SDK and see how Apple advises making complex and physically realistic interactions, then you will come across <a href="https://developer.apple.com/reference/uikit/uidynamicanimator%3Flanguage%3Dobjc">UIKit Dynamics</a> . </p><br><p>  This crazy API was introduced in iOS 7. It uses a full-featured physics engine under the hood and allows us to operate with such physical properties as mass, speed and apply various forces to the object.  The physical parameters of the scene are determined by the applied behavior models (behavior).  We can easily change the previous implementation: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pan.state == <span class="hljs-built_in"><span class="hljs-built_in">UIGestureRecognizerStateEnded</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> velocity = [pan velocityInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.superview]; InteractablePoint *snapPoint = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> findClosestPoint:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.snapTo toPoint:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (snapPoint) { <span class="hljs-comment"><span class="hljs-comment">//   UIDynamicItemBehavior *itemBehaviour = [[UIDynamicItemBehavior alloc] initWithItems:@[self]]; [itemBehaviour addLinearVelocity:velocity forItem:self]; [self.animator addBehavior:itemBehaviour]; //    UISnapBehavior *snapBehaviour = [[UISnapBehavior alloc] initWithItem:self snapToPoint:[snapPoint positionWithOrigin: self.origin]]; snapBehaviour.damping = 0.8f; [self.animator addBehavior:snapBehaviour]; } }</span></span></code> </pre> <br><p>  This is closer, but still not enough.  There are two major drawbacks to using UIKit Dynamics.  Firstly, there is no possibility to use it on Android.  There is nothing in the Android SDK that we could use as a replacement.  And, secondly, some features, such as binding, do not provide enough control.  There is no way to specify the force with which the object will be fixed. </p><br><h3 id="realizaciya-nativnogo-drayvera-tretya-popytka">  Implementing a native driver: Third attempt </h3><br><p>  Let's add some craziness.  Why not implement UIKit Dynamics yourself?  Ultimately, physical forces are expressed by relatively simple mathematical equations.  Developing a physics engine from scratch should not be too complicated. </p><br><p>  We can adapt behaviors from UIKit Dynamics.  Let's take, for example, the function of snapping an object.  We can implement it using a spring.  But how should this spring behave?  It is time to remember a little <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2593%25D1%2583%25D0%25BA%25D0%25B0">physics</a> . </p><br><p><img src="https://habrastorage.org/web/5f1/c40/56c/5f1c4056c2504e23b18a28d50376a353.png"></p><br><p>  No need to worry too much about math.  This is what the library will do under the hood.  Articles on Wikipedia under <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD%25D1%258B_%25D0%259D%25D1%258C%25D1%258E%25D1%2582%25D0%25BE%25D0%25BD%25D0%25B0">the Newton</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2593%25D1%2583%25D0%25BA%25D0%25B0">Hooke</a> <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD%25D1%258B_%25D0%259D%25D1%258C%25D1%258E%25D1%2582%25D0%25BE%25D0%25BD%25D0%25B0">Laws</a> will give you all the information you need. </p><br><p>  We will have to calculate the strength and speed of each frame of our animation.  In order to achieve this, we need a high-precision timer that will ensure the execution of the code at a speed of 60 frames per second.  Fortunately, we just have a native API created specifically for this purpose - <a href="https://developer.apple.com/reference/quartzcore/cadisplaylink">CADisplayLink</a> .  Putting it all together we get: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.displayLink = [<span class="hljs-built_in"><span class="hljs-built_in">CADisplayLink</span></span> displayLinkWithTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(displayLinkUpdated)]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.displayLink addToRunLoop:[<span class="hljs-built_in"><span class="hljs-built_in">NSRunLoop</span></span> mainRunLoop] forMode:<span class="hljs-built_in"><span class="hljs-built_in">NSRunLoopCommonModes</span></span>]; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)displayLinkUpdated { <span class="hljs-built_in"><span class="hljs-built_in">CFTimeInterval</span></span> deltaTime = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">CFTimeInterval</span></span> currentTime = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.displayLink timestamp]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.lastFrameTime &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) deltaTime = currentTime - <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.lastFrameTime; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.lastFrameTime = currentTime; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> animateFrameWithDeltaTime:deltaTime]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)executeFrameWithDeltaTime:(<span class="hljs-built_in"><span class="hljs-built_in">CFTimeInterval</span></span>)deltaTime onObject:(PhysicsObject*)object { <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> dx = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.target.center.x - <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.anchorPoint.x; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> ax = (-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tension * dx) / object.mass; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> vx = object.velocity.x + deltaTime * ax; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> dy = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.target.center.y - <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.anchorPoint.y; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> ay = (-<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tension * dy) / object.mass; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> vy = object.velocity.y + deltaTime * ay; object.velocity = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(vx, vy); }</code> </pre> <br><p>  Now it feels right, but it pushes one interesting thought ... </p><br><p>  <em>We are writing a declarative physics engine for React Native.</em> </p><br><p>  And it's damn cool! </p><br><p>  Finally, we have a native driver that is completely under our control.  It's time to use this powerful engine and add some new features to our declarative interface. </p><br><h3 id="rasshiryaem-api-novymi-svoystvami">  Expanding API with new properties. </h3><br><p>  Our declarative interface is a good foundation for further improvements, but it still lacks the functionality to implement all the tricky interactions from the 8 UX examples.  Let's look at the notification panel from iOS.  When the user pulls the panel with enough force, it jumps off the bottom of the screen. </p><br><p>  We can easily add support for this behavior to our interface.  Restrict the movement of the object to the frame and add a rebound from the edges: </p><br><p><img src="https://habrastorage.org/web/35c/d40/68d/35cd4068d68e452599cfe43eaa65727a.gif"></p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        &lt;Interactable.View verticalOnly={true} snapPoints={[ {y: 50}, {y: 667} ]} initialPosition={{y: 50}} boundaries={{bottom: 667, bounce: 2}} friction={0.7} /&gt;</span></span></code> </pre> <br><p>  Let's look at a more complex scenario, this time with actions for rows of lists.  Some lines have action buttons on one side only.  In such a case, a common behavior would be to allow the line to move freely in the direction to show the buttons, but when moving in the opposite direction, the movement should experience increasing resistance. </p><br><p>  We can add resistance to the movement of the string by tying one of its sides to the edge of the screen using a constant <strong>spring</strong> .  Unlike the anchor points, this spring will be active while dragging. </p><br><p>  Then we will need to solve another problem.  The line should move freely to the left (to display the action buttons) and experience resistance when moving to the right.  We can achieve this behavior by adding to the interface for each applied force, such as a spring, an optional influence area. </p><br><p>  When an object is outside the area of ‚Äã‚Äãinfluence, no force is applied to it. </p><br><p><img src="https://habrastorage.org/web/c52/855/a42/c52855a42aeb4475a58acacb9403e52b.gif"></p><br><pre> <code class="javascript hljs">&lt;Interactable.View horizontalOnly={<span class="hljs-literal"><span class="hljs-literal">true</span></span>} snapPoints={[ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-230</span></span>} ]} springPoints={[ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">tension</span></span>: <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-attr"><span class="hljs-attr">damping</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">influenceArea</span></span>: {<span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}} ]} friction={<span class="hljs-number"><span class="hljs-number">0.7</span></span>} /&gt;</code> </pre> <br><p>  As you can see, when new scenarios appear, we can simply add generalized properties to our interface that can describe them. </p><br><h3 id="rasshiryaem-api-vzaimodeystviem-s-animated">  Extend the API by interacting with Animated </h3><br><p>  We still lack a big piece of the puzzle.  Let's return to actions with a line of the list.  As you move the line, action buttons gradually appear from under it.  A common scenario is a smooth change in their size and transparency as they appear. </p><br><p>  You can see this behavior in the picture below (action buttons are indicated in blue): </p><br><p><img src="https://habrastorage.org/web/1af/023/ebc/1af023ebcaad442b90edde864875b738.gif"></p><br><p>  Also note that the objects that we want to animate (blue buttons) are different from the object with which the user interacts (the gray row of the list). </p><br><p>  This effect is not so simple to implement as the animation steps now depend on the horizontal position of the line, and not on the timer.  Nevertheless, it is still an animation where the properties of the object (size and transparency) are consistently changed.  And we already have a powerful tool for animating properties - the Animated library.  Let's see how we can use it for our purposes. </p><br><p>  Animation of object properties in Animated is done declaratively, defining interpolations using Animated.Value: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._animValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animated.Value(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Animated.View</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">transform:</span></span></span></span><span class="xml"><span class="hljs-tag"> [{ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">scale:</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">this._animValue.interpolate</span></span></span></span><span class="xml"><span class="hljs-tag">({ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputRange:</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-150</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">], </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">outputRange:</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0.3</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">] }) }] }}&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Animated.View</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  Since the animation depends on the horizontal position of the line, can we try to pass this position through Animated.Value?  This will allow us to specify interpolations, based on the position of the interaction object, to change other objects that are not directly associated with it (for example, buttons). </p><br><p>  How, then, would it work with our interface?  We can achieve this behavior by passing Animated.Value as a property (animatedValueX): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    Animated this._deltaX = new Animated.Value(0); &lt;Animated.View style={{ transform: [{ scale: this._deltaX.interpolate({ inputRange: [-150, 0], outputRange: [0.3, 1] }) }] }}&gt; ... &lt;/Animated.View&gt; //   API &lt;Interactable.View horizontalOnly={true} snapPoints={[{x: 0}, {x: -230}]} animatedValueX={this._deltaX} /&gt;</span></span></code> </pre> <br><p>  The native driver will do the actual transfer under the hood.  You can do this with <a href="https://facebook.github.io/react-native/docs/animated.html">Animated.events</a> .  New versions of Animated support control of Animated.events using the <a href="https://github.com/facebook/react-native/commit/fc11a5fde847f40f446823ac2bbb0d2e64236306">native driver</a> .  And this means that the entire animation, starting from the transfer of the position to the interpolation and updating of the objects, will take place in the native area without the need to send data through the bridge.  This is great news if we want to run an animation at 60 FPS. </p><br><h3 id="rasshiryaem-api-finalnye-shtrihi">  Expanding API: Final touches </h3><br><p>  If we already set about developing our own physics engine, let's add other forces.  We already have springs, let's add gravity and magnetism.  This will give developers the necessary flexibility to create any crazy physical interactions. </p><br><p>  We also need event support so that our JavaScript code knows when the interaction is completed or when the object has reached the anchor point.  And while we're still here, it would be great to add tactile feedback.  So that the phone can vibrate slightly when objects collide.  These nuances add gloss to the application, which is so necessary for pleasant use. </p><br><p>  Time to sum up ... </p><br><p>  I want to show you the full power of what we have created here.  Take a look at this description.  Can you say what it implements? </p><br><pre> <code class="javascript hljs">&lt;Interactable.View snapPoints={[{<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">140</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-140</span></span>}]} gravityPoints={[{<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">strength</span></span>: <span class="hljs-number"><span class="hljs-number">8000</span></span>, <span class="hljs-attr"><span class="hljs-attr">falloff</span></span>: <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-attr"><span class="hljs-attr">damping</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">haptics</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]} dragWithSpring={{<span class="hljs-attr"><span class="hljs-attr">tension</span></span>: <span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-attr"><span class="hljs-attr">damping</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>}} onStop={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onStopInteraction} animatedValueX={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._deltaX} animatedValueY={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._deltaY} /&gt;</code> </pre> <br><p>  Our mysterious object is fixed at the left or right edge of the screen.  A gravity well at the bottom of the screen will tighten our object if it gets too close.  Also note that we did not restrict the movement of objects, providing them with the ability to move in any direction. </p><br><p>  We got a full implementation of "chat heads" in just 7 lines of code! </p><br><p><img src="https://habrastorage.org/web/c18/c83/7e4/c18c837e4f144b98a4aa409aac43d6b2.gif"></p><br><h3 id="realno-li-on-rabotaet-so-skorostyu-60-kadrov-v-sekundu">  Does it really work at 60 frames per second? </h3><br><p>  Watching video is not the same as self-interaction on a real device.  Note that even the simulator does not allow you to feel the real interaction as it can skip animation frames. </p><br><p>  So is this done on a real device at 60 frames per second?  Judge for yourself.    <a href="https://youtu.be/zqsnGEcMeV0">8 </a>    ,     .       <a href="https://itunes.apple.com/us/app/react-native-interactions/id1209875831%3Fls%3D1%26mt%3D8">Apple App Store</a>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.wix.interactions%26hl%3Den">Google Play</a> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RQrxdFJDNlk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     ,    iOS  Android,          <a href="https://github.com/wix/react-native-interactable"> GitHub</a> . </p><br><h3 id="peresekaya-poslednyuyu-milyu-1">    </h3><br><p>  ,         ,       .  ,  ,   React Native,    . </p><br><p>        React Native              ,     .      -     (    ),     , ,   . </p><br><p>     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336010/">https://habr.com/ru/post/336010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335994/index.html">Blockchain</a></li>
<li><a href="../335998/index.html">How to make a project on the recognition of handwritten numbers with additional training online. Hyde for not quite beginners</a></li>
<li><a href="../336000/index.html">Myriads of running C # tasks</a></li>
<li><a href="../336002/index.html">How to complete the first project</a></li>
<li><a href="../336006/index.html">Liscript - web REPL: kisses, bikes and excavators</a></li>
<li><a href="../336012/index.html">Support for system errors in C ++</a></li>
<li><a href="../336016/index.html">CrowdSourcing Accelerator</a></li>
<li><a href="../336018/index.html">Change of consumer preferences: in search of the ideal drive with support for the NVMe protocol</a></li>
<li><a href="../336020/index.html">30+ tools for professional development of Android applications</a></li>
<li><a href="../336022/index.html">Say no to solidity: how we made the CPA platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>