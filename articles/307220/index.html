<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>This little miracle is the Knut-Morris-Pratt (KMP) algorithm.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Knut-Morrs-Pratt algorithm is used to search for a substring (pattern) in a string. It seems that it can be simpler: we move along the line and su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>This little miracle is the Knut-Morris-Pratt (KMP) algorithm.</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D0%25BE%25D1%2580%25D1%2580%25D0%25B8%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D1%2580%25D0%25B0%25D1%2582%25D1%2582%25D0%25B0">The Knut-Morrs-Pratt algorithm is</a> used to search for a substring (pattern) in a string.  It seems that it can be simpler: we move along the line and successively compare the characters with the sample.  It did not coincide, we move the beginning of the comparison by one step and compare again.  And so on until we find a pattern or reach the end of the line. <br><a name="habracut"></a><br>  The function is approximately as follows: <br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      //        -1,    int find(char *, char *) { // i-     // j-     for (int i=0;[i];++i) { for (int j=0;;++j) { if (![j]) return i; //   if([i+j]!=[j]) break; } //   ,    } //   return -1; }</span></span></code> </pre> <br>  Simple search case <br>  'needle' - sample <br>  'stack of stack of <b>needle</b> <b>needle</b> stack of stack <b>needle</b> ' - search string <br><br>  Difficult search case <br>  aabbaab <br>  aabaabbaaabaabaabaabaabbaabb <br><br>  The function works and is quite fast if the samples and the string are ‚Äúgood‚Äù.  Good ones are when the inner loop is interrupted quickly (at step 1-3, say, as in the simple case).  But if the sample and the line contain frequently repeated nested pieces (as a complicated case above), then the internal loop terminates towards the end of the sample and the search time is estimated as O (&lt;sample length&gt; * &lt;string length&gt;).  If the line length is 100 thousand, and the sample length is 100, then we get O (10 million).  Of course, it‚Äôs really rare to find a sample with a length of 100, but in ‚ÄúOlympiad‚Äù tasks, ‚Äúsearch‚Äù is a common thing, so a simple search there is often not suitable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And if a string is a long text, and a sample is a fragment of a word, and all the occurrences of this fragment need to be found, and on the fly, as the word is typed (did you notice how quickly browsers do this)?  The KMP algorithm finds all occurrences of a sample in a line and its speed O (&lt;sample length&gt; + &lt;string length&gt;), therefore on large texts / samples or on weak processors (as in low-budget cellular ones) it is out of competition. <br><br>  Now look at the title?  Why "small"?  Because the highlight of the CMP is a prefix function, but it is really small.  And why "miracle"?  Because, he seems to be solving a completely different task, and this solution, after some wonderful trick, turns into a solution to the problem of finding all instances of the sample in a row. <br><br>  In order to understand what and how the prefix function does, let's look at the complex string <br><table><tbody><tr><td>  a </td><td>  <font color="brown"><b>a</b></font> </td><td>  <b>b</b> </td><td>  a </td><td>  <font color="green"><b>a</b></font> </td><td>  <font color="red"><b>b</b></font> </td><td>  a </td><td>  <font color="blue"><b>a</b></font> </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  b </td><td>  a </td><td>  a </td><td>  b </td><td>  but </td><td>  a </td><td>  a </td><td>  b </td></tr><tr><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  ten </td><td>  eleven </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  sixteen </td><td>  17 </td><td>  18 </td></tr><tr><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  2 </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  3 </td></tr></tbody></table>  The line below it is the number (position) of the character in the line (for convenience of the description of the algorithm, we consider the number from 1), and the lowest line is the array of M prefix lengths, the key to understanding the prefix function. <br>  Take the character number 7 (this is a) and for K from 1 to 6 we consider prefixed lines (a substring starting with the first index of the line) and suffixes (the substring whose last character is in the line at position 7 (this is ‚Äúour‚Äù character a)) length K. <br><br><table><tbody><tr><td>  K </td><td>  prefix </td><td>  suffix </td></tr><tr><td>  one </td><td>  but </td><td>  a </td><td>  everything is simple: the prefix is ‚Äã‚Äãthe first character of the string, and the suffix is ‚Äã‚Äãour character a </td></tr><tr><td>  2 </td><td>  aa </td><td>  ba </td><td></td></tr><tr><td>  3 </td><td>  aab </td><td>  aba </td><td></td></tr><tr><td>  <b>four</b> </td><td>  <b>aaba</b> </td><td>  <b>aaba</b> </td><td>  the longest match, and here and below the suffix and prefix began to overlap (as fragments of the search string) </td></tr><tr><td>  five </td><td>  aabaa </td><td>  baaba </td><td></td></tr><tr><td>  6 </td><td>  aabaab </td><td>  abaaba </td><td></td></tr></tbody></table><br>  Note: for length 4, the suffix (as a sequence of characters) matches the prefix and this is the maximum K value at which the suffix matches the prefix.  It is this that is entered in the corresponding position (7) of the array of prefix lengths. <br>  You can see that for K = 7, the prefix will also match the suffix, since this is the same string.  But this trivial case does not suit us, since  for the operation of the algorithm, it is necessary to use substrings <br><br>  Denote the S-source string, S (n) -prefix (prefix) of string S of length n, S [n] -character at position n of string S. M [n] value in the array, S (M [n]) - the same a string that is a prefix and suffix of the maximum length for position n (for brevity, we denote it by P (n)).  The string P (n) is, as it were, ‚Äúvirtual‚Äù; it is not formed and is not written anywhere.  This is just the initial fragment1 of the source string S of length M [n].  And this initial fragment1 coincides (as a sequence of characters) with fragment2 of length M [n], the last character of which is in position n.  If M [n] = 0, then there is no coincidence. <br><br>  We have: position 7 of the array is filled with the value M [7] = 4, the longest line P (7) = ' <b>aaba</b> ' of length 4 (of course), go to position 8 and fill in M ‚Äã‚Äã[8].  You can stupidly count all the prefixes and suffixes in length from 1 to 7, compare them and write the maximum length to position 8. But we will go the other way (after the ILC).  Let the maximum length string P (8) of length k be found, which is the prefix and suffix for position 8. The string p7 of the first k-1 characters is the prefix and suffix for position k-1.  Not the fact that for the 7th position it is the longest.  However, if it turned out that p7 = P7, then P8 is an extension of P7 by one character.  To check whether P7 can be extended by one position, it is necessary to check whether the character added to the suffix matches (this is the symbol S [8] = <font color="blue"><b>a</b></font> ) with the next prefix symbol.  The next character of the prefix <font color="green"><b>a</b></font> is in the position M [7] + 1 = 5 (think why this is so).  If it coincided (and in our case it coincided), then the task is completed - M [8] = M [7] +1, and P (8) = P (7) + character in 8 position S [8] = <font color="blue"><b>a</b></font> .  We <b>get</b> P (8) = ' <b>aabaa</b> '.  With successful expansion, you need only one comparison to calculate the next value of the array.  By the way, it follows that when moving along an array, the values ‚Äã‚Äãmay increase by a maximum of 1. <br>  <i>For convenience, I will repeat the complex line so that you do not need to move up and down.</i> <br><table><tbody><tr><td>  a </td><td>  <font color="brown"><b>a</b></font> </td><td>  <b>b</b> </td><td>  a </td><td>  <font color="green"><b>a</b></font> </td><td>  <font color="red"><b>b</b></font> </td><td>  a </td><td>  <font color="blue"><b>a</b></font> </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  b </td><td>  a </td><td>  a </td><td>  b </td><td>  but </td><td>  a </td><td>  a </td><td>  b </td></tr><tr><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  ten </td><td>  eleven </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  sixteen </td><td>  17 </td><td>  18 </td></tr><tr><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  2 </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  3 </td></tr></tbody></table>  Now another case - P8 could not be expanded;  the character S [9] = <font color="magenta">a</font> did not match the character of the string S in the position M [8] + 1 = 6 <font color="red">b</font> .  The suffix expands easily (since the new character is simply appended to the end), and with the prefix of the problem, since  the character added to the suffix may not match the next prefix character.  If the prefix P (k) does not fit, you need to find another such prefix, shorter, which has the same suffix and try to expand it.  But the prefix is ‚Äã‚Äãshorter, and with the same suffix it is S [M [M [k]]), since  When the array M is filled, each element contains the length of the maximum prefix with the same suffix.  Therefore, if we failed to expand S (M [k]), we also try to expand S (M [M [k]]), etc., until it matches or until we get a zero length (then the next character S should be simply compared with 1m character string S).  The loop of searching for suitable prefixes ends very quickly, because all the necessary information for this is already sitting in the array M. <br><br>  For our line, P (8) is just an extension of P (7) by one character, it took 1 comparison.  However, P (8) could not be expanded to P (9), since S [9] = <font color="magenta"><b>a</b></font> , and S [M [8] + 1 = 6] = <font color="red"><b>b</b></font> .  If the prefix P8 of length M [8] = 5 did not fit, try the prefix of length M [5] = 2.  It also does not fit: S [2 + 1] = <b>b</b> .  We try the prefix of length M [2] = 1 and it can be expanded because  S [1 + 1] = <font color="brown"><b>a</b></font> .  Therefore, M [9] = 2, one more than the length of the expanding prefix.  For filling M [10] you need 2 comparisons (you can check).  But to fill items from 11 to 17, you need one comparison.  As a result, the calculation of the array values ‚Äã‚Äãtakes time of the order O (the length of the string). <br>  So, the filling algorithm is more or less clear. <br><br><h2>  Go to the trick. </h2><br>  To find the sample <font color="blue">aabaa</font> in the string <font color="brown">aabaaaaaaaaaaaaaaab we</font> glue the sample with the string like this <font color="blue">aaaaa</font> <font color="brown">@aaaaaaaaaaaaaaaaab</font> and call for it a prefix function to fill the array. <br><table><tbody><tr><td>  a </td><td>  a </td><td>  b </td><td>  a </td><td>  a </td><td>  @ </td><td>  a </td><td>  a </td><td>  b </td><td>  a </td><td>  <font color="magenta"><b>a</b></font> </td><td>  b </td><td>  a </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  a </td><td>  b </td><td>  a </td><td>  <font color="magenta"><b>a</b></font> </td><td>  b </td><td>  but </td><td>  <font color="magenta"><b>a</b></font> </td><td>  a </td><td>  b </td></tr><tr><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  ten </td><td>  eleven </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  sixteen </td><td>  17 </td><td>  18 </td><td>  nineteen </td><td>  20 </td><td>  21 </td><td>  22 </td><td>  23 </td><td>  24 </td></tr><tr><td>  0 </td><td>  one </td><td>  0 </td><td>  one </td><td>  2 </td><td>  0 </td><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  3 </td><td>  four </td><td>  five </td><td>  2 </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  3 </td><td>  four </td><td>  five </td><td>  2 </td><td>  3 </td></tr></tbody></table>  The symbol <b>'@</b> ' plays the role of a separator, it is certainly not in the sample, or in the search bar (you need to choose such a symbol).  Let's look at positions 11, 14, 19, 22 of the array.  The values ‚Äã‚Äãin the array are equal to 5, which means that the suffix of length 5 (fragment of the search string) coincides with 5 characters of the prefix.  And the 5 characters of the prefix - this is the pattern for the search!  The search algorithm is obtained as follows: we glue together the sample and the search string using a separator, pass the gluing of the prefix function and then look for elements in the array that are equal to the sample length. <i>You can see that there will be no values ‚Äã‚Äãgreater than the sample length due to the separator symbol, equal to the sample length can appear only in the positions corresponding to the initial search string.</i>  The glued string has a length of &lt;sample length&gt; + &lt;string length&gt;, so the calculation time is estimated as O (&lt;sample length&gt; + &lt;string length&gt;), as mentioned at the beginning of the article.  The volume of the required prefix buffer function is &lt;sample length&gt; + &lt;string length&gt;, but you can modify the prefix function so that there is enough buffer &lt;sample length&gt; (example of modification in the appendix) <br><br><h2>  Prefix function </h2><br>  And now examples of prefix functions.  The difference from the description above is that, as is customary in C-languages, indices are counted from 0. <br><h4>  C ++ Example </h4><br>  The function returns a vector of lengths of prefixes of strings, and the string is passed as string (no need to calculate the length) <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; prefix_function (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = s.length(); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; pi(n); <span class="hljs-comment"><span class="hljs-comment">//  i-  (  i-1)           i. // p[0]=0 , p[1]=1,      for (size_t i=1; i&lt;n; ++i) { size_t j = pi[i-1]; while ((j &gt; 0) &amp;&amp; (s[i] != s[j])) //   j = pi[j-1]; //     (   ) if (s[i] == s[j]) //  ++j; pi[i] = j; } return pi; }</span></span></code> </pre><br><br><h4>  C example </h4><br>  The function returns nothing.  The first parameter is a pointer to a string, the second is a pointer to a prefix length array to be filled in, the third p is the length of a string and array. <br><pre> <code class="hljs lua">//     size_t,   int void prefix_function (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *s, int *<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>, size_t n) { <span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">0</span></span>; //  i-  (  i<span class="hljs-number"><span class="hljs-number">-1</span></span>)           i. // p[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">0</span></span> , p[<span class="hljs-number"><span class="hljs-number">1</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>,      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;n; ++i) { int j = <span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>[i<span class="hljs-number"><span class="hljs-number">-1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((j &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (s[i] != s[j])) //   j = <span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>[j<span class="hljs-number"><span class="hljs-number">-1</span></span>]; //     (   ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s[i] == s[j]) //  ++j; <span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>[i] = j; } }</code> </pre><br>  This code was added based on the discussion. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,       int f(size_t i) { printf("%d\n",i); return 1; } // str   // obr ,   // pi      (  ,    ) // int f(size_t i)   ,   .       str  //   0,      1,    void prefix_find (char *str, char *obr, size_t *pi, int (*f)(size_t)) { pi[0]=0; //  i-  (  i-1)           i. // p[0]=0 , p[1]=1,      size_t l; //   //       for (l=1; obr[l]; ++l) { size_t j = pi[l-1]; while ((j &gt; 0) &amp;&amp; (obr[l] != obr[j])) //   j = pi[j-1]; //     (   ) if (obr[l] == obr[j]) //  ++j; pi[l] = j; } size_t j=0; //       for (size_t i=0; str[i]; ++i) { while ((j &gt; 0) &amp;&amp; (str[i] != obr[j])) //         j = pi[j-1]; //     (   ) if (str[i] == obr[j]) //   ++j; //     1 if (j==l) if (!f(i-l+1)) return; //  ,    } }</span></span></code> </pre><br><br>  My story about a small miracle - the algorithm of the KMP came to an end.  Of course, this article on the CMP is far from the first and certainly not the last.  Here are two articles here on habrakhabr: <a href="https://habrahabr.ru/post/191454/">Search for substrings.</a>  <a href="https://habrahabr.ru/post/191454/">Knuth ‚Äì Morris-Pratt Algorithm and Substring</a> <a href="https://habrahabr.ru/post/113266/">Search and Related Issues</a> . <br>  But I hope someone will find this article useful for themselves, and someone (after all, it may happen) will apply the ILC.  Even if he did not fully understand the internal mechanism of his work (it's never too late to figure it out). <br><br>  The KMP algorithm is not the only fast search algorithm, but it <b>is</b> fast <b>enough</b> (for tasks like olympiad ones) and simple at the same time.  The <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D0%25BE%25D0%25B9%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">Boyer-Moore</a> algorithm is close to the ILC in complexity and for a certain range of tasks (where the sample does not contain repeating fragments) it is faster.  But on the other hand, for another set of tasks (where the pattern and the search string contain repeated sequences, as in the examples for the article), it is noticeably inferior to the CMP.  Finally, there are tasks where the choice of one or the other is a matter of taste (which is not disputed).  In some cases (or even areas), the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2590%25D1%2585%25D0%25BE_%25E2%2580%2594_%25D0%259A%25D0%25BE%25D1%2580%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BA">Aho-Corasic algorithm</a> can be more efficient for both the CMP and Boyer-Moore.  But those who really need this algorithm do not need a popular presentation, <b>IMHO</b> . <br><br><h4>  Addition to the discussion </h4><br>  You can modify the prefix function so that it uses the buffer not O (line length + sample length) but O (sample length).  In this case, the memory should be allocated only to store the sample prefix lengths, and the search string prefix lengths are not remembered in the array.  The length for the current position is stored in a variable and as soon as it is compared with the length of the sample (i.e., the sample is found), the prefix function calls the processing function of the found fragment.  Modified function <b>prefix_find</b> added to the article.  Actually, I never needed to save on memory allocation for an array, but I do not rule out that someone might need it. <br><br>  <b>Mayorovp</b> drew my attention to the opportunity to save memory, and he also gave a link in his <a href="https://habrahabr.ru/post/307220/">message</a> to the implementation of a variant of the prefix function, which displays the positions of the found fragments in cout. <br><br>  As noted, staticlab changed the type of variables to size_t (this would actually be more correct). <br><br>  For those who have read the article to the end, I will provide illustrations showing how prefix-suffix blocks are organized in fairly complex cases: <br><br><div class="spoiler">  <b class="spoiler_title">Illustrations</b> <div class="spoiler_text">  The lines of zeros and ones are the same, only in the first two illustrations are indices with 0, and in the following - with 1. In fact, this is not fundamental, since the <b>lengths of</b> substrings are written to the array, and the numbering method of characters in the string does not matter. <br>  The last illustration is a bird's-eye view of the prefix-string suffixes. <br>  habrhabhabrhabrhabrhabhabrhabhabrhabhabrhabrhabrhabhabrhabra <br>  without arrays of indices and lengths. <br><br><img src="https://habrastorage.org/files/dfa/2db/a16/dfa2dba164b34a328a91038099138cef.png"><br></div></div><br></div><p>Source: <a href="https://habr.com/ru/post/307220/">https://habr.com/ru/post/307220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307208/index.html">Debian Linux and Tor for a secure deb</a></li>
<li><a href="../307210/index.html">Common mistakes of the novice HTML maker-up</a></li>
<li><a href="../307212/index.html">Do not Perseids uniform or Model flash satellite with their own hands</a></li>
<li><a href="../307214/index.html">Mikrotik QOS in distributed systems or smart shapers</a></li>
<li><a href="../307218/index.html">How many neurons do you need to find out if the Alexander Nevsky Bridge is divorced?</a></li>
<li><a href="../307222/index.html">About pricing for indie games</a></li>
<li><a href="../307224/index.html">Fairy, evil corporation and duck. How games are really made. Part 2. Programmer</a></li>
<li><a href="../307226/index.html">New x features: Bind in UWP</a></li>
<li><a href="../307228/index.html">Sensor of absolute pressure BMP180</a></li>
<li><a href="../307232/index.html">We force FFMPEG to change HLS flows depending on the current throughput</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>