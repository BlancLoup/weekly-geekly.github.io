<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autotest, nightly assembly, extreme Agile. How we test our products</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our testing is a great product, tight deadlines, a huge responsibility. 

 Each company has its own views on the organization of workflows. And they c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autotest, nightly assembly, extreme Agile. How we test our products</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/748/cd8/dd4748cd82f7e350669f11af26663c07.jpg" width="500"></div><br>  <i>Our testing is a great product, tight deadlines, a huge responsibility.</i> <br><br>  Each company has its own views on the organization of workflows.  And they can be very different. <br><br>  Today we want to talk about how we test our products.  Perhaps you will argue with something, but you will adopt something. <br><a name="habracut"></a><br>  Our products consist of dozens of modules.  We regularly update them, and these upgrades are completed mini-products. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Developers assemble a pack of code in a separate version.  And write the description: ‚Äú <i>New online store in the cloud.</i>  <i>Changes such and such.</i>  <i>Added a bunch of new pages</i> . ‚Äù  And be sure to put a huge changelog with a few hundred commits. <br><br>  All this goes to testers.  I call this process ‚ÄúExtreme Agile‚Äù - we work on precise iterations.  Deviate from these rules of testing is impossible. <br><br>  This is a necessary measure - the product is huge, as are the changes in it.  And in order not to delay testing, we sacrifice a certain freedom. <br><br>  After receiving the task to check for updates, we check with the test plan.  It is designed separately for each module.  The plan lists all important usage scenarios. <br><br>  We used to do this.  We made detailed descriptions of precedents: ‚Äú <i>Click here.</i>  <i>Circles should appear in the password entry field.</i>  <i>If they do not appear, something is wrong</i> . ‚Äù <br><br>  We abandoned this practice when the number of precedents exceeded all reasonable limits. <br><br>  As a result, we came to the conclusion that our test plan is a listing of important business scenarios. <br><br>  An example is a list of case studies for working with tasks in Bitrix24. <br><br>  - Saving task works?  Great, go ahead. <br>  - Comments to the task are added?  Fine, the next item. <br><br>  First, we start with top-level, main scenarios - for example, creating and saving a store order.  And then we proceed to the scenarios at a lower level ‚Äî for example, the correct work of the deadline in the tasks. <br><br>  Then we check in several stages how the system actions are performed. <br><br><h2>  Testing stages </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/67c/2ac/11b67c2ac3c33de644d475caf5f59805.png"><br><br>  At the very beginning, we run autotests for specific modules.  We run all profitable modules through them. <br><br>  In parallel with the autotest run, we do: <br><br><h4>  Stage 1 </h4><br>  - We study the description of the changes from the developers. <br><br>  We look, as it should be on TZ.  Compare with how the module is made in reality.  But the main thing is to learn to look at the product and changes from the point of view of common sense and the average user. <br><br>  Is the working script convenient?  Is everything done ‚Äúhumanly‚Äù?  In parallel, we also conduct usability testing. <br><br>  It does not always work - a huge amount of changes.  But we still tell developers when a script can be made more convenient. <br><br>  We have automated a huge part of the routine.  And we constantly think that it is possible to screw it up. <br><br>  We discuss questions to developers in separate chats for each update.  We do not have a "broken phone" - in the chat there are all the staff involved in the release. <br><br><h4>  Stage 2 </h4><br>  So, we have studied the description of the update, and then we read into the change log - this is the second stage. <br><br>  - At this stage, we ‚Äúcatch‚Äù most of the errors.  The developer may miss something in the ‚Äúnormal‚Äù description, but the changelog will show all errors. <br><br>  Recently there was a funny thing.  The developer has made changes to the text of the localized version of the product.  In French. <br><br>  It would seem just a text.  But in this tricky combination there was an apostrophe.  As a result, at a certain stage of testing, JavaScript just started to fall. <br><br>  It turned out that the system simply does not know how to handle this combination.  But the author of the change did not mention it in the description.  We found a mistake only as a result of a careful study of the change log. <br><br><h4>  Stage 3 </h4><br>  Then the third stage begins - the analysis of customer requests for errors in the product: <br><br>  Calls are recorded in our Mantis error tracking system.  Why do we use it?  This is a historical heritage, Mantis has been ‚Äúworking‚Äù for us for 15 years already. <br><br>  Several times I suggested to colleagues to find something else.  We started to analyze and every time it turned out that Mantis has everything we need.  We perfectly integrated it into work: we linked it with ‚Äúopen lines‚Äù and technical support. <br><br>  The entire customer inquiry log for errors we take in Mantis. <br><br>  In each mini-update, we include both features and bug fixes that customers and testers have found. <br><br>  The developer claims that the error is fixed - we check.  If the error is not corrected, we return the ticket to work. <br><br>  If the developer fails to correct the same error several times, then remove this non-working part from the update, send it to the developer for revision. <br><br><h4>  Stage 4 </h4><br>  After verification, proceed to the fourth stage - the re-run of the test plan. <br><br>  The market situation may change.  If yesterday conditions were alone, then tomorrow they may change.  We do not have a tight binding to the TZ, which we developed six months ago.  Therefore, we run the test plan again. <br><br><h4>  5 stage </h4><br>  The fifth stage is the assembly of the update package and uploading to the reference testing environment: It is located in the Amazon cloud and is a separate portal ‚ÄúBitrix24‚Äù. <br><br>  Here is the final check of business scenarios.  At night, the whole set of autotests is run out, they track changes in infrastructure indicators. <br><br><h4>  6 stage </h4><br>  At the sixth stage, we organize a group of closed testing. <br><br>  The groups are not testers, but real customers and our partners.  We do this to get feedback from real users of our product.  Those who will work directly with him. <br><br>  By this stage, almost all the errors have already been caught.  Users tell how comfortable it is for them to work in different scenarios.  You can call this additional usability testing. <br><br><h4>  Stage 7 </h4><br>  Then comes the turn of the seventh stage - semi-closed testing: <br><br>  As a rule, in my Facebook, I invite customers to be the first to test our new products.  Anyone can participate, it's free, just <a href="https://www.facebook.com/strokatyy">email me</a> . <br><br>  For semi-closed testing, we have a stage environment.  Portals of customers who wish to participate are added to it.  Usually we recruit several thousand portals, but it all depends on the scale of the update. <br><br>  Here we also appreciate the convenience of working with the product, the convenience of scenarios. <br><br>  There are things that sometimes seem unobvious and at the previous stage the partners write that it is impossible to do this.  And this stage allows you to run the solution on a much larger sample of clients, to test the hypotheses. <br><br>  This stage can take 2-3 weeks.  We constantly make changes to customer feedback. <br><br>  After testing on the update update rolls out in production.  And we happily write educational articles and shoot a video. <br><br>  You can write about your impressions on Facebook, in person or on a public <a href="https://www.facebook.com/1CBitrix/">page</a> .  Ask questions, express opinions, criticize - I always welcome the constructive. <br><br><h2>  Cloud first </h2><br>  Many customers complain that we release updates first for the cloud version of Bitrix24.  So far, we have not been able to build the testing process and product release in such a way as to synchronously release updates for both the cloud and the box. <br><br>  The release of a box update is a more complicated process.  If you are familiar with running in a raw product, then you know what a test environment is.  In the cloud, we already have a ready-made infrastructure with given versions of PHP and MySQL with its own encoding.  Everything is set up and working there - you can install the product and test it calmly. <br><br>  With the "box" is different.  The variability of "environments" among customers is huge.  We try to encourage users to switch to higher versions of PHP, but many do so reluctantly. <br><br>  In fact, a large proportion of customers begin to change the version of PHP, only when they are forced hosters.  Add to this a variety of MySQL versions and encodings. <br><br>  That is why testing the "box" is much more difficult and longer. <br><br><h2>  Autotesting </h2><br>  Above, I described in detail the process of manual testing, but this is only part of the whole process.  Auto-testing plays an equally important role. <br><br>  The creation of autotests in our special department. <br><br>  Previously, we wrote large screenplay projects.  And these scenarios were related.  But they are difficult to maintain, if in a short time a huge amount of changes rolls out in the product. <br><br>  Therefore, we have broken large scenario autotests into smaller independent scenarios, cases. <br><br>  To work with autotests, we have a self-written framework on .NET and a separate framework for working with the database. <br><br>  Why do we have a PHP product, and a framework for autotests on .NET? <br><br>  In my many years of experience, any framework that will work is suitable for autotesting UI.  We use .NET because it connects perfectly to the UI and works great with Selenium, well, I just like it. <br><br>  How is the average autotest? <br><br><ul><li>  Prepare a test installation to test the script, through the API, bypassing the interface </li><li>  The robot checks the given case.  For example, tasks. </li></ul><br>  The same with data cleansing.  Checked the script.  If everything is good, then the task is not deleted through the interface, but through the API ‚Äî we call the method of deleting the task.  The robot quickly clears the data behind it. <br><br>  Previously, we tested only through the interface. <br><br>  It is believed that the more we click the interface, the better.  But we left it, because today it is important to test for precedents. <br><br><h2>  Smoke tests and night auto tests </h2><br>  We also conduct smoke tests.  They work very fast and check out the highest level, most popular business scenarios. <br><br>  We usually use them for final verification. <br><br>  If we return to the large testing process, a large iteration, a large update package, then we ‚Äúset‚Äù the package on the reference environment.  And at night the autotests are scheduled.  All sleep, and the robot clicks on the specified scenarios. <br><br>  Now our full cycle of night autotests has finally begun to fit in at night.  It used to take about 32 hours.  It was possible to accelerate autotests with the help of virtual machines and constant optimizations of the framework and the tests themselves. <br><br>  But there is no constant integration in our testing process.  It does not suit us, because there is an accumulated ‚Äúhistorical heritage‚Äù. <br><br>  We cannot abandon any part of the infrastructure that is very large and complex.  So, for now we are timidly trying to implement small elements of the classic continuous integration. <br><br><h2>  Nightly builds </h2><br>  Users of the boxed version know that every three months we release a new distribution.  And for three months, a new build is automatically assembled and laid out every night. <br><br>  How does this happen? <br><br>  The self-written system calls the update collector and automatically installs all possible updates.  Looks that fell during the installation phase. <br><br>  Then the machine collects all available distributions - we have 8 editions of them - and at night it develops local installations. <br><br>  Night builds we do not lay out in open access.  The system again fixes whether everything is established.  If everything is in order, all autotests are started. <br><br>  In the morning, the tester checks the logs and looks at where and what fell, where the developer made a mistake, where you need to fix the autotest. <br><br><h2>  Unit Tests </h2><br>  Most of our tests are UI, not Unit.  We use unit tests for important components only: main module, CRM, online store. <br><br>  In some companies, there is disagreement about who should write unit tests. <br><br>  In my opinion, they can write and testers, and developers.  We have developed so that the developers write them. <br><br>  To run unit tests, we use the standard PHP unit tool.  Just call the method.  We look at how it works with the parameters that are given to the input.  And look at the answer. <br><br><h2>  URL checker </h2><br>  This is my old idea.  Perhaps someone will be useful. <br><br>  Entry robot: <br><br><ul><li>  Gets the root URL of the site </li><li>  Collects the URL of all pages </li><li>  Goes over them and looks to see if there are any errors. </li></ul><br>  We have a ready list of possible errors: error 404, fatal error, database errors, JS errors, invalid characters, broken image, error 500. <br><br>  All that can be found and pulled out of the page code, the robot adds to the log with screenshots. <br><br>  To write such a robot is extremely simple, but it can save a lot of time. <br><br><h2>  Component checker </h2><br>  Our component checker works like this: <br><br><ul><li>  The component is placed on the page. </li><li>  It is saved, updated. </li><li>  We look what is given in text form and in code </li></ul><br>  An effective and simple test for web development. <br><br>  If you are our partner, and have ever given the module to our moderator in the Marketplace for moderation, know that we will definitely drive all your decisions with this checker. <br><br><h2>  Visual experiment </h2><br>  Now we are conducting a small experiment - we translate test plans from text into visual diagrams.  They are like communication diagrams. <br><br>  They immediately see which elements of the product are connected with what: what does saving orders or what affects saving itself?  What and how can affect the inventory accounting scheme? <br><br>  So the tester can quickly assess - which elements will be affected by changes in a particular component. <br><br><h2>  Quality testing </h2><br>  We abandoned over-testing.  I am a supporter of the principle of sufficiency. <br><br>  Now we are testing very little for ‚Äúfoolproof‚Äù.  For example, in the input field of a sum of money, most likely, we will not enter letters. <br><br>  In some companies it is practiced.  Some people think that any good tester is not obliged to limit himself to prescribed test precedents.  He can just make them up. <br><br>  But for us this approach has ceased to work - in our realities there is enough ‚Äúsufficient‚Äù testing. <br><br>  Sufficiency is determined by the needs of the market and the timing of product release.  We can test the new feature of the year, but be late with the release. <br><br>  Therefore, we adhere to the principle of sufficiency.  We do not release the raw product, because we are thrown out of the market.  And do not pull with the release of a licked feature, which will be outdated at the time of release. <br><br>  * * * <br>  I am interested in your opinion on the read.  How is testing done in your company? </div><p>Source: <a href="https://habr.com/ru/post/274955/">https://habr.com/ru/post/274955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274945/index.html">Keep this in mind! On the issue of warehouse automation</a></li>
<li><a href="../274947/index.html">Management of the company-developer: you need it?</a></li>
<li><a href="../274949/index.html">Corporate software for growth</a></li>
<li><a href="../274951/index.html">Everything goes according to plan? Planning in Bitrix24</a></li>
<li><a href="../274953/index.html">"Bitrix24" - now completely free communications for any team</a></li>
<li><a href="../274957/index.html">Enhanced ip</a></li>
<li><a href="../274959/index.html">Android IDE Template Format</a></li>
<li><a href="../274961/index.html">On the revision of the results of the competition in programming on JS</a></li>
<li><a href="../274967/index.html">Monitoring SSL certificate and domain expiration</a></li>
<li><a href="../274975/index.html">Monte Carlo method and its accuracy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>