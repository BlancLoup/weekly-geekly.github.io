<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating maps of noise functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most popular articles on my site is devoted to the generation of polygonal maps ( transfer to Habr√©). Creating such cards requires a lot of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating maps of noise functions</h1><div class="post__text post__text-html js-mediator-article">  One of the most popular articles on my site is devoted to the <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">generation of polygonal maps</a> ( <a href="https://habr.com/post/322504/">transfer</a> to Habr√©).  Creating such cards requires a lot of effort.  But I did not start with this, but with a <em>much</em> simpler task, which I will describe here.  This simple technique allows you to create such maps in less than 50 lines of code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  I will not explain how to <em>draw</em> such maps: it depends on the language, graphics library, platform, etc.  I‚Äôll just explain how to <em>fill in an array of</em> map data. <br><br><h2>  Noise </h2><br>  The standard way to generate 2D maps is to use a limited band noise function, such as a Perlin noise or simplex noise, as a building block.  Here's what the noise function looks like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="image"></div><br>  We assign each point of the map a number from 0.0 to 1.0.  In this image, 0.0 is black and 1.0 is white. <a name="habracut"></a>  Here's how to set the color of each grid point in the syntax of a similar C language: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  The loop will work the same way in Javascript, Python, Haxe, C ++, C #, Java, and most other popular languages, so I will show it in a C-like syntax so you can convert it to the language you need.  In the rest of the tutorial, I will show how the body of the loop changes (the string <code>value[y][x]=‚Ä¶</code> ) when adding new functions.  The demo will show a complete example. <br><br>  In some libraries, it will be necessary to shift or multiply the resulting values ‚Äã‚Äãto return them in the interval from 0.0 to 1.0. <br><br><h2>  Height </h2><br>  The noise itself is just a set of numbers.  We need to give it <em>meaning</em> .  The first thing to think about is to bind the noise value to the height (this is called the ‚Äúheight map‚Äù).  Let's take the noise shown above and draw it as a height: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  The code remained almost the same, except for the inner loop.  Now it looks like this: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Yes, that's all.  These maps have remained the same, but now I‚Äôll call them <code>elevation</code> , not <code>value</code> . <br><br>  We got a lot of hills, but nothing more.  What's wrong? <br><br><h3>  Frequency </h3><br>  Noise can be generated at any <em>frequency</em> .  So far I have chosen only one frequency.  Let's see how it affects. <br><br>  <strong>Try changing the value of the slider</strong> (in the original article) and see what happens at different frequencies: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Here the scale just changes.  At first it seems not very useful, but it is not.  I have another <a href="https://www.redblobgames.com/articles/noise/introduction.html">tutorial</a> ( <a href="https://habr.com/post/321874/">translation</a> in Habr√©), which explains the <em>theory</em> : concepts such as frequency, amplitude, octaves, pink and blue noise, and so on. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  It is also sometimes useful to recall the <em>wavelength</em> , which is the reciprocal of frequency.  With frequency doubling, the size is only halved.  Doubling the wavelength all doubles.  Wavelength is the distance measured in pixels / tiles / meters or any other units you have chosen for the maps.  It is related to the frequency: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Octave </h3><br>  To make the elevation map more interesting, we <em>add noise with different frequencies</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Let's mix in the same map large low-frequency hills with small high-frequency hills.  <strong>Move the slider</strong> (in the original article) to add small hills to the mix: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Now it is much more like the fractal relief we need!  We can get hills and uneven mountains, but we still don't have flat plains.  For this you need something else. <br><br><h3>  Redistribution </h3><br>  The noise function gives us values ‚Äã‚Äãbetween 0 and 1 (or -1 to +1, depending on the library).  To create flat plains, we can <em>raise the height to a power</em> .  <strong>Move the slider</strong> (in the original article) to get different degrees. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  High values <em>lower average heights into the plains</em> , and low values ‚Äã‚Äãraise average heights towards mountain peaks.  We need to lower them.  I use power functions because they are simpler, but you can use any curve;  I have a more complicated <a href="https://www.redblobgames.com/articles/noise/2d/">demo</a> . <br><br>  Now that we have a realistic elevation map, let's add biomes! <br><br><h2>  Biomes </h2><br>  Noise gives numbers, but we need a map with forests, deserts and oceans.  The first thing you can do is turn small heights into water: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Wow, this is already becoming a procedurally generated world!  We have water, grass and snow.  But what if we need more?  Let's make a sequence of water, sand, grass, forest, savannah, desert, and snow: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Elevation elevation</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Wow, that looks great!  For your game you can change the values ‚Äã‚Äãand biomes.  There will be much more jungle in Crysis;  Skyrim has a lot more ice and snow.  But no matter how you change the numbers, this approach is rather limited.  The types of relief correspond to heights, therefore they form stripes.  To make them more interesting, we need to choose biomes based on something else.  Let's create a <em>second</em> noise map for humidity. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Above - the noise of heights;</i>  <i>below - the noise of humidity</i> <br><br>  Now let's use the height and humidity <em>together</em> .  In the first image shown below, the y-axis is the height (taken from the image above) and the x-axis is the humidity (the second image is higher).  This gives us a convincing map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Relief based on two noise values</i> <br><br>  Low heights are oceans and coasts.  Great heights are rocky and snowy.  In between, we get a wide range of biomes.  The code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  If necessary, you can change all these values ‚Äã‚Äãin accordance with the requirements of your game. <br><br>  If we do not need biomes, then smooth gradients (see <a href="http://www.shadedrelief.com/hypso/hypso.html">this article</a> ) can create colors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  For both biomes and gradients, a single noise value does not provide sufficient variability, but two is enough. <br><br><h2>  Climate </h2><br>  In the previous section, I used <em>altitude</em> as a substitute for <em>temperature</em> .  The greater the height, the lower the temperature.  However, temperatures are also influenced by geographic latitude.  Let's use temperature and altitude and latitude to control temperature: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  Near the poles (high latitudes) the climate is colder, and on the tops of the mountains (high altitudes) the climate is also colder.  So far I have worked it not very hard: for the correct approach to these parameters you need a lot of fine tuning. <br><br>  There is also <em>seasonal</em> climate change.  In summer and in winter, the northern and southern hemispheres become warmer and colder, but at the equator the situation does not change much.  Here too much can be done, for example, one can model the prevailing winds and ocean currents, the influence of biomes on climate and the averaging effect of the oceans on temperature. <br><br><h2>  Islands </h2><br>  In some projects I needed the borders of the map to be water.  This turns the world into one or more islands.  There are many ways to do this, but in my polygon map generator I used a fairly simple solution: I changed the height like <code>e = e + a - b*d^c</code> , where <code>d</code> is the distance from the center (on a scale of 0-1).  Another option is to change <code>e = (e + a) * (1 - b*d^c)</code> .  The constant <code>a</code> raises everything up, <code>b</code> lowers the edges, and <code>c</code> controls the speed of descent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>I am not completely satisfied with this</em> and there is still much to explore.  Should it be Manhattan or Euclidean distance?  Should it depend on the distance to the center or from the distance to the edge?  Should the distance be squared, or be linear, or have some other degree?  Should it be addition / subtraction, or multiplication / division, or something else?  In the original article <b>try</b> Add, a = 0.1, b = 0.3, c = 2.0 or <b>try</b> Multiply, a = 0.05, b = 1.00, c = 1.5.  The options that suit you are dependent on your project. <br><br>  Why even stick to standard mathematical functions?  As I told in my <a href="https://www.redblobgames.com/articles/probability/damage-rolls.html">article about the damage in the RPG</a> ( <a href="https://habr.com/post/335840/">transfer</a> to Habr√©), everyone (including me) uses mathematical functions such as polynomials, exponential distributions, etc., but on the computer we can not be limited to them.  We can take <em>any</em> shaping function and use it here, using the lookup table <code>e = e + height_adjust[d]</code> .  So far I have not studied this question. <br><br><h2>  Pointed noise </h2><br>  Instead of raising the height to a power, we can use absolute value to create sharp peaks: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  To add octaves, we can vary the amplitudes of the high frequencies so that only mountains get added noise: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  I do not have much experience with this technique, so I need to experiment to learn how to use it well.  It may also be interesting to mix pointed low-frequency noise with non-pointed high-frequency noise. <br><br><h2>  Terraces </h2><br>  If we round the height to the next n levels, we get terraces: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  This is the result of applying the redistribution altitude function in the form <code>e = f(e)</code> .  Above, we used <code>e = Math.pow(e, exponent)</code> to sharpen mountain peaks;  here we use <code>e = Math.round(e * n) / n</code> to create terraces.  If you use a non-step function, the terraces can be rounded or occur only at some heights. <br><br><h2>  Tree placement </h2><br>  We usually used fractal noise for altitude and humidity, but it can also be used to place unevenly spaced objects, such as trees and stones.  For altitude we use high amplitudes with low frequencies (‚Äúred noise‚Äù).  To place objects you need to use high amplitudes with high frequencies (‚Äúblue noise‚Äù).  On the left is a blue noise pattern;  the right shows the places where the noise is more than the neighboring values <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  Choosing for each biome different R, we can get a variable density of trees: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  It's great that such noise can be used to place trees, but often more efficient and create a more even distribution of other algorithms: Poisson spots, Van tiles or graphical dithering. <br><br><h2>  To infinity and beyond </h2><br>  The calculations of the biome at position (x, y) do not depend on the calculations of all other positions.  This <strong>local calculation</strong> has two convenient properties: it can be calculated in parallel, and it can be used for infinite relief.  <strong>Place the mouse cursor on the minimap</strong> (in the original article) on the left to generate a map on the right.  You can generate any part of the map without generating (and even without storing) the entire map. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implementation </h2><br>  Using noise to generate terrain is a popular solution, and you can find tutorials on the Internet for many different languages ‚Äã‚Äãand platforms.  The code for generating maps in different languages ‚Äã‚Äãis about the same.  Here is the simplest loop in three different languages: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  All noise libraries are quite similar to each other.  Try <a href="https://pypi.python.org/pypi/opensimplex/">opensimplex for Python</a> , or <a href="http://libnoise.sourceforge.net/docs/">libnoise for C ++</a> , or <a href="https://www.npmjs.com/package/simplex-noise">simplex-noise</a> for Javascript.  For most popular languages, there are many noise libraries.  Or you can study how Perlin noise works or realize the noise yourself.  <em>I did not do this.</em> <br><br>  In different noise libraries for your language, application details may vary slightly (some return numbers in the range from 0.0 to 1.0, others in the range from -1.0 to +1.0), but the basic idea is the same.  For a real project, you may need to wrap the <code>noise</code> function and the <code>gen</code> object into a class, but these details are irrelevant, so I made them global. <br><br>  For such a simple project, it does not matter what noise you use: Perlin noise, simplex noise, OpenSimplex noise, value noise, midpoint shift, diamond algorithm or inverse Fourier transform.  Each of them has its pros and cons, but for a similar map generator, they all create more or less the same output values. <br><br>  <em>Drawing a</em> map depends on the platform and the game, so I did not implement it;  This code is only needed to generate heights and biomes, the rendering of which depends on the style used in the game.  You can copy, port and use it in your projects. <br><br><h2>  Experiments </h2><br>  I considered mixing the octaves, raising the height to a power, and combining the height with the humidity to produce a biome.  <a href="https://www.redblobgames.com/maps/terrain-from-noise/">Here</a> you can explore an interactive graph that allows you to experiment with all these parameters, which shows what the code consists of: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Here is a sample code: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  There is a difficulty here: for noise of heights and humidity it is necessary to use a different seed, otherwise they will be the same, and the maps will not look so interesting.  In Javascript I use <a href="https://www.npmjs.com/package/prng-parkmiller-js">the prng-parkmiller library</a> ;  in C ++, you can use two separate <a href="http://www.cplusplus.com/reference/random/linear_congruential_engine/linear_congruential_engine/">linear_congruential_engine objects</a> ;  in Python, you can create two separate instances of the <a href="https://docs.python.org/3/library/random.html">random.Random class</a> . <br><br><h2>  Thoughts </h2><br>  I like this approach to card generation because of its <b>simplicity</b> .  It is fast and requires very little code to create decent results. <br><br>  I do not like its limitations in this approach.  Local computing means that each point is independent of all others.  Different areas of the map are <em>not related to each other</em> .  Each place on the map "seems" the same.  There are no global restrictions here, for example ‚Äúthere should be from 3 to 5 lakes on the map‚Äù or global characteristics, for example, a river flowing from the top of the highest peak to the ocean.  Also, I don‚Äôt like the fact that to get a good picture you need to adjust the parameters for a long time. <br><br>  Why do I recommend it?  I think this is a good starting point, especially for indie games and game jams.  Two of my friends wrote the initial version of <a href="https://en.wikipedia.org/wiki/Realm_of_the_Mad_God">Realm of the Mad God in</a> just 30 days for a <a href="http://www.tigsource.com/2010/02/07/assemblee-competition-results/">game contest</a> .  They asked me for help in making maps.  I used this technique (plus a few more features that were not particularly useful) and made them a map.  A few months later, after receiving feedback from players and having carefully studied the design of the game, we created a more advanced map generator based on Voronoi polygons, described <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">here</a> (Habr√© <a href="https://habr.com/post/322504/">translation</a> ).  This map generator does not use the techniques described in this article.  In it, the noise for creating maps is applied quite differently. <br><br><h2>  Additional Information </h2><br>  There are <em>many</em> cool things you can do with the noise features.  If you search the Internet, you can find options such as turbulence, billow, ridged multifractal, amplitude damping, terraced, voronoi noise, analytical derivatives, domain warping, and others.  You can use <a href="http://iquilezles.org/www/articles/warp/warp.htm">this page</a> as a source of inspiration.  Here I do not consider them, my article focuses on simplicity. <br><br>  This project was influenced by my previous map generation projects: <br><br><ul><li>  I used the general Perlin noise for <a href="http://simblob.blogspot.com/2010/01/simple-map-generation.html">my first Realm of the Mad God card maker</a> .  We used it for the first six months of alpha testing, and then replaced it with <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">a map generator on Voronoi polygons</a> , specially created for the gameplay requirements that we defined during the alpha testing process.  Biomes and their colors for the article are taken from these projects. </li><li>  When studying audio signal processing, I wrote a <a href="https://www.redblobgames.com/articles/noise/2d/">tutorial on noise</a> , which explains concepts such as frequency, amplitude, octaves, and noise "color".  The same concepts working for sound are also applicable for noise-based map generation.  At that time, I created a few raw <a href="https://www.redblobgames.com/articles/noise/2d/">demo of the terrain generation</a> , but I didn‚Äôt finish them. </li><li>  Sometimes I experiment to find boundaries.  I wanted to know how much code is minimally needed to create compelling maps.  In <a href="https://www.redblobgames.com/x/1446-svg-filters/">this mini-project,</a> I reached <b>zero</b> lines of code ‚Äî everything is done by image filters (turbulence, thresholds, color gradients).  It pleased me and upset me.  To what extent can the generation of maps be performed by image filters?  In big enough.  Everything told above about the ‚Äúscheme of smooth color gradients‚Äù is taken from this experiment.  The noise layer is the image filter ‚Äúturbulence‚Äù;  octaves are images superimposed on each other;  The degree tool is called ‚Äúcurve correction‚Äù in Photoshop. </li></ul><br>  I get a little strained by the fact that most of the code that game developers write to generate noise-based relief (including midpoint displacement) turns out to be the same as in sound and image filters.  On the other hand, it creates quite decent results in just a few lines of code, which is why I wrote this article.  This is a <em>quick and easy reference point</em> .  Usually I do not use such cards for a long time, but replace them with a more complex card generator, as soon as I know which card types are better suited to the design of the game.  For me, this is a standard pattern: to start with something extremely simple, and then replace it only after I better understand the system with which I work. <br><br>  There are <em>many</em> more pieces that can be done with noise, in the article I mentioned only a few.  Try <a href="https://codepen.io/MittenedWatchmaker/full/aVeoRM/">Noise Studio</a> to interactively test various features. </div><p>Source: <a href="https://habr.com/ru/post/430384/">https://habr.com/ru/post/430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430374/index.html">Data Engineering and more: videotapes and slides from the mitap in Wrike</a></li>
<li><a href="../430376/index.html">JavaScript Guide, Part 6: Exceptions, Semicolon, Pattern Literals</a></li>
<li><a href="../430378/index.html">J2CL - Better Late Than Never</a></li>
<li><a href="../430380/index.html">JavaScript Guide, Part 5: Arrays and Loops</a></li>
<li><a href="../430382/index.html">JavaScript Guide, Part 4: Functions</a></li>
<li><a href="../430386/index.html">India to build solid state storage power plant</a></li>
<li><a href="../430388/index.html">Unconference Web Summit</a></li>
<li><a href="../430390/index.html">Introvert path in career and business</a></li>
<li><a href="../430394/index.html">Implementing Instant Android Search with RxJava</a></li>
<li><a href="../430396/index.html">Chain replication: building efficient KV storage (part 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>