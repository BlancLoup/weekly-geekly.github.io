<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Keeping up with the times: Using JWT in ASP.NET Core</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The release of ASP.Net Core 1.0 was released in June 2016 and now, if you are not afraid of the age of the new framework, you can gently start microse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Keeping up with the times: Using JWT in ASP.NET Core</h1><div class="post__text post__text-html js-mediator-article"> The release of ASP.Net Core 1.0 was released in June 2016 and now, if you are not afraid of the age of the new framework, you can gently start microservice in production (they all use microservice architecture, aren't they?).  In order to restrict access to your microservice for third parties, you need to do authentication using a fairly common method - tokens.  In the article under the cat, we will tell you more about how to do this using JSON Web Token (JWT), as well as the pros and cons of this approach. <br><br><img src="https://habrastorage.org/files/027/a54/123/027a54123b51414780d976e34a6c21dd.jpg"><br><a name="habracut"></a><br>  Typically, a token is a randomly generated string that is associated with a specific user and to retrieve its data (for example, id or email), it is necessary to make a query to the database (DB).  But, what if we don‚Äôt need to make an extra query to the database with user data, but need to store them right inside the token?  This is possible with JWT.  Let us examine what JWT is and create a test project. <br><br>  JWT is a signed JSON object containing something useful (for example, user id, user rights / roles), encoded in <i>base64</i> and consisting of three parts separated by dots <code>.</code>  : <i>Header</i> , <i>Payload</i> , <i>Signature</i> and usually looks like this <code>aaaaaaa.bbbbbb.cccccc</code> .  More information can be found at <a href="https://jwt.io/introduction/">jwt.io</a> or <a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Header - contains the type of the token, and the name of the hashing algorithm: <code>{ "alg": "HS256", "typ": "JWT" }</code> </li><li>  Payload - an object containing any data we need: <code>{ "email": "temp@jwt.ru", "user_id": "57dc51a3389b30fed1b13f91" }</code> </li><li>  Signature - serves to verify the sender that he is who he claims to be, and so that the message has not been changed.  If we use the HMAC SHA256 algorithm, the creation of the signature will look like this: <code>HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)</code> </li></ul><br><h2>  Project preparation </h2><br>  As usual, let's start by creating an empty project.  After that, add the following dependencies to the <code>project.json</code> file: <br><br><pre> <code class="hljs css">"<span class="hljs-selector-tag"><span class="hljs-selector-tag">Microsoft</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AspNetCore</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Authentication</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.JwtBearer</span></span>": "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">Microsoft</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AspNetCore</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Mvc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Core</span></span>": "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">Microsoft</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AspNetCore</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Mvc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Formatters</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Json</span></span>": "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>"</code> </pre> <br>  I use the <code>Microsoft.AspNetCore.Mvc.Core</code> assembly instead of <code>Microsoft.AspNetCore.Mvc</code> in order not to drag unnecessary (for our rest service) dependencies in the form of <i>Razor</i> , <i>TagHelper</i> , etc. <br><br>  In ASP.NET Core, the starting configuration of the project is specified in the <code>Startup.cs</code> file, slightly correcting it: <br><br><pre> <code class="javascript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Startup</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ConfigureServices(IServiceCollection services) { services.AddMvcCore(); } public <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseMvc().UseMvcWithDefaultRoute(); } }</code> </pre><br><h2>  Customize JWT </h2><br>  Open our <code>Startup.cs</code> and add the following: <br><br><pre> <code class="javascript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Startup</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ConfigureServices(IServiceCollection services) { services.AddMvcCore() .AddAuthorization(); services.AddSingleton&lt;IHttpContextAccessor, HttpContextAccessor&gt;(); } public <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = Encoding.UTF8 .GetBytes(<span class="hljs-string"><span class="hljs-string">"401b09eab3c013d4ca54922bb802bec8fd5318192b0a75f201d8b3727429090fb337591abd3e44453b954555b7a0812e1081c39b740293f765eae731f5a65ed1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JwtBearerOptions { TokenValidationParameters = { ValidIssuer = <span class="hljs-string"><span class="hljs-string">"ExampleIssuer"</span></span>, ValidAudience = <span class="hljs-string"><span class="hljs-string">"ExampleAudience"</span></span>, IssuerSigningKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SymmetricSecurityKey(key), ValidateIssuerSigningKey = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, ValidateLifetime = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, ClockSkew = TimeSpan.Zero } }; app.UseJwtBearerAuthentication(options); app.UseMvcWithDefaultRoute(); } }</code> </pre><br>  In the <code>ConfigureServices</code> method, everything is pretty obvious, we add the use of the authorization service, and also register the <code>HttpContextAccessor</code> .  For what we needed explicit registration HttpContextAccessor, we will find out a little later.  Let us turn to the <code>Configure</code> method, in which the parameters are set up to validate the <b>JWT</b> token.  Now, we are most interested in three parameters: <br><br>  <code>IssuerSigningKey</code> is the key with which our token should be signed.  For example, choose <i>SymmetricSecurityKey</i> , but you can also specify <i>X509SecurityKey ()</i> or <i><a href="https://tools.ietf.org/html/rfc7517">JsonWebKey</a></i> if you have a lot of love for JSON. <br><br>  <code>ValidateIssuerSigningKey</code> - we indicate that we will verify the key with which the JWT token was signed. <br>  <code>ValidateLifetime</code> - set to <i>true</i> , because we want to control the lifetime of the token. <br><br><h2>  Create routes </h2><br>  Now we need to add two methods: one to generate a token, the second to verify JW authentication.  Create a simple <code>HomeController.cs</code> controller: <br><br><pre> <code class="javascript hljs"> [Route(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)] public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeController</span></span></span><span class="hljs-class"> </span></span>{ private readonly IHttpContextAccessor _context; public HomeController(IHttpContextAccessor context) { _context = context; } [HttpGet(<span class="hljs-string"><span class="hljs-string">"token"</span></span>)] public dynamic GetToken() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JwtSecurityTokenHandler(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sec = <span class="hljs-string"><span class="hljs-string">"401b09eab3c013d4ca54922bb802bec8fd5318192b0a75f201d8b3727429090fb337591abd3e44453b954555b7a0812e1081c39b740293f765eae731f5a65ed1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> securityKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(sec)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> signingCredentials = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SigningCredentials(securityKey,SecurityAlgorithms.HmacSha256Signature); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> identity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClaimsIdentity(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericIdentity(<span class="hljs-string"><span class="hljs-string">"temp@jwt.ru"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Claim(<span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"57dc51a3389b30fed1b13f91"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> token = handler.CreateJwtSecurityToken(subject: identity, <span class="hljs-attr"><span class="hljs-attr">signingCredentials</span></span>: signingCredentials, <span class="hljs-attr"><span class="hljs-attr">audience</span></span>: <span class="hljs-string"><span class="hljs-string">"ExampleAudience"</span></span>, <span class="hljs-attr"><span class="hljs-attr">issuer</span></span>: <span class="hljs-string"><span class="hljs-string">"ExampleIssuer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">expires</span></span>: DateTime.UtcNow.AddSeconds(<span class="hljs-number"><span class="hljs-number">42</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler.WriteToken(token); } [Authorize, HttpGet(<span class="hljs-string"><span class="hljs-string">"secure"</span></span>)] public dynamic Secret() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentUser = _context.HttpContext.User; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentUser.Identity.Name; } }</code> </pre><br>  Since I use <code>AspNetCore.Mvc.Core</code> , the only way (although there may be another one) is to get to HttpContext - just through <code>IHttpContextAccessor</code> , which we registered earlier. <br><br>  <code>signingCredentials</code> - we create a key with which we sign our token, it should be the same as the one we specified in <code>Startup.cs</code> when setting up JWT parameters. <br><br>  <code>identity</code> - create our <code>payload</code> .  Of course, in a real application we will get data from the repository, having checked them before, and now we will build some hardcode. <br><br>  When creating a token, we specify its lifetime: <code>expires: DateTime.UtcNow.AddSeconds(42)</code> , rather trivial and flexible. <br><br>  Run the application and execute the first request for a token: <br><br><pre> <code class="javascript hljs">curl -X GET <span class="hljs-string"><span class="hljs-string">"http://localhost:&lt;your_port&gt;/token"</span></span></code> </pre> <br>  In response, the token will return to us: <br><br><pre> <code class="javascript hljs">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6InRlc3RAdGVzdC5ydSIsInVzZXJfaWQiOiI1N2RjNTFhMzM4OWIzMGZlZDFiMTNmOTEiLCJuYmYiOjE0NzQyMTU4MDAsImV4cCI6MTQ3NDIxNTgzNSwiaWF0IjoxNDc0MjE1ODAwLCJpc3MiOiJFeGFtcGxlSXNzdWVyIiwiYXVkIjoiRXhhbXBsZUF1ZGllbmNlIn0<span class="hljs-number"><span class="hljs-number">.9</span></span>NhOkoalaE70nIb-erH_waWx8rk6QJta5N19EiBLETQ</code> </pre> <br>  Let's try to make a request for a secret route without a token: <br><br><pre> <code class="javascript hljs">curl -X GET <span class="hljs-string"><span class="hljs-string">"http://localhost:&lt;your_port&gt;/secure"</span></span></code> </pre> <br>  In response, <code>401 Unauthorized</code> will be returned, as expected. <br><br>  Now we will make a request with the received token: <br><br><pre> <code class="javascript hljs">curl -X GET -H <span class="hljs-string"><span class="hljs-string">"Authorization: Bearer token_should_be_here"</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:&lt;your_port&gt;/secure"</span></span></code> </pre> <br>  The response will contain an email, which we passed to the constructor when creating <code>GenericIdentity</code> . <br><br>  If we wait 42 seconds, and our token lives so much, and we try to repeat the previous request, we will get: <code>401 Unauthorized</code> and the <code>WWW-Authenticate</code> header will have the value: <code>Bearer error="invalid_token", error_description="The token is expired"</code> telling us about expired token. <br><br><h2>  Instead of conclusion </h2><br>  As with any solution, in addition to the pros, JWT also has disadvantages.  For example, if we need to revoke a token, before its lifetime ends, then we can do it in two ways: <br><br><ul><li>  Use <code>blacklist</code> that will contain invalid tokens.  But now we still have to make an extra request to check our token. </li><li>  Some suggest using two tokens, one short, for 10 minutes, and <code>refresh</code> - a token for a longer time.  Not a beautiful decision in my opinion. </li></ul><br>  If you can allow the recall of all tokens at once in your project, then you can safely use JWT, otherwise the gain is not very big. <br><br>  We made a prototype project using JWT, in which we can validate and create tokens.  Of course, in a real project, everything will be a little different, because the format of the article is not enough to talk about all the JWT parameters in ASP.NET Core. <br><br><h3>  about the author </h3><br><img src="https://habrastorage.org/files/36e/618/416/36e618416e104a83a7b0da7aa2f483e2.jpg" align="left" width="120"><br>  Slava Bobik is an engineer at Radario, an ASP.NET Core and OSS enthusiast.  He is fond of distributed systems and skydiving. </div><p>Source: <a href="https://habr.com/ru/post/311594/">https://habr.com/ru/post/311594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311584/index.html">About hacking servers FirstVDS</a></li>
<li><a href="../311586/index.html">Restrictions (—Åonstraints) PostgreSQL: exclude, partial unique, pending restrictions, etc.</a></li>
<li><a href="../311588/index.html">What to do so that the organizer of the conference wants you</a></li>
<li><a href="../311590/index.html">Dependency Injection with Scala validation using language tools</a></li>
<li><a href="../311592/index.html">Chat bots, and how will Microsoft help us with this?</a></li>
<li><a href="../311596/index.html">Why traditional anti-money theft protection in RBS systems is vulnerable</a></li>
<li><a href="../311598/index.html">How to check causality without experiment?</a></li>
<li><a href="../311600/index.html">Power Query: how to stop being afraid of functional programming and start working in the advanced query editor</a></li>
<li><a href="../311602/index.html">GoTech 2016 participants: facts and figures</a></li>
<li><a href="../311604/index.html">Creating a programming language. Part 0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>