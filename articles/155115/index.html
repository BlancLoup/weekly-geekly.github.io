<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does apache cassandra work?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this topic, I would like to talk about how Cassandra ( cassandra ) is organized ‚Äî a decentralized, fault-tolerant, and reliable key-value database....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does apache cassandra work?</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2581%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B0"><img src="https://habrastorage.org/getpro/habr/post_images/21d/85e/47f/21d85e47fcd22d3d754467027f66780a.jpg" align="right" alt="Cassandra"></a> <br>  In this topic, I would like to talk about how <a href="http://cassandra.apache.org/">Cassandra</a> ( <a href="http://cassandra.apache.org/">cassandra</a> ) is <a href="http://cassandra.apache.org/">organized</a> ‚Äî a decentralized, fault-tolerant, and reliable key-value database.  The storage itself will take care of the problems of <a href="http://en.wikipedia.org/wiki/Single_point_of_failure">single point of failure</a> , server failure and data distribution between <a href="http://www.datastax.com/docs/1.1/initialize/index">cluster nodes</a> .  Moreover, both in the case of servers in a single <a href="http://en.wikipedia.org/wiki/Data_center">data center</a> ( <a href="http://en.wikipedia.org/wiki/Data_center">data center</a> ), and in a configuration with many data centers separated by distances and, accordingly, network delays.  Reliability is understood as <i>total</i> <a href="http://en.wikipedia.org/wiki/Eventual_consistency">data consistency</a> ( <a href="http://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a> ) of data with the ability to set the <i>level of data</i> <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">consistency</a> ( <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">tune consistency</a> ) of each request. <br><br>  <i><a href="http://en.wikipedia.org/wiki/NoSQL">NoSQL</a></i> databases generally require a greater understanding of their internal structure than <i><a href="http://en.wikipedia.org/wiki/SQL_database">SQL</a></i> .  This article will describe the basic structure, and in the following articles you can consider: CQL and programming interface;  engineering and optimization techniques;  features of clusters located in many data centers. <br><a name="habracut"></a><br><h1>  Data model </h1><br>  In the terminology of cassandra, the application works with the <a href="http://www.datastax.com/docs/1.1/ddl/keyspaces">keyspace</a> , which corresponds to the concept <i>of a</i> <a href="http://en.wikipedia.org/wiki/Database_schema">database schema</a> in the relational model.  In this key space there can be several <i>column families</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/column_family">column family</a> ), which corresponds to the concept of a relational table.  In turn, column families contain <i>columns</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/column_family">column</a> ), which are combined with a <i>key</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/about-data-model">row key</a> ) in a <i>record</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/about-data-model">row</a> ).  A column consists of three parts: a <i>name</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/column_family">column name</a> ), a <a href="http://www.datastax.com/docs/1.1/ddl/column_family">timestamp,</a> and a <a href="http://www.datastax.com/docs/1.1/ddl/column_family">value</a> .  The columns within the record are ordered.  Unlike a relational database, there are no restrictions on whether the records (and in terms of the database, these are lines) contain columns with the same names as in other records ‚Äî no.  Column families can be of several types, but in this article we will omit this detail.  Also in the latest versions of Cassandra, it became possible to perform <i>queries for defining and modifying data</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/index">DDL</a> , <a href="http://www.datastax.com/docs/1.1/dml/index">DML</a> ) using the <i><a href="http://www.datastax.com/docs/1.1/dml/using_cql">CQL</a></i> language, as well as creating <i>secondary indices</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/indexes">secondary indices</a> ). <br><img src="https://habrastorage.org/getpro/habr/post_images/e4f/66d/6dc/e4f66d6dcd7edd05873d71665d281c2e.png" alt="Data model"><br><br>  The specific value stored in the cassandra is identified by: <br><ul><li>  key space is a binding to an application (subject area).  Allows you to place data from different applications on one cluster; <br></li><li>  column family is a binding to the query; <br></li><li>  the key is binding to the cluster node.  The key depends on which nodes will get saved columns; <br></li><li>  column name is a binding to an attribute in an entry.  Allows you to store multiple values ‚Äã‚Äãin one record. <br></li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each value is associated with a time stamp ‚Äî a user-defined number that is used to resolve conflicts during recording: the larger the number, the newer the column is considered, and it compares the old columns when comparing. <br><br>  By data type: key space and column family are strings (names);  The time stamp is a 64-bit number;  and the key, column name, and column value are an array of bytes.  Also, cassandra has the concept <i>of data types</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/column_family">data type</a> ).  These types can be optionally specified by the developer (optional) when creating a column family.  For column names, this is called a <i>comparator</i> , for values ‚Äã‚Äãand keys, a <i>validator</i> .  The first determines which byte values ‚Äã‚Äãare valid for column names and how to arrange them.  The second is which byte values ‚Äã‚Äãare valid for the values ‚Äã‚Äãof columns and keys.  If these data types are not specified, the cassandra stores the values ‚Äã‚Äãand compares them as <i>byte strings</i> ( <a href="http://www.datastax.com/docs/1.1/ddl/column_family">BytesType</a> ) since, in fact, they are stored internally. <br><br>  Data types are as follows: <br><ul><li>  BytesType: any byte strings (without validation) <br></li><li>  AsciiType: ASCII string <br></li><li>  UTF8Type: UTF-8 string <br></li><li>  IntegerType: a number with an arbitrary size <br></li><li>  Int32Type: 4-byte number <br></li><li>  LongType: 8-byte number <br></li><li>  UUIDType: <i><a href="http://en.wikipedia.org/wiki/UUID">UUID</a></i> of the 1st or 4th type <br></li><li>  TimeUUIDType: Type 1 UUID <br></li><li>  DateType: 8-byte timestamp value <br></li><li>  BooleanType: two values: true = 1 or false = 0 <br></li><li>  FloatType: 4-byte floating point number <br></li><li>  DoubleType: 8-byte floating point number <br></li><li>  DecimalType: a number with an arbitrary size and a floating point <br></li><li>  CounterColumnType: 8-byte counter <br></li></ul><br><br>  In cassandra, all data writing operations are always rewriting operations, that is, if a column with the same key and name already exists in the column family, and the time stamp is greater than the one that is saved, the value is overwritten.  The recorded values ‚Äã‚Äãnever change, they just come in newer columns with new values. <br><br>  Writing to a cassandra works at a faster rate than reading.  This changes the approach that is used in the design.  If we consider cassandra from the point of view of designing a data model, then it is easier to imagine the column family not as a table, but as a <i>materialized view</i> ( <a href="http://en.wikipedia.org/wiki/Materialized_view">materialized view</a> ) - a structure that represents data of some complex query, but stores it on disk.  Instead of trying to somehow compile the data using queries, it is better to try to keep everything in the finite family that may be needed for this query.  That is, it is necessary to approach not from the side of relations between entities or relations between objects, but from the side of requests: which fields are required to choose;  in what order the records should go;  what data related to the main ones should be requested together - all this should already be stored in the column family.  The number of columns in the record is theoretically limited to 2 billion.  This is a brief digression, and in more detail - in the article on design and optimization techniques.  And now let's delve into the process of storing data in Cassandra and reading them. <br><br><h1>  Data distribution <br></h1><br>  Consider how data is distributed, depending on the key across <a href="http://www.datastax.com/docs/1.1/initialize/index">cluster nodes</a> ( <a href="http://www.datastax.com/docs/1.1/initialize/index">cluster nodes</a> ).  Cassandra allows you to set a data distribution strategy.  The first such strategy distributes data depending on the md5 key value - a <a href="http://www.datastax.com/docs/1.1/cluster_architecture/partitioning">random partitioner</a> .  The second takes into account the bit representation of the key itself - a <a href="http://www.datastax.com/docs/1.1/cluster_architecture/partitioning">byte-ordered partitioner</a> .  The first strategy, for the most part, provides more benefits, since you do not need to worry about evenly distributing data between servers and similar problems.  The second strategy is used in rare cases, for example, if <i>range queries are</i> necessary.  It is important to note that the choice of this strategy is made before the cluster is created and, in fact, cannot be changed without a full data reload. <br><br>  Cassandra uses a technique known as <i>consistent hashing</i> to distribute the data.  This approach allows you to distribute data between nodes and make it so that when adding and deleting a new node, the amount of data being sent was small.  For this, each node is assigned a <i>label</i> ( <a href="http://wiki.apache.org/cassandra/Operations">token</a> ), which breaks into pieces the set of all md5 key values.  Since in most cases the RandomPartitioner is used, consider it.  As I said, the RandomPartitioner calculates a 128-bit md5 for each key.  To determine in which nodes the data will be stored, all the labels of nodes from the smallest to the largest are sorted, and when the value of the label becomes greater than the md5 value of the key, then this node along with some number of subsequent nodes (in the order of labels) is selected for saving.  The total number of nodes selected must be equal <i>to the</i> <a href="http://www.datastax.com/docs/1.1/cluster_architecture/replication">replication factor</a> .  The replication level is set for each key space and allows you to adjust <a href="http://en.wikipedia.org/wiki/Data_redundancy">data redundancy</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f96/58a/dde/f9658addea7b79060fa9e1e9b2dd04d6.png" alt="Data replication"><br><br>  Before you add a node to the cluster, you must set a label for it.  From what percentage of keys covers the gap between this label and the next, depends on how much data will be stored on the site.  The entire label set for a cluster is called <i>a</i> <a href="http://wiki.apache.org/cassandra/Operations">ring</a> . <br><br>  Here is an illustration of a cluster ring consisting of 6 nodes with uniformly distributed labels using the <i><a href="http://www.datastax.com/docs/1.1/references/nodetool">nodetool</a></i> integrated utility. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79b/665/7c0/79b6657c0e3860194574b03e44eb6ac2.png" alt="nodetool ring"><br><br><h1>  Data consistency </h1><br>  Cassandra cluster nodes are equal, and customers can connect to any of them, both for writing and reading.  Requests go through a coordination stage, during which, having ascertained on which nodes the data should be located, the server sends requests to these nodes.  We will call the node that coordinates - the <i>coordinator</i> ( <a href="http://www.datastax.com/docs/1.1/cluster_architecture/about_client_requests">coordinator</a> ), and the nodes that are selected to save the record with this key - <a href="http://www.datastax.com/docs/1.1/cluster_architecture/about_client_requests">replica nodes</a> ( <a href="http://www.datastax.com/docs/1.1/cluster_architecture/about_client_requests">replica nodes</a> ).  Physically, the coordinator can be one of the replica nodes - it depends only on the key, the marker and tags. <br><br>  For each request, both for reading and writing, there is an opportunity to set the level of data consistency. <br><br>  For the record, this level will affect the number of replica nodes from which confirmation of a successful completion of the operation (the data has been recorded) will be expected before returning control to the user.  There are levels of consistency for recording: <br><ul><li>  ONE - the coordinator sends requests to all replica nodes, but, after waiting for confirmation from the first node, returns control to the user; <br></li><li>  TWO is the same, but the coordinator waits for confirmation from the first two nodes before returning control; <br></li><li>  THREE - similar, but the coordinator waits for confirmation from the first three nodes before returning control; <br></li><li>  QUORUM - a quorum is collected: the coordinator waits for confirmation of the record from more than half of the replica nodes, namely round (N / 2) + 1, where N is the level of replication; <br></li><li>  LOCAL_QUORUM - the coordinator waits for confirmation from more than half of the replica nodes in the same data center where the coordinator is located (for each request, potentially its own).  Allows you to get rid of the delays associated with sending data to other data centers.  Multi-data center issues are discussed in this article in passing; <br></li><li>  EACH_QUORUM ‚Äî The coorinator waits for confirmation from more than half of the replica nodes in each data center independently; <br></li><li>  ALL - the coordinator waits for confirmation from all replica nodes; <br></li><li>  ANY - allows you to write data, even if all nodes replicas do not respond.  The coordinator waits for either the first response from one of the replica nodes, or when the data is saved using the <a href="http://www.datastax.com/docs/1.1/dml/about_writes">hinted handoff</a> at the coordinator. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/036/140/710/0361407102434435059de5a02e0be3e1.png" alt="Writing to Cassandra"><br><br>  For reading, the level of consistency will affect the number of replica nodes from which to read.  There are levels of consistency to read: <br><ul><li>  ONE - the coordinator sends requests to the nearest node-replica.  The rest of the replicas are also read for the purpose of <i>reading with a repair</i> ( <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">read repair</a> ) with a probability set in the cassandra configuration; <br></li><li>  TWO is the same, but the coordinator sends requests to the two closest nodes.  Selects the value that has a large time stamp; <br></li><li>  THREE - similar to the previous version, but with three nodes; <br></li><li>  QUORUM - a quorum is collected, that is, the coordinator sends requests to more than half of the replica nodes, namely round (N / 2) + 1, where N is the level of replication; <br></li><li>  LOCAL_QUORUM - a quorum is collected in the data center in which coordination takes place, and the data is returned with the last time stamp; <br></li><li>  EACH_QUORUM ‚Äî The coordinator returns data after a quorum meeting at each data center; <br></li><li>  ALL - the coordinator returns data after reading all replica nodes. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/877/74a/72f/87774a72fa7f1c94424dcc6a6e339c8c.png" alt="Reading from Cassandra"><br><br>  Thus, it is possible to adjust the time delays of read, write operations and <i>adjust the consistency</i> ( <a href="http://www.datastax.com/dev/blog/your-ideal-performance-consistency-tradeoff">tune consistency</a> ), as well as the <i>availability</i> ( <a href="http://whatis.techtarget.com/definition/Reliability-Availability-and-Serviceability-RAS">availability</a> ) of each type of operation.  In fact, availability is directly dependent on the level of consistency of read and write operations, since it determines how many replica nodes can fail, and these operations will still be confirmed. <br><br>  If the number of nodes from which confirmation of a record comes, in total with the number of nodes from which reading occurs, is greater than the replication level, then we have a guarantee that after writing a new value will always be read, and this is called <i>strict consistency</i> ( <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">strong consistency</a> ).  In the absence of strict consistency, there is the possibility that the read operation will return outdated data. <br><br>  In any case, the value eventually spreads between the replicas, but after the coordination wait ends.  This distribution is called <a href="http://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a> .  If not all replica nodes will be available during recording, then sooner or later, recovery tools, such as reading with a fix and anti-entropy node repair, will be used.  More on this later. <br><br>  Thus, with the read and write QUORUM consistency level, strict consistency will always be maintained, and there will be some balance between the delay in the read and write operations.  When writing ALL, and reading ONE there will be strict consistency, and reading operations will be performed faster and will have greater accessibility, that is, the number of failed nodes, at which reading will still be performed, may be greater than with QUORUM.  For write operations, all replica work nodes will be required.  When writing ONE, reading ALL, there will also be strict consistency, and write operations will be faster and write accessibility will be great, it will be enough just to confirm that the write operation went on at least one of the servers, and read more slowly and require all replica nodes .  If the application does not have a requirement for strict consistency, then it becomes possible to speed up both read and write operations, as well as improve accessibility by setting lower levels of consistency. <br><br><h1>  Data recovery </h1><br>  Cassandra supports three data recovery mechanisms: <br><ul><li>  <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">read repair</a> ‚Äî during reading, data is requested from all replicas and compared after coordination is complete.  The column that has the latest time stamp will be distributed to nodes where tags are obsolete. <br></li><li>  <i>directional send</i> ( <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">hinted handoff</a> ) - allows you to save information about the write operation on the coordinator in the event that the write to any of the nodes failed.  Later, when it will be possible, the recording will be repeated.  Allows you to quickly perform data recovery in the event of a short-term absence of a node in the cluster.  In addition, at the level of consistency, ANY allows you to achieve <i>full write access</i> ( <a href="http://www.datastax.com/docs/1.1/dml/about_writes">absolute write availability</a> ), when even all replica nodes are not available, the write operation is confirmed, and the data is stored on the coordinator node. <br></li><li>  <i>anti-</i> <a href="http://www.datastax.com/docs/1.1/dml/data_consistency">entropy node repair</a> is a kind of recovery process for all replicas that must be started regularly manually using the ‚Äúnodetool repair‚Äù command and allows you to maintain the replica number of all data that may not have been restored by the first two methods, required level of replication. <br></li></ul><br><br><h1>  Burn to disc </h1><br>  When data comes after coordination directly to the node for recording, they fall into two data structures: a <i>table in memory</i> ( <a href="https://git-wip-us.apache.org/repos/asf%3Fp%3Dcassandra.git%3Ba%3Dblob_plain%3Bf%3Dsrc/java/org/apache/cassandra/db/Memtable.java%3Bhb%3Drefs/heads/cassandra-1.1">memtable</a> ) and a <i>log of</i> <a href="https://git-wip-us.apache.org/repos/asf%3Fp%3Dcassandra.git%3Ba%3Dblob_plain%3Bf%3Dsrc/java/org/apache/cassandra/db/commitlog/CommitLog.java%3Bhb%3Drefs/heads/cassandra-1.1">commit</a> ( <a href="https://git-wip-us.apache.org/repos/asf%3Fp%3Dcassandra.git%3Ba%3Dblob_plain%3Bf%3Dsrc/java/org/apache/cassandra/db/commitlog/CommitLog.java%3Bhb%3Drefs/heads/cassandra-1.1">commit log</a> ).  A table in memory exists for each column family and allows you to memorize the value instantly.  Technically, this is a <i>hash table</i> with <i>simultaneous access</i> ( <a href="http://en.wikipedia.org/wiki/Concurrent_access">concurrent access</a> ) based on a data structure called <i>‚Äú</i> <a href="http://en.wikipedia.org/wiki/Skip_list">skip list</a> ‚Äù.  The pinning log is one for the entire key space and is stored on disk.  A log is a sequence of modification operations.  It also breaks into pieces when it reaches a certain size. <br><br>  Such an organization makes it possible to make the recording speed limited to the speed of sequential writing to the hard disk and at the same time guarantee <a href="http://en.wikipedia.org/wiki/ACID">data durability</a> ( <a href="http://en.wikipedia.org/wiki/ACID">data durability</a> ).  The pinning log in case of an emergency stop of the node is read at the start of the cassandra service and restores all tables in memory.  It turns out that the speed rests on the sequential write to the disk, and in modern hard drives it is about 100MB / s.  For this reason, it is advisable to put a fixing journal on a separate disk medium. <br><br>  It is clear that sooner or later the memory can be filled.  Therefore, the table in memory must also be saved to disk.  To determine the moment of saving, there is a <i>limit on the size of the occupied tables in memory</i> ( <a href="http://www.datastax.com/docs/1.1/configuration/node_configuration">memtable_total_spacein_mb</a> ), by default it is the maximum size of the <i>Java heap</i> ( <a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine_heap">Java heapspace</a> ).  When filling tables with more than this limit in memory, cassandra creates a new table and writes the old table in memory to disk as a <i>saved table</i> ( <a href="https://git-wip-us.apache.org/repos/asf%3Fp%3Dcassandra.git%3Ba%3Dblob_plain%3Bf%3Dsrc/java/org/apache/cassandra/io/sstable/SSTable.java%3Bh%3D9a29066b8af7334be8fa9325fa480cee632abca0%3Bhb%3Drefs/heads/cassandra-1.1">SSTable</a> ).  The stored table after creation is never <i>modified again</i> ( <a href="http://en.wikipedia.org/wiki/Immutable">is immutable</a> ).  When saving to disk occurs, the parts of the log are marked as free, thus freeing up the disk space occupied by the journal.  It is necessary to take into account that the journal has an interlaced structure from data of different column families in the key space, and some parts may not be released, since some areas will correspond to other data still in the tables in memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eda/06e/888/eda06e88899f7ac7f4098e92943b5822.png" alt="Save value to disk"><br><br>  As a result, each column family corresponds to one table in memory and a number of saved tables.  Now that the node is processing the read request, it needs to query all these structures and select the most recent value for the timestamp.  To speed up this process, there are three mechanisms: <i>bloom filtering</i> ( <a href="http://en.wikipedia.org/wiki/Bloom_filter">bloom filter</a> ), <a href="http://www.datastax.com/docs/1.1/operations/tuning">key cache</a> ( <a href="http://www.datastax.com/docs/1.1/operations/tuning">key cache</a> ) and <i>write cache</i> ( <a href="http://www.datastax.com/docs/1.1/operations/tuning">record cache</a> ): <br><ul><li>  The bloom filter is a data structure that takes up little space and allows you to answer the question: is the element contained, and in our case is it a key, in a set or not.  Moreover, if the answer is ‚Äúno‚Äù, then it is 100%, and if the answer is ‚Äúyes‚Äù, then this is probably a false-positive answer.  This allows you to reduce the number of reads from the saved tables; <br></li><li>  the key cache stores a position on the write disk for each key, thus reducing the number <i>of positioning operations</i> ( <a href="http://en.wikipedia.org/wiki/Seek_time">seek operations</a> ) while searching the stored table; <br></li><li>  write cache keeps the entire record, allowing you to completely get rid of disk read operations. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ea/9ce/878/9ea9ce87899424f5c331663c7920470b.png" alt="Read from disk"><br><br><h1>  Compaction </h1><br>  At a certain point in time, the data in the column family will be overwritten ‚Äî columns will come that will have the same name and key.  That is, a situation will arise when the older and newer stored table will contain old and new data.  In order to guarantee integrity, Cassandra must read all these stored tables and select data with the latest timestamp.  It turns out that the number of hard disk positioning operations when reading is proportional to the number of stored tables.  Therefore, in order to free up the overwritten data and reduce the number of saved tables, there <i>is a compaction process</i> .  It reads several stored tables in succession and writes a new saved table, which combines data by timestamps.  When a table is fully recorded and put into use, cassandra can release source tables (the tables that formed it).  Thus, if the tables contain overwritten data, then this redundancy is eliminated.  It is clear that during such an operation the amount of redundancy increases - a new saved table exists on the disk along with the source tables, which means that the amount of disk space must always be such that it can be compacted. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b10/f00/4b2/b10f004b2f67bf67e179f6ead1065070.png" alt="Compaction"><br><br>  Cassandra allows you to choose one of two compaction strategies: <br><ul><li>  strategy of <i>compacting saved tables of</i> <a href="http://www.datastax.com/docs/1.1/operations/tuning">size-tiered compaction</a> ‚Äî this strategy compacts the two tables selected in a certain way.  It is applied automatically as a <i>background compaction</i> ( <a href="http://www.datastax.com/docs/1.1/operations/tuning">minor compaction</a> ) and in manual mode, for <i>full compaction</i> ( <a href="http://www.datastax.com/docs/1.1/operations/tuning">major compaction</a> ).  Allows the situation of finding the key in many tables and, accordingly, requires to perform a search operation for each such table. <br></li><li>  strategy <i>compaction of saved tables with levels</i> ( <a href="http://www.datastax.com/dev/blog/when-to-use-leveled-compaction">leveled compaction</a> ) - compresses saved tables that are initially created small - 5 MB, grouping them into levels.  Each level is 10 times greater than the previous one.  Moreover, there are such guarantees: 90% of read requests will occur to a single saved table, and only 10% of the disk space will be used for outdated data.  In this case, only 10-fold size of the table, that is, 50 MB, is sufficient to perform compression for a temporary table.  More in this <a href="http://www.datastax.com/dev/blog/leveled-compaction-in-apache-cassandra">article</a> <br></li></ul><br><br><h1>  Delete operations </h1><br>  From the point of view of the internal device, the operation of deleting columns is the operation of writing a special value - a <i>wiping value</i> ( <a href="http://www.datastax.com/docs/1.1/dml/about_writes">tombstone</a> ).  When such a value is obtained as a result of reading, it is skipped, as if such a value never existed.  As a result of compaction, such values ‚Äã‚Äãare gradually crowding out obsolete real values ‚Äã‚Äãand, possibly, disappear altogether.  If there are columns with real data with even newer time stamps, then they will grind, and in the end, these overwrite values. <br><br><h1>  Transactional </h1><br>  Cassandra supports transactionalization at the level of one record, that is, for a set of columns with one key.  Here are four ACID requirements: <br><ul><li>  <i>atomicity</i> - all columns in one record in one operation will be either recorded or not; <br></li><li>  <a href="http://en.wikipedia.org/wiki/ACID">consistency</a> - as already mentioned above, it is possible to use requests with strict consistency instead of availability, and thereby fulfill this requirement; <br></li><li>  <i>isolation</i> ( <a href="http://en.wikipedia.org/wiki/ACID">isolation</a> ) - starting with cassandra version 1.1, there is support for isolation, when, while recording the columns of one record, another user who reads the same record will see either the old version of the record or, after the end of the operation, the new version, not part of columns of one and part of the second; <br></li><li>  <i>durability is</i> ensured by the presence of a binding log that will be reproduced and will restore the node to the desired state in case of any failure. <br></li></ul><br><br><h1>  Afterword </h1><br>  So, we looked at how the basic operations are arranged - reading and writing values ‚Äã‚Äãto the cassandra. <br><br>  In addition, in my opinion, important references: <br><ul><li>  Page at apache.org <a href="http://cassandra.apache.org/">cassandra.apache.org</a> <br></li><li>  Documentation on datastax.com <a href="http://www.datastax.com/docs/1.1/index">www.datastax.com/docs/1.1/index#apache-cassandra-1-1-documentation</a> <br></li><li>  About BigTable <a href="http://research.google.com/archive/bigtable.html">research.google.com/archive/bigtable.html</a> <br></li><li>  About Amazon Dynamo <a href="http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html">www.allthingsdistributed.com/2007/10/amazons_dynamo.html</a> <br></li><li>  Just one of the blogs about the data model <a href="http://maxgrinev.com/2010/07/09/a-quick-introduction-to-the-cassandra-data-model/">maxgrinev.com/2010/07/09/a-quick-introduction-to-the-cassandra-data-model</a> <br></li></ul><br><br>  Please: comment on the spelling and ideas for improving the article expressed in a personal message. </div><p>Source: <a href="https://habr.com/ru/post/155115/">https://habr.com/ru/post/155115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155105/index.html">Restore base 1C using HEX editor</a></li>
<li><a href="../155107/index.html">JQuery tutorial for beginners</a></li>
<li><a href="../155109/index.html">Page Object Model + Webdriver. An example of implementation on a single test</a></li>
<li><a href="../155111/index.html">Extending Asterisk with PHP</a></li>
<li><a href="../155113/index.html">Metropolis or Windows 8 through the eyes of Delphi programmers</a></li>
<li><a href="../155119/index.html">How to search and find the best employees in the mobile mode?</a></li>
<li><a href="../155121/index.html">Virtual walk through Google data centers</a></li>
<li><a href="../155125/index.html">We build a universal, USB machine charging (attempt the number of times)</a></li>
<li><a href="../155127/index.html">Form Designer in Yii</a></li>
<li><a href="../155129/index.html">Deploying RemoteFX on Windows Server 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>