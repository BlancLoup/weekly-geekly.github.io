<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cross a hedgehog (Marathon) with a snake (Spring Cloud). Episode 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When switching to distributed systems with a large number of service instances, full-length problems arise with their service discovery and load balan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cross a hedgehog (Marathon) with a snake (Spring Cloud). Episode 1</h1><div class="post__text post__text-html js-mediator-article"><p>  When switching to distributed systems with a large number of service instances, full-length problems arise with their <strong>service discovery</strong> and <strong>load balancing</strong> between them.  As a rule, specialized tools such as <a href="https://www.consul.io/"><strong>Consul</strong></a> , <a href="https://github.com/Netflix/eureka"><strong>Eureka</strong></a> or good old <a href="https://zookeeper.apache.org/"><strong>Zookeeper</strong></a> are used to solve them, in combination with <strong>Nginx</strong> , <strong>HAProxy</strong> and some bridge between them (see <a href="https://github.com/gliderlabs/registrator"><strong>registrator</strong></a> ). </p><br><p>  The main problem in this approach is a large number of integrations, and, as a result, there are points where something can go wrong.  Indeed, in addition to the above solutions, a local small <strong>PaaS</strong> (for example, <a href="https://mesosphere.github.io/marathon/"><strong>Mesosphere Marathon</strong></a> or <strong>Kubernetes</strong> ) will probably be used.  The latter, by the way, already store the necessary configuration about the environment (after all, the whole deployment goes through them).  And the question arises, can we abandon the specialized tools for <strong>service discovery</strong> and reuse the same <strong>Marathon</strong> for this task? </p><br><p>  The short answer is we can.  If you are interested in how - read on. </p><a name="habracut"></a><br><h2 id="dispoziciya">  Disposition </h2><br><p>  So, what we have in stock: </p><br><ul><li>  <strong>Apache Mesos</strong> and its loyal <strong>Marathon</strong> framework as a service orchestration system </li><li>  Services that are written using the <strong>Spring Boot</strong> framework and its <strong>Spring Cloud</strong> extensions </li></ul><br><p>  <strong>Sugar-</strong> free <strong>mesos</strong> (read without frameworks) is a cluster resource management system that can be expanded with frameworks.  Frameworks serve different purposes.  Some are able to run a wide range of short-term tasks ( <strong>Chronos</strong> ), others long-lived ( <strong>Marathon</strong> ).  And some are sharpened for specific products, such as <strong>Hadoop</strong> or <strong>Jenkins</strong> . </p><br><p>  <strong>Mesosphere Marathon</strong> is the very framework that can manage the start, stop and overall planning of long-lived tasks, which include services that process client, and not so, requests for a long period of time. </p><br><p>  <strong><a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a></strong> is also a framework, but for the development of these same services, which implement both the basic patterns for their work in distributed systems, and the specific integration of these patterns with existing solutions on the market (for example, with the same <strong>Consul</strong> ). </p><br><p>  As part of the <strong>Spring Cloud</strong> , there are actually two implementations for solving the problem of discovering services. </p><br><p>  The first, using <a href="https://github.com/Netflix/zuul"><strong>Netflix Zuul</strong></a> , can be attributed to the <a href="http://microservices.io/patterns/server-side-discovery.html">Server-Side Service Discovery</a> pattern.  The essence of the template is that we make a number of routers that know the current location and various meta-information about the instances of services, and provide constant http-resources through which proxying requests to them go.  If we abstract from Spring, then the classic router is <strong>nginx</strong> , provided it is dynamically configured. </p><br><p><img src="https://habrastorage.org/files/52f/fc8/8c3/52ffc88c39f0441a89c5723c4cd598ae.png" alt="Server-Side Service Discovery pattern"></p><br><p>  The second implementation belongs to the class <a href="http://microservices.io/patterns/client-side-discovery.html">Client-Side Service Discovery</a> .  Its main difference from the previous one is the absence of a router, and therefore an intermediate link and an extra point of failure, as a class.  Instead, a smart client balancer is used as a router, which also knows everything you need to know about the instances of the services it calls.  In <strong>Spring Cloud</strong> , <a href="https://github.com/Netflix/ribbon"><strong>Netflix Ribbon is</strong></a> used as such balancer. <br><img src="https://habrastorage.org/files/a53/737/aab/a53737aab8fb49878f1c1a383de6ec86.png" alt="Client-Side Service Discovery pattern"></p><br><p>  In this series of articles, we will dwell on the client implementation of the template, although we'll also talk about the server one. </p><br><h2 id="enablediscoveryclient">  @EnableDiscoveryClient </h2><br><p>  In Spring, almost everything can be done by working on a class / method / variable one or two dozen annotations and writing a little configuration in the <strong>yaml</strong> file.  Well, ok, let's say that not everything, but a lot. </p><br><p>  The manual teaches us that by adding the <strong>@EnableDiscoveryClient</strong> magic annotation on our application, we will have to work (after a couple of dependencies and settings, but more on that later) the discovery of services.  At least locally inside our application.  This can be done very simply, even it is not necessary to strain: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableDiscoveryClient</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class, args); } }</code> </pre> <br><p>  After this begins the magic in which there is no magic.  Spring seeing this annotation loads all configurations that are listed in <strong>META-INF / spring.factories</strong> as downloadable for <strong>EnableDiscoveryClient</strong> : </p><br><pre> <code class="hljs axapta">org.springframework.cloud.<span class="hljs-keyword"><span class="hljs-keyword">client</span></span>.discovery.EnableDiscoveryClient=\ org.springframework.cloud.xxx.discovery.XXXDiscoveryClientConfiguration</code> </pre> <br><p>  From where and what configurations can be downloaded at all?  To answer this question, it must be said that <strong>Spring Cloud itself</strong> consists of the basic part, which has the necessary interfaces and the general logic for implementing various patterns, and connectors, which are supplied in the form of <strong>starters</strong> , and which have specific implementation for specific solutions.  Schematically, we can depict it like this: <img src="https://habrastorage.org/files/8b0/a3b/f8d/8b0a3bf8d1e24f5a8d5f8c5d64b9b4b7.png" alt="spring-cloud-scheme"><br>  For example, if we connect a starter for <strong>Netflix Eureka</strong> , then we will have one factory configuration in the <strong>classpath</strong> .  If the starter for <strong>Consul</strong> , then another. </p><br><p>  The ambush here, however, is that the abstract itself, with industrial, not hellworld development, is slightly less than completely useless, since all the profit is in the area of ‚Äã‚Äãprescribing the correct settings in <strong>bootstap.yml</strong> .  And for each connector they are, as you probably guessed, their own. </p><br><p>  Why it is so easy to understand.  <strong>Eureka</strong> , <strong>Consul</strong> and <strong>Marathon</strong> are arranged completely differently.  They need to connect in different ways.  They have a different API and features that are specific to a particular solution.  It is impossible to make a universal config, and in general there is no need. </p><br><p>  But back to the configuration that is pulled using <strong>@EnableDiscoveryClient</strong> .  And the first thing that comes to mind, and what is quickly found through a search in your favorite IDE, is the implementation of the <strong>DiscoverClient</strong> interface.  The most important (at least at first glance) interface looks like this: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiscoveryClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">description</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServiceInstance </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocalServiceInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;ServiceInstance&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String serviceId)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  In principle, everything is pretty obvious.  We can get a description for <strong>HealthIndicator</strong> .  We can get ourselves.  We can get all instances for some service id.  And finally, we can get a list of all known services (more precisely, their identifiers). </p><br><p>  It's time to implement the interface in order to receive data from <strong>Marathon</strong> . </p><br><h2 id="pervaya-krov">  First blood </h2><br><p>  How to get data?  This is the first question we need to solve.  And it is not that difficult. </p><br><p>  First, it has a powerful <a href="https://mesosphere.github.io/marathon/api-console/index.html"><strong>API</strong></a> .  Secondly, there is already ready for <strong>Java</strong> <a href="https://github.com/mesosphere/marathon-client"><strong>SDK</strong></a> . </p><br><p>  We take legs in hands and we realize receipt of the list of all services: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client.getApps() .getApps() <span class="hljs-comment"><span class="hljs-comment">//,    .parallelStream() .map(App::getId) //  .map(ServiceIdConverter::convertToServiceId) //    .collect(Collectors.toList()); } catch (MarathonException e) { return Collections.emptyList(); } }</span></span></code> </pre> <br><p>  No magic except for <code>ServiceIdConverter::convertToServiceId</code> .  What is this strange converter you ask.  And here I must say about one feature of the representation of service identifiers in <strong>Marathon</strong> .  In general, they follow the following pattern: </p><br><pre> <code class="hljs pgsql">/<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>/<span class="hljs-type"><span class="hljs-type">path</span></span>/app</code> </pre> <br><p>  but the <code>/</code> symbol cannot be used to build a virtual host.  And thus, some parts of <strong>Spring Cloud</strong> that use the service ID as a virtual host will not work.  Therefore, instead of <code>/</code> we will use another separator that is allowed to be present in the host name, namely, a dot.  That is why we are forced to get a match for <code>/group/path/app</code> on <code>group.path.app</code> .  What the converter actually does. </p><br><p>  Getting all service instances is somewhat more complicated, but also no rocket science: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;ServiceInstance&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String serviceId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client.getAppTasks(ServiceIdConverter.convertToMarathonId(serviceId)) .getTasks() .parallelStream() .filter(task -&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> == task.getHealthCheckResults() || <span class="hljs-comment"><span class="hljs-comment">//health- ,    task.getHealthCheckResults() .stream() .allMatch(HealthCheckResult::isAlive) //    ) .map(task -&gt; new DefaultServiceInstance( ServiceIdConverter.convertToServiceId(task.getAppId()), task.getHost(), task.getPorts().stream().findFirst().orElse(0), //magi zero false )) .collect(Collectors.toList()); } catch (MarathonException e) { log.error(e.getMessage(), e); return Collections.emptyList(); } }</span></span></code> </pre> <br><p>  The main thing we need to check is that for the service all <strong>health checks</strong> <code>HealthCheckResult::isAlive</code> : <code>HealthCheckResult::isAlive</code> , because our task is to work only with those who are alive.  The mechanism of <strong>health checks is</strong> provided by <strong>Marathon</strong> itself, which makes it possible to set them up and itself monitors the health of the services entrusted to it, distributing this information free of charge through the API. </p><br><p>  In addition, we need to remember again to convert the identifier into the correct representation and select only one, first, port: <code>task.getPorts().stream().findFirst().orElse(0)</code> . </p><br><p>  So so, you say.  And what to do if the application has several ports?  Unfortunately, our choice is small.  On the one hand, we need to return an object that implements the <strong>ServiceInstance</strong> interface, which has a <code>getPort</code> method <code>getPort</code> , of course, can return only one port.  And on the other hand, we really do not know which port to take from the list.  <strong>Marathon</strong> does not give us any information about this.  Therefore, take the one that is listed first.  Perhaps lucky. </p><br><p>  You can try to solve this problem as <strong>registrator</strong> solves it when registering services in the same <strong>Consul</strong> .  This is to take into account the port of the service in its identifier.  Then the service identifier will be approximately like this: <code>group.path.app.8080</code> in case there are more ports than one. </p><br><p>  A little distracted.  It's time to add the new implementation as a bin: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMarathonEnabled</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(value = <span class="hljs-string"><span class="hljs-string">"spring.cloud.marathon.discovery.enabled"</span></span>, matchIfMissing = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MarathonDiscoveryClientAutoConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Marathon marathonClient; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MarathonDiscoveryProperties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">marathonDiscoveryProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MarathonDiscoveryProperties(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MarathonDiscoveryClient </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">marathonDiscoveryClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MarathonDiscoveryProperties discoveryProperties)</span></span></span><span class="hljs-function"> </span></span>{ MarathonDiscoveryClient discoveryClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MarathonDiscoveryClient(marathonClient, marathonDiscoveryProperties()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discoveryClient; } }</code> </pre> <br><p>  What is important here?  First, we use <strong>conditional</strong> annotations: <code>@ConditionalOnMarathonEnabled</code> and <code>@ConditionalOnProperty</code> .  That is, if the functionality is disabled in the settings, for example, through the <code>spring.cloud.marathon.discovery.enabled</code> configuration, the configuration will not be loaded. </p><br><p>  Secondly, the <code>@ConditionalOnMissingBean</code> magic annotation stands above our client, which makes it possible in a particular application to redefine a bin in the way that a user needs. </p><br><p>  We have to do just a little.  Configure the client for <strong>Marathon</strong> .  A naive but working implementation of the configuration looks like this: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">spring</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">cloud</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">marathon</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">scheme</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">http</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#url</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">scheme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">marathon</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#marathon</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">host</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">port</span></span>: 8080 <span class="hljs-selector-id"><span class="hljs-selector-id">#marathon</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">port</span></span></code> </pre> <br><p>  For this we need a class with its settings: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties</span></span>(<span class="hljs-string"><span class="hljs-string">"spring.cloud.marathon"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-comment"><span class="hljs-comment">//lombok is here public class MarathonProperties { @NotNull private String scheme = "http"; @NotNull private String host = "localhost"; @NotNull private int port = 8080; private String endpoint = null; public String getEndpoint() { if (null != endpoint) { return endpoint; } return this.getScheme() + "://" + this.getHost() + ":" + this.getPort(); } }</span></span></code> </pre> <br><p>  and very similar to the previous configuration: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMarathonEnabled</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MarathonAutoConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MarathonProperties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">marathonProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MarathonProperties(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Marathon </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">marathonClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MarathonProperties properties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MarathonClient.getInstance(properties.getEndpoint()); } }</code> </pre> <br><p>  After this, we can happily go to our application to customize the <code>DiscoveryClient</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DiscoveryClient discoveryClient;</code> </pre> <br><p>  and, for example, get a list of all instances for a certain service: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/instances"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;ServiceInstance&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> discoveryClient.getInstances(<span class="hljs-string"><span class="hljs-string">"someservice"</span></span>); }</code> </pre> <br><p>  And here we are in for the first surprise.  Our goal, after all, is not to get a list of instances, but to do a balancing between them.  And it turns out that <code>DiscoveryClient</code> not so much useful for this, because it simply doesn‚Äôt participate in the implementation of balancing.  Ok, I'm lying.  A little involved, for example, with dynamic registration of <strong>endpoint</strong> s in <strong>Zuul</strong> .  It is also used for <strong>health</strong> indicators.  But this is basically all its standard use.  Not so much truth? </p><br><h2 id="itogo">  Total </h2><br><p>  We were able to integrate with <strong>Marathon</strong> .  It's good.  We can even now get a list of services and their instances. </p><br><p>  But at the same time, we still have at least two unsolved problems.  The first is related to the fact that we have only one instance of the <strong>Marathon</strong> Wizard for connection specified in our configuration.  If he falls, then we will cease to possess information, and therefore the world. </p><br><p>  The second is that we haven‚Äôt gotten to the implementation of client balancing and in our hands so far a child‚Äôs toy, not a tool for solving problems. </p><br><h4 id="prodolzhenie-sleduet">  To be continued </h4></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325714/">https://habr.com/ru/post/325714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325700/index.html">Practical experience using this HotSwap</a></li>
<li><a href="../325704/index.html">Autopilot on your own. Part 1 - we collect the training data</a></li>
<li><a href="../325706/index.html">5 Tips for Creating Impressive Motion Graphics</a></li>
<li><a href="../325708/index.html">Some useful commands for working in terminal Linux</a></li>
<li><a href="../325710/index.html">How to set up the next generation extended protection in the corporate network</a></li>
<li><a href="../325716/index.html">Life without SDL. Winter 2017</a></li>
<li><a href="../325718/index.html">Big Data for car dealers and automakers: from idea to monetization</a></li>
<li><a href="../325720/index.html">Intel Media SDK has become an open source project.</a></li>
<li><a href="../325722/index.html">Cloud video surveillance from a webcam and router</a></li>
<li><a href="../325724/index.html">Everything in Openwork: Parallels RAS Integration into Microsoft Azure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>