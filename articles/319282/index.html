<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tail recursion optimization in Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a long time already certain things from the world of functional programming more and more penetrate into non-functional languages. It may seem str...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tail recursion optimization in Java</h1><div class="post__text post__text-html js-mediator-article">  For a long time already certain things from the world of functional programming more and more penetrate into non-functional languages.  It may seem strange that lambda expressions have been able to integrate into Java, but the tail recursion optimization (conversion of recursion into an equivalent cycle) has not yet been done, although it is much simpler.  Why is it not? <br><br>  Let's try to figure out the reasons and see what you can do with your own hands. <br><a name="habracut"></a><br>  First of all, an example.  I propose not to torment the unfortunate factorial this time and use another function: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(x ^ y, (x &amp; y) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  This is a recursive way of adding 2 integers.  It fits the definition of tail recursion: each recursive call is immediately followed by a <code>return</code> operation.  Optimization is to recursively call not to create a new stack frame, and reuse the current one.  To do this, put new parameters in place of the old ones and perform an unconditional transition to the first instruction of the method.  In pseudocode, it will look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ start: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; (x, y) = (x ^ y, (x &amp; y) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>); goto start; } }</code> </pre><br>  Further, various stylistic variations are possible, but in general, the code after manual optimization will become like this (it is possible and more beautiful, the verbosity here is only for clarity): <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x = x ^ y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _y = (x &amp; y) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; x = _x; y = _y; } }</code> </pre><br>  Immediately it becomes obvious minus the manual optimization of tail recursion: the code becomes worse, especially if there are more than one recursive call.  I'd like to optimize automatically. <br><br>  And everything would be fine, but there is one BUT: optimization breaks the semantics of program execution.  This is because in Java at any point in the code information about the call stack is available.  And if in the case of inline methods, JIT is still capable of resolving everything by itself, then when we replace the recursive call with <code>GOTO</code> we lose a lot of stack frames with information about the entry points that we should have according to the specification. <br><br>  This is unpleasant and suggests that, most likely, we will not see this optimization in Java. <br><br>  To continue the study, we accept the fact that several lines will disappear from stacktrace.  Suppose that the gain in speed (or the beauty of the code) is more important.  We define other factors that may interfere with optimization: <br><br><ul><li>  polymorphism: <br><br>  in order to implement <code>GOTO</code> , you need to know for sure that in fact the same method should be called.  This requirement is met for: <br><br>  - static methods; <br>  - private methods; <br>  - methods of <code>final</code> classes; <br>  - explicit <code>invokespecial</code> calls.  This option cannot be created by the compiler from Java source code, since <code>invokespecial</code> is only available for calling methods of the superclass. <br><br></li><li>  exceptions: <br><br>  if suddenly a recursive call occurs inside a <code>try</code> block, then we cannot just take and transfer control instructions outside this block itself.  Here is an example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldThrow)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shouldThrow) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { f(!shouldThrow); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  A call to <code>f(false)</code> should return -1, but if we make a <code>GOTO</code> in the place of a recursive call, we will get a <code>RuntimeException</code> , and this is clearly different from what should happen with the correct optimization. </li></ul><br>  There are at least 2 proven ways to modify Java class bytecodes: <br><br><ul><li>  the preprocessor is built into the compiler, the bytecode changes will go to the class files; </li><li>  <code>ClassLoader</code> - embedded in <code>ClassLoader</code> , changes will be visible only in runtime. </li></ul><br>  I chose the second option and wrote a simple Java Agent that optimizes tail recursion.  He will be able to optimize only under the above conditions: <br><ul><li>  <code>static method</code> / <code>final method</code> / <code>final class</code> ; </li><li>  recursive calls are outside <code>try</code> blocks. </li></ul><br>  For impatient link to github: <a href="https://github.com/ibessonov/java-tailrec-agent">github.com/ibessonov/java-tailrec-agent</a> . <br>  There is a customized IDEA project, in which there are examples to play with them.  And for the patient - a little explanation on the example. <br><br>  The verification of access modifiers in separate explanations does not need to be made obvious by its implementation.  Therefore, we omit it and proceed to consider the typical method and see what happens to it: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { <span class="hljs-comment"><span class="hljs-comment">// do nothing } return gcd(m, n % m); }</span></span></code> </pre><br>  After compilation, the method will look as follows (simplified for readability, some of the information is intentionally omitted): <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> gcd(II)I TRYCATCHBLOCK TryBlockStart TryBlockEnd CatchBlockStart java/lang/Throwable TryBlockStart: ILOAD <span class="hljs-number"><span class="hljs-number">1</span></span> IFNE ElseBlock ILOAD <span class="hljs-number"><span class="hljs-number">0</span></span> TryBlockEnd: IRETURN CatchBlockStart: ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//      -    ElseBlock: ILOAD 1 ILOAD 0 ILOAD 1 IREM INVOKESTATIC Main.gcd(II)I IRETURN</span></span></code> </pre><br>  Each method contains an array of <code>try</code> block descriptions.  Each description has 4 components: the start of the block, the end of the block, the exception handler, and the exception class descriptor.  This information allows us to unambiguously determine the instructions that are inside the <code>try</code> blocks, and not to optimize them. <br><br>  Next, you need to find all <code>INVOKE*</code> instructions with a method descriptor that matches the method itself (in this case, the <code>gcd(II)I</code> descriptor of the <code>Main</code> class method is searched for), immediately followed by a <code>RETURN</code> instruction. <br><br>  Found <code>INVOKESTATIC</code> must be converted from a call to an unconditional transition.  It is known that at the time of the call all the parameters are on the stack.  For static methods, everything is simple, you need to save these parameters back to local variables and make an unconditional transition to the very beginning: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> gcd(II)I TRYCATCHBLOCK TryBlockStart TryBlockEnd CatchBlockStart java/lang/Throwable StartLabel: TryBlockStart: ILOAD <span class="hljs-number"><span class="hljs-number">1</span></span> IFNE ElseBlock ILOAD <span class="hljs-number"><span class="hljs-number">0</span></span> TryBlockEnd: IRETURN CatchBlockStart: ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> ElseBlock: ILOAD <span class="hljs-number"><span class="hljs-number">1</span></span> ILOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ILOAD <span class="hljs-number"><span class="hljs-number">1</span></span> IREM ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span> ISTORE <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GOTO</span></span> StartLabel</code> </pre><br>  For non-static methods, one interesting problem arises: the method is invoked on an object, which, generally speaking, does not have to coincide with <code>this</code> .  It is technically possible to find in the bytecode the place of calculation of this object and to carry out optimization only when this calculation is equal to <code>ALOAD 0</code> . <br><br>  I acted lazily and saved the already calculated value of the required class instead of the current <code>this</code> (making <code>ASTORE 0</code> ).  Strangely enough, this approach works, but I, due to insufficient knowledge, cannot guarantee that the JIT will behave correctly in this situation.  I would like to know the answer in the comments - are there any risks here? <br><br>  In addition to simple tests, I tried to connect the agent to existing applications.  In Tomcat, there was not a single method in which to optimize.  In IntelliJ IDEA, there were at least a dozen of such methods, but the application crashed.  Given the presence of several agents and the complex logic of class loaders in IDEA, I would not dare to say what went wrong. <br><br>  As a result, a tool has been written that optimizes tail recursion in all methods, where it can be done without violating semantics (with the exception of modifying the stack of calls).  Of the obvious drawbacks can be noted the complexity of debugging.  On the other hand, debugging can always be done while the agent is off. <br><br>  Is it worth them somewhere to use - it's up to you. </div><p>Source: <a href="https://habr.com/ru/post/319282/">https://habr.com/ru/post/319282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319272/index.html">I'm cool and this is a problem</a></li>
<li><a href="../319274/index.html">How we went through the UMNIK program for receiving a grant from beginning to end with the CNC machine tool design project</a></li>
<li><a href="../319276/index.html">Programming without internet</a></li>
<li><a href="../319278/index.html">2016: a year of radical change for the CUBA platform</a></li>
<li><a href="../319280/index.html">Layout online store: list of goods</a></li>
<li><a href="../319284/index.html">How to attract a million users to the Bitcoin marketplace</a></li>
<li><a href="../319286/index.html">Virtualization with Ubuntu Server 16.04 and pHpVirtualBox 5.0.5</a></li>
<li><a href="../319288/index.html">Machine learning is easy</a></li>
<li><a href="../319290/index.html">The introduction of social services in non-game application</a></li>
<li><a href="../319294/index.html">Why did Tesla lure away the Swift language creator from Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>